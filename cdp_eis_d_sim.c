/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10001180(int a1, int a2);
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012F0(int a1, int a2);
int sub_100014D0(void); // weak
unsigned int sub_100014E0();
int __cdecl sub_10001530(int a1, int a2);
int __cdecl sub_10001550(int a1);
unsigned int sub_10001580();
int __cdecl sub_100015A0(int a1, char *a2, int a3, int a4);
char __cdecl sub_10001630(int a1, int a2, int a3);
char __cdecl sub_100016A0(int a1, int a2, int a3);
int sub_10001710();
_DWORD *__cdecl sub_10001730(int a1);
unsigned int __cdecl sub_10001750(int a1, int a2, int a3);
// void __usercall sub_100017C0(int a1@<esi>);
// char __usercall sub_10001810@<al>(int a1@<esi>);
// void __usercall sub_100018F0(int a1@<esi>, int a2);
// void __usercall sub_100019C0(int a1@<esi>, int a2);
// int __usercall sub_10001A60@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001C30(int this);
signed int __cdecl sub_10001C50(int a1, int a2);
char __cdecl sub_10001DA0(int a1, int a2, __int16 a3);
char __cdecl sub_10001DD0(int a1, int a2, __int16 a3);
char __cdecl sub_10001E00(unsigned int a1);
// int __usercall sub_10002130@<eax>(unsigned int a1@<eax>);
// void __usercall __noreturn sub_100021C0(char *a1@<edi>);
int __cdecl sub_10002400(int a1, int a2);
char __cdecl sub_10002420(int a1, unsigned int a2);
char sub_10002460();
char __thiscall sub_10002480(int this);
// void *__usercall sub_100025F0@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_100027A0(int a1);
int __cdecl sub_100027C0(int a1, int a2);
int __cdecl sub_10002840(int a1, __int16 a2, __int16 a3);
__int16 __cdecl sub_10002880(unsigned __int8 a1);
char __cdecl sub_100028A0(int (__cdecl *a1)(int));
char __cdecl sub_100028E0(int (__cdecl *a1)(int));
char __cdecl sub_10002900(int a1, __int16 *a2, _BYTE *a3);
// char __usercall sub_10002980@<al>(int a1@<ecx>, int a2@<edi>, int a3);
_WORD *__cdecl sub_10002AE0(int a1);
int __cdecl sub_10002B50(int a1);
bool __cdecl sub_10002B80(char a1);
// int __usercall sub_10002C30@<eax>(int a1@<eax>);
signed int __cdecl sub_10003AF0(int a1);
// int __usercall sub_10003EB0@<eax>(int a1@<esi>);
// char __usercall sub_10003F30@<al>(int a1@<esi>);
// char __usercall sub_10003F90@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// char __usercall sub_10004450@<al>(int a1@<edi>);
// void __usercall sub_100044F0(int a1@<eax>);
// void __usercall sub_100045A0(int a1@<eax>);
// void __usercall sub_100047D0(int a1@<eax>);
// void __usercall sub_10004C50(int a1@<eax>, float a2@<ecx>);
// char __usercall sub_10004D60@<al>(int a1@<edi>);
char __cdecl sub_100055C0(int a1);
bool __cdecl sub_100056B0(char a1);
// int __usercall sub_10005760@<eax>(int a1@<eax>);
// int __usercall sub_10006810@<eax>(int a1@<esi>);
// char __usercall sub_10006890@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// void __usercall sub_10006D30(int a1@<eax>);
// void __usercall sub_100071C0(int a1@<eax>);
// char __usercall sub_100071F0@<al>(int a1@<edi>);
char __cdecl sub_10007A50(int a1);
bool __cdecl sub_10007B40(char a1);
// int __usercall sub_10007BF0@<eax>(int a1@<eax>);
signed int __cdecl sub_10008CA0(int a1);
// int __usercall sub_10009130@<eax>(int a1@<esi>);
// char __usercall sub_10009190@<al>(int a1@<esi>);
// char __usercall sub_10009200@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// char __usercall sub_100096A0@<al>(int a1@<edi>);
// void __usercall sub_10009740(int a1@<eax>);
// void __usercall sub_10009820(int a1@<eax>);
// void __usercall sub_10009A50(int a1@<eax>);
// void __usercall sub_10009EE0(int a1@<eax>);
// char __usercall sub_10009F10@<al>(int a1@<edi>);
char __cdecl sub_1000A770(int a1);
bool __cdecl sub_1000A860(char a1);
// int __usercall sub_1000A910@<eax>(int a1@<eax>);
signed int __cdecl sub_1000BA00(int a1);
// int __usercall sub_1000BF30@<eax>(int a1@<esi>);
// char __usercall sub_1000BFB0@<al>(int a1@<esi>);
// char __usercall sub_1000BFF0@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// char __usercall sub_1000C4C0@<al>(int a1@<esi>);
// void __usercall sub_1000C550(int a1@<eax>);
void __cdecl sub_1000C600(float a1);
// void __usercall sub_1000CBC0(int a1@<eax>, float a2@<ecx>);
// void __usercall sub_1000CC60(int a1@<eax>);
// char __usercall sub_1000CC90@<al>(int a1@<edi>);
char __cdecl sub_1000D550(int a1);
bool __cdecl sub_1000D640(char a1);
// int __usercall sub_1000D6F0@<eax>(int a1@<eax>);
signed int __cdecl sub_1000E790(int a1);
// int __usercall sub_1000ECC0@<eax>(int a1@<esi>);
// char __usercall sub_1000ED40@<al>(int a1@<esi>);
// char __usercall sub_1000ED80@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// void __usercall sub_1000F250(int a1@<eax>);
void __cdecl sub_1000F330(float a1);
// void __usercall sub_1000F8F0(int a1@<eax>);
// void __usercall sub_1000F920(int a1@<eax>);
// char __usercall sub_1000F950@<al>(int a1@<edi>);
char __cdecl sub_10010210(int a1);
// int __usercall sub_10010300@<eax>(int a1@<eax>);
// int __usercall sub_10010490@<eax>(int a1@<eax>);
int __cdecl sub_100106B0(int a1);
// signed int __usercall sub_10012570@<eax>(int a1@<ebx>);
int sub_10012690();
// char __usercall sub_100126F0@<al>(int a1@<edi>);
// int __usercall sub_10012C50@<eax>(int a1@<edi>);
// char __usercall sub_10012CE0@<al>(int a1@<eax>);
// int __usercall sub_10012D70@<eax>(int a1@<eax>);
// int __usercall sub_10012DD0@<eax>(int a1@<eax>);
void __cdecl sub_10013080(int a1);
// _BYTE *__usercall sub_100133B0@<eax>(int a1@<eax>);
// void __usercall sub_10013810(int a1@<eax>);
void __cdecl sub_10013FC0(int a1);
// void __usercall sub_10014090(int a1@<eax>);
// signed int __usercall sub_10014810@<eax>(int a1@<eax>);
// void __usercall sub_10015B20(int a1@<eax>);
// int __usercall sub_10015DB0@<eax>(int a1@<eax>);
// signed int __usercall sub_100160F0@<eax>(int a1@<eax>);
// char __usercall sub_10016690@<al>(int a1@<esi>);
// int __usercall sub_100166D0@<eax>(char a1@<al>, int a2@<edi>);
// char __usercall sub_10016A90@<al>(int a1@<eax>);
// char __usercall sub_10016AF0@<al>(int a1@<eax>);
// char __usercall sub_10016BF0@<al>(int a1@<eax>);
// void __usercall sub_10016D50(float a1@<esi>, int a2);
// signed int __usercall sub_100174B0@<eax>(int a1@<edi>);
// char __usercall sub_10017F70@<al>(int a1@<esi>);
// char __usercall sub_10018050@<al>(float a1@<esi>, int a2);
int __cdecl sub_10018140(int a1);
// int __usercall sub_10019250@<eax>(int a1@<esi>);
// char __usercall sub_100192D0@<al>(int a1@<esi>);
// char __usercall sub_10019330@<al>(int a1@<edi>, __int16 a2, __int16 a3);
// void __usercall sub_100196C0(int a1@<eax>);
// void __usercall sub_100198D0(int a1@<eax>);
// char __usercall sub_100199B0@<al>(int a1@<edi>);
char __cdecl sub_10019DC0(int a1, char a2, char a3);
// int __usercall sub_10019F00@<eax>(int a1@<eax>);
// bool __usercall sub_1001A0F0@<al>(int a1@<esi>);
// char __usercall sub_1001A160@<al>(int a1@<esi>);
// char __usercall sub_1001A1C0@<al>(int a1@<ebx>, __int16 a2, __int16 a3);
// char __usercall sub_1001A660@<al>(int a1@<eax>);
// void __usercall sub_1001AF10(int a1@<eax>);
// bool __usercall sub_1001AFE0@<al>(int a1@<esi>);
char __cdecl sub_1001B2F0(int a1, char a2, char a3);
// int __usercall sub_1001B420@<eax>(int a1@<eax>);
// bool __usercall sub_1001B830@<al>(int a1@<esi>);
// char __usercall sub_1001B8B0@<al>(int a1@<esi>);
// char __usercall sub_1001B910@<al>(char a1@<dl>, int a2@<ecx>, float *a3@<esi>);
// char __usercall sub_1001B9C0@<al>(char a1@<dl>, int a2@<ecx>, float *a3@<esi>);
char __cdecl sub_1001BA70(int a1, __int16 a2, __int16 a3);
// char __usercall sub_1001C1F0@<al>(int a1@<edi>);
unsigned __int8 __cdecl sub_1001C320(int a1);
unsigned __int8 __cdecl sub_1001CBB0(int a1);
bool __cdecl sub_1001D390(int a1);
char __cdecl sub_1001D810(int a1, char a2, char a3);
// void __usercall sub_1001D950(unsigned __int8 a1@<dl>, unsigned __int8 a2@<bl>, int a3, char *a4);
// char __usercall sub_1001D9A0@<al>(int a1@<esi>);
// int __usercall sub_1001DB90@<eax>(int a1@<esi>);
// double __usercall sub_1001DC90@<st0>(int a1@<edi>, signed int a2);
// int __usercall sub_1001DD30@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3);
__int16 __cdecl sub_1001DD80(float a1);
// int __usercall sub_1001DDD0@<eax>(int a1@<esi>);
// void __usercall sub_1001E3B0(int a1@<esi>);
// char __usercall sub_1001E5E0@<al>(int a1@<esi>);
// void __usercall sub_1001EB90(int a1@<esi>);
// void __usercall sub_1001ED50(int a1@<esi>);
// char __usercall sub_1001F030@<al>(int a1@<esi>, float a2);
// int __usercall sub_1001F280@<eax>(char a1@<bl>, int a2@<esi>);
// void __usercall sub_1001F450(int a1@<esi>);
// int __usercall sub_1001F960@<eax>(int a1@<esi>);
// int __usercall sub_1001FEA0@<eax>(int a1@<esi>);
// void __usercall sub_10020070(int a1@<esi>);
// char __usercall sub_10020210@<al>(char a1@<bl>, int a2@<esi>);
// void __usercall sub_10020350(int a1@<esi>, float a2);
// signed int __usercall sub_100204F0@<eax>(int a1@<ebx>);
// char __usercall sub_10020610@<al>(int a1@<eax>, int a2@<ebx>, int a3, unsigned __int8 a4);
// int __usercall sub_100206F0@<eax>(int result@<eax>, char a2@<dl>, int a3@<ecx>, char a4);
// char __usercall sub_100207A0@<al>(int a1@<esi>);
// int __usercall sub_100207F0@<eax>(int a1@<edi>);
char __thiscall sub_10020880(int this);
char __cdecl sub_10020910(int a1);
// signed int __usercall sub_10020D70@<eax>(int a1@<esi>);
// char __usercall sub_10021150@<al>(int a1@<eax>);
// char __usercall sub_10021290@<al>(int a1@<eax>);
int __cdecl sub_10021420(int a1);
// void __usercall sub_10021520(int a1@<esi>, char a2, float a3);
// signed int __usercall sub_10021760@<eax>(int a1@<esi>);
// signed int __usercall sub_10021930@<eax>(int a1@<eax>);
// void __usercall sub_10021A00(int a1@<esi>);
// int __usercall sub_10021BE0@<eax>(int a1@<eax>);
// int __usercall sub_10021C40@<eax>(int a1@<eax>);
// int __usercall sub_10021F10@<eax>(float a1@<ecx>, int a2@<edi>);
// void __usercall sub_10022010(int a1@<edi>);
// int __usercall sub_100220F0@<eax>(int a1@<eax>);
// void __usercall sub_100224E0(int a1@<eax>, void *a2@<ecx>);
// char __usercall sub_10022630@<al>(int a1@<edi>);
void __cdecl sub_10022C70(int a1);
void __cdecl sub_100231D0(int a1);
// char __usercall sub_100232D0@<al>(int a1@<esi>);
// int __usercall sub_10023320@<eax>(void *a1@<ecx>, int a2@<esi>);
int sub_100233C0(); // weak
int sub_100233F0();
// int __usercall sub_10023410@<eax>(int a1@<eax>);
// int __usercall sub_100238E0@<eax>(int a1@<eax>);
// void __usercall sub_10024E60(int a1@<eax>);
// int __usercall sub_100250E0@<eax>(int a1@<eax>);
// int __usercall sub_10025980@<eax>(int a1@<eax>);
// char __usercall sub_10025CE0@<al>(int a1@<edi>);
// void __usercall sub_10025E20(char a1@<bl>, int a2@<esi>);
// char __usercall sub_10026250@<al>(int a1@<eax>);
// char __usercall sub_100262C0@<al>(int a1@<eax>);
// int __usercall sub_10026370@<eax>(int a1@<eax>);
// void __usercall sub_10026500(float a1@<esi>, int a2);
// char __usercall sub_10026850@<al>(int a1@<eax>);
// void __usercall sub_10026AB0(int a1@<eax>);
// char __usercall sub_10026AD0@<al>(int a1@<edi>);
// char __usercall sub_10027150@<al>(int a1@<esi>);
// void __usercall sub_10027210(int a1@<eax>);
void __cdecl sub_10027230(int a1);
// int __usercall sub_10027330@<eax>(_BYTE *a1@<ecx>, int a2@<esi>);
// signed int __usercall sub_100273B0@<eax>(char a1@<al>, int a2@<esi>, int a3, int a4);
// char __usercall sub_100274B0@<al>(int a1@<esi>, unsigned __int8 a2, char a3);
// int __usercall sub_100276E0@<eax>(int a1@<eax>, float a2, float a3, float a4, float a5);
signed int __fastcall sub_100277B0(int a1);
// int __usercall sub_10027910@<eax>(int a1@<esi>);
// BOOL __usercall sub_100279A0@<eax>(unsigned __int8 *a1@<edi>, unsigned int a2@<esi>);
// char __usercall sub_10027A30@<al>(int a1@<esi>);
// char __usercall sub_10027A70@<al>(int a1@<edi>);
// char __usercall sub_10027B90@<al>(void *a1@<edi>, int a2@<esi>, unsigned int a3);
signed int __thiscall sub_10027CA0(int this);
// void __usercall sub_10027EA0(int a1@<eax>);
// int __usercall sub_10028100@<eax>(int a1@<ecx>, int a2@<edi>);
int __thiscall sub_10028240(void *this);
// char __usercall sub_10028610@<al>(char result@<al>, int a2@<edx>, char a3@<cl>);
void __cdecl sub_100288C0(int a1);
int __cdecl sub_10028C60(int a1);
char __cdecl sub_10029620(int a1);
// int __usercall sub_100296D0@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3);
// int __usercall sub_10029710@<eax>(int a1@<eax>);
// char __usercall sub_1002B9B0@<al>(int a1@<esi>);
// char __usercall sub_1002B9F0@<al>(int a1@<edi>);
// int __usercall sub_1002BEF0@<eax>(char a1@<al>, int a2@<edi>);
// char __usercall sub_1002C200@<al>(int a1@<eax>);
// char __usercall sub_1002C270@<al>(int a1@<eax>);
// char __usercall sub_1002C310@<al>(int a1@<eax>);
char __cdecl sub_1002C410(int a1);
// char __usercall sub_1002C720@<al>(int a1@<esi>);
char __cdecl sub_1002C860(int a1);
// int __usercall sub_1002C960@<eax>(int a1@<edi>);
// double __usercall sub_1002CC10@<st0>(int a1@<edi>, signed int a2);
// int __usercall sub_1002CCA0@<eax>(int a1@<eax>);
// int __usercall sub_1002DF80@<eax>(int a1@<esi>);
// char __usercall sub_1002DFF0@<al>(int a1@<edi>);
// char __usercall sub_1002E460@<al>(int a1@<eax>);
// char __usercall sub_1002E4E0@<al>(int a1@<eax>);
// int __usercall sub_1002E550@<eax>(int a1@<eax>);
// char __usercall sub_1002E5C0@<al>(int a1@<eax>);
void __cdecl sub_1002E6E0(float a1);
// void __usercall sub_1002EA40(int a1@<eax>);
// char __usercall sub_1002ECA0@<al>(int a1@<ebx>);
// char __usercall sub_1002ED30@<al>(int a1@<esi>);
char __cdecl sub_1002F050(int a1);
// int __usercall sub_1002F140@<eax>(int a1@<esi>);
// int __usercall sub_1002F380@<eax>(void *a1@<edx>, signed int a2@<ecx>, int a3);
// int __usercall sub_1002F390@<eax>(int a1@<eax>);
// int __usercall sub_10030760@<eax>(int a1@<esi>);
// char __usercall sub_100307E0@<al>(int a1@<edi>);
// char __usercall sub_10030D10@<al>(int a1@<eax>);
// char __usercall sub_10030D90@<al>(int a1@<eax>);
// int __usercall sub_10030E20@<eax>(int a1@<eax>);
// int __usercall sub_10030EE0@<eax>(int a1@<eax>);
void __cdecl sub_10031100(int a1);
// unsigned __int8 __usercall sub_10031690@<al>(int a1@<eax>);
// void __usercall sub_100318E0(int a1@<ebx>);
char __cdecl sub_10031A20(int a1);
// char __usercall sub_10031AD0@<al>(int a1@<esi>);
void __cdecl sub_10031E80(int a1);
char __cdecl sub_10031F70(float a1, float a2, int a3);
int sub_10031FB0(void); // weak
char __cdecl sub_10031FC0(char a1);
char sub_10031FE0();
_WORD *__cdecl sub_10031FF0(int a1);
char __cdecl sub_10032090(unsigned int a1);
// _WORD *__usercall sub_100320E0@<eax>(int a1@<edi>, int a2);
char __cdecl sub_10032190(int a1);
char sub_10032210();
void __cdecl sub_10032220(unsigned int a1);
int sub_10032240(void); // weak
char __cdecl sub_10032250(int a1, unsigned __int8 a2);
int __cdecl sub_10032270(int a1, unsigned __int8 a2, char a3);
char __cdecl sub_100322C0(int a1, unsigned __int8 a2, __int16 a3);
int __cdecl sub_10032310(int a1, unsigned __int8 a2);
// char __usercall sub_100323E0@<al>(int a1@<eax>, int a2@<ecx>, char a3);
char __cdecl sub_10032470(int a1, unsigned __int8 a2);
char __cdecl sub_100324A0(int a1, unsigned __int8 a2, char a3);
// int __usercall sub_100324E0@<eax>(int a1@<eax>, char a2@<bl>, int a3);
int __cdecl sub_10032500(int a1, char a2);
int __cdecl sub_10032520(int a1);
int __cdecl sub_10032790(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5);
int sub_100330C0(void); // weak
_DWORD sub_100330F0(); // weak
// char __usercall sub_10033190@<al>(int a1@<ebx>, int a2@<esi>, int a3, _WORD *a4);
// char __usercall sub_10033340@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10033510@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// char __usercall sub_100335A0@<al>(int a1@<edx>, const void *a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_100337A0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_10033960@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_10033CF0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4);
char __cdecl sub_10034180(int a1, int a2, _WORD *a3, int a4, _WORD *a5);
// char __usercall sub_10034330@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10034500@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_10034680@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, const void *a5);
// __int16 __usercall sub_10034810@<ax>(int a1@<edi>, int a2, int a3);
// int __usercall sub_10034940@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>, _BYTE *a4);
// int __usercall sub_100349D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4);
void __cdecl sub_10034A30(int a1, int a2, int a3, int a4, float a5, float a6);
// signed int __usercall sub_10034D00@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// int __usercall sub_10034FC0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int16 *a4);
// void __usercall sub_10035360(int a1@<esi>, int a2, int a3, int a4);
char __cdecl sub_10035460(int a1, int a2, __int16 *a3, int a4, _WORD *a5);
// char __usercall sub_10035630@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
// char __usercall sub_100359D0@<al>(int a1@<eax>, int a2@<ecx>, int a3, _BYTE *a4, _WORD *a5);
// char __usercall sub_10035A60@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
char __cdecl sub_10035D60(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10035EC0@<al>(__int16 a1@<bx>, int a2, int a3, int a4, int a5, _WORD *a6);
// int __usercall sub_10036190@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// char __usercall sub_10036450@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_100366D0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5);
// int __usercall sub_10036790@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// int __usercall sub_10036A40@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall sub_10036B20@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, float a4);
// int __usercall sub_10036C30@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4);
// signed int __usercall sub_10037190@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4);
// signed int __usercall sub_10037D30@<eax>(int a1@<eax>, int a2@<esi>, int a3, __int16 *a4);
char __cdecl sub_100388E0(int a1, int a2, int *a3, int a4, _WORD *a5);
// int __usercall sub_10038B10@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// char __usercall sub_10039060@<al>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
// int __usercall sub_100391D0@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4);
char __cdecl sub_100392D0(int a1, int a2, int a3, int a4, _WORD *a5);
// __int16 __usercall sub_10039450@<ax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4);
// signed __int16 __usercall sub_100394A0@<ax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5);
// int __usercall sub_10039600@<eax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5);
// signed __int16 __usercall sub_10039810@<ax>(int a1@<eax>, int a2, int a3);
// char __usercall sub_10039860@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5);
// char __usercall sub_10039A40@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4, int a5);
// char __usercall sub_10039B10@<al>(int a1@<edx>, int a2@<ecx>, int a3, const void *a4, int a5);
// int __usercall sub_10039C90@<eax>(int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10039CE0@<eax>(int *a1@<eax>, int a2@<ecx>, int a3);
double __cdecl sub_10039D20(float a1);
signed int __cdecl sub_10039D90(int a1, int a2, int a3, int a4);
// signed int __usercall sub_1003A080@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4);
char __cdecl sub_1003A3C0(int a1, int a2, int *a3, int a4, _WORD *a5);
char __cdecl sub_1003A5A0(int a1, int a2, int a3, int *a4, _WORD *a5);
int __cdecl sub_1003A640(int a1, __int16 a2, __int16 a3, int a4);
char *__cdecl sub_1003A690(int a1, int a2, _BYTE *a3);
int __cdecl sub_1003AA80(unsigned __int8 a1, int a2, int a3);
char __cdecl sub_1003AAE0(int a1, const void *a2, int a3);
int __cdecl sub_1003ADC0(unsigned __int8 a1, int a2);
double __cdecl sub_1003AE10(int a1, int a2);
char *__cdecl sub_1003AE60(unsigned __int8 a1, _BYTE *a2);
int __cdecl sub_1003B0B0(float, float, int, int); // idb
int __cdecl sub_1003B160(float, float); // idb
void __cdecl sub_1003B1B0(int a1);
char __cdecl sub_1003B5E0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1003B7B0(unsigned int a1, char a2);
char __cdecl sub_1003B810(signed __int16 *a1, _BYTE *a2);
// __int16 __usercall sub_1003B880@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3);
// char *__usercall sub_1003B8E0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4);
// int __usercall sub_1003B9A0@<eax>(unsigned int a1@<eax>, char a2@<cl>);
// char __usercall sub_1003BA10@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3);
// char __usercall sub_1003BA80@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4);
char __cdecl sub_1003BC70(signed __int16 *a1, _BYTE *a2);
// char __usercall sub_1003BCF0@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4);
// char __usercall sub_1003C4E0@<al>(int a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4);
// char __usercall sub_1003C9E0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
char __cdecl sub_1003CAA0(int a1, int a2, int *a3, signed int *a4, int a5);
int __cdecl sub_1003D5A0(float); // idb
// int __usercall sub_1003D5C0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>);
// int __usercall sub_1003D620@<eax>(int a1@<eax>, int a2, int a3, int a4);
char __cdecl sub_1003D930(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1003DB60(int a1, int a2, int a3);
char __cdecl sub_1003DC30(int a1, int a2, int a3, float *a4);
// char __usercall sub_1003DE20@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>);
// char __usercall sub_1003DE90@<al>(int a1@<eax>, int a2@<ecx>, int a3);
char __cdecl sub_1003E150(int a1, int a2);
char __cdecl sub_1003E1B0(int a1, int a2, int *a3, float *a4, int a5);
char __cdecl sub_1003E660(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1003E7B0(unsigned int a1, char a2, int a3);
double __cdecl sub_1003E920(unsigned __int8 a1);
char __cdecl sub_1003E970(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_1003EAA0(int a1, __int16 a2);
char __cdecl sub_1003EAD0(int a1, int a2, char *a3);
int __cdecl sub_1003EB30(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_1003EC80@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_1003ED40@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_1003EDA0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_1003EF00(int a1, int a2, signed int a3);
char __cdecl sub_1003EF60(int a1, int a2, int a3, char *a4);
char __cdecl sub_1003F1C0(int a1, int a2, int a3, char *a4);
char __cdecl sub_1003F3B0(int a1, int a2, int a3, char *a4, int a5);
char __cdecl sub_1003F610(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1003F840(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_1003F920(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_1003F980(int a1, int a2, int a3, double *a4);
// char __usercall sub_1003FE80@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_1003FF60@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_10040A30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_10040AF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_10040B30(int a1, int a2, int *a3, float *a4, int a5);
// int __usercall sub_10041420@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_10041500(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_10041AB0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_10041B60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void __cdecl sub_10041C00(float a1, int a2, int a3, float a4, float a5, int a6);
char __cdecl sub_10041CA0(float a1, float a2, float a3, int a4);
char __cdecl sub_10041DB0(int a1, float a2, int a3);
int __cdecl sub_10041F10(int a1, int a2);
int __cdecl sub_10041F20(int, char, float, int); // idb
// int __usercall sub_100420E0@<eax>(int result@<eax>);
// char __usercall sub_10042100@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5);
// void __usercall sub_10042130(int a1@<esi>, int a2, _WORD *a3);
// int __usercall sub_100422C0@<eax>(int result@<eax>);
// int __usercall sub_100422E0@<eax>(int result@<eax>, int a2@<edx>);
int __cdecl sub_10042310(int, int, int, float, float, float, float, int); // idb
char __cdecl sub_100426F0(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_100427E0(int, int, int, float, float, float, float); // idb
int __cdecl sub_10042820(int, int, int, float, float, float, float); // idb
int __cdecl sub_100428D0(int, int, int, float, float, float, float); // idb
void __cdecl sub_10042980(_BYTE *a1, int a2);
int __cdecl sub_10042990(int a1, int a2);
int __cdecl sub_100429A0(int a1, char a2, float a3, int a4);
// char __usercall sub_100429B0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5);
// int __usercall sub_100429E0@<eax>(int result@<eax>);
char __cdecl sub_10042A20(int a1, int a2, int a3, int a4, _WORD *a5);
double __cdecl sub_10042B00(float a1, float a2);
double __cdecl sub_10042B20(float a1, float a2);
void __cdecl sub_10042B40(float a1, char *a2, float a3, float a4, int a5, int a6);
void __cdecl sub_10042C30(float a1, char *a2, float a3, float a4, int a5);
void __cdecl sub_10042D60(int a1, signed int a2, char a3, int a4);
int __cdecl sub_10042DB0(int a1, int a2);
// int __usercall sub_10042DF0@<eax>(int a1@<edx>, int a2@<ebx>, float a3, float a4, int a5);
// int __usercall sub_10042EF0@<eax>(int a1@<esi>, float a2, float a3, float a4, int a5);
// int __usercall sub_10043030@<eax>(int a1@<esi>);
// void __usercall sub_10043080(int a1@<esi>);
void __cdecl sub_10043770(int a1, int a2);
// void __usercall sub_10043800(int a1@<edi>, int a2);
// signed int __usercall sub_100438E0@<eax>(int a1@<ebx>);
void __cdecl sub_10043920(int a1);
// int __usercall sub_10043AC0@<eax>(int a1@<edi>, int a2@<esi>);
// void __usercall sub_10043B10(int a1@<eax>, int a2);
// int __usercall sub_10043C10@<eax>(int result@<eax>);
// void __usercall sub_10043D60(int a1@<ebx>);
// char __usercall sub_10043E30@<al>(int a1@<ebx>, int a2@<edi>, int a3, float a4);
// int __usercall sub_10044040@<eax>(int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<ebx>, unsigned __int8 a4, int a5);
int __cdecl sub_10044260(float, float, int); // idb
int __cdecl sub_10044300(float, float, float, int); // idb
char __cdecl sub_10044380(int a1, float a2, int a3);
char __cdecl sub_100443B0(int a1, float a2, int a3);
char __cdecl sub_100443D0(int a1, float a2, int a3);
int __cdecl sub_10044400(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
int __cdecl sub_10044420(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
int __cdecl sub_10044440(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
char __cdecl sub_10044460(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10044560(int a1, float a2, int a3);
int __cdecl sub_100445B0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
// char __usercall sub_100445F0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// char __usercall sub_100446E0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// char __usercall sub_10044870@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// int __usercall sub_10044AE0@<eax>(int a1@<esi>, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_10044E50(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_10044EC0(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_10044F30(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
signed int __cdecl sub_10044FA0(_BYTE *a1, int a2);
signed int __cdecl sub_10045010(int a1, signed int a2, int a3);
int __cdecl sub_10045050(int a1, int a2);
// void __usercall sub_100450B0(int a1@<ebx>, int a2);
// void __usercall sub_10045160(int a1@<esi>, int a2, int a3, int a4, _WORD *a5);
// void __usercall sub_10045260(int a1@<edi>, int a2);
// int __usercall sub_10045330@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_10045560(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10045660(int, int, int, float, float, float, float); // idb
// __int16 __usercall sub_100456A0@<ax>(int a1@<eax>, int a2@<esi>);
// const char *__usercall sub_100456E0@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3);
char __cdecl sub_100457E0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10045890(int a1, int a2, int a3, int *a4, _WORD *a5);
int __cdecl sub_10046480(float, float, int); // idb
signed int __cdecl sub_10046580(_BYTE *a1, int a2);
signed int __cdecl sub_100465F0(int a1, signed int a2, int a3);
int __cdecl sub_10046630(int a1, int a2);
// void __usercall sub_10046660(int a1@<eax>, int a2);
// int __usercall sub_10046750@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
int __cdecl sub_10046920(int, int, int, float, float, float, float); // idb
char __cdecl sub_10046960(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
void __cdecl sub_10046AD0(int a1, int a2);
// void __usercall sub_10046BA0(int a1@<esi>, int a2);
char __cdecl sub_10046CB0(int a1, int a2, int a3, int a4, _WORD *a5);
signed int __cdecl sub_10046D70(_BYTE *a1, int a2);
// int __usercall sub_10046DE0@<eax>(int a1@<eax>);
// void __usercall sub_10046E60(int a1@<edi>, int a2@<esi>);
// void __usercall sub_10046F40(int a1@<eax>, int a2@<ecx>);
int __thiscall sub_10046F50(int this);
char __cdecl sub_10047020(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10047070(int, int, int, float, float, float, float, float); // idb
char __cdecl sub_10047210(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10047850(int a1, int a2);
signed int __cdecl sub_10047AA0(_BYTE *a1, int a2);
void __cdecl sub_10047B10(int a1, signed int a2, char a3, int a4);
int __cdecl sub_10047B60(int a1, int a2);
// void __usercall sub_10047BD0(int a1@<esi>);
// void __usercall sub_10047CE0(int a1@<esi>);
void __cdecl sub_10048020(int a1, int a2);
// void __usercall sub_100480C0(int a1@<esi>, int a2);
// void __usercall sub_100481E0(int a1@<eax>, int a2);
char __cdecl sub_100482F0(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_100483D0(int, int, int, float, float, float, float, int); // idb
int __cdecl sub_10048850(int, int, int, float, float, float, float); // idb
signed int __cdecl sub_10048890(int a1);
void __cdecl sub_100488B0(float a1, char *a2, float a3, float a4, int a5);
int __cdecl sub_10048A00(float, float, int); // idb
void __cdecl sub_10048D80(int a1, float a2, float a3, int a4);
void __cdecl sub_10049040(int a1, signed int a2, char a3, int a4);
int __cdecl sub_10049090(unsigned __int8 a1, int a2);
int __cdecl sub_100490F0(int a1, int a2);
char *__cdecl sub_10049130(int a1, float a2, int a3);
void __cdecl sub_10049310(int a1, unsigned __int8 a2, char a3, int a4);
int __cdecl sub_10049630(float *a1);
// int __usercall sub_10049660@<eax>(int a1@<esi>, float a2, float a3, float a4, char a5);
// int __usercall sub_10049840@<eax>(int result@<eax>);
// void __usercall sub_10049880(int a1@<esi>, int a2);
// int __usercall sub_10049A20@<eax>(int result@<eax>);
// int __usercall sub_10049A40@<eax>(int result@<eax>, int a2@<edx>);
// void __usercall sub_10049A70(int a1@<edi>, int a2);
// void __usercall sub_10049B40(int a1@<esi>, _BYTE *a2, int a3, float a4, float a5, float a6, float a7, char a8);
// void __usercall sub_1004A000(int a1@<eax>);
void __cdecl sub_1004A1A0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8);
void __cdecl sub_1004A1E0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8);
int __cdecl sub_1004A630(float, float, float, int); // idb
int __cdecl sub_1004A660(float, float, float, int); // idb
unsigned __int8 __cdecl sub_1004A690(int a1, unsigned __int8 a2, int a3);
// void __usercall sub_1004A6F0(int a1@<esi>, int a2);
char __cdecl sub_1004A800(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1004A900(int a1, _WORD *a2, char **a3, int a4, int a5, int a6);
bool __cdecl sub_1004AA20(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_1004AB20(unsigned int a1);
char *__cdecl sub_1004AB50(unsigned int a1);
int __cdecl sub_1004AB70(unsigned int a1);
signed int __cdecl sub_1004AB90(__int16 a1);
signed int __cdecl sub_1004ABC0(int a1);
void *sub_1004ABF0();
// int __usercall sub_1004AC00@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_1004AC30@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_1004AC80@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_1004B180(_BYTE *a1, unsigned int a2);
int __cdecl sub_1004B1E0(unsigned int a1, unsigned int a2, float *a3);
int sub_1004B210();
int __cdecl sub_1004B2B0(int a1, int a2, int a3, unsigned __int8 a4);
char __cdecl sub_1004B430(int a1, const char *a2, int *a3);
int __cdecl sub_1004B470(unsigned int a1, char a2);
char __cdecl sub_1004B4D0(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_1004B6E0(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_1004B7B0(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1004B840(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
void __cdecl sub_1004BA60(int a1, int (__cdecl *a2)(int));
// unsigned int __usercall sub_1004BAA0@<eax>(unsigned int result@<eax>);
// int __usercall sub_1004BAE0@<eax>(int result@<eax>);
void __cdecl sub_1004BB10(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_1004BEC0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
char __thiscall sub_1004BEE0(void *this);
char __thiscall sub_1004BF10(void *this);
signed int sub_1004BF40();
double sub_1004BFC0();
double __fastcall sub_1004BFF0(float a1);
double sub_1004C070();
double sub_1004C0C0(void); // weak
double __fastcall sub_1004C0D0(_DWORD, _DWORD); // weak
int sub_1004C0E0();
char __cdecl sub_1004C150(char a1);
char __cdecl sub_1004C170(char a1);
int __cdecl sub_1004C190(float); // idb
int sub_1004C220();
int sub_1004C2B0();
void __cdecl sub_1004C380(int a1, unsigned __int8 a2);
double __cdecl sub_1004C3E0(unsigned __int16 a1);
void __cdecl sub_1004C410(float a1, int a2, int a3);
char __cdecl sub_1004CCA0(int a1, char a2);
double __cdecl sub_1004CF90(float a1, int a2, int a3, int a4, float a5, float a6);
char __cdecl sub_1004D100(unsigned int a1);
char __cdecl sub_1004D150(unsigned int a1);
int __cdecl sub_1004D1A0(int a1);
// signed int __usercall sub_1004D1E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __thiscall sub_1004D220(int this);
// signed int __usercall sub_1004D2D0@<eax>(int a1@<edi>);
signed int __thiscall sub_1004D360(int this);
// signed int __usercall sub_1004D400@<eax>(int a1@<esi>);
// char __usercall sub_1004D470@<al>(int a1@<eax>, char a2);
// int __usercall sub_1004D4C0@<eax>(int a1@<esi>);
// char __usercall sub_1004D4E0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_1004D5A0@<eax>(int a1@<eax>, char *a2@<esi>);
// char __usercall sub_1004D600@<al>(unsigned int a1@<ecx>, int *a2@<esi>);
// int __usercall sub_1004D6A0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>);
// __int16 __usercall sub_1004D740@<ax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1004D8B0(unsigned int a1, int a2);
void *__cdecl sub_1004DB30(unsigned int a1, char *a2);
signed int __cdecl sub_1004DB80(unsigned __int8 a1);
// signed int __usercall sub_1004DC00@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_1004DC70(unsigned __int8 a1);
// signed int __usercall sub_1004DCE0@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_1004DD60@<eax>(int a1@<eax>, char a2);
// int __usercall sub_1004DDF0@<eax>(int a1@<eax>);
char __cdecl sub_1004DE90(int a1, _BYTE *a2);
// void __usercall sub_1004DF30(int a1@<edi>, int a2, int a3);
char __cdecl sub_1004DF70(unsigned int a1);
char __cdecl sub_1004DFC0(unsigned int a1, unsigned __int8 a2, unsigned int a3);
char __cdecl sub_1004E100(unsigned int a1, char a2, int a3);
char __cdecl sub_1004E3E0(unsigned int a1);
int __cdecl sub_1004E450(__int64 a1);
int __cdecl sub_1004E500(int a1, int a2);
char __cdecl sub_1004E690(int a1, int a2);
__int16 __cdecl sub_1004E700(int a1, int a2);
double __cdecl sub_1004E740(unsigned int a1);
void __cdecl sub_1004E7F0(unsigned int a1, int a2);
unsigned __int8 __cdecl sub_1004EA60(unsigned int a1);
int __cdecl sub_1004EA90(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1004EB10(unsigned int a1);
char __cdecl sub_1004EB40(__int64 a1);
signed int __cdecl sub_1004EBE0(int a1);
char __cdecl sub_1004EDF0(signed int a1, int a2, signed int a3);
char __cdecl sub_1004EFB0(_DWORD *a1);
// signed int __usercall sub_1004F0C0@<eax>(signed int result@<eax>, char a2);
int __fastcall sub_1004F130(unsigned __int16 a1);
int __fastcall sub_1004F150(unsigned __int16 a1);
// signed int __usercall sub_1004F170@<eax>(unsigned __int16 a1@<ax>);
// char __usercall sub_1004F1E0@<al>(int a1@<ecx>, int a2@<esi>, _BYTE *a3);
// int __usercall sub_1004F240@<eax>(int a1@<eax>, _BYTE *a2@<edi>);
char __cdecl sub_1004F2A0(unsigned __int16 a1);
char __cdecl sub_1004F310(unsigned __int16 a1, _WORD *a2, __int16 *a3);
char __cdecl sub_1004F380(unsigned __int16 a1, char a2, _DWORD *a3);
char __cdecl sub_1004F490(unsigned __int16 a1, int a2, _BYTE *a3);
int __cdecl sub_1004F4F0(char, int, float, char, int); // idb
char __cdecl sub_1004F5C0(unsigned __int8 a1, int a2, char a3, int a4);
// char __usercall sub_1004F640@<al>(int a1@<eax>, unsigned __int8 a2);
// char __usercall sub_1004F6E0@<al>(int a1@<ecx>, _BYTE *a2@<edi>, int a3@<esi>, char a4);
int __fastcall sub_1004F790(int a1, int a2);
char __cdecl sub_1004F7C0(unsigned int a1, int a2, _BYTE *a3);
void __cdecl sub_1004F840(unsigned int a1, int a2);
char __cdecl sub_1004F980(unsigned int a1, int a2);
// void __usercall sub_1004FA30(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_1004FA60(unsigned int a1, int a2);
char __cdecl sub_1004FB80(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
// char __usercall sub_1004FBB0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6);
// char __usercall sub_1004FC50@<al>(int a1@<ebx>, _BYTE *a2, int *a3);
signed int __cdecl sub_1004FEA0(unsigned __int8 a1);
int __cdecl sub_1004FF00(unsigned __int16 a1, char a2, int a3);
int sub_1004FFD0();
void sub_10050030();
signed int sub_10050040();
void sub_10050050();
unsigned int __cdecl sub_10050060(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_100500D0(int, int, int, int, int, char, char *); // idb
char *__cdecl sub_10050660(unsigned __int8 a1);
signed int sub_10050720();
int sub_10050740();
int sub_100507A0();
char *sub_10050810();
int __cdecl sub_100508E0(const void *a1);
int sub_10050990();
char __cdecl sub_10050A30(float *a1);
char __cdecl sub_10050CF0(int a1, float *a2);
int __cdecl sub_10050D10(int, int, __int16, int, float); // idb
void __cdecl sub_10050D50(unsigned int a1, int a2);
char __cdecl sub_10050F30(unsigned int a1, int a2);
signed int __cdecl sub_10050FA0(unsigned __int8 a1);
char __cdecl sub_10050FE0(unsigned __int8 a1);
signed int __cdecl sub_10051020(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_10051080(unsigned __int8 a1);
char __cdecl sub_100510C0(int a1);
char __cdecl sub_10051100(int a1);
char __cdecl sub_10051140(int a1);
char __cdecl sub_10051180(int a1);
char __cdecl sub_100511C0(int a1);
char __cdecl sub_10051200(unsigned __int8 a1);
char __cdecl sub_10051240(unsigned __int8 a1);
char __cdecl sub_10051280(unsigned __int8 a1);
char __cdecl sub_100512C0(unsigned __int8 a1);
char __cdecl sub_10051300(unsigned __int8 a1);
int __cdecl sub_10051340(unsigned __int8 a1);
int __cdecl sub_10051380(_BYTE *a1, _BYTE *a2);
int sub_100513B0();
int __fastcall sub_100513C0(unsigned __int8 a1);
int __fastcall sub_100513E0(unsigned __int8 a1);
void *__cdecl sub_10051400(char a1, void *a2);
int __cdecl sub_100514D0(int a1);
char sub_10051690();
_DWORD __cdecl sub_100517F0(_DWORD, _DWORD); // weak
char *__cdecl sub_10051800(int a1, char *a2, int a3, char *a4, int a5);
char sub_10051930();
char __cdecl sub_10051940(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10051A40(char *a1, int a2, char a3, char *a4);
int sub_10051AB0();
char __cdecl sub_10051AE0(void *a1);
char __cdecl sub_10051B40(void *a1);
char __cdecl sub_10051BA0(float *a1);
char __cdecl sub_10051BD0(char *a1);
double sub_10051C00(void); // weak
char __thiscall sub_10051C20(void *this);
char __thiscall sub_10051C50(void *this);
char __fastcall sub_10051C80(int a1);
char __thiscall sub_10051CF0(void *this);
char __fastcall sub_10051D20(int a1);
char sub_10051D70();
BOOL __thiscall sub_10051D80(void *this);
int __thiscall sub_10051DA0(void *this);
char __thiscall sub_10051EF0(void *this);
char __thiscall sub_10051F20(void *this);
char __fastcall sub_10051F50(int a1);
char __thiscall sub_10051FA0(void *this);
char __thiscall sub_10051FD0(void *this);
int sub_10052000();
char __thiscall sub_10052030(void *this);
char __fastcall sub_10052060(int a1);
char __cdecl sub_100520B0(int a1);
int __cdecl sub_100520D0(int, char *); // idb
char __thiscall sub_10052130(void *this);
char __thiscall sub_10052150(void *this);
char __thiscall sub_10052170(void *this);
int __thiscall sub_10052190(void *this);
int __thiscall sub_100521B0(void *this);
char __thiscall sub_100521D0(void *this);
int __thiscall sub_100521F0(void *this);
char __thiscall sub_10052210(void *this);
char __thiscall sub_10052230(void *this);
char sub_10052250();
BOOL sub_10052270();
int __cdecl sub_10052290(char a1);
int __cdecl sub_100522A0(char a1);
int __cdecl sub_100522B0(char a1);
int __cdecl sub_100522C0(char a1);
int __cdecl sub_100522D0(char *, char *); // idb
// void *__usercall sub_10052310@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10052360();
char __cdecl sub_10054160(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_100543D0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// int __usercall sub_100543F0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_10054440(int a1, int a2, int a3, int a4, _WORD *a5);
__int16 __cdecl sub_100544C0(char a1);
// _BYTE *__usercall sub_100544F0@<eax>(int a1@<edi>, int a2@<esi>);
char __cdecl sub_100545E0(int a1, int a2, int a3, int a4, _WORD *a5);
// int __usercall sub_10054760@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_10054C30(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10054C60(int a1, int a2, int a3, int a4, _WORD *a5);
// BOOL __usercall sub_10054EE0@<eax>(int a1@<ecx>, int a2@<esi>);
// int __usercall sub_10054F20@<eax>(int result@<eax>);
// int __usercall sub_10055020@<eax>(int result@<eax>);
int __cdecl sub_10055120(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_10055E70@<eax>(int a1@<ebx>, int a2@<edi>, int *a3);
// int __usercall sub_10056FD0@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, _DWORD *a8);
// int __usercall sub_10057450@<eax>(int a1@<ebx>, int a2, float a3, float a4, float a5, float a6, float a7, int *a8, int a9);
// int __usercall sub_10057680@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, int a7);
// unsigned __int8 __usercall sub_10057920@<al>(int a1@<ebx>, _DWORD *a2@<edi>, int a3, int a4, int a5, float a6, float a7, float a8, float a9);
// bool __usercall sub_10057BC0@<al>(int a1@<esi>);
// double __usercall sub_10057CB0@<st0>(int a1@<eax>, float a2@<ecx>);
// int __usercall sub_10057D00@<eax>(int a1@<edx>, float *a2@<ecx>, int a3@<ebx>, float a4, int a5);
// char __usercall sub_10057DB0@<al>(int a1@<eax>, int a2@<ecx>);
// signed int __usercall sub_10057EB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>);
// unsigned int __usercall sub_10058000@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>);
// void __usercall sub_10058040(void *a1@<ecx>, int a2@<esi>);
// unsigned int __usercall sub_10058170@<eax>(int a1@<eax>, int a2@<ebx>);
int *__cdecl sub_100581D0(int a1, int *a2);
// int __usercall sub_10058770@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, float *a4@<edi>, int a5, int a6, _DWORD *a7);
// char __usercall sub_100587D0@<al>(int a1@<eax>, int a2);
unsigned int __cdecl sub_1005EE70(int a1);
// char __usercall sub_1005F7C0@<al>(int a1@<ebx>, int a2);
char __cdecl sub_10060680(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10060760(unsigned __int16 a1);
char __cdecl sub_10060770(int a1, int a2, int a3, int a4, __int16 *a5);
char __cdecl sub_10060DD0(int a1, int a2, int *a3, int a4, int a5);
void __cdecl sub_10060E40(_BYTE *a1, int a2);
int __cdecl sub_10060F20(int a1, char a2, int a3);
int __cdecl sub_10060F50(float, float, float, float, int); // idb
int __cdecl sub_10060F80(int a1, int a2);
int __cdecl sub_10060FA0(float, char *, float, float, float, int, int); // idb
int __cdecl sub_10061190(float, float, float, int, int); // idb
int __cdecl sub_100612A0(int, char, float, int); // idb
// int __usercall sub_100614E0@<eax>(int result@<eax>);
// void __usercall sub_100615F0(int a1@<esi>);
// void __usercall sub_100617A0(int a1@<esi>);
// int __usercall sub_10061950@<eax>(int result@<eax>, int a2@<edx>);
// void __usercall sub_10061980(int a1@<edi>, int a2);
int __thiscall sub_10061A10(int this);
// void __usercall sub_10061A60(int a1@<esi>);
int __cdecl sub_10061B00(int, int, int, float, float, float, float); // idb
int __cdecl sub_10061E10(int, int, int, float, float, float, float); // idb
void __cdecl sub_10061F10(float a1, char *a2, float a3, float a4, float a5, int a6);
int __cdecl sub_10061FA0(float, float, int, int); // idb
// void __usercall sub_10061FD0(int a1@<esi>, int a2);
char __cdecl sub_10062070(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10062160(float, float, float, int); // idb
void __cdecl sub_10062280(float a1, int a2, int a3);
unsigned __int8 __cdecl sub_10062420(char a1, int a2);
// char __usercall sub_10062560@<al>(int a1@<eax>);
char sub_10062580();
// char __usercall sub_100627C0@<al>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, int a5);
char __cdecl sub_10063AB0(int a1, int a2, _WORD *a3, int a4, _WORD *a5);
_DWORD *__cdecl sub_10063B70(_DWORD *a1);
int __cdecl sub_10063B80(int *a1, int a2);
_DWORD *__cdecl sub_10063BB0(_DWORD *a1, int a2);
char __cdecl sub_10063BC0(int a1, int a2, int a3);
char __cdecl sub_10063BF0(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_10063C20(unsigned int a1);
bool __cdecl sub_10063C40(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_10063C90(int a1, char *a2);
int __cdecl sub_10063CF0(int a1, int a2, char *a3, int a4);
char __cdecl sub_10063D60(int a1, char *a2, int a3);
int __cdecl sub_10063E10(int a1);
char __cdecl sub_10063E90(char a1);
char __cdecl sub_10063ED0(char a1);
signed int __cdecl sub_10063F40(char a1);
char __cdecl sub_10063FC0(char a1);
char __cdecl sub_10064030(char a1);
char __cdecl sub_100640E0(int a1);
char __thiscall sub_100641E0(void *this);
int __cdecl sub_100641F0(int *a1);
// char __usercall sub_10064220@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_100642C0(const char *a1);
char __cdecl sub_10064300(void *a1);
signed int __cdecl sub_10064350(unsigned int a1, int a2);
char **sub_100646F0();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10064710(int a1);
int __cdecl sub_10064720(int a1);
char __cdecl sub_10064730(char a1, unsigned __int16 a2, char a3);
bool __cdecl sub_10064760(float a1, int a2, int a3, int a4);
bool __cdecl sub_100648D0(signed int a1, signed int a2, _BYTE *a3);
void __cdecl sub_10064940(const char *a1, unsigned int a2, int a3);
void __cdecl sub_10064990(const char *a1, char a2, char a3);
int __cdecl sub_100649E0(int a1, _BYTE *a2, int a3);
int __cdecl sub_10064A30(void *, size_t); // idb
int __cdecl sub_10064A60(int, char *, int); // idb
int __cdecl sub_10064AC0(char *, size_t, char *, va_list); // idb
int sub_10064B00(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_10064B30(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_10064B70(int a1, int a2);
signed int __cdecl sub_10064B90(int (__cdecl *a1)(int));
char *__cdecl sub_10064BC0(unsigned __int8 a1);
int __cdecl sub_10064BF0(int, float, float, float, float, int); // idb
int __cdecl sub_10064CF0(unsigned int a1, int a2);
int __cdecl sub_10064E50(int a1, int a2);
void __cdecl sub_10064F60(float a1, char *a2, float a3, float a4, int a5, int a6, int a7);
int __cdecl sub_10065060(float); // idb
int __cdecl sub_100650F0(float); // idb
double __cdecl sub_10065120(float a1, int a2, int a3);
int __cdecl sub_10065280(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_100653C0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_10065400(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4);
void *sub_10065550();
// int __usercall sub_10065560@<eax>(int a1@<edi>, int a2@<esi>, char a3);
void __cdecl sub_10065630(int a1, int a2, int a3);
int __cdecl sub_10065650(int a1, int a2);
int __cdecl sub_10065670(int a1, int a2);
void __cdecl sub_10065690(float a1, float a2, float a3, int a4, int a5, int a6);
int __cdecl sub_10065750(unsigned __int8 a1);
void __cdecl sub_10065780(float a1, float a2, float a3, float a4, char a5);
void __cdecl sub_100659D0(float a1, float a2, float a3, float a4, float a5, float a6, char a7);
// int __usercall sub_10065A50@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_10065B30(int a1, int a2, int a3);
int __cdecl sub_10065B50(int a1, int a2, int a3);
int __cdecl sub_10065B70(int a1, int a2, int a3);
_BYTE *__cdecl sub_10065BE0(int a1, int a2, char a3);
int __cdecl sub_10065C10(char a1);
char __cdecl sub_10065C60(int a1, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_10065CD0(char a1);
signed int __cdecl sub_10065D00(signed int a1);
bool __cdecl sub_10065D40(char a1, _BYTE *a2);
int __cdecl sub_10065DC0(char a1);
int __cdecl sub_10065E00(char a1);
double sub_10065E40();
// void __usercall sub_10065E70(int a1@<esi>, int a2, float a3);
// char __usercall sub_10065FE0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_100660D0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_100663B0(float *a1);
void __cdecl sub_100663C0(int a1);
char __cdecl sub_100663D0(float *a1);
char __cdecl sub_100663F0(float *a1);
char __cdecl sub_10066410(float *a1);
char __cdecl sub_100664A0(float *a1);
char __cdecl sub_10066510(float *a1);
double sub_10066580();
double __cdecl sub_100665E0(float a1, float a2, int a3, float a4);
int __cdecl sub_100666C0(int a1, int a2);
int __cdecl sub_10066720(int a1, int a2);
int __cdecl sub_10066730(int, int, float, float); // idb
char __cdecl sub_10066790(unsigned __int16 a1, float *a2);
void sub_100668B0();
double __cdecl sub_100668C0(float a1);
signed int sub_10066920();
// char __usercall sub_10066930@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10066E70(unsigned __int8 a1, _DWORD *a2);
char __cdecl sub_10066EE0(int a1, unsigned __int8 a2, unsigned __int8 a3);
bool __cdecl sub_10066F80(unsigned __int16 a1, _BYTE *a2, unsigned __int8 a3);
bool __cdecl sub_10067000(unsigned __int16 a1, _BYTE *a2);
int __cdecl sub_10067030(int a1);
int __cdecl sub_100671C0(int a1);
int __cdecl sub_100674D0(int a1);
int __cdecl sub_10067650(float, float, float, float, char, int); // idb
int __cdecl sub_10067700(int a1);
int __cdecl sub_10067A90(float, float, float, float, int, int); // idb
int __cdecl sub_10067C30(float, float, float, float, float, float, int); // idb
int __cdecl sub_10067EE0(float, float, float, float, int); // idb
int __cdecl sub_10067FF0(float, float, float, float, int, float); // idb
int __cdecl sub_100680A0(int a1);
int __cdecl sub_100682A0(float, float, float, float, int, float); // idb
int __cdecl sub_10068320(float, float, float, float, int, float, int); // idb
int __cdecl sub_10068550(float, float, float, float, float, int, int); // idb
int __cdecl sub_100689C0(float, float, float, int); // idb
int __cdecl sub_10068A50(int, int, int, float); // idb
char __cdecl sub_10068AE0(int a1, int a2, unsigned __int16 a3, int a4, char a5);
int __cdecl sub_10068CB0(float, float, float, int); // idb
int __cdecl sub_100690D0(float, float, float, float, int); // idb
int __cdecl sub_10069290(int a1);
int __cdecl sub_10069340(int a1, int a2, unsigned __int16 a3, int a4, char a5);
int __cdecl sub_10069450(float, float, float, float, float, int, int); // idb
int __cdecl sub_100698D0(int a1);
int __cdecl sub_10069BD0(int a1);
int __cdecl sub_10069C80(int a1, int a2, unsigned __int8 a3, char a4);
int __cdecl sub_10069E40(float, float, float, float, float, int, int); // idb
void __cdecl sub_1006A190(int a1);
void __cdecl sub_1006A400(int a1);
// int __usercall sub_1006A440@<eax>(char a1@<al>, int a2@<ecx>, char a3);
// void __usercall sub_1006A770(int a1@<ebx>, int a2@<esi>, char a3);
// int __usercall sub_1006A810@<eax>(int a1@<esi>, float a2, float a3, float a4, float a5, float a6);
// void __usercall sub_1006A990(int *a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8);
int __cdecl sub_1006AA90(int a1, char a2);
int __cdecl sub_1006AAB0(int a1);
void __cdecl sub_1006BEC0(int a1, int a2);
int __cdecl sub_1006BEE0(int, float, float, float, float); // idb
int __cdecl sub_1006BF20(int, float, float, float, float); // idb
int __cdecl sub_1006BF60(int a1, char a2);
void __cdecl sub_1006BF80(float a1, float a2, float a3, float a4, float a5, int a6, int a7);
// void __usercall sub_1006BFD0(int a1@<edx>, int a2@<ecx>, char a3);
void __cdecl sub_1006C050(int a1, int a2);
void __cdecl sub_1006C070(int a1, int a2);
void __cdecl sub_1006C090(int a1, int a2);
char __thiscall sub_1006C1B0(void *this);
char __cdecl sub_1006C240(int a1, char a2);
char __cdecl sub_1006C300(int a1, char a2);
char __cdecl sub_1006C3C0(char a1);
char __cdecl sub_1006C3F0(char a1);
char __cdecl sub_1006C420(unsigned __int16 a1);
char __cdecl sub_1006C4C0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1006C5D0(char a1);
bool __cdecl sub_1006C620(char a1);
int __cdecl sub_1006C650(unsigned __int8 a1);
int __cdecl sub_1006C660(unsigned int a1, float *a2);
char *__cdecl sub_1006C690(unsigned int a1, float *a2);
int __cdecl sub_1006C6B0(double, double); // idb
void sub_1006C700();
signed int sub_1006C710();
// char __usercall sub_1006C720@<al>(float *a1@<esi>);
signed int sub_1006C790();
bool __cdecl sub_1006C7C0(char a1, int a2);
char __cdecl sub_1006C9E0(float *a1);
bool __cdecl sub_1006CA40(float *a1);
char __cdecl sub_1006CAA0(unsigned __int16 a1, int a2, char a3);
char __cdecl sub_1006CCA0(char a1);
char __cdecl sub_1006CCC0(unsigned int a1, float *a2);
double __cdecl sub_1006D0E0(int a1, unsigned __int16 a2, char a3, char *a4);
double __cdecl sub_1006D4B0(int a1, unsigned int a2);
double __cdecl sub_1006DAE0(int a1, unsigned int a2);
char __cdecl sub_1006E1D0(float a1, int a2, char a3, int a4);
void __cdecl sub_1006E2C0(char a1, _DWORD *a2, _DWORD *a3, char a4);
char __cdecl sub_1006E300(char a1, _DWORD *a2, int *a3, char a4, int a5);
char __cdecl sub_1006E390(char a1, _DWORD *a2, int *a3, char a4, int a5);
int __cdecl sub_1006E420(int a1);
int __cdecl sub_1006E440(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1006E5D0(unsigned __int8 a1);
bool __thiscall sub_1006E630(void *this);
int __cdecl sub_1006E640(int *a1, int a2);
unsigned int __cdecl sub_1006E660(signed int *a1, int a2);
char __cdecl sub_1006E6D0(int a1);
int __cdecl sub_1006E710(unsigned __int8 a1);
char __cdecl sub_1006E750(int a1);
// char __usercall sub_1006E790@<al>(char result@<al>, char *a2@<esi>);
// int __usercall sub_1006E7B0@<eax>(unsigned __int8 a1@<al>, int a2@<ecx>, _DWORD *a3@<esi>, int a4);
// int __usercall sub_1006E800@<eax>(unsigned __int8 a1@<al>, int a2@<ecx>, int a3, unsigned __int8 a4);
// BOOL __usercall sub_1006E840@<eax>(unsigned __int8 a1@<al>, unsigned __int8 a2@<cl>);
// bool __usercall sub_1006E860@<al>(unsigned __int8 a1@<al>, int a2@<ecx>, int a3);
char __cdecl sub_1006E8A0(int a1, _DWORD *a2, unsigned __int8 a3);
int __cdecl sub_1006E910(int a1, unsigned __int8 a2, unsigned __int8 a3);
bool __cdecl sub_1006E980(int a1, unsigned __int8 a2);
char __cdecl sub_1006E9E0(int a1);
char __cdecl sub_1006EA30(char a1);
BOOL sub_1006EAB0();
char __cdecl sub_1006EAF0(unsigned __int8 a1);
void sub_1006EB90();
signed int __cdecl sub_1006EBA0(_DWORD *a1);
char __cdecl sub_1006EBC0(char a1);
bool __cdecl sub_1006EC00(unsigned __int8 a1, char a2);
char __cdecl sub_1006EC70(float a1);
unsigned __int8 __cdecl sub_1006ECC0(unsigned __int8 a1, _BYTE *a2);
int __cdecl sub_1006ECF0(unsigned __int16 a1);
char *__cdecl sub_1006ED10(unsigned __int16 a1);
// void *__usercall sub_1006ED50@<eax>(int a1@<eax>, unsigned __int16 a2@<di>, void *a3@<esi>);
void *sub_1006ED80();
char __thiscall sub_1006F390(void *this);
int __thiscall sub_1006F3C0(void *this);
bool __cdecl sub_1006F3E0(char a1);
BOOL __fastcall sub_1006F450(int a1);
bool __thiscall sub_1006F480(void *this);
__int16 __cdecl sub_1006F4C0(int a1, int a2, int a3);
char __cdecl sub_1006F4F0(int a1, int a2, int a3, int a4);
char __cdecl sub_1006F520(int a1);
char __thiscall sub_1006F590(void *this);
// char __usercall sub_1006F600@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1006F640@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1006F6E0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1006F720(char a1, char a2, void *a3);
char __cdecl sub_1006F780(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1006F7C0(char a1, char a2, void *a3);
char __cdecl sub_1006F7F0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1006F830(char a1, char a2, void *a3);
char __cdecl sub_1006F870(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1006F8B0(char a1, char a2, void *a3);
char __cdecl sub_1006F900(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1006F940(char a1, char a2, void *a3);
char __cdecl sub_1006F980(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1006F9C0(char a1, char a2, void *a3);
char __cdecl sub_1006FA00(char a1, void *a2);
char __cdecl sub_1006FA30(char a1, void *a2);
char __cdecl sub_1006FA60(char a1, void *a2);
char __cdecl sub_1006FA90(char a1, void *a2);
char __cdecl sub_1006FAC0(char a1, void *a2);
char __cdecl sub_1006FAF0(char a1, void *a2);
char __cdecl sub_1006FB20(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1006FB60(char a1, char a2, void *a3);
char __cdecl sub_1006FBB0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1006FBF0(char a1, char a2, void *a3);
char __cdecl sub_1006FC20(char a1, void *a2);
char __cdecl sub_1006FC50(char a1, void *a2);
char __cdecl sub_1006FC80(char a1, void *a2);
char __cdecl sub_1006FCB0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10070050(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100700C0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10070120(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10070190(char a1, _BYTE *a2);
char __thiscall sub_100701D0(void *this);
char __cdecl sub_10070240(char a1, int a2);
char __cdecl sub_10070270(char a1, int a2);
char __cdecl sub_100702A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl nullsub_1(_DWORD, _DWORD);
char *__cdecl sub_10070480(char **a1);
int sub_100704D0();
int __cdecl sub_10070510(_BYTE *a1, int a2);
signed int __cdecl sub_10070580(_BYTE *a1, int a2);
// int __usercall sub_10070620@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10070650@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10070820@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10070880@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10070910@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10070960@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_100709C0@<eax>(int a1@<eax>);
// int __usercall sub_100709E0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10070A20@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10070AB0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10070C00@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10070CA0@<eax>(int result@<eax>);
char *__cdecl sub_10070CE0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10070E90@<eax>(int a1@<eax>);
// int __usercall sub_10070EC0@<eax>(int a1@<esi>);
void __cdecl sub_10070EF0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10071360();
void *sub_100713B0();
char *sub_10071410();
char sub_10071430();
char __cdecl sub_10071440(int a1, int a2, unsigned int a3);
// int *__usercall sub_10071480@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_100714D0();
int __cdecl sub_100714E0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10071590(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_100717A0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10071860(char a1);
int *__cdecl sub_10071900(_BYTE *a1);
// int __usercall sub_100719C0@<eax>(int a1@<eax>);
// signed int __usercall sub_10071B20@<eax>(int a1@<esi>);
int __cdecl sub_10071B90(int, int); // weak
char **sub_10071E70();
// int __usercall sub_10071E80@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10071F70(char *a1);
int sub_100721B0();
int __cdecl sub_10072290(int a1, int a2, char a3);
_DWORD *sub_100722E0();
int sub_100722F0();
void sub_10072310();
signed int sub_10072320();
int sub_10072330();
char sub_10072360();
void sub_10072400();
int __cdecl sub_10072410(char a1);
signed int sub_10072430();
// signed int __usercall sub_10072480@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10072520@<eax>(char a1@<al>);
// int __usercall sub_10072540@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10072560@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_100727A0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10072900(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10072A80(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10072BE0(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10072D20(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10072E00(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10073080(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_100730B0(char a1, int a2, void *a3);
char __cdecl sub_100730E0(char a1, int a2, void *a3, int a4);
char __thiscall sub_10073110(void *this);
char sub_10073130();
double __cdecl sub_10073170(char a1);
double sub_100731F0(void); // weak
void sub_10073200();
char __cdecl sub_10073210(unsigned __int8 a1);
signed int sub_10073270();
// char __usercall sub_10073280@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10073360(int a1, char a2, void *a3);
char __cdecl sub_100733E0(int a1, void *a2);
int __cdecl sub_10073400(int a1, int a2);
BOOL __cdecl sub_10073410(unsigned int a1);
char __thiscall sub_10073480(void *this);
void __cdecl sub_100734A0(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_100734D0(int a1);
signed int sub_100734F0();
void __cdecl sub_10073520(_BYTE *a1);
char __cdecl sub_10073540(int a1, size_t a2, void *a3);
int __cdecl sub_10073580(int a1);
char __fastcall sub_100735A0(int *a1);
char sub_100737C0();
signed int sub_100737E0();
int sub_10073810();
int __cdecl sub_10073820(int a1, unsigned int a2);
__int16 __cdecl sub_10073910(int a1, unsigned int a2);
int __cdecl sub_10073960(int *a1, unsigned int a2);
__int16 __cdecl sub_10073990(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10073A10(_BYTE *a1);
char __cdecl sub_10073A40(_BYTE *a1, _BYTE *a2);
char __cdecl sub_10073A90(_BYTE *a1, _BYTE *a2);
int sub_10073AE0();
__int16 sub_10073BB0();
// int __usercall sub_10073C10@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_10073C90(int a1);
unsigned __int8 sub_10073D80();
char sub_10073E50();
int (__cdecl *(*sub_10074010())[2])(int, int);
// int __usercall sub_10074140@<eax>(const char *a1@<eax>, int a2@<ecx>);
int __cdecl sub_100741C0(float, float, int, int, int, float, char); // idb
signed int __cdecl sub_10074360(int a1);
double __cdecl sub_10074380(signed int a1, char a2);
void __cdecl sub_100743C0(_BYTE *a1, signed int a2, int a3);
char __cdecl sub_10074460(int a1, char a2, int a3, _DWORD *a4, int a5);
bool __cdecl sub_100746A0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_100746E0(unsigned __int16 a1);
bool __cdecl sub_10074710(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10074750(int a1);
signed int __cdecl sub_10074850(int a1, int a2);
int __cdecl sub_100748F0(int a1, signed int a2, signed int a3);
double __cdecl sub_10074910(_DWORD); // weak
bool sub_10074920();
bool sub_10074930();
char __cdecl sub_10074950(int a1, int a2);
char __cdecl sub_10074A70(int a1);
char __cdecl sub_10074A80(unsigned __int16 a1);
unsigned int __cdecl sub_10074BD0(char *a1);
int __cdecl sub_10074BF0(_BYTE *a1);
int __cdecl sub_10074C10(unsigned __int8 *a1);
unsigned int __cdecl sub_10074C30(int a1, int a2);
unsigned int __cdecl sub_10074F60(int a1, int a2);
unsigned int __cdecl sub_100753A0(_BYTE *a1);
int __cdecl sub_100753C0(unsigned __int8 *a1);
int __cdecl sub_100753E0(unsigned __int8 *a1);
int __cdecl sub_10075400(_BYTE *a1);
int __cdecl sub_10075420(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_10075470(unsigned __int8 *a1);
int __cdecl sub_10075490(int a1);
unsigned int __cdecl sub_10075520(int a1);
signed int __cdecl sub_10075540(int a1);
unsigned int __cdecl sub_10075590(int a1);
int __cdecl sub_100755F0(_BYTE *a1);
unsigned int __cdecl sub_10075610(_BYTE *a1);
int __cdecl sub_10075630(unsigned __int8 *a1);
int __cdecl sub_10075650(_BYTE *a1);
signed int __cdecl sub_10075670(_BYTE *a1, int a2);
int __cdecl sub_100756A0(_BYTE *a1, int a2);
int __cdecl sub_100756E0(int a1, int a2);
int __cdecl sub_10075770(unsigned __int8 *a1);
int __cdecl sub_10075790(int a1);
int __cdecl sub_100757C0(unsigned __int8 *a1);
unsigned int __cdecl sub_100757E0(int a1);
int __cdecl sub_10075810(int a1);
int __cdecl sub_10075900(int a1);
signed int __cdecl sub_10075A10(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10075A40(_BYTE *a1, int a2);
int __cdecl sub_10075A70(int a1);
int __cdecl sub_10075AA0(unsigned __int8 *a1);
int __cdecl sub_10075B00(int a1);
signed int __cdecl sub_10075B10(_BYTE *a1, int a2);
int __cdecl sub_10075B40(int a1, int a2);
_DWORD __cdecl sub_10075BC0(_DWORD); // weak
int __cdecl sub_10075BD0(int a1);
unsigned int __cdecl sub_10075C50(int a1);
unsigned int __cdecl sub_10075C90(int a1);
int __cdecl sub_10075CE0(int a1);
int __cdecl sub_10075D10(int a1);
unsigned int __cdecl sub_10075D40(int a1);
unsigned int __cdecl sub_10075D70(int a1);
unsigned int __cdecl sub_10075D90(int a1);
void __cdecl __noreturn sub_10075DD0(int a1);
signed int __cdecl sub_10075F40(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10075FA0@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10076070(int a1);
char __cdecl sub_10076080(char a1);
signed int __cdecl sub_100760C0(char a1);
int __cdecl sub_10076100(char *a1, char a2);
bool __cdecl sub_10076170(int a1, void *a2);
char __cdecl sub_10076230(int a1, bool *a2);
char __cdecl sub_100762F0(char a1);
char __thiscall sub_10076320(void *this);
char __cdecl sub_10076330(char a1, void *a2);
char __cdecl sub_100763E0(char a1);
int __cdecl sub_10076440(char a1);
// unsigned int __usercall sub_10076450@<eax>(int a1@<eax>);
char __cdecl sub_10076690(int a1, int a2, int a3, int a4, __int16 *a5);
int __cdecl sub_10076770(_BYTE *a1);
int __cdecl sub_10076790(unsigned __int8 *a1);
int __cdecl sub_100767B0(unsigned __int8 *a1);
int __cdecl sub_100767D0(unsigned __int8 *a1);
int __cdecl sub_100767F0(unsigned __int8 *a1);
_DWORD __cdecl sub_10076810(_DWORD); // weak
int __cdecl sub_10076820(int a1);
int __cdecl sub_10076860(int a1);
signed int __fastcall sub_10076880(unsigned __int8 a1);
char __cdecl sub_10076890(unsigned __int8 a1);
__int16 __cdecl sub_100768B0(unsigned __int8 a1);
int __cdecl sub_100768D0(int a1);
int __cdecl sub_100768E0(void *); // idb
int __cdecl sub_10076960(int a1, int a2);
signed int __cdecl sub_10076990(int a1, int a2, int a3);
char __cdecl sub_100769B0(_DWORD *a1);
char __cdecl sub_10076AC0(int a1, unsigned int a2);
bool __cdecl sub_10076AF0(const void **a1, int a2);
bool __cdecl sub_10076B20(const void **a1, int a2);
bool __cdecl sub_10076B50(const void **a1, int a2);
bool __cdecl sub_10076B80(const void **a1, int a2);
bool __cdecl sub_10076BB0(const void **a1, int a2);
bool __cdecl sub_10076BE0(int a1, int a2);
bool __cdecl sub_10076C20(int a1, int a2);
bool __cdecl sub_10076C60(const void **a1, int a2);
bool __cdecl sub_10076C90(const void **a1, int a2);
char __cdecl sub_10076CC0(int a1, unsigned int a2);
bool __cdecl sub_10076CF0(const void **a1, int a2);
bool __cdecl sub_10076D20(const void **a1, int a2);
bool __cdecl sub_10076D50(const void **a1, int a2);
bool __cdecl sub_10076D80(const void **a1, int a2);
bool __cdecl sub_10076DB0(const void **a1, int a2);
bool __cdecl sub_10076DE0(const void **a1, int a2);
bool __cdecl sub_10076E10(const void **a1, int a2);
bool __cdecl sub_10076E40(const void **a1, int a2);
bool __cdecl sub_10076E70(const void **a1, int a2);
bool __cdecl sub_10076EA0(const void **a1, int a2);
int __cdecl sub_10076ED0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10076F40(int a1, char a2);
int __cdecl sub_10076F60(int a1, int a2, int a3);
int __cdecl sub_10076F90(int a1, int a2, int a3, int a4);
int __cdecl sub_10076FC0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10077000(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10077040(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10077090(int a1);
char __cdecl sub_100770C0(int a1);
char __cdecl sub_100770D0(int a1, int a2);
signed int __cdecl sub_10077250(int a1);
signed int __cdecl sub_10077290(int a1, int a2, int a3);
char __cdecl sub_10077330(int a1);
char __cdecl sub_10077390(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10077400(char *a1);
int __cdecl sub_100774A0(int a1, int a2, int a3);
bool __cdecl sub_10077510(int a1, unsigned int a2, int a3);
char __cdecl sub_100775A0(int a1, int a2, char a3, char a4);
char __cdecl sub_10077650(int a1);
char __cdecl sub_10077660(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_100776E0(int a1, const char *a2))(const char *);
signed int __cdecl sub_10077730(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10077780(int a1, int a2, int a3, size_t a4, char *a5);
int sub_10077900();
const char *__cdecl sub_10077910(unsigned int a1);
int __cdecl sub_10077930(int a1, int a2, int a3, int a4);
int __cdecl sub_100779E0(int a1);
int __cdecl sub_10077A00(int a1);
char *sub_10077A20(char *a1, ...);
// char *__usercall sub_10077A60@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_10077A80@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_10077C60();
int sub_10077C80();
int __cdecl sub_10077CA0(int a1, int a2);
int __cdecl sub_10077D00(int a1);
int __cdecl sub_10077D10(int a1, int a2);
int __cdecl sub_10077D70(int a1);
bool __cdecl sub_10077D80(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10077EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10078270(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_100786C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_10078B80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10078F40(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_10079340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10079700(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_10079C40(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1007A020(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1007A3E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1007A780(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1007AB80(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1007AF20(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1007B500(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1007B8F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1007BC90();
// BOOL __usercall sub_1007BCC0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1007BE30@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1007C0A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1007C3A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1007C450(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1007C490(int a1, int a2);
char __cdecl sub_1007C4D0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1007D280(int a1, int a2);
char **__cdecl sub_1007D300(int a1);
int (**sub_1007D340())();
int (__cdecl *__cdecl sub_1007D350(const char *a1))(const char *);
const char *sub_1007D370();
__int64 sub_1007D380();
const char *sub_1007D390();
// int __usercall sub_1007D3A0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1007D3F0(int a1, int a2);
int sub_1007D420(); // weak
// int __usercall sub_1007D540@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_1007D8C0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_1007E6E0(int a1);
int __cdecl sub_1007E750(int a1);
int __cdecl sub_1007E790(char a1);
int __cdecl sub_1007E7B0(int, void *); // idb
// int __usercall sub_1007E810@<eax>(char a1@<al>);
BOOL __cdecl sub_1007E840(char a1, int a2);
int __cdecl sub_1007E870(int, char, int, int, void *); // idb
char __cdecl sub_1007E8A0(void *a1);
BOOL __cdecl sub_1007E8C0(int a1);
char __cdecl sub_1007E8E0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1007E910(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1007E9A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_1007EA40(char a1, void *a2);
// signed int __usercall sub_1007EA80@<eax>(char a1@<al>);
bool __cdecl sub_1007EAA0(char a1, void *a2);
bool __cdecl sub_1007EB90(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1007EBC0(unsigned __int8 a1);
// BOOL __usercall sub_1007EBD0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1007EC00(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1007EDB0(unsigned __int8 a1, int a2);
bool __cdecl sub_1007EDF0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char sub_1007EEE0();
BOOL __cdecl sub_1007EF80(int a1, int a2);
char __cdecl sub_1007EFA0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1007EFE0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1007F080(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1007F100(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1007F170(char a1, void *a2);
char __cdecl sub_1007F1F0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1007F270(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1007F2F0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1007F360(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1007F470(char a1, void *a2);
bool __cdecl sub_1007F490(unsigned __int8 a1, char *a2);
char __cdecl sub_1007F4D0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1007F510();
char __cdecl sub_1007F570(int a1, char *a2);
BOOL __cdecl sub_1007F660(int a1, int a2);
char __cdecl sub_1007F680(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1007F6C0(int a1, int a2);
BOOL __cdecl sub_1007F770(int a1, int a2);
char __cdecl sub_1007F790(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1007F7D0(void *a1);
char __cdecl sub_1007F7F0(void *a1);
bool __thiscall sub_1007F940(void *this);
char __cdecl sub_1007F960(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1007FB00(char a1);
// __int16 __usercall sub_1007FB40@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1007FB50(unsigned __int8 a1, char *a2);
char __cdecl sub_1007FC20(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1007FCA0(char a1, int a2);
// int __usercall sub_1007FE10@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1007FE50@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1007FE90();
char __cdecl sub_1007FEA0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1007FF00(char a1, void *a2);
char __cdecl sub_10080020(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100800A0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_10080250(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10080380(char a1, int a2);
bool __cdecl sub_10080400(void *a1);
char __cdecl sub_10080450(char a1, int a2);
// __int16 __usercall sub_10080530@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10080540(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_100805D0(unsigned __int8 a1, char a2);
bool __cdecl sub_10080690(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10080790(char a1, void *a2);
unsigned __int8 __cdecl sub_100807E0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10080820(char a1, _DWORD *a2);
char __cdecl sub_10080860(char a1);
char __cdecl sub_10080890(char a1, void *a2);
int __cdecl sub_10080910(char a1, _DWORD *a2);
void __cdecl sub_10080960(char a1, char a2);
signed int __cdecl sub_100809D0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10080A20(int, float, float, int, int); // idb
unsigned int __cdecl sub_10080B10(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10080B60(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10080C20(void *a1, size_t a2, int a3);
int __cdecl sub_10080C80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10080CD0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10080D70(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_10080E20(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
char __cdecl sub_10080E80(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
signed int __cdecl sub_10080EE0(char a1, char a2);
int __cdecl sub_10080F40(char a1);
signed int __cdecl sub_10080F80(char a1, char a2, char a3);
int __cdecl sub_10080FF0(char a1);
int __cdecl sub_10081030(char a1);
char __cdecl sub_10081070(char a1, int a2);
char __cdecl sub_10081090(char a1, int a2);
char __cdecl sub_100810C0(char a1, int a2);
char __cdecl sub_10081110(char a1, int a2);
char __cdecl sub_10081140(char a1, int a2);
char __cdecl sub_10081160(int a1);
char __cdecl sub_10081180(char a1);
int __cdecl sub_100811B0(char a1, char a2);
// bool __usercall sub_10081260@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10081290@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10081330(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100813B0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10081430(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100814B0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10081530(char a1);
double __cdecl sub_100815D0(int a1);
int __cdecl sub_10081620(int, float); // idb
int __cdecl sub_10081640(int, float); // idb
char sub_10081660();
signed int __cdecl sub_10081690(unsigned __int8 a1);
char sub_100817C0();
int __cdecl sub_10081840(int a1);
char __cdecl sub_10081850(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10081890(const char *a1, int a2);
// char *__usercall sub_10081900@<eax>(char *result@<eax>);
void __cdecl sub_10081930(char *a1);
void __cdecl sub_100819F0(char *a1, char *a2);
void *__cdecl sub_10081A50(int a1);
char __thiscall sub_10081BE0(void *this);
// _DWORD *__usercall sub_10081C00@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10081C30(); // weak
int sub_10081C90(); // weak
char __cdecl sub_10081CE0(int a1, int a2);
_DWORD *sub_10081DE0();
int __cdecl sub_10081E70(char a1);
_DWORD __cdecl sub_10081EA0(char); // weak
char __cdecl sub_10081EB0(int a1, int a2);
char __cdecl sub_10081F00(int a1, int a2);
char __cdecl sub_10081FB0(int a1, int a2);
char __cdecl sub_10082010(int a1, int a2);
bool __cdecl sub_100820E0(void *a1);
char __cdecl sub_10082120(char a1);
char __cdecl sub_10082150(char a1);
int __cdecl sub_10082180(unsigned __int8 *a1);
unsigned int __cdecl sub_100821A0(void *a1);
unsigned int __cdecl sub_100821C0(void *a1);
unsigned int __cdecl sub_100821E0(void *a1);
unsigned int __cdecl sub_10082200(void *a1);
unsigned int __cdecl sub_10082220(void *a1);
int __cdecl sub_10082240(int a1);
int __cdecl sub_10082290(void *); // idb
unsigned int __cdecl sub_10082360(void *a1);
int __cdecl sub_100823C0(unsigned __int8 *a1);
int __cdecl sub_100823E0(unsigned __int8 *a1, int a2);
int __cdecl sub_10082410(unsigned __int8 *a1);
char sub_10082430();
int __cdecl sub_10082440(int a1, int a2);
// char __usercall sub_10082580@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10082650(_DWORD *a1, char *a2);
BOOL __cdecl sub_10082730(unsigned int a1);
BOOL __cdecl sub_10082750(int a1);
_DWORD __cdecl sub_10082770(_DWORD); // weak
unsigned int __cdecl sub_10082780(int a1, char a2);
signed int __cdecl sub_100827E0(void *a1, int a2, unsigned int a3);
int __cdecl sub_10082800(int a1, int a2, int a3);
char __cdecl sub_10082820(const char *a1, const char *a2);
int __cdecl sub_10082960(int a1, int a2, unsigned int a3);
int sub_100829E0();
void __cdecl sub_100829F0(int a1);
int __cdecl sub_10082A20(int a1);
bool __cdecl sub_10082A40(int a1);
void *__cdecl sub_10082A70(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10082AB0@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10082AD0@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10082AF0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10082B20(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10082C00(int a1, int a2, int a3);
// void *__usercall sub_10082CB0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10082F30(int a1, int a2);
char __cdecl sub_10083000(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10083070@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_100833D0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_100834E0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10083670(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_100837C0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10083910(int a1, int a2);
signed int __cdecl sub_10083950(int a1, int a2);
bool __cdecl sub_100839B0(signed int a1);
int sub_10083A20();
char sub_10083D40();
char sub_10083F60();
char sub_10084160();
char sub_100842E0();
char sub_10084460();
char sub_100845D0();
char sub_100846D0();
char sub_10084830();
char sub_10084990();
char sub_10084AF0();
char sub_10084C60();
char sub_10084DC0();
char sub_10084F20();
char sub_10085140();
char sub_100852A0();
char sub_10085400();
char sub_10085560();
char sub_100856D0();
char sub_10085830();
char sub_10085990();
char sub_10085BB0();
char sub_10085DB0();
char sub_10085F30();
char sub_100860B0();
char sub_10086220();
char sub_10086310();
char sub_10086470();
char sub_100865D0();
char sub_10086730();
char sub_100868A0();
char sub_10086A00();
char sub_10086B60();
char sub_10086D60();
char sub_10086EC0();
char sub_10087020();
char sub_10087180();
char sub_100872F0();
char sub_10087450();
char sub_100875B0();
char sub_10087B50();
char sub_10087D60();
char sub_10087F50();
char sub_100880C0();
char sub_10088230();
char sub_10088390();
char sub_10088480();
char sub_100885E0();
char sub_10088740();
char sub_100888A0();
char sub_10088A10();
char sub_10088B70();
char sub_10088CD0();
char sub_10088ED0();
char sub_10089030();
char sub_10089190();
char sub_100892F0();
char sub_10089460();
char sub_100895C0();
char sub_10089720();
char sub_10089930();
char sub_10089B20();
char sub_10089C90();
char sub_10089E00();
char sub_10089F60();
char sub_1008A050();
char sub_1008A1B0();
char sub_1008A310();
char sub_1008A470();
char sub_1008A5E0();
char sub_1008A740();
char sub_1008A8A0();
char sub_1008AAA0();
char sub_1008AC00();
char sub_1008AD60();
char sub_1008AEC0();
char sub_1008B030();
char sub_1008B190();
char **sub_1008B2F0();
int __cdecl sub_1008B300(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1008B320@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1008B330@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1008B560(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1008B5B0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1008B600(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1008B650(int a1))(int);
int __cdecl sub_1008B6D0(int a1, int a2);
int (__cdecl *__cdecl sub_1008B750(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1008B7A0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1008B7E0(int a1, int a2, int a3))(int);
char __cdecl sub_1008B840(char a1);
char __cdecl sub_1008B8C0(char a1);
char __cdecl sub_1008B900(char a1);
int __cdecl sub_1008B920(int a1, int a2);
char __cdecl sub_1008B940(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
char __cdecl sub_1008BA30(float a1, int a2, int a3);
void __cdecl sub_1008BAE0(int a1, int a2, int a3, float *a4, int a5);
void __cdecl sub_1008BC10(int a1, int a2, int a3, int a4, int a5, float a6);
char __cdecl sub_1008BC80(float a1, int a2, int a3);
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD); // weak
int __cdecl sub_1008BF10(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_execute(_DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_start(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_stop(_DWORD); // weak
int __cdecl sub_1008BFB0(float, float, float, float); // idb
int __cdecl sub_1008BFE0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl j_gdi_pvg_disable_client_state(_DWORD); // weak
int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1008C060(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int __cdecl j_gdi_pvg_enable_client_state(_DWORD); // weak
int __cdecl j_gdi_pvg_end();
int j_gdi_pvg_flush(void); // weak
int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD); // weak
int sub_1008C100();
int __cdecl sub_1008C110(float); // idb
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_1008C160(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_attrib(void); // weak
int j_gdi_pvg_pop_matrix(void); // weak
int __cdecl j_gdi_pvg_push_attrib(_DWORD); // weak
int j_gdi_pvg_push_matrix(void); // weak
int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1008C1F0(float, float, float, float); // idb
int __cdecl sub_1008C220(float, float); // idb
int __cdecl sub_1008C240(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1008C280(int, int, float); // idb
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1008C2B0(float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_1008C2F0(float, float); // idb
int __cdecl sub_1008C310(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// time_t __cdecl static _mkgmtime_0(struct tm *Tm);
int __cdecl sub_1008C370(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_1008C3B0();
int __cdecl sub_1008C400(int a1);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_1008C420(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_1008C480(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1008C4F0(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_1008C530(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_1008C5C0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1008C610(int a1);
int __cdecl sub_1008C630(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1008C660(int a1, int a2, int a3, char a4);
char __cdecl sub_1008C680(int a1);
signed int __cdecl sub_1008C6B0(unsigned int a1, int a2, int a3);
int __cdecl sub_1008C6D0(int a1, int a2, int a3);
int __cdecl sub_1008C6F0(int a1);
int sub_1008C710();
int __cdecl sub_1008C730(int a1, int a2);
__int16 __cdecl sub_1008C760(int a1);
int sub_1008C780();
int __cdecl sub_1008C7A0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_1008C7E0(int a1, int a2, int a3, int a4);
int __cdecl sub_1008C810(int a1);
int __cdecl sub_1008C830(int a1);
int __cdecl sub_1008C850(int a1, int a2);
int __cdecl sub_1008C880(int a1, int a2, int a3, int a4);
int __cdecl sub_1008C8B0(int a1, int a2);
int __cdecl sub_1008C8E0(int a1);
int __cdecl sub_1008C900(int a1);
char __cdecl sub_1008C920(int a1, int a2);
int __cdecl sub_1008C990(_BYTE *a1);
int __cdecl sub_1008C9D0(int a1, int a2);
int __cdecl sub_1008CA00(int a1, int a2);
int __cdecl sub_1008CA20(int a1);
int __cdecl sub_1008CA60(int a1, int a2, int a3);
char __cdecl sub_1008CA80(int a1, int a2, int a3);
int __cdecl sub_1008CAC0(int, void *, int, void *); // idb
int __cdecl sub_1008CB00(int a1, int a2, int a3);
int __cdecl sub_1008CB30(int a1, int a2, int a3);
int __cdecl sub_1008CB50(int a1, int a2, int a3);
int __cdecl sub_1008CBB0(int a1, int a2, int a3);
char __cdecl sub_1008CBF0(int a1, int a2, int a3);
int __cdecl sub_1008CC30(int, void *, int, void *); // idb
int __cdecl sub_1008CC80(unsigned int a1);
int __cdecl sub_1008CCA0(float, float, float, float, float, int, int); // idb
void sub_1008CCD0();
int __cdecl sub_1008CCE0(int a1);
char __cdecl sub_1008CD40(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5);
int sub_1008CDE0();
signed int __fastcall sub_1008CE10(char *a1);
// int __usercall sub_1008CE60@<eax>(unsigned int a1@<eax>);
double __cdecl sub_1008CE70(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_1008D010(int a1, int a2, float a3);
void __cdecl sub_1008D070(int a1, _BYTE *a2);
int __cdecl sub_1008D0A0(int a1, int a2);
int sub_1008D0C0(void); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl sub_1008D110(int a1, int a2);
// int __usercall sub_1008D170@<eax>(const char **a1@<esi>);
// int __usercall sub_1008D470@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1008D490(int a1);
__int16 __cdecl sub_1008D560(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_1008D5A0(int a1, _DWORD *a2, _BYTE *a3);
signed int sub_1008D610();
int __cdecl sub_1008D620(unsigned int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1008D6C0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1008D710(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1008D780(int a1);
int __cdecl sub_1008D7C0(int a1);
int __cdecl sub_1008D800(int a1);
int __cdecl sub_1008D840(int a1);
int __cdecl sub_1008D880(int a1, int a2, int a3, int a4);
int __cdecl sub_1008D8F0(int a1, int a2, int a3);
unsigned int __cdecl sub_1008D990(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1008DB40@<eax>(int a1@<esi>);
int __cdecl sub_1008DBF0(int a1, unsigned __int64 a2);
// int __usercall sub_1008DCA0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_1008DD30(int a1, void *a2, int a3, int a4, int a5);
int sub_1008DE80(void); // weak
void __cdecl sub_1008DE90(__int16 a1, _BYTE *a2);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
char sub_1008DED0();
char __cdecl sub_1008DF20(int a1);
double __cdecl sub_1008E170(char a1);
char sub_1008E200();
char __cdecl sub_1008E220(char a1);
void __cdecl sub_1008E290(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_1008E2F0(float, float, int); // idb
void __cdecl sub_1008E4B0(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_1008E880(int a1, int a2, float *a3, float *a4);
double __cdecl sub_1008E960(float a1);
void __cdecl sub_1008E990(float *a1, float *a2, int a3);
double __cdecl sub_1008EA50(int a1, int a2);
int __cdecl sub_1008EA70(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_1008EB80(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_1008EC60(int a1);
int __cdecl sub_1008EFB0(int a1);
unsigned int __cdecl sub_1008F190(int a1);
int __cdecl sub_1008F6C0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_1008F720(int a1);
int __cdecl sub_1008F780(int a1, int a2, char a3);
void sub_1008F870();
int __cdecl sub_1008F880(int a1, _BYTE *a2, int a3);
char __cdecl sub_1008F8C0(char a1, char a2);
int __cdecl sub_1008F8E0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_10090120(_BYTE *a1);
bool __cdecl sub_100901C0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_100902D0(int a1, _BYTE *a2, int a3);
int __cdecl sub_100903C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_10090620(int a1, __int16 a2, __int16 a3, char a4);
int __cdecl sub_10090B70(int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_10091260(int a1, signed int a2, int a3, char a4);
int __cdecl sub_100916F0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_100917E0(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
char *__cdecl sub_10092920(int a1, int a2, int a3, int a4);
char __cdecl sub_10092990(int a1, int a2);
char *__cdecl sub_100929E0(int a1, int a2);
signed int __cdecl sub_10092A30(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_10092B80(__int16 a1, __int16 a2);
char *__cdecl sub_10092C20(int a1, int a2);
char *__cdecl sub_10092DD0(int a1, int a2);
int __cdecl sub_10092F80(int a1);
int __cdecl sub_10093150(int a1, signed int a2, signed int a3);
char __cdecl sub_10093620(int a1);
char __cdecl sub_100936D0(int a1);
int __cdecl sub_10093840(int a1);
char *__cdecl sub_100938A0(int a1);
unsigned int __cdecl sub_100939F0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10093AB0(int a1, int a2);
unsigned int __cdecl sub_10093BD0(int a1, int a2);
int __cdecl sub_10093D70(int a1, int a2, int a3);
int __cdecl sub_10093DF0(int a1, int a2, int a3);
int __cdecl sub_10093E60(int a1, int a2, int a3);
char __cdecl sub_10093EE0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10093FF0(int a1, signed int a2, signed int a3);
int __cdecl sub_100940E0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100941E0(int a1, int a2);
char *__cdecl sub_10094310(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10094450(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_100946A0(int a1, signed int a2, int a3);
int __cdecl sub_100947E0(int a1, signed int a2, int a3);
int __cdecl sub_10094920(int a1, __int16 a2, __int16 a3);
char __cdecl sub_10094980(int a1, __int16 a2, __int16 a3, __int16 a4, char a5);
int __cdecl sub_10095400(int a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_10095660(signed int a1, signed int a2);
double __cdecl sub_100956A0(float a1, float a2);
double __cdecl sub_10095740(float a1, float a2);
double __cdecl sub_100957E0(double a1, double a2);
double __cdecl sub_10095840(float a1, float a2);
int __cdecl sub_100958C0(double); // idb
double __cdecl sub_100958E0(float a1);
int __cdecl sub_10095920(int a1, int a2);
int __cdecl sub_10095940(float); // idb
double __cdecl sub_10095970(float a1, float a2);
int __cdecl sub_100959E0(float, int, int); // idb
int __cdecl sub_10095A00(float); // idb
double __cdecl sub_10095A60(double a1, double a2);
double __cdecl sub_10095AD0(float a1, float a2);
double __cdecl sub_10095B60(int a1);
int __cdecl sub_10095BA0(float, int, int); // idb
int __cdecl sub_10095BC0(int a1, int a2, int a3);
int __cdecl sub_10095BE0(int a1, int a2);
void __cdecl sub_10095C00(int a1, int a2);
int __cdecl sub_10095C50(int a1, int a2, int a3);
int __cdecl sub_10095C80(float, int, int); // idb
int __cdecl sub_10095CB0(int a1, _DWORD *a2);
int __cdecl sub_10095EC0(int a1, int *a2, int *a3);
int __cdecl sub_10095F60(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10095F80(unsigned int *a1, signed int a2, unsigned int a3);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_dsply_alrt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// char *__cdecl strncpy(char *, const char *, size_t);
// void *__cdecl memset(void *, int, size_t);
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strchr(const char *, int);
// int __cdecl strncmp(const char *, const char *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl atof(const char *);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// char *__cdecl strrchr(const char *, int);
// double __usercall sub_1009814A@<st0>(double@<st0>); weak
// double __cdecl floor(double);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10098802(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_1009991A(int, FILE *); // idb
int __cdecl sub_1009A4AF(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_1009C295(_DWORD *a1);
signed int __cdecl sub_1009C2CC(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1009CF12();
int (*sub_1009D3BF())(void);
void __cdecl sub_1009D3E3(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall _cintrindisp2(_DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_100A17BB(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_100A2BE0(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_100A2C86(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_100A30F2(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_100A328E(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_100A38B0(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_100A39D0(signed int a1);
void **sub_100A3A2E();
signed int sub_100A3A34();
// int __cdecl _fileno(FILE *);
void sub_100A3E25();
// int _get_sse2_info(void); weak
int sub_100A3EDD();
int sub_100A46A2();
int __cdecl sub_100A485F(int a1);
int __cdecl sub_100A4869(int a1);
int __cdecl sub_100A4873(int a1);
int __cdecl sub_100A4952(int a1);
signed int __cdecl sub_100A6029(int a1, int a2);
signed int __cdecl sub_100A656B(int a1, int a2);
int sub_100A6C79();
int __cdecl sub_100A768C(FILE *); // idb
int __cdecl sub_100A77AC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_100A86EB(signed int a1);
signed int __cdecl sub_100A876C(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_100A887D(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_100A8B7E();
int __cdecl sub_100A8B87(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_100A9991(signed int a1);
signed int __cdecl sub_100A9B70(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_100A9BD0(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_100A9BF0(unsigned int a1);
bool __cdecl sub_100A9C10(int a1);
int __cdecl sub_100A9CE0(int a1);
int __cdecl sub_100A9D00(int a1, int a2);
signed int __cdecl sub_100A9D40(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_100A9E00(int a1);
// int __usercall sub_100A9E40@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_100A9EF0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_100AA0C0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100AA0D0@<eax>(int result@<eax>);
// char __usercall sub_100AA0F0@<al>(int a1@<eax>);
// int __usercall sub_100AA110@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_100AA150(int a1, int a2);
// int __usercall sub_100AA170@<eax>(int a1@<esi>);
// signed int __usercall sub_100AA1B0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100AA3C0(int a1);
signed int __cdecl sub_100AA630(unsigned int a1, int a2, int a3);
// int __usercall sub_100AA6D0@<eax>(int a1@<eax>);
// int __usercall sub_100AA6F0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_100AA720@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_100AA810@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100AA840@<eax>(int a1@<eax>);
signed int __cdecl sub_100AA870(unsigned int a1);
signed int __cdecl sub_100AA8C0(int a1, int a2);
signed int __cdecl sub_100AAAB0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_100AAB10(unsigned int a1, int a2, int a3);
// signed int __usercall sub_100AACA0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100ABD50@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_100ABDB0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_100ACB30@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_100ACB50(int a1, unsigned int a2);
// int __usercall sub_100ACBB0@<eax>(int result@<eax>);
// int __usercall sub_100ACBF0@<eax>(int result@<eax>);
// unsigned int __usercall sub_100AE310@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_100AE410@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_100AE490@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_100AE530@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_100AE5F0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_100AE650@<eax>(char *a1@<edi>);
// int __usercall sub_100AE710@<eax>(int a1@<ebx>);
char __cdecl sub_100AE7D0(char *a1, size_t a2, int a3);
char __cdecl sub_100AE820(char *a1, unsigned int a2, int a3);
bool __cdecl sub_100AE870(int a1, int a2);
// int __usercall sub_100AE8A0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_100AEAB0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_100AEB00(int a1, int a2);
signed int __cdecl sub_100AEB90(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_100AECC0(void *a1, int a2);
// BOOL __usercall sub_100AED40@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100AEDE0@<eax>(int result@<eax>);
unsigned int __fastcall sub_100AEE70(unsigned int a1, int a2);
// int __usercall sub_100AEE90@<eax>(int result@<eax>);
// int __usercall sub_100AEF20@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_100AF3A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_100AF450@<eax>(int a1@<edi>);
// int __usercall sub_100AF4B0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_100AF680@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_100AF700(int a1, int a2);
// unsigned int __usercall sub_100AF770@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_100AF920@<eax>(int a1@<esi>, int a2);
// int __usercall sub_100AF9F0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_100AFAA0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_100AFAE0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_100AFB40@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100AFC20@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100B01C0@<eax>(int a1@<eax>);
// int __usercall sub_100B0400@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_100B04A0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_100B0680@<eax>(int a1@<edi>);
// int __usercall sub_100B07C0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_100B0A70(int a1, int a2);
// signed int __usercall sub_100B0D30@<eax>(int a1@<eax>);
// _WORD *__usercall sub_100B0E00@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_100B1020(int a1, int a2);
signed int __cdecl sub_100B1330(int a1, int a2);
signed int __cdecl sub_100B1740(int a1, int a2);
int __cdecl sub_100B18B0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_100B19B0(int a1);
// signed int __usercall sub_100B19D0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_100B1E70@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_100B1EC0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_100B1EE0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100B2290@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_100B23D0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_100B2420@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_100B24C0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_100B24E0(int a1);
// int __usercall sub_100B24F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100B2B90@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_100B3570@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_100B38A0(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10006870; // weak
_UNKNOWN loc_10006880; // weak
_UNKNOWN loc_10030D00; // weak
_UNKNOWN loc_1004C350; // weak
_UNKNOWN loc_10065FD0; // weak
_UNKNOWN unk_100B4870; // weak
__int16 word_100B5558 = 2573; // weak
int dword_100B5B20[] = { 7 }; // weak
int (__cdecl *off_100B5B24)(int, int, int, int, int) = &sub_1003A5A0; // weak
int dword_100B5B28[] = { 16 }; // weak
_UNKNOWN unk_100B62D0; // weak
_UNKNOWN unk_100B62D8; // weak
_UNKNOWN unk_100B62F8; // weak
char byte_100B8180[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_100B8840; // weak
_UNKNOWN unk_100B8860; // weak
_UNKNOWN unk_100B8880; // weak
_UNKNOWN unk_100B8930; // weak
_UNKNOWN unk_100B8950; // weak
_UNKNOWN unk_100B8970; // weak
_UNKNOWN unk_100B8A00; // weak
_UNKNOWN unk_100B8A80; // weak
_UNKNOWN unk_100B8AA0; // weak
_UNKNOWN unk_100B8AA4; // weak
_UNKNOWN unk_100B8AB8; // weak
_UNKNOWN unk_100B8B6C; // weak
_UNKNOWN unk_100B8BA0; // weak
_UNKNOWN unk_100B8BF4; // weak
_UNKNOWN unk_100B8C00; // weak
_UNKNOWN unk_100B8C50; // weak
__int16 word_100B8D60 = 18065; // weak
_UNKNOWN unk_100B8DC0; // weak
_UNKNOWN unk_100B8EB0; // weak
_UNKNOWN unk_100B8ECC; // weak
_UNKNOWN unk_100B8ED4; // weak
_UNKNOWN unk_100B8EDC; // weak
_UNKNOWN unk_100B950C; // weak
_UNKNOWN unk_100B952C; // weak
_UNKNOWN unk_100B954C; // weak
_UNKNOWN unk_100B9550; // weak
_UNKNOWN unk_100B9610; // weak
_UNKNOWN unk_100B9630; // weak
_UNKNOWN unk_100B9650; // weak
_UNKNOWN unk_100B9670; // weak
_UNKNOWN unk_100B9700; // weak
_UNKNOWN unk_100B97A0; // weak
_UNKNOWN unk_100B97C0; // weak
_UNKNOWN unk_100B9874; // weak
_UNKNOWN unk_100B9890; // weak
_UNKNOWN unk_100B98DC; // weak
_UNKNOWN unk_100B9910; // weak
_UNKNOWN unk_100B996C; // weak
_UNKNOWN unk_100BA0A4; // weak
_UNKNOWN unk_100BA0C4; // weak
_UNKNOWN unk_100BA0E4; // weak
_UNKNOWN unk_100BA0E8; // weak
_UNKNOWN unk_100BA198; // weak
_UNKNOWN unk_100BA1B8; // weak
_UNKNOWN unk_100BA1D8; // weak
_UNKNOWN unk_100BA1F8; // weak
_UNKNOWN unk_100BA2A8; // weak
_UNKNOWN unk_100BA348; // weak
_UNKNOWN unk_100BA368; // weak
_UNKNOWN unk_100BA41C; // weak
_UNKNOWN unk_100BA438; // weak
_UNKNOWN unk_100BA484; // weak
_UNKNOWN unk_100BA4B8; // weak
_UNKNOWN unk_100BA514; // weak
_UNKNOWN unk_100BABE4; // weak
_UNKNOWN unk_100BAC14; // weak
_UNKNOWN unk_100BAC34; // weak
_UNKNOWN unk_100BAC38; // weak
_UNKNOWN unk_100BAD18; // weak
_UNKNOWN unk_100BAD38; // weak
_UNKNOWN unk_100BAD58; // weak
_UNKNOWN unk_100BAD78; // weak
_UNKNOWN unk_100BAD98; // weak
_UNKNOWN unk_100BAE38; // weak
_UNKNOWN unk_100BAE58; // weak
_UNKNOWN unk_100BAF0C; // weak
_UNKNOWN unk_100BAF28; // weak
_UNKNOWN unk_100BAF74; // weak
_UNKNOWN unk_100BAF80; // weak
_UNKNOWN unk_100BAFC8; // weak
_UNKNOWN unk_100BB72C; // weak
_UNKNOWN unk_100BB74C; // weak
_UNKNOWN unk_100BB76C; // weak
_UNKNOWN unk_100BB770; // weak
_UNKNOWN unk_100BB840; // weak
_UNKNOWN unk_100BB860; // weak
_UNKNOWN unk_100BB880; // weak
_UNKNOWN unk_100BB8A0; // weak
_UNKNOWN unk_100BB8C0; // weak
_UNKNOWN unk_100BB960; // weak
_UNKNOWN unk_100BB980; // weak
_UNKNOWN unk_100BBA34; // weak
_UNKNOWN unk_100BBA50; // weak
_UNKNOWN unk_100BBA9C; // weak
_UNKNOWN unk_100BBAA8; // weak
_UNKNOWN unk_100BBAF0; // weak
_UNKNOWN unk_100BC260; // weak
_UNKNOWN unk_100BC30C; // weak
char byte_100BC320[] = { '\0' }; // weak
__int16 word_100BC322[] = { 24 }; // weak
_UNKNOWN unk_100BC38C; // weak
_UNKNOWN unk_100BC43C; // weak
_UNKNOWN unk_100BC468; // weak
_UNKNOWN unk_100BC508; // weak
_UNKNOWN unk_100BC5B8; // weak
_UNKNOWN unk_100BC5D8; // weak
_UNKNOWN unk_100BC668; // weak
_UNKNOWN unk_100BC6A8; // weak
_UNKNOWN unk_100BC778; // weak
_UNKNOWN unk_100BC798; // weak
_UNKNOWN unk_100BC7B8; // weak
_UNKNOWN unk_100BC7D8; // weak
_UNKNOWN unk_100BC808; // weak
_UNKNOWN unk_100BC828; // weak
_UNKNOWN unk_100BC8C8; // weak
_UNKNOWN unk_100BC8E8; // weak
_UNKNOWN unk_100BC908; // weak
_UNKNOWN unk_100BC978; // weak
_UNKNOWN unk_100BC998; // weak
_UNKNOWN unk_100BCA3C; // weak
_UNKNOWN unk_100BCA50; // weak
_UNKNOWN unk_100BCAB8; // weak
_UNKNOWN unk_100BCB3C; // weak
_UNKNOWN unk_100BCB44; // weak
_UNKNOWN unk_100BCB4C; // weak
_UNKNOWN unk_100BCCB8; // weak
_UNKNOWN unk_100BCE04; // weak
_UNKNOWN unk_100BD430; // weak
char byte_100BD4E0[] = { '\0' }; // weak
__int16 word_100BD4E2[] = { 24 }; // weak
_UNKNOWN unk_100BD580; // weak
_UNKNOWN unk_100BD594; // weak
_UNKNOWN unk_100BD5A8; // weak
_UNKNOWN unk_100BD668; // weak
_UNKNOWN unk_100BD67C; // weak
_UNKNOWN unk_100BD6A0; // weak
_UNKNOWN unk_100BD6E8; // weak
_UNKNOWN unk_100BD770; // weak
_UNKNOWN unk_100BD778; // weak
__int16 word_100BD780[] = { 60 }; // weak
__int16 word_100BD782[] = { 61 }; // weak
_UNKNOWN unk_100BD950; // weak
_UNKNOWN unk_100BD954; // weak
char aLoad[7] = "LOAD %"; // weak
_UNKNOWN unk_100BDF94; // weak
_UNKNOWN unk_100BDF98; // weak
_UNKNOWN unk_100BDFF8; // weak
_UNKNOWN unk_100BE058; // weak
_UNKNOWN unk_100BE0F8; // weak
_UNKNOWN unk_100BE1AC; // weak
_UNKNOWN unk_100BE1C0; // weak
_UNKNOWN unk_100BE1F4; // weak
_UNKNOWN unk_100BE228; // weak
_UNKNOWN unk_100BE26C; // weak
float flt_100BE2CC =  119.0; // weak
_UNKNOWN unk_100BE908; // weak
_UNKNOWN unk_100BE98C; // weak
_UNKNOWN unk_100BEAB0; // weak
_UNKNOWN unk_100BEAC4; // weak
_UNKNOWN unk_100BEB10; // weak
_UNKNOWN unk_100BEB24; // weak
_UNKNOWN unk_100BEB38; // weak
_UNKNOWN unk_100BEB4C; // weak
_UNKNOWN unk_100BEB60; // weak
_UNKNOWN unk_100BEB74; // weak
_UNKNOWN unk_100BEB90; // weak
_UNKNOWN unk_100BEBB8; // weak
_UNKNOWN unk_100BEBCC; // weak
_UNKNOWN unk_100BEBF4; // weak
_UNKNOWN unk_100BEC08; // weak
_UNKNOWN unk_100BEC20; // weak
_UNKNOWN unk_100BED28; // weak
void *off_100BED9C = &unk_100BE928; // weak
void **off_100BEDB0 = &off_100BED34; // weak
_UNKNOWN unk_100BF390; // weak
_UNKNOWN unk_100BF4EC; // weak
_UNKNOWN unk_100BF4F0; // weak
_UNKNOWN unk_100BF504; // weak
_UNKNOWN unk_100BF520; // weak
_UNKNOWN unk_100BF534; // weak
_UNKNOWN unk_100BF548; // weak
_UNKNOWN unk_100BF55C; // weak
_UNKNOWN unk_100BF598; // weak
_UNKNOWN unk_100BF5B0; // weak
_UNKNOWN unk_100BF5F4; // weak
_UNKNOWN unk_100BF64C; // weak
_UNKNOWN unk_100BF668; // weak
_UNKNOWN unk_100BF690; // weak
_UNKNOWN unk_100BF6A4; // weak
_UNKNOWN unk_100BF6B8; // weak
_UNKNOWN unk_100BF770; // weak
_UNKNOWN unk_100BF7D0; // weak
void *off_100BF834 = &unk_100BF3B0; // weak
void **off_100BF848 = &off_100BF7DC; // weak
_UNKNOWN unk_100BFE88; // weak
char byte_100BFF68[] = { '\0' }; // weak
__int16 word_100BFF6A[] = { 24 }; // weak
_UNKNOWN unk_100BFFCC; // weak
_UNKNOWN unk_100C0094; // weak
_UNKNOWN unk_100C00C0; // weak
_UNKNOWN unk_100C0288; // weak
_UNKNOWN unk_100C0418; // weak
_UNKNOWN unk_100C04F4; // weak
_UNKNOWN unk_100C0508; // weak
_UNKNOWN unk_100C05B8; // weak
_UNKNOWN unk_100C0694; // weak
_UNKNOWN unk_100C06A8; // weak
_UNKNOWN unk_100C0788; // weak
_UNKNOWN unk_100C0818; // weak
_UNKNOWN unk_100C0890; // weak
_UNKNOWN unk_100C0938; // weak
_UNKNOWN unk_100C09D0; // weak
_UNKNOWN unk_100C0A24; // weak
_UNKNOWN unk_100C0A2C; // weak
_UNKNOWN unk_100C11A8; // weak
_UNKNOWN unk_100C11E8; // weak
_UNKNOWN unk_100C1238; // weak
_UNKNOWN unk_100C124C; // weak
_UNKNOWN unk_100C1840; // weak
_UNKNOWN unk_100C18DC; // weak
char byte_100C18F0[] = { '\0' }; // weak
__int16 word_100C18F2[] = { 24 }; // weak
_UNKNOWN unk_100C19B4; // weak
_UNKNOWN unk_100C19E0; // weak
_UNKNOWN unk_100C1AF0; // weak
_UNKNOWN unk_100C1B9C; // weak
_UNKNOWN unk_100C1BC8; // weak
_UNKNOWN unk_100C1C74; // weak
_UNKNOWN unk_100C1CA0; // weak
_UNKNOWN unk_100C1CF8; // weak
_UNKNOWN unk_100C1DC8; // weak
_UNKNOWN unk_100C1E08; // weak
_UNKNOWN unk_100C1E44; // weak
_UNKNOWN unk_100C1E4C; // weak
_UNKNOWN unk_100C1E60; // weak
_UNKNOWN unk_100C1E6C; // weak
_UNKNOWN unk_100C1E78; // weak
char byte_100C2549[] = { '' }; // weak
_UNKNOWN unk_100C2578; // weak
_UNKNOWN unk_100C2590; // weak
_UNKNOWN unk_100C2634; // weak
_UNKNOWN unk_100C263C; // weak
char word_100C2700[] = { ' ', '\0' }; // idb
_UNKNOWN unk_100C2E30; // weak
char byte_100C2EC0[] = { '\0' }; // weak
__int16 word_100C2EC2[] = { 24 }; // weak
_UNKNOWN unk_100C2F1C; // weak
_UNKNOWN unk_100C2FA8; // weak
_UNKNOWN unk_100C2FBC; // weak
_UNKNOWN unk_100C2FE0; // weak
_UNKNOWN unk_100C308C; // weak
_UNKNOWN unk_100C30B8; // weak
_UNKNOWN unk_100C30DC; // weak
_UNKNOWN unk_100C3100; // weak
_UNKNOWN unk_100C3134; // weak
_UNKNOWN unk_100C313C; // weak
_UNKNOWN unk_100C3160; // weak
_UNKNOWN unk_100C3168; // weak
_UNKNOWN unk_100C31A0; // weak
_UNKNOWN unk_100C31AC; // weak
_UNKNOWN unk_100C31D8; // weak
_UNKNOWN unk_100C3814; // weak
char byte_100C3828[] = { '\0' }; // weak
__int16 word_100C382A[] = { 24 }; // weak
int dword_100C38E8[] = { 1057206946 }; // weak
float flt_100C38EC[] = {  102.5 }; // weak
float flt_100C38F0[] = {  0.0010515032 }; // weak
float flt_100C38F4[] = {  1.0 }; // weak
int dword_100C38F8[] = { 0 }; // weak
float flt_100C38FC[] = {  0.027023634 }; // weak
float flt_100C3900[] = {  0.024920627 }; // weak
float flt_100C3904[] = {  0.021398092 }; // weak
_UNKNOWN unk_100C3988; // weak
_UNKNOWN unk_100C39E8; // weak
_UNKNOWN unk_100C3A68; // weak
_UNKNOWN unk_100C3B18; // weak
_UNKNOWN unk_100C3C08; // weak
_UNKNOWN unk_100C3C28; // weak
_UNKNOWN unk_100C3C48; // weak
_UNKNOWN unk_100C3C68; // weak
_UNKNOWN unk_100C3CA8; // weak
_UNKNOWN unk_100C3CE8; // weak
_UNKNOWN unk_100C3E08; // weak
_UNKNOWN unk_100C3EBC; // weak
_UNKNOWN unk_100C3EE8; // weak
_UNKNOWN unk_100C3F2C; // weak
_UNKNOWN unk_100C3F38; // weak
char byte_100C45B8[] = { '\0' }; // weak
__int16 word_100C45BA[] = { 24 }; // weak
int dword_100C4700[] = { 1120731136 }; // weak
float flt_100C4704[] = {  102.5 }; // weak
float flt_100C4708[] = {  0.0010515032 }; // weak
float flt_100C470C[] = {  0.0010515032 }; // weak
int dword_100C4710[] = { 0 }; // weak
float flt_100C4714[] = {  0.027969986 }; // weak
float flt_100C4718[] = {  0.02544638 }; // weak
float flt_100C471C[] = {  0.021555817 }; // weak
_UNKNOWN unk_100C47B0; // weak
_UNKNOWN unk_100C4810; // weak
_UNKNOWN unk_100C4890; // weak
_UNKNOWN unk_100C49F0; // weak
_UNKNOWN unk_100C4A30; // weak
_UNKNOWN unk_100C4A70; // weak
_UNKNOWN unk_100C4AB0; // weak
_UNKNOWN unk_100C4B30; // weak
_UNKNOWN unk_100C4C50; // weak
_UNKNOWN unk_100C4D04; // weak
_UNKNOWN unk_100C4D38; // weak
_UNKNOWN unk_100C4D78; // weak
_UNKNOWN unk_100C4DC4; // weak
_UNKNOWN unk_100C4DF8; // weak
_UNKNOWN unk_100C4E38; // weak
_UNKNOWN unk_100C4EA0; // weak
_UNKNOWN unk_100C5508; // weak
char byte_100C712C[] = { '\0' }; // weak
int (__cdecl *off_100C7134)(int) = &sub_10002B50; // weak
char byte_100C7138[] = { '\0' }; // weak
_UNKNOWN unk_100C7139; // weak
_UNKNOWN unk_100C81B8; // weak
_UNKNOWN unk_100C82A8; // weak
_UNKNOWN unk_100C8368; // weak
_UNKNOWN unk_100C8390; // weak
_UNKNOWN unk_100C8450; // weak
_UNKNOWN unk_100C8508; // weak
_UNKNOWN unk_100C85B8; // weak
_UNKNOWN unk_100C86E0; // weak
_UNKNOWN unk_100C8780; // weak
_UNKNOWN unk_100C87A0; // weak
_UNKNOWN unk_100C87D8; // weak
_UNKNOWN unk_100C88DC; // weak
_UNKNOWN unk_100C8918; // weak
_UNKNOWN unk_100C8988; // weak
_UNKNOWN unk_100C8A28; // weak
char byte_100C8A29[] = { '\x17' }; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
void *off_100CD488 = &unk_100CD3A0; // weak
char *off_100CE118[2] = { "%02d:%02u", "__:__" }; // weak
char *off_100CE11C = "__:__"; // weak
char byte_100CE120[] = { '9' }; // weak
char a03d02u[11] = "%+03d:%02u"; // weak
int dword_100CE148 = 1; // weak
__int16 word_100CE14C[] = { 99 }; // weak
int dword_100CE150 = 4; // weak
char byte_100CE154[] = { '\0' }; // weak
char byte_100CE155[] = { '\x01' }; // weak
char byte_100CE3D8[] = { '#' }; // weak
_UNKNOWN unk_100CFA74; // weak
__int16 word_100D1710 = 48; // weak
float flt_100D3928[] = {  1.0 }; // weak
float flt_100D3934[] = { -1.0 }; // weak
float flt_100D3940[] = {  0.0 }; // weak
char byte_100D394C[] = { '\x02' }; // weak
float flt_100D6778[] = {  0.2 }; // weak
_UNKNOWN unk_100D6D38; // weak
_UNKNOWN unk_100D6D44; // weak
_UNKNOWN unk_100D6D90; // weak
char byte_100D7EC8[] = { ' ' }; // weak
char byte_100D7ED0[] = { ' ' }; // weak
_UNKNOWN unk_100D7ED8; // weak
char byte_100D7F30[] = { '\x05' }; // weak
char byte_100D7F34[] = { '\b' }; // weak
int dword_100D7F38[] = { 9 }; // weak
_UNKNOWN unk_100D7F60; // weak
char byte_100D7F98[] = { '\0' }; // weak
char byte_100D7F99[] = { '\0' }; // weak
char byte_100D7F9A[] = { '\xFF' }; // weak
char byte_100D7F9B[] = { '\xFF' }; // weak
char byte_100D7F9C[] = { '\xFF' }; // weak
_UNKNOWN unk_100D851D; // weak
_UNKNOWN unk_100D8556; // weak
char byte_100D8558[] = { '\x0E' }; // weak
char *off_100D8588 = "/shr_mem/udb_intf.shr"; // weak
char a______[7] = "______"; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_100DE774; // weak
char byte_100DE775[] = { '\x0E' }; // weak
_UNKNOWN unk_100E3830; // weak
__int16 word_100E3832[] = { 4838 }; // weak
_UNKNOWN unk_100E3868; // weak
_UNKNOWN unk_100E386C; // weak
_UNKNOWN unk_100E4968; // weak
_UNKNOWN unk_100E4AF8; // weak
_UNKNOWN unk_100E4C88; // weak
_UNKNOWN unk_100E4E80; // weak
_UNKNOWN unk_100E4F90; // weak
_UNKNOWN unk_100E4F94; // weak
int dword_100E5750[] = { 0 }; // weak
_UNKNOWN unk_100E59C0; // weak
_UNKNOWN unk_100E5A90; // weak
_UNKNOWN unk_100E5B60; // weak
_UNKNOWN unk_100E5C30; // weak
_UNKNOWN unk_100E5D00; // weak
_UNKNOWN unk_100E5DD0; // weak
_UNKNOWN unk_100E5EA0; // weak
_UNKNOWN unk_100E5F70; // weak
_UNKNOWN unk_100E6040; // weak
_UNKNOWN unk_100E6110; // weak
_UNKNOWN unk_100E61E0; // weak
_UNKNOWN unk_100E62B0; // weak
_UNKNOWN unk_100E6380; // weak
_UNKNOWN unk_100E6450; // weak
_UNKNOWN unk_100E6520; // weak
_UNKNOWN unk_100E65F0; // weak
_UNKNOWN unk_100E66C0; // weak
_UNKNOWN unk_100E6790; // weak
_UNKNOWN unk_100E6860; // weak
_UNKNOWN unk_100E6930; // weak
_UNKNOWN unk_100E6A00; // weak
_UNKNOWN unk_100E6AD0; // weak
_UNKNOWN unk_100E6BA0; // weak
_UNKNOWN unk_100E6C70; // weak
_UNKNOWN unk_100E6D40; // weak
_UNKNOWN unk_100E6E10; // weak
_UNKNOWN unk_100E6EE0; // weak
_UNKNOWN unk_100E6FB0; // weak
_UNKNOWN unk_100E7080; // weak
_UNKNOWN unk_100E7150; // weak
_UNKNOWN unk_100E7220; // weak
_UNKNOWN unk_100E72F0; // weak
_UNKNOWN unk_100E73C0; // weak
_UNKNOWN unk_100E7490; // weak
_UNKNOWN unk_100E7560; // weak
_UNKNOWN unk_100E7630; // weak
_UNKNOWN unk_100E7700; // weak
_UNKNOWN unk_100E77D0; // weak
_UNKNOWN unk_100E78A0; // weak
_UNKNOWN unk_100E7970; // weak
_UNKNOWN unk_100E7A40; // weak
_UNKNOWN unk_100E7B10; // weak
_UNKNOWN unk_100E7BE0; // weak
_UNKNOWN unk_100E7CB0; // weak
_UNKNOWN unk_100E7D80; // weak
_UNKNOWN unk_100E7E50; // weak
_UNKNOWN unk_100E7F20; // weak
_UNKNOWN unk_100E7FF0; // weak
_UNKNOWN unk_100E80C0; // weak
_UNKNOWN unk_100E8190; // weak
_UNKNOWN unk_100E8260; // weak
_UNKNOWN unk_100E8330; // weak
_UNKNOWN unk_100E8400; // weak
_UNKNOWN unk_100E84D0; // weak
_UNKNOWN unk_100E85A0; // weak
_UNKNOWN unk_100E8670; // weak
_UNKNOWN unk_100E8740; // weak
_UNKNOWN unk_100E8810; // weak
_UNKNOWN unk_100E88E0; // weak
_UNKNOWN unk_100E89B0; // weak
_UNKNOWN unk_100E8A80; // weak
_UNKNOWN unk_100E8B50; // weak
_UNKNOWN unk_100E8C20; // weak
_UNKNOWN unk_100E8CF0; // weak
_UNKNOWN unk_100E8DC0; // weak
_UNKNOWN unk_100E8E90; // weak
_UNKNOWN unk_100E8F60; // weak
int dword_100EA148 = 4294901760; // idb
int dword_100EA184[] = { 0 }; // weak
_UNKNOWN unk_100EA1C0; // weak
_UNKNOWN unk_100EA1D4; // weak
__int16 word_100EAD14[] = { 81 }; // weak
_UNKNOWN unk_100EB2AC; // weak
_UNKNOWN unk_100EB358; // weak
void *off_100EB35C = &unk_100EB2CC; // weak
char *off_100EBD98[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100EBC08 }; // weak
_UNKNOWN unk_100EBDAC; // weak
_BYTE word_100ECF98[540] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  4,
  0,
  45,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  44,
  0,
  45,
  0,
  45,
  0,
  37,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  37,
  0,
  60,
  0,
  61,
  0,
  45,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  0,
  37,
  0,
  37,
  0,
  36,
  0,
  44,
  0,
  36,
  0,
  45,
  32,
  44,
  13,
  0,
  5,
  0,
  5,
  0,
  5,
  0,
  13,
  0,
  5,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  36,
  0,
  36,
  0,
  36,
  0,
  44,
  64,
  45,
  0,
  4,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66,
  67,
  68,
  69,
  70,
  0,
  0,
  0,
  0,
  87,
  83,
  0,
  0,
  69,
  78,
  0,
  0
}; // idb
_UNKNOWN unk_100EDCB0; // weak
_UNKNOWN unk_100EDCD0; // weak
_UNKNOWN unk_100EF468; // weak
int dword_100EF46C[] = { 0 }; // weak
_UNKNOWN unk_100EF808; // weak
int dword_100EF80C[] = { 0 }; // weak
char *off_100F1798 = "/shr_mem/iop_gea_intf.shr"; // weak
_UNKNOWN unk_100F2430; // weak
float flt_100F2434[] = {  16.0 }; // weak
float flt_100F2438[] = {  8.0 }; // weak
float flt_100F2478[] = { -1.0 }; // weak
float flt_100F247C[] = {  1.0 }; // weak
float flt_100F2480[] = {  10.0 }; // weak
_UNKNOWN unk_100F32B8; // weak
int dword_100F32BC[] = { 6006 }; // weak
void *off_100F3A70 = &unk_100C3160; // weak
char *off_100F3A74[7] = { "AMPS", "", "", "", "T", "", "" }; // weak
char *off_100F3C80 = "/shr_mem/pvt_intf.shr"; // weak
_UNKNOWN unk_100F4920; // weak
int dword_100F4924 = 4294967295; // weak
int dword_100F4928 = 0; // weak
int dword_100F492C = 4278255615; // weak
int dword_100F4930 = 0; // weak
int dword_100F4934[] = { 4278190080 }; // weak
int dword_100F4938[] = { 4278255615 }; // weak
int dword_100F493C = 0; // weak
char byte_100F53C1[] = { '\x01' }; // weak
int dword_100F53CC[] = { 69 }; // weak
int dword_100F5DC0[] = { 2175 }; // weak
char byte_100F5DD0[] = { '\x01' }; // weak
char byte_100F5DEC[] = { '\x01' }; // weak
char *off_100F61C4 = "/shr_mem/gdl69_xm_wx_intf.shr"; // weak
_UNKNOWN unk_100F61E8; // weak
_BYTE byte_100F61F0[12] = { 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0 }; // idb
void *off_100F61FC = &unk_100F61EC; // weak
_UNKNOWN unk_100F6230; // weak
_UNKNOWN unk_100F7670; // weak
char *off_100F7814[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100F7828 }; // weak
char *off_100F79B8 = "true"; // weak
char byte_100F79BC[] = { '\x01' }; // weak
char *off_100F7A20 = "failure listener"; // weak
_UNKNOWN unk_100F81C0; // weak
char *off_100F8858 = "/shr_mem/prx_intf.shr"; // weak
char *off_100F8884 = "/shr_mem/nav_intf.shr"; // weak
int dword_100F92CC[] = { 88 }; // weak
__int16 word_100F977C[] = { 836 }; // weak
char *off_100F979C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_100F97B0 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_100F97C4 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_100F97D8 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_100F97EC = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_100F9800 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
char *off_100FA770 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
int (__cdecl *off_100FACC8)(int, size_t, void *) = &sub_10073540; // weak
int (*off_100FB210[4])() = { &sub_10073800, &sub_100737E0, &sub_100737F0, &sub_100737E0 }; // weak
int (*off_100FB21C)() = &sub_100737E0; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100FB288 = "006-D0170-"; // weak
int (__cdecl *(*off_100FB28C)[2])(int, int) = &off_10122980; // weak
char byte_100FB2D8[] = { '\x03' }; // weak
__int16 word_100FB2DA[] = { 7 }; // weak
__int16 word_100FB2DC[] = { 0 }; // weak
__int16 word_100FB2DE[] = { 0 }; // weak
void *off_100FB2E0 = &unk_100FB2A0; // weak
_UNKNOWN unk_100FB380; // weak
int dword_100FB384[] = { 1312 }; // weak
int (__cdecl *off_100FD708[3])(char) = { &sub_10063FC0, &sub_10063ED0, &sub_10063E90 }; // weak
_UNKNOWN unk_100FDC88; // weak
char byte_100FDC8C[] = { '\0' }; // weak
__int16 word_10113730[] = { 43 }; // weak
char byte_10113734[] = { '\x06' }; // weak
char *off_10113CDC[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_10113CE4[3] = { "normal", "robust", "EQ" }; // weak
char *off_10113CEC = "EQ"; // weak
char *off_10113D08[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10113D14[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_10113D1C[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_10113FD0; // weak
_UNKNOWN unk_1011400C; // weak
char *off_101143C8 = "printf_listener"; // weak
int (*off_101150B0[2])() = { &sub_1008B2F0, &sub_100646F0 }; // weak
char *off_10115160 = "gate_listener"; // weak
int dword_10115594[] = { 6829 }; // weak
int dword_10116408 = 64; // weak
__int16 word_1011640C[] = { 6782 }; // weak
__int16 word_10116410[] = { 128 }; // weak
_UNKNOWN unk_1011642C; // weak
_DWORD dword_10116430[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_10117840[] = { 1565 }; // weak
__int16 word_10117844[] = { 534 }; // weak
char byte_10117848[] = { '\x04' }; // weak
__int16 word_1011784A[] = { 6512 }; // weak
int dword_10117860[] = { 118000 }; // weak
__int16 word_101191F2[] = { 233 }; // weak
int dword_101191F8[] = { 6201 }; // weak
__int16 word_1011BDA8[] = { 114 }; // weak
char *off_1011CC58 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_1011CD78[] = { 551 }; // weak
int dword_1011CDA4[] = { 1600085855 }; // weak
_UNKNOWN unk_1011DC60; // weak
char byte_1011DC61[] = { '\0' }; // weak
char byte_1011DC88[] = { '\x01' }; // weak
__int16 word_1011DC8A[] = { 3020 }; // weak
_UNKNOWN unk_1011E518; // weak
_UNKNOWN unk_1011E530; // weak
_UNKNOWN unk_1011E578; // weak
int dword_1011E57C[] = { 6767 }; // weak
_UNKNOWN unk_1011E588; // weak
_UNKNOWN unk_1011E5A0; // weak
_UNKNOWN unk_1011E5B8; // weak
int dword_1011E5BC[] = { 6769 }; // weak
_UNKNOWN unk_1011E5D0; // weak
int dword_1011E5D4[] = { 6093 }; // weak
_UNKNOWN unk_101201E0; // weak
int dword_101201E4[] = { 0 }; // weak
_UNKNOWN unk_101201F8; // weak
int dword_101201FC[] = { 0 }; // weak
_UNKNOWN unk_10120220; // weak
int dword_10120224[] = { 0 }; // weak
_UNKNOWN unk_10120250; // weak
int dword_10120254[] = { 0 }; // weak
char byte_101203B9[] = { '\x1E' }; // weak
_UNKNOWN unk_10122778; // weak
void *off_1012277C = &unk_101224F0; // weak
int (__cdecl *off_10122980[2])(int, int) = { &sub_10081FB0, &sub_10082010 }; // weak
_UNKNOWN unk_10125640; // weak
_UNKNOWN unk_10125664; // weak
_UNKNOWN unk_101257F8; // weak
char off_10126420[] = { '', '<', '\x11', '\x10' }; // idb
int dword_1012643C = 1; // idb
char byte_10126458[] = { '\x01' }; // weak
char *off_1012645C = "1"; // weak
void *off_10126460 = &unk_100C31D8; // weak
char off_10126464[8] = { '\x10', 'd', '\x12', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_101264E8[] = { '\0' }; // weak
char byte_101264E9[] = { '\0' }; // weak
int dword_101264EC[] = { 0 }; // weak
char *off_101264F0 = "0, 0, 0"; // weak
double dbl_10126758[] = {  0.0 }; // weak
double dbl_10126760[] = {  0.0 }; // weak
double dbl_10126768[] = {  0.0 }; // weak
int dword_10126770[] = { 0 }; // weak
char off_10126774[32] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10127378[] = {  0.0 }; // weak
float flt_1012737C[] = {  0.0 }; // weak
float flt_10127380[] = {  0.0 }; // weak
int dword_10127384[] = { 0 }; // weak
char off_10127388[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_10127B0C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_1013C768
}; // weak
int dword_10127B20[] = { 0 }; // weak
int dword_10127B24[] = { 0 }; // weak
int dword_10127B28[] = { 0 }; // weak
int dword_10127B2C[] = { 0 }; // weak
char *off_10127B30 = "0, 0, 0"; // weak
__int16 word_101282B8[] = { 0 }; // weak
__int16 word_101282BA[] = { 0 }; // weak
__int16 word_101282BC[] = { 0 }; // weak
int dword_101282C0[] = { 0 }; // weak
char *off_101282C4 = "0, 0, 0"; // weak
int dword_101288C8[] = { 0 }; // weak
int dword_101288CC[] = { 0 }; // weak
int dword_101288D0[] = { 0 }; // weak
int dword_101288D4[] = { 0 }; // weak
char off_101288D8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10129060[] = { 0 }; // weak
int dword_10129064[] = { 0 }; // weak
int dword_10129068[] = { 0 }; // weak
int dword_1012906C[] = { 0 }; // weak
int dword_10129070[] = { 0 }; // weak
int dword_10129074[] = { 0 }; // weak
int dword_10129078[] = { 0 }; // weak
char off_1012907C[32] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10129C80[] = { '\0' }; // weak
char byte_10129C81[] = { '\0' }; // weak
char byte_10129C82[] = { '\0' }; // weak
int dword_10129C84[] = { 0 }; // weak
char *off_10129C88 = "0, 0, 0"; // weak
int dword_1012A110[] = { 0 }; // weak
int dword_1012A114[] = { 0 }; // weak
int dword_1012A118[] = { 0 }; // weak
int dword_1012A11C[] = { 0 }; // weak
char *off_1012A120 = "0, 0, 0"; // weak
int dword_1012A8A8[] = { 0 }; // weak
int dword_1012A8AC[] = { 0 }; // weak
int dword_1012A8B0[] = { 0 }; // weak
int dword_1012A8B4[] = { 0 }; // weak
char off_1012A8B8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1012AC18[] = { 0 }; // weak
__int16 word_1012AC1A[] = { 0 }; // weak
__int16 word_1012AC1C[] = { 0 }; // weak
int dword_1012AC20[] = { 0 }; // weak
char *off_1012AC24 = "0, 0, 0"; // weak
int dword_1012AED8[] = { 0 }; // weak
int dword_1012AEDC[] = { 0 }; // weak
int dword_1012AEE0[] = { 0 }; // weak
int dword_1012AEE4[] = { 0 }; // weak
char off_1012AEE8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1012B248[] = { 0 }; // weak
int dword_1012B24C[] = { 0 }; // weak
int dword_1012B250[] = { 0 }; // weak
int dword_1012B254[] = { 0 }; // weak
int dword_1012B258[] = { 0 }; // weak
int dword_1012B25C[] = { 0 }; // weak
int dword_1012B260[] = { 0 }; // weak
char *off_1012B264 = "0, 0, 0"; // weak
char byte_1012B7C8[] = { '\0' }; // weak
char byte_1012B7C9[] = { '\0' }; // weak
char byte_1012B7CA[] = { '\0' }; // weak
int dword_1012B7CC[] = { 0 }; // weak
char *off_1012B7D0 = "0, 0, 0"; // weak
int dword_1012B9D8[] = { 0 }; // weak
int dword_1012B9DC[] = { 0 }; // weak
int dword_1012B9E0[] = { 0 }; // weak
int dword_1012B9E4[] = { 0 }; // weak
char off_1012B9E8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1012BD48[] = { '\x01' }; // weak
char *off_1012BD4C = "1"; // weak
void *off_1012BD50 = &unk_100C31D8; // weak
char off_1012BD54[8] = { '', '_', '\x12', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1012BDD8[] = { '\0' }; // weak
char byte_1012BDD9[] = { '\0' }; // weak
int dword_1012BDDC[] = { 0 }; // weak
char *off_1012BDE0 = "0, 0, 0"; // weak
double dbl_1012C048[] = {  0.0 }; // weak
double dbl_1012C050[] = {  0.0 }; // weak
double dbl_1012C058[] = {  0.0 }; // weak
int dword_1012C060[] = { 0 }; // weak
char *off_1012C064 = "0, 0, 0"; // weak
float flt_1012CC68[] = {  0.0 }; // weak
float flt_1012CC6C[] = {  0.0 }; // weak
float flt_1012CC70[] = {  0.0 }; // weak
int dword_1012CC74[] = { 0 }; // weak
char off_1012CC78[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1012D400[] = { 0 }; // weak
int dword_1012D404[] = { 0 }; // weak
int dword_1012D408[] = { 0 }; // weak
int dword_1012D40C[] = { 0 }; // weak
char *off_1012D410 = "0, 0, 0"; // weak
__int16 word_1012DB98[] = { 0 }; // weak
__int16 word_1012DB9A[] = { 0 }; // weak
__int16 word_1012DB9C[] = { 0 }; // weak
int dword_1012DBA0[] = { 0 }; // weak
char *off_1012DBA4 = "0, 0, 0"; // weak
int dword_1012E1A8[] = { 0 }; // weak
int dword_1012E1AC[] = { 0 }; // weak
int dword_1012E1B0[] = { 0 }; // weak
int dword_1012E1B4[] = { 0 }; // weak
char off_1012E1B8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1012E940[] = { 0 }; // weak
int dword_1012E944[] = { 0 }; // weak
int dword_1012E948[] = { 0 }; // weak
int dword_1012E94C[] = { 0 }; // weak
int dword_1012E950[] = { 0 }; // weak
int dword_1012E954[] = { 0 }; // weak
int dword_1012E958[] = { 0 }; // weak
char off_1012E95C[32] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1012F560[] = { '\0' }; // weak
char byte_1012F561[] = { '\0' }; // weak
char byte_1012F562[] = { '\0' }; // weak
int dword_1012F564[] = { 0 }; // weak
char *off_1012F568 = "0, 0, 0"; // weak
int dword_1012F9F0[] = { 0 }; // weak
int dword_1012F9F4[] = { 0 }; // weak
int dword_1012F9F8[] = { 0 }; // weak
int dword_1012F9FC[] = { 0 }; // weak
char *off_1012FA00 = "0, 0, 0"; // weak
int dword_10130188[] = { 0 }; // weak
int dword_1013018C[] = { 0 }; // weak
int dword_10130190[] = { 0 }; // weak
int dword_10130194[] = { 0 }; // weak
char off_10130198[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_101304F8[] = { 0 }; // weak
__int16 word_101304FA[] = { 0 }; // weak
__int16 word_101304FC[] = { 0 }; // weak
int dword_10130500[] = { 0 }; // weak
char *off_10130504 = "0, 0, 0"; // weak
int dword_101307B8[] = { 0 }; // weak
int dword_101307BC[] = { 0 }; // weak
int dword_101307C0[] = { 0 }; // weak
int dword_101307C4[] = { 0 }; // weak
char off_101307C8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10130B28[] = { 0 }; // weak
int dword_10130B2C[] = { 0 }; // weak
int dword_10130B30[] = { 0 }; // weak
int dword_10130B34[] = { 0 }; // weak
int dword_10130B38[] = { 0 }; // weak
int dword_10130B3C[] = { 0 }; // weak
int dword_10130B40[] = { 0 }; // weak
char *off_10130B44 = "0, 0, 0"; // weak
char byte_101310A8[] = { '\0' }; // weak
char byte_101310A9[] = { '\0' }; // weak
char byte_101310AA[] = { '\0' }; // weak
int dword_101310AC[] = { 0 }; // weak
char *off_101310B0 = "0, 0, 0"; // weak
int dword_101312B8[] = { 0 }; // weak
int dword_101312BC[] = { 0 }; // weak
int dword_101312C0[] = { 0 }; // weak
int dword_101312C4[] = { 0 }; // weak
char off_101312C8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10131628[] = { '\x01' }; // weak
char *off_1013162C[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_10131630[2] = { "1", "pass_normal_1" }; // weak
char off_10131634[8] = { '', '^', '\x12', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10131678[] = { '\0' }; // weak
char byte_10131679[] = { '\0' }; // weak
int dword_1013167C[] = { 0 }; // weak
char *off_10131680 = "0, 0, 0"; // weak
double dbl_101318E8[] = {  0.0 }; // weak
double dbl_101318F0[] = {  0.0 }; // weak
double dbl_101318F8[] = {  0.0 }; // weak
int dword_10131900[] = { 0 }; // weak
char *off_10131904 = "0, 0, 0"; // weak
float flt_10132508[] = {  0.0 }; // weak
float flt_1013250C[] = {  0.0 }; // weak
float flt_10132510[] = {  0.0 }; // weak
int dword_10132514[] = { 0 }; // weak
char off_10132518[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10132CA0[] = { 0 }; // weak
int dword_10132CA4[] = { 0 }; // weak
int dword_10132CA8[] = { 0 }; // weak
int dword_10132CAC[] = { 0 }; // weak
char *off_10132CB0 = "0, 0, 0"; // weak
__int16 word_10133438[] = { 0 }; // weak
__int16 word_1013343A[] = { 0 }; // weak
__int16 word_1013343C[] = { 0 }; // weak
int dword_10133440[] = { 0 }; // weak
char *off_10133444 = "0, 0, 0"; // weak
int dword_10133A48[] = { 0 }; // weak
int dword_10133A4C[] = { 0 }; // weak
int dword_10133A50[] = { 0 }; // weak
int dword_10133A54[] = { 0 }; // weak
char off_10133A58[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101341E0[] = { 0 }; // weak
int dword_101341E4[] = { 0 }; // weak
int dword_101341E8[] = { 0 }; // weak
int dword_101341EC[] = { 0 }; // weak
int dword_101341F0[] = { 0 }; // weak
int dword_101341F4[] = { 0 }; // weak
int dword_101341F8[] = { 0 }; // weak
char off_101341FC[32] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10134E00[] = { '\0' }; // weak
char byte_10134E01[] = { '\0' }; // weak
char byte_10134E02[] = { '\0' }; // weak
int dword_10134E04[] = { 0 }; // weak
char *off_10134E08 = "0, 0, 0"; // weak
int dword_10135290[] = { 0 }; // weak
int dword_10135294[] = { 0 }; // weak
int dword_10135298[] = { 0 }; // weak
int dword_1013529C[] = { 0 }; // weak
char *off_101352A0 = "0, 0, 0"; // weak
int dword_10135A28[] = { 0 }; // weak
int dword_10135A2C[] = { 0 }; // weak
int dword_10135A30[] = { 0 }; // weak
int dword_10135A34[] = { 0 }; // weak
char off_10135A38[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10135D98[] = { 0 }; // weak
__int16 word_10135D9A[] = { 0 }; // weak
__int16 word_10135D9C[] = { 0 }; // weak
int dword_10135DA0[] = { 0 }; // weak
char *off_10135DA4 = "0, 0, 0"; // weak
int dword_10136058[] = { 0 }; // weak
int dword_1013605C[] = { 0 }; // weak
int dword_10136060[] = { 0 }; // weak
int dword_10136064[] = { 0 }; // weak
char off_10136068[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101363C8[] = { 0 }; // weak
int dword_101363CC[] = { 0 }; // weak
int dword_101363D0[] = { 0 }; // weak
int dword_101363D4[] = { 0 }; // weak
int dword_101363D8[] = { 0 }; // weak
int dword_101363DC[] = { 0 }; // weak
int dword_101363E0[] = { 0 }; // weak
char *off_101363E4 = "0, 0, 0"; // weak
char byte_10136948[] = { '\0' }; // weak
char byte_10136949[] = { '\0' }; // weak
char byte_1013694A[] = { '\0' }; // weak
int dword_1013694C[] = { 0 }; // weak
char *off_10136950 = "0, 0, 0"; // weak
int dword_10136B58[] = { 0 }; // weak
int dword_10136B5C[] = { 0 }; // weak
int dword_10136B60[] = { 0 }; // weak
int dword_10136B64[] = { 0 }; // weak
char off_10136B68[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10136EC8[] = { '\x01' }; // weak
char *off_10136ECC[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_10136ED0[2] = { "1", "pass_robust_1" }; // weak
char off_10136ED4[8] = { '', '^', '\x12', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10136F18[] = { '\0' }; // weak
char byte_10136F19[] = { '\0' }; // weak
int dword_10136F1C[] = { 0 }; // weak
char *off_10136F20 = "0, 0, 0"; // weak
double dbl_10137188[] = {  0.0 }; // weak
double dbl_10137190[] = {  0.0 }; // weak
double dbl_10137198[] = {  0.0 }; // weak
int dword_101371A0[] = { 0 }; // weak
char *off_101371A4 = "0, 0, 0"; // weak
float flt_10137DA8[] = {  0.0 }; // weak
float flt_10137DAC[] = {  0.0 }; // weak
float flt_10137DB0[] = {  0.0 }; // weak
int dword_10137DB4[] = { 0 }; // weak
char off_10137DB8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10138540[] = { 0 }; // weak
int dword_10138544[] = { 0 }; // weak
int dword_10138548[] = { 0 }; // weak
int dword_1013854C[] = { 0 }; // weak
char *off_10138550 = "0, 0, 0"; // weak
__int16 word_10138CD8[] = { 0 }; // weak
__int16 word_10138CDA[] = { 0 }; // weak
__int16 word_10138CDC[] = { 0 }; // weak
int dword_10138CE0[] = { 0 }; // weak
char *off_10138CE4 = "0, 0, 0"; // weak
int dword_101392E8[] = { 0 }; // weak
int dword_101392EC[] = { 0 }; // weak
int dword_101392F0[] = { 0 }; // weak
int dword_101392F4[] = { 0 }; // weak
char off_101392F8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10139A80[] = { 0 }; // weak
int dword_10139A84[] = { 0 }; // weak
int dword_10139A88[] = { 0 }; // weak
int dword_10139A8C[] = { 0 }; // weak
int dword_10139A90[] = { 0 }; // weak
int dword_10139A94[] = { 0 }; // weak
int dword_10139A98[] = { 0 }; // weak
char off_10139A9C[32] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1013A6A0[] = { '\0' }; // weak
char byte_1013A6A1[] = { '\0' }; // weak
char byte_1013A6A2[] = { '\0' }; // weak
int dword_1013A6A4[] = { 0 }; // weak
char *off_1013A6A8 = "0, 0, 0"; // weak
int dword_1013AB30[] = { 0 }; // weak
int dword_1013AB34[] = { 0 }; // weak
int dword_1013AB38[] = { 0 }; // weak
int dword_1013AB3C[] = { 0 }; // weak
char *off_1013AB40 = "0, 0, 0"; // weak
int dword_1013B2C8[] = { 0 }; // weak
int dword_1013B2CC[] = { 0 }; // weak
int dword_1013B2D0[] = { 0 }; // weak
int dword_1013B2D4[] = { 0 }; // weak
char off_1013B2D8[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1013B638[] = { 0 }; // weak
__int16 word_1013B63A[] = { 0 }; // weak
__int16 word_1013B63C[] = { 0 }; // weak
int dword_1013B640[] = { 0 }; // weak
char *off_1013B644 = "0, 0, 0"; // weak
int dword_1013B8F8[] = { 0 }; // weak
int dword_1013B8FC[] = { 0 }; // weak
int dword_1013B900[] = { 0 }; // weak
int dword_1013B904[] = { 0 }; // weak
char off_1013B908[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1013BC68[] = { 0 }; // weak
int dword_1013BC6C[] = { 0 }; // weak
int dword_1013BC70[] = { 0 }; // weak
int dword_1013BC74[] = { 0 }; // weak
int dword_1013BC78[] = { 0 }; // weak
int dword_1013BC7C[] = { 0 }; // weak
int dword_1013BC80[] = { 0 }; // weak
char *off_1013BC84 = "0, 0, 0"; // weak
char byte_1013C1E8[] = { '\0' }; // weak
char byte_1013C1E9[] = { '\0' }; // weak
char byte_1013C1EA[] = { '\0' }; // weak
int dword_1013C1EC[] = { 0 }; // weak
char *off_1013C1F0 = "0, 0, 0"; // weak
int dword_1013C3F8[] = { 0 }; // weak
int dword_1013C3FC[] = { 0 }; // weak
int dword_1013C400[] = { 0 }; // weak
int dword_1013C404[] = { 0 }; // weak
char off_1013C408[20] =
{
  'x',
  'c',
  '\x12',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1013D3E8; // weak
int dword_101405BC[] = { 0 }; // weak
_UNKNOWN off_101405C0; // weak
_UNKNOWN unk_10140650; // weak
_UNKNOWN unk_10140654; // weak
_UNKNOWN unk_10140658; // weak
_UNKNOWN unk_1014065C; // weak
_UNKNOWN unk_10140660; // weak
_UNKNOWN unk_10140664; // weak
_UNKNOWN unk_10140668; // weak
_UNKNOWN unk_1014066C; // weak
char byte_10142878[] = { '\x01' }; // weak
__int16 word_1014287A[] = { 3020 }; // weak
char byte_10145672[] = { '\x04' }; // weak
char byte_10145677[] = { '\a' }; // weak
char *off_1014E574 = "/shr_mem/cdp_mngr_intf.shr"; // weak
_UNKNOWN unk_1014EAB0; // weak
int dword_1014EAB4[] = { 3535 }; // weak
_UNKNOWN unk_1014EAE8; // weak
int dword_1014EAEC[] = { 6813 }; // weak
_UNKNOWN unk_1014EB20; // weak
int dword_1014EB24[] = { 9036 }; // weak
_UNKNOWN unk_1014EB58; // weak
int dword_1014EB5C[] = { 6763 }; // weak
int dword_10150758[] = { 6103 }; // weak
int dword_1015075C[] = { 8000 }; // weak
char byte_101513F0[] = { '\0' }; // weak
char byte_101513FC[12] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0'
}; // idb
int (__cdecl *off_10151408[16])(int, int) =
{
  &sub_10092C20,
  &sub_10092C20,
  &sub_10092C20,
  &sub_10092DD0,
  &sub_10092DD0,
  &sub_10092DD0,
  &sub_10092DD0,
  &sub_10092C20,
  &sub_100929E0,
  &sub_10092990,
  &sub_10092990,
  &sub_100929E0,
  &sub_100929E0,
  &sub_10092990,
  &sub_10092990,
  &sub_100929E0
}; // weak
int (__cdecl *off_10151428[8])(int, int) =
{
  &sub_100929E0,
  &sub_10092990,
  &sub_10092990,
  &sub_100929E0,
  &sub_100929E0,
  &sub_10092990,
  &sub_10092990,
  &sub_100929E0
}; // weak
int dword_10151450 = 0; // idb
int dword_10151D90[] = { 0 }; // weak
_WORD dword_10160350[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_10160750[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_10160B50[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_10160F50[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_10161350[] = { 99 }; // weak
int dword_10161750[] = { 25344 }; // weak
int dword_10161B50[] = { 6488064 }; // weak
int dword_10161F50[] = { 1660944384 }; // weak
int dword_10162378[] = { 128 }; // weak
int dword_10162388[] = { 0 }; // weak
int dword_10162398[] = { 0 }; // weak
char byte_10162409[] = { '\0' }; // weak
char byte_1016240A[] = { '\0' }; // weak
char byte_1016240B[] = { '\0' }; // weak
char byte_1016240C[] = { '\x10' }; // weak
int dword_10162420[] = { 0 }; // weak
_UNKNOWN unk_10162498; // weak
_UNKNOWN unk_10162918; // weak
char byte_10162990[] = { '\0' }; // weak
char byte_10162A90[] = { '\0' }; // weak
char byte_10162B90[] = { '\0' }; // weak
int dword_10162C90[] = { 0 }; // weak
int dword_10162D08[] = { 0 }; // weak
int (__cdecl *off_10162D88)(int, int) = &sub_100B1740; // weak
int dword_10162F70[] = { 0 }; // weak
int dword_10162FB8[] = { 16 }; // weak
_UNKNOWN unk_10163008; // weak
_UNKNOWN unk_10163088; // weak
_UNKNOWN unk_10163108; // weak
_UNKNOWN unk_10163180; // weak
_UNKNOWN unk_101631F8; // weak
_UNKNOWN unk_101641F8; // weak
_UNKNOWN unk_10164350; // weak
_UNKNOWN unk_10164358; // weak
int (*off_1016628C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_10166340; // weak
_UNKNOWN unk_10166A30; // weak
void *off_10166D10 = &unk_1031FB80; // weak
_UNKNOWN unk_10166D20; // weak
_UNKNOWN unk_10166D80; // weak
double dbl_10166F90 =  1.797693134862316e308; // weak
int dword_10167180 = 1024; // weak
int dword_10167184 = 4294966273; // weak
int dword_10167188 = 53; // weak
int dword_1016718C = 11; // weak
int dword_10167190 = 64; // weak
int dword_10167194 = 1023; // weak
int dword_10167198 = 128; // weak
int dword_1016719C = 4294967169; // weak
int dword_101671A0 = 24; // weak
int dword_101671A4 = 8; // weak
int dword_101671A8 = 32; // weak
int dword_101671AC = 127; // weak
_UNKNOWN unk_10167820; // weak
char byte_10167824 = '\0'; // weak
int dword_10167828 = 0; // weak
_UNKNOWN unk_10167830; // weak
char byte_10167900 = '\0'; // weak
char byte_10167908 = '\0'; // idb
int dword_10168908; // weak
char byte_10168910[]; // weak
char byte_10168912; // weak
__int16 word_10168914[]; // weak
int dword_10168918; // weak
int dword_1016891C; // weak
__int16 word_10168920[]; // weak
_UNKNOWN unk_10168928; // weak
_UNKNOWN unk_101689C0; // weak
int dword_101689C4; // weak
int dword_101689CC; // weak
int dword_101689F0; // weak
int dword_101689F8; // weak
int dword_10168A1C; // weak
int dword_10168A24; // weak
int dword_10168A48; // weak
int dword_10168A50; // weak
int dword_10168A74; // weak
int dword_10168A7C; // weak
_UNKNOWN unk_10168AA0; // weak
float flt_10168ABC; // weak
int dword_10168AD0; // weak
int dword_10168AD8; // weak
char byte_10168AF9; // weak
int dword_10168AFC; // weak
char byte_10168B00; // weak
int dword_10168B04; // weak
float flt_10168B14; // weak
int dword_10168B28; // weak
char byte_10168B2C; // weak
int dword_10168B30; // weak
float flt_10168B40; // weak
_UNKNOWN unk_10168B50; // weak
int dword_10168B54; // weak
int dword_10168B5C; // weak
float flt_10168B60; // weak
float flt_10168B64; // weak
float flt_10168B68[]; // weak
float flt_10168B6C; // weak
float flt_10168B74[]; // weak
char byte_10168B80[]; // weak
char byte_10168B81[]; // weak
char byte_10168B82[]; // weak
int dword_10168B84[]; // weak
int dword_10168B8C[]; // weak
float flt_10168B94; // weak
float flt_10168B9C[]; // weak
char byte_10168BA8[]; // weak
int dword_10168BB0; // weak
int dword_10168BB8; // weak
float flt_10168BC0; // weak
float flt_10168BC8; // weak
float flt_10168BD0; // weak
int dword_10168BDC; // weak
int dword_10168BE4; // weak
int dword_10168C08; // weak
int dword_10168C10; // weak
int dword_10168C34; // weak
int dword_10168C3C; // weak
int dword_10168C60; // weak
int dword_10168C68; // weak
char byte_10168C89; // weak
int dword_10168C8C; // weak
int dword_10168C94; // weak
int dword_10168CB8; // weak
int dword_10168CC0; // weak
float flt_10168CC4; // weak
float flt_10168CC8; // weak
_UNKNOWN unk_10168CE0; // weak
char byte_10168CE1; // weak
int dword_10168CE4; // weak
char byte_10168CE8; // weak
int dword_10168CEC; // weak
float flt_10168CFC; // weak
float flt_10168D00; // weak
char byte_10168D08; // weak
_UNKNOWN unk_10168D38; // weak
float flt_10168D54; // weak
float flt_10168D78; // weak
float flt_10168D80; // weak
float flt_10168DA4; // weak
float flt_10168DAC; // weak
int dword_10168DC0; // weak
int dword_10168DC8; // weak
float flt_10168DCC; // weak
float flt_10168DD0; // weak
float flt_10168DD4; // weak
float flt_10168DD8; // weak
_UNKNOWN unk_10168DE8; // weak
float flt_10168DEC[]; // weak
float flt_10168E3C; // weak
float flt_10168E48; // weak
float flt_10168E64; // weak
float flt_10168E70; // weak
float flt_10168E8C; // weak
float flt_10168EB4; // weak
float flt_10168EDC; // weak
float flt_10168F04; // weak
float flt_10168F2C; // weak
float flt_10168F34; // weak
_UNKNOWN unk_10168F78; // weak
int dword_10168F7C; // weak
int dword_10168F84; // weak
int dword_10168FA8; // weak
int dword_10168FB0; // weak
int dword_10168FD4; // weak
int dword_10168FDC; // weak
int dword_10169000; // weak
int dword_10169008; // weak
int dword_1016902C; // weak
int dword_10169034; // weak
char byte_10169054; // weak
int dword_10169058[]; // weak
int dword_1016905C; // weak
int dword_10169060; // weak
int dword_10169064; // weak
int dword_10169068; // weak
_UNKNOWN unk_10169070; // weak
int dword_101C5C70; // weak
int dword_101C5C74; // weak
int dword_101C5C78; // weak
char byte_101C5C7C; // weak
_UNKNOWN unk_101C5C80; // weak
float flt_101CAB20; // weak
float flt_101CAB24; // weak
__int16 word_101CAB28[]; // weak
char byte_101CAB50[]; // weak
int dword_101CAC50; // weak
void (__cdecl *dword_101CAC58[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_101CAC78; // weak
__int16 word_101CFDE4; // weak
__int16 word_101CFDE8; // weak
__int16 word_101CFDEC; // weak
int dword_101CFDF0; // weak
char byte_101D53E8; // weak
char byte_101D53E9; // weak
_UNKNOWN unk_101D53EC; // weak
_UNKNOWN unk_101D53F0; // weak
int dword_101D53F4; // weak
_UNKNOWN unk_101D53F8; // weak
_UNKNOWN unk_101D53F9; // weak
_UNKNOWN unk_101D540F; // weak
_UNKNOWN unk_101D5410; // weak
_UNKNOWN unk_101D5411; // weak
_UNKNOWN unk_101D5412; // weak
_UNKNOWN unk_101D5414; // weak
_UNKNOWN unk_101D5418; // weak
_UNKNOWN unk_101D541C; // weak
_UNKNOWN unk_101D543C; // weak
_UNKNOWN unk_101D545C; // weak
_UNKNOWN unk_101D547C; // weak
_UNKNOWN unk_101D549C; // weak
_UNKNOWN unk_101D54BC; // weak
_UNKNOWN unk_101D54DC; // weak
_UNKNOWN unk_101D54FC; // weak
_UNKNOWN unk_101D551C; // weak
_UNKNOWN unk_101D553C; // weak
_UNKNOWN unk_101D555C; // weak
_UNKNOWN unk_101D557C; // weak
_UNKNOWN unk_101D559C; // weak
_UNKNOWN unk_101D55BC; // weak
_UNKNOWN unk_101D55DC; // weak
_UNKNOWN unk_101D55FC; // weak
_UNKNOWN unk_101D561C; // weak
_UNKNOWN unk_101D563C; // weak
_UNKNOWN unk_101D565C; // weak
_UNKNOWN unk_101D567C; // weak
_UNKNOWN unk_101D569C; // weak
_UNKNOWN unk_101D56BC; // weak
_UNKNOWN unk_101D56DC; // weak
_UNKNOWN unk_101D56FC; // weak
_UNKNOWN unk_101D571C; // weak
_UNKNOWN unk_101D573C; // weak
_UNKNOWN unk_101D575C; // weak
_UNKNOWN unk_101D577C; // weak
_UNKNOWN unk_101D579C; // weak
_UNKNOWN unk_101D57A0; // weak
_UNKNOWN unk_101D57A4; // weak
_UNKNOWN unk_101D57A8; // weak
_UNKNOWN unk_101D57AC; // weak
_UNKNOWN unk_101D57B0; // weak
_UNKNOWN unk_101D57B4; // weak
_UNKNOWN unk_101D57D4; // weak
_UNKNOWN unk_101D57F4; // weak
_UNKNOWN unk_101D5814; // weak
_UNKNOWN unk_101D5834; // weak
_UNKNOWN unk_101D5854; // weak
_UNKNOWN unk_101D5874; // weak
_UNKNOWN unk_101D5894; // weak
_UNKNOWN unk_101D58B4; // weak
_UNKNOWN unk_101D58B5; // weak
_UNKNOWN unk_101D58B6; // weak
_UNKNOWN unk_101D5908; // weak
_UNKNOWN unk_101D5928; // weak
_UNKNOWN unk_101D5948; // weak
_UNKNOWN unk_101D594C; // weak
_UNKNOWN unk_101D5950; // weak
_UNKNOWN unk_101D5954; // weak
_UNKNOWN unk_101D5974; // weak
_UNKNOWN unk_101D5994; // weak
_UNKNOWN unk_101D59B4; // weak
_UNKNOWN unk_101D59D4; // weak
_UNKNOWN unk_101D59F4; // weak
_UNKNOWN unk_101D5A14; // weak
_UNKNOWN unk_101D5A34; // weak
_UNKNOWN unk_101D5A54; // weak
_UNKNOWN unk_101D5A74; // weak
_UNKNOWN unk_101D5ABC; // weak
_UNKNOWN unk_101D5B04; // weak
_UNKNOWN unk_101D5B4C; // weak
_UNKNOWN unk_101D5B94; // weak
_UNKNOWN unk_101D5BDC; // weak
_UNKNOWN unk_101D5C24; // weak
_UNKNOWN unk_101D5C6C; // weak
_UNKNOWN unk_101D5CB4; // weak
_UNKNOWN unk_101D5CFC; // weak
_UNKNOWN unk_101D5D44; // weak
_UNKNOWN unk_101D5D8C; // weak
_UNKNOWN unk_101D5DD4; // weak
_UNKNOWN unk_101D5E1C; // weak
_UNKNOWN unk_101D5E64; // weak
_UNKNOWN unk_101D5EAC; // weak
_UNKNOWN unk_101D5EF4; // weak
_UNKNOWN unk_101D5F3C; // weak
_UNKNOWN unk_101D5F84; // weak
_UNKNOWN unk_101D5FCC; // weak
_UNKNOWN unk_101D6014; // weak
_UNKNOWN unk_101D605C; // weak
_UNKNOWN unk_101D60A4; // weak
_UNKNOWN unk_101D60EC; // weak
_UNKNOWN unk_101D6134; // weak
_UNKNOWN unk_101D617C; // weak
_UNKNOWN unk_101D61C4; // weak
_UNKNOWN unk_101D620C; // weak
_UNKNOWN unk_101D6254; // weak
_UNKNOWN unk_101D629C; // weak
_UNKNOWN unk_101D62E4; // weak
_UNKNOWN unk_101D62FC; // weak
_UNKNOWN unk_101D631C; // weak
_UNKNOWN unk_101D633C; // weak
_UNKNOWN unk_101D6340; // weak
_UNKNOWN unk_101D63E4; // weak
_UNKNOWN unk_101D6488; // weak
_UNKNOWN unk_101D652C; // weak
_UNKNOWN unk_101D65D0; // weak
_UNKNOWN unk_101D6674; // weak
_UNKNOWN unk_101D6718; // weak
_UNKNOWN unk_101D67BC; // weak
_UNKNOWN unk_101D6860; // weak
_UNKNOWN unk_101D6904; // weak
_UNKNOWN unk_101D69A8; // weak
_UNKNOWN unk_101D6A4C; // weak
_UNKNOWN unk_101D6AF0; // weak
_UNKNOWN unk_101D6B94; // weak
_UNKNOWN unk_101D6C38; // weak
_UNKNOWN unk_101D6CDC; // weak
_UNKNOWN unk_101D6D80; // weak
_UNKNOWN unk_101D6E24; // weak
_UNKNOWN unk_101D6EC8; // weak
_UNKNOWN unk_101D6F6C; // weak
_UNKNOWN unk_101D7010; // weak
_UNKNOWN unk_101D70B4; // weak
_UNKNOWN unk_101D7158; // weak
_UNKNOWN unk_101D71FC; // weak
_UNKNOWN unk_101D72A0; // weak
_UNKNOWN unk_101D7344; // weak
_UNKNOWN unk_101D73E8; // weak
_UNKNOWN unk_101D748C; // weak
_UNKNOWN unk_101D7530; // weak
_UNKNOWN unk_101D75D4; // weak
_UNKNOWN unk_101D7678; // weak
_UNKNOWN unk_101D771C; // weak
_UNKNOWN unk_101D77C0; // weak
_UNKNOWN unk_101D7864; // weak
_UNKNOWN unk_101D7908; // weak
_UNKNOWN unk_101D79AC; // weak
_UNKNOWN unk_101D7A50; // weak
_UNKNOWN unk_101D7AF4; // weak
_UNKNOWN unk_101D7B98; // weak
_UNKNOWN unk_101D7C3C; // weak
_UNKNOWN unk_101D7CE0; // weak
_UNKNOWN unk_101D7D84; // weak
_UNKNOWN unk_101D7E28; // weak
_UNKNOWN unk_101D7ECC; // weak
_UNKNOWN unk_101D7F70; // weak
_UNKNOWN unk_101D8014; // weak
_UNKNOWN unk_101D80B8; // weak
_UNKNOWN unk_101D815C; // weak
_UNKNOWN unk_101D8200; // weak
_UNKNOWN unk_101D82A4; // weak
_UNKNOWN unk_101D8348; // weak
_UNKNOWN unk_101D83EC; // weak
_UNKNOWN unk_101D8490; // weak
_UNKNOWN unk_101D8534; // weak
_UNKNOWN unk_101D85D8; // weak
_UNKNOWN unk_101D867C; // weak
_UNKNOWN unk_101D8720; // weak
_UNKNOWN unk_101D87C4; // weak
_UNKNOWN unk_101D8868; // weak
_UNKNOWN unk_101D890C; // weak
_UNKNOWN unk_101D89B0; // weak
_UNKNOWN unk_101D8A54; // weak
_UNKNOWN unk_101D8AF8; // weak
_UNKNOWN unk_101D8B9C; // weak
_UNKNOWN unk_101D8C40; // weak
_UNKNOWN unk_101D8CE4; // weak
_UNKNOWN unk_101D8D88; // weak
_UNKNOWN unk_101D8E2C; // weak
_UNKNOWN unk_101D8ED0; // weak
_UNKNOWN unk_101D8F74; // weak
_UNKNOWN unk_101D9018; // weak
_UNKNOWN unk_101D90BC; // weak
_UNKNOWN unk_101D9160; // weak
_UNKNOWN unk_101D9204; // weak
_UNKNOWN unk_101D92A8; // weak
_UNKNOWN unk_101D934C; // weak
_UNKNOWN unk_101D93F0; // weak
_UNKNOWN unk_101D9494; // weak
_UNKNOWN unk_101D9538; // weak
_UNKNOWN unk_101D95DC; // weak
_UNKNOWN unk_101D9680; // weak
_UNKNOWN unk_101D9724; // weak
_UNKNOWN unk_101D97C8; // weak
_UNKNOWN unk_101D986C; // weak
_UNKNOWN unk_101D9910; // weak
_UNKNOWN unk_101D99B4; // weak
_UNKNOWN unk_101D9A58; // weak
_UNKNOWN unk_101D9AFC; // weak
_UNKNOWN unk_101D9BA0; // weak
_UNKNOWN unk_101D9C44; // weak
_UNKNOWN unk_101D9CE8; // weak
_UNKNOWN unk_101D9D8C; // weak
_UNKNOWN unk_101D9E30; // weak
_UNKNOWN unk_101D9ED4; // weak
_UNKNOWN unk_101D9F78; // weak
_UNKNOWN unk_101DA01C; // weak
_UNKNOWN unk_101DA0C0; // weak
_UNKNOWN unk_101DA164; // weak
_UNKNOWN unk_101DA208; // weak
_UNKNOWN unk_101DA2AC; // weak
_UNKNOWN unk_101DA350; // weak
_UNKNOWN unk_101DA370; // weak
_UNKNOWN unk_101DA390; // weak
_UNKNOWN unk_101DA3B0; // weak
_UNKNOWN unk_101DA3D0; // weak
_UNKNOWN unk_101DA3F8; // weak
_UNKNOWN unk_101DA414; // weak
_UNKNOWN unk_101DA430; // weak
_UNKNOWN unk_101DA44C; // weak
_UNKNOWN unk_101DA468; // weak
_UNKNOWN unk_101DA484; // weak
_UNKNOWN unk_101DA4A0; // weak
_UNKNOWN unk_101DA4BC; // weak
_UNKNOWN unk_101DA4D8; // weak
_UNKNOWN unk_101DA4F4; // weak
_UNKNOWN unk_101DA510; // weak
_UNKNOWN unk_101DA52C; // weak
_UNKNOWN unk_101DA548; // weak
_UNKNOWN unk_101DA564; // weak
_UNKNOWN unk_101DA580; // weak
_UNKNOWN unk_101DA59C; // weak
_UNKNOWN unk_101DA5B8; // weak
_UNKNOWN unk_101DA5D4; // weak
_UNKNOWN unk_101DA5F0; // weak
_UNKNOWN unk_101DA60C; // weak
_UNKNOWN unk_101DA628; // weak
_UNKNOWN unk_101DA644; // weak
_UNKNOWN unk_101DA660; // weak
_UNKNOWN unk_101DA67C; // weak
_UNKNOWN unk_101DA698; // weak
_UNKNOWN unk_101DA6B4; // weak
_UNKNOWN unk_101DA6D0; // weak
_UNKNOWN unk_101DA6EC; // weak
_UNKNOWN unk_101DA708; // weak
_UNKNOWN unk_101DA724; // weak
_UNKNOWN unk_101DA740; // weak
_UNKNOWN unk_101DA75C; // weak
_UNKNOWN unk_101DA778; // weak
_UNKNOWN unk_101DA794; // weak
_UNKNOWN unk_101DA7B0; // weak
_UNKNOWN unk_101DA7CC; // weak
_UNKNOWN unk_101DA7E8; // weak
_UNKNOWN unk_101DA804; // weak
_UNKNOWN unk_101DA820; // weak
_UNKNOWN unk_101DA83C; // weak
_UNKNOWN unk_101DA858; // weak
_UNKNOWN unk_101DA874; // weak
_UNKNOWN unk_101DA890; // weak
_UNKNOWN unk_101DA8AC; // weak
_UNKNOWN unk_101DA8C8; // weak
_UNKNOWN unk_101DA8E4; // weak
_UNKNOWN unk_101DA900; // weak
_UNKNOWN unk_101DA91C; // weak
_UNKNOWN unk_101DA938; // weak
_UNKNOWN unk_101DA954; // weak
_UNKNOWN unk_101DA970; // weak
_UNKNOWN unk_101DA98C; // weak
_UNKNOWN unk_101DA9A8; // weak
_UNKNOWN unk_101DA9C4; // weak
_UNKNOWN unk_101DA9E0; // weak
_UNKNOWN unk_101DA9FC; // weak
_UNKNOWN unk_101DAA18; // weak
_UNKNOWN unk_101DAA34; // weak
_UNKNOWN unk_101DAA50; // weak
_UNKNOWN unk_101DAA6C; // weak
_UNKNOWN unk_101DAA88; // weak
_UNKNOWN unk_101DAAA4; // weak
_UNKNOWN unk_101DAAC0; // weak
_UNKNOWN unk_101DAADC; // weak
_UNKNOWN unk_101DAAF8; // weak
_UNKNOWN unk_101DAB14; // weak
_UNKNOWN unk_101DAB30; // weak
_UNKNOWN unk_101DAB4C; // weak
_UNKNOWN unk_101DAB68; // weak
_UNKNOWN unk_101DAB84; // weak
_UNKNOWN unk_101DABA0; // weak
_UNKNOWN unk_101DABBC; // weak
_UNKNOWN unk_101DABD8; // weak
_UNKNOWN unk_101DABF4; // weak
_UNKNOWN unk_101DAC10; // weak
_UNKNOWN unk_101DAC2C; // weak
_UNKNOWN unk_101DAC48; // weak
_UNKNOWN unk_101DAC64; // weak
_UNKNOWN unk_101DAC80; // weak
_UNKNOWN unk_101DAC9C; // weak
_UNKNOWN unk_101DACB8; // weak
_UNKNOWN unk_101DACD4; // weak
_UNKNOWN unk_101DACF0; // weak
_UNKNOWN unk_101DAD0C; // weak
_UNKNOWN unk_101DAD28; // weak
_UNKNOWN unk_101DAD44; // weak
_UNKNOWN unk_101DAD60; // weak
_UNKNOWN unk_101DAD7C; // weak
_UNKNOWN unk_101DAD98; // weak
_UNKNOWN unk_101DADB4; // weak
_UNKNOWN unk_101DADD0; // weak
_UNKNOWN unk_101DADEC; // weak
_UNKNOWN unk_101DAE08; // weak
_UNKNOWN unk_101DAE24; // weak
_UNKNOWN unk_101DAE40; // weak
_UNKNOWN unk_101DAE5C; // weak
_UNKNOWN unk_101DAE78; // weak
_UNKNOWN unk_101DAE94; // weak
_UNKNOWN unk_101DAEB0; // weak
_UNKNOWN unk_101DAECC; // weak
_UNKNOWN unk_101DAEE8; // weak
_UNKNOWN unk_101DAEEC; // weak
_UNKNOWN unk_101DAEF0; // weak
_UNKNOWN unk_101DAEF4; // weak
_UNKNOWN unk_101DAEF8; // weak
_UNKNOWN unk_101DAEFC; // weak
_UNKNOWN unk_101DAF00; // weak
_UNKNOWN unk_101DAF04; // weak
_UNKNOWN unk_101DAF08; // weak
_UNKNOWN unk_101DAF0C; // weak
_UNKNOWN unk_101DAF10; // weak
_UNKNOWN unk_101DAF14; // weak
_UNKNOWN unk_101DAF18; // weak
_UNKNOWN unk_101DAF1C; // weak
_UNKNOWN unk_101DAF20; // weak
_UNKNOWN unk_101DAF24; // weak
_UNKNOWN unk_101DAF28; // weak
_UNKNOWN unk_101DAF2C; // weak
_UNKNOWN unk_101DAF30; // weak
_UNKNOWN unk_101DB014; // weak
_UNKNOWN unk_101DC1D4; // weak
_UNKNOWN unk_101DC1D8; // weak
_UNKNOWN unk_101DC200; // weak
_UNKNOWN unk_101DC228; // weak
_UNKNOWN unk_101DC268; // weak
_UNKNOWN unk_101DC2E8; // weak
_UNKNOWN unk_101DC2EC; // weak
_UNKNOWN unk_101DC2F0; // weak
_UNKNOWN unk_101DC2F2; // weak
_UNKNOWN unk_101DC2F4; // weak
_UNKNOWN unk_101DC2F5; // weak
_UNKNOWN unk_101DC2F6; // weak
_UNKNOWN unk_101DC2F8; // weak
_UNKNOWN unk_101DC35C; // weak
_UNKNOWN unk_101DC364; // weak
_UNKNOWN unk_101DC36C; // weak
_UNKNOWN unk_101DC374; // weak
_UNKNOWN unk_101DC37C; // weak
_UNKNOWN unk_101DC384; // weak
_UNKNOWN unk_101DC38C; // weak
_UNKNOWN unk_101DC394; // weak
_UNKNOWN unk_101DC39C; // weak
_UNKNOWN unk_101DC3A4; // weak
_UNKNOWN unk_101DC3AC; // weak
_UNKNOWN unk_101DC3B4; // weak
_UNKNOWN unk_101DC3BC; // weak
_UNKNOWN unk_101DC3C4; // weak
_UNKNOWN unk_101DC3CC; // weak
_UNKNOWN unk_101DC3D4; // weak
_UNKNOWN unk_101DC3DC; // weak
_UNKNOWN unk_101DC3E4; // weak
_UNKNOWN unk_101DC3EC; // weak
_UNKNOWN unk_101DC3F4; // weak
_UNKNOWN unk_101DC3FC; // weak
_UNKNOWN unk_101DC404; // weak
_UNKNOWN unk_101DC40C; // weak
_UNKNOWN unk_101DC414; // weak
_UNKNOWN unk_101DC41C; // weak
_UNKNOWN unk_101DC424; // weak
_UNKNOWN unk_101DC42C; // weak
_UNKNOWN unk_101DC434; // weak
_UNKNOWN unk_101DC43C; // weak
_UNKNOWN unk_101DC444; // weak
_UNKNOWN unk_101DC44C; // weak
_UNKNOWN unk_101DC454; // weak
_UNKNOWN unk_101DC45C; // weak
_UNKNOWN unk_101DC464; // weak
_UNKNOWN unk_101DC46C; // weak
_UNKNOWN unk_101DC474; // weak
_UNKNOWN unk_101DC47C; // weak
_UNKNOWN unk_101DC484; // weak
_UNKNOWN unk_101DC48C; // weak
_UNKNOWN unk_101DC494; // weak
_UNKNOWN unk_101DC67C; // weak
_UNKNOWN unk_101DC68C; // weak
_UNKNOWN unk_101DC69C; // weak
_UNKNOWN unk_101DC6AC; // weak
_UNKNOWN unk_101DC6AD; // weak
_UNKNOWN unk_101DC6AE; // weak
_UNKNOWN unk_101DC6B0; // weak
_UNKNOWN unk_101DC6B4; // weak
_UNKNOWN unk_101DC75C; // weak
_UNKNOWN unk_101DC760; // weak
_UNKNOWN unk_101DC764; // weak
_UNKNOWN unk_101DC7B4; // weak
_UNKNOWN unk_101DC7B8; // weak
_UNKNOWN unk_101DC7BC; // weak
_UNKNOWN unk_101DC8AC; // weak
_UNKNOWN unk_101DC99C; // weak
_UNKNOWN unk_101DC9A0; // weak
_UNKNOWN unk_101DC9A8; // weak
_UNKNOWN unk_101DC9B0; // weak
_UNKNOWN unk_101DC9B8; // weak
_UNKNOWN unk_101DC9C0; // weak
_UNKNOWN unk_101DC9C8; // weak
_UNKNOWN unk_101DC9D0; // weak
_UNKNOWN unk_101DC9D8; // weak
_UNKNOWN unk_101DC9E0; // weak
_UNKNOWN unk_101DC9E8; // weak
_UNKNOWN unk_101DC9F0; // weak
_UNKNOWN unk_101DC9F8; // weak
_UNKNOWN unk_101DC9FC; // weak
_UNKNOWN unk_101DCA00; // weak
_UNKNOWN unk_101DCA04; // weak
_UNKNOWN unk_101DCA58; // weak
_UNKNOWN unk_101DCAAC; // weak
_UNKNOWN unk_101DCAB4; // weak
_UNKNOWN unk_101DCAB8; // weak
_UNKNOWN unk_101DCABC; // weak
_UNKNOWN unk_101DCAC0; // weak
_UNKNOWN unk_101DCAC4; // weak
_UNKNOWN unk_101DCCCC; // weak
_UNKNOWN unk_101DCE2C; // weak
_UNKNOWN unk_101DCE44; // weak
_UNKNOWN unk_101DCE5C; // weak
_UNKNOWN unk_101DCE66; // weak
_UNKNOWN unk_101DCE68; // weak
_UNKNOWN unk_101DCE78; // weak
_UNKNOWN unk_101DCE7C; // weak
_UNKNOWN unk_101DCE80; // weak
_UNKNOWN unk_101DCE84; // weak
_UNKNOWN unk_101DCE85; // weak
_UNKNOWN unk_101DCE88; // weak
_UNKNOWN unk_101DCED8; // weak
_UNKNOWN unk_101DCEDC; // weak
_UNKNOWN unk_101DCEDD; // weak
_UNKNOWN unk_101DCEDE; // weak
_UNKNOWN unk_101DCEDF; // weak
_UNKNOWN unk_101DCEF3; // weak
_UNKNOWN unk_101DCEF4; // weak
_UNKNOWN unk_101DCEF5; // weak
_UNKNOWN unk_101DCEF6; // weak
_UNKNOWN unk_101DCEF8; // weak
_UNKNOWN unk_101DCF98; // weak
_UNKNOWN unk_101DCFE8; // weak
_UNKNOWN unk_101DCFEC; // weak
_UNKNOWN unk_101DCFF0; // weak
_UNKNOWN unk_101DCFF4; // weak
_UNKNOWN unk_101DCFF8; // weak
_UNKNOWN unk_101DCFFC; // weak
_UNKNOWN unk_101DD000; // weak
_UNKNOWN unk_101DD004; // weak
_UNKNOWN unk_101DD008; // weak
_UNKNOWN unk_101DD00C; // weak
_UNKNOWN unk_101DD010; // weak
_UNKNOWN unk_101DD014; // weak
_UNKNOWN unk_101DD018; // weak
_UNKNOWN unk_101DD158; // weak
_UNKNOWN unk_101DD164; // weak
_UNKNOWN unk_101DD1AC; // weak
_UNKNOWN unk_101DD1AD; // weak
_UNKNOWN unk_101DD1D8; // weak
_UNKNOWN unk_101DD208; // weak
_UNKNOWN unk_101DD230; // weak
_UNKNOWN unk_101DD234; // weak
_UNKNOWN unk_101DD238; // weak
_UNKNOWN unk_101DD23C; // weak
_UNKNOWN unk_101DD26C; // weak
_UNKNOWN unk_101DD26D; // weak
_UNKNOWN unk_101DD26E; // weak
_UNKNOWN unk_101DD270; // weak
_UNKNOWN unk_101DD274; // weak
_UNKNOWN unk_101DD278; // weak
_UNKNOWN unk_101DD27C; // weak
_UNKNOWN unk_101DD280; // weak
_UNKNOWN unk_101DD284; // weak
_UNKNOWN unk_101DD288; // weak
_UNKNOWN unk_101DD28C; // weak
_UNKNOWN unk_101DD290; // weak
_UNKNOWN unk_101DD294; // weak
_UNKNOWN unk_101DD5F4; // weak
_UNKNOWN unk_101DD5F8; // weak
_UNKNOWN unk_101DD602; // weak
_UNKNOWN unk_101DD60C; // weak
_UNKNOWN unk_101DEDC8; // weak
_UNKNOWN unk_101DEDD4; // weak
char byte_101DEDE0; // weak
char byte_101DEDE1; // weak
_UNKNOWN unk_101DEDE8; // weak
__int16 word_101DEE88; // weak
__int16 word_101DEE8C; // weak
__int16 word_101DEE90; // weak
_UNKNOWN unk_101DEE98; // weak
__int16 word_101DEF38; // weak
char byte_101DEF3C; // weak
_UNKNOWN unk_101DEF3D; // weak
char byte_101DEF3E; // weak
__int16 word_101DEF40; // weak
__int16 word_101DEF48[]; // weak
_UNKNOWN unk_101DEF69; // weak
int dword_101E058C[]; // weak
int dword_101E05A0; // weak
int dword_101E05A4; // weak
int dword_101E05B0; // weak
int dword_101E05B8; // weak
_UNKNOWN unk_101E05C0; // weak
char byte_101E0898[]; // weak
char byte_101E0899[]; // weak
char byte_101E08B8[]; // weak
char byte_101E08B9[]; // weak
_UNKNOWN unk_101E1B00; // weak
int dword_101E34B0; // weak
_UNKNOWN unk_101E34B8; // weak
_UNKNOWN unk_101E3B90; // weak
_UNKNOWN unk_101E4268; // weak
_UNKNOWN unk_101E4940; // weak
_UNKNOWN unk_101E5018; // weak
_UNKNOWN unk_101E56F0; // weak
_UNKNOWN unk_101E5DC8; // weak
_UNKNOWN unk_101E64A0; // weak
_UNKNOWN unk_101E6B78; // weak
_UNKNOWN unk_101E7250; // weak
_UNKNOWN unk_101E7928; // weak
_UNKNOWN unk_101E8000; // weak
_UNKNOWN unk_101E86D8; // weak
_UNKNOWN unk_101E8DB0; // weak
_UNKNOWN unk_101E9488; // weak
_UNKNOWN unk_101E9B60; // weak
_UNKNOWN unk_101EA238; // weak
_UNKNOWN unk_101EA910; // weak
_UNKNOWN unk_101EAFE8; // weak
_UNKNOWN unk_101EB6C0; // weak
_UNKNOWN unk_101EBD98; // weak
_UNKNOWN unk_101EC470; // weak
_UNKNOWN unk_101ECB48; // weak
_UNKNOWN unk_101ED220; // weak
_UNKNOWN unk_101ED8F8; // weak
_UNKNOWN unk_101EDFD0; // weak
_UNKNOWN unk_101EE6A8; // weak
_UNKNOWN unk_101EED80; // weak
_UNKNOWN unk_101EF458; // weak
_UNKNOWN unk_101EFB30; // weak
_UNKNOWN unk_101F0208; // weak
_UNKNOWN unk_101F08E0; // weak
_UNKNOWN unk_101F0FB8; // weak
_UNKNOWN unk_101F1690; // weak
_UNKNOWN unk_101F1D68; // weak
_UNKNOWN unk_101F2440; // weak
_UNKNOWN unk_101F2B18; // weak
_UNKNOWN unk_101F31F0; // weak
_UNKNOWN unk_101F38C8; // weak
_UNKNOWN unk_101F3FA0; // weak
_UNKNOWN unk_101F4678; // weak
_UNKNOWN unk_101F4D50; // weak
_UNKNOWN unk_101F5428; // weak
_UNKNOWN unk_101F5B00; // weak
_UNKNOWN unk_101F61D8; // weak
_UNKNOWN unk_101F68B0; // weak
_UNKNOWN unk_101F6F88; // weak
_UNKNOWN unk_101F7660; // weak
_UNKNOWN unk_101F7D38; // weak
_UNKNOWN unk_101F8410; // weak
_UNKNOWN unk_101F8AE8; // weak
_UNKNOWN unk_101F91C0; // weak
_UNKNOWN unk_101F9898; // weak
_UNKNOWN unk_101F9F70; // weak
_UNKNOWN unk_101FA648; // weak
_UNKNOWN unk_101FAD20; // weak
_UNKNOWN unk_101FB3F8; // weak
_UNKNOWN unk_101FBAD0; // weak
_UNKNOWN unk_101FC1A8; // weak
_UNKNOWN unk_101FC880; // weak
_UNKNOWN unk_101FCF58; // weak
_UNKNOWN unk_101FD630; // weak
_UNKNOWN unk_101FDD08; // weak
_UNKNOWN unk_101FE3E0; // weak
_UNKNOWN unk_101FEAB8; // weak
_UNKNOWN unk_101FF190; // weak
_UNKNOWN unk_101FF868; // weak
_UNKNOWN unk_101FFF40; // weak
_UNKNOWN unk_10200618; // weak
_UNKNOWN unk_10200CF0; // weak
_UNKNOWN unk_102013C8; // weak
_UNKNOWN unk_10201AA0; // weak
_UNKNOWN unk_10202178; // weak
_UNKNOWN unk_10202850; // weak
_UNKNOWN unk_10202F28; // weak
_UNKNOWN unk_10203600; // weak
_UNKNOWN unk_10203CD8; // weak
_UNKNOWN unk_102043B0; // weak
_UNKNOWN unk_10204A88; // weak
_UNKNOWN unk_10205160; // weak
_UNKNOWN unk_10205838; // weak
_UNKNOWN unk_10205F10; // weak
_UNKNOWN unk_102065E8; // weak
_UNKNOWN unk_10206CC0; // weak
_UNKNOWN unk_10207398; // weak
_UNKNOWN unk_10207A70; // weak
_UNKNOWN unk_10208148; // weak
_UNKNOWN unk_10208820; // weak
_UNKNOWN unk_10208EF8; // weak
_UNKNOWN unk_102095D0; // weak
_UNKNOWN unk_10209CA8; // weak
_UNKNOWN unk_1020A380; // weak
_UNKNOWN unk_1020AA58; // weak
_UNKNOWN unk_1020B130; // weak
_UNKNOWN unk_1020B808; // weak
_UNKNOWN unk_1020BEE0; // weak
_UNKNOWN unk_1020C5B8; // weak
_UNKNOWN unk_1020CC90; // weak
_UNKNOWN unk_1020D368; // weak
_UNKNOWN unk_1020DA40; // weak
_UNKNOWN unk_1020E118; // weak
int dword_1020FF50; // weak
_UNKNOWN unk_1020FF58; // weak
int dword_10211498; // weak
char byte_102114A0[]; // weak
char byte_102114A4[]; // weak
char byte_102114A5[]; // weak
int dword_102114AC[]; // weak
int dword_102114B4[]; // weak
int dword_102114E8[]; // weak
int dword_102114EC; // weak
int dword_102114F0; // weak
int dword_102114F4; // weak
int dword_102114F8; // weak
int dword_102114FC[]; // weak
int dword_10211500; // weak
int dword_10211504; // weak
int dword_10211508; // weak
int dword_1021150C; // weak
_UNKNOWN unk_10211510; // weak
int dword_10211628; // weak
int dword_1021162C; // weak
int dword_10211630; // weak
int dword_10211634; // weak
int dword_10211638; // weak
int dword_1021163C; // weak
int dword_10211640; // weak
int dword_10211644; // weak
int dword_10211648; // weak
int dword_1021164C; // weak
int dword_10211650; // weak
int dword_10211654; // weak
int dword_10211658; // weak
int dword_1021165C; // weak
char byte_10211660; // weak
int dword_10211664; // weak
int dword_10211668; // weak
int dword_1021166C; // weak
int dword_10211670; // weak
char byte_10211674; // weak
char byte_10211680[100]; // idb
char byte_102116E8; // idb
char byte_102117E8[254]; // idb
char byte_102118E6[]; // weak
char byte_102118E7[]; // weak
char byte_10211CE8[2800]; // idb
char byte_102127D8[1022]; // idb
char byte_10212BD6[]; // weak
char byte_10212BD7[]; // weak
char byte_10212BD8[1022]; // idb
char byte_10212FD6[]; // weak
char byte_10212FD7[]; // weak
char byte_10212FD8[1022]; // idb
char byte_102133D6[]; // weak
char byte_102133D7[]; // weak
int dword_102163D8[]; // weak
int dword_102163EC[]; // weak
char byte_10216400[2800]; // idb
char byte_10216EF0[2800]; // idb
char byte_102179E0[2800]; // idb
int dword_102184D0[]; // weak
int dword_102184E4[]; // weak
char byte_102184F8[2796]; // idb
char byte_10218FE4[]; // weak
char byte_10218FE8[559]; // idb
char byte_10219217[]; // weak
int dword_10219AD8[]; // weak
int dword_10219AEC[]; // weak
char byte_10219B00[2800]; // idb
int dword_1021A5F0; // weak
_UNKNOWN unk_1021A5F8; // weak
_UNKNOWN unk_1021B150; // weak
int dword_1021D4B4; // weak
int dword_1021D4B8; // weak
int dword_1021D4BC; // weak
int dword_1021D4C0; // weak
char byte_1021FD58[]; // weak
char byte_1021FD59[]; // weak
_UNKNOWN unk_1021FDF8; // weak
int dword_102200C8[]; // weak
int dword_102200CC[]; // weak
_UNKNOWN unk_102205E8; // weak
_UNKNOWN unk_102234F0; // weak
_UNKNOWN unk_102239F0; // weak
_UNKNOWN unk_10223A98; // weak
char byte_10223AB8; // weak
char byte_10223AB9; // weak
char byte_10223ABA; // weak
char byte_10223ABB; // weak
_UNKNOWN unk_10223AC0; // weak
_UNKNOWN unk_10223AE0; // weak
int dword_10283850; // weak
char byte_10283858[]; // weak
char byte_102838A8[]; // weak
_UNKNOWN unk_1028ABF8; // weak
_UNKNOWN unk_1028AC00; // weak
_UNKNOWN unk_1028AC08; // weak
char byte_1028CC10; // weak
char byte_1028CC11; // weak
int dword_1028DDD8; // weak
int dword_1028DDDC; // weak
int dword_1028DDE0; // weak
int dword_1028DDE4; // weak
int dword_1028DDE8; // weak
int dword_1028DDEC; // weak
int dword_10293670; // weak
int dword_1029F4A0; // weak
_DWORD dword_1029F4A8[16]; // idb
int dword_1029F4E8[]; // weak
int dword_1029F528; // weak
int dword_1029F530[]; // weak
char byte_102AC554; // weak
char byte_102AC555; // weak
int dword_102AC570; // weak
int dword_102AC574; // weak
int dword_102AC8A0; // weak
int dword_102AC8AC; // weak
int dword_102ACED0; // weak
int dword_102ACEDC; // weak
int dword_102ACEE8; // weak
int dword_102ACEEC; // weak
int dword_102ACEF0; // weak
int dword_102ACF0C; // weak
int dword_102ACF10; // weak
int dword_102ACF14; // weak
int dword_102ACF18; // weak
int dword_102ACF1C; // weak
int dword_102BA908; // weak
char byte_102BA90C; // weak
char byte_102BA90D; // weak
char byte_102BA90E; // weak
int dword_102BA920; // weak
_UNKNOWN unk_102BA924; // weak
char byte_1031E940; // weak
char byte_1031E941; // weak
char byte_1031E942; // weak
char byte_1031E944; // weak
char byte_1031E94B; // weak
__int16 word_1031E94E; // weak
__int16 word_1031E950; // weak
__int16 word_1031E954; // weak
int dword_1031E958; // weak
int dword_1031E95C; // weak
int dword_1031E974; // weak
int dword_1031E980; // weak
int dword_1031E988; // weak
char byte_1031EAC8; // weak
int dword_1031EB1C; // weak
char byte_1031EB20; // weak
int dword_1031EB40[]; // weak
_BYTE dword_1031EB44[1120]; // idb
int dword_1031EFA8; // weak
_UNKNOWN unk_1031EFAC; // weak
int dword_1031EFC0[]; // weak
char byte_1031EFC4[]; // weak
int dword_1031F1C0; // weak
int dword_1031F1C4; // weak
char byte_1031F1C8; // weak
int dword_1031F1CC; // weak
char byte_1031F1D0; // weak
int dword_1031F1D4; // weak
char byte_1031F1D8; // weak
int dword_1031F1DC; // weak
_UNKNOWN unk_1031F1E0; // weak
int dword_1031F1E4[]; // weak
char byte_1031F1F1[]; // weak
int dword_1031F2A8; // weak
int dword_1031F2AC; // weak
char byte_1031F2B0; // weak
int dword_1031F2C0[]; // weak
__int16 word_1031F2C4[]; // weak
int dword_1031F2C8[]; // weak
int dword_1031F2CC; // weak
int dword_1031F2D0; // weak
int dword_1031F2D4; // weak
int dword_1031F2D8; // weak
__int16 word_1031F2DC; // weak
int dword_1031F2E0; // weak
int dword_1031F2F0; // weak
__int16 word_1031F324; // weak
int dword_1031F328; // weak
int dword_1031F344; // weak
__int16 word_1031F348; // weak
int dword_1031F388; // weak
int dword_1031F3B8; // weak
__int16 word_1031F3FC; // weak
int dword_1031F400; // weak
int dword_1031F458; // weak
__int16 word_1031F45C; // weak
int dword_1031F470; // weak
__int16 word_1031F474; // weak
int dword_1031F47C; // weak
__int16 word_1031F480; // weak
int dword_1031F4A8; // weak
int dword_1031F4B4; // weak
int dword_1031F4C4; // weak
__int16 word_1031F4C8; // weak
int dword_1031F4D0; // weak
__int16 word_1031F4D4; // weak
int dword_1031F4DC; // weak
__int16 word_1031F4E0; // weak
int dword_1031F5E4; // weak
int dword_1031F65C; // weak
__int16 word_1031F660; // weak
_UNKNOWN unk_1031F9C8; // weak
_UNKNOWN unk_1031F9C9; // weak
char byte_1031F9CA; // weak
__int16 word_1031F9E0[]; // weak
__int16 word_1031F9E2; // weak
__int16 word_1031F9E4; // weak
__int16 word_1031F9E6; // weak
__int16 word_1031F9E8; // weak
__int16 word_1031F9EA; // weak
__int16 word_1031F9EC; // weak
__int16 word_1031F9EE; // weak
__int16 word_1031F9F0; // weak
__int16 word_1031F9F2; // weak
__int16 word_1031F9F4; // weak
__int16 word_1031F9F6; // weak
__int16 word_1031F9F8; // weak
__int16 word_1031F9FA; // weak
__int16 word_1031FA04; // weak
__int16 word_1031FA06; // weak
__int16 word_1031FA6A; // weak
char byte_1031FB0C; // weak
char byte_1031FB0D; // weak
int dword_1031FB10; // weak
char byte_1031FB14; // weak
int dword_1031FB18; // weak
int dword_1031FB20; // weak
int dword_1031FB24; // weak
int dword_1031FB28; // weak
int dword_1031FB2C; // weak
int dword_1031FB30; // weak
int dword_1031FB38; // weak
char byte_1031FB3C[]; // weak
int dword_1031FB40; // weak
int dword_1031FB44; // weak
int dword_1031FB60; // weak
void *dword_1031FB64; // idb
int dword_10320B80; // weak
UINT uNumber; // idb
int dword_10320BA0[]; // weak
int dword_10320CA0; // weak
int dword_10320CB8; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_1031EFA8;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 1031EFA8: using guessed type int dword_1031EFA8;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_1008C160(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 1008C120: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 1008C140: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1008C150: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 1008C350: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
int __cdecl sub_10001180(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_100010B0(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (100011B0) --------------------------------------------------------
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_10002840(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_1008C3B0();
        sub_1008C400(1);
        v6 = sub_1008C370(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = dword_101C5C70;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_1008C3B0();
      sub_1008C400(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_1008C370(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10051A40(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 101C5C70: using guessed type int dword_101C5C70;

//----- (100012F0) --------------------------------------------------------
char __cdecl sub_100012F0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10051A40(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = dword_101C5C70;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&dword_101C5C70 + 1);
      *(_DWORD *)(v7 + 8) = *(&dword_101C5C70 + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_1008EA70(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10051A40(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 1008C140: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 101C5C70: using guessed type int dword_101C5C70;

//----- (100014E0) --------------------------------------------------------
unsigned int sub_100014E0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // edx@3

  v0 = dword_1031EB44;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&unk_1031EFAC );
  do
  {
    v2 = dword_100B5B20[result];
    dword_1031EB40[2 * v2] = *(int *)((char *)&off_100B5B24 + result * 4);
    v3 = dword_100B5B28[result];
    result += 3;
    dword_1031EB44[2 * v2] = v3;
  }
  while ( result < 129 );
  return result * 4;
}
// 100B5B20: using guessed type int dword_100B5B20[];
// 100B5B24: using guessed type int (__cdecl *off_100B5B24)(int, int, int, int, int);
// 100B5B28: using guessed type int dword_100B5B28[];
// 1031EB40: using guessed type int dword_1031EB40[];
// 1031EB44: using guessed type int dword_1031EB44[];

//----- (10001530) --------------------------------------------------------
int __cdecl sub_10001530(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (10001550) --------------------------------------------------------
int __cdecl sub_10001550(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (10001580) --------------------------------------------------------
unsigned int sub_10001580()
{
  char *v0; // eax@1
  signed int v1; // esi@3
  void *v2; // ecx@3
  unsigned int result; // eax@4
  char v4; // dl@4

  byte_1031EB20 = 0;
  sub_10063B70(&unk_10167820);
  sub_1004C170(0);
  v0 = byte_1031EFC4;
  do
  {
    *((_DWORD *)v0 - 1) = sub_100233C0;
    *v0 = 0;
    v0 += 8;
  }
  while ( (signed int)v0 < (signed int)&dword_1031F1C4 );
  v1 = 24;
  v2 = &unk_100B4870;
  do
  {
    result = 8 * *(_BYTE *)v2;
    dword_1031EFC0[result / 4] = *((_DWORD *)v2 + 1);
    v4 = *((_BYTE *)v2 + 8);
    v2 = (char *)v2 + 12;
    --v1;
    byte_1031EFC4[result] = v4;
  }
  while ( v1 );
  return result;
}
// 100233C0: using guessed type int sub_100233C0();
// 1031EB20: using guessed type char byte_1031EB20;
// 1031EFC0: using guessed type int dword_1031EFC0[];
// 1031F1C4: using guessed type int dword_1031F1C4;

//----- (100015A0) --------------------------------------------------------
int __cdecl sub_100015A0(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10051A40(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_100027C0(a1, a3);
  *((_DWORD *)a2 + 14) = sub_100027C0(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_100027C0(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_100027C0(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10001630) --------------------------------------------------------
char __cdecl sub_10001630(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_1008C8B0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10051A40(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (100016A0) --------------------------------------------------------
char __cdecl sub_100016A0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_1008C8B0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10051A40(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10001710) --------------------------------------------------------
int sub_10001710()
{
  int result; // eax@1

  result = sub_1008C780();
  dword_10167828 = result;
  byte_10167824 = 0;
  return result;
}
// 10167824: using guessed type char byte_10167824;
// 10167828: using guessed type int dword_10167828;

//----- (10001730) --------------------------------------------------------
_DWORD *__cdecl sub_10001730(int a1)
{
  return sub_10063BB0(&unk_10167820, a1);
}

//----- (10001750) --------------------------------------------------------
unsigned int __cdecl sub_10001750(int a1, int a2, int a3)
{
  unsigned int result; // eax@1

  result = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (100017C0) --------------------------------------------------------
void __usercall sub_100017C0(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_1008C100();
    sub_1008C3B0();
    sub_1008C400(1);
    *(_DWORD *)(a1 + 28) = sub_1008C370(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    sub_1008C3B0();
    *(_DWORD *)(a1 + 24) = sub_1008C370(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (10001810) --------------------------------------------------------
char __usercall sub_10001810@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_102BA90E = *v1 == -32749;
  byte_1031EB20 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_1008CAC0(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_100641E0(v3) != 2 && v7 & 0x1C )
  {
    byte_102BA90E = 0;
    byte_1031EB20 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_10052250() )
  {
    byte_102BA90E = 0;
    byte_1031EB20 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_10063D60(a1, (char *)v5, (int)&unk_100EB2AC);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_10032190(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 1031EB20: using guessed type char byte_1031EB20;

//----- (100018F0) --------------------------------------------------------
void __usercall sub_100018F0(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_1008BF10(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_1008C060(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_1008BF10(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 1008C140: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (100019C0) --------------------------------------------------------
void __usercall sub_100019C0(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_1008EB80(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001A60) --------------------------------------------------------
int __usercall sub_10001A60@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_1008C060(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_1008BF10(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_100018F0(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_100019C0(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_1008C060(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 1008C130: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 1008C140: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1008C2E0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001C30) --------------------------------------------------------
char __thiscall sub_10001C30(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001C50) --------------------------------------------------------
signed int __cdecl sub_10001C50(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10001630(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10001630(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001DA0) --------------------------------------------------------
char __cdecl sub_10001DA0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001630(a1, (int)&v4, 8);
}

//----- (10001DD0) --------------------------------------------------------
char __cdecl sub_10001DD0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100016A0(a1, (int)&v4, 8);
}

//----- (10001E00) --------------------------------------------------------
char __cdecl sub_10001E00(unsigned int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0
  int v18; // [sp+0h] [bp-10h]@51

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10063B80((int *)&unk_10167820, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10032090(a1);
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001810(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10001550(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_10052250() != byte_10167824 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_10167824 = sub_10052250();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_100027C0(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_100B62F8, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        sub_10031FF0(a1);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001C30(a1) )
          (*(void (__cdecl **)(unsigned int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            nullsub_1(a1, v18);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002420(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001DA0(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 1008C3A0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 10167824: using guessed type char byte_10167824;

//----- (10002130) --------------------------------------------------------
int __usercall sub_10002130@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_1008C730(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_1008C730(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001E00(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001A60(v1, (int)&dword_101C5C70);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 101C5C70: using guessed type int dword_101C5C70;

//----- (100021C0) --------------------------------------------------------
void __usercall __noreturn sub_100021C0(char *a1@<edi>)
{
  void *v1; // ecx@8
  unsigned int v2; // esi@16
  int v3; // eax@19
  int v4; // [sp+10h] [bp-ECh]@1
  char v5; // [sp+14h] [bp-E8h]@9
  char v6; // [sp+18h] [bp-E4h]@5

  dword_1031EB1C = (int)&dword_102BA920;
  sub_1008C990(&v4);
  if ( !(v4 & 0x10) )
    sub_10051A40(".\\cdp_main.c", 403, 1, 0);
  v4 |= 0x10u;
  if ( !sub_1008C920(1, 20000) )
    sub_10051A40(".\\cdp_main.c", 428, 1, 0);
  sub_100330C0();
  sub_10064300(&v6);
  sub_1008CCD0();
  while ( 1 )
  {
    byte_1031EAC8 = 0;
    if ( v4 & 0x10 || v4 & 0x8000 )
    {
      sub_10001550((int)&byte_1031E940);
      byte_1031E942 = sub_100521D0(v1);
      byte_1031E944 = 0;
      dword_1031E974 = (int)&unk_10167830;
      word_1031E94E = 0;
      word_1031E950 = 0;
      dword_1031E980 = 5;
      word_1031E954 = 125;
      dword_1031E958 = -1;
      dword_1031E95C = -1;
      byte_1031E94B = 1;
      dword_1031E988 = 0;
      byte_1031E940 = 0;
      while ( sub_1008C730(dword_1031E974, (int)&v5) != 1 )
        ;
      sub_100014D0();
      sub_100027A0((int)&byte_1031E940);
      sub_100320E0((int)a1, (int)&byte_1031E940);
      sub_10064720((int)&unk_100B62D0);
      sub_10064710((int)&unk_100B62D8);
      sub_100017C0((int)&byte_1031E940);
      sub_10032220((unsigned int)&byte_1031E940);
    }
    if ( v4 & 2 )
      sub_10002130((unsigned int)&byte_1031E940);
    if ( v4 & 1 )
    {
      v4 |= 0x20000000u;
      if ( (unsigned int)(sub_1008C780() - dword_10167828) >= 0x3E8 )
      {
        dword_10167828 += 1000;
        j_nullsub_1(&byte_1031E940);
        sub_100641F0((int *)&v6);
      }
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v4 )
      {
        v3 = sub_10063E10(v2);
        sub_10001C50((int)&byte_1031E940, v3);
        sub_10002130((unsigned int)&byte_1031E940);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_1031EAC8 || byte_1031E941 )
    {
      a1 = &byte_1031E940;
      sub_10001A60((int)&byte_1031E940, (int)&dword_101C5C70);
    }
    sub_1008C990(&v4);
  }
}
// 100014D0: using guessed type int sub_100014D0(void);
// 100330C0: using guessed type int sub_100330C0(void);
// 10064700: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 10167828: using guessed type int dword_10167828;
// 101C5C70: using guessed type int dword_101C5C70;
// 102BA920: using guessed type int dword_102BA920;
// 1031E940: using guessed type char byte_1031E940;
// 1031E941: using guessed type char byte_1031E941;
// 1031E942: using guessed type char byte_1031E942;
// 1031E944: using guessed type char byte_1031E944;
// 1031E94B: using guessed type char byte_1031E94B;
// 1031E94E: using guessed type __int16 word_1031E94E;
// 1031E950: using guessed type __int16 word_1031E950;
// 1031E954: using guessed type __int16 word_1031E954;
// 1031E958: using guessed type int dword_1031E958;
// 1031E95C: using guessed type int dword_1031E95C;
// 1031E974: using guessed type int dword_1031E974;
// 1031E980: using guessed type int dword_1031E980;
// 1031E988: using guessed type int dword_1031E988;
// 1031EAC8: using guessed type char byte_1031EAC8;
// 1031EB1C: using guessed type int dword_1031EB1C;

//----- (10002400) --------------------------------------------------------
int __cdecl sub_10002400(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002420) --------------------------------------------------------
char __cdecl sub_10002420(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_102BA924 || a2 >= dword_102BA920 )
    result = sub_10051A40(".\\cdp_mem.c", 222, 1, 0);
  dword_102BA920 = a2;
  return result;
}
// 102BA920: using guessed type int dword_102BA920;

//----- (10002460) --------------------------------------------------------
char sub_10002460()
{
  char result; // al@1

  byte_10167900 = 0;
  result = sub_1008C680((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_10167900 = 1;
  return result;
}
// 10167900: using guessed type char byte_10167900;

//----- (10002480) --------------------------------------------------------
char __thiscall sub_10002480(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_1008C7A0((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10064B00(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_1008C680((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_1008C4F0(v1, &byte_10167908, 4096),
          sub_1008C420(v2),
          (v1 = (unsigned int)strstr(&byte_10167908, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_10167908;
      v4 = v1 - (_DWORD)&byte_10167908 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((word_100ECF98[2 * (unsigned __int8)*(&byte_10167908 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_10167908 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_10168908 = v1;
    }
    else
    {
      dword_10168908 = 0;
    }
  }
  else
  {
    dword_10168908 = 0;
  }
  return v1;
}
// 1008C4E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10168908: using guessed type int dword_10168908;

//----- (100025F0) --------------------------------------------------------
void *__usercall sub_100025F0@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_10168908 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_10168908 = v3;
    sub_1008C7A0((int)&v10, 1, v5, 20);
    sub_10064B00(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_100649E0((int)&byte_10167908, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x64000 )
    {
      sub_100649E0((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_10064B30(&byte_10167908, &v12, 4096);
    }
    sub_10064B00(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 409600);
    result = (void *)sub_10064B30(&byte_10167908, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_10002900((int)i, (__int16 *)&v9, &v11);
      sub_10064B00(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_10064B30(&byte_10167908, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_10064A30(&byte_10167908, 0x1000u);
        j_FIL_vfs_write(v6, &byte_10167908, v8);
        sub_1008C630(v6, v8, 0);
        result = (void *)sub_1008C420(v6);
      }
    }
  }
  return result;
}
// 1008C4E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10168908: using guessed type int dword_10168908;

//----- (100027A0) --------------------------------------------------------
char __cdecl sub_100027A0(int a1)
{
  char result; // al@2

  dword_102BA920 = (int)&unk_102BA924;
  if ( byte_10167900 )
    result = sub_10002480(a1);
  return result;
}
// 10167900: using guessed type char byte_10167900;
// 102BA920: using guessed type int dword_102BA920;

//----- (100027C0) --------------------------------------------------------
int __cdecl sub_100027C0(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_10167900 )
    sub_100025F0(dword_102BA920 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_102BA920, dword_102BA920 + 4 * v2 > *(_DWORD *)(a1 + 476) + 409604) )
  {
    sub_10051A40(".\\cdp_mem.c", 371, 1, 0);
    result = dword_102BA920;
  }
  dword_102BA920 = result + 4 * v2;
  return result;
}
// 10167900: using guessed type char byte_10167900;
// 102BA920: using guessed type int dword_102BA920;

//----- (10002840) --------------------------------------------------------
int __cdecl sub_10002840(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10002400(a2, a3);
  return sub_100027C0(a1, v3);
}

//----- (10002880) --------------------------------------------------------
__int16 __cdecl sub_10002880(unsigned __int8 a1)
{
  return *(_WORD *)(dword_102BA908 + 4 * (unsigned __int8)byte_10168910[a1] + 2);
}
// 102BA908: using guessed type int dword_102BA908;

//----- (100028A0) --------------------------------------------------------
char __cdecl sub_100028A0(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_10064B90(a1);
  if ( v1 == -1 )
    sub_10051A40(".\\cdp_page_list.c", 705, 1, 0);
  return byte_100C7138[56 * v1];
}

//----- (100028E0) --------------------------------------------------------
char __cdecl sub_100028E0(int (__cdecl *a1)(int))
{
  return *(_BYTE *)(dword_102BA908 + 4 * (unsigned __int8)byte_10168910[(unsigned __int8)sub_100028A0(a1)] + 1);
}
// 102BA908: using guessed type int dword_102BA908;

//----- (10002900) --------------------------------------------------------
char __cdecl sub_10002900(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_10064B90(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_10002880(byte_100C7138[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = (char *)&unk_100C7139 + v3;
    do
    {
      v7 = *v6;
      v6[a3 - ((char *)&unk_100C7139 + v3)] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (10002980) --------------------------------------------------------
char __usercall sub_10002980@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
  signed int v3; // eax@1
  signed int v4; // esi@3
  char *v5; // edi@3
  int v6; // eax@4
  int v7; // eax@8
  char *v8; // esi@8
  int v9; // ecx@9
  signed int v10; // edi@13
  int (__cdecl **v11)(int); // ebp@13
  int v12; // ST0C_4@15
  int v14; // [sp-Eh] [bp-10h]@3
  int v15; // [sp-2h] [bp-4h]@1

  v15 = a1;
  dword_102BA908 = (int)byte_100C712C;
  dword_10168918 = 0;
  BYTE3(v15) = 0;
  byte_10168912 = 1;
  v3 = 0;
  do
  {
    byte_10168910[(unsigned __int8)byte_100C712C[4 * v3]] = v3;
    ++v3;
  }
  while ( v3 <= 1 );
  v4 = 0;
  v14 = a2;
  v5 = byte_100C7138;
  memset(&unk_10168928, 1, 1u);
  do
  {
    LOBYTE(v6) = *v5;
    if ( (unsigned __int8)*v5 < 1u )
    {
      v6 = (unsigned __int8)v6;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v6 + 3) )
      {
        word_10168914[v6] = v4;
        *((_BYTE *)&v15 + (unsigned __int8)v6 + 3) = 1;
      }
    }
    ++v4;
    v5 += 56;
  }
  while ( v4 < 1 );
  dword_1016891C = (int)*(&off_100C7134 + 14 * (unsigned __int16)word_10168914[0]);
  v7 = 0;
  BYTE3(v15) = 0;
  v8 = byte_100C7138;
  do
  {
    LOBYTE(v9) = *v8;
    if ( (unsigned __int8)*v8 < 1u )
    {
      v9 = (unsigned __int8)v9;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v9 + 3) )
      {
        word_10168920[v9] = v7;
        *((_BYTE *)&v15 + (unsigned __int8)v9 + 3) = 1;
      }
    }
    --v7;
    v8 -= 56;
  }
  while ( v7 >= 0 );
  sub_10032210();
  sub_10002AE0(a3);
  sub_10031FF0(a3);
  v10 = 0;
  v11 = &off_100C7134;
  do
  {
    (*v11)(a3);
    ++v10;
    v11 += 14;
  }
  while ( v10 < 1 );
  nullsub_1(a3, v14);
  nullsub_1(a3, v12);
  return sub_10002420(0, *(_DWORD *)(a3 + 56));
}
// 10002980: could not find valid save-restore pair for edi
// 100C7134: using guessed type int (__cdecl *off_100C7134)(int);
// 10168912: using guessed type char byte_10168912;
// 10168914: using guessed type __int16 word_10168914[];
// 10168918: using guessed type int dword_10168918;
// 1016891C: using guessed type int dword_1016891C;
// 10168920: using guessed type __int16 word_10168920[];
// 102BA908: using guessed type int dword_102BA908;

//----- (10002AE0) --------------------------------------------------------
_WORD *__cdecl sub_10002AE0(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_100027C0(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_100B62F8, 0x14Cu);
  sub_100015A0(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1008F780(a1 + 392, (int)&dword_101C5C70, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1008F720(a1 + 392);
}
// 101C5C70: using guessed type int dword_101C5C70;

//----- (10002B50) --------------------------------------------------------
int __cdecl sub_10002B50(int a1)
{
  unsigned int v1; // eax@1

  v1 = *(_BYTE *)dword_1031FB44;
  if ( v1 >= 0x3F )
    LOBYTE(v1) = 63;
  return ((int (__cdecl *)(int, _DWORD, _DWORD))dword_1031EFC0[2 * (unsigned __int8)v1])(a1, 0, 0);
}
// 1031EFC0: using guessed type int dword_1031EFC0[];
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10002B80) --------------------------------------------------------
bool __cdecl sub_10002B80(char a1)
{
  bool v1; // zf@6
  bool v2; // bl@8
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+10h] [bp-14h]@1

  v6 = 1;
  v7 = 0;
  LOBYTE(v5) = 67;
  v4 = 2;
  if ( a1 )
  {
    if ( a1 == 2 )
      LOBYTE(v5) = 7;
  }
  else
  {
    LOBYTE(v5) = 6;
  }
  sub_10065D40(a1, &v4);
  sub_10065C60(v5, 1, 9, (int)&v6, (int)&v7, 16);
  if ( v7 == 3 )
    v1 = v4 == 0;
  else
    v1 = v4 == 1;
  v2 = v1;
  if ( !v1 )
    sub_10051A40(
      ".\\cdp_pg_eis_cessna_172_3d.c",
      1181,
      0,
      "Fuel sensor calibration does not match fuel sensor configuration");
  return v2;
}

//----- (10002C30) --------------------------------------------------------
int __usercall sub_10002C30@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  void *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int result; // eax@6
  int v6; // [sp+10h] [bp-14h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = &unk_100B8C50;
  v3 = v1 + 200;
  do
  {
    v4 = *(float *)v2;
    v2 = (char *)v2 + 4;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)".\\cdp_pg_eis_cessna_172_3d.c" );
  *(_DWORD *)(v1 + 43792) = 2;
  *(float *)(v1 + 43784) = 0.0;
  *(_DWORD *)(v1 + 43800) = 0;
  *(float *)(v1 + 43788) = 0.0;
  *(_DWORD *)(v1 + 43804) = -1;
  *(float *)(v1 + 43796) = 12.0;
  *(float *)(v1 + 43808) = 0.5;
  *(float *)(v1 + 43812) = 1.0;
  *(float *)(v1 + 43816) = 40.0;
  *(_BYTE *)(v1 + 20830) = sub_1004BEE0(v2);
  *(_BYTE *)(v1 + 2420) = 1;
  *(float *)(v1 + 32884) = 9.8999998e24;
  *(float *)(v1 + 32888) = 9.8999998e24;
  *(float *)(v1 + 32892) = 9.8999998e24;
  *(float *)(v1 + 32896) = 9.8999998e24;
  *(_BYTE *)(v1 + 32264) = 0;
  sub_10061B00(v1 + 32904, (int)"RPM", dword_1031FB44 + 4076, 10.0, 5.0, 127.0, 127.0);
  *(float *)(v1 + 33124) = 158.0;
  *(_DWORD *)(v1 + 34980) = 54;
  *(float *)(v1 + 33128) = 382.0;
  *(float *)(v1 + 33228) = 224.0;
  *(float *)(v1 + 35204) = 73.0;
  *(float *)(v1 + 35208) = 88.0;
  *(float *)(v1 + 35244) = 23.0;
  *(float *)(v1 + 35236) = 0.5;
  *(float *)(v1 + 33004) = 73.0;
  *(float *)(v1 + 33008) = 80.0;
  *(float *)(v1 + 33052) = 9.0;
  *(float *)(v1 + 33044) = 0.5;
  *(float *)(v1 + 32940) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 32904);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 32904);
  v6 = v1 + 32904;
  if ( *(_BYTE *)dword_1031FB44 == 14 )
    sub_100612A0((int)&unk_100B8840, 2, 0.0, v6);
  else
    sub_100612A0((int)&unk_100B8860, 2, 0.0, v6);
  sub_10060F20(v1 + 196, 1, v1 + 32904);
  *(_WORD *)(v1 + 38462) = 6;
  *(_BYTE *)(v1 + 38468) = 1;
  *(_DWORD *)(v1 + 38464) = &unk_100B8DC0;
  qmemcpy((void *)(v1 + 38500), (const void *)(dword_1031FB44 + 4076), 0xA4u);
  sub_1004A1A0(v1 + 10612, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 152.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4240, 0.40000001, 0.0, v1 + 10612);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 10612);
  sub_10049040(v1 + 208, 1, 0, v1 + 10612);
  sub_10049310((int)&unk_100B8880, 0xBu, 0, v1 + 10612);
  *(float *)(v1 + 10676) = 73.5;
  *(float *)(v1 + 10716) = 0.5;
  *(_WORD *)(v1 + 14924) = 33;
  *(_BYTE *)(v1 + 14932) = 1;
  *(_DWORD *)(v1 + 14928) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 11126) = 2;
  sub_1004A1A0(v1 + 22056, (int)"OIL PRES", dword_1031FB44 + 4404, 10.0, 212.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 22056);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 22056);
  sub_10049310((int)&unk_100B8930, 2u, 0, v1 + 22056);
  sub_10049040(v1 + 220, 1, 0, v1 + 22056);
  *(float *)(v1 + 22120) = 73.5;
  *(float *)(v1 + 22160) = 0.5;
  *(_WORD *)(v1 + 26368) = 15;
  *(_BYTE *)(v1 + 26376) = 1;
  *(_DWORD *)(v1 + 26372) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 22570) = 2;
  sub_1004A1A0(v1 + 27160, (int)"OIL TEMP", dword_1031FB44 + 4568, 10.0, 272.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 27160);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 27160);
  sub_10049310((int)&unk_100B8950, 2u, 0, v1 + 27160);
  sub_10049040(v1 + 232, 1, 0, v1 + 27160);
  *(float *)(v1 + 27224) = 73.5;
  *(float *)(v1 + 27264) = 0.5;
  *(_WORD *)(v1 + 31472) = 10;
  *(_BYTE *)(v1 + 31480) = 1;
  *(_DWORD *)(v1 + 31476) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 27674) = 2;
  sub_1004A1A0(v1 + 4896, (int)"EGT", dword_1031FB44 + 5224, 10.0, 332.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 5224, 0.40000001, 0.0, v1 + 4896);
  sub_100490F0(dword_1031FB44 + 20704, v1 + 4896);
  sub_10049310((int)&unk_100B8970, 9u, 0, v1 + 4896);
  sub_10049040(v1 + 244, 1, 0, v1 + 4896);
  *(float *)(v1 + 4960) = 73.5;
  *(float *)(v1 + 5000) = 0.5;
  *(_WORD *)(v1 + 9208) = 10;
  *(_BYTE *)(v1 + 9216) = 1;
  *(_DWORD *)(v1 + 9212) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 5410) = 2;
  sub_1004A1A0(v1 + 39292, (int)"VAC", dword_1031FB44 + 6044, 10.0, 392.0, 127.0, 18.5, 0);
  sub_10049310((int)&unk_100B8A80, 2u, 0, v1 + 39292);
  sub_10049040(v1 + 508, 1, 0, v1 + 39292);
  *(float *)(v1 + 39356) = 73.5;
  *(float *)(v1 + 39396) = 0.5;
  *(_WORD *)(v1 + 43604) = 15;
  *(_BYTE *)(v1 + 43612) = 1;
  *(_DWORD *)(v1 + 43608) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 39806) = 2;
  sub_1004A1E0(v1 + 15112, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 455.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100B8A00, 8u, 0, v1 + 15112);
  sub_10049040(v1 + 256, 2, 0, v1 + 15112);
  *(float *)(v1 + 15572) = 26.0;
  *(float *)(v1 + 15636) = 26.0;
  *(_WORD *)(v1 + 19424) = 31;
  *(_BYTE *)(v1 + 19432) = 1;
  *(_DWORD *)(v1 + 19428) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 15626) = 0;
  *(_BYTE *)(v1 + 15690) = 0;
  sub_10046920(v1 + 9388, (int)"ENG HRS", dword_1031FB44 + 5880, 10.0, 537.0, 127.0, 15.0);
  *(_WORD *)(v1 + 9904) = 39;
  *(_BYTE *)(v1 + 9912) = 1;
  *(_DWORD *)(v1 + 9908) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 9436) = v1 + 504;
  sub_10046920(v1 + 21444, (int)byte_100B8180, dword_1031FB44 + 5388, -109.0, 620.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 21444);
  *(float *)(v1 + 21504) = 0.5;
  *(_WORD *)(v1 + 21960) = 21;
  *(_BYTE *)(v1 + 21968) = 1;
  *(_DWORD *)(v1 + 21964) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 21492) = v1 + 288;
  *(_BYTE *)(v1 + 21619) = 1;
  sub_10046920(v1 + 2424, (int)byte_100B8180, dword_1031FB44 + 5388, -12.0, 620.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 2424);
  *(float *)(v1 + 2484) = 0.5;
  *(_WORD *)(v1 + 2940) = 21;
  *(_BYTE *)(v1 + 2948) = 1;
  *(_DWORD *)(v1 + 2944) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 2472) = v1 + 300;
  *(_BYTE *)(v1 + 2599) = 1;
  sub_10046920(v1 + 20832, (int)byte_100B8180, dword_1031FB44 + 5552, -109.0, 675.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20760, v1 + 20832);
  *(_WORD *)(v1 + 21348) = 24;
  *(_BYTE *)(v1 + 21356) = 1;
  *(float *)(v1 + 20892) = 0.5;
  *(_DWORD *)(v1 + 21352) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 20880) = v1 + 312;
  *(_BYTE *)(v1 + 21007) = 1;
  sub_10046920(v1 + 38676, (int)byte_100B8180, dword_1031FB44 + 5716, -13.0, 675.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20788, v1 + 38676);
  *(float *)(v1 + 38736) = 0.5;
  *(_WORD *)(v1 + 39192) = 24;
  *(_BYTE *)(v1 + 39200) = 1;
  *(_DWORD *)(v1 + 39196) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 38724) = v1 + 324;
  *(_BYTE *)(v1 + 38851) = 1;
  sub_10046920(v1 + 10000, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 563.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20536, v1 + 10000);
  *(_WORD *)(v1 + 10516) = 33;
  *(_BYTE *)(v1 + 10524) = 1;
  *(_DWORD *)(v1 + 10520) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 10048) = v1 + 336;
  sub_10046920(v1 + 32272, (int)"PEAK", dword_1031FB44 + 6536, 10.0, 320.0, 127.0, 15.0);
  *(_WORD *)(v1 + 32788) = 11;
  *(_BYTE *)(v1 + 32796) = 1;
  *(_DWORD *)(v1 + 32792) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 32320) = v1 + 348;
  *(float *)(v1 + 32300) = *(float *)(v1 + 32300) - 15.0;
  *(_WORD *)(v1 + 32568) = 18065;
  *(_BYTE *)(v1 + 32570) = 0;
  *(float *)(v1 + 32552) = 122.0;
  sub_100483D0(v1 + 3036, (int)"EGT", dword_1031FB44 + 5224, 10.0, 147.0, 127.0, 106.0, 4);
  sub_10047B10(v1 + 352, 4, 1, v1 + 3036);
  *(_BYTE *)(v1 + 3996) = 1;
  *(_BYTE *)(v1 + 3997) = 1;
  *(_WORD *)(v1 + 4000) = 10;
  *(_BYTE *)(v1 + 3998) = -1;
  *(float *)(v1 + 3144) = 288.0;
  *(float *)(v1 + 3180) = 0.0;
  *(float *)(v1 + 3184) = 1.0;
  *(_BYTE *)(v1 + 3136) = 16;
  *(_DWORD *)(v1 + 3112) = v1 + 32884;
  *(_DWORD *)(v1 + 3116) = v1 + 32888;
  *(_DWORD *)(v1 + 3120) = v1 + 32892;
  *(_DWORD *)(v1 + 3124) = v1 + 32896;
  sub_10046920(v1 + 4284, (int)"EGT F", dword_1031FB44 + 5224, 10.0, 290.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20704, v1 + 4284);
  *(_WORD *)(v1 + 4800) = 10;
  *(_BYTE *)(v1 + 4808) = 1;
  *(_DWORD *)(v1 + 4804) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 4332) = v1 + 408;
  sub_100483D0(v1 + 560, (int)"CHT", dword_1031FB44 + 4732, 10.0, 375.0, 127.0, 91.0, 4);
  sub_10047B10(v1 + 412, 4, 1, v1 + 560);
  *(_BYTE *)(v1 + 1520) = 1;
  *(_BYTE *)(v1 + 1521) = 1;
  *(_WORD *)(v1 + 1524) = 10;
  *(_BYTE *)(v1 + 1522) = -1;
  *(float *)(v1 + 668) = 501.0;
  *(float *)(v1 + 704) = 0.0;
  *(float *)(v1 + 708) = 1.0;
  *(_BYTE *)(v1 + 660) = 12;
  sub_10046920(v1 + 1808, (int)"CHT F", dword_1031FB44 + 4732, 10.0, 503.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20620, v1 + 1808);
  *(_WORD *)(v1 + 2324) = 10;
  *(_BYTE *)(v1 + 2332) = 1;
  *(_DWORD *)(v1 + 2328) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 1856) = v1 + 468;
  sub_10046920(v1 + 26548, (int)"OIL PSI", dword_1031FB44 + 4404, 10.0, 202.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20564, v1 + 26548);
  *(_WORD *)(v1 + 27064) = 15;
  *(_BYTE *)(v1 + 27072) = 1;
  *(_DWORD *)(v1 + 27068) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 26596) = v1 + 480;
  sub_10046920(v1 + 31652, (int)"OIL F", dword_1031FB44 + 4568, 10.0, 242.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20592, v1 + 31652);
  *(_WORD *)(v1 + 32168) = 10;
  *(_BYTE *)(v1 + 32176) = 1;
  *(_DWORD *)(v1 + 32172) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 31700) = v1 + 492;
  sub_10046920(v1 + 20216, (int)"GAL USED", dword_1031FB44 + 6208, 10.0, 377.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20872, v1 + 20216);
  *(_WORD *)(v1 + 20732) = 31;
  *(_BYTE *)(v1 + 20740) = 1;
  *(_DWORD *)(v1 + 20736) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 20264) = v1 + 528;
  result = sub_10046920(v1 + 19604, (int)"GAL REM", dword_1031FB44 + 6372, 10.0, 422.0, 127.0, 15.0);
  *(_WORD *)(v1 + 20120) = 30;
  *(_BYTE *)(v1 + 20128) = 1;
  *(_DWORD *)(v1 + 20124) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 19652) = v1 + 540;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10003AF0) --------------------------------------------------------
signed int __cdecl sub_10003AF0(int a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  signed int result; // eax@1
  int v4; // edi@1
  __int16 v5; // fps@52
  bool v6; // c0@52
  char v7; // c2@52
  bool v8; // c3@52
  double v9; // st7@53
  __int16 v10; // fps@53
  double v11; // st6@53
  bool v12; // c0@53
  char v13; // c2@53
  bool v14; // c3@53
  int v15; // ecx@59
  __int16 v16; // [sp+Ch] [bp-1Ch]@1
  int v17; // [sp+10h] [bp-18h]@1
  char v18; // [sp+14h] [bp-14h]@1
  int v19; // [sp+18h] [bp-10h]@1
  int v20; // [sp+1Ch] [bp-Ch]@1
  char v21; // [sp+20h] [bp-8h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v17 = 0;
  v16 = -32713;
  v18 = 9;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  result = sub_10052230(v1) != 1 ? 9 : 14;
  v4 = result;
  if ( 9.8999998e24 != *(float *)(v2 + 204) && *(float *)(dword_1031FB44 + 28) < (double)*(float *)(v2 + 204) )
  {
    if ( !*(_BYTE *)(v2 + 38664) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(result, (int)&v16, 10, 1);
    }
    LOBYTE(v19) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 228)
    && (*(float *)(v2 + 22428) >= (double)*(float *)(v2 + 228) || *(float *)(v2 + 22452) < (double)*(float *)(v2 + 228)) )
  {
    if ( !*(_BYTE *)(v2 + 38665) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE1(v19) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 240) && *(float *)(v2 + 27548) <= (double)*(float *)(v2 + 240) )
  {
    if ( !*(_BYTE *)(v2 + 38666) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE2(v19) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 264) && *(float *)(v2 + 15492) >= (double)*(float *)(v2 + 264) )
  {
    if ( !*(_BYTE *)(v2 + 38667) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE3(v19) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 276) && *(float *)(v2 + 15492) >= (double)*(float *)(v2 + 276) )
  {
    if ( !*(_BYTE *)(v2 + 38668) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    LOBYTE(v20) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 288)
    && (*(float *)(v2 + 21880) >= (double)*(float *)(v2 + 288) || *(float *)(v2 + 21888) < (double)*(float *)(v2 + 288)) )
  {
    if ( !*(_BYTE *)(v2 + 38669) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE1(v20) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 300)
    && (*(float *)(v2 + 2860) >= (double)*(float *)(v2 + 300) || *(float *)(v2 + 2868) < (double)*(float *)(v2 + 300)) )
  {
    if ( !*(_BYTE *)(v2 + 38670) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE2(v20) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 312) && *(float *)(v2 + 21268) >= (double)*(float *)(v2 + 312) )
  {
    if ( !*(_BYTE *)(v2 + 38671) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    BYTE3(v20) = 1;
  }
  v6 = 9.8999998e24 < *(float *)(v2 + 324);
  v7 = 0;
  v8 = 9.8999998e24 == *(float *)(v2 + 324);
  BYTE1(result) = HIBYTE(v5);
  if ( 9.8999998e24 == *(float *)(v2 + 324)
    || (v9 = *(float *)(v2 + 324),
        v11 = *(float *)(v2 + 39112),
        v12 = v11 < v9,
        v13 = 0,
        v14 = v11 == v9,
        BYTE1(result) = HIBYTE(v10),
        v11 < v9) )
  {
    LOBYTE(result) = v21;
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 38672) && *(_BYTE *)(v2 + 32900) )
    {
      v18 = 3;
      result = sub_1008C880(v4, (int)&v16, 10, 1);
    }
    LOBYTE(result) = 1;
  }
  v15 = v20;
  *(_DWORD *)(v2 + 38664) = v19;
  *(_DWORD *)(v2 + 38668) = v15;
  *(_BYTE *)(v2 + 38672) = result;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10003EB0) --------------------------------------------------------
int __usercall sub_10003EB0@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8AA4, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 156),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 136),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 176),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10003F30) --------------------------------------------------------
char __usercall sub_10003F30@<al>(int a1@<esi>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 32900) = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 2420) = 1;
  *(float *)(v1 + 32884) = 9.8999998e24;
  *(float *)(v1 + 32888) = 9.8999998e24;
  *(float *)(v1 + 32892) = 9.8999998e24;
  *(float *)(v1 + 32896) = 9.8999998e24;
  *(_BYTE *)(v1 + 32264) = 0;
  sub_1004C170(*(_BYTE *)(v1 + 32900));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10003F90) --------------------------------------------------------
char __usercall sub_10003F90@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // esi@1
  void *v4; // ecx@1
  void *v5; // ecx@10
  int v6; // eax@14
  char result; // al@14
  int v8; // [sp+18h] [bp-Ch]@2
  float v9; // [sp+1Ch] [bp-8h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 43824, 0);
  *(_DWORD *)(v3 + 38664) = 0;
  *(_DWORD *)(v3 + 38668) = 0;
  *(_BYTE *)(v3 + 38672) = 0;
  *(_BYTE *)(v3 + 43820) = 0;
  *(_BYTE *)(v3 + 39288) = 0;
  *(_BYTE *)(v3 + 39288) = sub_10052210(v4);
  *(_DWORD *)(v3 + 156) = &unk_100B8BA0;
  *(_DWORD *)(v3 + 164) = &unk_100B8C00;
  *(_DWORD *)(v3 + 160) = &unk_100B8B6C;
  *(_DWORD *)(v3 + 140) = v3 + 84;
  v10 = v3 + 84;
  *(_DWORD *)(v3 + 176) = v3 + 108;
  *(_DWORD *)(v3 + 184) = v3 + 118;
  *(_DWORD *)(v3 + 180) = v3 + 127;
  *(_DWORD *)(v3 + 136) = v3 + 8;
  *(_DWORD *)(v3 + 144) = v3 + 48;
  *(_BYTE *)(v3 + 108) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 8) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 176) + 9) = 3;
  **(_BYTE **)(v3 + 180) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 180) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 180) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 180) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 180) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 180) + 5) = 3;
  **(_BYTE **)(v3 + 184) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 184) + 8) = 3;
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100B8AA0);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10002C30(a1);
  if ( !sub_10066790(3u, &v9) || !sub_10031F70(100.0, v9, (int)&v8) )
    v8 = 0;
  sub_10066730(v3 + 544, v8, 1.0, 0.125);
  if ( !sub_10066790(0x56u, &v9) || !sub_10031F70(100.0, v9, (int)&v8) )
    v8 = 0;
  sub_10066730(v3 + 552, v8, 1.0, 0.125);
  if ( !sub_100663D0(&v9) || !sub_10031F70(100000.0, v9, (int)&v8) )
    v8 = 0;
  sub_10066730(v3 + 15104, v8, 1.0, 0.125);
  *(_BYTE *)(v3 + 20830) = sub_1004BEE0(v5);
  *(_BYTE *)(v3 + 20828) = 1;
  *(_BYTE *)(v3 + 20829) = 1;
  if ( sub_10002B80(0) )
    *(_BYTE *)(v3 + 20828) = 0;
  if ( sub_10002B80(2) )
    *(_BYTE *)(v3 + 20829) = 0;
  *(_DWORD *)v3 = v3 + 32904;
  *(_DWORD *)(v3 + 4) = v3 + 15112;
  *(_DWORD *)(v3 + 8) = v3 + 10612;
  *(_DWORD *)(v3 + 20) = v3 + 4896;
  *(_DWORD *)(v3 + 36) = v3 + 2424;
  *(_DWORD *)(v3 + 12) = v3 + 22056;
  *(_DWORD *)(v3 + 16) = v3 + 27160;
  *(_DWORD *)(v3 + 40) = v3 + 20832;
  *(_DWORD *)(v3 + 24) = v3 + 39292;
  *(_DWORD *)(v3 + 28) = v3 + 9388;
  *(_DWORD *)(v3 + 44) = v3 + 38676;
  v6 = v10;
  *(_DWORD *)(v3 + 32) = v3 + 21444;
  *(_DWORD *)v6 = v3 + 10000;
  *(_DWORD *)(v6 + 4) = v3 + 32272;
  *(_DWORD *)(v6 + 8) = v3 + 4284;
  *(_DWORD *)(v6 + 12) = v3 + 3036;
  *(_DWORD *)(v6 + 16) = v3 + 1808;
  *(_DWORD *)(v6 + 20) = v3 + 560;
  *(_DWORD *)(v3 + 48) = v3 + 26548;
  *(_DWORD *)(v3 + 56) = v3 + 10000;
  *(_DWORD *)(v3 + 60) = v3 + 19604;
  *(_DWORD *)(v3 + 72) = v3 + 2424;
  *(_DWORD *)(v3 + 52) = v3 + 31652;
  *(_DWORD *)(v3 + 76) = v3 + 20832;
  *(_DWORD *)(v3 + 64) = v3 + 20216;
  *(_DWORD *)(v3 + 68) = v3 + 21444;
  *(_DWORD *)(v3 + 80) = v3 + 38676;
  *(_BYTE *)(v3 + 32900) = sub_1004BF10((void *)(v3 + 21444));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8AA4, v3, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8BA0, v3 + 8, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8B6C, v10, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004450) --------------------------------------------------------
char __usercall sub_10004450@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // al@3
  unsigned __int8 v3; // al@6
  int v4; // ST04_4@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( !*(_BYTE *)(v1 + 20830) )
    {
      v3 = ++*(_BYTE *)(v1 + 3998);
      *(_BYTE *)(v1 + 2420) = 0;
      if ( v3 >= *(_BYTE *)(dword_1031FB44 + 25) )
        *(_BYTE *)(v1 + 3998) = 0;
      *(_BYTE *)(v1 + 1522) = *(_BYTE *)(v1 + 3998);
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    v2 = *(_BYTE *)(v1 + 20830) == 0;
    *(_BYTE *)(v1 + 20830) = v2;
    sub_1004C150(v2);
    if ( !*(_BYTE *)(v1 + 20830) )
    {
      *(_BYTE *)(v1 + 2420) = 1;
      *(_BYTE *)(v1 + 32264) = 0;
    }
  }
  v4 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v4, -32734);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100044F0) --------------------------------------------------------
void __usercall sub_100044F0(int a1@<eax>)
{
  int v1; // edi@1
  signed int v2; // esi@1
  float *v3; // ebx@1
  float *v4; // ecx@8
  float v5; // [sp+0h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 416);
  do
  {
    v5 = sub_1004C3E0((unsigned __int16)v2 + 8);
    if ( v5 != 9.8999998e24 )
      *v3 = v5 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 4 );
  if ( *(_BYTE *)(v1 + 2420) || *(_BYTE *)(v1 + 20830) )
    *(_BYTE *)(v1 + 1522) = sub_10066EE0(v1 + 196, 0x12u, 4u);
  v4 = (float *)(v1 + 12 * *(_BYTE *)(v1 + 1522) + 416);
  if ( 9.8999998e24 != *v4 )
    *(float *)(v1 + 464) = *v4;
}

//----- (100045A0) --------------------------------------------------------
void __usercall sub_100045A0(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // edi@1
  float *v3; // ebx@1
  double v4; // st7@2
  bool v5; // zf@6
  signed int v6; // ebx@7
  float *v7; // edx@7
  float *v8; // ecx@7
  int v9; // eax@17
  float *v10; // ecx@17
  double v11; // st6@17
  signed int v12; // eax@17
  int v13; // ecx@26
  float *v14; // edx@26
  float v15; // [sp+10h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 356);
  do
  {
    v15 = sub_1004C3E0((unsigned __int16)v2 + 14);
    v4 = 9.8999998e24;
    if ( v15 != 9.8999998e24 )
      *v3 = v15 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 4 );
  if ( *(_BYTE *)(v1 + 20830) )
  {
    v5 = *(_BYTE *)(v1 + 32264) == 0;
    *(_BYTE *)(v1 + 32445) = 0;
    *(_BYTE *)(v1 + 32446) = 0;
    *(_BYTE *)(v1 + 32447) = 0;
    if ( v5 )
    {
      v6 = 0;
      v7 = (float *)(v1 + 356);
      v8 = (float *)(v1 + 32884);
      while ( 1 )
      {
        if ( 9.8999998e24 == *v8 )
          *v8 = 0.0;
        if ( *v8 < (double)*v7 )
          *v8 = *v7;
        if ( *v8 - *v7 > 7.0 )
          break;
        ++v6;
        ++v8;
        v7 += 3;
        if ( v6 >= 4 )
          goto LABEL_16;
      }
      *(_BYTE *)(v1 + 32264) = 1;
      *(_BYTE *)(v1 + 3998) = v6;
      *(_BYTE *)(v1 + 2420) = 0;
    }
LABEL_16:
    if ( *(_BYTE *)(v1 + 32264) == 1 )
    {
      v9 = *(_BYTE *)(v1 + 3998);
      *(_BYTE *)(v1 + 3995) = 0;
      v10 = (float *)(v1 + 32884);
      v11 = *(float *)(v1 + 12 * v9 + 356) - *(float *)(v1 + 4 * v9 + 32884);
      v12 = 0;
      *(float *)(v1 + 32268) = v11;
      do
      {
        if ( v12 != *(_BYTE *)(v1 + 3998) )
          *v10 = 9.8999998e24;
        ++v12;
        ++v10;
      }
      while ( v12 < 4 );
      *(float *)(v1 + 344) = *(float *)(v1 + 32268);
    }
    else
    {
      *(_BYTE *)(v1 + 3995) = 1;
      *(float *)(v1 + 32268) = 100000.0;
      *(float *)(v1 + 344) = *(float *)(v1 + 32268);
    }
  }
  else
  {
    *(_BYTE *)(v1 + 32445) = 1;
    *(_BYTE *)(v1 + 32446) = 1;
    *(_BYTE *)(v1 + 32447) = 1;
    *(_DWORD *)(v1 + 32884) = 1761805953;
    *(_DWORD *)(v1 + 32888) = 1761805953;
    *(_DWORD *)(v1 + 32892) = 1761805953;
    *(_DWORD *)(v1 + 32896) = 1761805953;
  }
  if ( *(_BYTE *)(v1 + 2420) )
  {
    v4 = 9.8999998e24;
    *(_BYTE *)(v1 + 3998) = sub_10066EE0(v1 + 196, 0xDu, 4u);
  }
  v13 = *(_BYTE *)(v1 + 3998);
  v14 = (float *)(v1 + 12 * v13 + 356);
  if ( v4 != *v14 )
  {
    *(float *)(v1 + 248) = *v14;
    sprintf((char *)(v1 + 5380), "%d", v13 + 1);
    *(float *)(v1 + 404) = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 3998) + 356);
  }
}

//----- (100047D0) --------------------------------------------------------
void __usercall sub_100047D0(int a1@<eax>)
{
  int v1; // ebx@1
  long double v2; // st7@1
  int v3; // esi@1
  float *v4; // edi@1
  float *v5; // eax@1
  signed int v6; // ecx@1
  double v7; // st7@5
  double v8; // st7@6
  int v9; // edx@16
  int v10; // ecx@16
  double v11; // st7@22
  signed int v12; // ebx@22
  double v13; // st6@24
  float v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  float v16; // [sp+20h] [bp-Ch]@5
  int v17; // [sp+24h] [bp-8h]@1
  int v18; // [sp+28h] [bp-4h]@1

  v1 = a1;
  v15 = 0;
  v2 = pow(2.0, 31.0);
  v17 = (signed int)(v2 - 1.0);
  v18 = (signed int)(v2 * -1.0);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v14 = 0.0;
  v4 = (float *)(v3 + 200);
  v5 = (float *)(v3 + 200);
  v6 = 29;
  do
  {
    *v5 = 9.8999998e24;
    v5 += 3;
    --v6;
  }
  while ( v6 );
  *v4 = sub_1004C3E0(0x1Eu);
  if ( sub_100663D0(&v14) && sub_10031F70(100000.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 15104, v15);
    v16 = (double)*(signed int *)(v3 + 15108) / 100000.0;
    v7 = v16;
    *(float *)(v3 + 212) = v16;
    *(float *)(v3 + 332) = v7;
  }
  v16 = sub_1004C3E0(0x1Cu);
  v8 = v16;
  *(float *)(v3 + 224) = v16;
  *(float *)(v3 + 476) = v8;
  v14 = sub_1004C3E0(0x1Du);
  if ( v14 != 9.8999998e24 )
  {
    *(float *)(v3 + 236) = v14 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 488) = 1.799999952316284 * v14 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 39288) == 2 )
  {
    *(_BYTE *)(v3 + 20828) = sub_10002B80(0) == 0;
    *(_BYTE *)(v3 + 20829) = sub_10002B80(2) == 0;
  }
  if ( sub_100664A0(&v14) && !*(_BYTE *)(v3 + 20828) )
    *(float *)(v3 + 260) = v14;
  if ( sub_10066510(&v14) && !*(_BYTE *)(v3 + 20829) )
    *(float *)(v3 + 272) = v14;
  *(float *)(v3 + 536) = sub_1004C0C0();
  *(float *)(v3 + 524) = sub_1004C0D0(v10, v9);
  *(float *)(v3 + 284) = sub_1004C3E0(4u);
  *(float *)(v3 + 296) = sub_1004C3E0(5u);
  sub_100045A0(v1);
  sub_100044F0(v1);
  *(float *)(v3 + 500) = sub_1004C070();
  *(float *)(v3 + 512) = sub_1004C3E0(0x20u);
  if ( sub_10066790(3u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 544, v15);
    *(float *)(v3 + 308) = (double)*(signed int *)(v3 + 548) / 100.0;
  }
  if ( sub_10066790(0x56u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 552, v15);
    *(float *)(v3 + 320) = (double)*(signed int *)(v3 + 556) / 100.0;
  }
  v11 = 9.8999998e24;
  v12 = 29;
  do
  {
    v16 = *v4;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || (v13 = *v4 / *(v4 - 1), (double)v17 < v13) || (double)v18 > v13 )
    {
      if ( v11 != *v4 )
      {
        sub_10051A40(".\\cdp_pg_eis_cessna_172_3d.c", 3350, 0, "Gauge data is not finite");
        v11 = 9.8999998e24;
      }
      *v4 = v11;
    }
    v4 += 3;
    --v12;
  }
  while ( v12 );
  sub_1004C380(v3 + 196, 0x1Du);
  if ( *(float *)(v3 + 39120) > (double)*(float *)(v3 + 324) && *(float *)(v3 + 39112) < (double)*(float *)(v3 + 324) )
  {
    *(float *)(v3 + 320) = 0.0;
    *(float *)(v3 + 324) = 0.0;
  }
  if ( *(float *)(v3 + 312) >= 100.0 || *(float *)(v3 + 312) <= -100.0 )
    *(_WORD *)(v3 + 21348) = 23;
  else
    *(_WORD *)(v3 + 21348) = 24;
  if ( *(float *)(v3 + 324) >= 100.0 || *(float *)(v3 + 324) <= -100.0 )
    *(_WORD *)(v3 + 39192) = 23;
  else
    *(_WORD *)(v3 + 39192) = 24;
  if ( *(float *)(v3 + 288) >= 100.0 || *(float *)(v3 + 288) <= -10.0 )
    *(_WORD *)(v3 + 21960) = 20;
  else
    *(_WORD *)(v3 + 21960) = 21;
  if ( *(float *)(v3 + 300) >= 100.0 || *(float *)(v3 + 300) <= -10.0 )
    *(_WORD *)(v3 + 2940) = 20;
  else
    *(_WORD *)(v3 + 2940) = 21;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (10004C50) --------------------------------------------------------
void __usercall sub_10004C50(int a1@<eax>, float a2@<ecx>)
{
  int v2; // esi@1
  signed int v3; // eax@3
  double v4; // st7@4
  float v5; // [sp+0h] [bp-4h]@1

  v5 = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)dword_1031FB44 == 14 )
  {
    if ( sub_10051AE0(&v5) )
    {
      v4 = v5;
      if ( v5 >= 1432.5601 )
      {
        if ( v4 > 1615.440063476562 && v4 < 2956.5601 )
        {
          *(_DWORD *)(v2 + 38560) = -16726016;
          *(_DWORD *)(v2 + 38564) = -1;
          goto LABEL_12;
        }
        if ( v4 <= 3139.4399 )
        {
LABEL_12:
          sub_10060E40((_BYTE *)(v2 + 38500), v2 + 32904);
          if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v2 + 204) )
            *(_BYTE *)(v2 + 34904) = 10;
          else
            *(_BYTE *)(v2 + 34904) = 16;
          return;
        }
        v3 = -16726016;
      }
      else
      {
        v3 = -1;
      }
    }
    else
    {
      v3 = -1;
    }
    *(_DWORD *)(v2 + 38560) = v3;
    *(_DWORD *)(v2 + 38564) = v3;
    goto LABEL_12;
  }
  if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v2 + 204) )
    *(_BYTE *)(v2 + 34888) = 10;
  else
    *(_BYTE *)(v2 + 34888) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10004D60) --------------------------------------------------------
char __usercall sub_10004D60@<al>(int a1@<edi>)
{
  int v1; // esi@1
  float v2; // ecx@1
  float *v3; // ebp@4
  char result; // al@5
  double v5; // st7@6
  float *v6; // ebp@8
  float v7; // ST44_4@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100047D0(a1);
  sub_10004C50(a1, v2);
  sub_10003AF0(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8AB8, (int)&unk_100B8BF4, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B8AA4, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 156),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 136),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 32900) + 176),
    255);
  if ( *(_BYTE *)(v1 + 32900) != 1 )
  {
    *(_BYTE *)(v1 + 20830) = 0;
    sub_1004C150(0);
    *(_BYTE *)(v1 + 2420) = 1;
    *(_BYTE *)(v1 + 32264) = 0;
  }
  if ( !*(_BYTE *)(v1 + 32900) )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 567.0);
    sub_1008C2F0(137.0, 567.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 43808) = 0.5;
    v3 = (float *)(v1 + 43784);
    *(float *)(v1 + 43812) = 0.5;
    *(_DWORD *)(v1 + 43800) = -14671840;
    *(float *)(v1 + 43784) = 75.5;
    *(_DWORD *)(v1 + 43804) = -1;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 567.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 43784);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 43784);
    *v3 = 24.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 43784);
    *v3 = 126.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 43784);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 614.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 43784);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 43784);
    *v3 = 24.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 43784);
    *v3 = 126.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 43784);
    *v3 = 75.5;
    *(float *)(v1 + 43788) = 669.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 43784);
    sub_10048A00(10.0, 455.0, v1 + 15112);
  }
  result = *(_BYTE *)(v1 + 32900);
  if ( result == 1 )
  {
    sub_10046480(10.0, 563.0, v1 + 10000);
    sub_10046480(10.0, 503.0, v1 + 1808);
    v5 = 618.0;
LABEL_9:
    v7 = v5;
    result = sub_10048A00(10.0, v7, v1 + 15112);
    goto LABEL_10;
  }
  if ( result == 2 )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 567.0);
    sub_1008C2F0(137.0, 567.0);
    sub_1008C2F0(10.0, 287.0);
    sub_1008C2F0(137.0, 287.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 43808) = 0.5;
    v6 = (float *)(v1 + 43784);
    *(float *)(v1 + 43812) = 0.5;
    *(_DWORD *)(v1 + 43800) = -14671840;
    *(float *)(v1 + 43784) = 75.5;
    *(_DWORD *)(v1 + 43804) = -1;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 567.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 43784);
    *v6 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 287.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
    sub_10065B50(a1, (int)"FUEL CALC", v1 + 43784);
    *v6 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 43784);
    *v6 = 24.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 43784);
    *v6 = 126.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 590.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 43784);
    *v6 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 614.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 43784);
    *v6 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 43784);
    *v6 = 24.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 43784);
    *v6 = 126.0;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 645.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 43784);
    *v6 = 75.5;
    *(_DWORD *)(v1 + 43792) = 2;
    *(float *)(v1 + 43788) = 669.0;
    *(float *)(v1 + 43796) = 12.0;
    *(float *)(v1 + 43816) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 43784);
    sub_10046480(10.0, 332.0, v1 + 10000);
    sub_10046480(10.0, 202.0, v1 + 26548);
    v5 = 467.0;
    goto LABEL_9;
  }
LABEL_10:
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (100055C0) --------------------------------------------------------
char __cdecl sub_100055C0(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_10003EB0(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10003F90(a1, 0, 0);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_10004D60(a1);
      break;
    case 32821:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 43820) = 0;
      break;
    case 32820:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 43820) = 1;
      break;
    case 32825:
      LOBYTE(v1) = sub_10003F30(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v1) = sub_10004450(a1);
      break;
    case 32791:
    case 32792:
    case 32793:
    case 32794:
    case 32795:
    case 32796:
    case 32797:
    case 32798:
    case 32799:
    case 32800:
    case 32801:
    case 32803:
    case 32804:
    case 32805:
    case 32806:
    case 32807:
    case 32808:
    case 32809:
    case 32810:
    case 32811:
    case 32812:
    case 32813:
    case 32814:
    case 32815:
    case 32816:
    case 32817:
    case 32818:
    case 32822:
    case 32823:
    case 32826:
    case 32827:
    case 32828:
    case 32829:
    case 32830:
    case 32831:
    case 32832:
    case 32834:
    case 32835:
    case 32836:
    case 32837:
    case 32838:
    case 32839:
    case 32840:
    case 32841:
    case 32842:
    case 32843:
    case 32844:
    case 32845:
    case 32846:
    case 32847:
    case 32848:
    case 32849:
    case 32850:
    case 32851:
    case 32852:
    case 32853:
    case 32854:
    case 32855:
    case 32856:
    case 32857:
    case 32858:
    case 32859:
    case 32860:
    case 32861:
    case 32862:
    case 32863:
    case 32864:
    case 32865:
    case 32866:
    case 32867:
    case 32868:
    case 32869:
    case 32870:
    case 32871:
    case 32872:
    case 32873:
    case 32874:
    case 32875:
    case 32876:
    case 32877:
    case 32878:
    case 32879:
    case 32880:
    case 32881:
    case 32882:
    case 32883:
    case 32884:
    case 32885:
    case 32886:
    case 32887:
      return v1;
  }
  return v1;
}

//----- (100056B0) --------------------------------------------------------
bool __cdecl sub_100056B0(char a1)
{
  bool v1; // zf@6
  bool v2; // bl@8
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+10h] [bp-14h]@1

  v6 = 1;
  v7 = 0;
  LOBYTE(v5) = 67;
  v4 = 2;
  if ( a1 )
  {
    if ( a1 == 2 )
      LOBYTE(v5) = 7;
  }
  else
  {
    LOBYTE(v5) = 6;
  }
  sub_10065D40(a1, &v4);
  sub_10065C60(v5, 1, 9, (int)&v6, (int)&v7, 16);
  if ( v7 == 3 )
    v1 = v4 == 0;
  else
    v1 = v4 == 1;
  v2 = v1;
  if ( !v1 )
    sub_10051A40(
      ".\\cdp_pg_eis_cessna_182T_3d.c",
      1203,
      0,
      "Fuel sensor calibration does not match fuel sensor configuration");
  return v2;
}

//----- (10005760) --------------------------------------------------------
int __usercall sub_10005760@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  const char *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = "QC";
  v3 = v1 + 208;
  do
  {
    v4 = *(float *)v2;
    v2 += 4;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)".\\cdp_pg_eis_cessna_182T_3d.c" );
  *(_DWORD *)(v1 + 53808) = 2;
  *(float *)(v1 + 53800) = 0.0;
  *(_DWORD *)(v1 + 53816) = 0;
  *(float *)(v1 + 53804) = 0.0;
  *(_DWORD *)(v1 + 53820) = -1;
  *(float *)(v1 + 53812) = 12.0;
  *(float *)(v1 + 53824) = 0.5;
  *(float *)(v1 + 53828) = 1.0;
  *(float *)(v1 + 53832) = 40.0;
  *(_BYTE *)(v1 + 25402) = sub_1004BEE0((void *)v2);
  *(_BYTE *)(v1 + 6992) = 1;
  *(float *)(v1 + 43052) = 9.8999998e24;
  *(float *)(v1 + 43056) = 9.8999998e24;
  *(float *)(v1 + 43060) = 9.8999998e24;
  *(float *)(v1 + 43064) = 9.8999998e24;
  *(float *)(v1 + 43068) = 9.8999998e24;
  *(float *)(v1 + 43072) = 9.8999998e24;
  *(_BYTE *)(v1 + 42432) = 0;
  sub_10061B00(v1 + 25404, (int)"MAN IN", dword_1031FB44 + 3912, 10.0, 5.0, 127.0, 127.0);
  *(float *)(v1 + 25624) = 158.0;
  *(_DWORD *)(v1 + 27480) = 54;
  *(float *)(v1 + 25628) = 382.0;
  *(float *)(v1 + 25728) = 224.0;
  *(float *)(v1 + 27704) = 73.0;
  *(float *)(v1 + 27708) = 88.0;
  *(float *)(v1 + 27744) = 23.0;
  *(float *)(v1 + 27736) = 0.5;
  *(float *)(v1 + 25504) = 73.0;
  *(float *)(v1 + 25508) = 80.0;
  *(float *)(v1 + 25552) = 9.0;
  *(float *)(v1 + 25544) = 0.5;
  *(float *)(v1 + 25440) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 25404);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 25404);
  sub_100612A0((int)&unk_100B950C, 2, 0.0, v1 + 25404);
  sub_10060F20(v1 + 204, 1, v1 + 25404);
  *(_WORD *)(v1 + 30962) = 5;
  *(_BYTE *)(v1 + 30968) = 1;
  *(_DWORD *)(v1 + 30964) = &unk_100B8DC0;
  sub_10061B00(v1 + 43080, (int)"RPM", dword_1031FB44 + 4076, 10.0, 117.0, 127.0, 127.0);
  *(float *)(v1 + 43300) = 158.0;
  *(_DWORD *)(v1 + 45156) = 54;
  *(float *)(v1 + 43304) = 382.0;
  *(float *)(v1 + 43404) = 224.0;
  *(float *)(v1 + 45380) = 73.0;
  *(float *)(v1 + 45384) = 200.0;
  *(float *)(v1 + 45420) = 23.0;
  *(float *)(v1 + 45412) = 0.5;
  *(float *)(v1 + 43180) = 73.0;
  *(float *)(v1 + 43184) = 192.0;
  *(float *)(v1 + 43228) = 9.0;
  *(float *)(v1 + 43220) = 0.5;
  *(float *)(v1 + 43116) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 43080);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 43080);
  sub_100612A0((int)&unk_100B952C, 2, 0.0, v1 + 43080);
  sub_10060F20(v1 + 216, 1, v1 + 43080);
  *(_WORD *)(v1 + 48638) = 6;
  *(_BYTE *)(v1 + 48644) = 1;
  *(_DWORD *)(v1 + 48640) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 15184, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4240, 0.40000001, 0.0, v1 + 15184);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 15184);
  sub_10049040(v1 + 228, 1, 0, v1 + 15184);
  sub_10049310((int)&unk_100B9550, 0xCu, 0, v1 + 15184);
  *(float *)(v1 + 15248) = 73.5;
  *(float *)(v1 + 15288) = 0.5;
  *(_WORD *)(v1 + 19496) = 33;
  *(_BYTE *)(v1 + 19504) = 1;
  *(_DWORD *)(v1 + 19500) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 15698) = 2;
  sub_1004A1A0(v1 + 32224, (int)"OIL PRES", dword_1031FB44 + 4404, 10.0, 299.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 32224);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 32224);
  sub_10049310((int)&unk_100B9610, 2u, 0, v1 + 32224);
  sub_10049040(v1 + 240, 1, 0, v1 + 32224);
  *(float *)(v1 + 32288) = 73.5;
  *(float *)(v1 + 32328) = 0.5;
  *(_WORD *)(v1 + 36536) = 15;
  *(_BYTE *)(v1 + 36544) = 1;
  *(_DWORD *)(v1 + 36540) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 32738) = 2;
  sub_1004A1A0(v1 + 37328, (int)"OIL TEMP", dword_1031FB44 + 4568, 10.0, 347.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 37328);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 37328);
  sub_10049310((int)&unk_100B9630, 2u, 0, v1 + 37328);
  sub_10049040(v1 + 252, 1, 0, v1 + 37328);
  *(float *)(v1 + 37392) = 73.5;
  *(float *)(v1 + 37432) = 0.5;
  *(_WORD *)(v1 + 41640) = 10;
  *(_BYTE *)(v1 + 41648) = 1;
  *(_DWORD *)(v1 + 41644) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 37842) = 2;
  sub_1004A1A0(v1 + 1888, (int)"CHT", dword_1031FB44 + 6700, 10.0, 395.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 6700, 0.40000001, 0.0, v1 + 1888);
  sub_100490F0(dword_1031FB44 + 20956, v1 + 1888);
  sub_10049310((int)&unk_100B9650, 2u, 0, v1 + 1888);
  sub_10049040(v1 + 264, 1, 0, v1 + 1888);
  *(float *)(v1 + 1952) = 73.5;
  *(float *)(v1 + 1992) = 0.5;
  *(_WORD *)(v1 + 6200) = 10;
  *(_BYTE *)(v1 + 6208) = 1;
  *(_DWORD *)(v1 + 6204) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 2402) = 2;
  sub_1004A1A0(v1 + 9468, (int)"EGT", dword_1031FB44 + 5224, 10.0, 443.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 5224, 0.40000001, 0.0, v1 + 9468);
  sub_100490F0(dword_1031FB44 + 20704, v1 + 9468);
  sub_10049310((int)&unk_100B9670, 9u, 0, v1 + 9468);
  sub_10049040(v1 + 276, 1, 0, v1 + 9468);
  *(float *)(v1 + 9532) = 73.5;
  *(float *)(v1 + 9572) = 0.5;
  *(_WORD *)(v1 + 13780) = 10;
  *(_BYTE *)(v1 + 13788) = 1;
  *(_DWORD *)(v1 + 13784) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 9982) = 2;
  sub_1004A1E0(v1 + 19684, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 491.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100B9700, 0xAu, 0, v1 + 19684);
  sub_10049040(v1 + 288, 2, 0, v1 + 19684);
  *(float *)(v1 + 20144) = 26.0;
  *(float *)(v1 + 20208) = 26.0;
  *(_WORD *)(v1 + 23996) = 31;
  *(_BYTE *)(v1 + 24004) = 1;
  *(_DWORD *)(v1 + 24000) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 20198) = 0;
  *(_BYTE *)(v1 + 20262) = 0;
  sub_10046920(v1 + 31612, (int)byte_100B8180, dword_1031FB44 + 5388, -109.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 31612);
  *(float *)(v1 + 31672) = 0.5;
  *(_WORD *)(v1 + 32128) = 21;
  *(_BYTE *)(v1 + 32136) = 1;
  *(_DWORD *)(v1 + 32132) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 31660) = v1 + 320;
  *(_BYTE *)(v1 + 31787) = 1;
  sub_10046920(v1 + 6996, (int)byte_100B8180, dword_1031FB44 + 5388, -12.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 6996);
  *(float *)(v1 + 7056) = 0.5;
  *(_WORD *)(v1 + 7512) = 21;
  *(_BYTE *)(v1 + 7520) = 1;
  *(_DWORD *)(v1 + 7516) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 7044) = v1 + 332;
  *(_BYTE *)(v1 + 7171) = 1;
  sub_10046920(v1 + 31000, (int)byte_100B8180, dword_1031FB44 + 5552, -109.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20760, v1 + 31000);
  *(_WORD *)(v1 + 31516) = 24;
  *(_BYTE *)(v1 + 31524) = 1;
  *(_DWORD *)(v1 + 31520) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 31048) = v1 + 344;
  *(_BYTE *)(v1 + 31175) = 1;
  *(float *)(v1 + 31060) = 0.5;
  sub_10046920(v1 + 48692, (int)byte_100B8180, dword_1031FB44 + 5716, -13.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20788, v1 + 48692);
  *(_WORD *)(v1 + 49208) = 24;
  *(_BYTE *)(v1 + 49216) = 1;
  *(_DWORD *)(v1 + 49212) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 48740) = v1 + 356;
  *(_BYTE *)(v1 + 48867) = 1;
  *(float *)(v1 + 48752) = 0.5;
  sub_10046920(v1 + 14572, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20536, v1 + 14572);
  *(_WORD *)(v1 + 15088) = 33;
  *(_BYTE *)(v1 + 15096) = 1;
  *(_DWORD *)(v1 + 15092) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 14620) = v1 + 368;
  sub_10046920(v1 + 42440, (int)"PEAK", dword_1031FB44 + 6536, 10.0, 436.0, 127.0, 15.0);
  *(_WORD *)(v1 + 42956) = 11;
  *(_BYTE *)(v1 + 42964) = 1;
  *(_DWORD *)(v1 + 42960) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 42488) = v1 + 380;
  *(float *)(v1 + 42468) = *(float *)(v1 + 42468) - 15.0;
  *(_WORD *)(v1 + 42736) = 18065;
  *(_BYTE *)(v1 + 42738) = 0;
  *(float *)(v1 + 42720) = 122.0;
  sub_10048850(v1 + 7608, (int)"EGT", dword_1031FB44 + 5224, 10.0, 271.0, 127.0, 106.0);
  sub_10047B10(v1 + 384, 6, 1, v1 + 7608);
  *(_BYTE *)(v1 + 8568) = 1;
  *(_BYTE *)(v1 + 8569) = 1;
  *(_WORD *)(v1 + 8572) = 10;
  *(_BYTE *)(v1 + 8570) = -1;
  *(float *)(v1 + 7716) = 412.0;
  *(float *)(v1 + 7752) = 0.0;
  *(float *)(v1 + 7756) = 1.0;
  *(_BYTE *)(v1 + 7708) = 16;
  *(_DWORD *)(v1 + 7684) = v1 + 43052;
  *(_DWORD *)(v1 + 7688) = v1 + 43056;
  *(_DWORD *)(v1 + 7692) = v1 + 43060;
  *(_DWORD *)(v1 + 7696) = v1 + 43064;
  *(_DWORD *)(v1 + 7700) = v1 + 43068;
  *(_DWORD *)(v1 + 7704) = v1 + 43072;
  sub_10046920(v1 + 8856, (int)"EGT F", dword_1031FB44 + 5224, 10.0, 414.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20704, v1 + 8856);
  *(_WORD *)(v1 + 9372) = 10;
  *(_BYTE *)(v1 + 9380) = 1;
  *(_DWORD *)(v1 + 9376) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 8904) = v1 + 464;
  sub_10048850(v1 + 640, (int)"CHT", dword_1031FB44 + 4732, 10.0, 456.0, 127.0, 91.0);
  sub_10047B10(v1 + 468, 6, 1, v1 + 640);
  *(_BYTE *)(v1 + 1600) = 1;
  *(_BYTE *)(v1 + 1601) = 1;
  *(_WORD *)(v1 + 1604) = 10;
  *(_BYTE *)(v1 + 1602) = -1;
  *(float *)(v1 + 748) = 582.0;
  *(float *)(v1 + 784) = 0.0;
  *(float *)(v1 + 788) = 1.0;
  *(_BYTE *)(v1 + 740) = 12;
  sub_10046920(v1 + 6380, (int)"CHT F", dword_1031FB44 + 4732, 10.0, 584.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20620, v1 + 6380);
  *(_WORD *)(v1 + 6896) = 10;
  *(_BYTE *)(v1 + 6904) = 1;
  *(_DWORD *)(v1 + 6900) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 6428) = v1 + 548;
  sub_10046920(v1 + 36716, (int)"OIL PSI", dword_1031FB44 + 4404, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20564, v1 + 36716);
  *(_WORD *)(v1 + 37232) = 15;
  *(_BYTE *)(v1 + 37240) = 1;
  *(_DWORD *)(v1 + 37236) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 36764) = v1 + 560;
  sub_10046920(v1 + 41820, (int)"OIL F", dword_1031FB44 + 4568, 10.0, 281.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20592, v1 + 41820);
  *(_WORD *)(v1 + 42336) = 10;
  *(_BYTE *)(v1 + 42344) = 1;
  *(_DWORD *)(v1 + 42340) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 41868) = v1 + 572;
  sub_10046920(v1 + 13960, (int)"ENG HRS", dword_1031FB44 + 5880, 10.0, 311.0, 127.0, 15.0);
  *(_WORD *)(v1 + 14476) = 39;
  *(_BYTE *)(v1 + 14484) = 1;
  *(_DWORD *)(v1 + 14480) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 14008) = v1 + 584;
  sub_1004A1A0(v1 + 49308, (int)"VAC", dword_1031FB44 + 6044, 10.0, 341.0, 127.0, 18.5, 0);
  sub_10049310((int)&unk_100B97A0, 2u, 0, v1 + 49308);
  sub_10049040(v1 + 588, 1, 0, v1 + 49308);
  *(_WORD *)(v1 + 53620) = 15;
  *(_BYTE *)(v1 + 53628) = 1;
  *(_DWORD *)(v1 + 53624) = &unk_100B8DC0;
  *(float *)(v1 + 49372) = 73.5;
  *(float *)(v1 + 49412) = 0.5;
  *(_BYTE *)(v1 + 49822) = 2;
  sub_10046920(v1 + 24788, (int)"GAL USED", dword_1031FB44 + 6208, 10.0, 434.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20872, v1 + 24788);
  *(_WORD *)(v1 + 25304) = 31;
  *(_BYTE *)(v1 + 25312) = 1;
  *(_DWORD *)(v1 + 25308) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 24836) = v1 + 608;
  sub_10046920(v1 + 24176, (int)"GAL REM", dword_1031FB44 + 6372, 10.0, 464.0, 127.0, 15.0);
  *(_WORD *)(v1 + 24692) = 30;
  *(_BYTE *)(v1 + 24700) = 1;
  *(_DWORD *)(v1 + 24696) = &unk_100B8DC0;
  result = v1 + 620;
  *(_DWORD *)(v1 + 24224) = v1 + 620;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10006810) --------------------------------------------------------
int __usercall sub_10006810@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B9874, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 164),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 144),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 184),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10006890) --------------------------------------------------------
char __usercall sub_10006890@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // ecx@1
  signed int v6; // eax@1
  void *v7; // ecx@12
  int v8; // eax@16
  char result; // al@16
  int v10; // [sp+18h] [bp-Ch]@4
  float v11; // [sp+1Ch] [bp-8h]@3
  int v12; // [sp+20h] [bp-4h]@1

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 53840, 0);
  v4 = v3;
  *(_DWORD *)(v3 + 48676) = 0;
  *(_DWORD *)(v3 + 48680) = 0;
  *(_DWORD *)(v3 + 48684) = 0;
  *(_WORD *)(v3 + 48688) = 0;
  *(_BYTE *)(v3 + 48690) = 0;
  *(_BYTE *)(v3 + 53836) = 0;
  *(_BYTE *)(v3 + 49304) = 0;
  *(_BYTE *)(v3 + 49304) = sub_10052210(v5);
  *(_DWORD *)(v4 + 164) = &unk_100B9890;
  *(_DWORD *)(v4 + 172) = &unk_100B9910;
  *(_DWORD *)(v4 + 168) = &unk_100B98DC;
  *(_DWORD *)(v4 + 148) = v4 + 92;
  v12 = v4 + 92;
  *(_DWORD *)(v4 + 184) = v4 + 116;
  *(_DWORD *)(v4 + 192) = v4 + 125;
  *(_DWORD *)(v4 + 188) = v4 + 136;
  *(_DWORD *)(v4 + 144) = v4 + 12;
  *(_DWORD *)(v4 + 152) = v4 + 48;
  *(_BYTE *)(v4 + 116) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 8) = 3;
  **(_BYTE **)(v4 + 188) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 5) = 3;
  v6 = 0;
  do
    *(_BYTE *)(v6++ + *(_DWORD *)(v4 + 192)) = 3;
  while ( v6 < 11 );
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100B954C);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10005760(a1);
  if ( !sub_10066790(3u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 624, v10, 1.0, 0.125);
  if ( !sub_10066790(0x56u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 632, v10, 1.0, 0.125);
  if ( !sub_100663D0(&v11) || !sub_10031F70(100000.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 19676, v10, 1.0, 0.125);
  *(_BYTE *)(v4 + 25402) = sub_1004BEE0(v7);
  *(_BYTE *)(v4 + 25400) = 1;
  *(_BYTE *)(v4 + 25401) = 1;
  if ( sub_100056B0(0) )
    *(_BYTE *)(v4 + 25400) = 0;
  if ( sub_100056B0(2) )
    *(_BYTE *)(v4 + 25401) = 0;
  *(_DWORD *)(v4 + 8) = v4 + 19684;
  *(_DWORD *)v4 = v4 + 25404;
  *(_DWORD *)(v4 + 4) = v4 + 43080;
  *(_DWORD *)(v4 + 20) = v4 + 37328;
  *(_DWORD *)(v4 + 36) = v4 + 6996;
  *(_DWORD *)(v4 + 12) = v4 + 15184;
  *(_DWORD *)(v4 + 16) = v4 + 32224;
  *(_DWORD *)(v4 + 40) = v4 + 31000;
  *(_DWORD *)(v4 + 24) = v4 + 1888;
  *(_DWORD *)(v4 + 28) = v4 + 9468;
  *(_DWORD *)(v4 + 44) = v4 + 48692;
  v8 = v12;
  *(_DWORD *)(v4 + 32) = v4 + 31612;
  *(_DWORD *)v8 = v4 + 14572;
  *(_DWORD *)(v8 + 4) = v4 + 42440;
  *(_DWORD *)(v8 + 8) = v4 + 8856;
  *(_DWORD *)(v8 + 12) = v4 + 7608;
  *(_DWORD *)(v8 + 16) = v4 + 6380;
  *(_DWORD *)(v8 + 20) = v4 + 640;
  *(_DWORD *)(v4 + 48) = v4 + 36716;
  *(_DWORD *)(v4 + 56) = v4 + 13960;
  *(_DWORD *)(v4 + 64) = v4 + 14572;
  *(_DWORD *)(v4 + 68) = v4 + 24176;
  *(_DWORD *)(v4 + 52) = v4 + 41820;
  *(_DWORD *)(v4 + 80) = v4 + 6996;
  *(_DWORD *)(v4 + 60) = v4 + 49308;
  *(_DWORD *)(v4 + 84) = v4 + 31000;
  *(_DWORD *)(v4 + 72) = v4 + 24788;
  *(_DWORD *)(v4 + 76) = v4 + 31612;
  *(_DWORD *)(v4 + 88) = v4 + 48692;
  *(_BYTE *)(v4 + 43076) = sub_1004BF10((void *)(v4 + 31612));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B9874, v4, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B9890, v4 + 12, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B98DC, v12, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10006D30) --------------------------------------------------------
void __usercall sub_10006D30(int a1@<eax>)
{
  int v1; // ebx@1
  long double v2; // st7@1
  int v3; // esi@1
  float *v4; // edi@1
  float *v5; // eax@1
  signed int v6; // ecx@1
  double v7; // st7@5
  double v8; // st7@6
  int v9; // edx@16
  int v10; // ecx@16
  double v11; // st7@22
  signed int v12; // ebx@22
  double v13; // st6@24
  float v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  float v16; // [sp+20h] [bp-Ch]@5
  int v17; // [sp+24h] [bp-8h]@1
  int v18; // [sp+28h] [bp-4h]@1

  v1 = a1;
  v15 = 0;
  v2 = pow(2.0, 31.0);
  v17 = (signed int)(v2 - 1.0);
  v18 = (signed int)(v2 * -1.0);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v14 = 0.0;
  v4 = (float *)(v3 + 208);
  v5 = (float *)(v3 + 208);
  v6 = 35;
  do
  {
    *v5 = 9.8999998e24;
    v5 += 3;
    --v6;
  }
  while ( v6 );
  *v4 = sub_1004C3E0(0x18u);
  *(float *)(v3 + 220) = sub_1004C3E0(0x1Eu);
  if ( sub_100663D0(&v14) && sub_10031F70(100000.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 19676, v15);
    v16 = (double)*(signed int *)(v3 + 19680) / 100000.0;
    v7 = v16;
    *(float *)(v3 + 232) = v16;
    *(float *)(v3 + 364) = v7;
  }
  v16 = sub_1004C3E0(0x1Cu);
  v8 = v16;
  *(float *)(v3 + 244) = v16;
  *(float *)(v3 + 556) = v8;
  v14 = sub_1004C3E0(0x1Du);
  if ( v14 != 9.8999998e24 )
  {
    *(float *)(v3 + 256) = v14 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 568) = 1.799999952316284 * v14 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 49304) == 2 )
  {
    *(_BYTE *)(v3 + 25400) = sub_100056B0(0) == 0;
    *(_BYTE *)(v3 + 25401) = sub_100056B0(2) == 0;
  }
  if ( sub_100664A0(&v14) && !*(_BYTE *)(v3 + 25400) )
    *(float *)(v3 + 292) = v14;
  if ( sub_10066510(&v14) && !*(_BYTE *)(v3 + 25401) )
    *(float *)(v3 + 304) = v14;
  *(float *)(v3 + 616) = sub_1004C0C0();
  *(float *)(v3 + 604) = sub_1004C0D0(v10, v9);
  *(float *)(v3 + 316) = sub_1004C3E0(4u);
  *(float *)(v3 + 328) = sub_1004C3E0(5u);
  sub_10009820(v1);
  sub_10009740(v1);
  *(float *)(v3 + 580) = sub_1004C070();
  *(float *)(v3 + 592) = sub_1004C3E0(0x20u);
  if ( sub_10066790(3u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 624, v15);
    *(float *)(v3 + 340) = (double)*(signed int *)(v3 + 628) / 100.0;
  }
  if ( sub_10066790(0x56u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 632, v15);
    *(float *)(v3 + 352) = (double)*(signed int *)(v3 + 636) / 100.0;
  }
  v11 = 9.8999998e24;
  v12 = 35;
  do
  {
    v16 = *v4;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || (v13 = *v4 / *(v4 - 1), (double)v17 < v13) || (double)v18 > v13 )
    {
      if ( v11 != *v4 )
      {
        sub_10051A40(".\\cdp_pg_eis_cessna_182T_3d.c", 3362, 0, "Gauge data is not finite");
        v11 = 9.8999998e24;
      }
      *v4 = v11;
    }
    v4 += 3;
    --v12;
  }
  while ( v12 );
  sub_1004C380(v3 + 204, 0x23u);
  if ( *(float *)(v3 + 49136) > (double)*(float *)(v3 + 356) && *(float *)(v3 + 49128) < (double)*(float *)(v3 + 356) )
  {
    *(float *)(v3 + 352) = 0.0;
    *(float *)(v3 + 356) = 0.0;
  }
  if ( *(float *)(v3 + 344) >= 100.0 || *(float *)(v3 + 344) <= -100.0 )
    *(_WORD *)(v3 + 31516) = 23;
  else
    *(_WORD *)(v3 + 31516) = 24;
  if ( *(float *)(v3 + 356) >= 100.0 || *(float *)(v3 + 356) <= -100.0 )
    *(_WORD *)(v3 + 49208) = 23;
  else
    *(_WORD *)(v3 + 49208) = 24;
  if ( *(float *)(v3 + 320) >= 100.0 || *(float *)(v3 + 320) <= -10.0 )
    *(_WORD *)(v3 + 32128) = 20;
  else
    *(_WORD *)(v3 + 32128) = 21;
  if ( *(float *)(v3 + 332) >= 100.0 || *(float *)(v3 + 332) <= -10.0 )
    *(_WORD *)(v3 + 7512) = 20;
  else
    *(_WORD *)(v3 + 7512) = 21;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (100071C0) --------------------------------------------------------
void __usercall sub_100071C0(int a1@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v1 + 224) )
    *(_BYTE *)(v1 + 45064) = 10;
  else
    *(_BYTE *)(v1 + 45064) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100071F0) --------------------------------------------------------
char __usercall sub_100071F0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  float *v2; // ebp@4
  char result; // al@5
  double v4; // st7@6
  float *v5; // ebp@8
  float v6; // ST44_4@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10006D30(a1);
  sub_100071C0(a1);
  sub_10008CA0(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B97C0, (int)&unk_100B996C, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100B9874, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 164),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 144),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 184),
    255);
  if ( *(_BYTE *)(v1 + 43076) != 1 )
  {
    *(_BYTE *)(v1 + 25402) = 0;
    sub_1004C150(0);
    *(_BYTE *)(v1 + 6992) = 1;
    *(_BYTE *)(v1 + 42432) = 0;
  }
  if ( !*(_BYTE *)(v1 + 43076) )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 53824) = 0.5;
    v2 = (float *)(v1 + 53800);
    *(float *)(v1 + 53828) = 0.5;
    *(_DWORD *)(v1 + 53816) = -14671840;
    *(float *)(v1 + 53800) = 75.5;
    *(_DWORD *)(v1 + 53820) = -1;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 565.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 53800);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 612.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 53800);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 53800);
    *v2 = 75.5;
    *(float *)(v1 + 53804) = 667.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 53800);
    sub_10048A00(10.0, 491.0, v1 + 19684);
  }
  result = *(_BYTE *)(v1 + 43076);
  if ( result == 1 )
  {
    sub_10046480(10.0, 251.0, v1 + 14572);
    sub_10046480(10.0, 584.0, v1 + 6380);
    v4 = 624.0;
LABEL_9:
    v6 = v4;
    result = sub_10048A00(10.0, v6, v1 + 19684);
    goto LABEL_10;
  }
  if ( result == 2 )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    sub_1008C2F0(10.0, 374.0);
    sub_1008C2F0(137.0, 374.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 53824) = 0.5;
    v5 = (float *)(v1 + 53800);
    *(float *)(v1 + 53828) = 0.5;
    *(_DWORD *)(v1 + 53816) = -14671840;
    *(float *)(v1 + 53800) = 75.5;
    *(_DWORD *)(v1 + 53820) = -1;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 565.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 374.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
    sub_10065B50(a1, (int)"FUEL CALC", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 53800);
    *v5 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v5 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 612.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 53800);
    *v5 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v5 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 667.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 53800);
    sub_10046480(10.0, 404.0, v1 + 14572);
    sub_10046480(10.0, 251.0, v1 + 36716);
    v4 = 491.0;
    goto LABEL_9;
  }
LABEL_10:
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10007A50) --------------------------------------------------------
char __cdecl sub_10007A50(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_10006810(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10006890(a1, 0, 0);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_100071F0(a1);
      break;
    case 32821:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 53836) = 0;
      break;
    case 32820:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 53836) = 1;
      break;
    case 32825:
      LOBYTE(v1) = sub_10009190(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v1) = sub_100096A0(a1);
      break;
    case 32791:
    case 32792:
    case 32793:
    case 32794:
    case 32795:
    case 32796:
    case 32797:
    case 32798:
    case 32799:
    case 32800:
    case 32801:
    case 32803:
    case 32804:
    case 32805:
    case 32806:
    case 32807:
    case 32808:
    case 32809:
    case 32810:
    case 32811:
    case 32812:
    case 32813:
    case 32814:
    case 32815:
    case 32816:
    case 32817:
    case 32818:
    case 32822:
    case 32823:
    case 32826:
    case 32827:
    case 32828:
    case 32829:
    case 32830:
    case 32831:
    case 32832:
    case 32834:
    case 32835:
    case 32836:
    case 32837:
    case 32838:
    case 32839:
    case 32840:
    case 32841:
    case 32842:
    case 32843:
    case 32844:
    case 32845:
    case 32846:
    case 32847:
    case 32848:
    case 32849:
    case 32850:
    case 32851:
    case 32852:
    case 32853:
    case 32854:
    case 32855:
    case 32856:
    case 32857:
    case 32858:
    case 32859:
    case 32860:
    case 32861:
    case 32862:
    case 32863:
    case 32864:
    case 32865:
    case 32866:
    case 32867:
    case 32868:
    case 32869:
    case 32870:
    case 32871:
    case 32872:
    case 32873:
    case 32874:
    case 32875:
    case 32876:
    case 32877:
    case 32878:
    case 32879:
    case 32880:
    case 32881:
    case 32882:
    case 32883:
    case 32884:
    case 32885:
    case 32886:
    case 32887:
      return v1;
  }
  return v1;
}

//----- (10007B40) --------------------------------------------------------
bool __cdecl sub_10007B40(char a1)
{
  bool v1; // zf@6
  bool v2; // bl@8
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+10h] [bp-14h]@1

  v6 = 1;
  v7 = 0;
  LOBYTE(v5) = 67;
  v4 = 2;
  if ( a1 )
  {
    if ( a1 == 2 )
      LOBYTE(v5) = 7;
  }
  else
  {
    LOBYTE(v5) = 6;
  }
  sub_10065D40(a1, &v4);
  sub_10065C60(v5, 1, 9, (int)&v6, (int)&v7, 16);
  if ( v7 == 3 )
    v1 = v4 == 0;
  else
    v1 = v4 == 1;
  v2 = v1;
  if ( !v1 )
    sub_10051A40(
      ".\\cdp_pg_eis_cessna_206h_3d.c",
      1205,
      0,
      "Fuel sensor calibration does not match fuel sensor configuration");
  return v2;
}

//----- (10007BF0) --------------------------------------------------------
int __usercall sub_10007BF0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  const char *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = "QC";
  v3 = v1 + 208;
  do
  {
    v4 = *(float *)v2;
    v2 += 4;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)".\\cdp_pg_eis_cessna_206h_3d.c" );
  *(_DWORD *)(v1 + 53808) = 2;
  *(float *)(v1 + 53800) = 0.0;
  *(_DWORD *)(v1 + 53816) = 0;
  *(float *)(v1 + 53804) = 0.0;
  *(_DWORD *)(v1 + 53820) = -1;
  *(float *)(v1 + 53812) = 12.0;
  *(float *)(v1 + 53824) = 0.5;
  *(float *)(v1 + 53828) = 1.0;
  *(float *)(v1 + 53832) = 40.0;
  *(_BYTE *)(v1 + 25402) = sub_1004BEE0((void *)v2);
  *(_BYTE *)(v1 + 6992) = 1;
  *(float *)(v1 + 43052) = 9.8999998e24;
  *(float *)(v1 + 43056) = 9.8999998e24;
  *(float *)(v1 + 43060) = 9.8999998e24;
  *(float *)(v1 + 43064) = 9.8999998e24;
  *(float *)(v1 + 43068) = 9.8999998e24;
  *(float *)(v1 + 43072) = 9.8999998e24;
  *(_BYTE *)(v1 + 42432) = 0;
  sub_10061B00(v1 + 25404, (int)"MAN IN", dword_1031FB44 + 3912, 10.0, 5.0, 127.0, 127.0);
  *(float *)(v1 + 25624) = 158.0;
  *(_DWORD *)(v1 + 27480) = 54;
  *(float *)(v1 + 25628) = 382.0;
  *(float *)(v1 + 25728) = 224.0;
  *(float *)(v1 + 27704) = 73.0;
  *(float *)(v1 + 27708) = 88.0;
  *(float *)(v1 + 27744) = 23.0;
  *(float *)(v1 + 27736) = 0.5;
  *(float *)(v1 + 25504) = 73.0;
  *(float *)(v1 + 25508) = 80.0;
  *(float *)(v1 + 25552) = 9.0;
  *(float *)(v1 + 25544) = 0.5;
  *(float *)(v1 + 25440) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 25404);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 25404);
  sub_100612A0((int)&unk_100BA0A4, 2, 0.0, v1 + 25404);
  sub_10060F20(v1 + 204, 1, v1 + 25404);
  *(_WORD *)(v1 + 30962) = 5;
  *(_BYTE *)(v1 + 30968) = 1;
  *(_DWORD *)(v1 + 30964) = &unk_100B8DC0;
  sub_10061B00(v1 + 43080, (int)"RPM", dword_1031FB44 + 4076, 10.0, 117.0, 127.0, 127.0);
  *(float *)(v1 + 43300) = 158.0;
  *(_DWORD *)(v1 + 45156) = 54;
  *(float *)(v1 + 43304) = 382.0;
  *(float *)(v1 + 43404) = 224.0;
  *(float *)(v1 + 45380) = 73.0;
  *(float *)(v1 + 45384) = 200.0;
  *(float *)(v1 + 45420) = 23.0;
  *(float *)(v1 + 45412) = 0.5;
  *(float *)(v1 + 43180) = 73.0;
  *(float *)(v1 + 43184) = 192.0;
  *(float *)(v1 + 43228) = 9.0;
  *(float *)(v1 + 43220) = 0.5;
  *(float *)(v1 + 43116) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 43080);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 43080);
  sub_100612A0((int)&unk_100BA0C4, 2, 0.0, v1 + 43080);
  sub_10060F20(v1 + 216, 1, v1 + 43080);
  *(_WORD *)(v1 + 48638) = 6;
  *(_BYTE *)(v1 + 48644) = 1;
  *(_DWORD *)(v1 + 48640) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 15184, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4240, 0.40000001, 0.0, v1 + 15184);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 15184);
  sub_10049040(v1 + 228, 1, 0, v1 + 15184);
  sub_10049310((int)&unk_100BA0E8, 0xBu, 0, v1 + 15184);
  *(float *)(v1 + 15248) = 73.5;
  *(float *)(v1 + 15288) = 0.5;
  *(_WORD *)(v1 + 19496) = 33;
  *(_BYTE *)(v1 + 19504) = 1;
  *(_DWORD *)(v1 + 19500) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 15698) = 2;
  sub_1004A1A0(v1 + 32224, (int)"OIL PRES", dword_1031FB44 + 4404, 10.0, 299.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 32224);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 32224);
  sub_10049310((int)&unk_100BA198, 2u, 0, v1 + 32224);
  sub_10049040(v1 + 240, 1, 0, v1 + 32224);
  *(float *)(v1 + 32288) = 73.5;
  *(float *)(v1 + 32328) = 0.5;
  *(_WORD *)(v1 + 36536) = 15;
  *(_BYTE *)(v1 + 36544) = 1;
  *(_DWORD *)(v1 + 36540) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 32738) = 2;
  sub_1004A1A0(v1 + 37328, (int)"OIL TEMP", dword_1031FB44 + 4568, 10.0, 347.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 37328);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 37328);
  sub_10049310((int)&unk_100BA1B8, 2u, 0, v1 + 37328);
  sub_10049040(v1 + 252, 1, 0, v1 + 37328);
  *(float *)(v1 + 37392) = 73.5;
  *(float *)(v1 + 37432) = 0.5;
  *(_WORD *)(v1 + 41640) = 10;
  *(_BYTE *)(v1 + 41648) = 1;
  *(_DWORD *)(v1 + 41644) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 37842) = 2;
  sub_1004A1A0(v1 + 1888, (int)"CHT", dword_1031FB44 + 6700, 10.0, 395.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 6700, 0.40000001, 0.0, v1 + 1888);
  sub_100490F0(dword_1031FB44 + 20956, v1 + 1888);
  sub_10049310((int)&unk_100BA1D8, 2u, 0, v1 + 1888);
  sub_10049040(v1 + 264, 1, 0, v1 + 1888);
  *(float *)(v1 + 1952) = 73.5;
  *(float *)(v1 + 1992) = 0.5;
  *(_WORD *)(v1 + 6200) = 10;
  *(_BYTE *)(v1 + 6208) = 1;
  *(_DWORD *)(v1 + 6204) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 2402) = 2;
  sub_1004A1A0(v1 + 9468, (int)"EGT", dword_1031FB44 + 6864, 10.0, 443.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 6864, 0.40000001, 0.0, v1 + 9468);
  sub_100490F0(dword_1031FB44 + 20984, v1 + 9468);
  sub_10049310((int)&unk_100BA1F8, 0xBu, 0, v1 + 9468);
  sub_10049040(v1 + 276, 1, 0, v1 + 9468);
  *(float *)(v1 + 9532) = 73.5;
  *(float *)(v1 + 9572) = 0.5;
  *(_WORD *)(v1 + 13780) = 10;
  *(_BYTE *)(v1 + 13788) = 1;
  *(_DWORD *)(v1 + 13784) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 9982) = 2;
  sub_1004A1E0(v1 + 19684, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 491.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100BA2A8, 0xAu, 0, v1 + 19684);
  sub_10049040(v1 + 288, 2, 0, v1 + 19684);
  *(float *)(v1 + 20144) = 26.0;
  *(float *)(v1 + 20208) = 26.0;
  *(_WORD *)(v1 + 23996) = 31;
  *(_BYTE *)(v1 + 24004) = 1;
  *(_DWORD *)(v1 + 24000) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 20198) = 0;
  *(_BYTE *)(v1 + 20262) = 0;
  sub_10046920(v1 + 31612, (int)byte_100B8180, dword_1031FB44 + 5388, -109.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 31612);
  *(float *)(v1 + 31672) = 0.5;
  *(_WORD *)(v1 + 32128) = 21;
  *(_BYTE *)(v1 + 32136) = 1;
  *(_DWORD *)(v1 + 32132) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 31660) = v1 + 320;
  *(_BYTE *)(v1 + 31787) = 1;
  sub_10046920(v1 + 6996, (int)byte_100B8180, dword_1031FB44 + 5388, -12.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 6996);
  *(float *)(v1 + 7056) = 0.5;
  *(_WORD *)(v1 + 7512) = 21;
  *(_BYTE *)(v1 + 7520) = 1;
  *(_DWORD *)(v1 + 7516) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 7044) = v1 + 332;
  *(_BYTE *)(v1 + 7171) = 1;
  sub_10046920(v1 + 31000, (int)byte_100B8180, dword_1031FB44 + 5552, -109.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20760, v1 + 31000);
  *(_WORD *)(v1 + 31516) = 24;
  *(_BYTE *)(v1 + 31524) = 1;
  *(_DWORD *)(v1 + 31520) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 31048) = v1 + 344;
  *(_BYTE *)(v1 + 31175) = 1;
  *(float *)(v1 + 31060) = 0.5;
  sub_10046920(v1 + 48692, (int)byte_100B8180, dword_1031FB44 + 5716, -13.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20788, v1 + 48692);
  *(_WORD *)(v1 + 49208) = 24;
  *(_BYTE *)(v1 + 49216) = 1;
  *(_DWORD *)(v1 + 49212) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 48740) = v1 + 356;
  *(_BYTE *)(v1 + 48867) = 1;
  *(float *)(v1 + 48752) = 0.5;
  sub_10046920(v1 + 14572, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20536, v1 + 14572);
  *(_WORD *)(v1 + 15088) = 33;
  *(_BYTE *)(v1 + 15096) = 1;
  *(_DWORD *)(v1 + 15092) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 14620) = v1 + 368;
  sub_10046920(v1 + 42440, (int)"PEAK", dword_1031FB44 + 6536, 10.0, 436.0, 127.0, 15.0);
  *(_WORD *)(v1 + 42956) = 11;
  *(_BYTE *)(v1 + 42964) = 1;
  *(_DWORD *)(v1 + 42960) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 42488) = v1 + 380;
  *(float *)(v1 + 42468) = *(float *)(v1 + 42468) - 15.0;
  *(_WORD *)(v1 + 42736) = 18065;
  *(_BYTE *)(v1 + 42738) = 0;
  *(float *)(v1 + 42720) = 122.0;
  sub_10048850(v1 + 7608, (int)"EGT", dword_1031FB44 + 5224, 10.0, 271.0, 127.0, 106.0);
  sub_10047B10(v1 + 384, 6, 1, v1 + 7608);
  *(_BYTE *)(v1 + 8568) = 1;
  *(_BYTE *)(v1 + 8569) = 1;
  *(_WORD *)(v1 + 8572) = 10;
  *(_BYTE *)(v1 + 8570) = -1;
  *(float *)(v1 + 7716) = 412.0;
  *(float *)(v1 + 7752) = 0.0;
  *(float *)(v1 + 7756) = 1.0;
  *(_BYTE *)(v1 + 7708) = 16;
  *(_DWORD *)(v1 + 7684) = v1 + 43052;
  *(_DWORD *)(v1 + 7688) = v1 + 43056;
  *(_DWORD *)(v1 + 7692) = v1 + 43060;
  *(_DWORD *)(v1 + 7696) = v1 + 43064;
  *(_DWORD *)(v1 + 7700) = v1 + 43068;
  *(_DWORD *)(v1 + 7704) = v1 + 43072;
  sub_10046920(v1 + 8856, (int)"EGT F", dword_1031FB44 + 5224, 10.0, 414.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20704, v1 + 8856);
  *(_WORD *)(v1 + 9372) = 10;
  *(_BYTE *)(v1 + 9380) = 1;
  *(_DWORD *)(v1 + 9376) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 8904) = v1 + 464;
  sub_10048850(v1 + 640, (int)"CHT", dword_1031FB44 + 4732, 10.0, 456.0, 127.0, 91.0);
  sub_10047B10(v1 + 468, 6, 1, v1 + 640);
  *(_BYTE *)(v1 + 1600) = 1;
  *(_BYTE *)(v1 + 1601) = 1;
  *(_WORD *)(v1 + 1604) = 10;
  *(_BYTE *)(v1 + 1602) = -1;
  *(float *)(v1 + 748) = 582.0;
  *(float *)(v1 + 784) = 0.0;
  *(float *)(v1 + 788) = 1.0;
  *(_BYTE *)(v1 + 740) = 12;
  sub_10046920(v1 + 6380, (int)"CHT F", dword_1031FB44 + 4732, 10.0, 584.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20620, v1 + 6380);
  *(_WORD *)(v1 + 6896) = 10;
  *(_BYTE *)(v1 + 6904) = 1;
  *(_DWORD *)(v1 + 6900) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 6428) = v1 + 548;
  sub_10046920(v1 + 36716, (int)"OIL PSI", dword_1031FB44 + 4404, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20564, v1 + 36716);
  *(_WORD *)(v1 + 37232) = 15;
  *(_BYTE *)(v1 + 37240) = 1;
  *(_DWORD *)(v1 + 37236) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 36764) = v1 + 560;
  sub_10046920(v1 + 41820, (int)"OIL F", dword_1031FB44 + 4568, 10.0, 281.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20592, v1 + 41820);
  *(_WORD *)(v1 + 42336) = 10;
  *(_BYTE *)(v1 + 42344) = 1;
  *(_DWORD *)(v1 + 42340) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 41868) = v1 + 572;
  sub_10046920(v1 + 13960, (int)"ENG HRS", dword_1031FB44 + 5880, 10.0, 311.0, 127.0, 15.0);
  *(_WORD *)(v1 + 14476) = 39;
  *(_BYTE *)(v1 + 14484) = 1;
  *(_DWORD *)(v1 + 14480) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 14008) = v1 + 584;
  sub_1004A1A0(v1 + 49308, (int)"VAC", dword_1031FB44 + 6044, 10.0, 341.0, 127.0, 18.5, 0);
  sub_10049310((int)&unk_100BA348, 2u, 0, v1 + 49308);
  sub_10049040(v1 + 588, 1, 0, v1 + 49308);
  *(_WORD *)(v1 + 53620) = 15;
  *(_BYTE *)(v1 + 53628) = 1;
  *(_DWORD *)(v1 + 53624) = &unk_100B8DC0;
  *(float *)(v1 + 49372) = 73.5;
  *(float *)(v1 + 49412) = 0.5;
  *(_BYTE *)(v1 + 49822) = 2;
  sub_10046920(v1 + 24788, (int)"GAL USED", dword_1031FB44 + 6208, 10.0, 434.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20872, v1 + 24788);
  *(_WORD *)(v1 + 25304) = 31;
  *(_BYTE *)(v1 + 25312) = 1;
  *(_DWORD *)(v1 + 25308) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 24836) = v1 + 608;
  sub_10046920(v1 + 24176, (int)"GAL REM", dword_1031FB44 + 6372, 10.0, 464.0, 127.0, 15.0);
  *(_WORD *)(v1 + 24692) = 30;
  *(_BYTE *)(v1 + 24700) = 1;
  *(_DWORD *)(v1 + 24696) = &unk_100B8DC0;
  result = v1 + 620;
  *(_DWORD *)(v1 + 24224) = v1 + 620;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10008CA0) --------------------------------------------------------
signed int __cdecl sub_10008CA0(int a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  signed int result; // eax@1
  int v4; // ecx@1
  char *v5; // ebx@20
  _BYTE *v6; // ebp@20
  float *v7; // edi@20
  __int16 v8; // fps@60
  bool v9; // c0@60
  char v10; // c2@60
  bool v11; // c3@60
  double v12; // st7@61
  __int16 v13; // fps@61
  double v14; // st6@61
  bool v15; // c0@61
  char v16; // c2@61
  bool v17; // c3@61
  int v18; // edx@67
  int v19; // ecx@67
  int v20; // [sp+4h] [bp-28h]@1
  __int16 v21; // [sp+8h] [bp-24h]@1
  int v22; // [sp+Ch] [bp-20h]@1
  char v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@20
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+1Ch] [bp-10h]@1
  int v27; // [sp+20h] [bp-Ch]@1
  __int16 v28; // [sp+24h] [bp-8h]@1
  char v29; // [sp+26h] [bp-6h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v22 = 0;
  v21 = -32713;
  v23 = 9;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  result = sub_10052230(v1) != 1 ? 9 : 14;
  v4 = result;
  v20 = result;
  if ( 9.8999998e24 != *(float *)(v2 + 224) && *(float *)(dword_1031FB44 + 28) < (double)*(float *)(v2 + 224) )
  {
    if ( !*(_BYTE *)(v2 + 48676) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(result, (int)&v21, 10, 1);
      v4 = v20;
    }
    LOBYTE(v25) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 248)
    && (*(float *)(v2 + 32596) >= (double)*(float *)(v2 + 248) || *(float *)(v2 + 32620) < (double)*(float *)(v2 + 248)) )
  {
    if ( !*(_BYTE *)(v2 + 48677) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    BYTE1(v25) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 260) && *(float *)(v2 + 37716) <= (double)*(float *)(v2 + 260) )
  {
    if ( !*(_BYTE *)(v2 + 48678) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    BYTE2(v25) = 1;
  }
  v5 = (char *)&v25 + 3;
  v6 = (_BYTE *)(v2 + 48679);
  v7 = (float *)(v2 + 476);
  v24 = 6;
  do
  {
    if ( 9.8999998e24 != *v7 && *(float *)(v2 + 2268) < (double)*v7 )
    {
      if ( !*v6 && *(_BYTE *)(v2 + 43076) )
      {
        v23 = 4;
        result = sub_1008C880(v4, (int)&v21, 10, 1);
        v4 = v20;
      }
      *v5 = 1;
    }
    v7 += 3;
    ++v6;
    ++v5;
    --v24;
  }
  while ( v24 );
  if ( 9.8999998e24 != *(float *)(v2 + 296) && *(float *)(v2 + 20064) >= (double)*(float *)(v2 + 296) )
  {
    if ( !*(_BYTE *)(v2 + 48685) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    BYTE1(v27) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 308) && *(float *)(v2 + 20064) >= (double)*(float *)(v2 + 308) )
  {
    if ( !*(_BYTE *)(v2 + 48686) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    BYTE2(v27) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 320)
    && (*(float *)(v2 + 32048) >= (double)*(float *)(v2 + 320) || *(float *)(v2 + 32056) < (double)*(float *)(v2 + 320)) )
  {
    if ( !*(_BYTE *)(v2 + 48687) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    BYTE3(v27) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 332)
    && (*(float *)(v2 + 7432) >= (double)*(float *)(v2 + 332) || *(float *)(v2 + 7440) < (double)*(float *)(v2 + 332)) )
  {
    if ( !*(_BYTE *)(v2 + 48688) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    LOBYTE(v28) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 344) && *(float *)(v2 + 31436) >= (double)*(float *)(v2 + 344) )
  {
    if ( !*(_BYTE *)(v2 + 48689) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
      v4 = v20;
    }
    HIBYTE(v28) = 1;
  }
  v9 = 9.8999998e24 < *(float *)(v2 + 356);
  v10 = 0;
  v11 = 9.8999998e24 == *(float *)(v2 + 356);
  BYTE1(result) = HIBYTE(v8);
  if ( 9.8999998e24 == *(float *)(v2 + 356)
    || (v12 = *(float *)(v2 + 356),
        v14 = *(float *)(v2 + 49128),
        v15 = v14 < v12,
        v16 = 0,
        v17 = v14 == v12,
        BYTE1(result) = HIBYTE(v13),
        v14 < v12) )
  {
    LOBYTE(result) = v29;
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 48690) && *(_BYTE *)(v2 + 43076) )
    {
      v23 = 4;
      result = sub_1008C880(v4, (int)&v21, 10, 1);
    }
    LOBYTE(result) = 1;
  }
  v18 = v26;
  *(_DWORD *)(v2 + 48676) = v25;
  v19 = v27;
  *(_DWORD *)(v2 + 48680) = v18;
  LOWORD(v18) = v28;
  *(_DWORD *)(v2 + 48684) = v19;
  *(_WORD *)(v2 + 48688) = v18;
  *(_BYTE *)(v2 + 48690) = result;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10009130) --------------------------------------------------------
int __usercall sub_10009130@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA41C, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 164),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 144),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 184),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10009190) --------------------------------------------------------
char __usercall sub_10009190@<al>(int a1@<esi>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 43076) = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 6992) = 1;
  *(float *)(v1 + 43052) = 9.8999998e24;
  *(float *)(v1 + 43056) = 9.8999998e24;
  *(float *)(v1 + 43060) = 9.8999998e24;
  *(float *)(v1 + 43064) = 9.8999998e24;
  *(float *)(v1 + 43068) = 9.8999998e24;
  *(float *)(v1 + 43072) = 9.8999998e24;
  *(_BYTE *)(v1 + 42432) = 0;
  sub_1004C170(*(_BYTE *)(v1 + 43076));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10009200) --------------------------------------------------------
char __usercall sub_10009200@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // ecx@1
  signed int v6; // eax@1
  void *v7; // ecx@12
  int v8; // eax@16
  char result; // al@16
  int v10; // [sp+18h] [bp-Ch]@4
  float v11; // [sp+1Ch] [bp-8h]@3
  int v12; // [sp+20h] [bp-4h]@1

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 53840, 0);
  v4 = v3;
  *(_DWORD *)(v3 + 48676) = 0;
  *(_DWORD *)(v3 + 48680) = 0;
  *(_DWORD *)(v3 + 48684) = 0;
  *(_WORD *)(v3 + 48688) = 0;
  *(_BYTE *)(v3 + 48690) = 0;
  *(_BYTE *)(v3 + 53836) = 0;
  *(_BYTE *)(v3 + 49304) = 0;
  *(_BYTE *)(v3 + 49304) = sub_10052210(v5);
  *(_DWORD *)(v4 + 164) = &unk_100BA438;
  *(_DWORD *)(v4 + 172) = &unk_100BA4B8;
  *(_DWORD *)(v4 + 168) = &unk_100BA484;
  *(_DWORD *)(v4 + 148) = v4 + 92;
  v12 = v4 + 92;
  *(_DWORD *)(v4 + 184) = v4 + 116;
  *(_DWORD *)(v4 + 192) = v4 + 125;
  *(_DWORD *)(v4 + 188) = v4 + 136;
  *(_DWORD *)(v4 + 144) = v4 + 12;
  *(_DWORD *)(v4 + 152) = v4 + 48;
  *(_BYTE *)(v4 + 116) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 184) + 8) = 3;
  **(_BYTE **)(v4 + 188) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 188) + 5) = 3;
  v6 = 0;
  do
    *(_BYTE *)(v6++ + *(_DWORD *)(v4 + 192)) = 3;
  while ( v6 < 11 );
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BA0E4);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10007BF0(a1);
  if ( !sub_10066790(3u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 624, v10, 1.0, 0.125);
  if ( !sub_10066790(0x56u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 632, v10, 1.0, 0.125);
  if ( !sub_100663D0(&v11) || !sub_10031F70(100000.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 19676, v10, 1.0, 0.125);
  *(_BYTE *)(v4 + 25402) = sub_1004BEE0(v7);
  *(_BYTE *)(v4 + 25400) = 1;
  *(_BYTE *)(v4 + 25401) = 1;
  if ( sub_10007B40(0) )
    *(_BYTE *)(v4 + 25400) = 0;
  if ( sub_10007B40(2) )
    *(_BYTE *)(v4 + 25401) = 0;
  *(_DWORD *)(v4 + 8) = v4 + 19684;
  *(_DWORD *)v4 = v4 + 25404;
  *(_DWORD *)(v4 + 4) = v4 + 43080;
  *(_DWORD *)(v4 + 20) = v4 + 37328;
  *(_DWORD *)(v4 + 36) = v4 + 6996;
  *(_DWORD *)(v4 + 12) = v4 + 15184;
  *(_DWORD *)(v4 + 16) = v4 + 32224;
  *(_DWORD *)(v4 + 40) = v4 + 31000;
  *(_DWORD *)(v4 + 24) = v4 + 1888;
  *(_DWORD *)(v4 + 28) = v4 + 9468;
  *(_DWORD *)(v4 + 44) = v4 + 48692;
  v8 = v12;
  *(_DWORD *)(v4 + 32) = v4 + 31612;
  *(_DWORD *)v8 = v4 + 14572;
  *(_DWORD *)(v8 + 4) = v4 + 42440;
  *(_DWORD *)(v8 + 8) = v4 + 8856;
  *(_DWORD *)(v8 + 12) = v4 + 7608;
  *(_DWORD *)(v8 + 16) = v4 + 6380;
  *(_DWORD *)(v8 + 20) = v4 + 640;
  *(_DWORD *)(v4 + 48) = v4 + 36716;
  *(_DWORD *)(v4 + 56) = v4 + 13960;
  *(_DWORD *)(v4 + 64) = v4 + 14572;
  *(_DWORD *)(v4 + 68) = v4 + 24176;
  *(_DWORD *)(v4 + 52) = v4 + 41820;
  *(_DWORD *)(v4 + 80) = v4 + 6996;
  *(_DWORD *)(v4 + 60) = v4 + 49308;
  *(_DWORD *)(v4 + 84) = v4 + 31000;
  *(_DWORD *)(v4 + 72) = v4 + 24788;
  *(_DWORD *)(v4 + 76) = v4 + 31612;
  *(_DWORD *)(v4 + 88) = v4 + 48692;
  *(_BYTE *)(v4 + 43076) = sub_1004BF10((void *)(v4 + 31612));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA41C, v4, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA438, v4 + 12, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA484, v12, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100096A0) --------------------------------------------------------
char __usercall sub_100096A0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // al@3
  unsigned __int8 v3; // al@6
  int v4; // ST04_4@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( !*(_BYTE *)(v1 + 25402) )
    {
      v3 = ++*(_BYTE *)(v1 + 8570);
      *(_BYTE *)(v1 + 6992) = 0;
      if ( v3 >= *(_BYTE *)(dword_1031FB44 + 25) )
        *(_BYTE *)(v1 + 8570) = 0;
      *(_BYTE *)(v1 + 1602) = *(_BYTE *)(v1 + 8570);
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    v2 = *(_BYTE *)(v1 + 25402) == 0;
    *(_BYTE *)(v1 + 25402) = v2;
    sub_1004C150(v2);
    if ( !*(_BYTE *)(v1 + 25402) )
    {
      *(_BYTE *)(v1 + 6992) = 1;
      *(_BYTE *)(v1 + 42432) = 0;
    }
  }
  v4 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v4, -32734);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10009740) --------------------------------------------------------
void __usercall sub_10009740(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // edi@1
  float *v3; // ebx@1
  int v4; // ecx@8
  float *v5; // edx@8
  float v6; // [sp+0h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 472);
  do
  {
    v6 = sub_1004C3E0((unsigned __int16)v2 + 8);
    if ( v6 != 9.8999998e24 )
      *v3 = v6 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 6 );
  if ( *(_BYTE *)(v1 + 6992) || *(_BYTE *)(v1 + 25402) )
    *(_BYTE *)(v1 + 1602) = sub_10066EE0(v1 + 204, 0x16u, 6u);
  v4 = *(_BYTE *)(v1 + 1602);
  v5 = (float *)(v1 + 12 * v4 + 472);
  if ( 9.8999998e24 != *v5 )
  {
    *(float *)(v1 + 268) = *v5;
    sprintf((char *)(v1 + 2372), "%d", v4 + 1);
    *(float *)(v1 + 544) = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 1602) + 472);
  }
}

//----- (10009820) --------------------------------------------------------
void __usercall sub_10009820(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // ebp@1
  float *v3; // edi@1
  double v4; // st7@2
  bool v5; // zf@6
  signed int v6; // edx@7
  float *v7; // edi@7
  float *v8; // ecx@7
  int v9; // eax@17
  float *v10; // ecx@17
  double v11; // st6@17
  signed int v12; // eax@17
  int v13; // ecx@26
  float *v14; // edx@26
  float v15; // [sp+10h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 388);
  do
  {
    v15 = sub_1004C3E0((unsigned __int16)v2 + 14);
    v4 = 9.8999998e24;
    if ( v15 != 9.8999998e24 )
      *v3 = v15 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 6 );
  if ( *(_BYTE *)(v1 + 25402) )
  {
    v5 = *(_BYTE *)(v1 + 42432) == 0;
    *(_BYTE *)(v1 + 42613) = 0;
    *(_BYTE *)(v1 + 42614) = 0;
    *(_BYTE *)(v1 + 42615) = 0;
    if ( v5 )
    {
      v6 = 0;
      v7 = (float *)(v1 + 388);
      v8 = (float *)(v1 + 43052);
      while ( 1 )
      {
        if ( 9.8999998e24 == *v8 )
          *v8 = 0.0;
        if ( *v8 < (double)*v7 )
          *v8 = *v7;
        if ( *v8 - *v7 > 7.0 )
          break;
        ++v6;
        ++v8;
        v7 += 3;
        if ( v6 >= 6 )
          goto LABEL_16;
      }
      *(_BYTE *)(v1 + 42432) = 1;
      *(_BYTE *)(v1 + 8570) = v6;
      *(_BYTE *)(v1 + 6992) = 0;
    }
LABEL_16:
    if ( *(_BYTE *)(v1 + 42432) == 1 )
    {
      v9 = *(_BYTE *)(v1 + 8570);
      *(_BYTE *)(v1 + 8567) = 0;
      v10 = (float *)(v1 + 43052);
      v11 = *(float *)(v1 + 12 * v9 + 388) - *(float *)(v1 + 4 * v9 + 43052);
      v12 = 0;
      *(float *)(v1 + 42436) = v11;
      do
      {
        if ( v12 != *(_BYTE *)(v1 + 8570) )
          *v10 = 9.8999998e24;
        ++v12;
        ++v10;
      }
      while ( v12 < 6 );
      *(float *)(v1 + 376) = *(float *)(v1 + 42436);
    }
    else
    {
      *(_BYTE *)(v1 + 8567) = 1;
      *(float *)(v1 + 42436) = 100000.0;
      *(float *)(v1 + 376) = *(float *)(v1 + 42436);
    }
  }
  else
  {
    *(_BYTE *)(v1 + 42613) = 1;
    *(_BYTE *)(v1 + 42614) = 1;
    *(_BYTE *)(v1 + 42615) = 1;
    *(_DWORD *)(v1 + 43052) = 1761805953;
    *(_DWORD *)(v1 + 43056) = 1761805953;
    *(_DWORD *)(v1 + 43060) = 1761805953;
    *(_DWORD *)(v1 + 43064) = 1761805953;
    *(_DWORD *)(v1 + 43068) = 1761805953;
    *(_DWORD *)(v1 + 43072) = 1761805953;
  }
  if ( *(_BYTE *)(v1 + 6992) )
  {
    v4 = 9.8999998e24;
    *(_BYTE *)(v1 + 8570) = sub_10066EE0(v1 + 204, 0xFu, 6u);
  }
  v13 = *(_BYTE *)(v1 + 8570);
  v14 = (float *)(v1 + 12 * v13 + 388);
  if ( v4 != *v14 )
  {
    *(float *)(v1 + 280) = *v14;
    sprintf((char *)(v1 + 9952), "%d", v13 + 1);
    *(float *)(v1 + 460) = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 8570) + 388);
  }
}

//----- (10009A50) --------------------------------------------------------
void __usercall sub_10009A50(int a1@<eax>)
{
  int v1; // ebx@1
  long double v2; // st7@1
  int v3; // esi@1
  float *v4; // edi@1
  float *v5; // eax@1
  signed int v6; // ecx@1
  double v7; // st7@5
  double v8; // st7@6
  int v9; // edx@16
  int v10; // ecx@16
  double v11; // st7@22
  signed int v12; // ebx@22
  double v13; // st6@24
  float v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  float v16; // [sp+20h] [bp-Ch]@5
  int v17; // [sp+24h] [bp-8h]@1
  int v18; // [sp+28h] [bp-4h]@1

  v1 = a1;
  v15 = 0;
  v2 = pow(2.0, 31.0);
  v17 = (signed int)(v2 - 1.0);
  v18 = (signed int)(v2 * -1.0);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v14 = 0.0;
  v4 = (float *)(v3 + 208);
  v5 = (float *)(v3 + 208);
  v6 = 35;
  do
  {
    *v5 = 9.8999998e24;
    v5 += 3;
    --v6;
  }
  while ( v6 );
  *v4 = sub_1004C3E0(0x18u);
  *(float *)(v3 + 220) = sub_1004C3E0(0x1Eu);
  if ( sub_100663D0(&v14) && sub_10031F70(100000.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 19676, v15);
    v16 = (double)*(signed int *)(v3 + 19680) / 100000.0;
    v7 = v16;
    *(float *)(v3 + 232) = v16;
    *(float *)(v3 + 364) = v7;
  }
  v16 = sub_1004C3E0(0x1Cu);
  v8 = v16;
  *(float *)(v3 + 244) = v16;
  *(float *)(v3 + 556) = v8;
  v14 = sub_1004C3E0(0x1Du);
  if ( v14 != 9.8999998e24 )
  {
    *(float *)(v3 + 256) = v14 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 568) = 1.799999952316284 * v14 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 49304) == 2 )
  {
    *(_BYTE *)(v3 + 25400) = sub_10007B40(0) == 0;
    *(_BYTE *)(v3 + 25401) = sub_10007B40(2) == 0;
  }
  if ( sub_100664A0(&v14) && !*(_BYTE *)(v3 + 25400) )
    *(float *)(v3 + 292) = v14;
  if ( sub_10066510(&v14) && !*(_BYTE *)(v3 + 25401) )
    *(float *)(v3 + 304) = v14;
  *(float *)(v3 + 616) = sub_1004C0C0();
  *(float *)(v3 + 604) = sub_1004C0D0(v10, v9);
  *(float *)(v3 + 316) = sub_1004C3E0(4u);
  *(float *)(v3 + 328) = sub_1004C3E0(5u);
  sub_10009820(v1);
  sub_10009740(v1);
  *(float *)(v3 + 580) = sub_1004C070();
  *(float *)(v3 + 592) = sub_1004C3E0(0x20u);
  if ( sub_10066790(3u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 624, v15);
    *(float *)(v3 + 340) = (double)*(signed int *)(v3 + 628) / 100.0;
  }
  if ( sub_10066790(0x56u, &v14) && sub_10031F70(100.0, v14, (int)&v15) )
  {
    sub_100666C0(v3 + 632, v15);
    *(float *)(v3 + 352) = (double)*(signed int *)(v3 + 636) / 100.0;
  }
  v11 = 9.8999998e24;
  v12 = 35;
  do
  {
    v16 = *v4;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || (v13 = *v4 / *(v4 - 1), (double)v17 < v13) || (double)v18 > v13 )
    {
      if ( v11 != *v4 )
      {
        sub_10051A40(".\\cdp_pg_eis_cessna_206h_3d.c", 3364, 0, "Gauge data is not finite");
        v11 = 9.8999998e24;
      }
      *v4 = v11;
    }
    v4 += 3;
    --v12;
  }
  while ( v12 );
  sub_1004C380(v3 + 204, 0x23u);
  if ( *(float *)(v3 + 49136) > (double)*(float *)(v3 + 356) && *(float *)(v3 + 49128) < (double)*(float *)(v3 + 356) )
  {
    *(float *)(v3 + 352) = 0.0;
    *(float *)(v3 + 356) = 0.0;
  }
  if ( *(float *)(v3 + 344) >= 100.0 || *(float *)(v3 + 344) <= -100.0 )
    *(_WORD *)(v3 + 31516) = 23;
  else
    *(_WORD *)(v3 + 31516) = 24;
  if ( *(float *)(v3 + 356) >= 100.0 || *(float *)(v3 + 356) <= -100.0 )
    *(_WORD *)(v3 + 49208) = 23;
  else
    *(_WORD *)(v3 + 49208) = 24;
  if ( *(float *)(v3 + 320) >= 100.0 || *(float *)(v3 + 320) <= -10.0 )
    *(_WORD *)(v3 + 32128) = 20;
  else
    *(_WORD *)(v3 + 32128) = 21;
  if ( *(float *)(v3 + 332) >= 100.0 || *(float *)(v3 + 332) <= -10.0 )
    *(_WORD *)(v3 + 7512) = 20;
  else
    *(_WORD *)(v3 + 7512) = 21;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (10009EE0) --------------------------------------------------------
void __usercall sub_10009EE0(int a1@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v1 + 224) )
    *(_BYTE *)(v1 + 45072) = 10;
  else
    *(_BYTE *)(v1 + 45072) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10009F10) --------------------------------------------------------
char __usercall sub_10009F10@<al>(int a1@<edi>)
{
  int v1; // esi@1
  float *v2; // ebp@4
  char result; // al@5
  double v4; // st7@6
  float *v5; // ebp@8
  float v6; // ST44_4@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10009A50(a1);
  sub_10009EE0(a1);
  sub_10008CA0(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA368, (int)&unk_100BA514, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BA41C, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 164),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 144),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43076) + 184),
    255);
  if ( *(_BYTE *)(v1 + 43076) != 1 )
  {
    *(_BYTE *)(v1 + 25402) = 0;
    sub_1004C150(0);
    *(_BYTE *)(v1 + 6992) = 1;
    *(_BYTE *)(v1 + 42432) = 0;
  }
  if ( !*(_BYTE *)(v1 + 43076) )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 53824) = 0.5;
    v2 = (float *)(v1 + 53800);
    *(float *)(v1 + 53828) = 0.5;
    *(_DWORD *)(v1 + 53816) = -14671840;
    *(float *)(v1 + 53800) = 75.5;
    *(_DWORD *)(v1 + 53820) = -1;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 565.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 53800);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 612.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 53800);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 53800);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 53800);
    *v2 = 75.5;
    *(float *)(v1 + 53804) = 667.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 53800);
    sub_10048A00(10.0, 491.0, v1 + 19684);
  }
  result = *(_BYTE *)(v1 + 43076);
  if ( result == 1 )
  {
    sub_10046480(10.0, 251.0, v1 + 14572);
    sub_10046480(10.0, 584.0, v1 + 6380);
    v4 = 624.0;
LABEL_9:
    v6 = v4;
    result = sub_10048A00(10.0, v6, v1 + 19684);
    goto LABEL_10;
  }
  if ( result == 2 )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    sub_1008C2F0(10.0, 374.0);
    sub_1008C2F0(137.0, 374.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 53824) = 0.5;
    v5 = (float *)(v1 + 53800);
    *(float *)(v1 + 53828) = 0.5;
    *(_DWORD *)(v1 + 53816) = -14671840;
    *(float *)(v1 + 53800) = 75.5;
    *(_DWORD *)(v1 + 53820) = -1;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 565.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 374.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
    sub_10065B50(a1, (int)"FUEL CALC", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 53800);
    *v5 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v5 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 588.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 612.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 53800);
    *v5 = 24.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 53800);
    *v5 = 126.0;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 643.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 53800);
    *v5 = 75.5;
    *(_DWORD *)(v1 + 53808) = 2;
    *(float *)(v1 + 53804) = 667.0;
    *(float *)(v1 + 53812) = 12.0;
    *(float *)(v1 + 53832) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 53800);
    sub_10046480(10.0, 404.0, v1 + 14572);
    sub_10046480(10.0, 251.0, v1 + 36716);
    v4 = 491.0;
    goto LABEL_9;
  }
LABEL_10:
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1000A770) --------------------------------------------------------
char __cdecl sub_1000A770(int a1)
{
  int v1; // eax@1
  char result; // al@9

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_10009130(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10009200(a1, 0, 0);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_10009F10(a1);
      break;
    case 32821:
      JUMPOUT(&loc_10006870);
      return result;
    case 32820:
      JUMPOUT(&loc_10006880);
      return result;
    case 32825:
      LOBYTE(v1) = sub_10009190(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v1) = sub_100096A0(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (1000A860) --------------------------------------------------------
bool __cdecl sub_1000A860(char a1)
{
  bool v1; // zf@6
  bool v2; // bl@8
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+10h] [bp-14h]@1

  v6 = 1;
  v7 = 0;
  LOBYTE(v5) = 67;
  v4 = 2;
  if ( a1 )
  {
    if ( a1 == 2 )
      LOBYTE(v5) = 7;
  }
  else
  {
    LOBYTE(v5) = 6;
  }
  sub_10065D40(a1, &v4);
  sub_10065C60(v5, 1, 9, (int)&v6, (int)&v7, 16);
  if ( v7 == 3 )
    v1 = v4 == 0;
  else
    v1 = v4 == 1;
  v2 = v1;
  if ( !v1 )
    sub_10051A40(
      ".\\cdp_pg_eis_cessna_t182t_3d.c",
      1239,
      0,
      "Fuel sensor calibration does not match fuel sensor configuration");
  return v2;
}

//----- (1000A910) --------------------------------------------------------
int __usercall sub_1000A910@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  double v5; // st7@3
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"QC";
  v3 = v1 + 216;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)".\\cdp_pg_eis_cessna_t182t_3d.c" );
  *(_DWORD *)(v1 + 54588) = 2;
  *(float *)(v1 + 54580) = 0.0;
  *(_DWORD *)(v1 + 54596) = 0;
  *(float *)(v1 + 54584) = 0.0;
  *(_DWORD *)(v1 + 54600) = -1;
  *(float *)(v1 + 54592) = 12.0;
  *(float *)(v1 + 54604) = 0.5;
  *(float *)(v1 + 54608) = 1.0;
  *(float *)(v1 + 54612) = 40.0;
  qmemcpy((void *)(v1 + 26528), (const void *)(dword_1031FB44 + 3912), 0xA4u);
  *(_BYTE *)(v1 + 20930) = sub_1004BEE0(0);
  *(_BYTE *)(v1 + 7012) = 1;
  *(_BYTE *)(v1 + 38740) = 0;
  sub_10061B00(v1 + 20932, (int)"MAN IN", dword_1031FB44 + 3912, 10.0, 5.0, 127.0, 127.0);
  *(_DWORD *)(v1 + 23008) = 54;
  *(float *)(v1 + 21152) = 158.0;
  *(float *)(v1 + 21156) = 382.0;
  *(float *)(v1 + 21256) = 224.0;
  *(float *)(v1 + 23232) = 73.0;
  *(float *)(v1 + 23236) = 73.0;
  *(float *)(v1 + 23272) = 23.0;
  *(float *)(v1 + 23264) = 0.5;
  *(float *)(v1 + 21032) = 73.0;
  *(float *)(v1 + 21036) = 68.0;
  *(float *)(v1 + 21080) = 9.0;
  *(float *)(v1 + 21072) = 0.5;
  *(float *)(v1 + 20968) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 20932);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 20932);
  sub_100612A0((int)&unk_100BABE4, 3, 0.0, v1 + 20932);
  sub_10060F20(v1 + 212, 1, v1 + 20932);
  *(_WORD *)(v1 + 26490) = 5;
  *(_BYTE *)(v1 + 26496) = 1;
  *(_DWORD *)(v1 + 26492) = &unk_100B8DC0;
  sub_10061B00(v1 + 38752, (int)"RPM", dword_1031FB44 + 4076, 10.0, 117.0, 127.0, 127.0);
  *(float *)(v1 + 38972) = 158.0;
  *(_DWORD *)(v1 + 40828) = 54;
  *(float *)(v1 + 38976) = 382.0;
  *(float *)(v1 + 39076) = 224.0;
  *(float *)(v1 + 41052) = 73.0;
  *(float *)(v1 + 41056) = 185.0;
  *(float *)(v1 + 41092) = 23.0;
  *(float *)(v1 + 41084) = 0.5;
  *(float *)(v1 + 38852) = 73.0;
  *(float *)(v1 + 38856) = 180.0;
  *(float *)(v1 + 38900) = 9.0;
  *(float *)(v1 + 38892) = 0.5;
  *(float *)(v1 + 38788) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 38752);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 38752);
  sub_100612A0((int)&unk_100BAC14, 2, 0.0, v1 + 38752);
  sub_10060F20(v1 + 224, 1, v1 + 38752);
  *(_WORD *)(v1 + 44310) = 6;
  *(_BYTE *)(v1 + 44316) = 1;
  *(_DWORD *)(v1 + 44312) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 10712, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4240, 0.40000001, 0.0, v1 + 10712);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 10712);
  sub_10049040(v1 + 236, 1, 0, v1 + 10712);
  sub_10049310((int)&unk_100BAC38, 0xEu, 0, v1 + 10712);
  *(float *)(v1 + 12076) = 3.0;
  v5 = *(float *)(v1 + 12068);
  *(_WORD *)(v1 + 15024) = 33;
  *(_BYTE *)(v1 + 15032) = 1;
  *(_DWORD *)(v1 + 15028) = &unk_100B8DC0;
  *(float *)(v1 + 12068) = v5 + 4.0;
  *(_BYTE *)(v1 + 11226) = 2;
  *(float *)(v1 + 12072) = *(float *)(v1 + 12072) + 4.0;
  *(float *)(v1 + 10776) = 73.5;
  *(float *)(v1 + 10816) = 0.5;
  sub_1004A1A0(v1 + 27916, (int)"OIL PRES", dword_1031FB44 + 4404, 10.0, 299.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 27916);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 27916);
  sub_10049310((int)&unk_100BAD18, 2u, 0, v1 + 27916);
  sub_10049040(v1 + 248, 1, 0, v1 + 27916);
  *(float *)(v1 + 27980) = 73.5;
  *(float *)(v1 + 28020) = 0.5;
  *(_WORD *)(v1 + 32228) = 15;
  *(_BYTE *)(v1 + 32236) = 1;
  *(_DWORD *)(v1 + 32232) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 28430) = 2;
  sub_1004A1A0(v1 + 33020, (int)"OIL TEMP", dword_1031FB44 + 4568, 10.0, 347.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 33020);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 33020);
  sub_10049310((int)&unk_100BAD38, 2u, 0, v1 + 33020);
  sub_10049040(v1 + 260, 1, 0, v1 + 33020);
  *(float *)(v1 + 33084) = 73.5;
  *(float *)(v1 + 33124) = 0.5;
  *(_WORD *)(v1 + 37332) = 10;
  *(_BYTE *)(v1 + 37340) = 1;
  *(_DWORD *)(v1 + 37336) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 33534) = 2;
  sub_1004A1A0(v1 + 1908, (int)"CHT", dword_1031FB44 + 6700, 10.0, 395.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 6700, 0.40000001, 0.0, v1 + 1908);
  sub_100490F0(dword_1031FB44 + 20956, v1 + 1908);
  sub_10049310((int)&unk_100BAD58, 2u, 0, v1 + 1908);
  sub_10049040(v1 + 272, 1, 0, v1 + 1908);
  *(float *)(v1 + 1972) = 73.5;
  *(float *)(v1 + 2012) = 0.5;
  *(_WORD *)(v1 + 6220) = 10;
  *(_BYTE *)(v1 + 6228) = 1;
  *(_DWORD *)(v1 + 6224) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 2422) = 2;
  sub_1004A1A0(v1 + 45596, (int)"TIT", dword_1031FB44 + 4896, 10.0, 443.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4896, 0.40000001, 0.0, v1 + 45596);
  sub_100490F0(dword_1031FB44 + 20648, v1 + 45596);
  sub_10049310((int)&unk_100BAD78, 2u, 0, v1 + 45596);
  sub_10049040(v1 + 284, 1, 0, v1 + 45596);
  *(float *)(v1 + 45660) = 73.5;
  *(float *)(v1 + 45700) = 0.5;
  *(_WORD *)(v1 + 49908) = 10;
  *(_BYTE *)(v1 + 49916) = 1;
  *(_DWORD *)(v1 + 49912) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 46110) = 2;
  sub_1004A1E0(v1 + 15212, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 491.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100BAD98, 0xAu, 0, v1 + 15212);
  sub_10049040(v1 + 296, 2, 0, v1 + 15212);
  *(float *)(v1 + 15672) = 26.0;
  *(float *)(v1 + 15736) = 26.0;
  *(_WORD *)(v1 + 19524) = 31;
  *(_BYTE *)(v1 + 19532) = 1;
  *(_DWORD *)(v1 + 19528) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 15726) = 0;
  *(_BYTE *)(v1 + 15790) = 0;
  sub_10046920(v1 + 27304, (int)byte_100B8180, dword_1031FB44 + 5388, -109.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 27304);
  *(_WORD *)(v1 + 27820) = 21;
  *(_BYTE *)(v1 + 27828) = 1;
  *(_DWORD *)(v1 + 27824) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 27352) = v1 + 328;
  *(float *)(v1 + 27364) = 0.5;
  *(_BYTE *)(v1 + 27479) = 1;
  sub_10046920(v1 + 7016, (int)byte_100B8180, dword_1031FB44 + 5388, -12.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 7016);
  *(_WORD *)(v1 + 7532) = 21;
  *(_BYTE *)(v1 + 7540) = 1;
  *(_DWORD *)(v1 + 7536) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 7064) = v1 + 340;
  *(_BYTE *)(v1 + 7191) = 1;
  *(float *)(v1 + 7076) = 0.5;
  sub_10046920(v1 + 26692, (int)byte_100B8180, dword_1031FB44 + 5552, -109.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20760, v1 + 26692);
  *(_WORD *)(v1 + 27208) = 24;
  *(_BYTE *)(v1 + 27216) = 1;
  *(_DWORD *)(v1 + 27212) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 26740) = v1 + 352;
  *(_BYTE *)(v1 + 26867) = 1;
  *(float *)(v1 + 26752) = 0.5;
  sub_10046920(v1 + 44368, (int)byte_100B8180, dword_1031FB44 + 5716, -13.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20788, v1 + 44368);
  *(_WORD *)(v1 + 44884) = 24;
  *(_BYTE *)(v1 + 44892) = 1;
  *(_DWORD *)(v1 + 44888) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 44416) = v1 + 364;
  *(_BYTE *)(v1 + 44543) = 1;
  *(float *)(v1 + 44428) = 0.5;
  sub_10046920(v1 + 10100, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20536, v1 + 10100);
  *(_WORD *)(v1 + 10616) = 33;
  *(_BYTE *)(v1 + 10624) = 1;
  *(_DWORD *)(v1 + 10620) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 10148) = v1 + 376;
  sub_10046920(v1 + 44984, (int)"TIT F", dword_1031FB44 + 4896, 10.0, 276.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20648, v1 + 44984);
  *(_WORD *)(v1 + 45500) = 10;
  *(_BYTE *)(v1 + 45508) = 1;
  *(_DWORD *)(v1 + 45504) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 45032) = v1 + 388;
  sub_10046920(v1 + 38128, (int)"PEAK", dword_1031FB44 + 6536, 10.0, 315.0, 127.0, 15.0);
  *(_WORD *)(v1 + 38644) = 11;
  *(_BYTE *)(v1 + 38652) = 1;
  *(_DWORD *)(v1 + 38648) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 38176) = v1 + 400;
  *(float *)(v1 + 38156) = *(float *)(v1 + 38156) - 15.0;
  *(_WORD *)(v1 + 38424) = 18065;
  *(_BYTE *)(v1 + 38426) = 0;
  *(float *)(v1 + 38408) = 122.0;
  sub_10048850(v1 + 7628, (int)"EGT", dword_1031FB44 + 5224, 10.0, 323.0, 127.0, 106.0);
  sub_10047B10(v1 + 404, 6, 1, v1 + 7628);
  *(_BYTE *)(v1 + 8588) = 1;
  *(_BYTE *)(v1 + 8589) = 1;
  *(_WORD *)(v1 + 8592) = 10;
  *(_BYTE *)(v1 + 8590) = -1;
  *(float *)(v1 + 7736) = 464.0;
  *(float *)(v1 + 7772) = 0.0;
  *(float *)(v1 + 7776) = 1.0;
  *(_BYTE *)(v1 + 7728) = 16;
  sub_10046920(v1 + 8876, (int)"EGT F", dword_1031FB44 + 5224, 10.0, 464.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20704, v1 + 8876);
  *(_WORD *)(v1 + 9392) = 10;
  *(_BYTE *)(v1 + 9400) = 1;
  *(_DWORD *)(v1 + 9396) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 8924) = v1 + 484;
  sub_10048850(v1 + 660, (int)"CHT", dword_1031FB44 + 4732, 10.0, 477.0, 127.0, 91.0);
  sub_10047B10(v1 + 488, 6, 1, v1 + 660);
  *(_BYTE *)(v1 + 1620) = 1;
  *(_BYTE *)(v1 + 1621) = 1;
  *(_WORD *)(v1 + 1624) = 10;
  *(_BYTE *)(v1 + 1622) = -1;
  *(float *)(v1 + 768) = 603.0;
  *(float *)(v1 + 804) = 0.0;
  *(float *)(v1 + 808) = 1.0;
  *(_BYTE *)(v1 + 760) = 12;
  sub_10046920(v1 + 6400, (int)"CHT F", dword_1031FB44 + 4732, 10.0, 603.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20620, v1 + 6400);
  *(_WORD *)(v1 + 6916) = 10;
  *(_BYTE *)(v1 + 6924) = 1;
  *(_DWORD *)(v1 + 6920) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 6448) = v1 + 568;
  sub_10046920(v1 + 32408, (int)"OIL PSI", dword_1031FB44 + 4404, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20564, v1 + 32408);
  *(_WORD *)(v1 + 32924) = 15;
  *(_BYTE *)(v1 + 32932) = 1;
  *(_DWORD *)(v1 + 32928) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 32456) = v1 + 580;
  sub_10046920(v1 + 37512, (int)"OIL F", dword_1031FB44 + 4568, 10.0, 281.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20592, v1 + 37512);
  *(_WORD *)(v1 + 38028) = 10;
  *(_BYTE *)(v1 + 38036) = 1;
  *(_DWORD *)(v1 + 38032) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 37560) = v1 + 592;
  sub_10046920(v1 + 9488, (int)"ENG HRS", dword_1031FB44 + 5880, 10.0, 311.0, 127.0, 15.0);
  *(_WORD *)(v1 + 10004) = 39;
  *(_BYTE *)(v1 + 10012) = 1;
  *(_DWORD *)(v1 + 10008) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 9536) = v1 + 604;
  sub_1004A1A0(v1 + 50088, (int)"VAC", dword_1031FB44 + 6044, 10.0, 341.0, 127.0, 18.5, 0);
  sub_10049310((int)&unk_100BAE38, 2u, 0, v1 + 50088);
  sub_10049040(v1 + 608, 1, 0, v1 + 50088);
  *(_WORD *)(v1 + 54400) = 15;
  *(_BYTE *)(v1 + 54408) = 1;
  *(_DWORD *)(v1 + 54404) = &unk_100B8DC0;
  *(float *)(v1 + 50152) = 73.5;
  *(float *)(v1 + 50192) = 0.5;
  *(_BYTE *)(v1 + 50602) = 2;
  sub_10046920(v1 + 20316, (int)"GAL USED", dword_1031FB44 + 6208, 10.0, 434.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20872, v1 + 20316);
  *(_WORD *)(v1 + 20832) = 31;
  *(_BYTE *)(v1 + 20840) = 1;
  *(_DWORD *)(v1 + 20836) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 20364) = v1 + 628;
  sub_10046920(v1 + 19704, (int)"GAL REM", dword_1031FB44 + 6372, 10.0, 464.0, 127.0, 15.0);
  *(_WORD *)(v1 + 20220) = 30;
  *(_BYTE *)(v1 + 20228) = 1;
  *(_DWORD *)(v1 + 20224) = &unk_100B8DC0;
  result = v1 + 640;
  *(_DWORD *)(v1 + 19752) = v1 + 640;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000BA00) --------------------------------------------------------
signed int __cdecl sub_1000BA00(int a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  char v3; // al@1
  bool v4; // c3@1
  signed int result; // eax@1
  int v6; // edi@1
  char v7; // al@29
  int *v8; // ebx@33
  _BYTE *v9; // ebp@33
  float *v10; // edi@33
  int v11; // edi@45
  __int16 v12; // fps@74
  bool v13; // c0@74
  char v14; // c2@74
  bool v15; // c3@74
  double v16; // st7@75
  __int16 v17; // fps@75
  double v18; // st6@75
  bool v19; // c0@75
  char v20; // c2@75
  bool v21; // c3@75
  int v22; // edx@81
  int v23; // ecx@81
  int v24; // edx@81
  __int16 v25; // [sp+8h] [bp-2Ch]@1
  int v26; // [sp+Ch] [bp-28h]@1
  char v27; // [sp+10h] [bp-24h]@1
  int v28; // [sp+14h] [bp-20h]@1
  int v29; // [sp+18h] [bp-1Ch]@33
  int v30; // [sp+1Ch] [bp-18h]@1
  int v31; // [sp+20h] [bp-14h]@1
  int v32; // [sp+24h] [bp-10h]@1
  int v33; // [sp+28h] [bp-Ch]@1
  char v34; // [sp+2Ch] [bp-8h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v26 = 0;
  v25 = -32713;
  v27 = 9;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v3 = sub_10052230(v1);
  v4 = 9.8999998e24 == *(float *)(v2 + 220);
  result = v3 != 1 ? 9 : 14;
  v6 = result;
  v28 = result;
  if ( !v4 && *(float *)(dword_1031FB44 + 32) < (double)*(float *)(v2 + 220) )
  {
    if ( !*(_BYTE *)(v2 + 44348) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(result, (int)&v25, 10, 1);
    }
    LOBYTE(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 232) )
  {
    HIWORD(result) = HIWORD(dword_1031FB44);
    if ( *(float *)(dword_1031FB44 + 28) < (double)*(float *)(v2 + 232) )
    {
      if ( !*(_BYTE *)(v2 + 44349) && *(_BYTE *)(v2 + 38748) )
      {
        v27 = 4;
        result = sub_1008C880(v6, (int)&v25, 10, 1);
      }
      BYTE1(v30) = 1;
    }
  }
  if ( 9.8999998e24 != *(float *)(v2 + 256)
    && (*(float *)(v2 + 28288) >= (double)*(float *)(v2 + 256) || *(float *)(v2 + 28312) < (double)*(float *)(v2 + 256)) )
  {
    if ( !*(_BYTE *)(v2 + 44350) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v6, (int)&v25, 10, 1);
    }
    BYTE2(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 268) && *(float *)(v2 + 33408) <= (double)*(float *)(v2 + 268) )
  {
    if ( !*(_BYTE *)(v2 + 44351) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v6, (int)&v25, 10, 1);
    }
    BYTE3(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 292) && *(float *)(v2 + 45976) < (double)*(float *)(v2 + 292) )
  {
    if ( !*(_BYTE *)(v2 + 44358) )
    {
      v7 = *(_BYTE *)(v2 + 38748);
      if ( v7 )
      {
        if ( v7 != 1 )
        {
          v27 = 4;
          result = sub_1008C880(v6, (int)&v25, 10, 1);
        }
      }
    }
    BYTE2(v32) = 1;
  }
  v8 = &v31;
  v9 = (_BYTE *)(v2 + 44352);
  v10 = (float *)(v2 + 496);
  v29 = 6;
  do
  {
    if ( 9.8999998e24 != *v10 && *(float *)(v2 + 2288) < (double)*v10 )
    {
      if ( !*v9 && *(_BYTE *)(v2 + 38748) )
      {
        v27 = 4;
        result = sub_1008C880(v28, (int)&v25, 10, 1);
      }
      *(_BYTE *)v8 = 1;
    }
    v10 += 3;
    ++v9;
    v8 = (int *)((char *)v8 + 1);
    --v29;
  }
  while ( v29 );
  if ( 9.8999998e24 == *(float *)(v2 + 304) || *(float *)(v2 + 15592) < (double)*(float *)(v2 + 304) )
  {
    v11 = v28;
  }
  else if ( *(_BYTE *)(v2 + 44359) || !*(_BYTE *)(v2 + 38748) )
  {
    v11 = v28;
    BYTE3(v32) = 1;
  }
  else
  {
    v11 = v28;
    v27 = 4;
    result = sub_1008C880(v28, (int)&v25, 10, 1);
    BYTE3(v32) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 316) && *(float *)(v2 + 15592) >= (double)*(float *)(v2 + 316) )
  {
    if ( !*(_BYTE *)(v2 + 44360) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    LOBYTE(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 328)
    && (*(float *)(v2 + 27740) >= (double)*(float *)(v2 + 328) || *(float *)(v2 + 27748) < (double)*(float *)(v2 + 328)) )
  {
    if ( !*(_BYTE *)(v2 + 44361) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE1(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 340)
    && (*(float *)(v2 + 7452) >= (double)*(float *)(v2 + 340) || *(float *)(v2 + 7460) < (double)*(float *)(v2 + 340)) )
  {
    if ( !*(_BYTE *)(v2 + 44362) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE2(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 352) && *(float *)(v2 + 27128) >= (double)*(float *)(v2 + 352) )
  {
    if ( !*(_BYTE *)(v2 + 44363) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE3(v33) = 1;
  }
  v13 = 9.8999998e24 < *(float *)(v2 + 364);
  v14 = 0;
  v15 = 9.8999998e24 == *(float *)(v2 + 364);
  BYTE1(result) = HIBYTE(v12);
  if ( 9.8999998e24 == *(float *)(v2 + 364)
    || (v16 = *(float *)(v2 + 364),
        v18 = *(float *)(v2 + 44804),
        v19 = v18 < v16,
        v20 = 0,
        v21 = v18 == v16,
        BYTE1(result) = HIBYTE(v17),
        v18 < v16) )
  {
    LOBYTE(result) = v34;
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 44364) && *(_BYTE *)(v2 + 38748) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    LOBYTE(result) = 1;
  }
  v22 = v31;
  *(_DWORD *)(v2 + 44348) = v30;
  v23 = v32;
  *(_DWORD *)(v2 + 44352) = v22;
  v24 = v33;
  *(_DWORD *)(v2 + 44356) = v23;
  *(_DWORD *)(v2 + 44360) = v24;
  *(_BYTE *)(v2 + 44364) = result;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000BF30) --------------------------------------------------------
int __usercall sub_1000BF30@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAF0C, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 172),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 152),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 192),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000BFB0) --------------------------------------------------------
char __usercall sub_1000BFB0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  char v2; // dl@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 38748) = v2;
  *(_BYTE *)(v1 + 7012) = 1;
  sub_1004C170(v2);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1000BFF0) --------------------------------------------------------
char __usercall sub_1000BFF0@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // ecx@1
  signed int v6; // eax@1
  void *v7; // ecx@12
  int v8; // eax@16
  char result; // al@16
  int v10; // [sp+18h] [bp-Ch]@4
  float v11; // [sp+1Ch] [bp-8h]@3
  int v12; // [sp+20h] [bp-4h]@1

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 54620, 0);
  v4 = v3;
  *(_DWORD *)(v3 + 44348) = 0;
  *(_DWORD *)(v3 + 44352) = 0;
  *(_DWORD *)(v3 + 44356) = 0;
  *(_DWORD *)(v3 + 44360) = 0;
  *(_BYTE *)(v3 + 44364) = 0;
  *(_BYTE *)(v3 + 54616) = 0;
  *(_BYTE *)(v3 + 44980) = 0;
  *(_BYTE *)(v3 + 44980) = sub_10052210(v5);
  *(_DWORD *)(v4 + 172) = &unk_100BAF28;
  *(_DWORD *)(v4 + 180) = &unk_100BAFC8;
  *(_DWORD *)(v4 + 176) = &unk_100BAF80;
  *(_DWORD *)(v4 + 156) = v4 + 92;
  v12 = v4 + 92;
  *(_DWORD *)(v4 + 192) = v4 + 124;
  *(_DWORD *)(v4 + 200) = v4 + 133;
  *(_DWORD *)(v4 + 196) = v4 + 144;
  *(_DWORD *)(v4 + 152) = v4 + 12;
  *(_DWORD *)(v4 + 160) = v4 + 48;
  *(_BYTE *)(v4 + 124) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 8) = 3;
  **(_BYTE **)(v4 + 196) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 7) = 3;
  v6 = 0;
  do
    *(_BYTE *)(v6++ + *(_DWORD *)(v4 + 200)) = 3;
  while ( v6 < 11 );
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BAC34);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_1000A910(a1);
  if ( !sub_10066790(3u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 644, v10, 1.0, 0.125);
  if ( !sub_10066790(0x56u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 652, v10, 1.0, 0.125);
  if ( !sub_100663D0(&v11) || !sub_10031F70(100000.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 15204, v10, 1.0, 0.125);
  *(_BYTE *)(v4 + 20930) = sub_1004BEE0(v7);
  *(_BYTE *)(v4 + 20928) = 1;
  *(_BYTE *)(v4 + 20929) = 1;
  if ( sub_1000A860(0) )
    *(_BYTE *)(v4 + 20928) = 0;
  if ( sub_1000A860(2) )
    *(_BYTE *)(v4 + 20929) = 0;
  *(_DWORD *)v4 = v4 + 20932;
  *(_DWORD *)(v4 + 4) = v4 + 38752;
  *(_DWORD *)(v4 + 8) = v4 + 15212;
  *(_DWORD *)(v4 + 12) = v4 + 10712;
  *(_DWORD *)(v4 + 28) = v4 + 1908;
  *(_DWORD *)(v4 + 32) = v4 + 27304;
  *(_DWORD *)(v4 + 36) = v4 + 7016;
  *(_DWORD *)(v4 + 40) = v4 + 26692;
  *(_DWORD *)(v4 + 16) = v4 + 27916;
  *(_DWORD *)(v4 + 20) = v4 + 33020;
  *(_DWORD *)(v4 + 44) = v4 + 44368;
  v8 = v12;
  *(_DWORD *)(v4 + 24) = v4 + 45596;
  *(_DWORD *)(v8 + 8) = v4 + 45596;
  *(_DWORD *)v8 = v4 + 10100;
  *(_DWORD *)(v8 + 4) = v4 + 44984;
  *(_DWORD *)(v8 + 12) = v4 + 38128;
  *(_DWORD *)(v8 + 16) = v4 + 8876;
  *(_DWORD *)(v8 + 20) = v4 + 7628;
  *(_DWORD *)(v8 + 24) = v4 + 6400;
  *(_DWORD *)(v8 + 28) = v4 + 660;
  *(_DWORD *)(v4 + 52) = v4 + 37512;
  *(_DWORD *)(v4 + 64) = v4 + 10100;
  *(_DWORD *)(v4 + 68) = v4 + 19704;
  *(_DWORD *)(v4 + 76) = v4 + 27304;
  *(_DWORD *)(v4 + 80) = v4 + 7016;
  *(_DWORD *)(v4 + 48) = v4 + 32408;
  *(_DWORD *)(v4 + 56) = v4 + 9488;
  *(_DWORD *)(v4 + 84) = v4 + 26692;
  *(_DWORD *)(v4 + 60) = v4 + 50088;
  *(_DWORD *)(v4 + 72) = v4 + 20316;
  *(_DWORD *)(v4 + 88) = v4 + 44368;
  *(_BYTE *)(v4 + 38748) = sub_1004BF10((void *)(v4 + 20316));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAF0C, v4, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAF28, v4 + 12, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAF80, v12, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000C4C0) --------------------------------------------------------
char __usercall sub_1000C4C0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  bool v2; // cl@3
  unsigned __int8 v3; // cl@5
  int v4; // ST04_4@8

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( !*(_BYTE *)(v1 + 20930) )
    {
      v3 = ++*(_BYTE *)(v1 + 8590);
      *(_BYTE *)(v1 + 7012) = 0;
      if ( v3 >= *(_BYTE *)(dword_1031FB44 + 25) )
        *(_BYTE *)(v1 + 8590) = 0;
      *(_BYTE *)(v1 + 1622) = *(_BYTE *)(v1 + 8590);
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    v2 = *(_BYTE *)(v1 + 20930) == 0;
    *(_BYTE *)(v1 + 20930) = v2;
    sub_1004C150(v2);
  }
  v4 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v4, -32734);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000C550) --------------------------------------------------------
void __usercall sub_1000C550(int a1@<eax>)
{
  int v1; // edi@1
  signed int v2; // esi@1
  float *v3; // ebx@1
  float *v4; // ecx@8
  float v5; // [sp+0h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 408);
  do
  {
    v5 = sub_1004C3E0((unsigned __int16)v2 + 14);
    if ( v5 != 9.8999998e24 )
      *v3 = v5 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 6 );
  if ( *(_BYTE *)(v1 + 7012) || *(_BYTE *)(v1 + 20930) )
    *(_BYTE *)(v1 + 8590) = sub_10066EE0(v1 + 212, 0x10u, 6u);
  v4 = (float *)(v1 + 12 * (*(_BYTE *)(v1 + 8590) + 34));
  if ( 9.8999998e24 != *v4 )
    *(float *)(v1 + 480) = *v4;
}

//----- (1000C600) --------------------------------------------------------
void __cdecl sub_1000C600(float a1)
{
  int v1; // ebp@1
  long double v2; // st7@1
  int v3; // esi@1
  float *v4; // edi@1
  float *v5; // eax@1
  signed int v6; // ecx@1
  double v7; // st7@5
  double v8; // st7@6
  int v9; // edx@16
  int v10; // ecx@16
  bool v11; // c3@19
  double v12; // st7@27
  double v13; // st7@37
  signed int v14; // ebp@37
  double v15; // st6@39
  int v16; // [sp+1Ch] [bp-10h]@1
  float v17; // [sp+20h] [bp-Ch]@5
  int v18; // [sp+24h] [bp-8h]@1
  int v19; // [sp+28h] [bp-4h]@1

  v1 = LODWORD(a1);
  v16 = 0;
  v2 = pow(2.0, 31.0);
  v18 = (signed int)(v2 - 1.0);
  v19 = (signed int)(v2 * -1.0);
  v3 = *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 56) + 12);
  a1 = 0.0;
  v4 = (float *)(v3 + 216);
  v5 = (float *)(v3 + 216);
  v6 = 36;
  do
  {
    *v5 = 9.8999998e24;
    v5 += 3;
    --v6;
  }
  while ( v6 );
  *v4 = sub_1004C3E0(0x18u);
  *(float *)(v3 + 228) = sub_1004C3E0(0x1Eu);
  if ( sub_100663D0(&a1) && sub_10031F70(100000.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 15204, v16);
    v17 = (double)*(signed int *)(v3 + 15208) / 100000.0;
    v7 = v17;
    *(float *)(v3 + 240) = v17;
    *(float *)(v3 + 372) = v7;
  }
  v17 = sub_1004C3E0(0x1Cu);
  v8 = v17;
  *(float *)(v3 + 252) = v17;
  *(float *)(v3 + 576) = v8;
  a1 = sub_1004C3E0(0x1Du);
  if ( a1 != 9.8999998e24 )
  {
    *(float *)(v3 + 264) = a1 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 588) = 1.799999952316284 * a1 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 44980) == 2 )
  {
    *(_BYTE *)(v3 + 20928) = sub_1000A860(0) == 0;
    *(_BYTE *)(v3 + 20929) = sub_1000A860(2) == 0;
  }
  if ( sub_100664A0(&a1) && !*(_BYTE *)(v3 + 20928) )
    *(float *)(v3 + 300) = a1;
  if ( sub_10066510(&a1) && !*(_BYTE *)(v3 + 20929) )
    *(float *)(v3 + 312) = a1;
  *(float *)(v3 + 636) = sub_1004C0C0();
  *(float *)(v3 + 624) = sub_1004C0D0(v10, v9);
  *(float *)(v3 + 324) = sub_1004C3E0(4u);
  *(float *)(v3 + 336) = sub_1004C3E0(5u);
  sub_1000C550(v1);
  sub_1000F250(v1);
  a1 = sub_1004C3E0(0x1Fu);
  if ( a1 != 9.8999998e24 )
  {
    *(float *)(v3 + 288) = a1 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 384) = 1.799999952316284 * a1 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 20930) )
  {
    v11 = 9.8999998e24 == *(float *)(v3 + 38744);
    *(_BYTE *)(v3 + 38301) = 0;
    *(_BYTE *)(v3 + 38302) = 0;
    *(_BYTE *)(v3 + 38303) = 0;
    if ( v11 )
      *(float *)(v3 + 38744) = 0.0;
    if ( *(float *)(v3 + 38744) >= (double)*(float *)(v3 + 288) || *(_BYTE *)(v3 + 38740) )
    {
      if ( *(float *)(v3 + 38744) - *(float *)(v3 + 288) > 7.0 )
        *(_BYTE *)(v3 + 38740) = 1;
    }
    else
    {
      *(float *)(v3 + 38744) = *(float *)(v3 + 288);
    }
    if ( *(_BYTE *)(v3 + 38740) )
      v12 = *(float *)(v3 + 288) - *(float *)(v3 + 38744);
    else
      v12 = 100000.0;
    *(float *)(v3 + 38124) = v12;
    *(float *)(v3 + 396) = *(float *)(v3 + 38124);
  }
  else
  {
    *(_BYTE *)(v3 + 38301) = 1;
    *(float *)(v3 + 38744) = 0.0;
    *(_BYTE *)(v3 + 38302) = 1;
    *(_BYTE *)(v3 + 38303) = 1;
    *(_BYTE *)(v3 + 38740) = 0;
    *(float *)(v3 + 38124) = 9.8999998e24;
  }
  *(float *)(v3 + 600) = sub_1004C070();
  *(float *)(v3 + 612) = sub_1004C3E0(0x20u);
  if ( sub_10066790(3u, &a1) && sub_10031F70(100.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 644, v16);
    *(float *)(v3 + 348) = (double)*(signed int *)(v3 + 648) / 100.0;
  }
  if ( sub_10066790(0x56u, &a1) && sub_10031F70(100.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 652, v16);
    *(float *)(v3 + 360) = (double)*(signed int *)(v3 + 656) / 100.0;
  }
  v13 = 9.8999998e24;
  v14 = 36;
  do
  {
    v17 = *v4;
    if ( (LODWORD(v17) & 0x7F800000) == 2139095040 || (v15 = *v4 / *(v4 - 1), (double)v18 < v15) || (double)v19 > v15 )
    {
      if ( v13 != *v4 )
      {
        sub_10051A40(".\\cdp_pg_eis_cessna_t182t_3d.c", 3411, 0, "Gauge data is not finite");
        v13 = 9.8999998e24;
      }
      *v4 = v13;
    }
    v4 += 3;
    --v14;
  }
  while ( v14 );
  sub_1004C380(v3 + 212, 0x24u);
  if ( *(float *)(v3 + 44812) > (double)*(float *)(v3 + 364) && *(float *)(v3 + 44804) < (double)*(float *)(v3 + 364) )
  {
    *(float *)(v3 + 360) = 0.0;
    *(float *)(v3 + 364) = 0.0;
  }
  if ( *(float *)(v3 + 352) >= 100.0 || *(float *)(v3 + 352) <= -100.0 )
    *(_WORD *)(v3 + 27208) = 23;
  else
    *(_WORD *)(v3 + 27208) = 24;
  if ( *(float *)(v3 + 364) >= 100.0 || *(float *)(v3 + 364) <= -100.0 )
    *(_WORD *)(v3 + 44884) = 23;
  else
    *(_WORD *)(v3 + 44884) = 24;
  if ( *(float *)(v3 + 328) >= 100.0 || *(float *)(v3 + 328) <= -10.0 )
    *(_WORD *)(v3 + 27820) = 20;
  else
    *(_WORD *)(v3 + 27820) = 21;
  if ( *(float *)(v3 + 340) >= 100.0 || *(float *)(v3 + 340) <= -10.0 )
    *(_WORD *)(v3 + 7532) = 20;
  else
    *(_WORD *)(v3 + 7532) = 21;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (1000CBC0) --------------------------------------------------------
void __usercall sub_1000CBC0(int a1@<eax>, float a2@<ecx>)
{
  int v2; // esi@1
  double v3; // st7@3
  float v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( !sub_10051AE0(&v4) )
  {
LABEL_5:
    v3 = 91432.438;
    goto LABEL_6;
  }
  if ( v4 >= 4480.5601 )
  {
    if ( v4 <= 4663.4399 )
      goto LABEL_7;
    goto LABEL_5;
  }
  v3 = 94818.828;
LABEL_6:
  *(float *)(v2 + 26544) = v3;
LABEL_7:
  sub_10060E40((_BYTE *)(v2 + 26528), v2 + 20932);
  if ( *(float *)(dword_1031FB44 + 32) >= (double)*(float *)(v2 + 220) )
    *(_BYTE *)(v2 + 22924) = 10;
  else
    *(_BYTE *)(v2 + 22924) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000CC60) --------------------------------------------------------
void __usercall sub_1000CC60(int a1@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v1 + 232) )
    *(_BYTE *)(v1 + 40736) = 10;
  else
    *(_BYTE *)(v1 + 40736) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000CC90) --------------------------------------------------------
char __usercall sub_1000CC90@<al>(int a1@<edi>)
{
  int v1; // esi@1
  float v2; // ecx@1
  float *v3; // ebp@2
  char result; // al@3
  float *v5; // ebp@6
  float v6; // [sp+8h] [bp-10h]@0

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1000C600(v6);
  sub_1000CBC0(a1, v2);
  sub_1000CC60(a1);
  sub_1000BA00(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAE58, (int)&unk_100BAF74, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BAF0C, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 172),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 152),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38748) + 192),
    255);
  if ( !*(_BYTE *)(v1 + 38748) )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 54604) = 0.5;
    v3 = (float *)(v1 + 54580);
    *(float *)(v1 + 54608) = 0.5;
    *(_DWORD *)(v1 + 54596) = -14671840;
    *(float *)(v1 + 54580) = 75.5;
    *(_DWORD *)(v1 + 54600) = -1;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 565.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 54580);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 588.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 54580);
    *v3 = 24.0;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 588.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54580);
    *v3 = 126.0;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 588.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 54580);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 612.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 54580);
    *v3 = 75.5;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 643.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 54580);
    *v3 = 24.0;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 643.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54580);
    *v3 = 126.0;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54584) = 643.0;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 54580);
    *v3 = 75.5;
    *(float *)(v1 + 54584) = 667.0;
    *(_DWORD *)(v1 + 54588) = 2;
    *(float *)(v1 + 54592) = 12.0;
    *(float *)(v1 + 54612) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 54580);
    sub_10048A00(10.0, 443.0, v1 + 45596);
    sub_10048A00(10.0, 491.0, v1 + 15212);
    *(_BYTE *)(v1 + 49786) = 0;
  }
  result = *(_BYTE *)(v1 + 38748);
  if ( result == 1 )
  {
    sub_10046480(10.0, 251.0, v1 + 10100);
    sub_10048A00(10.0, 279.0, v1 + 45596);
    sub_10046480(10.0, 603.0, v1 + 6400);
    result = sub_10048A00(10.0, 630.0, v1 + 15212);
    *(_BYTE *)(v1 + 49786) = 1;
    *(_BYTE *)(a1 + 6) = 2;
  }
  else
  {
    if ( result == 2 )
    {
      j_gdi_pvg_color_u32(-1);
      sub_1008C110(1.0);
      j_gdi_pvg_begin(64);
      sub_1008C2F0(10.0, 565.0);
      sub_1008C2F0(137.0, 565.0);
      sub_1008C2F0(10.0, 374.0);
      sub_1008C2F0(137.0, 374.0);
      j_gdi_pvg_end();
      *(float *)(v1 + 54604) = 0.5;
      v5 = (float *)(v1 + 54580);
      *(float *)(v1 + 54608) = 0.5;
      *(_DWORD *)(v1 + 54596) = -14671840;
      *(float *)(v1 + 54580) = 75.5;
      *(_DWORD *)(v1 + 54600) = -1;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 565.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
      sub_10065B50(a1, (int)"ELECTRICAL", v1 + 54580);
      *v5 = 75.5;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 374.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
      sub_10065B50(a1, (int)"FUEL CALC", v1 + 54580);
      *v5 = 75.5;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 588.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
      sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 54580);
      *v5 = 24.0;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 588.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54580);
      *v5 = 126.0;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 588.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 54580);
      *v5 = 75.5;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 612.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)"VOLTS", 12.0);
      sub_10065B50(a1, (int)"VOLTS", v1 + 54580);
      *v5 = 75.5;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 643.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)"BATT", 12.0);
      sub_10065B50(a1, (int)"BATT", v1 + 54580);
      *v5 = 24.0;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 643.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54580);
      *v5 = 126.0;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 643.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
      sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 54580);
      *v5 = 75.5;
      *(_DWORD *)(v1 + 54588) = 2;
      *(float *)(v1 + 54584) = 667.0;
      *(float *)(v1 + 54592) = 12.0;
      *(float *)(v1 + 54612) = sub_1008D010(2, (int)"AMPS", 12.0);
      sub_10065B50(a1, (int)"AMPS", v1 + 54580);
      sub_10046480(10.0, 404.0, v1 + 10100);
      sub_10046480(10.0, 251.0, v1 + 32408);
      result = sub_10048A00(10.0, 491.0, v1 + 15212);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1000D550) --------------------------------------------------------
char __cdecl sub_1000D550(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_1000BF30(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_1000BFF0(a1, 0, 0);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_1000CC90(a1);
      break;
    case 32821:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54616) = 0;
      break;
    case 32820:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54616) = 1;
      break;
    case 32825:
      LOBYTE(v1) = sub_1000BFB0(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v1) = sub_1000C4C0(a1);
      break;
    case 32791:
    case 32792:
    case 32793:
    case 32794:
    case 32795:
    case 32796:
    case 32797:
    case 32798:
    case 32799:
    case 32800:
    case 32801:
    case 32803:
    case 32804:
    case 32805:
    case 32806:
    case 32807:
    case 32808:
    case 32809:
    case 32810:
    case 32811:
    case 32812:
    case 32813:
    case 32814:
    case 32815:
    case 32816:
    case 32817:
    case 32818:
    case 32822:
    case 32823:
    case 32826:
    case 32827:
    case 32828:
    case 32829:
    case 32830:
    case 32831:
    case 32832:
    case 32834:
    case 32835:
    case 32836:
    case 32837:
    case 32838:
    case 32839:
    case 32840:
    case 32841:
    case 32842:
    case 32843:
    case 32844:
    case 32845:
    case 32846:
    case 32847:
    case 32848:
    case 32849:
    case 32850:
    case 32851:
    case 32852:
    case 32853:
    case 32854:
    case 32855:
    case 32856:
    case 32857:
    case 32858:
    case 32859:
    case 32860:
    case 32861:
    case 32862:
    case 32863:
    case 32864:
    case 32865:
    case 32866:
    case 32867:
    case 32868:
    case 32869:
    case 32870:
    case 32871:
    case 32872:
    case 32873:
    case 32874:
    case 32875:
    case 32876:
    case 32877:
    case 32878:
    case 32879:
    case 32880:
    case 32881:
    case 32882:
    case 32883:
    case 32884:
    case 32885:
    case 32886:
    case 32887:
      return v1;
  }
  return v1;
}

//----- (1000D640) --------------------------------------------------------
bool __cdecl sub_1000D640(char a1)
{
  bool v1; // zf@6
  bool v2; // bl@8
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+10h] [bp-14h]@1

  v6 = 1;
  v7 = 0;
  LOBYTE(v5) = 67;
  v4 = 2;
  if ( a1 )
  {
    if ( a1 == 2 )
      LOBYTE(v5) = 7;
  }
  else
  {
    LOBYTE(v5) = 6;
  }
  sub_10065D40(a1, &v4);
  sub_10065C60(v5, 1, 9, (int)&v6, (int)&v7, 16);
  if ( v7 == 3 )
    v1 = v4 == 0;
  else
    v1 = v4 == 1;
  v2 = v1;
  if ( !v1 )
    sub_10051A40(
      ".\\cdp_pg_eis_cessna_t206h_3d.c",
      1232,
      0,
      "Fuel sensor calibration does not match fuel sensor configuration");
  return v2;
}

//----- (1000D6F0) --------------------------------------------------------
int __usercall sub_1000D6F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  const char *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = "QC";
  v3 = v1 + 216;
  do
  {
    v4 = *(float *)v2;
    v2 += 4;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)".\\cdp_pg_eis_cessna_t206h_3d.c" );
  *(_DWORD *)(v1 + 54424) = 2;
  *(float *)(v1 + 54416) = 0.0;
  *(_DWORD *)(v1 + 54432) = 0;
  *(float *)(v1 + 54420) = 0.0;
  *(_DWORD *)(v1 + 54436) = -1;
  *(float *)(v1 + 54428) = 12.0;
  *(float *)(v1 + 54440) = 0.5;
  *(float *)(v1 + 54444) = 1.0;
  *(float *)(v1 + 54448) = 40.0;
  *(_BYTE *)(v1 + 20930) = sub_1004BEE0((void *)v2);
  *(_BYTE *)(v1 + 7012) = 1;
  *(_BYTE *)(v1 + 38576) = 0;
  sub_10061B00(v1 + 20932, (int)"MAN IN", dword_1031FB44 + 3912, 10.0, 5.0, 127.0, 127.0);
  *(float *)(v1 + 21152) = 158.0;
  *(_DWORD *)(v1 + 23008) = 54;
  *(float *)(v1 + 21156) = 382.0;
  *(float *)(v1 + 21256) = 224.0;
  *(float *)(v1 + 23232) = 73.0;
  *(float *)(v1 + 23236) = 88.0;
  *(float *)(v1 + 23272) = 23.0;
  *(float *)(v1 + 23264) = 0.5;
  *(float *)(v1 + 21032) = 73.0;
  *(float *)(v1 + 21036) = 80.0;
  *(float *)(v1 + 21080) = 9.0;
  *(float *)(v1 + 21072) = 0.5;
  *(float *)(v1 + 20968) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 20932);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 20932);
  sub_100612A0((int)&unk_100BB72C, 2, 0.0, v1 + 20932);
  sub_10060F20(v1 + 212, 1, v1 + 20932);
  *(_WORD *)(v1 + 26490) = 5;
  *(_BYTE *)(v1 + 26496) = 1;
  *(_DWORD *)(v1 + 26492) = &unk_100B8DC0;
  sub_10061B00(v1 + 38588, (int)"RPM", dword_1031FB44 + 4076, 10.0, 117.0, 127.0, 127.0);
  *(float *)(v1 + 38808) = 158.0;
  *(_DWORD *)(v1 + 40664) = 54;
  *(float *)(v1 + 38812) = 382.0;
  *(float *)(v1 + 38912) = 224.0;
  *(float *)(v1 + 40888) = 73.0;
  *(float *)(v1 + 40892) = 200.0;
  *(float *)(v1 + 40928) = 23.0;
  *(float *)(v1 + 40920) = 0.5;
  *(float *)(v1 + 38688) = 73.0;
  *(float *)(v1 + 38692) = 192.0;
  *(float *)(v1 + 38736) = 9.0;
  *(float *)(v1 + 38728) = 0.5;
  *(float *)(v1 + 38624) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 38588);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 38588);
  sub_100612A0((int)&unk_100BB74C, 2, 0.0, v1 + 38588);
  sub_10060F20(v1 + 224, 1, v1 + 38588);
  *(_WORD *)(v1 + 44146) = 6;
  *(_BYTE *)(v1 + 44152) = 1;
  *(_DWORD *)(v1 + 44148) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 10712, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4240, 0.40000001, 0.0, v1 + 10712);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 10712);
  sub_10049040(v1 + 236, 1, 0, v1 + 10712);
  sub_10049310((int)&unk_100BB770, 0xDu, 0, v1 + 10712);
  *(float *)(v1 + 10776) = 73.5;
  *(float *)(v1 + 10816) = 0.5;
  *(_WORD *)(v1 + 15024) = 33;
  *(_BYTE *)(v1 + 15032) = 1;
  *(_DWORD *)(v1 + 15028) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 11226) = 2;
  sub_1004A1A0(v1 + 27752, (int)"OIL PRES", dword_1031FB44 + 4404, 10.0, 299.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 27752);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 27752);
  sub_10049310((int)&unk_100BB840, 2u, 0, v1 + 27752);
  sub_10049040(v1 + 248, 1, 0, v1 + 27752);
  *(float *)(v1 + 27816) = 73.5;
  *(_WORD *)(v1 + 32064) = 15;
  *(float *)(v1 + 27856) = 0.5;
  *(_BYTE *)(v1 + 32072) = 1;
  *(_DWORD *)(v1 + 32068) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 28266) = 2;
  sub_1004A1A0(v1 + 32856, (int)"OIL TEMP", dword_1031FB44 + 4568, 10.0, 347.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 32856);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 32856);
  sub_10049310((int)&unk_100BB860, 2u, 0, v1 + 32856);
  sub_10049040(v1 + 260, 1, 0, v1 + 32856);
  *(float *)(v1 + 32920) = 73.5;
  *(float *)(v1 + 32960) = 0.5;
  *(_WORD *)(v1 + 37168) = 10;
  *(_BYTE *)(v1 + 37176) = 1;
  *(_DWORD *)(v1 + 37172) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 33370) = 2;
  sub_1004A1A0(v1 + 1908, (int)"CHT", dword_1031FB44 + 6700, 10.0, 395.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 6700, 0.40000001, 0.0, v1 + 1908);
  sub_100490F0(dword_1031FB44 + 20956, v1 + 1908);
  sub_10049310((int)&unk_100BB880, 2u, 0, v1 + 1908);
  sub_10049040(v1 + 272, 1, 0, v1 + 1908);
  *(float *)(v1 + 1972) = 73.5;
  *(float *)(v1 + 2012) = 0.5;
  *(_WORD *)(v1 + 6220) = 10;
  *(_BYTE *)(v1 + 6228) = 1;
  *(_DWORD *)(v1 + 6224) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 2422) = 2;
  sub_1004A1A0(v1 + 45432, (int)"TIT", dword_1031FB44 + 4896, 10.0, 443.0, 127.0, 18.5, 0);
  sub_10048D80(dword_1031FB44 + 4896, 0.40000001, 0.0, v1 + 45432);
  sub_100490F0(dword_1031FB44 + 20648, v1 + 45432);
  sub_10049310((int)&unk_100BB8A0, 2u, 0, v1 + 45432);
  sub_10049040(v1 + 284, 1, 0, v1 + 45432);
  *(_WORD *)(v1 + 49744) = 10;
  *(_BYTE *)(v1 + 49752) = 1;
  *(_DWORD *)(v1 + 49748) = &unk_100B8DC0;
  *(float *)(v1 + 45496) = 73.5;
  *(_BYTE *)(v1 + 45946) = 2;
  *(float *)(v1 + 45536) = 0.5;
  sub_1004A1E0(v1 + 15212, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 491.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100BB8C0, 0xAu, 0, v1 + 15212);
  sub_10049040(v1 + 296, 2, 0, v1 + 15212);
  *(float *)(v1 + 15672) = 26.0;
  *(float *)(v1 + 15736) = 26.0;
  *(_WORD *)(v1 + 19524) = 31;
  *(_BYTE *)(v1 + 19532) = 1;
  *(_DWORD *)(v1 + 19528) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 15726) = 0;
  *(_BYTE *)(v1 + 15790) = 0;
  sub_10046920(v1 + 27140, (int)byte_100B8180, dword_1031FB44 + 5388, -109.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 27140);
  *(float *)(v1 + 27200) = 0.5;
  *(_WORD *)(v1 + 27656) = 21;
  *(_BYTE *)(v1 + 27664) = 1;
  *(_DWORD *)(v1 + 27660) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 27188) = v1 + 328;
  *(_BYTE *)(v1 + 27315) = 1;
  sub_10046920(v1 + 7016, (int)byte_100B8180, dword_1031FB44 + 5388, -12.0, 618.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20732, v1 + 7016);
  *(float *)(v1 + 7076) = 0.5;
  *(_WORD *)(v1 + 7532) = 21;
  *(_BYTE *)(v1 + 7540) = 1;
  *(_DWORD *)(v1 + 7536) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 7064) = v1 + 340;
  *(_BYTE *)(v1 + 7191) = 1;
  sub_10046920(v1 + 26528, (int)byte_100B8180, dword_1031FB44 + 5552, -109.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20760, v1 + 26528);
  *(_WORD *)(v1 + 27044) = 24;
  *(_BYTE *)(v1 + 27052) = 1;
  *(_DWORD *)(v1 + 27048) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 26576) = v1 + 352;
  *(_BYTE *)(v1 + 26703) = 1;
  *(float *)(v1 + 26588) = 0.5;
  sub_10046920(v1 + 44204, (int)byte_100B8180, dword_1031FB44 + 5716, -13.0, 673.0, 136.0, 15.0);
  sub_10046630(dword_1031FB44 + 20788, v1 + 44204);
  *(_WORD *)(v1 + 44720) = 24;
  *(_BYTE *)(v1 + 44728) = 1;
  *(_DWORD *)(v1 + 44724) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 44252) = v1 + 364;
  *(_BYTE *)(v1 + 44379) = 1;
  *(float *)(v1 + 44264) = 0.5;
  sub_10046920(v1 + 10100, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20536, v1 + 10100);
  *(_WORD *)(v1 + 10616) = 33;
  *(_BYTE *)(v1 + 10624) = 1;
  *(_DWORD *)(v1 + 10620) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 10148) = v1 + 376;
  sub_10046920(v1 + 44820, (int)"TIT F", dword_1031FB44 + 4896, 10.0, 276.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20648, v1 + 44820);
  *(_WORD *)(v1 + 45336) = 10;
  *(_BYTE *)(v1 + 45344) = 1;
  *(_DWORD *)(v1 + 45340) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 44868) = v1 + 388;
  sub_10046920(v1 + 37964, (int)"PEAK", dword_1031FB44 + 6536, 10.0, 315.0, 127.0, 15.0);
  *(_WORD *)(v1 + 38480) = 11;
  *(_BYTE *)(v1 + 38488) = 1;
  *(_DWORD *)(v1 + 38484) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 38012) = v1 + 400;
  *(float *)(v1 + 37992) = *(float *)(v1 + 37992) - 15.0;
  *(_WORD *)(v1 + 38260) = 18065;
  *(_BYTE *)(v1 + 38262) = 0;
  *(float *)(v1 + 38244) = 122.0;
  sub_10048850(v1 + 7628, (int)"EGT", dword_1031FB44 + 5224, 10.0, 323.0, 127.0, 106.0);
  sub_10047B10(v1 + 404, 6, 1, v1 + 7628);
  *(_BYTE *)(v1 + 8588) = 1;
  *(_BYTE *)(v1 + 8589) = 1;
  *(_WORD *)(v1 + 8592) = 10;
  *(_BYTE *)(v1 + 8590) = -1;
  *(float *)(v1 + 7736) = 464.0;
  *(float *)(v1 + 7772) = 0.0;
  *(float *)(v1 + 7776) = 1.0;
  *(_BYTE *)(v1 + 7728) = 16;
  sub_10046920(v1 + 8876, (int)"EGT F", dword_1031FB44 + 5224, 10.0, 464.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20704, v1 + 8876);
  *(_WORD *)(v1 + 9392) = 10;
  *(_BYTE *)(v1 + 9400) = 1;
  *(_DWORD *)(v1 + 9396) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 8924) = v1 + 484;
  sub_10048850(v1 + 660, (int)"CHT", dword_1031FB44 + 4732, 10.0, 477.0, 127.0, 91.0);
  sub_10047B10(v1 + 488, 6, 1, v1 + 660);
  *(_BYTE *)(v1 + 1620) = 1;
  *(_BYTE *)(v1 + 1621) = 1;
  *(_WORD *)(v1 + 1624) = 10;
  *(_BYTE *)(v1 + 1622) = -1;
  *(float *)(v1 + 768) = 603.0;
  *(float *)(v1 + 804) = 0.0;
  *(float *)(v1 + 808) = 1.0;
  *(_BYTE *)(v1 + 760) = 12;
  sub_10046920(v1 + 6400, (int)"CHT F", dword_1031FB44 + 4732, 10.0, 603.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20620, v1 + 6400);
  *(_WORD *)(v1 + 6916) = 10;
  *(_BYTE *)(v1 + 6924) = 1;
  *(_DWORD *)(v1 + 6920) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 6448) = v1 + 568;
  sub_10046920(v1 + 32244, (int)"OIL PSI", dword_1031FB44 + 4404, 10.0, 251.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20564, v1 + 32244);
  *(_WORD *)(v1 + 32760) = 15;
  *(_BYTE *)(v1 + 0x8000) = 1;
  *(_DWORD *)(v1 + 32764) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 32292) = v1 + 580;
  sub_10046920(v1 + 37348, (int)"OIL F", dword_1031FB44 + 4568, 10.0, 281.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20592, v1 + 37348);
  *(_WORD *)(v1 + 37864) = 10;
  *(_BYTE *)(v1 + 37872) = 1;
  *(_DWORD *)(v1 + 37868) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 37396) = v1 + 592;
  sub_10046920(v1 + 9488, (int)"ENG HRS", dword_1031FB44 + 5880, 10.0, 311.0, 127.0, 15.0);
  *(_WORD *)(v1 + 10004) = 39;
  *(_BYTE *)(v1 + 10012) = 1;
  *(_DWORD *)(v1 + 10008) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 9536) = v1 + 604;
  sub_1004A1A0(v1 + 49924, (int)"VAC", dword_1031FB44 + 6044, 10.0, 341.0, 127.0, 18.5, 0);
  sub_10049310((int)&unk_100BB960, 2u, 0, v1 + 49924);
  sub_10049040(v1 + 608, 1, 0, v1 + 49924);
  *(_WORD *)(v1 + 54236) = 15;
  *(_BYTE *)(v1 + 54244) = 1;
  *(_DWORD *)(v1 + 54240) = &unk_100B8DC0;
  *(float *)(v1 + 49988) = 73.5;
  *(float *)(v1 + 50028) = 0.5;
  *(_BYTE *)(v1 + 50438) = 2;
  sub_10046920(v1 + 20316, (int)"GAL USED", dword_1031FB44 + 6208, 10.0, 434.0, 127.0, 15.0);
  sub_10046630(dword_1031FB44 + 20872, v1 + 20316);
  *(_WORD *)(v1 + 20832) = 31;
  *(_BYTE *)(v1 + 20840) = 1;
  *(_DWORD *)(v1 + 20836) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 20364) = v1 + 628;
  sub_10046920(v1 + 19704, (int)"GAL REM", dword_1031FB44 + 6372, 10.0, 464.0, 127.0, 15.0);
  *(_WORD *)(v1 + 20220) = 30;
  *(_BYTE *)(v1 + 20228) = 1;
  *(_DWORD *)(v1 + 20224) = &unk_100B8DC0;
  result = v1 + 640;
  *(_DWORD *)(v1 + 19752) = v1 + 640;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000E790) --------------------------------------------------------
signed int __cdecl sub_1000E790(int a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  char v3; // al@1
  bool v4; // c3@1
  signed int result; // eax@1
  int v6; // edi@1
  char v7; // al@29
  int *v8; // ebx@33
  _BYTE *v9; // ebp@33
  float *v10; // edi@33
  int v11; // edi@45
  __int16 v12; // fps@74
  bool v13; // c0@74
  char v14; // c2@74
  bool v15; // c3@74
  double v16; // st7@75
  __int16 v17; // fps@75
  double v18; // st6@75
  bool v19; // c0@75
  char v20; // c2@75
  bool v21; // c3@75
  int v22; // edx@81
  int v23; // ecx@81
  int v24; // edx@81
  __int16 v25; // [sp+8h] [bp-2Ch]@1
  int v26; // [sp+Ch] [bp-28h]@1
  char v27; // [sp+10h] [bp-24h]@1
  int v28; // [sp+14h] [bp-20h]@1
  int v29; // [sp+18h] [bp-1Ch]@33
  int v30; // [sp+1Ch] [bp-18h]@1
  int v31; // [sp+20h] [bp-14h]@1
  int v32; // [sp+24h] [bp-10h]@1
  int v33; // [sp+28h] [bp-Ch]@1
  char v34; // [sp+2Ch] [bp-8h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v26 = 0;
  v25 = -32713;
  v27 = 9;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v3 = sub_10052230(v1);
  v4 = 9.8999998e24 == *(float *)(v2 + 220);
  result = v3 != 1 ? 9 : 14;
  v6 = result;
  v28 = result;
  if ( !v4 && *(float *)(dword_1031FB44 + 32) < (double)*(float *)(v2 + 220) )
  {
    if ( !*(_BYTE *)(v2 + 44184) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(result, (int)&v25, 10, 1);
    }
    LOBYTE(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 232) )
  {
    HIWORD(result) = HIWORD(dword_1031FB44);
    if ( *(float *)(dword_1031FB44 + 28) < (double)*(float *)(v2 + 232) )
    {
      if ( !*(_BYTE *)(v2 + 44185) && *(_BYTE *)(v2 + 38584) )
      {
        v27 = 4;
        result = sub_1008C880(v6, (int)&v25, 10, 1);
      }
      BYTE1(v30) = 1;
    }
  }
  if ( 9.8999998e24 != *(float *)(v2 + 256)
    && (*(float *)(v2 + 28124) >= (double)*(float *)(v2 + 256) || *(float *)(v2 + 28148) < (double)*(float *)(v2 + 256)) )
  {
    if ( !*(_BYTE *)(v2 + 44186) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v6, (int)&v25, 10, 1);
    }
    BYTE2(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 268) && *(float *)(v2 + 33244) <= (double)*(float *)(v2 + 268) )
  {
    if ( !*(_BYTE *)(v2 + 44187) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v6, (int)&v25, 10, 1);
    }
    BYTE3(v30) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 292) && *(float *)(v2 + 45812) < (double)*(float *)(v2 + 292) )
  {
    if ( !*(_BYTE *)(v2 + 44194) )
    {
      v7 = *(_BYTE *)(v2 + 38584);
      if ( v7 )
      {
        if ( v7 != 1 )
        {
          v27 = 4;
          result = sub_1008C880(v6, (int)&v25, 10, 1);
        }
      }
    }
    BYTE2(v32) = 1;
  }
  v8 = &v31;
  v9 = (_BYTE *)(v2 + 44188);
  v10 = (float *)(v2 + 496);
  v29 = 6;
  do
  {
    if ( 9.8999998e24 != *v10 && *(float *)(v2 + 2288) < (double)*v10 )
    {
      if ( !*v9 && *(_BYTE *)(v2 + 38584) )
      {
        v27 = 4;
        result = sub_1008C880(v28, (int)&v25, 10, 1);
      }
      *(_BYTE *)v8 = 1;
    }
    v10 += 3;
    ++v9;
    v8 = (int *)((char *)v8 + 1);
    --v29;
  }
  while ( v29 );
  if ( 9.8999998e24 == *(float *)(v2 + 304) || *(float *)(v2 + 15592) < (double)*(float *)(v2 + 304) )
  {
    v11 = v28;
  }
  else if ( *(_BYTE *)(v2 + 44195) || !*(_BYTE *)(v2 + 38584) )
  {
    v11 = v28;
    BYTE3(v32) = 1;
  }
  else
  {
    v11 = v28;
    v27 = 4;
    result = sub_1008C880(v28, (int)&v25, 10, 1);
    BYTE3(v32) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 316) && *(float *)(v2 + 15592) >= (double)*(float *)(v2 + 316) )
  {
    if ( !*(_BYTE *)(v2 + 44196) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    LOBYTE(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 328)
    && (*(float *)(v2 + 27576) >= (double)*(float *)(v2 + 328) || *(float *)(v2 + 27584) < (double)*(float *)(v2 + 328)) )
  {
    if ( !*(_BYTE *)(v2 + 44197) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE1(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 340)
    && (*(float *)(v2 + 7452) >= (double)*(float *)(v2 + 340) || *(float *)(v2 + 7460) < (double)*(float *)(v2 + 340)) )
  {
    if ( !*(_BYTE *)(v2 + 44198) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE2(v33) = 1;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 352) && *(float *)(v2 + 26964) >= (double)*(float *)(v2 + 352) )
  {
    if ( !*(_BYTE *)(v2 + 44199) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    BYTE3(v33) = 1;
  }
  v13 = 9.8999998e24 < *(float *)(v2 + 364);
  v14 = 0;
  v15 = 9.8999998e24 == *(float *)(v2 + 364);
  BYTE1(result) = HIBYTE(v12);
  if ( 9.8999998e24 == *(float *)(v2 + 364)
    || (v16 = *(float *)(v2 + 364),
        v18 = *(float *)(v2 + 44640),
        v19 = v18 < v16,
        v20 = 0,
        v21 = v18 == v16,
        BYTE1(result) = HIBYTE(v17),
        v18 < v16) )
  {
    LOBYTE(result) = v34;
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 44200) && *(_BYTE *)(v2 + 38584) )
    {
      v27 = 4;
      result = sub_1008C880(v11, (int)&v25, 10, 1);
    }
    LOBYTE(result) = 1;
  }
  v22 = v31;
  *(_DWORD *)(v2 + 44184) = v30;
  v23 = v32;
  *(_DWORD *)(v2 + 44188) = v22;
  v24 = v33;
  *(_DWORD *)(v2 + 44192) = v23;
  *(_DWORD *)(v2 + 44196) = v24;
  *(_BYTE *)(v2 + 44200) = result;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000ECC0) --------------------------------------------------------
int __usercall sub_1000ECC0@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BBA34, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 172),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 152),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 192),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000ED40) --------------------------------------------------------
char __usercall sub_1000ED40@<al>(int a1@<esi>)
{
  int v1; // eax@1
  char v2; // dl@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 38584) = v2;
  *(_BYTE *)(v1 + 7012) = 1;
  sub_1004C170(v2);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1000ED80) --------------------------------------------------------
char __usercall sub_1000ED80@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // ecx@1
  signed int v6; // eax@1
  void *v7; // ecx@12
  int v8; // eax@16
  char result; // al@16
  int v10; // [sp+18h] [bp-Ch]@4
  float v11; // [sp+1Ch] [bp-8h]@3
  int v12; // [sp+20h] [bp-4h]@1

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 54456, 0);
  v4 = v3;
  *(_DWORD *)(v3 + 44184) = 0;
  *(_DWORD *)(v3 + 44188) = 0;
  *(_DWORD *)(v3 + 44192) = 0;
  *(_DWORD *)(v3 + 44196) = 0;
  *(_BYTE *)(v3 + 44200) = 0;
  *(_BYTE *)(v3 + 54452) = 0;
  *(_BYTE *)(v3 + 44816) = 0;
  *(_BYTE *)(v3 + 44816) = sub_10052210(v5);
  *(_DWORD *)(v4 + 172) = &unk_100BBA50;
  *(_DWORD *)(v4 + 180) = &unk_100BBAF0;
  *(_DWORD *)(v4 + 176) = &unk_100BBAA8;
  *(_DWORD *)(v4 + 156) = v4 + 92;
  v12 = v4 + 92;
  *(_DWORD *)(v4 + 192) = v4 + 124;
  *(_DWORD *)(v4 + 200) = v4 + 133;
  *(_DWORD *)(v4 + 196) = v4 + 144;
  *(_DWORD *)(v4 + 152) = v4 + 12;
  *(_DWORD *)(v4 + 160) = v4 + 48;
  *(_BYTE *)(v4 + 124) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 8) = 3;
  **(_BYTE **)(v4 + 196) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 7) = 3;
  v6 = 0;
  do
    *(_BYTE *)(v6++ + *(_DWORD *)(v4 + 200)) = 3;
  while ( v6 < 11 );
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BB76C);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_1000D6F0(a1);
  if ( !sub_10066790(3u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 644, v10, 1.0, 0.125);
  if ( !sub_10066790(0x56u, &v11) || !sub_10031F70(100.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 652, v10, 1.0, 0.125);
  if ( !sub_100663D0(&v11) || !sub_10031F70(100000.0, v11, (int)&v10) )
    v10 = 0;
  sub_10066730(v4 + 15204, v10, 1.0, 0.125);
  *(_BYTE *)(v4 + 20930) = sub_1004BEE0(v7);
  *(_BYTE *)(v4 + 20928) = 1;
  *(_BYTE *)(v4 + 20929) = 1;
  if ( sub_1000D640(0) )
    *(_BYTE *)(v4 + 20928) = 0;
  if ( sub_1000D640(2) )
    *(_BYTE *)(v4 + 20929) = 0;
  *(_DWORD *)v4 = v4 + 20932;
  *(_DWORD *)(v4 + 4) = v4 + 38588;
  *(_DWORD *)(v4 + 8) = v4 + 15212;
  *(_DWORD *)(v4 + 12) = v4 + 10712;
  *(_DWORD *)(v4 + 28) = v4 + 1908;
  *(_DWORD *)(v4 + 32) = v4 + 27140;
  *(_DWORD *)(v4 + 36) = v4 + 7016;
  *(_DWORD *)(v4 + 40) = v4 + 26528;
  *(_DWORD *)(v4 + 16) = v4 + 27752;
  *(_DWORD *)(v4 + 20) = v4 + 32856;
  *(_DWORD *)(v4 + 44) = v4 + 44204;
  v8 = v12;
  *(_DWORD *)(v4 + 24) = v4 + 45432;
  *(_DWORD *)(v8 + 8) = v4 + 45432;
  *(_DWORD *)v8 = v4 + 10100;
  *(_DWORD *)(v8 + 4) = v4 + 44820;
  *(_DWORD *)(v8 + 12) = v4 + 37964;
  *(_DWORD *)(v8 + 16) = v4 + 8876;
  *(_DWORD *)(v8 + 20) = v4 + 7628;
  *(_DWORD *)(v8 + 24) = v4 + 6400;
  *(_DWORD *)(v8 + 28) = v4 + 660;
  *(_DWORD *)(v4 + 52) = v4 + 37348;
  *(_DWORD *)(v4 + 64) = v4 + 10100;
  *(_DWORD *)(v4 + 68) = v4 + 19704;
  *(_DWORD *)(v4 + 76) = v4 + 27140;
  *(_DWORD *)(v4 + 80) = v4 + 7016;
  *(_DWORD *)(v4 + 48) = v4 + 32244;
  *(_DWORD *)(v4 + 56) = v4 + 9488;
  *(_DWORD *)(v4 + 84) = v4 + 26528;
  *(_DWORD *)(v4 + 60) = v4 + 49924;
  *(_DWORD *)(v4 + 72) = v4 + 20316;
  *(_DWORD *)(v4 + 88) = v4 + 44204;
  *(_BYTE *)(v4 + 38584) = sub_1004BF10((void *)(v4 + 20316));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BBA34, v4, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BBA50, v4 + 12, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BBAA8, v12, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000F250) --------------------------------------------------------
void __usercall sub_1000F250(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // edi@1
  float *v3; // ebx@1
  int v4; // ecx@8
  float *v5; // edx@8
  float v6; // [sp+0h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = (float *)(v1 + 492);
  do
  {
    v6 = sub_1004C3E0((unsigned __int16)v2 + 8);
    if ( v6 != 9.8999998e24 )
      *v3 = v6 * 1.799999952316284 + 32.0;
    ++v2;
    v3 += 3;
  }
  while ( v2 < 6 );
  if ( *(_BYTE *)(v1 + 7012) || *(_BYTE *)(v1 + 20930) )
    *(_BYTE *)(v1 + 1622) = sub_10066EE0(v1 + 212, 0x17u, 6u);
  v4 = *(_BYTE *)(v1 + 1622);
  v5 = (float *)(v1 + 4 * (3 * v4 + 123));
  if ( 9.8999998e24 != *v5 )
  {
    *(float *)(v1 + 276) = *v5;
    sprintf((char *)(v1 + 2392), "%d", v4 + 1);
    *(float *)(v1 + 564) = *(float *)(v1 + 12 * (*(_BYTE *)(v1 + 1622) + 41));
  }
}

//----- (1000F330) --------------------------------------------------------
void __cdecl sub_1000F330(float a1)
{
  int v1; // ebp@1
  long double v2; // st7@1
  int v3; // esi@1
  float *v4; // edi@1
  float *v5; // eax@1
  signed int v6; // ecx@1
  double v7; // st7@5
  double v8; // st7@6
  int v9; // edx@16
  int v10; // ecx@16
  bool v11; // c3@19
  double v12; // st7@27
  double v13; // st7@37
  signed int v14; // ebp@37
  double v15; // st6@39
  int v16; // [sp+1Ch] [bp-10h]@1
  float v17; // [sp+20h] [bp-Ch]@5
  int v18; // [sp+24h] [bp-8h]@1
  int v19; // [sp+28h] [bp-4h]@1

  v1 = LODWORD(a1);
  v16 = 0;
  v2 = pow(2.0, 31.0);
  v18 = (signed int)(v2 - 1.0);
  v19 = (signed int)(v2 * -1.0);
  v3 = *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 56) + 12);
  a1 = 0.0;
  v4 = (float *)(v3 + 216);
  v5 = (float *)(v3 + 216);
  v6 = 36;
  do
  {
    *v5 = 9.8999998e24;
    v5 += 3;
    --v6;
  }
  while ( v6 );
  *v4 = sub_1004C3E0(0x18u);
  *(float *)(v3 + 228) = sub_1004C3E0(0x1Eu);
  if ( sub_100663D0(&a1) && sub_10031F70(100000.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 15204, v16);
    v17 = (double)*(signed int *)(v3 + 15208) / 100000.0;
    v7 = v17;
    *(float *)(v3 + 240) = v17;
    *(float *)(v3 + 372) = v7;
  }
  v17 = sub_1004C3E0(0x1Cu);
  v8 = v17;
  *(float *)(v3 + 252) = v17;
  *(float *)(v3 + 576) = v8;
  a1 = sub_1004C3E0(0x1Du);
  if ( a1 != 9.8999998e24 )
  {
    *(float *)(v3 + 264) = a1 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 588) = 1.799999952316284 * a1 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 44816) == 2 )
  {
    *(_BYTE *)(v3 + 20928) = sub_1000D640(0) == 0;
    *(_BYTE *)(v3 + 20929) = sub_1000D640(2) == 0;
  }
  if ( sub_100664A0(&a1) && !*(_BYTE *)(v3 + 20928) )
    *(float *)(v3 + 300) = a1;
  if ( sub_10066510(&a1) && !*(_BYTE *)(v3 + 20929) )
    *(float *)(v3 + 312) = a1;
  *(float *)(v3 + 636) = sub_1004C0C0();
  *(float *)(v3 + 624) = sub_1004C0D0(v10, v9);
  *(float *)(v3 + 324) = sub_1004C3E0(4u);
  *(float *)(v3 + 336) = sub_1004C3E0(5u);
  sub_1000C550(v1);
  sub_1000F250(v1);
  a1 = sub_1004C3E0(0x1Fu);
  if ( a1 != 9.8999998e24 )
  {
    *(float *)(v3 + 288) = a1 * 1.799999952316284 + 32.0;
    *(float *)(v3 + 384) = 1.799999952316284 * a1 + 32.0;
  }
  if ( *(_BYTE *)(v3 + 20930) )
  {
    v11 = 9.8999998e24 == *(float *)(v3 + 38580);
    *(_BYTE *)(v3 + 38137) = 0;
    *(_BYTE *)(v3 + 38138) = 0;
    *(_BYTE *)(v3 + 38139) = 0;
    if ( v11 )
      *(float *)(v3 + 38580) = 0.0;
    if ( *(float *)(v3 + 38580) >= (double)*(float *)(v3 + 288) || *(_BYTE *)(v3 + 38576) )
    {
      if ( *(float *)(v3 + 38580) - *(float *)(v3 + 288) > 7.0 )
        *(_BYTE *)(v3 + 38576) = 1;
    }
    else
    {
      *(float *)(v3 + 38580) = *(float *)(v3 + 288);
    }
    if ( *(_BYTE *)(v3 + 38576) )
      v12 = *(float *)(v3 + 288) - *(float *)(v3 + 38580);
    else
      v12 = 100000.0;
    *(float *)(v3 + 37960) = v12;
    *(float *)(v3 + 396) = *(float *)(v3 + 37960);
  }
  else
  {
    *(_BYTE *)(v3 + 38137) = 1;
    *(float *)(v3 + 38580) = 0.0;
    *(_BYTE *)(v3 + 38138) = 1;
    *(_BYTE *)(v3 + 38139) = 1;
    *(_BYTE *)(v3 + 38576) = 0;
    *(float *)(v3 + 37960) = 9.8999998e24;
  }
  *(float *)(v3 + 600) = sub_1004C070();
  *(float *)(v3 + 612) = sub_1004C3E0(0x20u);
  if ( sub_10066790(3u, &a1) && sub_10031F70(100.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 644, v16);
    *(float *)(v3 + 348) = (double)*(signed int *)(v3 + 648) / 100.0;
  }
  if ( sub_10066790(0x56u, &a1) && sub_10031F70(100.0, a1, (int)&v16) )
  {
    sub_100666C0(v3 + 652, v16);
    *(float *)(v3 + 360) = (double)*(signed int *)(v3 + 656) / 100.0;
  }
  v13 = 9.8999998e24;
  v14 = 36;
  do
  {
    v17 = *v4;
    if ( (LODWORD(v17) & 0x7F800000) == 2139095040 || (v15 = *v4 / *(v4 - 1), (double)v18 < v15) || (double)v19 > v15 )
    {
      if ( v13 != *v4 )
      {
        sub_10051A40(".\\cdp_pg_eis_cessna_t206h_3d.c", 3404, 0, "Gauge data is not finite");
        v13 = 9.8999998e24;
      }
      *v4 = v13;
    }
    v4 += 3;
    --v14;
  }
  while ( v14 );
  sub_1004C380(v3 + 212, 0x24u);
  if ( *(float *)(v3 + 44648) > (double)*(float *)(v3 + 364) && *(float *)(v3 + 44640) < (double)*(float *)(v3 + 364) )
  {
    *(float *)(v3 + 360) = 0.0;
    *(float *)(v3 + 364) = 0.0;
  }
  if ( *(float *)(v3 + 352) >= 100.0 || *(float *)(v3 + 352) <= -100.0 )
    *(_WORD *)(v3 + 27044) = 23;
  else
    *(_WORD *)(v3 + 27044) = 24;
  if ( *(float *)(v3 + 364) >= 100.0 || *(float *)(v3 + 364) <= -100.0 )
    *(_WORD *)(v3 + 44720) = 23;
  else
    *(_WORD *)(v3 + 44720) = 24;
  if ( *(float *)(v3 + 328) >= 100.0 || *(float *)(v3 + 328) <= -10.0 )
    *(_WORD *)(v3 + 27656) = 20;
  else
    *(_WORD *)(v3 + 27656) = 21;
  if ( *(float *)(v3 + 340) >= 100.0 || *(float *)(v3 + 340) <= -10.0 )
    *(_WORD *)(v3 + 7532) = 20;
  else
    *(_WORD *)(v3 + 7532) = 21;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (1000F8F0) --------------------------------------------------------
void __usercall sub_1000F8F0(int a1@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(dword_1031FB44 + 32) >= (double)*(float *)(v1 + 220) )
    *(_BYTE *)(v1 + 22924) = 10;
  else
    *(_BYTE *)(v1 + 22924) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000F920) --------------------------------------------------------
void __usercall sub_1000F920(int a1@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(dword_1031FB44 + 28) >= (double)*(float *)(v1 + 232) )
    *(_BYTE *)(v1 + 40580) = 10;
  else
    *(_BYTE *)(v1 + 40580) = 16;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1000F950) --------------------------------------------------------
char __usercall sub_1000F950@<al>(int a1@<edi>)
{
  int v1; // esi@1
  float *v2; // ebp@2
  char result; // al@3
  float *v4; // ebp@6
  float v5; // [sp+8h] [bp-10h]@0

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1000F330(v5);
  sub_1000F8F0(a1);
  sub_1000F920(a1);
  sub_1000E790(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BB980, (int)&unk_100BBA9C, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BBA34, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 172),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 152),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 38584) + 192),
    255);
  if ( !*(_BYTE *)(v1 + 38584) )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 565.0);
    sub_1008C2F0(137.0, 565.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 54440) = 0.5;
    v2 = (float *)(v1 + 54416);
    *(float *)(v1 + 54444) = 0.5;
    *(_DWORD *)(v1 + 54432) = -14671840;
    *(float *)(v1 + 54416) = 75.5;
    *(_DWORD *)(v1 + 54436) = -1;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 565.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 54416);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 588.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 54416);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 588.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54416);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 588.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 54416);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 612.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)"VOLTS", 12.0);
    sub_10065B50(a1, (int)"VOLTS", v1 + 54416);
    *v2 = 75.5;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 643.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)"BATT", 12.0);
    sub_10065B50(a1, (int)"BATT", v1 + 54416);
    *v2 = 24.0;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 643.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
    sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54416);
    *v2 = 126.0;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54420) = 643.0;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
    sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 54416);
    *v2 = 75.5;
    *(float *)(v1 + 54420) = 667.0;
    *(_DWORD *)(v1 + 54424) = 2;
    *(float *)(v1 + 54428) = 12.0;
    *(float *)(v1 + 54448) = sub_1008D010(2, (int)"AMPS", 12.0);
    sub_10065B50(a1, (int)"AMPS", v1 + 54416);
    sub_10048A00(10.0, 443.0, v1 + 45432);
    sub_10048A00(10.0, 491.0, v1 + 15212);
    *(_BYTE *)(v1 + 49622) = 0;
  }
  result = *(_BYTE *)(v1 + 38584);
  if ( result == 1 )
  {
    sub_10046480(10.0, 251.0, v1 + 10100);
    sub_10048A00(10.0, 279.0, v1 + 45432);
    sub_10046480(10.0, 603.0, v1 + 6400);
    result = sub_10048A00(10.0, 630.0, v1 + 15212);
    *(_BYTE *)(v1 + 49622) = 1;
    *(_BYTE *)(a1 + 6) = 2;
  }
  else
  {
    if ( result == 2 )
    {
      j_gdi_pvg_color_u32(-1);
      sub_1008C110(1.0);
      j_gdi_pvg_begin(64);
      sub_1008C2F0(10.0, 565.0);
      sub_1008C2F0(137.0, 565.0);
      sub_1008C2F0(10.0, 374.0);
      sub_1008C2F0(137.0, 374.0);
      j_gdi_pvg_end();
      *(float *)(v1 + 54440) = 0.5;
      v4 = (float *)(v1 + 54416);
      *(float *)(v1 + 54444) = 0.5;
      *(_DWORD *)(v1 + 54432) = -14671840;
      *(float *)(v1 + 54416) = 75.5;
      *(_DWORD *)(v1 + 54436) = -1;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 565.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
      sub_10065B50(a1, (int)"ELECTRICAL", v1 + 54416);
      *v4 = 75.5;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 374.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
      sub_10065B50(a1, (int)"FUEL CALC", v1 + 54416);
      *v4 = 75.5;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 588.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8EDC, 12.0);
      sub_10065B50(a1, (int)&unk_100B8EDC, v1 + 54416);
      *v4 = 24.0;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 588.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54416);
      *v4 = 126.0;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 588.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ECC, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ECC, v1 + 54416);
      *v4 = 75.5;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 612.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)"VOLTS", 12.0);
      sub_10065B50(a1, (int)"VOLTS", v1 + 54416);
      *v4 = 75.5;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 643.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)"BATT", 12.0);
      sub_10065B50(a1, (int)"BATT", v1 + 54416);
      *v4 = 24.0;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 643.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8ED4, 12.0);
      sub_10065B50(a1, (int)&unk_100B8ED4, v1 + 54416);
      *v4 = 126.0;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 643.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)&unk_100B8EB0, 12.0);
      sub_10065B50(a1, (int)&unk_100B8EB0, v1 + 54416);
      *v4 = 75.5;
      *(_DWORD *)(v1 + 54424) = 2;
      *(float *)(v1 + 54420) = 667.0;
      *(float *)(v1 + 54428) = 12.0;
      *(float *)(v1 + 54448) = sub_1008D010(2, (int)"AMPS", 12.0);
      sub_10065B50(a1, (int)"AMPS", v1 + 54416);
      sub_10046480(10.0, 404.0, v1 + 10100);
      sub_10046480(10.0, 251.0, v1 + 32244);
      result = sub_10048A00(10.0, 491.0, v1 + 15212);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10010210) --------------------------------------------------------
char __cdecl sub_10010210(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_1000ECC0(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_1000ED80(a1, 0, 0);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_1000F950(a1);
      break;
    case 32821:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54452) = 0;
      break;
    case 32820:
      LOBYTE(v1) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54452) = 1;
      break;
    case 32825:
      LOBYTE(v1) = sub_1000ED40(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v1) = sub_1000C4C0(a1);
      break;
    case 32791:
    case 32792:
    case 32793:
    case 32794:
    case 32795:
    case 32796:
    case 32797:
    case 32798:
    case 32799:
    case 32800:
    case 32801:
    case 32803:
    case 32804:
    case 32805:
    case 32806:
    case 32807:
    case 32808:
    case 32809:
    case 32810:
    case 32811:
    case 32812:
    case 32813:
    case 32814:
    case 32815:
    case 32816:
    case 32817:
    case 32818:
    case 32822:
    case 32823:
    case 32826:
    case 32827:
    case 32828:
    case 32829:
    case 32830:
    case 32831:
    case 32832:
    case 32834:
    case 32835:
    case 32836:
    case 32837:
    case 32838:
    case 32839:
    case 32840:
    case 32841:
    case 32842:
    case 32843:
    case 32844:
    case 32845:
    case 32846:
    case 32847:
    case 32848:
    case 32849:
    case 32850:
    case 32851:
    case 32852:
    case 32853:
    case 32854:
    case 32855:
    case 32856:
    case 32857:
    case 32858:
    case 32859:
    case 32860:
    case 32861:
    case 32862:
    case 32863:
    case 32864:
    case 32865:
    case 32866:
    case 32867:
    case 32868:
    case 32869:
    case 32870:
    case 32871:
    case 32872:
    case 32873:
    case 32874:
    case 32875:
    case 32876:
    case 32877:
    case 32878:
    case 32879:
    case 32880:
    case 32881:
    case 32882:
    case 32883:
    case 32884:
    case 32885:
    case 32886:
    case 32887:
      return v1;
  }
  return v1;
}

//----- (10010300) --------------------------------------------------------
int __usercall sub_10010300@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1
  double v3; // st7@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10049310((int)&unk_100BC508, 0xBu, 0, v1 + 23704);
  sub_1004A1A0(v1 + 43104, (int)"EGT F", dword_1031FB44 + 5388, 7.0, 560.0, 135.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20732, v1 + 43104);
  sub_10049310((int)&unk_100BC8E8, 2u, 0, v1 + 43104);
  sub_10049040(v1 + 404, 1, 1, v1 + 43104);
  *(float *)(v1 + 43564) = 26.0;
  *(float *)(v1 + 43168) = 7.0;
  *(float *)(v1 + 43208) = 0.0;
  *(_WORD *)(v1 + 47416) = 17;
  *(_BYTE *)(v1 + 47424) = 1;
  *(_DWORD *)(v1 + 47420) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 43618) = 0;
  strcpy((char *)(v1 + 43588), "1");
  result = sub_10046920(v1 + 139624, (int)" PEAK", dword_1031FB44 + 6536, 255.0, 429.0, 1.0, 15.0);
  *(float *)(v1 + 139840) = 0.5;
  *(float *)(v1 + 139684) = 0.5;
  *(_DWORD *)(v1 + 140144) = &unk_100B8DC0;
  v3 = *(float *)(v1 + 139656) + 21.0;
  *(_WORD *)(v1 + 140140) = 10;
  *(_BYTE *)(v1 + 140148) = 1;
  *(float *)(v1 + 139656) = v3;
  *(_DWORD *)(v1 + 139672) = v1 + 604;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10010490) --------------------------------------------------------
int __usercall sub_10010490@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10049310((int)&unk_100BC468, 0xAu, 0, v1 + 23704);
  sub_1004A1E0(v1 + 123476, (int)"TIT F", dword_1031FB44 + 5552, 7.0, 560.0, 135.0, 37.0, 0);
  sub_100490F0(dword_1031FB44 + 20760, v1 + 123476);
  sub_10049310((int)&unk_100BC668, 4u, 0, v1 + 123476);
  *(_WORD *)(v1 + 127788) = 17;
  *(_BYTE *)(v1 + 127796) = 1;
  *(_DWORD *)(v1 + 127792) = &unk_100B8DC0;
  sub_10049040(v1 + 488, 2, 1, v1 + 123476);
  *(float *)(v1 + 123936) = 26.0;
  *(float *)(v1 + 124000) = 26.0;
  v2 = *(float *)(v1 + 123544);
  *(_BYTE *)(v1 + 123990) = 0;
  *(_BYTE *)(v1 + 124054) = 0;
  *(float *)(v1 + 123544) = v2 - 17.0;
  sub_10044EC0(v1 + 127968, (int)"TIT F", dword_1031FB44 + 5552, 235.0, 429.0, 120.0, 190.0);
  sub_10042DB0(dword_1031FB44 + 20760, v1 + 127968);
  sub_100445B0((int)&unk_100BC6A8, 0xDu, 0, v1 + 127968);
  *(_WORD *)(v1 + 139418) = 17;
  *(_BYTE *)(v1 + 139424) = 1;
  *(_DWORD *)(v1 + 139420) = &unk_100B8DC0;
  sub_10042D60(v1 + 488, 2, 1, v1 + 127968);
  sub_10046960(v1 + 139624, (int)byte_100B8180, dword_1031FB44 + 6536, 235.0, 634.0, 120.0, 15.0);
  *(_DWORD *)(v1 + 139720) = v1 + 616;
  *(_DWORD *)(v1 + 139672) = v1 + 604;
  *(_WORD *)(v1 + 140140) = 10;
  *(_BYTE *)(v1 + 140148) = 1;
  *(_DWORD *)(v1 + 140144) = &unk_100B8DC0;
  strcpy((char *)(v1 + 139868), "");
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100106B0) --------------------------------------------------------
int __cdecl sub_100106B0(int a1)
{
  int v1; // ebp@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  double v5; // st7@3
  int v6; // ST58_4@3
  char v7; // al@3
  float v8; // edi@6
  signed int v9; // eax@6
  float v10; // edi@6
  double v11; // st6@6
  double v12; // st6@6
  double v13; // st7@6
  int v14; // ST58_4@6
  float v15; // ST5C_4@6
  int v16; // ecx@6
  float v17; // ST5C_4@9
  int v18; // ecx@9
  int v19; // ST58_4@13
  int result; // eax@16
  int v21; // [sp+8h] [bp-84h]@12
  float v22; // [sp+Ch] [bp-80h]@3
  float v23; // [sp+Ch] [bp-80h]@12
  float v24; // [sp+10h] [bp-7Ch]@3
  float v25; // [sp+10h] [bp-7Ch]@12
  float v26; // [sp+14h] [bp-78h]@3
  float v27; // [sp+14h] [bp-78h]@12
  float v28; // [sp+18h] [bp-74h]@3
  float v29; // [sp+18h] [bp-74h]@12
  int v30; // [sp+38h] [bp-54h]@6
  float v31; // [sp+3Ch] [bp-50h]@6
  int v32; // [sp+40h] [bp-4Ch]@6
  int v33; // [sp+44h] [bp-48h]@6
  char v34; // [sp+48h] [bp-44h]@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"QC";
  v3 = v1 + 180;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&unk_100BC43C );
  *(float *)(v1 + 172040) = 0.0;
  *(float *)(v1 + 172044) = 0.0;
  *(float *)(v1 + 172052) = 12.0;
  *(_DWORD *)(v1 + 172048) = 2;
  *(_DWORD *)(v1 + 172056) = 0;
  *(float *)(v1 + 172064) = 0.5;
  *(_DWORD *)(v1 + 172060) = -1;
  *(float *)(v1 + 172068) = 1.0;
  *(float *)(v1 + 172072) = 40.0;
  sub_10061B00(v1 + 644, (int)"MAN IN HG", dword_1031FB44 + 3912, 7.0, 5.0, 128.0, 128.0);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 644);
  *(float *)(v1 + 864) = 165.0;
  v5 = *(float *)(v1 + 868) - 165.0;
  *(_WORD *)(v1 + 6202) = 5;
  *(_BYTE *)(v1 + 6208) = 1;
  *(_DWORD *)(v1 + 6204) = &unk_100B8DC0;
  *(float *)(v1 + 968) = v5;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 644);
  sub_10060F20(v1 + 176, 1, v1 + 644);
  sub_10062160(16931.934, 0.0, -0.2, v1 + 644);
  sub_10061F10(16931.934, "%.0f", 1.0, 9.0, -0.2, v1 + 644);
  sub_10061B00(v1 + 11872, (int)"RPM", dword_1031FB44 + 4076, 7.0, 138.0, 128.0, 128.0);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 11872);
  *(float *)(v1 + 14172) = 71.0;
  *(_WORD *)(v1 + 17430) = 6;
  *(_BYTE *)(v1 + 17436) = 1;
  *(float *)(v1 + 14176) = 231.0;
  *(_DWORD *)(v1 + 17432) = &unk_100B8DC0;
  *(float *)(v1 + 11972) = 71.0;
  *(float *)(v1 + 11976) = 227.0;
  *(float *)(v1 + 11908) = 118.0;
  *(float *)(v1 + 12092) = 165.0;
  *(float *)(v1 + 12196) = *(float *)(v1 + 12096) - 165.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 11872);
  sub_10060F20(v1 + 188, 1, v1 + 11872);
  v6 = sub_10062160(500.0, 0.0, -0.2, v1 + 11872);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 9.0, -0.2, v1 + 11872);
  sub_10060FA0(1500.0, "x100", 1.0, 9.0, -0.60000002, v6, v1 + 11872);
  *(_BYTE *)(v1 + 17428) = v6 + 1;
  v7 = (signed int)*(float *)(dword_1031FB44 + 7240);
  *(_BYTE *)(v1 + 23088) = v7;
  v28 = 15.0;
  v26 = 135.0;
  v24 = 282.0;
  v22 = 7.0;
  if ( v7 )
  {
    sub_10046920(v1 + 23092, (int)"ENG", dword_1031FB44 + 7192, v22, v24, v26, v28);
    *(_WORD *)(v1 + 23608) = 39;
    *(_BYTE *)(v1 + 23616) = 1;
    *(_DWORD *)(v1 + 23612) = &unk_100B8DC0;
    strcpy((char *)(v1 + 23336), "HRS");
    *(float *)(v1 + 23320) = 142.0;
    *(_DWORD *)(v1 + 23140) = v1 + 640;
    *(float *)(v1 + 23360) = 1.0;
    *(float *)(v1 + 23120) = 74.0;
    *(float *)(v1 + 23152) = 0.5;
  }
  else
  {
    sub_10046920(v1 + 23092, (int)byte_100B8180, dword_1031FB44 + 7192, v22, v24, v26, v28);
    *(_BYTE *)(v1 + 23266) = 1;
  }
  sub_1004A1A0(v1 + 23704, (int)"FFLOW GPH", dword_1031FB44 + 4240, 7.0, 388.0, 135.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 23704);
  *(_WORD *)(v1 + 28016) = 33;
  *(_BYTE *)(v1 + 28024) = 1;
  *(_DWORD *)(v1 + 28020) = &unk_100B8DC0;
  sub_10049040(v1 + 200, 1, 1, v1 + 23704);
  *(float *)(v1 + 23768) = 7.0;
  *(float *)(v1 + 23808) = 0.0;
  *(_BYTE *)(v1 + 24218) = 0;
  *(float *)(v1 + 24164) = 26.0;
  sub_1004A1E0(v1 + 107700, (int)"FUEL QTY GAL", dword_1031FB44 + 5224, 7.0, 308.0, 135.0, 37.0, 0);
  *(_WORD *)(v1 + 112012) = 31;
  *(_BYTE *)(v1 + 112020) = 1;
  sub_10049310((int)&unk_100BC828, 0xAu, 0, v1 + 107700);
  *(float *)&v30 = 0.0;
  v31 = 0.0;
  v32 = 0;
  v33 = 0;
  v30 = *(int *)(v1 + 107724);
  v8 = COERCE_FLOAT(sub_10048890(v1 + 107700));
  v31 = -0.40000001;
  sub_10049130((int)&v30, v8, v1 + 107700);
  *(_DWORD *)((LODWORD(v8) << 6) + v1 + 108592) = -1;
  v9 = sub_10048890(v1 + 107700);
  v31 = 0.40000001;
  v10 = *(float *)&v9;
  sub_100649E0((int)&v32, &unk_100BCCB8, 7);
  sub_10049130((int)&v30, v10, v1 + 107700);
  *(_DWORD *)((LODWORD(v10) << 6) + v1 + 108592) = -1;
  sub_10049040(v1 + 380, 2, 0, v1 + 107700);
  *(float *)(v1 + 108160) = 26.0;
  *(float *)(v1 + 108224) = 26.0;
  *(float *)(v1 + 108352) = 10.0;
  *(float *)(v1 + 108356) = 10.0;
  *(_BYTE *)(v1 + 108214) = 0;
  v11 = *(float *)(v1 + 108156);
  *(_BYTE *)(v1 + 108278) = 0;
  v12 = v11 - *(float *)(v1 + 108164);
  *(_BYTE *)(v1 + 108396) = 2;
  *(_DWORD *)(v1 + 108400) = -16711681;
  *(_BYTE *)(v1 + 108406) = 1;
  *(_BYTE *)(v1 + 108460) = 2;
  *(_DWORD *)(v1 + 108464) = -16711681;
  *(float *)(v1 + 108348) = v12 + 5.0;
  *(_BYTE *)(v1 + 108470) = 1;
  *(float *)(v1 + 108416) = 10.0;
  *(float *)(v1 + 108420) = 10.0;
  *(float *)(v1 + 108412) = *(float *)(v1 + 108228) + *(float *)(v1 + 108220) - 5.0;
  sub_1004A1A0(v1 + 62620, (int)"OIL PSI", dword_1031FB44 + 4732, 7.0, 448.0, 135.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20620, v1 + 62620);
  sub_10049310((int)&unk_100BC778, 2u, 0, v1 + 62620);
  sub_10049040(v1 + 296, 1, 1, v1 + 62620);
  *(float *)(v1 + 62684) = 7.0;
  *(float *)(v1 + 62724) = 0.0;
  *(float *)(v1 + 63080) = 26.0;
  *(_WORD *)(v1 + 66932) = 14;
  *(_BYTE *)(v1 + 66940) = 1;
  *(_DWORD *)(v1 + 66936) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 63134) = 0;
  sub_1004A1A0(v1 + 52508, (int)"OIL F", dword_1031FB44 + 4568, 7.0, 497.0, 135.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 52508);
  sub_10049310((int)"8L", 2u, 0, v1 + 52508);
  sub_10049040(v1 + 284, 1, 1, v1 + 52508);
  *(float *)(v1 + 52572) = 7.0;
  *(float *)(v1 + 52612) = 0.0;
  *(_WORD *)(v1 + 56820) = 17;
  *(float *)(v1 + 52968) = 26.0;
  *(_BYTE *)(v1 + 56828) = 1;
  *(_DWORD *)(v1 + 56824) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 53022) = 0;
  sub_1004A1A0(v1 + 33816, (int)"CHT F", dword_1031FB44 + 4404, 7.0, 621.0, 135.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 33816);
  sub_10049310((int)&unk_100BC5B8, 2u, 0, v1 + 33816);
  sub_10049040(v1 + 212, 1, 1, v1 + 33816);
  *(float *)(v1 + 34276) = 26.0;
  *(float *)(v1 + 33880) = 7.0;
  *(_WORD *)(v1 + 38128) = 17;
  *(float *)(v1 + 33920) = 0.0;
  *(_DWORD *)(v1 + 38132) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 38136) = 1;
  *(_BYTE *)(v1 + 34330) = 0;
  strcpy((char *)(v1 + 34300), "1");
  sub_1004A1A0(v1 + 151496, (int)"AILERON TRIM", dword_1031FB44 + 5716, 7.0, 664.0, 135.0, 18.5, 0);
  sub_10049310((int)&unk_100BC8C8, 2u, 0, v1 + 151496);
  sub_10049040(v1 + 536, 1, 0, v1 + 151496);
  *(float *)(v1 + 151956) = 26.0;
  *(_WORD *)(v1 + 155808) = 12;
  *(_BYTE *)(v1 + 155816) = 1;
  *(_BYTE *)(v1 + 152010) = 0;
  sub_1004A1A0(v1 + 160480, (int)"TRIM", dword_1031FB44 + 5880, 171.0, 513.0, 18.5, 160.0, 1);
  sub_10049310((int)&unk_100BC978, 2u, 0, v1 + 160480);
  sub_10049040(v1 + 548, 1, 0, v1 + 160480);
  v13 = *(float *)(v1 + 160548) - 8.0;
  *(_WORD *)(v1 + 164792) = 12;
  *(_BYTE *)(v1 + 164800) = 1;
  *(float *)(v1 + 160548) = v13;
  *(_BYTE *)(v1 + 160994) = 0;
  *(float *)(v1 + 160944) = 26.0;
  sub_10042820(v1 + 6240, (int)"MAN IN HG", dword_1031FB44 + 3912, 287.0, 15.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20480, v1 + 6240);
  *(_WORD *)(v1 + 11814) = 5;
  *(_BYTE *)(v1 + 11820) = 1;
  *(_DWORD *)(v1 + 11816) = &unk_100B8DC0;
  *(float *)(v1 + 6476) = 165.0;
  *(float *)(v1 + 6580) = *(float *)(v1 + 6480) - 165.0;
  sub_10042980((_BYTE *)(dword_1031FB44 + 3912), v1 + 6240);
  sub_10062160(16931.934, 3386.3867, -0.2, v1 + 6256);
  sub_10061F10(16931.934, "%.0f", 1.0, 12.0, -0.2, v1 + 6256);
  sub_10060F20(v1 + 176, 1, v1 + 6256);
  *(float *)(v1 + 6360) = *(float *)(v1 + 6360) + 20.0;
  *(float *)(v1 + 8560) = *(float *)(v1 + 8560) + 20.0;
  sub_10042820(v1 + 17468, (int)"RPM", dword_1031FB44 + 4076, 522.0, 15.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20508, v1 + 17468);
  *(_WORD *)(v1 + 23042) = 6;
  *(_BYTE *)(v1 + 23048) = 1;
  *(_DWORD *)(v1 + 23044) = &unk_100B8DC0;
  *(float *)(v1 + 17704) = 165.0;
  *(float *)(v1 + 17808) = *(float *)(v1 + 17708) - 165.0;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4076), v1 + 17468);
  v14 = sub_10062160(500.0, 100.0, -0.2, v1 + 17484);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 12.0, -0.2, v1 + 17484);
  sub_10060F20(v1 + 188, 1, v1 + 17484);
  *(float *)(v1 + 17588) = *(float *)(v1 + 17588) + 20.0;
  *(float *)(v1 + 19788) = *(float *)(v1 + 19788) + 20.0;
  sub_10060FA0(1500.0, "x100", 1.0, 12.0, -0.60000002, v14, v1 + 17484);
  *(_BYTE *)(v1 + 23040) = v14 + 1;
  sub_10042820(v1 + 28196, (int)"FFLOW GPH", dword_1031FB44 + 4240, 20.0, 190.0, 175.0, 175.0);
  sub_10042990(dword_1031FB44 + 20536, v1 + 28196);
  *(_WORD *)(v1 + 33770) = 33;
  *(_BYTE *)(v1 + 33776) = 1;
  *(_DWORD *)(v1 + 33772) = &unk_100B8DC0;
  *(float *)(v1 + 28432) = 165.0;
  *(float *)(v1 + 28536) = *(float *)(v1 + 28436) - 165.0;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4240), v1 + 28196);
  sub_10062160(0.0052575162, 0.0026287581, -0.2, v1 + 28212);
  sub_10061F10(0.0052575162, "%.0f", 1.0, 9.0, -0.2, v1 + 28212);
  sub_10060F20(v1 + 200, 1, v1 + 28212);
  *(float *)(v1 + 28316) = *(float *)(v1 + 28316) + 5.0;
  *(float *)(v1 + 30516) = *(float *)(v1 + 30516) + 5.0;
  sub_100427E0(v1 + 47596, (int)"EGT F", dword_1031FB44 + 5388, 55.0, 455.0, 140.0, 190.0);
  sub_10041F10(dword_1031FB44 + 20732, v1 + 47596);
  sub_10041F20((int)&unk_100BC908, 7, 0.0, v1 + 47596);
  sub_10047B10(v1 + 404, 6, 1, v1 + 47612);
  *(_WORD *)(v1 + 48576) = 17;
  *(_BYTE *)(v1 + 48584) = 1;
  *(_DWORD *)(v1 + 48580) = &unk_100B8DC0;
  *(float *)(v1 + 47716) = 55.0;
  *(float *)(v1 + 47720) = *(float *)(v1 + 48332) - 18.0;
  *(float *)(v1 + 47756) = 0.5;
  sub_10042820(v1 + 112192, (int)"L FUEL QTY GAL", dword_1031FB44 + 5224, 242.0, 240.0, 125.0, 125.0);
  *(_WORD *)(v1 + 117766) = 31;
  *(_BYTE *)(v1 + 117772) = 1;
  *(_DWORD *)(v1 + 117768) = &unk_100B8DC0;
  v15 = *(float *)(v1 + 112228) - *(float *)(v1 + 112224);
  sub_10062160(v15, 0.0, -0.2, v1 + 112208);
  qmemcpy(&v34, (const void *)(v1 + 114628), 0x40u);
  v16 = sub_10062160(37.854118, 18.927059, -0.2, v1 + 112208) << 6;
  if ( *(float *)(v1 + 112228) <= 189.2706 )
  {
    qmemcpy((void *)(v16 + v1 + 114564), &v34, 0x40u);
    ++*(_BYTE *)(v1 + 117764);
  }
  else
  {
    qmemcpy((void *)(v16 + v1 + 114500), &v34, 0x40u);
  }
  sub_10061F10(37.854118, "%.0f", 1.0, 9.0, -0.2, v1 + 112208);
  sub_10060FA0(*(float *)(v1 + 112228), "F", 1.0, 9.0, -0.2, 5, v1 + 112208);
  sub_10060F20(v1 + 380, 0, v1 + 112208);
  *(_DWORD *)(v1 + 117804) = 59;
  *(float *)(v1 + 112312) = *(float *)(v1 + 112312) + 15.0;
  *(float *)(v1 + 123436) = 317.0;
  *(float *)(v1 + 123440) = 315.0;
  *(float *)(v1 + 123444) = 20.0;
  *(float *)(v1 + 123448) = 20.0;
  *(_DWORD *)(v1 + 123452) = -16777216;
  sub_10042820(v1 + 117812, (int)"R FUEL QTY GAL", dword_1031FB44 + 5224, 387.0, 240.0, 125.0, 125.0);
  *(_WORD *)(v1 + 123386) = 31;
  *(_BYTE *)(v1 + 123392) = 1;
  *(_DWORD *)(v1 + 123388) = &unk_100B8DC0;
  v17 = *(float *)(v1 + 117848) - *(float *)(v1 + 117844);
  sub_10062160(v17, 0.0, -0.2, v1 + 117828);
  qmemcpy(&v34, (const void *)(v1 + 120248), 0x40u);
  v18 = sub_10062160(37.854118, 18.927059, -0.2, v1 + 117828) << 6;
  if ( *(float *)(v1 + 117848) <= 189.2706 )
  {
    qmemcpy((void *)(v18 + v1 + 120184), &v34, 0x40u);
    ++*(_BYTE *)(v1 + 123384);
  }
  else
  {
    qmemcpy((void *)(v18 + v1 + 120120), &v34, 0x40u);
  }
  sub_10061F10(37.854118, "%.0f", 1.0, 9.0, -0.2, v1 + 117828);
  sub_10060FA0(*(float *)(v1 + 117848), "F", 1.0, 9.0, -0.2, 5, v1 + 117828);
  sub_10060F20(v1 + 392, 0, v1 + 117828);
  *(_DWORD *)(v1 + 123424) = 59;
  *(float *)(v1 + 117932) = *(float *)(v1 + 117932) + 15.0;
  *(float *)(v1 + 123456) = 462.0;
  *(float *)(v1 + 123460) = 315.0;
  *(float *)(v1 + 123464) = 20.0;
  *(float *)(v1 + 123468) = 20.0;
  *(_DWORD *)(v1 + 123472) = -16777216;
  sub_10044EC0(v1 + 96044, (int)"BUS VOLTS", dword_1031FB44 + 5060, 839.0, 445.0, 75.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20676, v1 + 96044);
  sub_100445B0((int)&unk_100BC808, 2u, 0, v1 + 96044);
  sub_10042D60(v1 + 356, 2, 1, v1 + 96044);
  *(_WORD *)(v1 + 107494) = 21;
  *(_BYTE *)(v1 + 107500) = 1;
  *(_DWORD *)(v1 + 107496) = &unk_100B8DC0;
  sub_10044EC0(v1 + 72732, (int)"ALT AMPS", dword_1031FB44 + 4896, 625.0, 445.0, 75.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20648, v1 + 72732);
  sub_100445B0((int)&unk_100BC7B8, 2u, 0, v1 + 72732);
  *(_WORD *)(v1 + 84182) = 22;
  *(_BYTE *)(v1 + 84188) = 1;
  *(_DWORD *)(v1 + 84184) = &unk_100B8DC0;
  sub_10042D60(v1 + 308, 2, 1, v1 + 72732);
  sub_10044EC0(v1 + 84388, (int)"BATT AMPS", dword_1031FB44 + 7028, 732.0, 445.0, 75.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 21012, v1 + 84388);
  sub_100445B0((int)&unk_100BC7D8, 3u, 0, v1 + 84388);
  sub_10042D60(v1 + 332, 2, 1, v1 + 84388);
  *(_WORD *)(v1 + 95838) = 22;
  *(_BYTE *)(v1 + 95844) = 1;
  *(_DWORD *)(v1 + 95840) = &unk_100B8DC0;
  sub_10042820(v1 + 57000, (int)&word_100B8D60, dword_1031FB44 + 4568, 75.0, 15.0, 175.0, 175.0);
  *(float *)(v1 + 57236) = 140.0;
  *(float *)(v1 + 57240) = 240.0;
  *(float *)(v1 + 57340) = 100.0;
  *(float *)(v1 + 57048) = *(float *)(v1 + 57024) * 0.5;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4568), v1 + 57000);
  sub_10042990(dword_1031FB44 + 20592, v1 + 57000);
  sub_100429A0((int)"8L", 2, 0.0, v1 + 57000);
  sub_10060F20(v1 + 284, 1, v1 + 57016);
  *(_WORD *)(v1 + 62574) = 17;
  *(_BYTE *)(v1 + 62580) = 1;
  *(_DWORD *)(v1 + 62576) = &unk_100B8DC0;
  *(float *)(v1 + 59356) = 15.0;
  *(float *)(v1 + 59316) = *(float *)(v1 + 59316) - 30.0;
  *(float *)(v1 + 57116) = *(float *)(v1 + 57116) - 30.0;
  *(float *)(v1 + 59320) = *(float *)(v1 + 59320) + 10.0;
  *(float *)(v1 + 57120) = *(float *)(v1 + 57120) + 10.0;
  sub_10042820(v1 + 67112, (int)"PSI", dword_1031FB44 + 4732, 75.0, 15.0, 175.0, 175.0);
  *(float *)(v1 + 67348) = 40.0;
  *(float *)(v1 + 67352) = -60.0;
  *(float *)(v1 + 67452) = -100.0;
  *(float *)(v1 + 67152) = *(float *)(v1 + 67136) * 0.5 + *(float *)(v1 + 67128);
  *(float *)(v1 + 67160) = 0.5 * *(float *)(v1 + 67136);
  sub_10042980((_BYTE *)(dword_1031FB44 + 4732), v1 + 67112);
  sub_10042990(dword_1031FB44 + 20620, v1 + 67112);
  sub_100429A0((int)&unk_100BC798, 2, 0.0, v1 + 67112);
  sub_10060F20(v1 + 296, 1, v1 + 67128);
  *(_WORD *)(v1 + 72686) = 15;
  *(_BYTE *)(v1 + 72692) = 1;
  *(_DWORD *)(v1 + 72688) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 72724) = 59;
  *(float *)(v1 + 69468) = 15.0;
  *(float *)(v1 + 69428) = *(float *)(v1 + 69428) + 25.0;
  *(float *)(v1 + 67228) = *(float *)(v1 + 67228) + 25.0;
  *(float *)(v1 + 69432) = *(float *)(v1 + 69432) + 10.0;
  *(float *)(v1 + 67232) = *(float *)(v1 + 67232) + 10.0;
  v29 = 175.0;
  v27 = 175.0;
  v25 = 15.0;
  v23 = 774.0;
  v21 = dword_1031FB44 + 6044;
  if ( *(_BYTE *)(v1 + 172077) )
  {
    sub_10042820(v1 + 140256, (int)"OXY QTY", v21, v23, v25, v27, v29);
    sub_10042990(dword_1031FB44 + 20844, v1 + 140256);
    *(_WORD *)(v1 + 145830) = 14;
    *(_BYTE *)(v1 + 145836) = 1;
    *(_DWORD *)(v1 + 145832) = &unk_100B8DC0;
    *(float *)(v1 + 140492) = 165.0;
    *(float *)(v1 + 140596) = *(float *)(v1 + 140496) - 165.0;
    sub_10042980((_BYTE *)(dword_1031FB44 + 6044), v1 + 140256);
    sub_10060F20(v1 + 512, 1, v1 + 140272);
    v19 = sub_10062160(3447379.8, 689475.94, -0.2, v1 + 140272);
    sub_10061F10(3447379.8, "%.0f", 0.0099999998, 12.0, -0.2, v1 + 140272);
    *(float *)(v1 + 142612) = 15.0;
    *(float *)(v1 + 140428) = *(float *)(v1 + 140428) + 15.0;
    *(float *)(v1 + 142576) = *(float *)(v1 + 142576) + 15.0;
    strcpy((char *)(v1 + 140440), "PSI");
    sub_10060FA0(6894759.5, "x100", 1.0, 12.0, -0.60000002, v19, v1 + 140272);
    *(_BYTE *)(v1 + 145828) = v19 + 1;
    sub_10042820(v1 + 145876, (int)"OXY OUTLET", dword_1031FB44 + 6700, 829.0, 190.0, 175.0, 175.0);
    sub_10042990(dword_1031FB44 + 20956, v1 + 145876);
    *(_WORD *)(v1 + 151450) = 14;
    *(_BYTE *)(v1 + 151456) = 1;
    *(_DWORD *)(v1 + 151452) = &unk_100B8DC0;
    *(float *)(v1 + 146112) = 165.0;
    *(float *)(v1 + 146216) = *(float *)(v1 + 146116) - 165.0;
    sub_10042980((_BYTE *)(dword_1031FB44 + 6700), v1 + 145876);
    sub_10060F20(v1 + 524, 1, v1 + 145892);
    sub_10062160(*(float *)(dword_1031FB44 + 28656), *(float *)(dword_1031FB44 + 28652), -0.2, v1 + 145892);
    sub_10061F10(*(float *)(dword_1031FB44 + 28656), "%.0f", 1.0, *(float *)(dword_1031FB44 + 6748), -0.2, v1 + 145892);
    *(float *)(v1 + 148232) = 15.0;
    *(float *)(v1 + 146048) = *(float *)(v1 + 146048) + 15.0;
    *(float *)(v1 + 148196) = *(float *)(v1 + 148196) + 15.0;
    strcpy((char *)(v1 + 146060), "PSI");
    *(_BYTE *)(v1 + 148236) = 1;
  }
  else
  {
    sub_10042820(v1 + 140256, (int)byte_100B8180, v21, v23, v25, v27, v29);
    *(_BYTE *)(v1 + 142623) = 1;
    sub_10042820(v1 + 145876, (int)byte_100B8180, dword_1031FB44 + 6700, 829.0, 190.0, 175.0, 175.0);
    *(_BYTE *)(v1 + 148243) = 1;
  }
  sub_100427E0(v1 + 38308, (int)"CHT F", dword_1031FB44 + 4404, 440.0, 455.0, 140.0, 190.0);
  sub_10041F10(dword_1031FB44 + 20564, v1 + 38308);
  sub_10041F20((int)&unk_100BC5D8, 5, 0.0, v1 + 38308);
  sub_10047B10(v1 + 212, 6, 1, v1 + 38324);
  *(_WORD *)(v1 + 39288) = 17;
  *(_BYTE *)(v1 + 39296) = 1;
  *(_DWORD *)(v1 + 39292) = &unk_100B8DC0;
  *(float *)(v1 + 38428) = 440.0;
  *(float *)(v1 + 38432) = *(float *)(v1 + 39044) - 18.0;
  *(float *)(v1 + 38468) = 0.5;
  *(_BYTE *)(v1 + 39286) = -1;
  sub_1004A1A0(v1 + 155988, (int)"AILERON TRIM", dword_1031FB44 + 5716, 645.0, 605.0, 280.0, 25.0, 0);
  sub_10049310((int)&unk_100BC8C8, 2u, 0, v1 + 155988);
  sub_10049040(v1 + 536, 1, 0, v1 + 155988);
  *(_WORD *)(v1 + 160300) = 12;
  *(_BYTE *)(v1 + 160308) = 1;
  *(float *)(v1 + 156448) = *(float *)(v1 + 156000) / 18.5 * 135.0 * 0.1000000014901161;
  *(_BYTE *)(v1 + 156502) = 0;
  sub_1004A1A0(v1 + 164972, (int)"TRIM", dword_1031FB44 + 5880, 965.0, 435.0, 25.0, 200.0, 1);
  sub_10049310((int)&unk_100BC978, 2u, 0, v1 + 164972);
  sub_10049040(v1 + 548, 1, 0, v1 + 164972);
  *(_WORD *)(v1 + 169284) = 12;
  *(_BYTE *)(v1 + 169292) = 1;
  *(float *)(v1 + 165040) = *(float *)(v1 + 165040) - 15.0;
  *(float *)(v1 + 165436) = *(float *)(v1 + 164980) / 18.5 * 135.0 * 0.1000000014901161;
  *(_BYTE *)(v1 + 165486) = 0;
  sub_10046920(v1 + 169464, (int)"GAL REM", dword_1031FB44 + 6208, 612.0, 280.0, 0.0, 15.0);
  *(_WORD *)(v1 + 169980) = 31;
  *(_BYTE *)(v1 + 169988) = 1;
  *(_DWORD *)(v1 + 169984) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 169512) = v1 + 564;
  *(float *)(v1 + 169680) = 0.5;
  *(float *)(v1 + 169496) = *(float *)(v1 + 169496) + 3.0;
  *(float *)(v1 + 169524) = 0.5;
  *(float *)(v1 + 169528) = 0.0;
  sub_10046920(v1 + 170076, (int)"GAL USED", dword_1031FB44 + 6208, 612.0, 330.0, 0.0, 15.0);
  *(_WORD *)(v1 + 170592) = 31;
  *(_DWORD *)(v1 + 170596) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 170600) = 1;
  *(_DWORD *)(v1 + 170124) = v1 + 576;
  *(float *)(v1 + 170292) = 0.5;
  *(float *)(v1 + 170108) = *(float *)(v1 + 170108) + 3.0;
  *(float *)(v1 + 170136) = 0.5;
  *(float *)(v1 + 170140) = 0.0;
  *(_WORD *)(v1 + 170688) = 4142;
  *(_DWORD *)(v1 + 170692) = -1;
  *(_DWORD *)(v1 + 170696) = 0;
  *(float *)(v1 + 170700) = 15.0;
  *(float *)(v1 + 170704) = 60.0;
  *(_DWORD *)(v1 + 170708) = sub_10065060(*(float *)(v1 + 170700));
  *(float *)(v1 + 170712) = 0.5;
  *(float *)(v1 + 170716) = 0.0;
  *(_DWORD *)(v1 + 170720) = 0x7FFFFFFF;
  *(float *)(v1 + 170724) = 732.0;
  *(float *)(v1 + 170728) = 283.0;
  sub_10046920(v1 + 170812, (int)"RANGE NM", dword_1031FB44 + 6372, 732.0, 330.0, 0.0, 15.0);
  *(_WORD *)(v1 + 171328) = 38;
  *(_BYTE *)(v1 + 171336) = 1;
  *(_DWORD *)(v1 + 171332) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 170860) = v1 + 588;
  *(float *)(v1 + 171028) = 0.5;
  *(float *)(v1 + 170844) = *(float *)(v1 + 170844) + 3.0;
  *(float *)(v1 + 170872) = 0.5;
  *(float *)(v1 + 170876) = 0.0;
  sub_10046920(v1 + 171424, (int)"CO LVL HIGH PPM", dword_1031FB44 + 6864, 625.0, 675.0, 220.0, 15.0);
  *(_WORD *)(v1 + 171940) = 36;
  *(_BYTE *)(v1 + 171948) = 1;
  *(_DWORD *)(v1 + 171944) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 171472) = v1 + 628;
  if ( *(_BYTE *)dword_1031FB44 == 23 )
  {
    result = sub_10010490(a1);
    *(_BYTE *)(v1 + 149) = 0;
  }
  else
  {
    result = sub_10010300(a1);
    *(_BYTE *)(v1 + 147) = 0;
    *(_BYTE *)(v1 + 171) = 0;
  }
  return result;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10012570) --------------------------------------------------------
signed int __usercall sub_10012570@<eax>(int a1@<ebx>)
{
  int v1; // esi@1
  float v2; // ST3C_4@1
  float v3; // ST40_4@1
  float v4; // ST44_4@1
  double v5; // st5@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  memcpy((void *)(v1 + 172108), (const void *)(v1 + 172112), 0x24u);
  memcpy((void *)(v1 + 172148), (const void *)(v1 + 172152), 0x24u);
  memcpy((void *)(v1 + 172188), (const void *)(v1 + 172192), 0x24u);
  *(float *)(v1 + 172144) = *(float *)(v1 + 172096);
  *(float *)(v1 + 172184) = *(float *)(v1 + 172100);
  *(float *)(v1 + 172224) = *(float *)(v1 + 172104);
  v2 = sub_1002CC10(v1 + 172108, 10);
  *(float *)(v1 + 172228) = v2;
  v3 = sub_1002CC10(v1 + 172148, 10);
  *(float *)(v1 + 172232) = v3;
  v4 = sub_1002CC10(v1 + 172188, 10);
  *(float *)(v1 + 172236) = v4;
  v5 = 1.5 * v2;
  *(float *)(v1 + 172084) = v3 + v5;
  result = *(_WORD *)(*(_DWORD *)(a1 + 56) + 32);
  *(float *)(v1 + 172088) = (double)result - v5 + v3;
  *(float *)(v1 + 172092) = v4 + v2;
  *(float *)(v1 + 172080) = v4 + (double)*(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - v2;
  return result;
}

//----- (10012690) --------------------------------------------------------
int sub_10012690()
{
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_pop_matrix();
  return j_gdi_pvg_matrix_mode(52);
}
// 1008C150: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 1008C1B0: using guessed type int j_gdi_pvg_pop_matrix(void);

//----- (100126F0) --------------------------------------------------------
char __usercall sub_100126F0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // dl@1
  signed int v3; // eax@9
  char result; // al@11
  char v5; // [sp+Eh] [bp-Ah]@1
  char v6; // [sp+Fh] [bp-9h]@5
  int v7; // [sp+10h] [bp-8h]@9
  char v8; // [sp+14h] [bp-4h]@3

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 172240, 0);
  sub_1008D070(9, &v5);
  *(_BYTE *)(v1 + 172036) = 0;
  v2 = *(_DWORD *)(a1 + 64) == 9;
  *(_BYTE *)(v1 + 172076) = v2;
  *(_BYTE *)(v1 + 172077) = v5 == 7;
  if ( v2 )
  {
    sub_100522C0(1);
    sub_100011B0(a1, 0, 0, 1024, 686, 3);
    sub_10032790(a1, &unk_100BC260, 5u, 3, 1u);
    if ( *(_BYTE *)(v1 + 172077) )
    {
      if ( sub_10066E70(0, &v8) )
      {
        sub_10032270(a1, 0x1Au, 0);
        sub_1008CA60(10016, (int)&v6, 1);
        if ( v6 )
          sub_100324A0(a1, 0x1Au, 1);
        else
          sub_100324A0(a1, 0x1Au, 0);
      }
      else
      {
        sub_10032270(a1, 0x1Au, 1);
      }
    }
  }
  else
  {
    sub_100011B0(a1, 0, 0, 210, 686, 3);
  }
  *(float *)(v1 + 172084) = 0.0;
  v7 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 32);
  *(float *)(v1 + 172088) = (double)v7;
  *(float *)(v1 + 172092) = 0.0;
  v7 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 34);
  *(float *)(v1 + 172080) = (double)v7;
  *(float *)(v1 + 172096) = 0.0;
  *(float *)(v1 + 172100) = 0.0;
  *(float *)(v1 + 172104) = 0.0;
  *(float *)(v1 + 172228) = 0.0;
  *(float *)(v1 + 172232) = 0.0;
  *(float *)(v1 + 172236) = 0.0;
  *(float *)(v1 + 172108) = 0.0;
  *(float *)(v1 + 172148) = 0.0;
  *(float *)(v1 + 172188) = 0.0;
  *(float *)(v1 + 172112) = 0.0;
  *(float *)(v1 + 172152) = 0.0;
  *(float *)(v1 + 172192) = 0.0;
  *(float *)(v1 + 172116) = 0.0;
  *(float *)(v1 + 172156) = 0.0;
  *(float *)(v1 + 172196) = 0.0;
  *(float *)(v1 + 172120) = 0.0;
  *(float *)(v1 + 172160) = 0.0;
  *(float *)(v1 + 172200) = 0.0;
  *(float *)(v1 + 172124) = 0.0;
  *(float *)(v1 + 172164) = 0.0;
  *(float *)(v1 + 172204) = 0.0;
  *(float *)(v1 + 172128) = 0.0;
  *(float *)(v1 + 172168) = 0.0;
  *(float *)(v1 + 172208) = 0.0;
  *(float *)(v1 + 172132) = 0.0;
  *(float *)(v1 + 172172) = 0.0;
  *(float *)(v1 + 172212) = 0.0;
  *(float *)(v1 + 172136) = 0.0;
  *(float *)(v1 + 172176) = 0.0;
  *(float *)(v1 + 172216) = 0.0;
  *(float *)(v1 + 172140) = 0.0;
  *(float *)(v1 + 172180) = 0.0;
  *(float *)(v1 + 172220) = 0.0;
  *(float *)(v1 + 172144) = 0.0;
  *(float *)(v1 + 172184) = 0.0;
  *(float *)(v1 + 172224) = 0.0;
  v3 = sub_1004BF40();
  if ( v3 == 0x7FFFFFFF )
    v3 = 0;
  *(_DWORD *)(v1 + 170732) = v3;
  *(_DWORD *)(v1 + 170736) = v3;
  *(_DWORD *)(v1 + 170740) = v3;
  *(_DWORD *)(v1 + 170744) = v3;
  *(_DWORD *)(v1 + 170748) = v3;
  *(_DWORD *)(v1 + 170752) = v3;
  *(_DWORD *)(v1 + 170756) = v3;
  *(_DWORD *)(v1 + 170760) = v3;
  *(_DWORD *)(v1 + 170764) = v3;
  *(_DWORD *)(v1 + 170768) = v3;
  *(_DWORD *)(v1 + 170772) = v3;
  *(_DWORD *)(v1 + 170776) = v3;
  *(_DWORD *)(v1 + 170780) = v3;
  *(_DWORD *)(v1 + 170784) = v3;
  *(_DWORD *)(v1 + 170788) = v3;
  *(_DWORD *)(v1 + 170792) = v3;
  *(_DWORD *)(v1 + 170796) = v3;
  *(_DWORD *)(v1 + 170800) = v3;
  *(_DWORD *)(v1 + 170804) = v3;
  *(_DWORD *)(v1 + 170808) = v3;
  *(_BYTE *)(v1 + 140244) = 0;
  sub_1004CCA0(v1 + 52416, 1);
  *(_DWORD *)(v1 + 52420) = v1 + 408;
  *(_DWORD *)(v1 + 52424) = v1 + 420;
  *(_DWORD *)(v1 + 52428) = v1 + 432;
  *(_DWORD *)(v1 + 52432) = v1 + 444;
  *(_DWORD *)(v1 + 52436) = v1 + 456;
  *(_DWORD *)(v1 + 52440) = v1 + 468;
  *(_DWORD *)(v1 + 52444) = v1 + 204;
  *(_DWORD *)(v1 + 11860) = 3000;
  *(_DWORD *)(v1 + 11864) = -1;
  *(float *)(v1 + 11868) = *(float *)(dword_1031FB44 + 32);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_DWORD *)v1 = v1 + 644;
  *(_DWORD *)(v1 + 4) = v1 + 11872;
  *(_DWORD *)(v1 + 8) = v1 + 23092;
  *(_DWORD *)(v1 + 12) = v1 + 107700;
  *(_DWORD *)(v1 + 16) = v1 + 23704;
  *(_DWORD *)(v1 + 20) = v1 + 62620;
  *(_DWORD *)(v1 + 24) = v1 + 52508;
  *(_DWORD *)(v1 + 28) = v1 + 123476;
  *(_DWORD *)(v1 + 36) = v1 + 43104;
  *(_DWORD *)(v1 + 32) = v1 + 33816;
  *(_DWORD *)(v1 + 40) = v1 + 151496;
  *(_DWORD *)(v1 + 44) = v1 + 160480;
  *(_DWORD *)(v1 + 88) = v1 + 6240;
  *(_DWORD *)(v1 + 92) = v1 + 17468;
  *(_DWORD *)(v1 + 96) = v1 + 57000;
  *(_DWORD *)(v1 + 100) = v1 + 67112;
  *(_DWORD *)(v1 + 56) = v1 + 72732;
  *(_DWORD *)(v1 + 60) = v1 + 84388;
  *(_DWORD *)(v1 + 104) = v1 + 112192;
  *(_DWORD *)(v1 + 108) = v1 + 117812;
  *(_DWORD *)(v1 + 64) = v1 + 96044;
  *(_DWORD *)(v1 + 52) = v1 + 164972;
  *(_DWORD *)(v1 + 68) = v1 + 169464;
  *(_DWORD *)(v1 + 48) = v1 + 155988;
  *(_DWORD *)(v1 + 76) = v1 + 170076;
  *(_DWORD *)(v1 + 80) = v1 + 170688;
  *(_DWORD *)(v1 + 72) = v1 + 171424;
  *(_DWORD *)(v1 + 112) = v1 + 140256;
  *(_DWORD *)(v1 + 116) = v1 + 145876;
  *(_DWORD *)(v1 + 84) = v1 + 170812;
  *(_DWORD *)(v1 + 120) = v1 + 47596;
  v7 = v1 + 120;
  *(_DWORD *)(v1 + 128) = v1 + 38308;
  *(_DWORD *)(v1 + 132) = v1 + 28196;
  *(_DWORD *)(v1 + 124) = v1 + 127968;
  *(_DWORD *)(v1 + 136) = v1 + 139624;
  *(_DWORD *)(v1 + 140) = 50529027;
  *(_DWORD *)(v1 + 144) = 50529027;
  *(_DWORD *)(v1 + 148) = 50529027;
  *(_DWORD *)(v1 + 152) = 50529027;
  *(_DWORD *)(v1 + 156) = 50529027;
  *(_DWORD *)(v1 + 160) = 50529027;
  *(_DWORD *)(v1 + 164) = 50529027;
  *(_DWORD *)(v1 + 170) = 50529027;
  *(_WORD *)(v1 + 168) = 771;
  *(_BYTE *)(v1 + 174) = 0;
  sub_100106B0(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCA50, v1, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCAB8, v1 + 48, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCA3C, v1 + 112, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BC43C, v7, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 100);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10012C50) --------------------------------------------------------
int __usercall sub_10012C50@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  float v2; // ST28_4@1
  int v3; // ST10_4@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(LODWORD(v2));
  sub_1008C160(
    *(float *)(v1 + 172084),
    *(float *)(v1 + 172088),
    *(float *)(v1 + 172092),
    *(float *)(v1 + 172080),
    0.0,
    1.0);
  j_gdi_pvg_matrix_mode(52);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(v3);
  return j_gdi_pvg_viewport(
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 28),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 30),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 32),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 34));
}
// 1008C120: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 1008C150: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 1008C1D0: using guessed type int j_gdi_pvg_push_matrix(void);
// 1008C350: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10012CE0) --------------------------------------------------------
char __usercall sub_10012CE0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(float *)(v1 + 52392) = 0.0;
  *(float *)(v1 + 52396) = 0.0;
  *(float *)(v1 + 52400) = 0.0;
  *(_DWORD *)(v1 + 47688) = 0;
  *(float *)(v1 + 52404) = 0.0;
  *(_DWORD *)(v1 + 47692) = 0;
  *(float *)(v1 + 52408) = 0.0;
  *(_DWORD *)(v1 + 47696) = 0;
  *(float *)(v1 + 52412) = 0.0;
  *(_DWORD *)(v1 + 47700) = 0;
  *(_DWORD *)(v1 + 47704) = 0;
  *(_DWORD *)(v1 + 47708) = 0;
  *(float *)(v1 + 140236) = 0.0;
  *(float *)(v1 + 140248) = 0.0;
  *(_DWORD *)(v1 + 128024) = 0;
  *(float *)(v1 + 140240) = 0.0;
  *(_DWORD *)(v1 + 128028) = 0;
  *(float *)(v1 + 140252) = 0.0;
  *(_BYTE *)(v1 + 174) = 0;
  return sub_1004CCA0(v1 + 52416, 1);
}

//----- (10012D70) --------------------------------------------------------
int __usercall sub_10012D70@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edi@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (unsigned __int8)sub_10066EE0(v1 + 176, 3u, 6u);
  sub_10049040(v1 + 12 * v2 + 212, 1, 1, v1 + 33816);
  return sprintf((char *)(v1 + 34300), "%d", v2 + 1);
}

//----- (10012DD0) --------------------------------------------------------
int __usercall sub_10012DD0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@4
  float v3; // ST30_4@6
  double v4; // st7@6
  double v5; // st6@6
  float v6; // ST30_4@8
  double v7; // st6@8
  float v8; // ST34_4@12
  double v9; // st3@13
  double v10; // st4@13
  double v11; // st2@16
  double v12; // st7@18
  float v13; // ST30_4@22
  float v14; // ST34_4@23
  double v15; // st7@23
  float v16; // ST30_4@25
  double v17; // st7@25
  float v18; // ST30_4@27
  int v19; // edi@28
  float v21; // [sp+8h] [bp-8h]@6
  float v22; // [sp+8h] [bp-8h]@13
  float v23; // [sp+8h] [bp-8h]@20
  float v24; // [sp+Ch] [bp-4h]@4
  float v25; // [sp+Ch] [bp-4h]@18

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 140244) == 1 )
  {
    if ( *(_BYTE *)dword_1031FB44 == 23 )
    {
      v24 = *(float *)(v1 + 492);
      v2 = *(float *)(v1 + 140236);
      if ( v24 >= v2 )
        v2 = v24;
      v3 = v2;
      v4 = v3;
      *(float *)(v1 + 140236) = v3;
      v21 = *(float *)(v1 + 504);
      v5 = *(float *)(v1 + 140240);
      if ( v21 >= v5 )
        v5 = v21;
      v6 = v5;
      v7 = v6;
      *(float *)(v1 + 140240) = v6;
      if ( *(float *)(v1 + 492) == v4 )
        *(float *)(v1 + 140248) = *(float *)(v1 + 204);
      if ( *(float *)(v1 + 504) == v7 )
        *(float *)(v1 + 140252) = *(float *)(v1 + 204);
      v8 = *(float *)(v1 + 492) * 1.799999952316284 + 32.0 - (v4 * 1.799999952316284 + 32.0);
      if ( v8 <= 0.0 )
      {
        v22 = *(float *)(v1 + 492) * 1.799999952316284 + 32.0 - (v4 * 1.799999952316284 + 32.0);
        v9 = 0.0;
        v10 = 0.0;
      }
      else
      {
        v9 = 0.0;
        v10 = 0.0;
        v22 = 0.0;
      }
      *(float *)(v1 + 600) = v22;
      if ( v22 <= -500.0 )
      {
        v22 = -500.0;
        v11 = -500.0;
      }
      else
      {
        v11 = -500.0;
      }
      *(float *)(v1 + 600) = v22;
      v12 = v9;
      v25 = *(float *)(v1 + 504) * 1.799999952316284 + 32.0 - (1.799999952316284 * v7 + 32.0);
      if ( v25 <= v10 )
        v12 = v25;
      v23 = v12;
      *(float *)(v1 + 612) = v23;
      if ( v23 <= -500.0 )
      {
        v13 = v11;
        *(float *)(v1 + 612) = v13;
      }
      else
      {
        *(float *)(v1 + 612) = v23;
      }
    }
    else
    {
      sub_10047850(v1 + 52416, v1 + 47612);
      v14 = *(float *)(v1 + 4 * (3 * *(_BYTE *)(v1 + 52450) + 102)) * 1.799999952316284
          + 32.0
          - (1.799999952316284 * *(float *)(v1 + 4 * *(_BYTE *)(v1 + 52450) + 52460)
           + 32.0);
      v15 = v14;
      if ( v14 > 0.0 )
        v15 = 0.0;
      v16 = v15;
      v17 = v16;
      *(float *)(v1 + 600) = v16;
      if ( v16 <= -500.0 )
        v17 = -500.0;
      v18 = v17;
      *(float *)(v1 + 600) = v18;
    }
  }
  else
  {
    *(_BYTE *)(v1 + 48574) = -1;
  }
  v19 = (unsigned __int8)sub_10066EE0(v1 + 176, 0x13u, 6u);
  sub_10049040(v1 + 12 * v19 + 404, 1, 1, v1 + 43104);
  return sprintf((char *)(v1 + 43588), "%d", v19 + 1);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10013080) --------------------------------------------------------
void __cdecl sub_10013080(int a1)
{
  int v1; // edi@1
  float *v2; // eax@1
  signed int v3; // ecx@1
  unsigned int v4; // esi@3
  double v5; // st7@4
  int v6; // eax@4
  int v7; // esi@14
  float *v8; // ecx@16
  double v9; // st6@16
  float *v10; // ecx@22
  double v11; // st6@22
  int v12; // edx@34
  int v13; // ecx@34
  int v14; // eax@34
  double v15; // st7@36
  float v16; // [sp+0h] [bp-18h]@0
  char v17; // [sp+Fh] [bp-9h]@7
  float v18; // [sp+10h] [bp-8h]@5
  float v19; // [sp+14h] [bp-4h]@16

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 180);
  v3 = 39;
  do
  {
    *v2 = 9.8999998e24;
    v2 += 3;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  do
  {
    v5 = sub_1004C3E0(word_100BC322[v4]);
    v6 = (unsigned __int8)byte_100BC320[v4 * 2] + 15;
    v4 += 2;
    *(float *)(v1 + 12 * v6) = v5;
  }
  while ( v4 < 54 );
  *(float *)(v1 + 636) = sub_1004C070();
  if ( sub_10066790(0x9Bu, &v18) )
    *(float *)(v1 + 624) = v18;
  *(_BYTE *)(v1 + 158) = 0;
  if ( sub_10067000(0xBCu, &v17) && v17 == 1 )
    *(_BYTE *)(v1 + 158) = 3;
  if ( sub_100664A0(&v18) )
    *(float *)(v1 + 384) = v18;
  if ( sub_10066510(&v18) )
    *(float *)(v1 + 396) = v18;
  v7 = -16777216;
  *(_DWORD *)(v1 + 107740) = 0;
  *(_DWORD *)(v1 + 107744) = 0;
  *(_DWORD *)(v1 + 123452) = -16777216;
  *(_DWORD *)(v1 + 123472) = -16777216;
  if ( sub_10067000(0xCCu, &v17) )
  {
    if ( v17 )
    {
      v8 = (float *)(v1 + 123432);
      v19 = *(float *)(v1 + 384) - 18.92705917358398;
      v9 = v19;
      *(float *)(v1 + 123432) = v19;
      if ( v9 < 0.0 )
        *v8 = *(float *)(v1 + 384) + 18.92705917358398;
      *(_DWORD *)(v1 + 107740) = v8;
      *(_DWORD *)(v1 + 123452) = -16711681;
    }
    else
    {
      *(_DWORD *)(v1 + 107740) = 0;
      *(_DWORD *)(v1 + 123452) = -16777216;
    }
  }
  if ( sub_10067000(0xCDu, &v17) )
  {
    if ( v17 )
    {
      v10 = (float *)(v1 + 123432);
      v19 = *(float *)(v1 + 396) - 18.92705917358398;
      v11 = v19;
      *(float *)(v1 + 123432) = v19;
      if ( v11 < 0.0 )
        *v10 = *(float *)(v1 + 396) + 18.92705917358398;
      *(_DWORD *)(v1 + 107744) = v10;
      *(_DWORD *)(v1 + 123472) = -16711681;
    }
    else
    {
      *(_DWORD *)(v1 + 107744) = 0;
      *(_DWORD *)(v1 + 123472) = -16777216;
    }
  }
  if ( *(_DWORD *)(v1 + 107740) && *(_DWORD *)(v1 + 107744) )
  {
    *(_DWORD *)(v1 + 107740) = 0;
    *(_DWORD *)(v1 + 107744) = 0;
    *(_DWORD *)(v1 + 123452) = -16777216;
    *(_DWORD *)(v1 + 123472) = -16777216;
  }
  if ( sub_10067000(0xCEu, &v17) && v17 )
  {
    *(_DWORD *)(v1 + 107740) = 0;
    *(_DWORD *)(v1 + 107744) = 0;
    *(_DWORD *)(v1 + 123452) = -16777216;
    *(_DWORD *)(v1 + 123472) = -16777216;
  }
  if ( sub_100663D0(&v18) )
    *(float *)(v1 + 204) = v18;
  *(float *)(v1 + 564) = sub_1004C0C0();
  *(float *)(v1 + 576) = sub_1004C0D0(v13, v12);
  v14 = sub_1004BF40();
  *(_DWORD *)(v1 + 170720) = v14;
  if ( v14 != 0x7FFFFFFF )
  {
    v7 = 20;
    *(_DWORD *)(v1 + 170720) = sub_100296D0(v1 + 170732, 0x14u, v14);
  }
  v19 = sub_1004BFF0(v16);
  v15 = v19;
  *(float *)(v1 + 588) = v19;
  if ( 9.8999998e24 == v15 )
    *(float *)(v1 + 588) = -1.0;
  if ( sub_10066930(v7, 0x70u, &v18) )
    *(float *)(v1 + 540) = v18;
  if ( sub_10066930(v7, 0x68u, &v18) )
    *(float *)(v1 + 552) = v18;
  sub_10012D70(a1);
  sub_10012DD0(a1);
  sub_1004C380(v1 + 176, 0x27u);
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100BC322: using guessed type __int16 word_100BC322[];

//----- (100133B0) --------------------------------------------------------
_BYTE *__usercall sub_100133B0@<eax>(int a1@<eax>)
{
  int v1; // ecx@1
  int v2; // esi@1
  _BYTE *result; // eax@17
  signed int v4; // ecx@18
  int v5; // edi@22
  _BYTE *v6; // ecx@23
  char v7; // [sp+3h] [bp-5h]@1
  float v8; // [sp+4h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v8 = 0.0;
  v2 = *(_DWORD *)(v1 + 12);
  v7 = 1;
  if ( *(_BYTE *)dword_1031FB44 == 23 )
  {
    if ( *(float *)(v2 + 2624) >= (double)*(float *)(v2 + 184) )
    {
      *(_DWORD *)(v2 + 11864) = -1;
    }
    else if ( *(_DWORD *)(v2 + 11864) == -1 )
    {
      *(_DWORD *)(v2 + 11864) = sub_1008C780();
      *(_DWORD *)(v2 + 11860) = 3000;
    }
    if ( *(float *)(v2 + 11868) < (double)*(float *)(v2 + 184) )
      *(_DWORD *)(v2 + 11860) = 0;
    if ( *(_DWORD *)(v2 + 11864) != -1
      && (unsigned int)(sub_1008C780() - *(_DWORD *)(v2 + 11864)) < *(_DWORD *)(v2 + 11860) )
    {
      v8 = 1.0;
    }
  }
  if ( *(float *)(v2 + 196) >= 500.0 )
  {
    if ( 0.0 == v8 )
    {
      *(_BYTE *)(v2 + 2636) = *(_BYTE *)(dword_1031FB44 + 4007);
      *(_BYTE *)(v2 + 8248) = *(_BYTE *)(dword_1031FB44 + 4007);
    }
    else
    {
      *(_BYTE *)(v2 + 2636) = 10;
      *(_BYTE *)(v2 + 8248) = 10;
    }
    *(_BYTE *)(v2 + 62996) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v2 + 38916) = *(_BYTE *)(dword_1031FB44 + 4496);
    *(_BYTE *)(v2 + 34192) = *(_BYTE *)(dword_1031FB44 + 4496);
    *(_BYTE *)(v2 + 69096) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v2 + 96544) = *(_BYTE *)(dword_1031FB44 + 5153);
    *(_BYTE *)(v2 + 96624) = *(_BYTE *)(dword_1031FB44 + 5153);
  }
  else
  {
    *(_BYTE *)(v2 + 2636) = 10;
    *(_BYTE *)(v2 + 62996) = 10;
    *(_BYTE *)(v2 + 38916) = 10;
    *(_BYTE *)(v2 + 34192) = 10;
    *(_BYTE *)(v2 + 8248) = 10;
    *(_BYTE *)(v2 + 69096) = 10;
    *(_BYTE *)(v2 + 96544) = 10;
    *(_BYTE *)(v2 + 96624) = 10;
  }
  result = (_BYTE *)sub_1008CA60(10016, (int)&v7, 1);
  if ( v7 )
  {
    v5 = dword_1031FB44;
    result = 0;
    if ( *(_BYTE *)(dword_1031FB44 + 6700) )
    {
      v6 = (_BYTE *)(v2 + 147860);
      do
      {
        *v6 = result[v5 + 6792];
        v5 = dword_1031FB44;
        ++result;
        v6 += 8;
      }
      while ( (signed int)result < *(_BYTE *)(dword_1031FB44 + 6700) );
    }
  }
  else
  {
    v4 = 0;
    if ( *(_BYTE *)(dword_1031FB44 + 6700) )
    {
      result = (_BYTE *)(v2 + 147860);
      do
      {
        *result = 10;
        ++v4;
        result += 8;
      }
      while ( v4 < *(_BYTE *)(dword_1031FB44 + 6700) );
    }
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10013810) --------------------------------------------------------
void __usercall sub_10013810(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@1
  void *v3; // ecx@1
  float v4; // ST4C_4@3
  double v5; // st6@3
  float v6; // ST44_4@3
  float v7; // ST48_4@3
  float v8; // ST4C_4@3
  float v9; // ST50_4@3
  double v10; // st5@3
  float v11; // ST50_4@3
  double v12; // st4@3
  float v13; // ST50_4@3
  double v14; // st3@3
  float v15; // ST50_4@3
  double v16; // rt1@3
  float v17; // ST50_4@3
  double v18; // st7@3
  float *v19; // ebp@8
  char v20; // cl@17
  int v21; // [sp+8h] [bp-24h]@10
  int v22; // [sp+8h] [bp-24h]@13

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10013080(a1);
  sub_100133B0(v1);
  if ( sub_10052210(v3) == 2 && *(_BYTE *)(v2 + 172036) )
  {
    v4 = (*(float *)(v2 + 664) + *(float *)(v2 + 660)) * 0.5;
    v5 = v4;
    *(float *)(v2 + 180) = v4;
    v6 = (*(float *)(v2 + 11892) + *(float *)(v2 + 11888)) * 0.5;
    *(float *)(v2 + 192) = v6;
    v7 = (*(float *)(v2 + 52532) + *(float *)(v2 + 52528)) * 0.5;
    *(float *)(v2 + 288) = v7;
    v8 = (*(float *)(v2 + 62644) + *(float *)(v2 + 62640)) * 0.5;
    *(float *)(v2 + 300) = v8;
    v9 = (*(float *)(v2 + 72756) + *(float *)(v2 + 72752)) * 0.5;
    v10 = v9;
    *(float *)(v2 + 312) = v9;
    *(float *)(v2 + 324) = v9;
    v11 = (*(float *)(v2 + 96068) + *(float *)(v2 + 96064)) * 0.5;
    v12 = v11;
    *(float *)(v2 + 360) = v11;
    *(float *)(v2 + 372) = v11;
    v13 = (*(float *)(v2 + 47636) + *(float *)(v2 + 47632)) * 0.5;
    v14 = v13;
    *(float *)(v2 + 408) = v13;
    *(float *)(v2 + 420) = v13;
    *(float *)(v2 + 432) = v13;
    *(float *)(v2 + 444) = v13;
    *(float *)(v2 + 456) = v13;
    *(float *)(v2 + 468) = v13;
    v15 = (*(float *)(v2 + 107724) + *(float *)(v2 + 107720)) * 0.5;
    *(float *)(v2 + 384) = v15;
    *(float *)(v2 + 396) = v15;
    v16 = v15;
    v17 = 0.5 * (*(float *)(v2 + 171448) + *(float *)(v2 + 171444));
    *(float *)(v2 + 624) = v17;
    *(float *)(v2 + 184) = v5;
    *(float *)(v2 + 196) = v6;
    *(float *)(v2 + 292) = v7;
    *(float *)(v2 + 304) = v8;
    *(float *)(v2 + 316) = v10;
    *(float *)(v2 + 328) = v10;
    *(float *)(v2 + 364) = v12;
    *(float *)(v2 + 376) = v12;
    *(float *)(v2 + 412) = v14;
    *(float *)(v2 + 424) = v14;
    *(float *)(v2 + 436) = v14;
    *(float *)(v2 + 448) = v14;
    *(float *)(v2 + 460) = v14;
    *(float *)(v2 + 472) = v14;
    v18 = v17;
    *(float *)(v2 + 388) = v16;
    *(float *)(v2 + 400) = v16;
    *(float *)(v2 + 628) = *(float *)&v18;
  }
  if ( *(_BYTE *)(v2 + 172076) )
  {
    sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BC38C, (int)&unk_100BCB4C, 0, 255);
    sub_10012570(v1);
    sub_10012C50(v1);
    sub_1006BEE0((int)"TEMPERATURE", 5.0, 380.0, 600.0, 290.0);
    sub_1006BEE0((int)"ELECTRICAL", 620.0, 380.0, 300.0, 175.0);
    sub_10068CB0(620.0, 570.0, 0.0, -1);
    sub_10068CB0(935.0, 569.0, COERCE_FLOAT(2), -1);
    sub_10068CB0(936.0, 380.0, 0.0, -1);
    sub_10068CB0(1015.0, 380.0, COERCE_FLOAT(1), -1);
    sub_10068CB0(1015.0, 645.0, COERCE_FLOAT(2), -1);
    sub_10068CB0(620.0, 645.0, COERCE_FLOAT(3), -1);
    j_gdi_pvg_color_u32(-1);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(630.0, 570.0);
    sub_1008C2F0(925.0, 570.0);
    sub_1008C2F0(935.5, 390.0);
    sub_1008C2F0(935.5, 559.0);
    sub_1008C2F0(946.0, 380.0);
    sub_1008C2F0(1005.0, 380.0);
    sub_1008C2F0(1015.5, 390.0);
    sub_1008C2F0(1015.5, 635.0);
    sub_1008C2F0(630.0, 645.5);
    sub_1008C2F0(1005.0, 645.5);
    sub_1008C2F0(620.0, 580.5);
    sub_1008C2F0(620.0, 635.0);
    j_gdi_pvg_end();
    if ( *(_BYTE *)(v2 + 140244) != 1 || 85.0 != *(float *)(v2 + 172228) )
    {
      sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BCAB8, v2 + 48, v2 + 152, 255);
      sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BCA3C, v2 + 112, v2 + 168, 255);
      sub_100680A0(v2 + 123436);
      sub_100680A0(v2 + 123456);
      sub_1006BEE0((int)"FUEL CALC", 552.0, 250.0, 240.0, 110.0);
    }
    sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BC43C, v2 + 120, v2 + 170, 255);
    v19 = (float *)(v2 + 172040);
    *(float *)(v2 + 172040) = 162.5;
    *(float *)(v2 + 172044) = 127.5;
    sub_10065670((int)"OIL", v2 + 172040);
    *(float *)(v2 + 172040) = 732.0;
    *(float *)(v2 + 172044) = 280.0;
    *(float *)(v2 + 172064) = 0.5;
    sub_10065670((int)"ENDUR", v2 + 172040);
    if ( *(_BYTE *)(v2 + 140244) == 1 && *(_BYTE *)dword_1031FB44 == 23 )
    {
      v21 = v2 + 172040;
      *v19 = 235.0;
      *(float *)(v2 + 172044) = 669.0;
      *(float *)(v2 + 172064) = 0.0;
      if ( *(float *)(v2 + 140248) <= (double)*(float *)(v2 + 204) )
        sub_10065670((int)"RICH", v21);
      else
        sub_10065670((int)"LEAN", v21);
      *v19 = 355.0;
      v22 = v2 + 172040;
      *(float *)(v2 + 172064) = 1.0;
      if ( *(float *)(v2 + 140252) <= (double)*(float *)(v2 + 204) )
        sub_10065670((int)"RICH", v22);
      else
        sub_10065670((int)"LEAN", v22);
    }
    *v19 = *(float *)(v2 + 165036);
    *(float *)(v2 + 172044) = *(float *)(v2 + 165040) - 16.0;
    *(float *)(v2 + 172064) = 0.5;
    sub_10065670((int)"ELEV", v2 + 172040);
    sub_10012690();
  }
  v20 = *(_BYTE *)(v2 + 172076);
  if ( !v20 )
    goto LABEL_21;
  if ( *(_BYTE *)(v2 + 140244) == 1 && 85.0 == *(float *)(v2 + 172228) )
  {
    if ( v20 )
    {
LABEL_22:
      sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BC998, (int)&unk_100BCB44, 0, 255);
      j_gdi_pvg_color_u32(-1);
      sub_1008C110(1.0);
      j_gdi_pvg_begin(67);
      sub_1008C2F0(151.0, 469.0);
      sub_1008C2F0(209.0, 469.0);
      sub_1008C2F0(209.0, 686.0);
      j_gdi_pvg_end();
      sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BCA50, v2, v2 + 140, 255);
      *(float *)(v2 + 172040) = *(float *)(v2 + 160544);
      *(float *)(v2 + 172044) = *(float *)(v2 + 160548) - 16.0;
      sub_10065670((int)"ELEV", v2 + 172040);
      goto LABEL_23;
    }
LABEL_21:
    sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BC30C, (int)&unk_100BCB3C, 0, 255);
    goto LABEL_22;
  }
LABEL_23:
  *(_BYTE *)(v1 + 6) = 2;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10013FC0) --------------------------------------------------------
void __cdecl sub_10013FC0(int a1)
{
  int v1; // esi@9
  int v2; // ebx@18
  int v3; // eax@24
  float *v4; // esi@24
  int v5; // edi@25

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      if ( !*(_BYTE *)(v1 + 172076) )
        goto LABEL_33;
      sub_10012C50(a1);
      if ( *(_BYTE *)(v1 + 140244) != 1 || 85.0 != *(float *)(v1 + 172228) )
      {
        sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCAB8, v1 + 48, v1 + 152, 255);
        sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCA3C, v1 + 112, v1 + 168, 255);
      }
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BC43C, v1 + 120, v1 + 170, 255);
      sub_10012690();
      if ( !*(_BYTE *)(v1 + 172076) || *(_BYTE *)(v1 + 140244) == 1 && 85.0 == *(float *)(v1 + 172228) )
LABEL_33:
        sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BCA50, v1, v1 + 140, 255);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8018:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 172076) )
        sub_100522C0(0);
      break;
    case 0x8041:
      sub_100126F0(a1);
      break;
    default:
      return;
    case 0x8022:
    case 0x8078:
      sub_10013810(a1);
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 172036) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 172036) = 0;
      break;
    case 0x806E:
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      switch ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) )
      {
        case 0x40:
          if ( sub_10032250(a1, 0x40u) == 1 )
          {
            *(_BYTE *)(v2 + 52387) = 1;
            *(_BYTE *)(v2 + 43099) = 1;
          }
          else
          {
            *(_BYTE *)(v2 + 52387) = 0;
            *(_BYTE *)(v2 + 43099) = 0;
          }
          break;
        case 0x41:
          sub_10012CE0(a1);
          if ( *(_BYTE *)(v2 + 140244) == 1 )
          {
            v3 = 0;
            *(_BYTE *)(v2 + 140244) = 0;
            v4 = (float *)(v2 + 47816);
            do
            {
              v5 = v3 + 1;
              sprintf((char *)v4 - 32, "%d", v3 + 1);
              *v4 = 9.0;
              v3 = v5;
              v4 += 13;
            }
            while ( v5 < 6 );
            *(float *)(v2 + 172096) = 0.0;
            *(float *)(v2 + 172100) = 0.0;
            *(float *)(v2 + 172104) = 0.0;
          }
          else
          {
            *(_BYTE *)(v2 + 140244) = 1;
            *(float *)(v2 + 172096) = 85.0;
            *(float *)(v2 + 172100) = -285.0;
            *(_DWORD *)(v2 + 128024) = v2 + 140236;
            *(_DWORD *)(v2 + 128028) = v2 + 140240;
            *(float *)(v2 + 172104) = 100.0;
            *(_BYTE *)(v2 + 174) = 3;
          }
          break;
        case 0x42:
          sub_1004C220();
          sub_1004C0E0();
          break;
        case 0x43:
          sub_1004C2B0();
          sub_1004C0E0();
          break;
        case 0x44:
          sub_1004C0E0();
          JUMPOUT(&loc_1004C350);
          return;
        default:
          return;
      }
      return;
  }
}

//----- (10014090) --------------------------------------------------------
void __usercall sub_10014090(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@3
  float v3; // ST54_4@8
  double v4; // st7@8
  float v5; // ST54_4@8
  float v6; // ST34_4@8
  float v7; // ST54_4@8
  float v8; // ST54_4@8
  signed int v9; // ebx@8
  float v10; // ST58_4@8
  float v11; // ST58_4@8
  float v12; // ST58_4@10
  float v13; // ST58_4@10
  int v14; // ebx@10
  float v15; // ST58_4@10
  float v16; // ST58_4@10
  float v17; // ST58_4@10
  float v18; // ST58_4@10
  float v19; // ST58_4@10
  double v20; // st7@10
  float v21; // ST58_4@10
  float v22; // ST34_4@10
  float v23; // ST58_4@10
  float v24; // ST58_4@10
  float v25; // ST58_4@10
  float v26; // ST58_4@10
  float v27; // ST58_4@10
  float v28; // ST58_4@10
  float v29; // ST58_4@10
  float v30; // [sp+20h] [bp-10h]@3
  float v31; // [sp+24h] [bp-Ch]@8
  signed int v32; // [sp+28h] [bp-8h]@8

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 11768) )
  {
    if ( *(_BYTE *)(v1 + 45080) )
    {
      v30 = 49.0;
      v2 = *(float *)(v1 + 17396) + 160.0;
    }
    else
    {
      v30 = 56.0;
      v2 = *(float *)(v1 + 17396) + 170.0;
    }
  }
  else if ( *(_BYTE *)(v1 + 45080) )
  {
    v30 = 65.0;
    v2 = *(float *)(v1 + 17396) + 170.0;
  }
  else
  {
    v30 = 70.0;
    v2 = *(float *)(v1 + 17396) + 175.0;
  }
  v31 = v2;
  v3 = v30 * 0.0 + v31;
  sub_1004A1A0(v1 + 28632, (int)"FUEL FLOW GPH", dword_1031FB44 + 4568, 10.0, v3, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 28632);
  *(_WORD *)(v1 + 32944) = 33;
  sub_10049040(v1 + 264, 1, 0, v1 + 28632);
  sub_10049090(0, v1 + 28632);
  v4 = *(float *)(v1 + 28656) - *(float *)(v1 + 28652);
  v5 = 0.1000000014901161 * v4;
  v6 = v5;
  v7 = v4;
  sub_1004A660(v7, v6, -0.80000001, v1 + 28632);
  v8 = *(float *)(v1 + 28656) - *(float *)(v1 + 28652);
  sub_100488B0(v8, "%.0f", 1.0, 9.0, v1 + 28632);
  v9 = 1;
  v32 = 1;
  v10 = v30 + v31;
  sub_1004A1A0(v1 + 39976, (int)"FUEL PRES", dword_1031FB44 + 4732, 10.0, v10, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20620, v1 + 39976);
  *(_WORD *)(v1 + 44288) = 15;
  sub_10049040(v1 + 276, 1, 0, v1 + 39976);
  sub_10049090(0, v1 + 39976);
  v11 = *(float *)(v1 + 40000) - *(float *)(v1 + 39996);
  sub_1004A660(v11, 0.0, -0.80000001, v1 + 39976);
  if ( *(_BYTE *)(v1 + 45080) )
  {
    v9 = 2;
    v32 = 2;
  }
  v12 = (double)v32 * v30 + v31;
  sub_1004A1A0(v1 + 49880, (int)"CHT", dword_1031FB44 + 4240, 10.0, v12, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 49880);
  sub_10049040(v1 + 288, 1, 0, v1 + 49880);
  sub_10049090(0, v1 + 49880);
  *(_WORD *)(v1 + 54192) = 17;
  v13 = *(float *)(v1 + 49904) - *(float *)(v1 + 49900);
  sub_1004A660(v13, 0.0, -0.80000001, v1 + 49880);
  v14 = v9 + 1;
  v15 = (double)v14 * v30 + v31;
  sub_1004A1A0(v1 + 68604, (int)"OIL TEMP", dword_1031FB44 + 5388, 10.0, v15, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20732, v1 + 68604);
  sub_10049040(v1 + 336, 1, 0, v1 + 68604);
  sub_10049090(0, v1 + 68604);
  *(_WORD *)(v1 + 72916) = 17;
  v16 = *(float *)(v1 + 68628) - *(float *)(v1 + 68624);
  sub_1004A660(v16, 0.0, -0.80000001, v1 + 68604);
  v17 = (double)++v14 * v30 + v31;
  sub_1004A1A0(v1 + 79328, (int)"OIL PRES", dword_1031FB44 + 5224, 10.0, v17, 130.0, 18.0, 0);
  sub_10049040(v1 + 348, 1, 0, v1 + 79328);
  sub_10049090(0, v1 + 79328);
  *(_WORD *)(v1 + 83640) = 15;
  v18 = *(float *)(v1 + 79352) - *(float *)(v1 + 79348);
  sub_1004A660(v18, 0.0, -0.80000001, v1 + 79328);
  v19 = (double)++v14 * v30 + v31;
  sub_1004A1A0(v1 + 88924, (int)"AMPS", dword_1031FB44 + 3912, 10.0, v19, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20480, v1 + 88924);
  sub_10049040(v1 + 360, 1, 0, v1 + 88924);
  sub_10049090(0, v1 + 88924);
  v20 = *(float *)(v1 + 88948) - *(float *)(v1 + 88944);
  *(_WORD *)(v1 + 93236) = 23;
  v21 = 0.5 * v20;
  v22 = v21;
  v23 = v20;
  sub_1004A660(v23, v22, -0.80000001, v1 + 88924);
  v24 = *(float *)(v1 + 88948) - *(float *)(v1 + 88944);
  sub_100488B0(v24, "%.0f", 1.0, 9.0, v1 + 88924);
  v25 = (double)(v14 + 1) * v30 + v31;
  sub_1004A1A0(v1 + 98528, (int)"VOLTS", dword_1031FB44 + 5880, 10.0, v25, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20816, v1 + 98528);
  sub_10049040(v1 + 372, 1, 0, v1 + 98528);
  sub_10049090(0, v1 + 98528);
  *(_WORD *)(v1 + 102840) = 20;
  v26 = *(float *)(v1 + 98552) - *(float *)(v1 + 98548);
  sub_1004A660(v26, 0.0, -0.80000001, v1 + 98528);
  v27 = (double)(v14 + 2) * v30 + v31;
  sub_1004A1E0(v1 + 114872, (int)"FUEL QTY GAL", dword_1031FB44 + 5716, 10.0, v27, 130.0, 37.0, 0);
  *(_WORD *)(v1 + 119184) = 31;
  sub_10049040(v1 + 384, 2, 0, v1 + 114872);
  sub_10049090(0, v1 + 114872);
  v28 = *(float *)(v1 + 114896) - *(float *)(v1 + 114892);
  sub_1004A630(v28, 18.927059, -0.40000001, v1 + 114872);
  v29 = *(float *)(v1 + 114896) - *(float *)(v1 + 114892);
  sub_100488B0(v29, "%.0f", 1.0, 9.0, v1 + 114872);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10014810) --------------------------------------------------------
signed int __usercall sub_10014810@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  float v3; // ST4C_4@1
  double v4; // st7@4
  float v5; // ST4C_4@4
  float v6; // ST4C_4@5
  double v7; // st7@5
  float v8; // ST4C_4@6
  float v9; // ST4C_4@7
  double v10; // st7@8
  float v11; // ST4C_4@8
  double v12; // st7@8
  float v13; // ST4C_4@9
  const char *v14; // eax@10
  float v15; // ST4C_4@13
  double v16; // st7@13
  float v17; // ST4C_4@13
  float v18; // ST34_4@13
  float v19; // ST4C_4@13
  float v20; // ST4C_4@13
  double v21; // st7@14
  float v22; // ST4C_4@14
  float v23; // ST34_4@14
  float v24; // ST4C_4@14
  float v25; // ST4C_4@14
  float v26; // ST4C_4@14
  double v27; // st7@15
  float v28; // ST4C_4@15
  float v29; // ST4C_4@15
  int v30; // ST3C_4@15
  float v31; // ST4C_4@15
  int v32; // ST3C_4@15
  float v33; // ST4C_4@15
  double v34; // st7@15
  float v35; // ST4C_4@15
  float v36; // ST34_4@15
  float v37; // ST4C_4@15
  float v38; // ST4C_4@15
  float v39; // ST4C_4@15
  signed int result; // eax@15
  float v41; // [sp+Ch] [bp-20h]@7
  float v42; // [sp+10h] [bp-1Ch]@7
  float v43; // [sp+14h] [bp-18h]@1
  float v44; // [sp+14h] [bp-18h]@4
  float v45; // [sp+14h] [bp-18h]@7
  float v46; // [sp+18h] [bp-14h]@1
  float v47; // [sp+18h] [bp-14h]@4
  float v48; // [sp+18h] [bp-14h]@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10042820(v1 + 528, (int)"MAN IN HG", dword_1031FB44 + 5060, 10.0, 10.0, 225.0, 225.0);
  sub_10042990(dword_1031FB44 + 20676, v1 + 528);
  *(_WORD *)(v1 + 6102) = 5;
  sub_10062160(16931.934, 3386.3867, -0.2, v1 + 544);
  sub_10061F10(16931.934, "%.0f", 1.0, 12.0, -0.2, v1 + 544);
  sub_10060F20(v1 + 240, 1, v1 + 544);
  v2 = *(_BYTE *)(v1 + 11768) == 0;
  v3 = *(float *)(v1 + 540) * 0.800000011920929 + *(float *)(v1 + 532);
  *(float *)(v1 + 2848) = v3;
  *(float *)(v1 + 648) = v3 - 6.0;
  v46 = 225.0;
  v43 = 225.0;
  if ( v2 )
    sub_10042820(v1 + 11772, (int)"RPM", dword_1031FB44 + 5552, 10.0, 10.0, v43, v46);
  else
    sub_10042820(v1 + 11772, (int)"RPM", dword_1031FB44 + 5552, 255.0, 10.0, v43, v46);
  sub_10042990(dword_1031FB44 + 20760, v1 + 11772);
  *(_WORD *)(v1 + 17346) = 6;
  sub_10062160(500.0, 100.0, -0.2, v1 + 11788);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 12.0, -0.2, v1 + 11788);
  sub_10060F20(v1 + 252, 1, v1 + 11788);
  sub_10060FA0(1500.0, "x100", 1.0, 12.0, -0.60000002, *(_BYTE *)(v1 + 17344), v1 + 11788);
  v4 = *(float *)(v1 + 11784) * 0.800000011920929;
  ++*(_BYTE *)(v1 + 17344);
  v2 = *(_BYTE *)(v1 + 11768) == 0;
  v5 = v4 + *(float *)(v1 + 11776);
  *(float *)(v1 + 14092) = v5;
  *(float *)(v1 + 11892) = v5 - 6.0;
  v47 = 225.0;
  v44 = 225.0;
  if ( v2 )
  {
    sub_10042820(v1 + 62984, (int)"OIL F", dword_1031FB44 + 5388, 255.0, 10.0, v44, v47);
    v8 = *(float *)(v1 + 62996) * 0.800000011920929 + *(float *)(v1 + 62988);
    *(float *)(v1 + 65304) = v8;
    v7 = v8 - 6.0;
  }
  else
  {
    sub_10042820(v1 + 62984, (int)&word_100B8D60, dword_1031FB44 + 5388, 10.0, 255.0, v44, v47);
    *(float *)(v1 + 63220) = 140.0;
    *(float *)(v1 + 63224) = 240.0;
    *(float *)(v1 + 63324) = 100.0;
    *(float *)(v1 + 63032) = *(float *)(v1 + 63008) * 0.4000000059604645;
    sub_10042980((_BYTE *)(dword_1031FB44 + 5388), v1 + 62984);
    *(float *)(v1 + 65340) = 18.0;
    v6 = *(float *)(v1 + 62992) * 0.3499999940395355 + *(float *)(v1 + 62984);
    *(float *)(v1 + 65300) = v6;
    *(float *)(v1 + 65332) = 0.5;
    *(float *)(v1 + 63140) = 0.5;
    *(float *)(v1 + 63100) = v6;
    *(float *)(v1 + 65304) = *(float *)(v1 + 62996) * 0.75 + *(float *)(v1 + 62988);
    v7 = *(float *)(v1 + 62996) * 0.6000000238418579 + *(float *)(v1 + 62988);
  }
  *(float *)(v1 + 63104) = v7;
  sub_10042990(dword_1031FB44 + 20732, v1 + 62984);
  sub_10060F20(v1 + 336, 1, v1 + 63000);
  *(_WORD *)(v1 + 68558) = 17;
  v9 = *(float *)(v1 + 63020) - *(float *)(v1 + 63016);
  sub_10062160(v9, 0.0, -0.2, v1 + 63000);
  v48 = 225.0;
  v45 = 225.0;
  v42 = 255.0;
  v41 = 10.0;
  if ( *(_BYTE *)(v1 + 11768) )
  {
    sub_10042820(v1 + 73708, (int)"PSI", dword_1031FB44 + 5224, v41, v42, v45, v48);
    *(float *)(v1 + 73944) = 40.0;
    *(float *)(v1 + 73948) = -60.0;
    *(float *)(v1 + 74048) = -100.0;
    *(float *)(v1 + 73748) = *(float *)(v1 + 73732) * 0.6000000238418579 + *(float *)(v1 + 73724);
    *(float *)(v1 + 73756) = *(float *)(v1 + 73732) * 0.4000000059604645;
    sub_10042980((_BYTE *)(dword_1031FB44 + 5224), v1 + 73708);
    *(float *)(v1 + 76064) = 18.0;
    v10 = *(float *)(v1 + 73716);
    *(_DWORD *)(v1 + 79320) = 59;
    v11 = v10 * 0.6499999761581421 + *(float *)(v1 + 73708);
    *(float *)(v1 + 76024) = v11;
    *(float *)(v1 + 76056) = 0.5;
    *(float *)(v1 + 73864) = 0.5;
    *(float *)(v1 + 73824) = v11;
    *(float *)(v1 + 76028) = *(float *)(v1 + 73720) * 0.75 + *(float *)(v1 + 73712);
    v12 = *(float *)(v1 + 73720) * 0.6000000238418579 + *(float *)(v1 + 73712);
  }
  else
  {
    sub_10042820(v1 + 73708, (int)"OIL PSI", dword_1031FB44 + 5224, v41, v42, v45, v48);
    v13 = *(float *)(v1 + 73720) * 0.800000011920929 + *(float *)(v1 + 73712);
    *(float *)(v1 + 76028) = v13;
    v12 = v13 - 6.0;
  }
  *(float *)(v1 + 73828) = v12;
  sub_10042990(dword_1031FB44 + 20704, v1 + 73708);
  sub_10060F20(v1 + 348, 1, v1 + 73724);
  *(_WORD *)(v1 + 79282) = 15;
  sub_10062160(999740.12, 0.0, -0.2, v1 + 73724);
  v14 = (const char *)&unk_100BCE04;
  if ( !*(_BYTE *)(v1 + 45080) )
    v14 = "FUEL FLOW GPH";
  sub_10042820(v1 + 23012, (int)v14, dword_1031FB44 + 4568, 255.0, 255.0, 225.0, 225.0);
  sub_10042990(dword_1031FB44 + 20592, v1 + 23012);
  *(_WORD *)(v1 + 28586) = 33;
  sub_10060F20(v1 + 264, 1, v1 + 23028);
  if ( *(_BYTE *)(v1 + 45080) )
  {
    *(float *)(v1 + 23248) = 140.0;
    *(float *)(v1 + 23252) = 240.0;
    *(float *)(v1 + 23352) = 100.0;
    *(float *)(v1 + 23060) = *(float *)(v1 + 23036) * 0.4000000059604645;
    sub_10042980((_BYTE *)(dword_1031FB44 + 4568), v1 + 23012);
    *(float *)(v1 + 25368) = 18.0;
    v15 = *(float *)(v1 + 23020) * 0.3499999940395355 + *(float *)(v1 + 23012);
    *(float *)(v1 + 25328) = v15;
    *(float *)(v1 + 25360) = 0.5;
    *(float *)(v1 + 23168) = 0.5;
    *(float *)(v1 + 23128) = v15;
    *(float *)(v1 + 25332) = *(float *)(v1 + 23024) * 0.75 + *(float *)(v1 + 23016);
    *(float *)(v1 + 23132) = *(float *)(v1 + 23024) * 0.6000000238418579 + *(float *)(v1 + 23016);
    v16 = *(float *)(v1 + 23048) - *(float *)(v1 + 23044);
    v17 = 0.1000000014901161 * v16;
    v18 = v17;
    v19 = v16 * 0.2000000029802322;
    sub_10062160(v19, v18, -0.2, v1 + 23028);
    v20 = *(float *)(v1 + 23048) - *(float *)(v1 + 23044);
    sub_10061F10(v20, "%.0f", 1.0, 12.0, -0.2, v1 + 23028);
  }
  else
  {
    v21 = *(float *)(v1 + 23048) - *(float *)(v1 + 23044);
    v22 = 0.1000000014901161 * v21;
    v23 = v22;
    v24 = v21 * 0.2000000029802322;
    sub_10062160(v24, v23, -0.2, v1 + 23028);
    v25 = (*(float *)(v1 + 23048) - *(float *)(v1 + 23044)) * 0.2000000029802322;
    sub_10061F10(v25, "%.0f", 1.0, 12.0, -0.2, v1 + 23028);
    v26 = *(float *)(v1 + 23024) * 0.800000011920929 + *(float *)(v1 + 23016);
    *(float *)(v1 + 25332) = v26;
    *(float *)(v1 + 23132) = v26 - 6.0;
  }
  sub_10042820(v1 + 34356, (int)"PSI", dword_1031FB44 + 4732, 255.0, 255.0, 225.0, 225.0);
  *(float *)(v1 + 34592) = 40.0;
  *(float *)(v1 + 34596) = -60.0;
  *(float *)(v1 + 34696) = -100.0;
  *(float *)(v1 + 34396) = *(float *)(v1 + 34380) * 0.6000000238418579 + *(float *)(v1 + 34372);
  *(float *)(v1 + 34404) = *(float *)(v1 + 34380) * 0.4000000059604645;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4732), v1 + 34356);
  *(float *)(v1 + 36712) = 18.0;
  v27 = *(float *)(v1 + 34364) * 0.6499999761581421;
  *(_DWORD *)(v1 + 39968) = 59;
  v28 = v27 + *(float *)(v1 + 34356);
  *(float *)(v1 + 36672) = v28;
  *(float *)(v1 + 36704) = 0.5;
  *(float *)(v1 + 34512) = 0.5;
  *(float *)(v1 + 34472) = v28;
  *(float *)(v1 + 36676) = *(float *)(v1 + 34368) * 0.75 + *(float *)(v1 + 34360);
  *(float *)(v1 + 34476) = *(float *)(v1 + 34368) * 0.6000000238418579 + *(float *)(v1 + 34360);
  sub_10060F20(v1 + 276, 1, v1 + 34372);
  sub_10042990(dword_1031FB44 + 20620, v1 + 34356);
  *(_WORD *)(v1 + 39930) = 15;
  v29 = *(float *)(v1 + 34392) - *(float *)(v1 + 34388);
  sub_10062160(v29, 0.0, -0.2, v1 + 34372);
  sub_10042820(v1 + 103632, (int)"L FUEL QTY", dword_1031FB44 + 5716, 32.0, 500.0, 180.0, 180.0);
  *(float *)(v1 + 103752) = *(float *)(v1 + 103752) + 15.0;
  *(_WORD *)(v1 + 109206) = 31;
  sub_100649E0(v1 + 103816, "GAL", 21);
  *(float *)(v1 + 103804) = *(float *)(v1 + 103804) + 30.0;
  sub_10060F20(v1 + 384, 0, v1 + 103648);
  sub_10062160(18.927059, 0.0, -0.2, v1 + 103648);
  sub_10061F10(18.927059, "%.0f", 1.0, 12.0, -0.2, v1 + 103648);
  sub_10042820(v1 + 109252, (int)"R FUEL QTY", dword_1031FB44 + 5716, 277.0, 500.0, 180.0, 180.0);
  *(_WORD *)(v1 + 114826) = 31;
  *(float *)(v1 + 109372) = *(float *)(v1 + 109372) + 15.0;
  sub_100649E0(v1 + 109436, "GAL", 21);
  *(float *)(v1 + 109424) = *(float *)(v1 + 109424) + 30.0;
  sub_10060F20(v1 + 396, 0, v1 + 109268);
  sub_10062160(18.927059, 0.0, -0.2, v1 + 109268);
  sub_10061F10(18.927059, "%.0f", 1.0, 12.0, -0.2, v1 + 109268);
  v30 = *(_BYTE *)(v1 + 125840);
  v31 = (double)v30 * 0.25 * 175.0;
  sub_10042310(v1 + 45084, (int)"CHT F", dword_1031FB44 + 4240, 570.0, 434.0, v31, 214.0, v30);
  sub_10041F10(dword_1031FB44 + 20536, v1 + 45084);
  sub_10047B10(v1 + 288, *(_BYTE *)(v1 + 125840), 1, v1 + 45100);
  *(_WORD *)(v1 + 46064) = 17;
  *(_BYTE *)(v1 + 46062) = -1;
  *(float *)(v1 + 45208) = 414.0;
  *(float *)(v1 + 45204) = 570.0;
  *(float *)(v1 + 45244) = 1.0;
  *(float *)(v1 + 45248) = 1.0;
  sub_10041CA0(55.555557, 27.777779, 0.80000001, v1 + 45084);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 45084);
  v32 = *(_BYTE *)(v1 + 125840);
  v33 = (double)v32 * 0.25 * 175.0;
  sub_10042310(v1 + 55620, (int)"EGT F", dword_1031FB44 + 4404, 570.0, 80.0, v33, 214.0, v32);
  sub_10041F10(dword_1031FB44 + 20564, v1 + 55620);
  sub_10047B10(v1 + 408, *(_BYTE *)(v1 + 125840), 1, v1 + 55636);
  *(_WORD *)(v1 + 56600) = 17;
  *(_BYTE *)(v1 + 56598) = -1;
  *(float *)(v1 + 55744) = 60.0;
  *(float *)(v1 + 55740) = 570.0;
  *(float *)(v1 + 55780) = 1.0;
  *(float *)(v1 + 55784) = 1.0;
  sub_10041CA0(55.555557, 27.777779, 0.80000001, v1 + 55620);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 55620);
  sub_10046920(v1 + 61756, (int)" PEAK", dword_1031FB44 + 6372, 605.0, 344.0, 105.0, 15.0);
  sub_100465F0(v1 + 492, 1, v1 + 61756);
  *(_WORD *)(v1 + 62272) = 10;
  sub_1004A1A0(v1 + 84432, (int)"AMPS", dword_1031FB44 + 3912, 815.0, 80.0, 180.0, 25.0, 0);
  sub_100490F0(dword_1031FB44 + 20480, v1 + 84432);
  sub_10049040(v1 + 360, 1, 1, v1 + 84432);
  sub_10049090(0, v1 + 84432);
  *(float *)(v1 + 84892) = 20.0;
  *(_WORD *)(v1 + 88744) = 23;
  v34 = *(float *)(v1 + 84456) - *(float *)(v1 + 84452);
  v35 = 0.5 * v34;
  v36 = v35;
  v37 = v34;
  sub_1004A660(v37, v36, -0.80000001, v1 + 84432);
  v38 = *(float *)(v1 + 84456) - *(float *)(v1 + 84452);
  sub_100488B0(v38, "%.0f", 1.0, 12.0, v1 + 84432);
  *(float *)(v1 + 88504) = 0.5;
  *(float *)(v1 + 88472) = *(float *)(v1 + 84496);
  *(float *)(v1 + 88476) = *(float *)(v1 + 84500);
  *(float *)(v1 + 84500) = *(float *)(v1 + 84500) - 20.0;
  sub_1004A1A0(v1 + 94036, (int)"VOLTS", dword_1031FB44 + 5880, 815.0, 185.0, 180.0, 25.0, 0);
  sub_100490F0(dword_1031FB44 + 20816, v1 + 94036);
  sub_10049040(v1 + 372, 1, 1, v1 + 94036);
  sub_10049090(0, v1 + 94036);
  *(float *)(v1 + 94496) = 20.0;
  *(_WORD *)(v1 + 98348) = 21;
  v39 = *(float *)(v1 + 94060) - *(float *)(v1 + 94056);
  sub_1004A660(v39, 0.0, -0.80000001, v1 + 94036);
  *(float *)(v1 + 98108) = 0.5;
  *(float *)(v1 + 98076) = *(float *)(v1 + 94100);
  *(float *)(v1 + 98080) = *(float *)(v1 + 94104);
  *(float *)(v1 + 94104) = *(float *)(v1 + 94104) - 20.0;
  sub_10046920(v1 + 119364, (int)"GALLONS REMAIN", dword_1031FB44 + 6044, 805.0, 485.0, 200.0, 15.0);
  *(_WORD *)(v1 + 119880) = 31;
  *(_DWORD *)(v1 + 119412) = v1 + 460;
  sub_10046920(v1 + 120588, (int)"GALLONS USED", dword_1031FB44 + 6044, 805.0, 515.0, 200.0, 15.0);
  *(_WORD *)(v1 + 121104) = 31;
  *(_DWORD *)(v1 + 120636) = v1 + 472;
  *(_WORD *)(v1 + 121812) = 4142;
  *(_DWORD *)(v1 + 121816) = -1;
  *(_DWORD *)(v1 + 121820) = 0;
  *(float *)(v1 + 121824) = 15.0;
  *(float *)(v1 + 121828) = 60.0;
  *(_DWORD *)(v1 + 121832) = sub_10065060(*(float *)(v1 + 121824));
  *(float *)(v1 + 121836) = 1.0;
  *(float *)(v1 + 121840) = 1.0;
  *(_DWORD *)(v1 + 121844) = 0x7FFFFFFF;
  *(float *)(v1 + 121848) = 1005.0;
  *(float *)(v1 + 121852) = 545.0;
  sub_10046920(v1 + 121980, (int)"RANGE NM", dword_1031FB44 + 6208, 805.0, 575.0, 200.0, 15.0);
  sub_100465F0(v1 + 480, 1, v1 + 121980);
  *(_WORD *)(v1 + 122496) = 38;
  sub_10046920(v1 + 124440, (int)byte_100B8180, dword_1031FB44 + 6208, 805.0, 655.0, 140.0, 15.0);
  sub_100465F0(v1 + 504, 1, v1 + 124440);
  *(_WORD *)(v1 + 124956) = 12;
  *(_DWORD *)(v1 + 124960) = " HRS";
  sub_10046920(v1 + 123212, (int)byte_100B8180, dword_1031FB44 + 6536, 815.0, 295.0, 120.0, 15.0);
  result = sub_100465F0(v1 + 516, 1, v1 + 123212);
  *(_WORD *)(v1 + 123728) = 37;
  *(_DWORD *)(v1 + 123732) = " PPM";
  return result;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10015B20) --------------------------------------------------------
void __usercall sub_10015B20(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST34_4@1
  signed int v3; // ST40_4@1
  float v4; // ST40_4@1
  double v5; // st7@1
  double v6; // st7@1
  float v7; // ST40_4@3
  int v8; // ST34_4@3
  signed int v9; // ST40_4@3
  float v10; // ST40_4@3
  double v11; // st7@3
  float v12; // [sp+1Ch] [bp-4h]@1
  float v13; // [sp+1Ch] [bp-4h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10046920(v1 + 33124, (int)"FFLOW GPH", dword_1031FB44 + 4568, 10.0, 285.0, 130.0, 15.0);
  sub_100465F0(v1 + 264, 1, v1 + 33124);
  sub_10046630(dword_1031FB44 + 20592, v1 + 33124);
  v2 = *(_BYTE *)(v1 + 125840);
  v3 = *(_BYTE *)(v1 + 125840);
  *(_WORD *)(v1 + 33640) = 33;
  v4 = (double)v3 * 0.25 * 130.0;
  sub_100483D0(v1 + 60416, (int)"EGT F", dword_1031FB44 + 4404, 10.0, 300.0, v4, 140.0, v2);
  sub_10047B60(dword_1031FB44 + 20564, v1 + 60416);
  sub_10047B10(v1 + 408, *(_BYTE *)(v1 + 125840), 1, v1 + 60416);
  v5 = *(float *)(v1 + 61084);
  *(_WORD *)(v1 + 61380) = 17;
  v12 = v5;
  v6 = 140.0;
  if ( v12 > 140.0 )
    v6 = v12;
  v7 = v6;
  *(float *)(v1 + 61084) = v7;
  sub_10046920(v1 + 62368, (int)" PEAK", dword_1031FB44 + 6372, 10.0, 495.0, 130.0, 15.0);
  sub_100465F0(v1 + 492, 1, v1 + 62368);
  v8 = *(_BYTE *)(v1 + 125840);
  v9 = *(_BYTE *)(v1 + 125840);
  *(_WORD *)(v1 + 62884) = 10;
  v10 = (double)v9 * 0.25 * 130.0;
  sub_100483D0(v1 + 54372, (int)"CHT F", dword_1031FB44 + 4240, 10.0, 510.0, v10, 140.0, v8);
  sub_10047B60(dword_1031FB44 + 20536, v1 + 54372);
  sub_10047B10(v1 + 288, *(_BYTE *)(v1 + 125840), 1, v1 + 54372);
  v11 = *(float *)(v1 + 55040);
  *(_WORD *)(v1 + 55336) = 17;
  v13 = v11;
  if ( v13 <= 140.0 )
    *(float *)(v1 + 55040) = 140.0;
  else
    *(float *)(v1 + 55040) = v13;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10015DB0) --------------------------------------------------------
int __usercall sub_10015DB0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float v2; // ST38_4@1
  float v3; // ST38_4@1
  bool v4; // zf@1
  double v5; // st7@2
  float v6; // ST38_4@4
  float v7; // ST3C_4@4
  float v8; // ST3C_4@4
  float v9; // ST3C_4@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10042820(v1 + 6148, (int)"MAN IN", dword_1031FB44 + 5060, -7.0, -5.0, 160.0, 160.0);
  sub_10042990(dword_1031FB44 + 20676, v1 + 6148);
  *(_WORD *)(v1 + 11722) = 5;
  *(_BYTE *)(v1 + 11765) = 1;
  sub_10060F20(v1 + 240, 1, v1 + 6164);
  sub_10060F50(-7.0, 5.0, 160.0, 120.0, v1 + 6164);
  v2 = *(float *)(v1 + 6184) - *(float *)(v1 + 6180);
  sub_10062160(v2, 0.0, -0.2, v1 + 6164);
  v3 = *(float *)(v1 + 6184) - *(float *)(v1 + 6180);
  sub_10061F10(v3, "%.0f", 1.0, 9.0, -0.2, v1 + 6164);
  *(float *)(v1 + 6268) = *(float *)(v1 + 6268) - 15.0;
  v4 = *(_BYTE *)(v1 + 11768) == 0;
  *(float *)(v1 + 8468) = *(float *)(v1 + 8468) - 15.0;
  *(float *)(v1 + 8540) = *(float *)(v1 + 8520);
  *(float *)(v1 + 8544) = *(float *)(v1 + 8528) + 8.0;
  *(float *)(v1 + 8604) = *(float *)(v1 + 8584);
  *(float *)(v1 + 8608) = *(float *)(v1 + 8592) + 8.0;
  if ( v4 )
    v5 = -5.0;
  else
    v5 = 125.0;
  v6 = v5;
  sub_10042820(v1 + 17392, (int)"RPM", dword_1031FB44 + 5552, -7.0, v6, 160.0, 160.0);
  sub_10042990(dword_1031FB44 + 20760, v1 + 17392);
  *(_WORD *)(v1 + 22966) = 6;
  *(_BYTE *)(v1 + 23009) = 1;
  v7 = *(float *)(v1 + 17428) - *(float *)(v1 + 17424);
  sub_10062160(v7, 0.0, -0.2, v1 + 17408);
  v8 = *(float *)(v1 + 17428) - *(float *)(v1 + 17424);
  sub_10061F10(v8, "%.0f", 1.0, 9.0, -0.2, v1 + 17408);
  sub_10060F20(v1 + 252, 1, v1 + 17408);
  *(float *)(v1 + 17512) = *(float *)(v1 + 17512) - 15.0;
  *(float *)(v1 + 19712) = *(float *)(v1 + 19712) - 15.0;
  *(float *)(v1 + 19784) = *(float *)(v1 + 19764);
  *(float *)(v1 + 19788) = *(float *)(v1 + 19772) + 8.0;
  *(float *)(v1 + 19848) = *(float *)(v1 + 19828) - 6.0;
  *(float *)(v1 + 19852) = *(float *)(v1 + 19836) + 8.0;
  v9 = v6 + 10.0;
  return sub_10060F50(-7.0, v9, 160.0, 120.0, v1 + 17408);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100160F0) --------------------------------------------------------
signed int __usercall sub_100160F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  double v3; // st7@2
  float v4; // ST38_4@4
  double v5; // st7@4
  float v6; // ST2C_4@4
  int v7; // eax@4
  signed int result; // eax@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10046920(v1 + 73096, (int)"OIL F", dword_1031FB44 + 5388, 10.0, 315.0, 130.0, 15.0);
  sub_100465F0(v1 + 336, 1, v1 + 73096);
  sub_10046630(dword_1031FB44 + 20732, v1 + 73096);
  *(_WORD *)(v1 + 73612) = 17;
  sub_10046920(v1 + 83820, (int)"OIL PSI", dword_1031FB44 + 5224, 10.0, 338.0, 130.0, 15.0);
  sub_100465F0(v1 + 348, 1, v1 + 83820);
  sub_10046630(dword_1031FB44 + 20704, v1 + 83820);
  *(_WORD *)(v1 + 84336) = 15;
  sub_10046920(v1 + 103020, (int)"VOLTS", dword_1031FB44 + 5880, 10.0, 361.0, 130.0, 15.0);
  sub_100465F0(v1 + 372, 1, v1 + 103020);
  sub_10046630(dword_1031FB44 + 20816, v1 + 103020);
  *(_WORD *)(v1 + 103536) = 21;
  sub_10046920(v1 + 93416, (int)"AMPS", dword_1031FB44 + 3912, 10.0, 384.0, 130.0, 15.0);
  sub_100465F0(v1 + 360, 1, v1 + 93416);
  sub_10046630(dword_1031FB44 + 20480, v1 + 93416);
  *(_WORD *)(v1 + 93932) = 23;
  sub_10046920(v1 + 33736, (int)"FFLOW GPH", dword_1031FB44 + 4568, 10.0, 407.0, 130.0, 15.0);
  sub_100465F0(v1 + 264, 1, v1 + 33736);
  sub_10046630(dword_1031FB44 + 20592, v1 + 33736);
  *(_WORD *)(v1 + 34252) = 33;
  sub_10046920(v1 + 44468, (int)"FPRES PSI", dword_1031FB44 + 4732, 10.0, 430.0, 130.0, 15.0);
  sub_100465F0(v1 + 276, 1, v1 + 44468);
  sub_10046630(dword_1031FB44 + 20620, v1 + 44468);
  v2 = *(_BYTE *)(v1 + 45080) == 0;
  *(_WORD *)(v1 + 44984) = 15;
  if ( v2 )
    v3 = 430.0;
  else
    v3 = 453.0;
  v4 = v3;
  sub_10046920(v1 + 123824, (int)"CO PPM", dword_1031FB44 + 6536, 10.0, v4, 130.0, 15.0);
  sub_100465F0(v1 + 516, 1, v1 + 123824);
  sub_10046630(dword_1031FB44 + 20928, v1 + 123824);
  *(_WORD *)(v1 + 124340) = 37;
  sub_10046920(v1 + 119976, (int)"GAL REM", dword_1031FB44 + 6044, 10.0, 535.0, 130.0, 15.0);
  *(_DWORD *)(v1 + 120024) = v1 + 460;
  *(_WORD *)(v1 + 120492) = 31;
  sub_10046920(v1 + 121200, (int)"GAL USED", dword_1031FB44 + 6044, 10.0, 558.0, 130.0, 15.0);
  *(float *)(v1 + 121868) = 15.0;
  *(float *)(v1 + 121872) = 60.0;
  *(_DWORD *)(v1 + 121248) = v1 + 472;
  v5 = *(float *)(v1 + 121824);
  *(_WORD *)(v1 + 121716) = 31;
  v6 = v5;
  *(_WORD *)(v1 + 121856) = 4142;
  *(_DWORD *)(v1 + 121860) = -1;
  *(_DWORD *)(v1 + 121864) = 0;
  v7 = sub_10065060(v6);
  *(float *)(v1 + 121880) = 1.0;
  *(_DWORD *)(v1 + 121876) = v7;
  *(float *)(v1 + 121884) = 1.0;
  *(_DWORD *)(v1 + 121888) = 0x7FFFFFFF;
  *(float *)(v1 + 121892) = 140.0;
  *(float *)(v1 + 121896) = 581.0;
  sub_10046920(v1 + 122592, (int)"RANGE NM", dword_1031FB44 + 6208, 10.0, 604.0, 130.0, 15.0);
  sub_100465F0(v1 + 480, 1, v1 + 122592);
  *(_WORD *)(v1 + 123108) = 38;
  sub_10046920(v1 + 125052, (int)byte_100B8180, dword_1031FB44 + 6208, 5.0, 680.0, 105.0, 15.0);
  result = sub_100465F0(v1 + 504, 1, v1 + 125052);
  *(_WORD *)(v1 + 125568) = 12;
  *(_DWORD *)(v1 + 125572) = " HRS";
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10016690) --------------------------------------------------------
char __usercall sub_10016690@<al>(int a1@<esi>)
{
  int v1; // eax@1
  char v2; // ST0C_1@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 62980) = 0;
  *(_BYTE *)(v1 + 170) = 0;
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 125843) = v2;
  sub_1004C170(v2);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (100166D0) --------------------------------------------------------
int __usercall sub_100166D0@<eax>(char a1@<al>, int a2@<edi>)
{
  int v2; // esi@1
  int result; // eax@5
  _WORD *v4; // ecx@12
  float v5; // ST20_4@14

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  if ( *(_BYTE *)(v2 + 125842) )
  {
    if ( a1 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD580, (int)&unk_100BD770, 0, 255);
      sub_1006BEE0((int)"TEMPERATURE", 510.0, 20.0, 250.0, 650.0);
      sub_1006BEE0((int)"ELECTRICAL", 795.0, 20.0, 220.0, 200.0);
      sub_1006BEE0((int)"FUEL CALCULATOR", 795.0, 455.0, 220.0, 130.0);
      sub_1006BEE0((int)"TOTAL TIME IN SERVICE", 795.0, 620.0, 220.0, 50.0);
      if ( *(_BYTE *)(v2 + 124436) )
        sub_1006BEE0((int)"CARBON MONOXIDE", 795.0, 255.0, 220.0, 60.0);
    }
    result = sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD5A8, v2, v2 + 80, 255);
    if ( *(_BYTE *)(v2 + 45080) )
    {
      *(float *)(v2 + 125844) = 367.5;
      *(float *)(v2 + 125848) = 288.75;
      result = sub_10065670((int)"FUEL", v2 + 125844);
    }
    if ( *(_BYTE *)(v2 + 11768) )
    {
      *(float *)(v2 + 125844) = 122.5;
      *(float *)(v2 + 125848) = 288.75;
      result = sub_10065670((int)"OIL", v2 + 125844);
    }
  }
  else
  {
    if ( a1 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD594, (int)&unk_100BD778, 0, 255);
      sub_100682A0(151.0, 0.0, 151.0, 686.0, -1, 1.0);
    }
    sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD668, v2 + 100, v2 + 108, 255);
    if ( *(_BYTE *)(v2 + 125843) == 1 )
    {
      result = sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD67C, v2 + 152, v2 + 168, 255);
    }
    else
    {
      v4 = *(_WORD **)(a2 + 52);
      if ( *(_BYTE *)(v2 + 125843) == 2 )
      {
        sub_100653C0(a2, v4, (char *)&unk_100BD6E8, v2 + 172, v2 + 224, 255);
        v5 = (double)(*(_BYTE *)(v2 + 45080) + *(_BYTE *)(v2 + 124436)) * 23.0 + 135.0;
        sub_1006BF20((int)"SYSTEM", 5.0, 285.0, 140.0, v5);
        sub_1006BF20((int)"FUEL CALC", 5.0, 505.0, 140.0, 110.0);
        *(float *)(v2 + 125844) = 75.0;
        *(float *)(v2 + 125848) = 650.0;
        *(float *)(v2 + 125868) = 0.5;
        *(float *)(v2 + 125872) = 1.0;
        sub_10065670((int)"TTL TIME IN SVC", v2 + 125844);
        result = sub_100682A0(5.0, 653.0, 146.0, 653.0, -1, 1.0);
      }
      else
      {
        result = sub_100653C0(a2, v4, (char *)&unk_100BD6A0, v2 + 112, v2 + 144, 255);
      }
    }
  }
  return result;
}

//----- (10016A90) --------------------------------------------------------
char __usercall sub_10016A90@<al>(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // ecx@1
  _DWORD *v3; // eax@2
  char result; // al@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  if ( *(_BYTE *)(v1 + 125840) )
  {
    v3 = (_DWORD *)(v1 + 60492);
    do
    {
      *(v3 - 1195) = 0;
      *v3 = 0;
      ++v2;
      ++v3;
    }
    while ( v2 < *(_BYTE *)(v1 + 125840) );
  }
  result = sub_1004CCA0(v1 + 61664, 1);
  *(_BYTE *)(v1 + 61664) = *(_BYTE *)(v1 + 125840);
  return result;
}

//----- (10016AF0) --------------------------------------------------------
char __usercall sub_10016AF0@<al>(int a1@<eax>)
{
  int v1; // ebx@1
  char result; // al@2
  signed int v3; // edi@5
  int v4; // esi@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10016A90(a1);
  if ( *(_BYTE *)(v1 + 62980) == 2 )
  {
    result = *(_BYTE *)(v1 + 125840);
    *(_BYTE *)(v1 + 62980) = 0;
    *(_BYTE *)(v1 + 90) = 0;
    *(_BYTE *)(v1 + 170) = 0;
    if ( (unsigned __int8)result <= 1u )
    {
      sub_100649E0(v1 + 55808, byte_100B8180, 21);
      *(float *)(v1 + 55840) = 9.0;
      result = sub_100649E0(v1 + 60588, byte_100B8180, 21);
      *(float *)(v1 + 60620) = 9.0;
    }
    else if ( (unsigned __int8)result > 0u )
    {
      v3 = 1;
      v4 = v1 + 55840;
      do
      {
        sub_10064B00((char *)(v4 - 32), 0x15u, "%d", v3);
        *(float *)v4 = 9.0;
        result = sub_10064B00((char *)(v4 + 4748), 0x15u, "%d", v3);
        *(float *)(v4 + 4780) = 9.0;
        ++v3;
        v4 += 52;
      }
      while ( v3 - 1 < *(_BYTE *)(v1 + 125840) );
    }
  }
  else
  {
    *(_BYTE *)(v1 + 62980) = 2;
    result = 3;
    *(_BYTE *)(v1 + 90) = 3;
    *(_BYTE *)(v1 + 170) = 3;
  }
  return result;
}

//----- (10016BF0) --------------------------------------------------------
char __usercall sub_10016BF0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@2
  float v3; // ST28_4@3
  double v4; // st7@3
  float v5; // ST28_4@5
  double v6; // st7@5
  unsigned __int8 v7; // dl@7
  float v8; // ST28_4@7
  unsigned __int8 v9; // ST1C_1@8
  char v10; // al@8
  unsigned __int8 v11; // ST10_1@8

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 62980) )
  {
    result = *(_BYTE *)(v1 + 62980) - 2;
    if ( *(_BYTE *)(v1 + 62980) != 2 )
      goto LABEL_10;
    sub_10047850(v1 + 61664, v1 + 55636);
    sub_10047850(v1 + 61664, v1 + 60416);
    v3 = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 61698) + 412) - *(float *)(v1 + 4 * *(_BYTE *)(v1 + 61698) + 61708);
    v4 = v3;
    if ( v3 > 0.0 )
      v4 = 0.0;
    v5 = v4;
    v6 = v5;
    *(float *)(v1 + 496) = v5;
    if ( v5 <= -500.0 )
      v6 = -500.0;
    v7 = *(_BYTE *)(v1 + 125840);
    v8 = v6;
    *(float *)(v1 + 496) = v8 * 1.799999952316284;
    result = sub_10066EE0(v1 + 240, 4u, v7);
  }
  else
  {
    v9 = *(_BYTE *)(v1 + 125840);
    *(_BYTE *)(v1 + 56598) = -1;
    v10 = sub_10066EE0(v1 + 240, 0xEu, v9);
    v11 = *(_BYTE *)(v1 + 125840);
    *(_BYTE *)(v1 + 61378) = v10;
    result = sub_10066EE0(v1 + 240, 4u, v11);
  }
  *(_BYTE *)(v1 + 55334) = result;
LABEL_10:
  if ( *(_BYTE *)(v1 + 125840) > 1u )
  {
    sub_10049040(v1 + 12 * (*(_BYTE *)(v1 + 55334) + 24), 1, 0, v1 + 49880);
    result = sub_10064B00((char *)(v1 + 50364), 7u, "%d", *(_BYTE *)(v1 + 55334) + 1);
  }
  return result;
}

//----- (10016D50) --------------------------------------------------------
void __usercall sub_10016D50(float a1@<esi>, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  float *v4; // eax@1
  signed int v5; // ecx@1
  unsigned int v6; // esi@3
  double v7; // st7@4
  int v8; // eax@4
  int v9; // esi@9
  int v10; // ebp@10
  double v11; // st7@10
  char v12; // cl@15
  float *v13; // ebx@15
  double v14; // st7@15
  double v15; // st6@15
  double v16; // st7@22
  double v17; // st7@23
  float v18; // edx@32
  double v19; // st7@35
  double v20; // st7@45
  double v21; // st7@47
  bool v22; // c0@47
  bool v23; // c3@47
  float *v24; // ecx@53
  float *v25; // esi@62
  float *v26; // esi@69
  int v27; // edx@80
  int v28; // ecx@80
  int v29; // eax@80
  double v30; // st7@83
  float v31; // [sp+Ch] [bp-44h]@3
  char v32; // [sp+1Eh] [bp-32h]@10
  char v33; // [sp+1Fh] [bp-31h]@87
  float v34; // [sp+20h] [bp-30h]@15
  float v35; // [sp+24h] [bp-2Ch]@10
  float v36; // [sp+28h] [bp-28h]@76
  int v37; // [sp+2Ch] [bp-24h]@5
  float v38; // [sp+30h] [bp-20h]@10
  float v39; // [sp+34h] [bp-1Ch]@10
  float v40; // [sp+38h] [bp-18h]@10
  float v41; // [sp+3Ch] [bp-14h]@15
  float v42; // [sp+40h] [bp-10h]@32
  float v43; // [sp+44h] [bp-Ch]@39
  float v44; // [sp+48h] [bp-8h]@44
  float v45; // [sp+4Ch] [bp-4h]@53
  float v46; // [sp+54h] [bp+4h]@82

  v2 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v4 = (float *)(v3 + 244);
  v5 = 24;
  do
  {
    *v4 = 9.8999998e24;
    v4 += 3;
    --v5;
  }
  while ( v5 );
  v31 = a1;
  v6 = 0;
  do
  {
    v7 = sub_1004C3E0(word_100BD4E2[v6]);
    v8 = (unsigned __int8)byte_100BD4E0[v6 * 2];
    v6 += 2;
    *(float *)(v3 + 12 * v8 + 244) = v7;
  }
  while ( v6 < 32 );
  if ( sub_10031F70(100.0, *(float *)(v3 + 364), (int)&v37) )
  {
    sub_100666C0(v3 + 94028, v37);
    *(float *)(v3 + 364) = (double)*(signed int *)(v3 + 94032) / 100.0;
  }
  if ( *(_BYTE *)(v3 + 125664) == 1 )
  {
    if ( *(_DWORD *)(a2 + 64) == 5 )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = 32 * v9 + v3;
        v32 = sub_10066790(word_100BD780[2 * v9], &v35);
        v39 = *(float *)(v10 + 125680);
        v40 = *(float *)(v10 + 125684);
        v11 = v35;
        v38 = v35;
        if ( (LODWORD(v35) & 0x7F800000) == 2139095040 || v39 < v11 )
        {
          v35 = v39;
        }
        else if ( v40 > v11 )
        {
          v35 = v40;
        }
        v12 = sub_10066790(word_100BD782[2 * v9], &v34);
        v13 = (float *)(32 * (v9 + 3928) + v3);
        v40 = *v13;
        v39 = *(float *)(v10 + 125700);
        v14 = v34;
        v41 = v34;
        v15 = v40;
        if ( (LODWORD(v34) & 0x7F800000) == 2139095040 || v15 < v14 || (v15 = v39, v39 > v14) )
        {
          v34 = v15;
          v14 = v34;
        }
        if ( v12 == 1 )
        {
          if ( v14 >= 1.8927059 )
          {
            if ( v14 >= 1.8927059 && v32 == 1 )
            {
              v19 = *(float *)(v10 + 125680) - 7.5708236;
              if ( v35 >= v19 )
              {
                if ( v9 )
                  sub_10066510((float *)(v3 + 4 * v9 + 125792));
                else
                  sub_100664A0((float *)(v3 + 125792));
                *(float *)(v3 + 4 * v9 + 125792) = *(float *)(v3 + 125672)
                                                 - *(float *)(v3 + 125668)
                                                 + *(float *)(v3 + 4 * v9 + 125792);
                v40 = *(float *)(v3 + 125672) + *v13;
                v39 = *(float *)(v10 + 125700) + *(float *)(v3 + 125672);
                v43 = *(float *)(v3 + 4 * v9 + 125792);
                v18 = v43;
LABEL_45:
                v20 = v40;
                if ( (LODWORD(v18) & 0x7F800000) != 2139095040
                  && *(float *)(v3 + 4 * v9 + 125792) <= v20
                  && (v21 = *(float *)(v3 + 4 * v9 + 125792), v22 = v39 < v21, v23 = v39 == v21, v20 = v39, v22 || v23) )
                {
                  *(_BYTE *)(v3 + v9 + 125744) = 1;
                }
                else
                {
                  *(float *)(v3 + 4 * v9 + 125792) = v20;
                  *(_BYTE *)(v3 + v9 + 125744) = 1;
                }
                goto LABEL_51;
              }
              if ( v35 < v19 )
              {
                if ( v9 )
                  sub_10066510((float *)(v3 + 4 * v9 + 125792));
                else
                  sub_100664A0((float *)(v3 + 125792));
                *(float *)(v3 + 4 * v9 + 125792) = *(float *)(v3 + 4 * v9 + 125792) - v34;
                v40 = *(float *)(v10 + 125680);
                v39 = *(float *)(v10 + 125684);
                v44 = *(float *)(v3 + 4 * v9 + 125792);
                v18 = v44;
                goto LABEL_45;
              }
            }
          }
          else if ( v32 == 1 )
          {
            v16 = *(float *)(v10 + 125680) - 1.8927059;
            if ( v35 >= v16 )
            {
              v40 = *(float *)(v3 + 4 * v9 + 125792) - *(float *)(v3 + 125676);
              v17 = v40;
              *(float *)(v3 + 4 * v9 + 125792) = v40;
              if ( *(float *)(v3 + 125668) >= v17 )
                *(float *)(v3 + 4 * v9 + 125792) = *(float *)(v3 + 125668);
              *(_BYTE *)(v3 + v9 + 125744) = 1;
              goto LABEL_51;
            }
            if ( v35 < v16 )
            {
              if ( v9 )
                sub_10066510((float *)(v3 + 4 * v9 + 125792));
              else
                sub_100664A0((float *)(v3 + 125792));
              if ( v34 > 0.0 )
                *(float *)(v3 + 4 * v9 + 125792) = *(float *)(v3 + 4 * v9 + 125792) - v34;
              v40 = *(float *)(v10 + 125680);
              v39 = *(float *)(v10 + 125684);
              v42 = *(float *)(v3 + 4 * v9 + 125792);
              v18 = v42;
              goto LABEL_45;
            }
          }
        }
        *(_BYTE *)(v3 + v9 + 125744) = 0;
LABEL_51:
        if ( *(_BYTE *)(v3 + v9 + 125744) )
          *(float *)(v3 + 12 * v9 + 388) = *(float *)(v3 + 4 * v9 + 125792);
        v24 = (float *)(v3 + 12 * v9 + 388);
        v45 = *v24;
        if ( (LODWORD(v45) & 0x7F800000) == 2139095040 || *v24 > 100.0 )
        {
          *v24 = 100.0;
        }
        else if ( *v24 < 0.0 )
        {
          *v24 = 0.0;
        }
        if ( *v24 == 100.0 )
          *v24 = 9.8999998e24;
        sub_1008CB30(v9 + 9143, v3 + 12 * v9 + 388, 4);
        if ( ++v9 >= 2 )
        {
          v2 = a2;
          goto LABEL_80;
        }
      }
    }
    v25 = (float *)(v3 + 388);
    sub_1008CA60(9143, v3 + 388, 4);
    if ( (COERCE_UNSIGNED_INT(*(float *)(v3 + 388)) & 0x7F800000) == 2139095040 || *v25 > 100.0 )
    {
      *v25 = 100.0;
    }
    else if ( *v25 < 0.0 )
    {
      *v25 = 0.0;
    }
    if ( *v25 == 100.0 )
      *v25 = 9.8999998e24;
    v26 = (float *)(v3 + 400);
    sub_1008CA60(9144, v3 + 400, 4);
    if ( (COERCE_UNSIGNED_INT(*(float *)(v3 + 400)) & 0x7F800000) == 2139095040 || *v26 > 100.0 )
    {
      *v26 = 100.0;
    }
    else if ( *v26 < 0.0 )
    {
      *v26 = 0.0;
    }
    if ( *v26 == 100.0 )
      *v26 = 9.8999998e24;
  }
  else
  {
    if ( sub_100664A0(&v36) )
      *(float *)(v3 + 388) = v36;
    if ( sub_10066510(&v36) )
      *(float *)(v3 + 400) = v36;
  }
LABEL_80:
  *(float *)(v3 + 460) = sub_1004C0C0();
  *(float *)(v3 + 472) = sub_1004C0D0(v28, v27);
  v29 = sub_1004BF40();
  *(_DWORD *)(v3 + 121844) = v29;
  if ( v29 != 0x7FFFFFFF )
    *(_DWORD *)(v3 + 121844) = sub_100296D0(v3 + 121900, 0x14u, v29);
  *(_DWORD *)(v3 + 121888) = *(_DWORD *)(v3 + 121844);
  v46 = sub_1004BFF0(v31);
  *(float *)(v3 + 484) = v46;
  if ( 9.8999998e24 == v46 )
  {
    v30 = -1.0;
LABEL_86:
    *(float *)(v3 + 484) = v30;
    goto LABEL_87;
  }
  if ( sub_10031F70(100.0, v46, (int)&v37) )
  {
    sub_100666C0(v3 + 123204, v37);
    v30 = (double)*(signed int *)(v3 + 123208) / 100.0;
    goto LABEL_86;
  }
LABEL_87:
  *(float *)(v3 + 508) = sub_1004C070();
  *(_BYTE *)(v3 + 123652) = 10;
  *(_BYTE *)(v3 + 124264) = 10;
  if ( sub_10067000(0xBCu, &v33) && v33 )
  {
    *(_BYTE *)(v3 + 123652) = 16;
    *(_BYTE *)(v3 + 124264) = 16;
  }
  if ( sub_100663D0(&v36) )
    *(float *)(v3 + 268) = v36;
  sub_10016BF0(v2);
  if ( sub_10031F70(100000.0, *(float *)(v3 + 268), (int)&v37) )
  {
    sub_100666C0(v3 + 34348, v37);
    *(float *)(v3 + 268) = (double)*(signed int *)(v3 + 34352) / 100000.0;
  }
  sub_1004C380(v3 + 240, 0x18u);
}
// 10016D50: could not find valid save-restore pair for esi
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100BD4E2: using guessed type __int16 word_100BD4E2[];
// 100BD780: using guessed type __int16 word_100BD780[];
// 100BD782: using guessed type __int16 word_100BD782[];

//----- (100174B0) --------------------------------------------------------
signed int __usercall sub_100174B0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  char v5; // al@3
  bool v6; // al@8
  char v7; // al@13
  signed int v8; // eax@20
  float *v9; // ecx@20
  double v10; // st7@22
  bool v11; // c0@24
  bool v12; // c3@24
  double v13; // st7@24
  double v14; // st6@31
  double v15; // st5@33
  double v16; // st5@41
  double v17; // st3@43
  double v18; // st3@49
  double v19; // st6@51
  double v20; // st4@53
  double v21; // st4@57
  double v22; // st4@59
  float v23; // ST38_4@64
  float v25; // [sp+Ch] [bp-B8h]@0
  float v26; // [sp+18h] [bp-ACh]@66
  int v27; // [sp+1Ch] [bp-A8h]@66
  char v28; // [sp+20h] [bp-A4h]@1
  float v29; // [sp+24h] [bp-A0h]@22
  float v30; // [sp+28h] [bp-9Ch]@22
  float v31; // [sp+2Ch] [bp-98h]@39
  float v32; // [sp+30h] [bp-94h]@33
  float v33; // [sp+4Ch] [bp-78h]@22
  float v34; // [sp+50h] [bp-74h]@43
  float v35; // [sp+54h] [bp-70h]@59
  float v36; // [sp+58h] [bp-6Ch]@53
  int v37; // [sp+74h] [bp-50h]@22
  int v38; // [sp+78h] [bp-4Ch]@64
  int v39; // [sp+7Ch] [bp-48h]@64
  int v40; // [sp+80h] [bp-44h]@64
  int v41; // [sp+9Ch] [bp-28h]@22
  int v42; // [sp+A0h] [bp-24h]@64
  int v43; // [sp+A4h] [bp-20h]@64
  int v44; // [sp+A8h] [bp-1Ch]@64

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1008D070(37, &v28);
  v2 = (float *)"QC";
  v3 = v1 + 244;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&unk_100BD580 );
  *(float *)(v1 + 125844) = 0.0;
  *(_DWORD *)(v1 + 125852) = 2;
  *(float *)(v1 + 125848) = 0.0;
  *(_DWORD *)(v1 + 125860) = -16777216;
  *(_DWORD *)(v1 + 125864) = -1;
  *(float *)(v1 + 125856) = 12.0;
  *(float *)(v1 + 125868) = 0.5;
  *(float *)(v1 + 125872) = 1.0;
  *(float *)(v1 + 125876) = 40.0;
  v5 = sub_1006C420(0x18u);
  *(_BYTE *)(v1 + 11768) = v5;
  if ( v5 )
  {
    *(_BYTE *)(v1 + 80) = 3;
    *(_BYTE *)(v1 + 108) = 3;
  }
  else
  {
    *(_BYTE *)(v1 + 80) = 0;
    *(_BYTE *)(v1 + 108) = 0;
  }
  v6 = sub_1006C420(0x16u) && v28 & 1;
  *(_BYTE *)(v1 + 45080) = v6;
  if ( v6 )
  {
    *(_BYTE *)(v1 + 85) = 3;
    *(_BYTE *)(v1 + 145) = 3;
    *(_BYTE *)(v1 + 229) = 3;
  }
  else
  {
    *(_BYTE *)(v1 + 85) = 0;
    *(_BYTE *)(v1 + 145) = 0;
    *(_BYTE *)(v1 + 229) = 0;
  }
  v7 = sub_1006C3C0(16);
  *(_BYTE *)(v1 + 124436) = v7;
  if ( v7 )
  {
    *(_BYTE *)(v1 + 98) = 3;
    *(_BYTE *)(v1 + 230) = 3;
  }
  else
  {
    *(_BYTE *)(v1 + 98) = 0;
    *(_BYTE *)(v1 + 230) = 0;
  }
  *(_BYTE *)(v1 + 125840) = *(_BYTE *)(dword_1031FB44 + 25);
  if ( sub_1006C420(0x3Cu) != 1 || sub_1006C420(0x3Du) != 1 || sub_1006C420(0x41u) != 1 || sub_1006C420(0x42u) != 1 )
  {
    *(_BYTE *)(v1 + 125664) = 0;
    goto LABEL_66;
  }
  *(_BYTE *)(v1 + 125664) = 1;
  v8 = 0;
  v9 = (float *)(v1 + 125792);
  do
  {
    *v9 = 0.0;
    *(_BYTE *)(v1 + v8++ + 125744) = 0;
    ++v9;
  }
  while ( v8 < 3 );
  sub_1008CA60(6090, (int)&v29, 40);
  sub_1008CA60(6092, (int)&v33, 40);
  sub_1008CA60(6114, (int)&v37, 40);
  sub_1008CA60(6116, (int)&v41, 40);
  v10 = v30;
  if ( (LODWORD(v30) & 0x7F800000) == 2139095040 )
  {
    v13 = 0.0;
  }
  else if ( v10 > 0.0 )
  {
    v13 = 0.0;
  }
  else
  {
    v11 = 0.0 < v10;
    v12 = 0.0 == v10;
    v13 = 0.0;
    if ( v11 || v12 )
      goto LABEL_29;
  }
  v30 = v13;
LABEL_29:
  if ( (LODWORD(v29) & 0x7F800000) == 2139095040 || v29 > 75.0 )
  {
    v14 = 75.0;
    v29 = 75.0;
  }
  else
  {
    v14 = 75.0;
    if ( v29 < v13 )
      v29 = v13;
  }
  v15 = v32;
  if ( (LODWORD(v32) & 0x7F800000) == 2139095040 || v15 > v13 || v15 < v13 )
    v32 = v13;
  if ( (LODWORD(v31) & 0x7F800000) == 2139095040 || v31 > 25.0 )
  {
    v16 = 25.0;
    v31 = 25.0;
  }
  else
  {
    v16 = 25.0;
    if ( v31 < v13 )
      v31 = v13;
  }
  v17 = v34;
  if ( (LODWORD(v34) & 0x7F800000) == 2139095040 || v17 > v13 || v17 < v13 )
    v34 = v13;
  v18 = v33;
  if ( (LODWORD(v33) & 0x7F800000) == 2139095040 || v18 > v14 )
  {
    v21 = v14;
    v19 = 25.0;
    v33 = v21;
  }
  else
  {
    v19 = 25.0;
    if ( v18 < v13 )
      v33 = v13;
  }
  v20 = v36;
  if ( (LODWORD(v36) & 0x7F800000) == 2139095040 || v20 > v13 || v20 < v13 )
    v36 = v13;
  v22 = v35;
  if ( (LODWORD(v35) & 0x7F800000) == 2139095040 || v22 > v16 )
  {
    v35 = v19;
  }
  else if ( v22 < v13 )
  {
    v35 = v13;
  }
  *(float *)(v1 + 125680) = v29;
  *(float *)(v1 + 125684) = v30;
  *(float *)(v1 + 125696) = v31;
  *(float *)(v1 + 125700) = v32;
  *(_DWORD *)(v1 + 125688) = v37;
  *(_DWORD *)(v1 + 125692) = v38;
  *(_DWORD *)(v1 + 125704) = v39;
  *(_DWORD *)(v1 + 125708) = v40;
  *(float *)(v1 + 125712) = v33;
  *(float *)(v1 + 125716) = v34;
  *(float *)(v1 + 125728) = v35;
  *(float *)(v1 + 125732) = v36;
  *(_DWORD *)(v1 + 125720) = v41;
  *(_DWORD *)(v1 + 125724) = v42;
  *(_DWORD *)(v1 + 125736) = v43;
  *(_DWORD *)(v1 + 125740) = v44;
  *(float *)(v1 + 125668) = v29;
  v23 = *(float *)(dword_1031FB44 + 1008) - v31;
  *(float *)(v1 + 125672) = v23;
  *(float *)(v1 + 125676) = (v23 - *(float *)(v1 + 125668)) / 30.0 * 0.125;
LABEL_66:
  v27 = 0;
  v26 = sub_1004C3E0(1u);
  if ( 9.8999998e24 == v26 )
    v26 = 0.0;
  sub_10031F70(100.0, v26, (int)&v27);
  sub_10066730(v1 + 94028, v27, 1.0, 0.125);
  v26 = 0.0;
  v27 = 0;
  sub_100663D0(&v26);
  sub_10031F70(100000.0, v26, (int)&v27);
  sub_10066730(v1 + 34348, v27, 1.0, 0.125);
  v26 = sub_1004BFF0(v25);
  if ( 9.8999998e24 == v26 )
    v26 = 0.0;
  v27 = 0;
  sub_10031F70(100.0, v26, (int)&v27);
  sub_10066730(v1 + 123204, v27, 1.0, 0.125);
  sub_10014810(a1);
  sub_10015DB0(a1);
  sub_10014090(a1);
  sub_10015B20(a1);
  return sub_100160F0(a1);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10017F70) --------------------------------------------------------
char __usercall sub_10017F70@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@5
  int v3; // ST04_4@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( *(_BYTE *)(v1 + 62980) != 2 )
    {
      v2 = (unsigned __int8)(*(_BYTE *)(v1 + 61378) + 1) % (signed __int16)*(_BYTE *)(v1 + 125840);
      *(_BYTE *)(v1 + 62980) = 1;
      *(_BYTE *)(v1 + 61378) = v2;
      *(_BYTE *)(v1 + 55334) = v2;
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    sub_10016AF0(a1);
  }
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v3, -32734);
}

//----- (10018050) --------------------------------------------------------
char __usercall sub_10018050@<al>(float a1@<esi>, int a2)
{
  int v2; // esi@12
  bool v3; // zf@12
  signed int v4; // eax@15
  void *v5; // ecx@17
  char result; // al@1
  float v7; // ST64_4@22

  result = a2;
  switch ( **(_WORD **)(a2 + 52) )
  {
    case 0x8015:
    case 0x8016:
      result = sub_100166D0(0, a2);
      *(_BYTE *)(a2 + 6) = 2;
      break;
    case 0x8018:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 125842) )
        result = sub_100522C0(0);
      break;
    case 0x8041:
      v2 = sub_100015A0(a2, *(char **)(a2 + 56), 125880, 0);
      *(_BYTE *)(v2 + 125841) = 0;
      v3 = *(_DWORD *)(a2 + 64) != 9;
      *(_BYTE *)(v2 + 125842) = *(_DWORD *)(a2 + 64) == 9;
      if ( v3 )
      {
        sub_100011B0(a2, 0, 0, 151, 686, 3);
      }
      else
      {
        sub_100522C0(1);
        sub_100011B0(a2, 0, 0, 1024, 686, 3);
        sub_10032790(a2, &unk_100BD430, 4u, 3, 1u);
      }
      v4 = sub_1004BF40();
      if ( v4 == 0x7FFFFFFF )
        v4 = 0;
      *(_DWORD *)(v2 + 121900) = v4;
      *(_DWORD *)(v2 + 121904) = v4;
      *(_DWORD *)(v2 + 121908) = v4;
      *(_DWORD *)(v2 + 121912) = v4;
      *(_DWORD *)(v2 + 121916) = v4;
      *(_DWORD *)(v2 + 121920) = v4;
      *(_DWORD *)(v2 + 121924) = v4;
      *(_DWORD *)(v2 + 121928) = v4;
      *(_DWORD *)(v2 + 121932) = v4;
      *(_DWORD *)(v2 + 121936) = v4;
      *(_DWORD *)(v2 + 121940) = v4;
      *(_DWORD *)(v2 + 121944) = v4;
      *(_DWORD *)(v2 + 121948) = v4;
      *(_DWORD *)(v2 + 121952) = v4;
      *(_DWORD *)(v2 + 121956) = v4;
      *(_DWORD *)(v2 + 121960) = v4;
      *(_DWORD *)(v2 + 121964) = v4;
      *(_DWORD *)(v2 + 121968) = v4;
      *(_DWORD *)(v2 + 121972) = v4;
      *(_DWORD *)(v2 + 121976) = v4;
      *(_BYTE *)(v2 + 62980) = 0;
      sub_1004CCA0(v2 + 61664, 1);
      *(_BYTE *)(v2 + 61664) = *(_BYTE *)(v2 + 125840);
      *(_DWORD *)(v2 + 61668) = v2 + 412;
      *(_DWORD *)(v2 + 61672) = v2 + 424;
      *(_DWORD *)(v2 + 61676) = v2 + 436;
      *(_DWORD *)(v2 + 61680) = v2 + 448;
      *(_DWORD *)(v2 + 61692) = v2 + 268;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 230) = -1;
      *(_DWORD *)v2 = v2 + 528;
      *(_DWORD *)(v2 + 4) = v2 + 11772;
      *(_DWORD *)(v2 + 8) = v2 + 62984;
      *(_DWORD *)(v2 + 12) = v2 + 73708;
      *(_DWORD *)(v2 + 16) = v2 + 23012;
      *(_DWORD *)(v2 + 20) = v2 + 34356;
      *(_DWORD *)(v2 + 24) = v2 + 103632;
      *(_DWORD *)(v2 + 28) = v2 + 109252;
      *(_DWORD *)(v2 + 32) = v2 + 45084;
      *(_DWORD *)(v2 + 36) = v2 + 55620;
      *(_DWORD *)(v2 + 40) = v2 + 61756;
      *(_DWORD *)(v2 + 44) = v2 + 84432;
      *(_DWORD *)(v2 + 48) = v2 + 94036;
      *(_DWORD *)(v2 + 52) = v2 + 119364;
      *(_DWORD *)(v2 + 56) = v2 + 120588;
      *(_DWORD *)(v2 + 64) = v2 + 121812;
      *(_DWORD *)(v2 + 68) = v2 + 121980;
      *(_DWORD *)(v2 + 60) = "ENDURANCE";
      *(_DWORD *)(v2 + 76) = v2 + 124440;
      *(_DWORD *)(v2 + 72) = v2 + 123212;
      *(_DWORD *)(v2 + 80) = 50529027;
      *(_DWORD *)(v2 + 84) = 50529027;
      *(_DWORD *)(v2 + 88) = 50529027;
      *(_DWORD *)(v2 + 92) = 50529027;
      *(_DWORD *)(v2 + 96) = 50529027;
      *(_BYTE *)(v2 + 90) = 0;
      *(_DWORD *)(v2 + 100) = v2 + 6148;
      *(_DWORD *)(v2 + 104) = v2 + 17392;
      *(_WORD *)(v2 + 108) = 771;
      *(_DWORD *)(v2 + 112) = v2 + 28632;
      *(_DWORD *)(v2 + 116) = v2 + 39976;
      *(_DWORD *)(v2 + 120) = v2 + 49880;
      *(_DWORD *)(v2 + 124) = v2 + 68604;
      *(_DWORD *)(v2 + 128) = v2 + 79328;
      *(_DWORD *)(v2 + 132) = v2 + 88924;
      *(_DWORD *)(v2 + 136) = v2 + 98528;
      *(_DWORD *)(v2 + 140) = v2 + 114872;
      *(_DWORD *)(v2 + 144) = 50529027;
      *(_DWORD *)(v2 + 148) = 50529027;
      *(_DWORD *)(v2 + 152) = v2 + 33124;
      *(_DWORD *)(v2 + 156) = v2 + 60416;
      *(_DWORD *)(v2 + 164) = v2 + 54372;
      *(_DWORD *)(v2 + 160) = v2 + 62368;
      *(_DWORD *)(v2 + 168) = 50529027;
      *(_DWORD *)(v2 + 172) = v2 + 73096;
      *(_DWORD *)(v2 + 176) = v2 + 83820;
      *(_DWORD *)(v2 + 180) = v2 + 103020;
      *(_DWORD *)(v2 + 184) = v2 + 93416;
      *(_DWORD *)(v2 + 188) = v2 + 33736;
      *(_DWORD *)(v2 + 192) = v2 + 44468;
      *(_DWORD *)(v2 + 204) = v2 + 121200;
      *(_DWORD *)(v2 + 200) = v2 + 119976;
      *(_DWORD *)(v2 + 212) = v2 + 121856;
      *(_DWORD *)(v2 + 216) = v2 + 122592;
      *(_BYTE *)(v2 + 170) = 0;
      *(_DWORD *)(v2 + 208) = "ENDUR";
      *(_DWORD *)(v2 + 220) = v2 + 125052;
      *(_DWORD *)(v2 + 196) = v2 + 123824;
      *(_DWORD *)(v2 + 224) = 50529027;
      *(_DWORD *)(v2 + 228) = 50529027;
      *(_DWORD *)(v2 + 232) = 50529027;
      *(_BYTE *)(v2 + 236) = 3;
      sub_100174B0(a2);
      *(_BYTE *)(v2 + 125843) = sub_1004BF10(v5);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD5A8, v2, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD6A0, v2 + 112, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD67C, v2 + 152, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD6E8, v2 + 172, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100BD668, v2 + 100, 0, 255);
      sub_10001750(a2, *(_DWORD *)(a2 + 56), 125);
      result = sub_10001DD0(a2, *(_DWORD *)(a2 + 56), -32648);
      *(_BYTE *)(a2 + 6) = 2;
      break;
    case 0x8022:
    case 0x8078:
      sub_10016D50(a1, a2);
      result = sub_100166D0(1, a2);
      *(_BYTE *)(a2 + 6) = 2;
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 125841) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 125841) = 0;
      break;
    case 0x8039:
      result = sub_10016690(a2);
      break;
    case 0x8033:
    case 0x8038:
      result = sub_10017F70(a2);
      break;
    case 0x806E:
      switch ( *(_BYTE *)(*(_DWORD *)(a2 + 52) + 8) )
      {
        case 0x40:
          result = sub_10016AF0(a2);
          break;
        case 0x41:
          sub_1004C220();
          result = sub_1004C0E0();
          break;
        case 0x42:
          sub_1004C2B0();
          result = sub_1004C0E0();
          break;
        case 0x43:
          sub_1004C0E0();
          v7 = *(float *)(dword_1031FB44 + 940) + *(float *)(dword_1031FB44 + 936) + *(float *)(dword_1031FB44 + 932);
          result = sub_1004C190(v7);
          break;
        default:
          return result;
      }
      break;
    case 0x8017:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8036:
    case 0x8037:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8048:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return result;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10018140) --------------------------------------------------------
int __cdecl sub_10018140(int a1)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int result; // eax@3
  float v6; // [sp+24h] [bp-10Ch]@3
  float v7; // [sp+28h] [bp-108h]@3
  char v8; // [sp+2Ch] [bp-104h]@3
  float v9; // [sp+34h] [bp-FCh]@3
  float v10; // [sp+38h] [bp-F8h]@3
  char v11; // [sp+3Ch] [bp-F4h]@3
  float v12; // [sp+44h] [bp-ECh]@3
  float v13; // [sp+48h] [bp-E8h]@3
  char v14; // [sp+4Ch] [bp-E4h]@3
  float v15; // [sp+54h] [bp-DCh]@3
  float v16; // [sp+58h] [bp-D8h]@3
  char v17; // [sp+5Ch] [bp-D4h]@3
  float v18; // [sp+64h] [bp-CCh]@3
  float v19; // [sp+68h] [bp-C8h]@3
  char v20; // [sp+6Ch] [bp-C4h]@3
  float v21; // [sp+74h] [bp-BCh]@3
  float v22; // [sp+78h] [bp-B8h]@3
  char v23; // [sp+7Ch] [bp-B4h]@3
  float v24; // [sp+84h] [bp-ACh]@3
  float v25; // [sp+88h] [bp-A8h]@3
  char v26; // [sp+8Ch] [bp-A4h]@3
  float v27; // [sp+94h] [bp-9Ch]@3
  float v28; // [sp+98h] [bp-98h]@3
  char v29; // [sp+9Ch] [bp-94h]@3
  float v30; // [sp+A4h] [bp-8Ch]@3
  float v31; // [sp+A8h] [bp-88h]@3
  char v32; // [sp+ACh] [bp-84h]@3
  float v33; // [sp+B4h] [bp-7Ch]@3
  float v34; // [sp+B8h] [bp-78h]@3
  char v35; // [sp+BCh] [bp-74h]@3
  float v36; // [sp+C4h] [bp-6Ch]@3
  float v37; // [sp+C8h] [bp-68h]@3
  char v38; // [sp+CCh] [bp-64h]@3
  float v39; // [sp+D4h] [bp-5Ch]@3
  float v40; // [sp+D8h] [bp-58h]@3
  char v41; // [sp+DCh] [bp-54h]@3
  float v42; // [sp+E4h] [bp-4Ch]@3
  float v43; // [sp+E8h] [bp-48h]@3
  char v44; // [sp+ECh] [bp-44h]@3
  float v45; // [sp+F4h] [bp-3Ch]@3
  float v46; // [sp+F8h] [bp-38h]@3
  char v47; // [sp+FCh] [bp-34h]@3
  float v48; // [sp+104h] [bp-2Ch]@3
  float v49; // [sp+108h] [bp-28h]@3
  char v50; // [sp+10Ch] [bp-24h]@3
  float v51; // [sp+114h] [bp-1Ch]@3
  float v52; // [sp+118h] [bp-18h]@3
  char v53; // [sp+11Ch] [bp-14h]@3
  char v54; // [sp+124h] [bp-Ch]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"\n#<";
  v3 = v1 + 172;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&flt_100BE2CC );
  *(float *)(v1 + 54344) = 0.0;
  *(_DWORD *)(v1 + 54352) = 2;
  *(float *)(v1 + 54348) = 0.0;
  *(_DWORD *)(v1 + 54360) = 0;
  *(_DWORD *)(v1 + 54364) = -1;
  *(float *)(v1 + 54356) = 12.0;
  *(float *)(v1 + 54368) = 0.5;
  *(float *)(v1 + 54372) = 1.0;
  *(float *)(v1 + 54376) = 40.0;
  sub_10061B00(v1 + 27224, (int)"LOAD %", dword_1031FB44 + 3912, 10.0, 15.0, 127.0, 127.0);
  sub_10060F80(dword_1031FB44 + 20480, v1 + 27224);
  sub_100612A0((int)&unk_100BDF98, 6, 0.0, v1 + 27224);
  sub_10060F20(v1 + 168, 1, v1 + 27224);
  *(_WORD *)(v1 + 32782) = 8;
  *(_BYTE *)(v1 + 32788) = 1;
  *(_DWORD *)(v1 + 32784) = &unk_100B8DC0;
  sub_10061B00(v1 + 43644, (int)"RPM", dword_1031FB44 + 4076, 10.0, 162.0, 127.0, 127.0);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 43644);
  sub_100612A0((int)&unk_100BDFF8, 6, 0.0, v1 + 43644);
  sub_10060F20(v1 + 180, 1, v1 + 43644);
  *(_WORD *)(v1 + 49202) = 6;
  *(_BYTE *)(v1 + 49208) = 1;
  *(_DWORD *)(v1 + 49204) = &unk_100B8DC0;
  sub_10046920(v1 + 10068, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 329.0, 127.0, 15.0);
  *(_DWORD *)(v1 + 10116) = v1 + 200;
  *(_WORD *)(v1 + 10584) = 33;
  *(_BYTE *)(v1 + 10592) = 1;
  *(_DWORD *)(v1 + 10588) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 37924, (int)"OIL TEMP", dword_1031FB44 + 4404, 10.0, 364.0, 127.0, 18.5, 0);
  v30 = *(float *)(dword_1031FB44 + 4408);
  v31 = -0.80000001;
  sub_100649E0((int)&v32, byte_100B8180, 7);
  v33 = *(float *)(dword_1031FB44 + 4412);
  v34 = -0.80000001;
  sub_100649E0((int)&v35, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 4404, 0.40000001, 0.0, v1 + 37924);
  sub_10049310((int)&v30, 2u, 0, v1 + 37924);
  sub_10049040(v1 + 204, 1, 0, v1 + 37924);
  *(float *)(v1 + 37988) = 73.5;
  *(float *)(v1 + 38028) = 0.5;
  *(_WORD *)(v1 + 42236) = 18;
  *(float *)(v1 + 38384) = 26.0;
  *(_BYTE *)(v1 + 42244) = 1;
  *(_DWORD *)(v1 + 42240) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 38438) = 0;
  sub_1004A1A0(v1 + 32820, (int)"OIL PRES", dword_1031FB44 + 4568, 10.0, 422.0, 127.0, 18.5, 0);
  v12 = *(float *)(dword_1031FB44 + 4572);
  v13 = -0.80000001;
  sub_100649E0((int)&v14, byte_100B8180, 7);
  v15 = *(float *)(dword_1031FB44 + 4576);
  v16 = -0.80000001;
  sub_100649E0((int)&v17, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 4568, 0.40000001, 0.0, v1 + 32820);
  sub_10049310((int)&v12, 2u, 0, v1 + 32820);
  sub_10049040(v1 + 216, 1, 0, v1 + 32820);
  *(float *)(v1 + 32884) = 73.5;
  *(_WORD *)(v1 + 37132) = 15;
  *(_BYTE *)(v1 + 37140) = 1;
  *(_DWORD *)(v1 + 37136) = &unk_100B8DC0;
  *(float *)(v1 + 32924) = 0.5;
  *(float *)(v1 + 33280) = 26.0;
  *(_BYTE *)(v1 + 33334) = 0;
  sub_1004A1A0(v1 + 4920, (int)"COOLANT TEMP", dword_1031FB44 + 4732, 10.0, 480.0, 127.0, 18.5, 0);
  v18 = *(float *)(dword_1031FB44 + 4736);
  v19 = -0.80000001;
  sub_100649E0((int)&v20, byte_100B8180, 7);
  v21 = *(float *)(dword_1031FB44 + 4740);
  v22 = -0.80000001;
  sub_100649E0((int)&v23, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 4732, 0.40000001, 0.0, v1 + 4920);
  sub_10049310((int)&v18, 2u, 0, v1 + 4920);
  sub_10049040(v1 + 228, 1, 0, v1 + 4920);
  *(float *)(v1 + 4984) = 73.5;
  *(float *)(v1 + 5024) = 0.5;
  *(_WORD *)(v1 + 9232) = 18;
  *(float *)(v1 + 5380) = 26.0;
  *(_BYTE *)(v1 + 9240) = 1;
  *(_DWORD *)(v1 + 9236) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 5434) = 0;
  sub_1004A1E0(v1 + 16404, (int)"FUEL TEMP", dword_1031FB44 + 4896, 10.0, 538.0, 127.0, 37.0, 0);
  v42 = *(float *)(dword_1031FB44 + 4900);
  v43 = -0.2;
  sub_100649E0((int)&v44, byte_100B8180, 7);
  v45 = *(float *)(dword_1031FB44 + 4900);
  v46 = 0.2;
  sub_100649E0((int)&v47, byte_100B8180, 7);
  v48 = *(float *)(dword_1031FB44 + 4904);
  v49 = -0.2;
  sub_100649E0((int)&v50, byte_100B8180, 7);
  v51 = *(float *)(dword_1031FB44 + 4904);
  v52 = 0.2;
  sub_100649E0((int)&v53, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 4896, 0.2, 0.5, v1 + 16404);
  sub_10049310((int)&v42, 4u, 0, v1 + 16404);
  sub_10049040(v1 + 240, 2, 0, v1 + 16404);
  *(_WORD *)(v1 + 20716) = 18;
  *(_BYTE *)(v1 + 20724) = 1;
  *(_DWORD *)(v1 + 20720) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 16918) = 0;
  *(_BYTE *)(v1 + 16982) = 0;
  *(float *)(v1 + 16864) = 26.0;
  *(float *)(v1 + 16928) = 26.0;
  sub_1004A1E0(v1 + 11300, (int)"FUEL QTY GAL", dword_1031FB44 + 5060, 10.0, 615.0, 127.0, 37.0, 0);
  sub_10049310((int)&unk_100BE058, 0xAu, 0, v1 + 11300);
  sub_10049040(v1 + 264, 2, 0, v1 + 11300);
  *(float *)(v1 + 11760) = 26.0;
  *(float *)(v1 + 11824) = 26.0;
  *(_WORD *)(v1 + 15612) = 31;
  *(_BYTE *)(v1 + 15620) = 1;
  *(_DWORD *)(v1 + 15616) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 11814) = 0;
  *(_BYTE *)(v1 + 11878) = 0;
  sub_1004A1A0(v1 + 49852, (int)"VOLTS", dword_1031FB44 + 5224, 10.0, 359.0, 127.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20704, v1 + 49852);
  v24 = *(float *)(dword_1031FB44 + 5228);
  v25 = -0.80000001;
  sub_100649E0((int)&v26, byte_100B8180, 7);
  v27 = *(float *)(dword_1031FB44 + 5232);
  v28 = -0.80000001;
  sub_100649E0((int)&v29, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 5224, 0.40000001, 0.0, v1 + 49852);
  sub_10049310((int)&v24, 2u, 0, v1 + 49852);
  sub_10049040(v1 + 288, 1, 1, v1 + 49852);
  *(float *)(v1 + 49956) = 0.0;
  *(float *)(v1 + 49916) = 10.0;
  *(_WORD *)(v1 + 54164) = 21;
  *(float *)(v1 + 50312) = 26.0;
  *(_BYTE *)(v1 + 54172) = 1;
  *(_DWORD *)(v1 + 54168) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 50366) = 0;
  sub_1004A1A0(v1 + 420, (int)"AMPS", dword_1031FB44 + 5388, 10.0, 417.0, 127.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20732, v1 + 420);
  v6 = *(float *)(dword_1031FB44 + 5392);
  v7 = -0.80000001;
  sprintf(&v54, "%d", (signed int)v6);
  sub_100649E0((int)&v8, &v54, 7);
  v9 = *(float *)(dword_1031FB44 + 5396);
  v10 = -0.80000001;
  sprintf(&v54, "%d", (signed int)v9);
  sub_100649E0((int)&v11, &v54, 7);
  sub_10048D80(dword_1031FB44 + 5388, 0.40000001, 0.0, v1 + 420);
  sub_10049310((int)&v6, 2u, 0, v1 + 420);
  sub_10049040(v1 + 300, 1, 1, v1 + 420);
  *(float *)(v1 + 1300) = 0.0;
  *(float *)(v1 + 1364) = 1.0;
  *(_WORD *)(v1 + 4732) = 23;
  *(_BYTE *)(v1 + 4740) = 1;
  *(_DWORD *)(v1 + 4736) = &unk_100B8DC0;
  *(float *)(v1 + 524) = 0.0;
  *(_BYTE *)(v1 + 934) = 0;
  *(float *)(v1 + 484) = 10.0;
  *(float *)(v1 + 880) = 26.0;
  sub_1004A1A0(v1 + 22732, (int)"GEARBOX C", dword_1031FB44 + 5552, 10.0, 515.0, 127.0, 18.5, 0);
  sub_100490F0(dword_1031FB44 + 20760, v1 + 22732);
  v36 = *(float *)(dword_1031FB44 + 5556);
  v37 = -0.80000001;
  sub_100649E0((int)&v38, byte_100B8180, 7);
  v39 = *(float *)(dword_1031FB44 + 5560);
  v40 = -0.80000001;
  sub_100649E0((int)&v41, byte_100B8180, 7);
  sub_10048D80(dword_1031FB44 + 5552, 0.40000001, 0.0, v1 + 22732);
  sub_10049310((int)&v36, 2u, 0, v1 + 22732);
  sub_10049040(v1 + 312, 1, 1, v1 + 22732);
  *(float *)(v1 + 22836) = 0.0;
  *(float *)(v1 + 22796) = 10.0;
  *(_WORD *)(v1 + 27044) = 17;
  *(_BYTE *)(v1 + 27052) = 1;
  *(float *)(v1 + 23192) = 26.0;
  *(_DWORD *)(v1 + 27048) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 23246) = 0;
  sub_10046920(v1 + 9412, (int)"COOLANT C", dword_1031FB44 + 5716, 10.0, 573.0, 127.0, 15.0);
  *(_WORD *)(v1 + 9928) = 17;
  *(_BYTE *)(v1 + 9936) = 1;
  *(_DWORD *)(v1 + 9932) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 9460) = v1 + 332;
  sub_10046920(v1 + 42416, (int)&unk_100BD954, dword_1031FB44 + 5880, 10.0, 633.0, 127.0, 15.0);
  *(_WORD *)(v1 + 42932) = 17;
  *(_BYTE *)(v1 + 42940) = 1;
  *(_DWORD *)(v1 + 42936) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 42464) = v1 + 344;
  sub_10046920(v1 + 37312, (int)&unk_100BD950, dword_1031FB44 + 6044, 10.0, 668.0, 127.0, 15.0);
  *(_WORD *)(v1 + 37828) = 16;
  *(_BYTE *)(v1 + 37836) = 1;
  *(_DWORD *)(v1 + 37832) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 37360) = v1 + 356;
  sub_10046920(v1 + 10680, (int)"FFLOW GPH", dword_1031FB44 + 4240, 10.0, 354.0, 127.0, 15.0);
  *(_DWORD *)(v1 + 10728) = v1 + 200;
  *(_WORD *)(v1 + 11196) = 33;
  *(_BYTE *)(v1 + 11204) = 1;
  *(_DWORD *)(v1 + 11200) = &unk_100B8DC0;
  sub_10046960(v1 + 15792, (int)"GAL", dword_1031FB44 + 5060, 10.0, 384.0, 127.0, 15.0);
  *(_WORD *)(v1 + 16308) = 30;
  *(_BYTE *)(v1 + 16316) = 1;
  *(_DWORD *)(v1 + 16312) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 15840) = v1 + 272;
  *(_DWORD *)(v1 + 15888) = v1 + 284;
  *(float *)(v1 + 15972) = 384.0;
  *(float *)(v1 + 15824) = 384.0;
  *(float *)(v1 + 15872) = 384.0;
  sub_10046960(v1 + 20896, (int)&unk_100BD954, dword_1031FB44 + 4896, 10.0, 414.0, 127.0, 15.0);
  *(_WORD *)(v1 + 21412) = 17;
  *(_BYTE *)(v1 + 21420) = 1;
  *(_DWORD *)(v1 + 21416) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 20944) = v1 + 248;
  *(_DWORD *)(v1 + 20992) = v1 + 260;
  *(float *)(v1 + 21076) = 414.0;
  *(float *)(v1 + 20928) = 414.0;
  *(float *)(v1 + 20976) = 414.0;
  sub_10046920(v1 + 21508, (int)"GAL REM", dword_1031FB44 + 6208, 10.0, 479.0, 127.0, 15.0);
  *(_WORD *)(v1 + 22024) = 31;
  *(_BYTE *)(v1 + 22032) = 1;
  *(_DWORD *)(v1 + 22028) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 21556) = v1 + 368;
  sub_10046920(v1 + 22120, (int)"GAL USED", dword_1031FB44 + 6372, 10.0, 509.0, 127.0, 15.0);
  *(_WORD *)(v1 + 22636) = 31;
  *(_BYTE *)(v1 + 22644) = 1;
  *(_DWORD *)(v1 + 22640) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 22168) = v1 + 380;
  *(_WORD *)(v1 + 10024) = 4142;
  *(_DWORD *)(v1 + 10028) = -1;
  *(_DWORD *)(v1 + 10032) = 0;
  *(float *)(v1 + 10036) = 15.0;
  *(float *)(v1 + 10040) = 60.0;
  *(_DWORD *)(v1 + 10044) = sub_10065060(*(float *)(v1 + 10036));
  *(float *)(v1 + 10048) = 1.0;
  *(float *)(v1 + 10052) = 1.0;
  *(float *)(v1 + 10060) = 137.0;
  *(float *)(v1 + 10064) = 539.0;
  sub_10046920(v1 + 43032, (int)"RANGE NM", dword_1031FB44 + 6700, 10.0, 569.0, 127.0, 15.0);
  *(_WORD *)(v1 + 43548) = 38;
  *(_BYTE *)(v1 + 43556) = 1;
  *(_DWORD *)(v1 + 43552) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 43080) = v1 + 404;
  sub_10046920(v1 + 49240, (int)"HRS", dword_1031FB44 + 6864, 10.0, 681.0, 127.0, 15.0);
  *(_WORD *)(v1 + 49756) = 39;
  *(_BYTE *)(v1 + 49764) = 1;
  result = v1 + 416;
  *(_DWORD *)(v1 + 49288) = v1 + 416;
  *(float *)(v1 + 49300) = 0.0;
  *(float *)(v1 + 49268) = 22.0;
  *(float *)(v1 + 49456) = 1.0;
  *(float *)(v1 + 49416) = 119.0;
  return result;
}
// 100BE2CC: using guessed type float flt_100BE2CC;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10019250) --------------------------------------------------------
int __usercall sub_10019250@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE1AC, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 128),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 108),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 148),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100192D0) --------------------------------------------------------
char __usercall sub_100192D0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char v2; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 43028) = v2;
  if ( v2 && v2 != 1 && v2 != 2 )
    sub_10051A40(".\\cdp_pg_eis_diamond_da40d.c", 1668, 1, 0);
  sub_1004C170(*(_BYTE *)(v1 + 43028));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10019330) --------------------------------------------------------
char __usercall sub_10019330@<al>(int a1@<edi>, __int16 a2, __int16 a3)
{
  int v3; // esi@1
  int v4; // ebx@7
  int v5; // eax@7
  char result; // al@7
  int v7; // [sp+18h] [bp-Ch]@2
  float v8; // [sp+1Ch] [bp-8h]@1
  int v9; // [sp+20h] [bp-4h]@7

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 54388, 0);
  *(_DWORD *)(v3 + 54380) = sub_1008C780();
  *(_BYTE *)(v3 + 54384) = 0;
  *(_DWORD *)(v3 + 128) = &unk_100BE1C0;
  *(_DWORD *)(v3 + 136) = &unk_100BE228;
  *(_DWORD *)(v3 + 132) = &unk_100BE1F4;
  *(_DWORD *)(v3 + 108) = v3 + 8;
  *(_DWORD *)(v3 + 112) = v3 + 64;
  *(_DWORD *)(v3 + 148) = v3 + 88;
  *(_DWORD *)(v3 + 156) = v3 + 94;
  *(_DWORD *)(v3 + 152) = v3 + 102;
  *(_DWORD *)(v3 + 116) = v3 + 32;
  *(_BYTE *)(v3 + 88) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 148) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 148) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 148) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 148) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 148) + 5) = 3;
  **(_BYTE **)(v3 + 152) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 152) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 152) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 152) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 152) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 152) + 5) = 3;
  **(_BYTE **)(v3 + 156) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 156) + 7) = 3;
  sub_100011B0(a1, a2, a3, 151, 686, 3);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BDF94);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10018140(a1);
  if ( !sub_10066790(3u, &v8) || !sub_10031F70(100.0, v8, (int)&v7) )
    v7 = 0;
  sub_10066730(v3 + 4912, v7, 1.0, 0.125);
  if ( !sub_100663D0(&v8) || !sub_10031F70(100000.0, v8, (int)&v7) )
    v7 = 0;
  sub_10066730(v3 + 11292, v7, 1.0, 0.125);
  v4 = v3 + 8;
  *(_DWORD *)v3 = v3 + 27224;
  *(_DWORD *)(v3 + 4) = v3 + 43644;
  *(_DWORD *)(v4 + 4) = v3 + 10068;
  *(_DWORD *)(v4 + 8) = v3 + 37924;
  *(_DWORD *)(v4 + 12) = v3 + 32820;
  *(_DWORD *)(v4 + 16) = v3 + 4920;
  v5 = v3 + 64;
  *(_DWORD *)(v4 + 20) = v3 + 16404;
  *(_DWORD *)v4 = v3 + 11300;
  *(_DWORD *)v5 = v3 + 49852;
  *(_DWORD *)(v5 + 4) = v3 + 420;
  *(_DWORD *)(v5 + 8) = v3 + 22732;
  *(_DWORD *)(v5 + 12) = v3 + 9412;
  v9 = v3 + 64;
  *(_DWORD *)(v5 + 16) = v3 + 42416;
  *(_DWORD *)(v5 + 20) = v3 + 37312;
  *(_DWORD *)(v3 + 32) = v3 + 10680;
  *(_DWORD *)(v3 + 36) = v3 + 15792;
  *(_DWORD *)(v3 + 40) = v3 + 20896;
  *(_DWORD *)(v3 + 44) = v3 + 21508;
  *(_DWORD *)(v3 + 48) = v3 + 22120;
  *(_DWORD *)(v3 + 52) = v3 + 10024;
  *(_DWORD *)(v3 + 56) = v3 + 43032;
  *(_DWORD *)(v3 + 60) = v3 + 49240;
  *(_BYTE *)(v3 + 43028) = sub_1004BF10((void *)(v3 + 49240));
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE1AC, v3, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE1C0, v3 + 8, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE1F4, v9, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100196C0) --------------------------------------------------------
void __usercall sub_100196C0(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // eax@1
  signed int v3; // ecx@1
  int v4; // edx@10
  int v5; // ecx@10
  double v6; // st7@10
  double v7; // st7@10
  double v8; // st7@10
  float v9; // [sp+Ch] [bp-18h]@0
  float v10; // [sp+14h] [bp-10h]@3
  int v11; // [sp+18h] [bp-Ch]@8
  float v12; // [sp+1Ch] [bp-8h]@10
  float v13; // [sp+20h] [bp-4h]@10

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 172);
  v3 = 21;
  do
  {
    *v2 = 9.8999998e24;
    v2 += 3;
    --v3;
  }
  while ( v3 );
  *(float *)(v1 + 184) = sub_1004C3E0(0x1Eu);
  *(float *)(v1 + 412) = sub_1004C070();
  if ( sub_100664A0(&v10) )
    *(float *)(v1 + 268) = v10;
  if ( sub_10066510(&v10) )
    *(float *)(v1 + 280) = v10;
  if ( sub_100663D0(&v10) && sub_10031F70(100000.0, v10, (int)&v11) )
  {
    sub_100666C0(v1 + 11292, v11);
    *(float *)(v1 + 196) = (double)*(signed int *)(v1 + 11296) / 100000.0;
  }
  *(float *)(v1 + 364) = sub_1004C0C0();
  *(float *)(v1 + 376) = sub_1004C0D0(v5, v4);
  *(_DWORD *)(v1 + 10056) = sub_1004BF40();
  *(float *)(v1 + 400) = sub_1004BFF0(v9);
  v12 = sub_1004C3E0(0x1Du);
  v6 = v12;
  *(float *)(v1 + 208) = v12;
  *(float *)(v1 + 340) = v6;
  *(float *)(v1 + 244) = sub_1004C3E0(0x4Eu);
  *(float *)(v1 + 256) = sub_1004C3E0(0x4Fu);
  v12 = sub_1004C3E0(0x59u);
  v7 = v12;
  *(float *)(v1 + 232) = v12;
  *(float *)(v1 + 328) = v7;
  *(float *)(v1 + 316) = sub_1004C3E0(0x5Bu);
  *(float *)(v1 + 172) = sub_1004C3E0(0x5Eu);
  v12 = sub_1004C3E0(0x1Cu);
  v8 = v12;
  *(float *)(v1 + 220) = v12;
  *(float *)(v1 + 352) = v8;
  if ( sub_10066790(1u, &v13) && sub_10031F70(100.0, v13, (int)&v11) )
  {
    sub_100666C0(v1 + 4912, v11);
    *(float *)(v1 + 304) = (double)*(signed int *)(v1 + 4916) / 100.0;
  }
  *(float *)(v1 + 292) = sub_1004C3E0(4u);
  sub_1004C380(v1 + 168, 0x15u);
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (100198D0) --------------------------------------------------------
void __usercall sub_100198D0(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // ecx@1
  int v3; // edx@2
  float *v4; // edi@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_1008C780();
  if ( *(_DWORD *)(v1 + 54380) > v2
    || (v3 = dword_1031FB44, *(float *)(dword_1031FB44 + 29628) >= (double)**(float **)(v1 + 43692)) )
  {
    *(_DWORD *)(v1 + 54380) = v2;
    v3 = dword_1031FB44;
  }
  v4 = *(float **)(v1 + 43692);
  if ( *(float *)(v3 + 29632) < (double)*v4 || *(float *)(v3 + 4124) <= (double)(v2 - *(_DWORD *)(v1 + 54380)) )
  {
    *(_BYTE *)(v1 + 8 * *(_BYTE *)(v3 + 4076) + 45604) = 16;
  }
  else if ( *(float *)(v1 + 45608) >= (double)*v4 || *(_BYTE *)(v1 + 45620) != 11 )
  {
    *(_BYTE *)(v1 + 8 * *(_BYTE *)(v3 + 4076) + 45604) = 10;
  }
  else
  {
    *(_BYTE *)(v1 + 8 * *(_BYTE *)(v3 + 4076) + 45604) = 11;
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100199B0) --------------------------------------------------------
char __usercall sub_100199B0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  char result; // al@1
  float *v3; // ebp@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100196C0(a1);
  sub_100198D0(a1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE0F8, (int)&unk_100BE26C, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE1AC, v1, 0, 255);
  sub_100653C0(
    a1,
    *(_WORD **)(a1 + 52),
    *(char **)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 128),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 108),
    *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 43028) + 148),
    255);
  result = *(_BYTE *)(v1 + 43028);
  if ( result == 1 )
  {
    j_gdi_pvg_color_u32(-1);
    sub_1008C110(1.0);
    j_gdi_pvg_begin(64);
    sub_1008C2F0(10.0, 319.0);
    sub_1008C2F0(137.0, 319.0);
    sub_1008C2F0(10.0, 475.5);
    sub_1008C2F0(137.0, 475.5);
    sub_1008C2F0(10.0, 598.0);
    sub_1008C2F0(137.0, 598.0);
    j_gdi_pvg_end();
    *(float *)(v1 + 54344) = 75.5;
    *(float *)(v1 + 54348) = 319.0;
    *(_DWORD *)(v1 + 54360) = -14671840;
    *(_DWORD *)(v1 + 54364) = -1;
    *(float *)(v1 + 54368) = 0.5;
    *(float *)(v1 + 54372) = 0.5;
    *(float *)(v1 + 54376) = sub_1008D010(2, (int)"ELECTRICAL", 12.0);
    sub_10065B50(a1, (int)"ELECTRICAL", v1 + 54344);
    *(float *)(v1 + 54348) = 475.5;
    *(float *)(v1 + 54376) = sub_1008D010(2, (int)"ENGINE", 12.0);
    sub_10065B50(a1, (int)"ENGINE", v1 + 54344);
    *(float *)(v1 + 54348) = 598.0;
    *(float *)(v1 + 54376) = sub_1008D010(2, (int)"OIL", 12.0);
    result = sub_10065B50(a1, (int)"OIL", v1 + 54344);
    *(_BYTE *)(a1 + 6) = 2;
  }
  else
  {
    if ( result == 2 )
    {
      j_gdi_pvg_color_u32(-1);
      sub_1008C110(1.0);
      j_gdi_pvg_begin(64);
      sub_1008C2F0(10.0, 319.0);
      sub_1008C2F0(137.0, 319.0);
      sub_1008C2F0(10.0, 444.0);
      sub_1008C2F0(137.0, 444.0);
      sub_1008C2F0(10.0, 661.0);
      sub_1008C2F0(137.0, 661.0);
      j_gdi_pvg_end();
      *(float *)(v1 + 54344) = 75.5;
      v3 = (float *)(v1 + 54344);
      *(float *)(v1 + 54348) = 319.0;
      *(_DWORD *)(v1 + 54360) = -14671840;
      *(_DWORD *)(v1 + 54364) = -1;
      *(float *)(v1 + 54368) = 0.5;
      *(float *)(v1 + 54372) = 0.5;
      *(float *)(v1 + 54376) = sub_1008D010(2, (int)"FUEL", 12.0);
      sub_10065B50(a1, (int)"FUEL", v1 + 54344);
      *(float *)(v1 + 54348) = 444.0;
      *(float *)(v1 + 54376) = sub_1008D010(2, (int)"FUEL CALC", 12.0);
      sub_10065B50(a1, (int)"FUEL CALC", v1 + 54344);
      *v3 = 72.5;
      *(float *)(v1 + 54348) = 651.0;
      *(float *)(v1 + 54376) = sub_1008D010(2, (int)"TTL TIME IN SVC", 12.0);
      sub_10065B50(a1, (int)"TTL TIME IN SVC", v1 + 54344);
      *v3 = 10.0;
      *(float *)(v1 + 54348) = 539.0;
      *(float *)(v1 + 54376) = sub_1008D010(2, (int)"ENDUR", 12.0);
      *(float *)(v1 + 54368) = 0.0;
      *(float *)(v1 + 54372) = 1.0;
      result = sub_10065B50(a1, (int)"ENDUR", v1 + 54344);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10019DC0) --------------------------------------------------------
char __cdecl sub_10019DC0(int a1, char a2, char a3)
{
  int v3; // eax@1
  __int16 v4; // cx@4
  __int16 v5; // ax@7

  v3 = **(_WORD **)(a1 + 52);
  switch ( v3 )
  {
    case 32789:
    case 32790:
      LOBYTE(v3) = sub_10019250(a1);
      break;
    case 32833:
      if ( a2 )
      {
        v4 = 47;
        if ( a3 )
        {
          if ( a3 == 1 )
          {
            v5 = 151;
          }
          else if ( a3 == 2 )
          {
            v5 = 302;
          }
          else
          {
            v5 = a1;
          }
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        v5 = 0;
        v4 = 0;
      }
      LOBYTE(v3) = sub_10019330(a1, v5, v4);
      if ( a2 )
      {
        v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
        *(_BYTE *)(v3 + 43028) = a3;
      }
      break;
    case 32802:
    case 32888:
      LOBYTE(v3) = sub_100199B0(a1);
      break;
    case 32821:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54384) = 0;
      break;
    case 32820:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 54384) = 1;
      break;
    case 32825:
      LOBYTE(v3) = sub_100192D0(a1);
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10019F00) --------------------------------------------------------
int __usercall sub_10019F00@<eax>(int a1@<eax>)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  qmemcpy((void *)(result + 1236), (const void *)(dword_1031FB44 + 868), 0x20u);
  qmemcpy((void *)(result + 636), (const void *)(dword_1031FB44 + 988), 0x20u);
  qmemcpy((void *)(result + 524), (const void *)(dword_1031FB44 + 292), 0x20u);
  qmemcpy((void *)(result + 1124), (const void *)(dword_1031FB44 + 804), 0x20u);
  qmemcpy((void *)(result + 1028), (const void *)(dword_1031FB44 + 740), 0x20u);
  qmemcpy((void *)(result + 216), (const void *)(dword_1031FB44 + 36), 0x20u);
  qmemcpy((void *)(result + 1448), (const void *)(dword_1031FB44 + 1084), 0x20u);
  qmemcpy((void *)(result + 732), (const void *)(dword_1031FB44 + 1372), 0x20u);
  qmemcpy((void *)(result + 328), (const void *)(dword_1031FB44 + 1436), 0x20u);
  qmemcpy((void *)(result + 836), (const void *)(dword_1031FB44 + 1500), 0x20u);
  qmemcpy((void *)(result + 932), (const void *)(dword_1031FB44 + 1564), 0x20u);
  qmemcpy((void *)(result + 424), (const void *)(dword_1031FB44 + 20312), 0x20u);
  qmemcpy((void *)(result + 1332), (const void *)(dword_1031FB44 + 3876), 0x20u);
  *(_WORD *)(result + 460) = 1801;
  *(_WORD *)(result + 1368) = 5758;
  *(_WORD *)(result + 704) = 76;
  *(_WORD *)(result + 711) = 82;
  *(_WORD *)(result + 592) = 76;
  *(_WORD *)(result + 599) = 82;
  *(_WORD *)(result + 1192) = 76;
  *(_WORD *)(result + 1199) = 82;
  *(_WORD *)(result + 1096) = 76;
  *(_WORD *)(result + 1103) = 82;
  *(_WORD *)(result + 284) = 76;
  *(_WORD *)(result + 291) = 82;
  *(_WORD *)(result + 1516) = 76;
  *(_WORD *)(result + 1523) = 82;
  *(_WORD *)(result + 396) = 76;
  *(_WORD *)(result + 403) = 82;
  *(_WORD *)(result + 800) = 76;
  *(_WORD *)(result + 807) = 82;
  *(_WORD *)(result + 904) = 76;
  *(_WORD *)(result + 911) = 82;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001A0F0) --------------------------------------------------------
bool __usercall sub_1001A0F0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  bool result; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BEAB0, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_1004AA20(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 1216) + 172),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 1216) + 152),
             0,
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1001A160) --------------------------------------------------------
char __usercall sub_1001A160@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char v2; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 1216) = v2;
  if ( v2 && v2 != 1 && v2 != 2 )
    sub_10051A40(".\\cdp_pg_eis_diamond_da42.c", 1290, 1, 0);
  sub_1004C170(*(_BYTE *)(v1 + 1216));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1001A1C0) --------------------------------------------------------
char __usercall sub_1001A1C0@<al>(int a1@<ebx>, __int16 a2, __int16 a3)
{
  int v3; // eax@1
  int v4; // esi@1
  signed int v5; // eax@1
  char *v6; // eax@7
  _BYTE *v7; // edi@7
  char v8; // cl@8
  char *v9; // eax@9
  _BYTE *v10; // edx@9
  char v11; // cl@10
  int *v12; // edi@11
  signed int v13; // ebp@11
  char result; // al@13

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 1544, 0);
  v4 = v3;
  *(_BYTE *)(v3 + 1540) = 0;
  *(_DWORD *)(v3 + 172) = &unk_100BEB10;
  *(_DWORD *)(v3 + 180) = &unk_100BEC20;
  *(_DWORD *)(v3 + 176) = &unk_100BEB90;
  *(_DWORD *)(v3 + 152) = v3 + 20;
  *(_DWORD *)(v3 + 192) = v3 + 121;
  v3 += 116;
  *(_DWORD *)(v4 + 148) = v3;
  *(_DWORD *)(v4 + 200) = v4 + 127;
  *(_DWORD *)(v4 + 196) = v4 + 138;
  *(_DWORD *)(v4 + 160) = v4 + 44;
  *(_DWORD *)(v4 + 156) = v4 + 88;
  *(_BYTE *)v3 = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 148) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 148) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 148) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 148) + 4) = 3;
  **(_BYTE **)(v4 + 192) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 192) + 5) = 3;
  **(_BYTE **)(v4 + 196) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v4 + 196) + 6) = 3;
  v5 = 0;
  do
    *(_BYTE *)(v5++ + *(_DWORD *)(v4 + 200)) = 3;
  while ( v5 < 11 );
  if ( sub_1006C420(0x6Du) != 1 )
    *(_BYTE *)(*(_DWORD *)(v4 + 196) + 6) = 0;
  if ( sub_1006C420(0x67u) != 1 )
  {
    *(_BYTE *)(*(_DWORD *)(v4 + 148) + 2) = 0;
    *(_BYTE *)(*(_DWORD *)(v4 + 148) + 3) = 0;
    *(_BYTE *)(*(_DWORD *)(v4 + 148) + 4) = 0;
  }
  sub_100011B0(a1, a2, a3, 151, 686, 1);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BE98C);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10019F00(a1);
  sub_10066730(v4 + 308, 0, 1.0, 0.125);
  sub_10066730(v4 + 316, 0, 1.0, 0.125);
  sub_10066730(v4 + 616, 0, 1.0, 0.125);
  sub_10066730(v4 + 624, 0, 1.0, 0.125);
  *(_DWORD *)(v4 + 4) = v4 + 928;
  *(_DWORD *)(v4 + 12) = v4 + 1424;
  *(_DWORD *)v4 = v4 + 1232;
  *(_DWORD *)(v4 + 8) = v4 + 1328;
  *(_DWORD *)(v4 + 16) = v4 + 1426;
  *(_DWORD *)(v4 + 28) = v4 + 1120;
  *(_DWORD *)(v4 + 32) = v4 + 1024;
  *(_DWORD *)(v4 + 36) = v4 + 324;
  *(_DWORD *)(v4 + 40) = v4 + 728;
  *(_DWORD *)(v4 + 20) = v4 + 632;
  *(_DWORD *)(v4 + 24) = v4 + 520;
  *(_DWORD *)(v4 + 92) = v4 + 1024;
  *(_DWORD *)(v4 + 88) = v4 + 1120;
  *(_DWORD *)(v4 + 96) = v4 + 1444;
  *(_DWORD *)(v4 + 100) = v4 + 212;
  *(_DWORD *)(v4 + 104) = v4 + 324;
  *(_DWORD *)(v4 + 108) = v4 + 832;
  *(_DWORD *)(v4 + 112) = v4 + 420;
  *(_DWORD *)(v4 + 44) = v4 + 632;
  *(_DWORD *)(v4 + 52) = v4 + 728;
  *(_DWORD *)(v4 + 56) = v4 + 824;
  *(_DWORD *)(v4 + 64) = v4 + 824;
  *(_DWORD *)(v4 + 68) = v4 + 828;
  *(_DWORD *)(v4 + 72) = v4 + 516;
  *(_DWORD *)(v4 + 76) = v4 + 1220;
  *(_DWORD *)(v4 + 80) = v4 + 1228;
  *(_DWORD *)(v4 + 48) = v4 + 520;
  *(_DWORD *)(v4 + 60) = v4 + 1224;
  *(_DWORD *)(v4 + 84) = v4 + 1440;
  *(_BYTE *)(v4 + 1216) = sub_1004BF10((void *)(v4 + 520));
  *(float *)(v4 + 1440) = sub_1004C070();
  *(float *)(v4 + 828) = 9.8999998e24;
  *(float *)(v4 + 1224) = 9.8999998e24;
  *(_DWORD *)(v4 + 516) = 0x7FFFFFFF;
  *(float *)(v4 + 1220) = 9.8999998e24;
  v6 = sub_1006C690(2u, 0);
  v7 = (_BYTE *)(v4 + 1228);
  do
  {
    v8 = *v6;
    *v7++ = *v6++;
  }
  while ( v8 );
  v9 = sub_1006C690(0x15u, 0);
  v10 = (_BYTE *)(v4 + 824);
  do
  {
    v11 = *v9;
    *v10++ = *v9++;
  }
  while ( v11 );
  *(_WORD *)(v4 + 1424) = 76;
  *(_WORD *)(v4 + 1426) = 82;
  v12 = (int *)(v4 + 1428);
  v13 = 3;
  do
  {
    *v12 = sub_1008C780();
    ++v12;
    --v13;
  }
  while ( v13 );
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BEAB0, v4, 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v4 + 172), *(_DWORD *)(v4 + 152), 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v4 + 176), *(_DWORD *)(v4 + 156), 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v4 + 180), *(_DWORD *)(v4 + 160), 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1001A660) --------------------------------------------------------
char __usercall sub_1001A660@<al>(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // ebx@1
  float *v3; // ebp@1
  double v4; // st7@2
  double v5; // st7@4
  float *v6; // ebx@5
  float *v7; // ebp@5
  char v8; // al@5
  bool v9; // zf@5
  double v10; // st7@6
  double v11; // st7@8
  char v12; // al@9
  char *v13; // edi@9
  char v14; // al@10
  char v15; // al@12
  char v16; // al@13
  double v17; // st7@16
  double v18; // st7@18
  char v19; // bl@19
  char *v20; // eax@19
  _BYTE *v21; // edx@19
  char v22; // cl@20
  char *v23; // eax@21
  int v24; // ecx@21
  _BYTE *v25; // edx@21
  double v26; // st7@24
  double v27; // st7@25
  float *v28; // ebx@31
  float *v29; // ebp@31
  char v30; // al@31
  double v31; // st7@32
  double v32; // st7@34
  float *v33; // ebx@35
  float *v34; // ebp@35
  char v35; // al@35
  double v36; // st7@36
  double v37; // st7@38
  float *v38; // ebx@39
  float *v39; // ebp@39
  char v40; // al@39
  double v41; // st7@40
  double v42; // st7@42
  float *v43; // ebx@43
  float *v44; // ebp@43
  char v45; // al@43
  double v46; // st7@44
  double v47; // st7@46
  float *v48; // ebx@47
  float *v49; // ebp@47
  char v50; // al@47
  double v51; // st7@48
  double v52; // st7@50
  float *v53; // ebx@51
  float *v54; // ebp@51
  char v55; // al@51
  double v56; // st7@52
  double v57; // st7@54
  char v58; // al@55
  char *v59; // edi@55
  char v60; // al@56
  char v61; // al@58
  char v62; // al@59
  double v63; // st7@62
  double v64; // st7@64
  float *v65; // ebx@65
  float *v66; // ebp@65
  char v67; // al@65
  double v68; // st7@66
  double v69; // st7@68
  float *v70; // edi@69
  char result; // al@69
  double v72; // st7@70
  int v73; // [sp+20h] [bp-18h]@10
  float v74; // [sp+24h] [bp-14h]@9
  float v75; // [sp+28h] [bp-10h]@55
  double v76; // [sp+2Ch] [bp-Ch]@23
  float v77; // [sp+34h] [bp-4h]@27

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 1280);
  v3 = (float *)(v1 + 1284);
  *(_BYTE *)(v1 + 1232) = sub_10066790(0x1Eu, (float *)(v1 + 1280));
  *(_BYTE *)(v1 + 1233) = sub_10066790(0x37u, (float *)(v1 + 1284));
  *(float *)(v1 + 1440) = sub_1004C070();
  if ( *(_BYTE *)(v1 + 1232) )
  {
    v4 = *v2;
    sub_1003B0B0(*v2, *(float *)(v1 + 1292), (int)&unk_100BEAB0, v1 + 1232);
    *(float *)(v1 + 1292) = v4;
  }
  if ( *(_BYTE *)(v1 + 1233) )
  {
    v5 = *v3;
    sub_1003B0B0(*v3, *(float *)(v1 + 1296), (int)&unk_100BEAB0, v1 + 1232);
    *(float *)(v1 + 1296) = v5;
  }
  v6 = (float *)(v1 + 680);
  *(_BYTE *)(v1 + 1328) = sub_10066930(v1, 0x67u, (float *)(v1 + 1376));
  v7 = (float *)(v1 + 684);
  *(_BYTE *)(v1 + 632) = sub_100664A0((float *)(v1 + 680));
  v8 = sub_10066510((float *)(v1 + 684));
  v9 = *(_BYTE *)(v1 + 632) == 0;
  *(_BYTE *)(v1 + 633) = v8;
  if ( !v9 )
  {
    v10 = *v6;
    sub_1003B0B0(*v6, *(float *)(v1 + 692), (int)&unk_100BEB10, v1 + 632);
    *(float *)(v1 + 692) = v10;
  }
  if ( *(_BYTE *)(v1 + 633) )
  {
    v11 = *v7;
    sub_1003B0B0(*v7, *(float *)(v1 + 696), (int)&unk_100BEB10, v1 + 632);
    *(float *)(v1 + 696) = v11;
  }
  v12 = sub_100663D0(&v74);
  v13 = (char *)(v1 + 520);
  *(_BYTE *)(v1 + 520) = v12;
  if ( v12 )
  {
    v14 = sub_10031F70(100000.0, v74, (int)&v73);
    *v13 = v14;
    if ( v14 )
    {
      sub_100666C0(v1 + 616, v73);
      *(float *)(v1 + 568) = (double)*(signed int *)(v1 + 620) / 100000.0;
    }
  }
  v15 = sub_100663F0(&v74);
  *(_BYTE *)(v1 + 521) = v15;
  if ( v15 )
  {
    v16 = sub_10031F70(100000.0, v74, (int)&v73);
    *(_BYTE *)(v1 + 521) = v16;
    if ( v16 )
    {
      sub_100666C0(v1 + 624, v73);
      *(float *)(v1 + 572) = (double)*(signed int *)(v1 + 628) / 100000.0;
    }
  }
  if ( *v13 )
  {
    v17 = *(float *)(v1 + 568);
    sub_1003B0B0(*(float *)(v1 + 568), *(float *)(v1 + 580), (int)&unk_100BEB24, v1 + 520);
    *(float *)(v1 + 580) = v17;
  }
  if ( *(_BYTE *)(v1 + 521) )
  {
    v18 = *(float *)(v1 + 572);
    sub_1003B0B0(*(float *)(v1 + 572), *(float *)(v1 + 584), (int)&unk_100BEB24, v1 + 520);
    *(float *)(v1 + 584) = v18;
  }
  v19 = sub_10066410(&v74);
  v20 = sub_1006C690(0x1215u, 0);
  v21 = (_BYTE *)(v1 + 824);
  do
  {
    v22 = *v20;
    *v21++ = *v20++;
  }
  while ( v22 );
  v23 = sub_1006C690(2u, 0);
  v25 = (_BYTE *)(v1 + 1228);
  do
  {
    LOBYTE(v24) = *v23;
    *v25++ = *v23++;
  }
  while ( (_BYTE)v24 );
  *(float *)(v1 + 828) = sub_1004C0D0(v24, v25);
  *(float *)(v1 + 1224) = sub_1004C0C0();
  v76 = *(float *)(v1 + 828);
  if ( sub_1004BFC0() < v76 )
  {
    *(float *)(v1 + 828) = sub_1004BFC0();
    v26 = 0.0;
    *(_DWORD *)(v1 + 516) = 0;
    *(float *)(v1 + 1224) = 0.0;
    goto LABEL_31;
  }
  *(float *)&v76 = sub_1004C0C0();
  v27 = *(float *)&v76;
  *(float *)(v1 + 1224) = *(float *)&v76;
  if ( v19 && 360000.0 * v74 > v27 )
  {
    *(_DWORD *)(v1 + 516) = (signed int)(v27 / v74);
    if ( sub_1006CA40(&v77) )
    {
      v26 = (double)*(signed int *)(v1 + 516) * v77;
      goto LABEL_31;
    }
  }
  else
  {
    *(_DWORD *)(v1 + 516) = 0x7FFFFFFF;
  }
  v26 = 9.8999998e24;
LABEL_31:
  v28 = (float *)(v1 + 1168);
  *(float *)(v1 + 1220) = v26;
  v29 = (float *)(v1 + 1172);
  *(_BYTE *)(v1 + 1120) = sub_10066790(0x1Du, (float *)(v1 + 1168));
  v30 = sub_10066790(0x36u, (float *)(v1 + 1172));
  v9 = *(_BYTE *)(v1 + 1120) == 0;
  *(_BYTE *)(v1 + 1121) = v30;
  if ( !v9 )
  {
    v31 = *v28;
    sub_1003B0B0(*v28, *(float *)(v1 + 1180), (int)&unk_100BEB38, v1 + 1120);
    *(float *)(v1 + 1180) = v31;
  }
  if ( *(_BYTE *)(v1 + 1121) )
  {
    v32 = *v29;
    sub_1003B0B0(*v29, *(float *)(v1 + 1184), (int)&unk_100BEB38, v1 + 1120);
    *(float *)(v1 + 1184) = v32;
  }
  v33 = (float *)(v1 + 776);
  v34 = (float *)(v1 + 780);
  *(_BYTE *)(v1 + 728) = sub_10066790(0x4Eu, (float *)(v1 + 776));
  v35 = sub_10066790(0x4Fu, (float *)(v1 + 780));
  v9 = *(_BYTE *)(v1 + 728) == 0;
  *(_BYTE *)(v1 + 729) = v35;
  if ( !v9 )
  {
    v36 = *v33;
    sub_1003B0B0(*v33, *(float *)(v1 + 788), (int)&unk_100BEB74, v1 + 728);
    *(float *)(v1 + 788) = v36;
  }
  if ( *(_BYTE *)(v1 + 729) )
  {
    v37 = *v34;
    sub_1003B0B0(*v34, *(float *)(v1 + 792), (int)&unk_100BEB74, v1 + 728);
    *(float *)(v1 + 792) = v37;
  }
  v38 = (float *)(v1 + 372);
  v39 = (float *)(v1 + 376);
  *(_BYTE *)(v1 + 324) = sub_10066790(0x59u, (float *)(v1 + 372));
  v40 = sub_10066790(0x5Au, (float *)(v1 + 376));
  v9 = *(_BYTE *)(v1 + 324) == 0;
  *(_BYTE *)(v1 + 325) = v40;
  if ( !v9 )
  {
    v41 = *v38;
    sub_1003B0B0(*v38, *(float *)(v1 + 384), (int)&unk_100BEB60, v1 + 324);
    *(float *)(v1 + 384) = v41;
  }
  if ( *(_BYTE *)(v1 + 325) )
  {
    v42 = *v39;
    sub_1003B0B0(*v39, *(float *)(v1 + 388), (int)&unk_100BEB60, v1 + 324);
    *(float *)(v1 + 388) = v42;
  }
  v43 = (float *)(v1 + 880);
  v44 = (float *)(v1 + 884);
  *(_BYTE *)(v1 + 832) = sub_10066790(0x5Bu, (float *)(v1 + 880));
  v45 = sub_10066790(0x5Cu, (float *)(v1 + 884));
  v9 = *(_BYTE *)(v1 + 832) == 0;
  *(_BYTE *)(v1 + 833) = v45;
  if ( !v9 )
  {
    v46 = *v43;
    sub_1003B0B0(*v43, *(float *)(v1 + 892), (int)&unk_100BEBF4, v1 + 832);
    *(float *)(v1 + 892) = v46;
  }
  if ( *(_BYTE *)(v1 + 833) )
  {
    v47 = *v44;
    sub_1003B0B0(*v44, *(float *)(v1 + 896), (int)&unk_100BEBF4, v1 + 832);
    *(float *)(v1 + 896) = v47;
  }
  v48 = (float *)(v1 + 976);
  v49 = (float *)(v1 + 980);
  *(_BYTE *)(v1 + 928) = sub_10066790(0x5Eu, (float *)(v1 + 976));
  v50 = sub_10066790(0x5Fu, (float *)(v1 + 980));
  v9 = *(_BYTE *)(v1 + 928) == 0;
  *(_BYTE *)(v1 + 929) = v50;
  if ( !v9 )
  {
    v51 = *v48;
    sub_1003B0B0(*v48, *(float *)(v1 + 988), (int)&unk_100BEAC4, v1 + 928);
    *(float *)(v1 + 988) = v51;
  }
  if ( *(_BYTE *)(v1 + 929) )
  {
    v52 = *v49;
    sub_1003B0B0(*v49, *(float *)(v1 + 992), (int)&unk_100BEAC4, v1 + 928);
    *(float *)(v1 + 992) = v52;
  }
  v53 = (float *)(v1 + 1072);
  v54 = (float *)(v1 + 1076);
  *(_BYTE *)(v1 + 1024) = sub_10066790(0x1Cu, (float *)(v1 + 1072));
  v55 = sub_10066790(0x35u, (float *)(v1 + 1076));
  v9 = *(_BYTE *)(v1 + 1024) == 0;
  *(_BYTE *)(v1 + 1025) = v55;
  if ( !v9 )
  {
    v56 = *v53;
    sub_1003B0B0(*v53, *(float *)(v1 + 1084), (int)&unk_100BEB4C, v1 + 1024);
    *(float *)(v1 + 1084) = v56;
  }
  if ( *(_BYTE *)(v1 + 1025) )
  {
    v57 = *v54;
    sub_1003B0B0(*v54, *(float *)(v1 + 1088), (int)&unk_100BEB4C, v1 + 1024);
    *(float *)(v1 + 1088) = v57;
  }
  v58 = sub_10066790(1u, &v75);
  v59 = (char *)(v1 + 212);
  *(_BYTE *)(v1 + 212) = v58;
  if ( v58 )
  {
    v60 = sub_10031F70(100.0, v75, (int)&v73);
    *v59 = v60;
    if ( v60 )
    {
      sub_100666C0(v1 + 308, v73);
      *(float *)(v1 + 260) = (double)*(signed int *)(v1 + 312) / 100.0;
    }
  }
  v61 = sub_10066790(2u, &v75);
  *(_BYTE *)(v1 + 213) = v61;
  if ( v61 )
  {
    v62 = sub_10031F70(100.0, v75, (int)&v73);
    *(_BYTE *)(v1 + 213) = v62;
    if ( v62 )
    {
      sub_100666C0(v1 + 316, v73);
      *(float *)(v1 + 264) = (double)*(signed int *)(v1 + 320) / 100.0;
    }
  }
  if ( *v59 )
  {
    v63 = *(float *)(v1 + 260);
    sub_1003B0B0(*(float *)(v1 + 260), *(float *)(v1 + 272), (int)&unk_100BEBCC, v1 + 212);
    *(float *)(v1 + 272) = v63;
  }
  if ( *(_BYTE *)(v1 + 213) )
  {
    v64 = *(float *)(v1 + 264);
    sub_1003B0B0(*(float *)(v1 + 264), *(float *)(v1 + 276), (int)&unk_100BEBCC, v1 + 212);
    *(float *)(v1 + 276) = v64;
  }
  v65 = (float *)(v1 + 1492);
  v66 = (float *)(v1 + 1496);
  *(_BYTE *)(v1 + 1444) = sub_100663B0((float *)(v1 + 1492));
  sub_100663C0(v1 + 1496);
  v9 = *(_BYTE *)(v1 + 1444) == 0;
  *(_BYTE *)(v1 + 1445) = v67;
  if ( !v9 )
  {
    v68 = *v65;
    sub_1003B0B0(*v65, *(float *)(v1 + 1504), (int)&unk_100BEBB8, v1 + 1444);
    *(float *)(v1 + 1504) = v68;
  }
  if ( *(_BYTE *)(v1 + 1445) )
  {
    v69 = *v66;
    sub_1003B0B0(*v66, *(float *)(v1 + 1508), (int)&unk_100BEBB8, v1 + 1444);
    *(float *)(v1 + 1508) = v69;
  }
  v70 = (float *)(v1 + 468);
  result = sub_10066790(0x6Du, (float *)(v1 + 468));
  *(_BYTE *)(v1 + 420) = result;
  if ( result )
  {
    v72 = *v70;
    result = sub_1003B0B0(*v70, *(float *)(v1 + 480), (int)&unk_100BEC08, v1 + 420);
    *(float *)(v1 + 480) = v72;
  }
  return result;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (1001AF10) --------------------------------------------------------
void __usercall sub_1001AF10(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  _BYTE *v3; // edi@1
  int v4; // ecx@1
  signed int v5; // esi@1
  int v6; // edx@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_1008C780();
  v3 = (_BYTE *)(v1 + 1325);
  v4 = v1 + 1292;
  v5 = 3;
  do
  {
    if ( *(_DWORD *)(v4 + 136) > v2 || (v6 = dword_1031FB44, *(float *)(dword_1031FB44 + 29628) >= (double)*(float *)v4) )
    {
      *(_DWORD *)(v4 + 136) = v2;
      v6 = dword_1031FB44;
    }
    if ( *(float *)(v6 + 29632) < (double)*(float *)v4 || *(float *)(v6 + 900) <= (double)(v2 - *(_DWORD *)(v4 + 136)) )
    {
      *v3 = 3;
    }
    else if ( *(float *)(v6 + 888) >= (double)*(float *)v4 || *(float *)(v6 + 892) == *(float *)(v6 + 888) )
    {
      *v3 = 1;
    }
    else
    {
      *v3 = 2;
    }
    v4 += 4;
    ++v3;
    --v5;
  }
  while ( v5 );
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001AFE0) --------------------------------------------------------
bool __usercall sub_1001AFE0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  void *v2; // ecx@1
  signed int v3; // ebx@3
  int v4; // ecx@3
  int v5; // eax@3
  bool result; // al@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1001A660(a1);
  sub_1001AF10(a1);
  if ( sub_10052210(v2) == 2 && *(_BYTE *)(v1 + 1540) )
  {
    sub_10019F00(a1);
    v3 = 3;
    v4 = v1 + 1232;
    v5 = v1 + 1280;
    do
    {
      *(float *)(v5 - 304) = *(float *)(dword_1031FB44 + 1584) * 0.800000011920929;
      *(float *)v5 = *(float *)(dword_1031FB44 + 888);
      *(float *)(v5 + 96) = *(float *)(dword_1031FB44 + 3892);
      *(float *)(v5 - 600) = *(float *)(dword_1031FB44 + 1004);
      *(float *)(v5 - 712) = *(float *)(dword_1031FB44 + 308);
      *(float *)(v5 - 112) = *(float *)(dword_1031FB44 + 820);
      *(float *)(v5 - 208) = *(float *)(dword_1031FB44 + 756);
      *(float *)(v5 - 908) = *(float *)(dword_1031FB44 + 1452);
      *(float *)(v5 - 504) = *(float *)(dword_1031FB44 + 1388);
      *(float *)(v5 - 1020) = *(float *)(dword_1031FB44 + 52);
      *(float *)(v5 + 212) = *(float *)(dword_1031FB44 + 1100);
      *(float *)(v5 - 400) = *(float *)(dword_1031FB44 + 1516);
      *(float *)(v5 - 812) = *(float *)(dword_1031FB44 + 20332) * 0.6000000238418579;
      *(float *)(v5 - 292) = *(float *)(dword_1031FB44 + 1584) * 0.800000011920929;
      *(float *)(v5 + 12) = *(float *)(dword_1031FB44 + 888);
      *(float *)(v5 + 108) = *(float *)(dword_1031FB44 + 3892);
      *(float *)(v5 - 588) = *(float *)(dword_1031FB44 + 1004);
      *(float *)(v5 - 700) = *(float *)(dword_1031FB44 + 308);
      *(float *)(v5 - 100) = *(float *)(dword_1031FB44 + 820);
      *(float *)(v5 - 196) = *(float *)(dword_1031FB44 + 756);
      *(float *)(v5 - 896) = *(float *)(dword_1031FB44 + 1452);
      *(float *)(v5 - 492) = *(float *)(dword_1031FB44 + 1388);
      *(float *)(v5 - 1008) = *(float *)(dword_1031FB44 + 52);
      *(float *)(v5 + 224) = *(float *)(dword_1031FB44 + 1100);
      *(float *)(v5 - 388) = *(float *)(dword_1031FB44 + 1516);
      *(float *)(v5 - 800) = *(float *)(dword_1031FB44 + 20332) * 0.6000000238418579;
      *(_BYTE *)(v4 - 304) = 1;
      *(_BYTE *)v4 = 1;
      *(_BYTE *)(v4 + 96) = 1;
      *(_BYTE *)(v4 - 600) = 1;
      *(_BYTE *)(v4 - 712) = 1;
      *(_BYTE *)(v4 - 112) = 1;
      *(_BYTE *)(v4 - 208) = 1;
      *(_BYTE *)(v4 - 908) = 1;
      *(_BYTE *)(v4 - 504) = 1;
      *(_BYTE *)(v4 - 1020) = 1;
      *(_BYTE *)(v4 + 212) = 1;
      *(_BYTE *)(v4 - 400) = 1;
      *(_BYTE *)(v4 - 812) = 1;
      v5 += 4;
      ++v4;
      --v3;
    }
    while ( v3 );
  }
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BE908, (int)&unk_100BED28, 0, 255);
  sub_1004AA20(
    a1,
    *(_WORD **)(a1 + 52),
    (char *)*(&off_100BED9C + *(_BYTE *)(v1 + 1216)),
    (int)(&off_100BEDB0)[*(_BYTE *)(v1 + 1216)],
    0,
    255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BEAB0, v1, *(_DWORD *)(v1 + 148), 255);
  result = sub_1004AA20(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 1216) + 172),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 1216) + 152),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 1216) + 192),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100BED9C: using guessed type void *off_100BED9C;
// 100BEDB0: using guessed type void **off_100BEDB0;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001B2F0) --------------------------------------------------------
char __cdecl sub_1001B2F0(int a1, char a2, char a3)
{
  int v3; // eax@1
  __int16 v4; // cx@4
  __int16 v5; // ax@7

  v3 = **(_WORD **)(a1 + 52);
  switch ( v3 )
  {
    case 32789:
    case 32790:
      LOBYTE(v3) = sub_1001A0F0(a1);
      break;
    case 32833:
      if ( a2 )
      {
        v4 = 47;
        if ( a3 )
        {
          if ( a3 == 1 )
          {
            v5 = 151;
          }
          else if ( a3 == 2 )
          {
            v5 = 302;
          }
          else
          {
            v5 = a1;
          }
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        v5 = 0;
        v4 = 0;
      }
      LOBYTE(v3) = sub_1001A1C0(a1, v5, v4);
      if ( a2 )
      {
        v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
        *(_BYTE *)(v3 + 1216) = a3;
      }
      break;
    case 32802:
    case 32888:
      LOBYTE(v3) = sub_1001AFE0(a1);
      break;
    case 32821:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 1540) = 0;
      break;
    case 32820:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 1540) = 1;
      break;
    case 32825:
      LOBYTE(v3) = sub_1001A160(a1);
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1001B420) --------------------------------------------------------
int __usercall sub_1001B420@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  void *v2; // ecx@1
  double v3; // st7@1
  char v4; // al@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // eax@1
  int v9; // ecx@1
  int v10; // eax@1
  int v11; // ecx@1
  double v12; // st7@1
  int v13; // edx@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  qmemcpy((void *)(v1 + 1688), (const void *)(dword_1031FB44 + 868), 0x20u);
  *(_BYTE *)(v1 + 1777) = 0;
  *(_BYTE *)(v1 + 1778) = 0;
  qmemcpy((void *)(v1 + 1176), (const void *)(dword_1031FB44 + 988), 0x20u);
  qmemcpy((void *)(v1 + 1060), (const void *)(dword_1031FB44 + 292), 0x20u);
  qmemcpy((void *)(v1 + 960), (const void *)(dword_1031FB44 + 228), 0x20u);
  qmemcpy((void *)(v1 + 1572), (const void *)(dword_1031FB44 + 228), 0x20u);
  qmemcpy((void *)(v1 + 444), (const void *)(dword_1031FB44 + 164), 0x20u);
  qmemcpy((void *)(v1 + 1476), (const void *)(dword_1031FB44 + 804), 0x20u);
  qmemcpy((void *)(v1 + 1380), (const void *)(dword_1031FB44 + 740), 0x20u);
  qmemcpy((void *)(v1 + 228), (const void *)(dword_1031FB44 + 36), 0x20u);
  qmemcpy((void *)(v1 + 644), (const void *)(dword_1031FB44 + 20408), 0x20u);
  qmemcpy((void *)(v1 + 1792), (const void *)(dword_1031FB44 + 1084), 0x20u);
  qmemcpy((void *)(v1 + 1284), (const void *)(dword_1031FB44 + 548), 0x20u);
  qmemcpy((void *)(v1 + 744), (const void *)(dword_1031FB44 + 20312), 0x20u);
  qmemcpy((void *)(v1 + 536), (const void *)(v1 + 440), 0x60u);
  *(_WORD *)(v1 + 780) = 1801;
  *(_WORD *)(v1 + 1608) = 7244;
  *(_WORD *)(v1 + 512) = 76;
  *(_WORD *)(v1 + 1244) = 76;
  *(_WORD *)(v1 + 1128) = 76;
  *(_WORD *)(v1 + 1544) = 76;
  *(_WORD *)(v1 + 1448) = 76;
  *(_WORD *)(v1 + 296) = 76;
  *(_WORD *)(v1 + 1860) = 76;
  *(_WORD *)(v1 + 519) = 82;
  *(_WORD *)(v1 + 1251) = 82;
  *(_WORD *)(v1 + 1135) = 82;
  *(_WORD *)(v1 + 1551) = 82;
  *(_WORD *)(v1 + 1455) = 82;
  *(_WORD *)(v1 + 303) = 82;
  *(_WORD *)(v1 + 1867) = 82;
  *(float *)(v1 + 852) = *(float *)(dword_1031FB44 + 232);
  *(float *)(v1 + 848) = *(float *)(dword_1031FB44 + 228);
  *(float *)(v1 + 856) = *(float *)(dword_1031FB44 + 248);
  *(float *)(v1 + 860) = *(float *)(dword_1031FB44 + 252);
  *(float *)(v1 + 900) = *(float *)(dword_1031FB44 + 232);
  v2 = (void *)dword_1031FB44;
  *(float *)(v1 + 896) = *(float *)(dword_1031FB44 + 228);
  *(float *)(v1 + 904) = *(float *)(dword_1031FB44 + 248);
  v3 = *(float *)(dword_1031FB44 + 252);
  *(_BYTE *)(v1 + 836) = 1;
  *(float *)(v1 + 908) = v3;
  v4 = sub_1004BEE0(v2);
  v5 = *(_DWORD *)(v1 + 952);
  v6 = *(_DWORD *)(v1 + 948);
  *(_BYTE *)(v1 + 1276) = v4;
  v7 = *(_DWORD *)(v1 + 936);
  *(_DWORD *)(v1 + 844) = v7;
  *(_DWORD *)(v1 + 872) = v5;
  *(_DWORD *)(v1 + 884) = v6;
  *(_DWORD *)(v1 + 892) = v7 + *(_BYTE *)(dword_1031FB44 + 25);
  v8 = *(_DWORD *)(v1 + 940);
  *(_DWORD *)(v1 + 920) = v5 + 4 * *(_BYTE *)(dword_1031FB44 + 25);
  v9 = *(_DWORD *)(v1 + 944);
  *(_DWORD *)(v1 + 876) = v8;
  *(_DWORD *)(v1 + 880) = v9;
  *(_DWORD *)(v1 + 932) = v6 + 1;
  *(_DWORD *)(v1 + 924) = v8 + 4 * *(_BYTE *)(dword_1031FB44 + 25);
  *(_DWORD *)(v1 + 928) = v9 + *(_BYTE *)(dword_1031FB44 + 25);
  *(float *)(v1 + 352) = *(float *)(dword_1031FB44 + 168);
  *(float *)(v1 + 348) = *(float *)(dword_1031FB44 + 164);
  *(float *)(v1 + 356) = *(float *)(dword_1031FB44 + 184);
  *(float *)(v1 + 360) = *(float *)(dword_1031FB44 + 188);
  *(float *)(v1 + 400) = *(float *)(dword_1031FB44 + 168);
  v10 = *(_DWORD *)(v1 + 436);
  *(float *)(v1 + 396) = *(float *)(dword_1031FB44 + 164);
  v11 = *(_DWORD *)(v1 + 636);
  *(float *)(v1 + 404) = *(float *)(dword_1031FB44 + 184);
  v12 = *(float *)(dword_1031FB44 + 188);
  v13 = *(_DWORD *)(v1 + 632);
  *(_DWORD *)(v1 + 372) = v11;
  *(float *)(v1 + 408) = v12;
  *(_DWORD *)(v1 + 384) = v13;
  *(_BYTE *)(v1 + 336) = 1;
  *(_DWORD *)(v1 + 344) = v10;
  *(_DWORD *)(v1 + 392) = v10 + *(_BYTE *)(dword_1031FB44 + 25);
  result = *(_BYTE *)(dword_1031FB44 + 25);
  *(_DWORD *)(v1 + 420) = v11 + 4 * result;
  *(_DWORD *)(v1 + 432) = v13 + 1;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001B830) --------------------------------------------------------
bool __usercall sub_1001B830@<al>(int a1@<esi>)
{
  int v1; // edi@1
  bool result; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BF4F0, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_1004AA20(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 1668) + 184),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 1668) + 164),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 1668) + 204),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1001B8B0) --------------------------------------------------------
char __usercall sub_1001B8B0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char v2; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 1668) = v2;
  if ( v2 && v2 != 1 && v2 != 2 )
    sub_10051A40(".\\cdp_pg_eis_diamond_da42l.c", 1744, 1, 0);
  sub_1004C170(*(_BYTE *)(v1 + 1668));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1001B910) --------------------------------------------------------
char __usercall sub_1001B910@<al>(char a1@<dl>, int a2@<ecx>, float *a3@<esi>)
{
  char result; // al@1

  a2 = (unsigned __int8)a2;
  result = 1;
  if ( (_BYTE)a2 )
  {
    if ( a2 == 1 )
    {
      switch ( a1 )
      {
        case 0:
          result = sub_10066790(0x21u, a3);
          goto LABEL_17;
        case 1:
          result = sub_10066790(0x22u, a3);
          goto LABEL_17;
        case 2:
          result = sub_10066790(0x23u, a3);
          goto LABEL_17;
        case 3:
          result = sub_10066790(0x24u, a3);
          goto LABEL_17;
        case 4:
          result = sub_10066790(0x25u, a3);
          goto LABEL_17;
        case 5:
          result = sub_10066790(0x26u, a3);
          goto LABEL_17;
        default:
          return result;
      }
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
        result = sub_10066790(8u, a3);
        goto LABEL_17;
      case 1:
        result = sub_10066790(9u, a3);
        goto LABEL_17;
      case 2:
        result = sub_10066790(0xAu, a3);
        goto LABEL_17;
      case 3:
        result = sub_10066790(0xBu, a3);
        goto LABEL_17;
      case 4:
        result = sub_10066790(0xCu, a3);
        goto LABEL_17;
      case 5:
        result = sub_10066790(0xDu, a3);
LABEL_17:
        if ( !result )
          *a3 = 0.0;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1001B9C0) --------------------------------------------------------
char __usercall sub_1001B9C0@<al>(char a1@<dl>, int a2@<ecx>, float *a3@<esi>)
{
  char result; // al@1

  a2 = (unsigned __int8)a2;
  result = 1;
  if ( (_BYTE)a2 )
  {
    if ( a2 == 1 )
    {
      switch ( a1 )
      {
        case 0:
          result = sub_10066790(0x27u, a3);
          goto LABEL_17;
        case 1:
          result = sub_10066790(0x28u, a3);
          goto LABEL_17;
        case 2:
          result = sub_10066790(0x29u, a3);
          goto LABEL_17;
        case 3:
          result = sub_10066790(0x2Au, a3);
          goto LABEL_17;
        case 4:
          result = sub_10066790(0x2Bu, a3);
          goto LABEL_17;
        case 5:
          result = sub_10066790(0x2Cu, a3);
          goto LABEL_17;
        default:
          return result;
      }
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
        result = sub_10066790(0xEu, a3);
        goto LABEL_17;
      case 1:
        result = sub_10066790(0xFu, a3);
        goto LABEL_17;
      case 2:
        result = sub_10066790(0x10u, a3);
        goto LABEL_17;
      case 3:
        result = sub_10066790(0x11u, a3);
        goto LABEL_17;
      case 4:
        result = sub_10066790(0x12u, a3);
        goto LABEL_17;
      case 5:
        result = sub_10066790(0x13u, a3);
LABEL_17:
        if ( !result )
          *a3 = 0.0;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1001BA70) --------------------------------------------------------
char __cdecl sub_1001BA70(int a1, __int16 a2, __int16 a3)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // edx@5
  signed int v7; // eax@5
  signed int v8; // ecx@7
  int v9; // eax@8
  signed int v10; // eax@10
  _BYTE *v11; // ebx@14
  int v12; // ecx@15
  int v13; // edx@16
  char *v14; // eax@17
  _BYTE *v15; // edx@17
  char v16; // cl@18
  char *v17; // eax@19
  char v18; // cl@20
  char result; // al@21

  v3 = sub_100015A0(a1, *(char **)(a1 + 56), 1888, 0);
  v4 = (unsigned __int16)(*(_BYTE *)(dword_1031FB44 + 24) * *(_BYTE *)(dword_1031FB44 + 25));
  *(_DWORD *)(v3 + 436) = sub_100027C0(a1, v4);
  *(_DWORD *)(v3 + 632) = sub_100027C0(a1, *(_BYTE *)(dword_1031FB44 + 24));
  *(_DWORD *)(v3 + 636) = sub_100027C0(a1, 4 * v4);
  *(_DWORD *)(v3 + 936) = sub_100027C0(a1, v4);
  *(_DWORD *)(v3 + 940) = sub_100027C0(a1, 4 * v4);
  *(_DWORD *)(v3 + 944) = sub_100027C0(a1, v4);
  *(_DWORD *)(v3 + 948) = sub_100027C0(a1, *(_BYTE *)(dword_1031FB44 + 24));
  *(_DWORD *)(v3 + 952) = sub_100027C0(a1, 4 * v4);
  *(_DWORD *)(v3 + 1780) = sub_100027C0(a1, 4 * v4);
  *(_DWORD *)(v3 + 1664) = sub_100027C0(a1, *(_BYTE *)(dword_1031FB44 + 24));
  *(float *)(v3 + 1616) = 9.8999998e24;
  v5 = 0;
  *(float *)(v3 + 1620) = 9.8999998e24;
  *(_BYTE *)(v3 + 1168) = -1;
  *(_BYTE *)(v3 + 1169) = -1;
  *(_BYTE *)(v3 + 1884) = 0;
  if ( v4 >= 4 )
  {
    do
    {
      *(_BYTE *)(v5 + *(_DWORD *)(v3 + 436)) = 0;
      *(float *)(*(_DWORD *)(v3 + 636) + 4 * v5) = 0.0;
      *(_BYTE *)(v5 + *(_DWORD *)(v3 + 936)) = 0;
      *(float *)(*(_DWORD *)(v3 + 940) + 4 * v5) = 0.0;
      *(_BYTE *)(v5 + *(_DWORD *)(v3 + 944)) = 0;
      *(float *)(*(_DWORD *)(v3 + 952) + 4 * v5) = 0.0;
      *(_DWORD *)(*(_DWORD *)(v3 + 1780) + 4 * v5) = 1;
      *(_BYTE *)(*(_DWORD *)(v3 + 436) + v5 + 1) = 0;
      *(float *)(*(_DWORD *)(v3 + 636) + 4 * v5 + 4) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 936) + v5 + 1) = 0;
      *(float *)(*(_DWORD *)(v3 + 940) + 4 * v5 + 4) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 944) + v5 + 1) = 0;
      *(float *)(*(_DWORD *)(v3 + 952) + 4 * v5 + 4) = 0.0;
      *(_DWORD *)(*(_DWORD *)(v3 + 1780) + 4 * v5 + 4) = 1;
      *(_BYTE *)(*(_DWORD *)(v3 + 436) + v5 + 2) = 0;
      *(float *)(*(_DWORD *)(v3 + 636) + 4 * v5 + 8) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 936) + v5 + 2) = 0;
      *(float *)(*(_DWORD *)(v3 + 940) + 4 * v5 + 8) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 944) + v5 + 2) = 0;
      *(float *)(*(_DWORD *)(v3 + 952) + 4 * v5 + 8) = 0.0;
      *(_DWORD *)(*(_DWORD *)(v3 + 1780) + 4 * v5 + 8) = 1;
      *(_BYTE *)(*(_DWORD *)(v3 + 436) + v5 + 3) = 0;
      *(float *)(*(_DWORD *)(v3 + 636) + 4 * v5 + 12) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 936) + v5 + 3) = 0;
      *(float *)(*(_DWORD *)(v3 + 940) + 4 * v5 + 12) = 0.0;
      *(_BYTE *)(*(_DWORD *)(v3 + 944) + v5 + 3) = 0;
      *(float *)(*(_DWORD *)(v3 + 952) + 4 * v5 + 12) = 0.0;
      *(_DWORD *)(*(_DWORD *)(v3 + 1780) + 4 * v5 + 12) = 1;
      v5 += 4;
    }
    while ( v5 < v4 - 3 );
  }
  for ( ; v5 < v4; ++v5 )
  {
    *(_BYTE *)(v5 + *(_DWORD *)(v3 + 436)) = 0;
    *(float *)(*(_DWORD *)(v3 + 636) + 4 * v5) = 0.0;
    *(_BYTE *)(v5 + *(_DWORD *)(v3 + 936)) = 0;
    *(float *)(*(_DWORD *)(v3 + 940) + 4 * v5) = 0.0;
    *(_BYTE *)(v5 + *(_DWORD *)(v3 + 944)) = 0;
    *(float *)(*(_DWORD *)(v3 + 952) + 4 * v5) = 0.0;
    *(_DWORD *)(*(_DWORD *)(v3 + 1780) + 4 * v5) = 1;
  }
  v6 = dword_1031FB44;
  v7 = 0;
  if ( *(_BYTE *)(dword_1031FB44 + 24) )
  {
    do
    {
      *(_BYTE *)(v7 + *(_DWORD *)(v3 + 632)) = 0;
      *(_BYTE *)(v7 + *(_DWORD *)(v3 + 948)) = 0;
      *(_BYTE *)(v7 + *(_DWORD *)(v3 + 1664)) = 0;
      v6 = dword_1031FB44;
      ++v7;
    }
    while ( v7 < *(_BYTE *)(dword_1031FB44 + 24) );
  }
  v8 = 0;
  if ( *(_BYTE *)(v6 + 24) )
  {
    v9 = v3 + 340;
    do
    {
      *(_BYTE *)(v9 + 1) = 1;
      *(_BYTE *)v9 = *(_BYTE *)(dword_1031FB44 + 25);
      *(_BYTE *)(v9 + 501) = 1;
      *(_BYTE *)(v9 + 500) = *(_BYTE *)(dword_1031FB44 + 25);
      ++v8;
      v9 += 48;
    }
    while ( v8 < *(_BYTE *)(dword_1031FB44 + 24) );
  }
  *(_DWORD *)(v3 + 184) = &unk_100BF520;
  *(_DWORD *)(v3 + 192) = &unk_100BF668;
  *(_DWORD *)(v3 + 188) = &unk_100BF5B0;
  *(_DWORD *)(v3 + 164) = v3 + 8;
  *(_DWORD *)(v3 + 204) = v3 + 132;
  *(_DWORD *)(v3 + 212) = v3 + 139;
  *(_DWORD *)(v3 + 208) = v3 + 155;
  *(_DWORD *)(v3 + 172) = v3 + 36;
  *(_DWORD *)(v3 + 168) = v3 + 100;
  *(_BYTE *)(v3 + 132) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 204) + 6) = 3;
  **(_BYTE **)(v3 + 208) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v3 + 208) + 7) = 3;
  v10 = 0;
  do
    *(_BYTE *)(v10++ + *(_DWORD *)(v3 + 212)) = 3;
  while ( v10 < 16 );
  if ( sub_1006C420(0x6Du) != 1 )
    *(_BYTE *)(*(_DWORD *)(v3 + 212) + 14) = 0;
  sub_100011B0(a1, a2, a3, 151, 686, 1);
  sub_10063C90(*(_DWORD *)(a1 + 56), (char *)&unk_100BF4EC);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_1001B420(a1);
  sub_10066730(v3 + 320, 0, 1.0, 0.125);
  sub_10066730(v3 + 328, 0, 1.0, 0.125);
  sub_10066730(v3 + 1152, 0, 1.0, 0.125);
  sub_10066730(v3 + 1160, 0, 1.0, 0.125);
  *(_DWORD *)v3 = v3 + 1684;
  *(_DWORD *)(v3 + 4) = v3 + 1280;
  *(_DWORD *)(v3 + 12) = v3 + 440;
  *(_DWORD *)(v3 + 20) = v3 + 1376;
  *(_DWORD *)(v3 + 28) = v3 + 224;
  *(_DWORD *)(v3 + 24) = v3 + 1788;
  *(_DWORD *)(v3 + 32) = v3 + 1172;
  *(_DWORD *)(v3 + 8) = v3 + 1056;
  *(_DWORD *)(v3 + 16) = v3 + 1472;
  *(_DWORD *)(v3 + 104) = v3 + 840;
  *(_DWORD *)(v3 + 108) = v3 + 888;
  *(_DWORD *)(v3 + 120) = v3 + 340;
  *(_DWORD *)(v3 + 124) = v3 + 388;
  *(_DWORD *)(v3 + 100) = v3 + 1056;
  *(_DWORD *)(v3 + 112) = v3 + 956;
  *(_DWORD *)(v3 + 128) = v3 + 536;
  *(_DWORD *)(v3 + 116) = v3 + 1568;
  *(_DWORD *)(v3 + 60) = v3 + 1056;
  *(_DWORD *)(v3 + 68) = v3 + 1676;
  *(_DWORD *)(v3 + 76) = v3 + 1272;
  *(_DWORD *)(v3 + 80) = v3 + 1052;
  *(_DWORD *)(v3 + 44) = v3 + 1788;
  *(_DWORD *)(v3 + 84) = v3 + 1672;
  *(_DWORD *)(v3 + 48) = v3 + 224;
  *(_DWORD *)(v3 + 88) = v3 + 1680;
  *(_DWORD *)(v3 + 52) = v3 + 640;
  *(_DWORD *)(v3 + 36) = v3 + 1472;
  *(_DWORD *)(v3 + 92) = v3 + 740;
  v11 = (_BYTE *)(v3 + 1268);
  *(_DWORD *)(v3 + 40) = v3 + 1376;
  *(_DWORD *)(v3 + 56) = v3 + 1172;
  *(_DWORD *)(v3 + 64) = v3 + 1268;
  *(_DWORD *)(v3 + 72) = v3 + 1268;
  *(_DWORD *)(v3 + 96) = v3 + 1784;
  *(_BYTE *)(v3 + 1668) = sub_1004BF10((void *)(v3 + 1172));
  if ( sub_1006C3C0(16) == 1 )
  {
    v12 = *(_DWORD *)(v3 + 212);
    *(_BYTE *)(v3 + 736) = 1;
    *(_BYTE *)(v12 + 4) = 3;
  }
  else
  {
    v13 = *(_DWORD *)(v3 + 212);
    *(_BYTE *)(v3 + 736) = 0;
    *(_BYTE *)(v13 + 4) = 0;
  }
  *(float *)(v3 + 1784) = sub_1004C070();
  *(float *)(v3 + 1272) = 9.8999998e24;
  *(float *)(v3 + 1676) = 9.8999998e24;
  *(_DWORD *)(v3 + 1052) = 0x7FFFFFFF;
  *(float *)(v3 + 1672) = 9.8999998e24;
  v14 = sub_1006C690(2u, 0);
  v15 = (_BYTE *)(v3 + 1680);
  do
  {
    v16 = *v14;
    *v15++ = *v14++;
  }
  while ( v16 );
  v17 = sub_1006C690(0x15u, 0);
  do
  {
    v18 = *v17;
    *v11++ = *v17++;
  }
  while ( v18 );
  sub_1004A900(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), (char *)&unk_100BF4F0, v3, 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v3 + 184), *(_DWORD *)(v3 + 164), 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v3 + 188), *(_DWORD *)(v3 + 168), 0, 255);
  sub_1004AA20(a1, *(_WORD **)(a1 + 52), *(char **)(v3 + 192), *(_DWORD *)(v3 + 172), 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001C1F0) --------------------------------------------------------
char __usercall sub_1001C1F0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // al@3
  signed int v3; // eax@5
  _BYTE *v4; // eax@9
  _BYTE *v5; // eax@9
  signed int v6; // eax@11
  int v7; // ST04_4@13

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( !*(_BYTE *)(v1 + 1276) )
    {
      v4 = *(_BYTE **)(v1 + 948);
      *(_BYTE *)(v1 + 836) = 0;
      *(_BYTE *)(v1 + 336) = 0;
      ++*v4;
      v5 = *(_BYTE **)(v1 + 948);
      if ( *v5 >= *(_BYTE *)(dword_1031FB44 + 25) )
        *v5 = 0;
      v6 = 0;
      if ( *(_BYTE *)(dword_1031FB44 + 24) )
      {
        do
        {
          *(_BYTE *)(*(_DWORD *)(v1 + 948) + v6) = **(_BYTE **)(v1 + 948);
          *(_BYTE *)(v6++ + *(_DWORD *)(v1 + 632)) = **(_BYTE **)(v1 + 948);
        }
        while ( v6 < *(_BYTE *)(dword_1031FB44 + 24) );
      }
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    v2 = *(_BYTE *)(v1 + 1276) == 0;
    *(_BYTE *)(v1 + 1276) = v2;
    sub_1004C150(v2);
    if ( *(_BYTE *)(v1 + 1276) )
    {
      *(float *)(v1 + 1616) = 9.8999998e24;
      *(_BYTE *)(v1 + 1168) = -1;
      *(float *)(v1 + 1620) = 9.8999998e24;
      *(_BYTE *)(v1 + 1169) = -1;
    }
    else
    {
      *(_BYTE *)(v1 + 836) = 1;
      v3 = 0;
      if ( *(_BYTE *)(dword_1031FB44 + 24) )
      {
        do
          *(_BYTE *)(v3++ + *(_DWORD *)(v1 + 1664)) = 0;
        while ( v3 < *(_BYTE *)(dword_1031FB44 + 24) );
      }
    }
  }
  v7 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v7, -32734);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001C320) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001C320(int a1)
{
  int v1; // ecx@1
  int v2; // edi@1
  unsigned __int8 v3; // dl@2
  char v4; // bl@2
  char v5; // al@2
  int v6; // ebx@5
  int v7; // ecx@5
  float *v8; // esi@5
  int v9; // ecx@5
  float *v10; // edx@6
  int v11; // esi@9
  int v12; // esi@10
  unsigned __int8 v13; // al@11
  unsigned __int8 v14; // cl@11
  char *v15; // eax@12
  int v16; // esi@12
  int v17; // eax@13
  int v18; // ecx@18
  float *v19; // esi@18
  int v20; // eax@18
  float *v21; // esi@19
  unsigned __int8 v22; // al@23
  int v23; // ecx@26
  int v24; // ecx@26
  int v25; // eax@33
  float v26; // ST24_4@34
  float v27; // ST24_4@34
  double v28; // st7@34
  int v29; // ST2C_4@36
  double v30; // st7@36
  unsigned __int8 v31; // al@40
  unsigned __int8 v32; // bl@41
  int v33; // esi@42
  double v34; // st7@43
  int v35; // eax@44
  double v36; // st7@44
  unsigned __int8 v37; // bl@48
  double v38; // st7@50
  unsigned __int8 v39; // bl@52
  double v40; // st7@54
  unsigned __int8 result; // al@56
  unsigned __int8 v42; // bl@57
  int v43; // ebp@58
  double v44; // st7@59
  int v45; // ecx@60
  double v46; // st7@60
  unsigned __int8 v47; // bl@64
  int v48; // esi@65
  double v49; // st7@66
  unsigned __int8 v50; // [sp+20h] [bp-8Ch]@1
  unsigned __int8 v51; // [sp+20h] [bp-8Ch]@40
  unsigned __int8 v52; // [sp+20h] [bp-8Ch]@56
  char v53; // [sp+21h] [bp-8Bh]@2
  char v54; // [sp+22h] [bp-8Ah]@2
  char v55; // [sp+23h] [bp-89h]@2
  float *v56; // [sp+24h] [bp-88h]@58
  _BYTE *v57; // [sp+2Ch] [bp-80h]@5
  float v58; // [sp+30h] [bp-7Ch]@2
  float v59; // [sp+34h] [bp-78h]@2
  int v60; // [sp+38h] [bp-74h]@44
  int v61; // [sp+3Ch] [bp-70h]@43
  char v62; // [sp+45h] [bp-67h]@43
  int v63; // [sp+48h] [bp-64h]@44
  float v64; // [sp+6Ch] [bp-40h]@43

  v1 = dword_1031FB44;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v50 = 0;
  if ( *(_BYTE *)(dword_1031FB44 + 24) )
  {
    while ( 1 )
    {
      v3 = *(_BYTE *)(v1 + 25);
      v4 = 0;
      v59 = 0.0;
      v5 = 0;
      v58 = 0.0;
      v54 = 0;
      v55 = 0;
      v53 = 0;
      if ( v3 )
      {
        while ( 1 )
        {
          v6 = (unsigned __int8)v5;
          v7 = (unsigned __int8)v5 + v50 * v3;
          v8 = (float *)(*(_DWORD *)(v2 + 952) + 4 * v7);
          LOBYTE(v7) = v50;
          *(_BYTE *)(v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25) + *(_DWORD *)(v2 + 936)) = sub_1001B9C0(v5, v7, v8);
          v9 = v50 * *(_BYTE *)(dword_1031FB44 + 25);
          v57 = (_BYTE *)(dword_1031FB44 + 25);
          if ( *(_BYTE *)(v6 + v9 + *(_DWORD *)(v2 + 936)) )
          {
            v10 = (float *)(*(_DWORD *)(v2 + 952) + 4 * (v6 + v9));
            if ( v59 < (double)*v10 )
            {
              v59 = *v10;
              v55 = v53;
            }
          }
          if ( *(_BYTE *)(v2 + 1276) )
          {
            v11 = 4 * (v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25));
            if ( (signed int)(*(float *)(v11 + *(_DWORD *)(v2 + 952)) + 0.5) > (signed int)*(float *)(*(_DWORD *)(v2 + 940) + v11) )
            {
              v12 = 4 * (v6 + v50 * *v57);
              *(float *)(v12 + *(_DWORD *)(v2 + 940)) = (double)(signed int)(*(float *)(v12 + *(_DWORD *)(v2 + 952))
                                                                           + 0.5);
              if ( *(_BYTE *)(v6 + v50 * *v57 + *(_DWORD *)(v2 + 944)) )
              {
                *(_BYTE *)(*(_DWORD *)(v2 + 1664) + v50) = 0;
                *(_BYTE *)(v2 + v50 + 1168) = -1;
                *(_BYTE *)(v2 + 836) = 1;
                v13 = *(_BYTE *)(dword_1031FB44 + 25);
                v14 = 0;
                if ( v13 )
                {
                  do
                  {
                    *(_BYTE *)(v14 + v50 * v13 + *(_DWORD *)(v2 + 944)) = 0;
                    v15 = (char *)(dword_1031FB44 + 25);
                    v16 = v14++ + v50 * *(_BYTE *)(dword_1031FB44 + 25);
                    *(float *)(*(_DWORD *)(v2 + 940) + 4 * v16) = 0.0;
                    v13 = *v15;
                  }
                  while ( v14 < v13 );
                }
              }
            }
            v17 = 4 * (v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25));
            if ( *(float *)(*(_DWORD *)(v2 + 940) + v17) - *(float *)(v17 + *(_DWORD *)(v2 + 952)) > 4.0
              && !*(_BYTE *)(v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25) + *(_DWORD *)(v2 + 944))
              && !*(_BYTE *)(*(_DWORD *)(v2 + 1664) + v50) )
            {
              *(_BYTE *)(v2 + v50 + 1168) = v53;
              *(_BYTE *)(v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25) + *(_DWORD *)(v2 + 944)) = 1;
              ++*(_BYTE *)(*(_DWORD *)(v2 + 1664) + v50);
              *(_BYTE *)(v2 + 836) = 0;
            }
          }
          else
          {
            *(_BYTE *)(v6 + *(_DWORD *)(v2 + 944) + v9) = 0;
            *(float *)(*(_DWORD *)(v2 + 940) + 4 * (v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25))) = 0.0;
          }
          v18 = v6 + v50 * *(_BYTE *)(dword_1031FB44 + 25);
          v19 = (float *)(*(_DWORD *)(v2 + 636) + 4 * v18);
          LOBYTE(v18) = v50;
          *(_BYTE *)(*(_DWORD *)(v2 + 436) + v50 * *(_BYTE *)(dword_1031FB44 + 25) + v6) = sub_1001B910(v53, v18, v19);
          v1 = dword_1031FB44;
          v3 = *(_BYTE *)(dword_1031FB44 + 25);
          v20 = v50 * *(_BYTE *)(dword_1031FB44 + 25);
          if ( *(_BYTE *)(v6 + *(_DWORD *)(v2 + 436) + v20) )
          {
            v21 = (float *)(*(_DWORD *)(v2 + 636) + 4 * (v20 + v6));
            if ( v58 < (double)*v21 )
            {
              v58 = *v21;
              v54 = v53;
            }
          }
          if ( (unsigned __int8)++v53 >= v3 )
            break;
          v5 = v53;
        }
        v4 = v54;
      }
      v22 = *(_BYTE *)(v50 + *(_DWORD *)(v2 + 1664));
      if ( v22 && v22 < *(_BYTE *)(v1 + 25) )
      {
        *(_BYTE *)(v50 + *(_DWORD *)(v2 + 948)) = *(_BYTE *)(v50 + v2 + 1168);
        *(_BYTE *)(v50 + *(_DWORD *)(v2 + 632)) = *(_BYTE *)(v50 + v2 + 1168);
      }
      *(float *)(v2 + 4 * v50 + 488) = v58;
      v23 = 7 * v50;
      *(_BYTE *)(v23 + v2 + 512) = v4 + 49;
      *(_BYTE *)(v23 + v2 + 513) = 0;
      v24 = v2 + 7 * v50;
      *(_BYTE *)(v50 + v2 + 440) = *(_BYTE *)((unsigned __int8)v4
                                            + v50 * *(_BYTE *)(dword_1031FB44 + 25)
                                            + *(_DWORD *)(v2 + 436));
      if ( *(float *)(48 * v50 + v2 + 356) < (double)v58 )
        break;
      if ( *(_BYTE *)(v2 + 336) )
        goto LABEL_29;
LABEL_30:
      if ( *(_BYTE *)(v2 + 836) )
        *(_BYTE *)(v50 + *(_DWORD *)(v2 + 948)) = v55;
      *(float *)(v2 + 4 * v50 + 584) = *(float *)(*(_DWORD *)(v2 + 636)
                                                + 4
                                                * (*(_BYTE *)(v50 + *(_DWORD *)(v2 + 632))
                                                 + v50 * *(_BYTE *)(dword_1031FB44 + 25)));
      *(float *)(v2 + 4 * v50 + 1004) = *(float *)(*(_DWORD *)(v2 + 952)
                                                 + 4
                                                 * (*(_BYTE *)(*(_DWORD *)(v2 + 948) + v50)
                                                  + v50 * *(_BYTE *)(dword_1031FB44 + 25)));
      *(_BYTE *)(v24 + 608) = *(_BYTE *)(v50 + *(_DWORD *)(v2 + 632)) + 49;
      *(_BYTE *)(v24 + 1028) = *(_BYTE *)(*(_DWORD *)(v2 + 948) + v50) + 49;
      *(_BYTE *)(7 * (v50 + 87) + v2) = 0;
      *(_BYTE *)(7 * (v50 + 147) + v2) = 0;
      *(_BYTE *)(v50 + v2 + 536) = *(_BYTE *)(*(_BYTE *)(v50 + *(_DWORD *)(v2 + 632))
                                            + v50 * *(_BYTE *)(dword_1031FB44 + 25)
                                            + *(_DWORD *)(v2 + 436));
      *(_BYTE *)(v50 + v2 + 956) = *(_BYTE *)(*(_BYTE *)(*(_DWORD *)(v2 + 948) + v50)
                                            + v50 * *(_BYTE *)(dword_1031FB44 + 25)
                                            + *(_DWORD *)(v2 + 936));
      if ( *(_BYTE *)(v2 + 1276) )
      {
        v25 = *(_BYTE *)(*(_DWORD *)(v2 + 948) + v50) + v50 * *(_BYTE *)(dword_1031FB44 + 25);
        if ( *(_BYTE *)(v25 + *(_DWORD *)(v2 + 944)) )
        {
          v26 = sub_1006D4B0(COERCE_INT(*(float *)(*(_DWORD *)(v2 + 940) + 4 * v25)), 0x1010u);
          v27 = v26 - sub_1006D4B0(COERCE_INT(*(float *)(v2 + 4 * v50 + 1004)), 0x1010u);
          v28 = v27;
          if ( v27 < 0.0 )
            v28 = 0.0;
          *(float *)&v29 = v28;
          v30 = sub_1006DAE0(v29, 0x1010u);
        }
        else
        {
          v30 = 9.9999996e24;
        }
        *(float *)(v2 + 4 * v50 + 1616) = v30;
      }
      v1 = dword_1031FB44;
      if ( ++v50 >= *(_BYTE *)(dword_1031FB44 + 24) )
        goto LABEL_40;
    }
    *(_BYTE *)(v2 + 336) = 1;
LABEL_29:
    *(_BYTE *)(v50 + *(_DWORD *)(v2 + 632)) = v4;
    goto LABEL_30;
  }
LABEL_40:
  v31 = 0;
  v51 = 0;
  if ( *(_BYTE *)(v1 + 24) )
  {
    do
    {
      v32 = 0;
      if ( *(_BYTE *)(v1 + 25) )
      {
        v33 = 48 * v31 + v2;
        do
        {
          v34 = *(float *)(v33 + 364);
          v61 = 264;
          v64 = v34;
          v62 = 6;
          if ( *(_BYTE *)(*(_DWORD *)(v33 + 344) + v32) )
          {
            v35 = *(_DWORD *)(v33 + 372);
            v36 = *(float *)(v35 + 4 * v32);
            sub_1003B0B0(*(float *)(v35 + 4 * v32), *(float *)(*(_DWORD *)(v33 + 368) + 4 * v32), (int)&v60, (int)&v63);
            *(float *)(*(_DWORD *)(v33 + 368) + 4 * v32) = v36;
            v1 = dword_1031FB44;
          }
          ++v32;
        }
        while ( v32 < *(_BYTE *)(v1 + 25) );
        v31 = v51;
      }
      v51 = ++v31;
    }
    while ( v31 < *(_BYTE *)(v1 + 24) );
  }
  v37 = 0;
  if ( *(_BYTE *)(v1 + 24) )
  {
    do
    {
      if ( *(_BYTE *)(v37 + v2 + 536) )
      {
        v38 = *(float *)(v2 + 4 * v37 + 584);
        sub_1003B0B0(*(float *)(v2 + 4 * v37 + 584), *(float *)(v2 + 4 * v37 + 596), (int)&unk_100BF64C, v2 + 536);
        *(float *)(v2 + 4 * v37 + 596) = v38;
        v1 = dword_1031FB44;
      }
      ++v37;
    }
    while ( v37 < *(_BYTE *)(v1 + 24) );
  }
  v39 = 0;
  if ( *(_BYTE *)(v1 + 24) )
  {
    do
    {
      if ( *(_BYTE *)(v39 + v2 + 440) )
      {
        v40 = *(float *)(v2 + 4 * v39 + 488);
        sub_1003B0B0(*(float *)(v2 + 4 * v39 + 488), *(float *)(v2 + 4 * v39 + 500), (int)&unk_100BF534, v2 + 440);
        *(float *)(v2 + 4 * v39 + 500) = v40;
        v1 = dword_1031FB44;
      }
      ++v39;
    }
    while ( v39 < *(_BYTE *)(v1 + 24) );
  }
  result = 0;
  v52 = 0;
  if ( *(_BYTE *)(v1 + 24) )
  {
    do
    {
      v42 = 0;
      if ( *(_BYTE *)(v1 + 25) )
      {
        v56 = (float *)(v2 + 16 * (3 * result + 54));
        v43 = 48 * result + v2;
        do
        {
          v44 = *v56;
          v61 = 6152;
          v64 = v44;
          v62 = 5;
          if ( *(_BYTE *)(v42 + *(_DWORD *)(v43 + 844)) )
          {
            v45 = *(_DWORD *)(v43 + 872);
            v46 = *(float *)(v45 + 4 * v42);
            sub_1003B0B0(*(float *)(v45 + 4 * v42), *(float *)(*(_DWORD *)(v43 + 868) + 4 * v42), (int)&v60, (int)&v63);
            *(float *)(*(_DWORD *)(v43 + 868) + 4 * v42) = v46;
            v1 = dword_1031FB44;
          }
          ++v42;
        }
        while ( v42 < *(_BYTE *)(v1 + 25) );
        result = v52;
      }
      v52 = ++result;
    }
    while ( result < *(_BYTE *)(v1 + 24) );
  }
  v47 = 0;
  if ( *(_BYTE *)(v1 + 24) )
  {
    do
    {
      v48 = v47;
      if ( *(_BYTE *)(v47 + v2 + 956) )
      {
        v49 = *(float *)(v2 + 4 * v47 + 1004);
        result = sub_1003B0B0(
                   *(float *)(v2 + 4 * v47 + 1004),
                   *(float *)(v2 + 4 * v47 + 1016),
                   (int)&unk_100BF5F4,
                   v2 + 956);
        *(float *)(v2 + 4 * v47 + 1016) = v49;
      }
      ++v47;
      *(float *)(v2 + 4 * v48 + 1628) = *(float *)(v2 + 4 * v48 + 1616);
      *(_BYTE *)(v48 + v2 + 1568) = *(_BYTE *)(v48 + v2 + 956);
    }
    while ( v47 < *(_BYTE *)(dword_1031FB44 + 24) );
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001CBB0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001CBB0(int a1)
{
  int v1; // esi@1
  float *v2; // ebx@1
  float *v3; // ebp@1
  double v4; // st7@2
  double v5; // st7@4
  float *v6; // ebx@5
  float *v7; // ebp@5
  char v8; // al@5
  bool v9; // zf@5
  double v10; // st7@6
  double v11; // st7@8
  char v12; // al@9
  char *v13; // edi@9
  char v14; // al@10
  char v15; // al@12
  char v16; // al@13
  double v17; // st7@16
  double v18; // st7@18
  char v19; // bl@19
  char *v20; // eax@19
  _BYTE *v21; // edx@19
  char v22; // cl@20
  char *v23; // eax@21
  int v24; // ecx@21
  _BYTE *v25; // edx@21
  double v26; // st7@24
  double v27; // st7@25
  float *v28; // ebx@31
  float *v29; // ebp@31
  char v30; // al@31
  double v31; // st7@32
  double v32; // st7@34
  float *v33; // ebx@35
  float *v34; // ebp@35
  char v35; // al@35
  double v36; // st7@36
  double v37; // st7@38
  float *v38; // ebx@39
  float *v39; // ebp@39
  char v40; // al@39
  double v41; // st7@40
  double v42; // st7@42
  char v43; // al@43
  char *v44; // edi@43
  char v45; // al@44
  char v46; // al@46
  char v47; // al@47
  double v48; // st7@50
  double v49; // st7@52
  float *v50; // ebx@53
  float *v51; // ebp@53
  char v52; // al@53
  double v53; // st7@54
  double v54; // st7@56
  float *v55; // edi@57
  char v56; // al@57
  double v57; // st7@58
  float *v58; // edi@60
  char v59; // al@60
  double v60; // st7@61
  unsigned __int8 result; // al@64
  char v62; // [sp+23h] [bp-19h]@62
  int v63; // [sp+24h] [bp-18h]@10
  float v64; // [sp+28h] [bp-14h]@9
  float v65; // [sp+2Ch] [bp-10h]@43
  double v66; // [sp+30h] [bp-Ch]@23
  float v67; // [sp+38h] [bp-4h]@27

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 1732);
  v3 = (float *)(v1 + 1736);
  *(_BYTE *)(v1 + 1684) = sub_10066790(0x1Eu, (float *)(v1 + 1732));
  *(_BYTE *)(v1 + 1685) = sub_10066790(0x37u, (float *)(v1 + 1736));
  *(float *)(v1 + 1784) = sub_1004C070();
  if ( *(_BYTE *)(v1 + 1684) )
  {
    v4 = *v2;
    sub_1003B0B0(*v2, *(float *)(v1 + 1744), (int)&unk_100BF4F0, v1 + 1684);
    *(float *)(v1 + 1744) = v4;
  }
  if ( *(_BYTE *)(v1 + 1685) )
  {
    v5 = *v3;
    sub_1003B0B0(*v3, *(float *)(v1 + 1748), (int)&unk_100BF4F0, v1 + 1684);
    *(float *)(v1 + 1748) = v5;
  }
  v6 = (float *)(v1 + 1220);
  v7 = (float *)(v1 + 1224);
  *(_BYTE *)(v1 + 1172) = sub_100664A0((float *)(v1 + 1220));
  v8 = sub_10066510((float *)(v1 + 1224));
  v9 = *(_BYTE *)(v1 + 1172) == 0;
  *(_BYTE *)(v1 + 1173) = v8;
  if ( !v9 )
  {
    v10 = *v6;
    sub_1003B0B0(*v6, *(float *)(v1 + 1232), (int)&unk_100BF598, v1 + 1172);
    *(float *)(v1 + 1232) = v10;
  }
  if ( *(_BYTE *)(v1 + 1173) )
  {
    v11 = *v7;
    sub_1003B0B0(*v7, *(float *)(v1 + 1236), (int)&unk_100BF598, v1 + 1172);
    *(float *)(v1 + 1236) = v11;
  }
  v12 = sub_100663D0(&v64);
  v13 = (char *)(v1 + 1056);
  *(_BYTE *)(v1 + 1056) = v12;
  if ( v12 )
  {
    v14 = sub_10031F70(100000.0, v64, (int)&v63);
    *v13 = v14;
    if ( v14 )
    {
      sub_100666C0(v1 + 1152, v63);
      *(float *)(v1 + 1104) = (double)*(signed int *)(v1 + 1156) / 100000.0;
    }
  }
  v15 = sub_100663F0(&v64);
  *(_BYTE *)(v1 + 1057) = v15;
  if ( v15 )
  {
    v16 = sub_10031F70(100000.0, v64, (int)&v63);
    *(_BYTE *)(v1 + 1057) = v16;
    if ( v16 )
    {
      sub_100666C0(v1 + 1160, v63);
      *(float *)(v1 + 1108) = (double)*(signed int *)(v1 + 1164) / 100000.0;
    }
  }
  if ( *v13 )
  {
    v17 = *(float *)(v1 + 1104);
    sub_1003B0B0(*(float *)(v1 + 1104), *(float *)(v1 + 1116), (int)&unk_100BF520, v1 + 1056);
    *(float *)(v1 + 1116) = v17;
  }
  if ( *(_BYTE *)(v1 + 1057) )
  {
    v18 = *(float *)(v1 + 1108);
    sub_1003B0B0(*(float *)(v1 + 1108), *(float *)(v1 + 1120), (int)&unk_100BF520, v1 + 1056);
    *(float *)(v1 + 1120) = v18;
  }
  v19 = sub_10066410(&v64);
  v20 = sub_1006C690(0x1215u, 0);
  v21 = (_BYTE *)(v1 + 1268);
  do
  {
    v22 = *v20;
    *v21++ = *v20++;
  }
  while ( v22 );
  v23 = sub_1006C690(2u, 0);
  v25 = (_BYTE *)(v1 + 1680);
  do
  {
    LOBYTE(v24) = *v23;
    *v25++ = *v23++;
  }
  while ( (_BYTE)v24 );
  *(float *)(v1 + 1272) = sub_1004C0D0(v24, v25);
  *(float *)(v1 + 1676) = sub_1004C0C0();
  v66 = *(float *)(v1 + 1272);
  if ( sub_1004BFC0() < v66 )
  {
    *(float *)(v1 + 1272) = sub_1004BFC0();
    v26 = 0.0;
    *(_DWORD *)(v1 + 1052) = 0;
    *(float *)(v1 + 1676) = 0.0;
    goto LABEL_31;
  }
  *(float *)&v66 = sub_1004C0C0();
  v27 = *(float *)&v66;
  *(float *)(v1 + 1676) = *(float *)&v66;
  if ( v19 && 360000.0 * v64 > v27 )
  {
    *(_DWORD *)(v1 + 1052) = (signed int)(v27 / v64);
    if ( sub_1006CA40(&v67) )
    {
      v26 = (double)*(signed int *)(v1 + 1052) * v67;
      goto LABEL_31;
    }
  }
  else
  {
    *(_DWORD *)(v1 + 1052) = 0x7FFFFFFF;
  }
  v26 = 9.8999998e24;
LABEL_31:
  v28 = (float *)(v1 + 1520);
  *(float *)(v1 + 1672) = v26;
  v29 = (float *)(v1 + 1524);
  *(_BYTE *)(v1 + 1472) = sub_10066790(0x1Du, (float *)(v1 + 1520));
  v30 = sub_10066790(0x36u, (float *)(v1 + 1524));
  v9 = *(_BYTE *)(v1 + 1472) == 0;
  *(_BYTE *)(v1 + 1473) = v30;
  if ( !v9 )
  {
    v31 = *v28;
    sub_1003B0B0(*v28, *(float *)(v1 + 1532), (int)&unk_100BF548, v1 + 1472);
    *(float *)(v1 + 1532) = v31;
  }
  if ( *(_BYTE *)(v1 + 1473) )
  {
    v32 = *v29;
    sub_1003B0B0(*v29, *(float *)(v1 + 1536), (int)&unk_100BF548, v1 + 1472);
    *(float *)(v1 + 1536) = v32;
  }
  v33 = (float *)(v1 + 1328);
  v34 = (float *)(v1 + 1332);
  *(_BYTE *)(v1 + 1280) = sub_10066790(0x18u, (float *)(v1 + 1328));
  v35 = sub_10066790(0x31u, (float *)(v1 + 1332));
  v9 = *(_BYTE *)(v1 + 1280) == 0;
  *(_BYTE *)(v1 + 1281) = v35;
  if ( !v9 )
  {
    v36 = *v33;
    sub_1003B0B0(*v33, *(float *)(v1 + 1340), (int)&unk_100BF504, v1 + 1280);
    *(float *)(v1 + 1340) = v36;
  }
  if ( *(_BYTE *)(v1 + 1281) )
  {
    v37 = *v34;
    sub_1003B0B0(*v34, *(float *)(v1 + 1344), (int)&unk_100BF504, v1 + 1280);
    *(float *)(v1 + 1344) = v37;
  }
  v38 = (float *)(v1 + 1424);
  v39 = (float *)(v1 + 1428);
  *(_BYTE *)(v1 + 1376) = sub_10066790(0x1Cu, (float *)(v1 + 1424));
  v40 = sub_10066790(0x35u, (float *)(v1 + 1428));
  v9 = *(_BYTE *)(v1 + 1376) == 0;
  *(_BYTE *)(v1 + 1377) = v40;
  if ( !v9 )
  {
    v41 = *v38;
    sub_1003B0B0(*v38, *(float *)(v1 + 1436), (int)&unk_100BF55C, v1 + 1376);
    *(float *)(v1 + 1436) = v41;
  }
  if ( *(_BYTE *)(v1 + 1377) )
  {
    v42 = *v39;
    sub_1003B0B0(*v39, *(float *)(v1 + 1440), (int)&unk_100BF55C, v1 + 1376);
    *(float *)(v1 + 1440) = v42;
  }
  v43 = sub_10066790(1u, &v65);
  v44 = (char *)(v1 + 224);
  *(_BYTE *)(v1 + 224) = v43;
  if ( v43 )
  {
    v45 = sub_10031F70(100.0, v65, (int)&v63);
    *v44 = v45;
    if ( v45 )
    {
      sub_100666C0(v1 + 320, v63);
      *(float *)(v1 + 272) = (double)*(signed int *)(v1 + 324) / 100.0;
    }
  }
  v46 = sub_10066790(2u, &v65);
  *(_BYTE *)(v1 + 225) = v46;
  if ( v46 )
  {
    v47 = sub_10031F70(100.0, v65, (int)&v63);
    *(_BYTE *)(v1 + 225) = v47;
    if ( v47 )
    {
      sub_100666C0(v1 + 328, v63);
      *(float *)(v1 + 276) = (double)*(signed int *)(v1 + 332) / 100.0;
    }
  }
  if ( *v44 )
  {
    v48 = *(float *)(v1 + 272);
    sub_1003B0B0(*(float *)(v1 + 272), *(float *)(v1 + 284), (int)&unk_100BF6A4, v1 + 224);
    *(float *)(v1 + 284) = v48;
  }
  if ( *(_BYTE *)(v1 + 225) )
  {
    v49 = *(float *)(v1 + 276);
    sub_1003B0B0(*(float *)(v1 + 276), *(float *)(v1 + 288), (int)&unk_100BF6A4, v1 + 224);
    *(float *)(v1 + 288) = v49;
  }
  v50 = (float *)(v1 + 1836);
  v51 = (float *)(v1 + 1840);
  *(_BYTE *)(v1 + 1788) = sub_100663B0((float *)(v1 + 1836));
  sub_100663C0(v1 + 1840);
  v9 = *(_BYTE *)(v1 + 1788) == 0;
  *(_BYTE *)(v1 + 1789) = v52;
  if ( !v9 )
  {
    v53 = *v50;
    sub_1003B0B0(*v50, *(float *)(v1 + 1848), (int)&unk_100BF690, v1 + 1788);
    *(float *)(v1 + 1848) = v53;
  }
  if ( *(_BYTE *)(v1 + 1789) )
  {
    v54 = *v51;
    sub_1003B0B0(*v51, *(float *)(v1 + 1852), (int)&unk_100BF690, v1 + 1788);
    *(float *)(v1 + 1852) = v54;
  }
  v55 = (float *)(v1 + 788);
  v56 = sub_10066790(0x6Du, (float *)(v1 + 788));
  *(_BYTE *)(v1 + 740) = v56;
  if ( v56 )
  {
    v57 = *v55;
    sub_1003B0B0(*v55, *(float *)(v1 + 800), (int)&unk_100BF770, v1 + 740);
    *(float *)(v1 + 800) = v57;
  }
  if ( *(_BYTE *)(v1 + 736) != 1 )
    return sub_1001C320(a1);
  v58 = (float *)(v1 + 688);
  v59 = sub_10066790(0x9Bu, (float *)(v1 + 688));
  *(_BYTE *)(v1 + 640) = v59;
  if ( v59 )
  {
    v60 = *v58;
    sub_1003B0B0(*v58, *(float *)(v1 + 700), (int)&unk_100BF6B8, v1 + 640);
    *(float *)(v1 + 700) = v60;
  }
  if ( sub_10067000(0xBCu, &v62) != 1 )
  {
    *(float *)(v1 + 656) = *(float *)(dword_1031FB44 + 20420);
    return sub_1001C320(a1);
  }
  if ( v62 == 1 )
  {
    *(float *)(v1 + 664) = -1.0;
    result = sub_1001C320(a1);
  }
  else
  {
    *(float *)(v1 + 664) = *(float *)(dword_1031FB44 + 20428);
    result = sub_1001C320(a1);
  }
  return result;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001D390) --------------------------------------------------------
bool __cdecl sub_1001D390(int a1)
{
  int v1; // edi@1
  int v2; // ebp@1
  void *v3; // ecx@1
  signed int v4; // edx@3
  int v5; // ecx@3
  int v6; // eax@3
  int v7; // esi@5
  unsigned __int8 v8; // cl@5
  unsigned __int8 v9; // al@6
  unsigned __int8 v10; // dl@7
  int v11; // ecx@8
  int v12; // eax@9
  int v13; // ST54_4@9
  float *v14; // esi@9
  float v15; // ST54_4@9
  double v16; // st6@9
  float v17; // ST54_4@9
  float *v18; // edi@9
  float v19; // ST54_4@9
  double v20; // st5@9
  float v21; // ST54_4@9
  float v22; // ST54_4@9
  float v23; // ST54_4@9
  bool result; // al@15
  unsigned __int8 v25; // [sp+Bh] [bp-9h]@5
  int v26; // [sp+10h] [bp-4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v26 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1001CBB0(a1);
  if ( sub_10052210(v3) == 2 )
  {
    if ( *(_BYTE *)(v2 + 1884) )
    {
      sub_1001B420(a1);
      v4 = 3;
      v5 = v2 + 1684;
      v6 = v2 + 1732;
      do
      {
        *(float *)(v6 - 404) = *(float *)(dword_1031FB44 + 568) * 0.8700000047683716;
        *(float *)v6 = *(float *)(dword_1031FB44 + 888);
        *(float *)(v6 - 512) = *(float *)(dword_1031FB44 + 1004);
        *(float *)(v6 - 628) = *(float *)(dword_1031FB44 + 308);
        *(float *)(v6 - 1244) = *(float *)(dword_1031FB44 + 180);
        *(float *)(v6 - 212) = *(float *)(dword_1031FB44 + 820);
        *(float *)(v6 - 308) = *(float *)(dword_1031FB44 + 756);
        *(float *)(v6 - 1460) = *(float *)(dword_1031FB44 + 52);
        *(float *)(v6 - 1044) = *(float *)(dword_1031FB44 + 20424);
        *(float *)(v6 + 104) = *(float *)(dword_1031FB44 + 1100);
        *(float *)(v6 - 728) = *(float *)(dword_1031FB44 + 244);
        *(float *)(v6 - 1148) = *(float *)(dword_1031FB44 + 180);
        *(float *)(v6 - 116) = *(float *)(dword_1031FB44 + 244);
        *(float *)(v6 - 944) = *(float *)(dword_1031FB44 + 20332) * 0.6000000238418579;
        *(float *)(v6 - 392) = *(float *)(dword_1031FB44 + 568) * 0.8700000047683716;
        *(float *)(v6 + 12) = *(float *)(dword_1031FB44 + 888);
        *(float *)(v6 - 500) = *(float *)(dword_1031FB44 + 1004);
        *(float *)(v6 - 616) = *(float *)(dword_1031FB44 + 308);
        *(float *)(v6 - 1232) = *(float *)(dword_1031FB44 + 180);
        *(float *)(v6 - 200) = *(float *)(dword_1031FB44 + 820);
        *(float *)(v6 - 296) = *(float *)(dword_1031FB44 + 756);
        *(float *)(v6 - 1448) = *(float *)(dword_1031FB44 + 52);
        *(float *)(v6 - 1032) = *(float *)(dword_1031FB44 + 20424);
        *(float *)(v6 + 116) = *(float *)(dword_1031FB44 + 1100);
        *(float *)(v6 - 716) = *(float *)(dword_1031FB44 + 244);
        *(float *)(v6 - 1136) = *(float *)(dword_1031FB44 + 180);
        v6 += 4;
        *(float *)(v6 - 108) = *(float *)(dword_1031FB44 + 244);
        *(float *)(v6 - 936) = *(float *)(dword_1031FB44 + 20332) * 0.6000000238418579;
        *(_BYTE *)(v5 - 404) = 1;
        *(_BYTE *)v5 = 1;
        *(_BYTE *)(v5 - 512) = 1;
        *(_BYTE *)(v5 - 628) = 1;
        *(_BYTE *)(v5 - 1244) = 1;
        *(_BYTE *)(v5 - 212) = 1;
        *(_BYTE *)(v5 - 308) = 1;
        *(_BYTE *)(v5 - 1460) = 1;
        *(_BYTE *)(v5 - 1044) = 1;
        *(_BYTE *)(v5 + 104) = 1;
        *(_BYTE *)(v5 - 728) = 1;
        *(_BYTE *)(v5 - 1148) = 1;
        *(_BYTE *)(v5 - 116) = 1;
        *(_BYTE *)(v5++ - 944) = 1;
        --v4;
      }
      while ( v4 );
      v7 = dword_1031FB44;
      v8 = 0;
      v25 = 0;
      if ( *(_BYTE *)(dword_1031FB44 + 24) )
      {
        v9 = *(_BYTE *)(dword_1031FB44 + 25);
        do
        {
          v10 = 0;
          if ( v9 )
          {
            v11 = v2 + 48 * v8;
            do
            {
              v12 = v10;
              v13 = 50 * v10;
              v14 = (float *)(v7 + 228);
              ++v10;
              v15 = (double)v13;
              v16 = v15;
              v17 = *v14 + 100.0 + v15;
              *(float *)(*(_DWORD *)(v11 + 872) + 4 * v12) = v17;
              v18 = (float *)(dword_1031FB44 + 180);
              v19 = (double)(30 * v12);
              v20 = v19;
              v21 = v19 + *(float *)(dword_1031FB44 + 180);
              *(float *)(*(_DWORD *)(v11 + 372) + 4 * v12) = v21;
              v22 = v16 + *v14 + 100.0;
              *(float *)(*(_DWORD *)(v11 + 868) + 4 * v12) = v22;
              v23 = v20 + *v18;
              *(float *)(*(_DWORD *)(v11 + 368) + 4 * v12) = v23;
              *(_BYTE *)(v12 + *(_DWORD *)(v11 + 844)) = 1;
              *(_BYTE *)(v12 + *(_DWORD *)(v11 + 344)) = 1;
              v7 = dword_1031FB44;
              v9 = *(_BYTE *)(dword_1031FB44 + 25);
            }
            while ( v10 < v9 );
            v2 = v26;
            v1 = a1;
            v8 = v25;
          }
          v25 = ++v8;
        }
        while ( v8 < *(_BYTE *)(v7 + 24) );
      }
    }
  }
  if ( *(_BYTE *)(v2 + 1276) )
    *(_BYTE *)(*(_DWORD *)(v2 + 208) + 4) = 3;
  else
    *(_BYTE *)(*(_DWORD *)(v2 + 208) + 4) = 0;
  sub_1004AA20(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BF390, (int)&unk_100BF7D0, 0, 255);
  sub_1004AA20(
    v1,
    *(_WORD **)(v1 + 52),
    (char *)*(&off_100BF834 + *(_BYTE *)(v2 + 1668)),
    (int)(&off_100BF848)[*(_BYTE *)(v2 + 1668)],
    0,
    255);
  sub_1004AA20(v1, *(_WORD **)(v1 + 52), (char *)&unk_100BF4F0, v2, 0, 255);
  result = sub_1004AA20(
             v1,
             *(_WORD **)(v1 + 52),
             *(char **)(v2 + 4 * *(_BYTE *)(v2 + 1668) + 184),
             *(_DWORD *)(v2 + 4 * *(_BYTE *)(v2 + 1668) + 164),
             *(_DWORD *)(v2 + 4 * *(_BYTE *)(v2 + 1668) + 204),
             255);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}
// 100BF834: using guessed type void *off_100BF834;
// 100BF848: using guessed type void **off_100BF848;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001D810) --------------------------------------------------------
char __cdecl sub_1001D810(int a1, char a2, char a3)
{
  int v3; // eax@1
  __int16 v4; // cx@4
  __int16 v5; // ax@7

  v3 = **(_WORD **)(a1 + 52);
  switch ( v3 )
  {
    case 32789:
    case 32790:
      LOBYTE(v3) = sub_1001B830(a1);
      break;
    case 32833:
      if ( a2 )
      {
        v4 = 47;
        if ( a3 )
        {
          if ( a3 == 1 )
          {
            v5 = 151;
          }
          else if ( a3 == 2 )
          {
            v5 = 302;
          }
          else
          {
            v5 = a1;
          }
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        v5 = 0;
        v4 = 0;
      }
      LOBYTE(v3) = sub_1001BA70(a1, v5, v4);
      if ( a2 )
      {
        v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
        *(_BYTE *)(v3 + 1668) = a3;
      }
      break;
    case 32802:
    case 32888:
      LOBYTE(v3) = sub_1001D390(a1);
      break;
    case 32819:
    case 32824:
      LOBYTE(v3) = sub_1001C1F0(a1);
      break;
    case 32821:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 1884) = 0;
      break;
    case 32820:
      LOBYTE(v3) = a1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 1884) = 1;
      break;
    case 32825:
      LOBYTE(v3) = sub_1001B8B0(a1);
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1001D950) --------------------------------------------------------
void __usercall sub_1001D950(unsigned __int8 a1@<dl>, unsigned __int8 a2@<bl>, int a3, char *a4)
{
  char *v4; // esi@2
  char *v5; // ecx@2
  int v6; // edi@2
  char v7; // al@4
  char v8; // al@9

  if ( a1 )
  {
    v4 = a4;
    v5 = (char *)(a3 + 1);
    v6 = a1;
    while ( 1 )
    {
      if ( a3 )
      {
        v7 = *v5;
        if ( (unsigned __int8)*v5 > a2 )
          goto LABEL_7;
        if ( *v5 == a2 )
          break;
      }
LABEL_8:
      if ( a4 )
      {
        v8 = *v4;
        if ( (unsigned __int8)*v4 > a2 )
          goto LABEL_12;
        if ( *v4 == a2 )
        {
          v8 = a1;
LABEL_12:
          *v4 = v8 - 1;
          goto LABEL_13;
        }
      }
LABEL_13:
      v5 += 44;
      v4 += 40;
      if ( !--v6 )
        return;
    }
    v7 = a1;
LABEL_7:
    *v5 = v7 - 1;
    goto LABEL_8;
  }
}

//----- (1001D9A0) --------------------------------------------------------
char __usercall sub_1001D9A0@<al>(int a1@<esi>)
{
  char v1; // ST27_1@1
  char v2; // bl@1
  char v3; // ST27_1@1
  char v4; // bl@1
  char v5; // ST27_1@1
  char v6; // bl@1
  char v7; // ST27_1@1
  char result; // al@1
  double v9; // st7@6
  double v10; // st7@16
  float v11; // [sp+8h] [bp-4h]@16

  v1 = 2 * sub_1006C420(0x38u);
  v2 = 2 * (v1 | sub_1006C420(0x1Fu));
  v3 = 2 * (v2 | sub_1006C420(0xB0u));
  v4 = 2 * (v3 | sub_1006C420(0x56u));
  v5 = 2 * (v4 | sub_1006C420(0x70u));
  v6 = 2 * (v5 | sub_1006C420(0x67u));
  v7 = 2 * (v6 | sub_1006C420(0x68u));
  result = v7 | sub_1006C420(0x69u);
  *(_BYTE *)(a1 + 242192) = result;
  if ( result & 0x40 || result & 0x20 )
  {
    *(float *)(a1 + 396) = 523.0;
    *(float *)(a1 + 400) = 844.0;
    *(float *)(a1 + 424) = 145.0;
    if ( result & 0x40 )
    {
      *(_BYTE *)(a1 + 457) = 1;
      *(_BYTE *)(a1 + 456) = 0;
      goto LABEL_5;
    }
  }
  else
  {
    *(float *)(a1 + 396) = 543.0;
    *(float *)(a1 + 400) = 824.0;
    *(float *)(a1 + 424) = 145.0;
  }
  *(_BYTE *)(a1 + 456) = 1;
  *(_BYTE *)(a1 + 457) = 0;
LABEL_5:
  if ( result & 0x10 )
  {
    *(float *)(a1 + 428) = 47.5;
    *(float *)(a1 + 432) = 132.5;
    *(float *)(a1 + 436) = 217.5;
    *(float *)(a1 + 440) = 302.5;
    v9 = 387.5;
  }
  else
  {
    *(float *)(a1 + 428) = 68.0;
    *(float *)(a1 + 432) = 174.0;
    *(float *)(a1 + 440) = 280.0;
    v9 = 386.0;
  }
  *(float *)(a1 + 444) = v9;
  if ( (result & 2 || result & 1) && result & 0xC )
    goto LABEL_22;
  if ( result & 0xC )
  {
    v11 = 838.0;
    v10 = 171.0;
    goto LABEL_19;
  }
  if ( result & 2 || result & 1 )
  {
LABEL_22:
    v11 = 838.0;
    v10 = 152.0;
    goto LABEL_19;
  }
  v11 = 748.0;
  v10 = 171.0;
LABEL_19:
  *(float *)(a1 + 452) = v10;
  *(float *)(a1 + 408) = 332.0;
  *(float *)(a1 + 404) = v11 - 166.0;
  *(float *)(a1 + 412) = v11 - 100.0;
  return result;
}

//----- (1001DB90) --------------------------------------------------------
int __usercall sub_1001DB90@<eax>(int a1@<esi>)
{
  int result; // eax@2

  j_gdi_pvg_color_u32(-1);
  sub_1008C110(1.0);
  j_gdi_pvg_begin(67);
  sub_1008C2F0(151.0, 0.0);
  sub_1008C2F0(151.0, *(float *)(a1 + 448));
  sub_1008C2F0(0.0, *(float *)(a1 + 448));
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  if ( *(_BYTE *)(a1 + 242192) & 3 )
  {
    sub_1008C2F0(151.0, 469.0);
    sub_1008C2F0(209.0, 469.0);
    sub_1008C2F0(209.0, 686.0);
    result = j_gdi_pvg_end();
  }
  else
  {
    sub_1008C2F0(151.0, *(float *)(a1 + 448));
    sub_1008C2F0(151.0, 686.0);
    result = j_gdi_pvg_end();
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1001DC90) --------------------------------------------------------
double __usercall sub_1001DC90@<st0>(int a1@<edi>, signed int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@2
  int v4; // eax@2
  double v5; // st7@3
  float v6; // ST04_4@3
  float v7; // ST04_4@3
  float v8; // ST04_4@3
  double v9; // st7@5
  float v11; // [sp+4h] [bp-8h]@1
  float v12; // [sp+8h] [bp-4h]@1

  v11 = 0.0;
  v2 = 0;
  v12 = 0.0;
  if ( a2 >= 4 )
  {
    v3 = ((unsigned int)(a2 - 4) >> 2) + 1;
    v4 = a1 + 8;
    v2 = 4 * v3;
    do
    {
      v5 = *(float *)(v4 - 8);
      v4 += 16;
      --v3;
      v6 = v5 + v11;
      v7 = v6 + *(float *)(v4 - 20);
      v8 = v7 + *(float *)(v4 - 16);
      v11 = v8 + *(float *)(v4 - 12);
    }
    while ( v3 );
  }
  for ( ; v2 < a2; v11 = v9 + v11 )
    v9 = *(float *)(a1 + 4 * v2++);
  if ( a2 > 0 )
    v12 = v11 / (double)a2;
  return v12;
}

//----- (1001DD30) --------------------------------------------------------
int __usercall sub_1001DD30@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3)
{
  unsigned int v3; // edi@1
  int result; // eax@1
  unsigned int v5; // eax@2

  v3 = 0;
  result = 0;
  if ( a2 )
  {
    memcpy((void *)a1, (const void *)(a1 + 4), 4 * a2 - 4);
    v5 = 0;
    *(_DWORD *)(a1 + 4 * a2 - 4) = a3;
    if ( a2 )
    {
      do
        v3 += *(_DWORD *)(a1 + 4 * v5++);
      while ( v5 < a2 );
    }
    result = v3 / a2;
  }
  return result;
}

//----- (1001DD80) --------------------------------------------------------
__int16 __cdecl sub_1001DD80(float a1)
{
  __int16 v1; // fps@1
  bool v2; // c0@1
  char v3; // c2@1
  bool v4; // c3@1
  char v5; // ah@1
  __int16 v6; // fps@1
  double v7; // st6@1
  char v8; // al@2
  bool v9; // c0@4
  char v10; // c2@4
  bool v11; // c3@4
  __int16 result; // ax@4

  v2 = a1 < 95.0;
  v3 = 0;
  v4 = a1 == 95.0;
  v5 = HIBYTE(v1);
  v7 = a1;
  if ( __SETP__(v5 & 0x44, 0) )
    v8 = 0;
  else
    v8 = 1;
  LOBYTE(result) = byte_10169054 ^ v8;
  v9 = v7 < 95.0;
  v10 = 0;
  v11 = v7 == 95.0;
  byte_10169054 = 1;
  HIBYTE(result) = HIBYTE(v6);
  if ( v7 != 95.0 )
    byte_10169054 = 0;
  return result;
}
// 10169054: using guessed type char byte_10169054;

//----- (1001DDD0) --------------------------------------------------------
int __usercall sub_1001DDD0@<eax>(int a1@<esi>)
{
  double v1; // st7@1
  double v2; // st7@1
  unsigned __int8 v3; // bl@1
  double v4; // st7@1
  float v5; // ST44_4@1
  float v6; // ST44_4@1
  double v7; // st7@1
  double v8; // st7@1
  double v9; // st7@1
  double v10; // st6@1
  float v11; // ST44_4@1
  int result; // eax@1
  double v13; // st7@1

  sub_10042820(a1 + 12732, (int)"MAN IN HG", dword_1031FB44 + 3912, 20.0, 20.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20480, a1 + 12732);
  *(float *)(a1 + 12968) = 165.0;
  *(float *)(a1 + 13072) = *(float *)(a1 + 12972) - 165.0;
  *(_WORD *)(a1 + 18306) = 5;
  *(_BYTE *)(a1 + 18312) = 1;
  *(_DWORD *)(a1 + 18308) = byte_100B8180;
  sub_10060F20(a1 + 460, 1, a1 + 12748);
  sub_10042980((_BYTE *)(dword_1031FB44 + 3912), a1 + 12732);
  sub_10062160(16931.934, 8465.9668, -0.2, a1 + 12748);
  sub_10061F10(16931.934, "%.0f", 1.0, 12.0, -0.2, a1 + 12748);
  v1 = *(float *)(a1 + 12852) + 20.0;
  *(_BYTE *)(a1 + 378) = 3;
  *(float *)(a1 + 12852) = v1;
  *(float *)(a1 + 15052) = *(float *)(a1 + 15052) + 20.0;
  sub_10042820(a1 + 24560, (int)"RPM", dword_1031FB44 + 4076, 20.0, 250.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20508, a1 + 24560);
  *(_WORD *)(a1 + 30134) = 6;
  sub_10060F20(a1 + 472, 1, a1 + 24576);
  *(float *)(a1 + 24796) = 165.0;
  *(_BYTE *)(a1 + 30140) = 1;
  v2 = *(float *)(a1 + 24800);
  *(_DWORD *)(a1 + 30136) = byte_100B8180;
  *(float *)(a1 + 24900) = v2 - 165.0;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4076), a1 + 24560);
  v3 = sub_10062160(500.0, 100.0, -0.2, a1 + 24576);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 12.0, -0.2, a1 + 24576);
  sub_10060FA0(1500.0, "x100", 1.0, 12.0, -0.60000002, v3, a1 + 24576);
  v4 = *(float *)(a1 + 24680) + 20.0;
  *(_BYTE *)(a1 + 30132) = v3 + 1;
  *(float *)(a1 + 24680) = v4;
  *(float *)(a1 + 26880) = *(float *)(a1 + 26880) + 20.0;
  *(_BYTE *)(a1 + 379) = 3;
  sub_10042820(a1 + 67808, (int)&word_100B8D60, dword_1031FB44 + 4568, 250.0, 250.0, 215.0, 215.0);
  *(float *)(a1 + 68044) = 140.0;
  *(float *)(a1 + 68048) = 240.0;
  *(float *)(a1 + 68148) = 100.0;
  *(float *)(a1 + 67856) = *(float *)(a1 + 67832) * 0.5;
  sub_10042990(dword_1031FB44 + 20592, a1 + 67808);
  sub_10060F20(a1 + 568, 1, a1 + 67824);
  *(_WORD *)(a1 + 73382) = 17;
  *(_BYTE *)(a1 + 73388) = 1;
  *(_DWORD *)(a1 + 73384) = byte_100B8180;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4568), a1 + 67808);
  v5 = *(float *)(dword_1031FB44 + 4576) - *(float *)(dword_1031FB44 + 4572);
  sub_10062160(v5, 0.0, -0.2, a1 + 67824);
  v6 = *(float *)(dword_1031FB44 + 4576) - *(float *)(dword_1031FB44 + 4572);
  sub_10061F10(v6, "%.0f", 1.0, 12.0, 9.0, a1 + 67824);
  *(float *)(a1 + 70164) = 15.0;
  *(float *)(a1 + 70124) = *(float *)(a1 + 70124) - 30.0;
  *(float *)(a1 + 67924) = *(float *)(a1 + 67924) - 30.0;
  *(float *)(a1 + 70128) = *(float *)(a1 + 70128) + 20.0;
  *(float *)(a1 + 67928) = *(float *)(a1 + 67928) + 20.0;
  sub_100649E0(a1 + 67992, "OIL", 21);
  v7 = *(float *)(a1 + 67980) + 3.0;
  *(_BYTE *)(a1 + 380) = 3;
  *(float *)(a1 + 67980) = v7;
  sub_10042820(a1 + 78532, (int)"PSI", dword_1031FB44 + 4404, 250.0, 250.0, 215.0, 215.0);
  *(float *)(a1 + 78768) = 40.0;
  *(float *)(a1 + 78772) = -60.0;
  *(float *)(a1 + 78872) = -100.0;
  v8 = *(float *)(a1 + 78556);
  *(_WORD *)(a1 + 84106) = 15;
  v9 = v8 * 0.5;
  *(_BYTE *)(a1 + 84112) = 1;
  v10 = *(float *)(a1 + 78548);
  *(_DWORD *)(a1 + 84108) = byte_100B8180;
  *(float *)(a1 + 78572) = v10 + v9;
  *(float *)(a1 + 78580) = v9;
  sub_10060F20(a1 + 580, 1, a1 + 78548);
  sub_10042990(dword_1031FB44 + 20564, a1 + 78532);
  sub_10042980((_BYTE *)(dword_1031FB44 + 4404), a1 + 78532);
  v11 = *(float *)(dword_1031FB44 + 4412) - *(float *)(dword_1031FB44 + 4408);
  result = sub_10062160(v11, 0.0, -0.2, a1 + 78548);
  *(_DWORD *)(a1 + 84144) = 59;
  *(float *)(a1 + 80888) = 15.0;
  v13 = *(float *)(a1 + 80848);
  *(_BYTE *)(a1 + 381) = 3;
  *(float *)(a1 + 80848) = v13 + 25.0;
  *(float *)(a1 + 78648) = *(float *)(a1 + 78648) + 25.0;
  *(float *)(a1 + 80852) = *(float *)(a1 + 80852) + 20.0;
  *(float *)(a1 + 78652) = *(float *)(a1 + 78652) + 20.0;
  return result;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001E3B0) --------------------------------------------------------
void __usercall sub_1001E3B0(int a1@<esi>)
{
  sub_10044E50(a1 + 181816, (int)"CARB F", dword_1031FB44 + 5060, 696.0, 472.0, 50.0, 175.0);
  sub_10042DB0(dword_1031FB44 + 20676, a1 + 181816);
  *(_WORD *)(a1 + 193266) = 17;
  *(_BYTE *)(a1 + 193272) = 1;
  *(_DWORD *)(a1 + 193268) = byte_100B8180;
  sub_10044260(*(float *)(dword_1031FB44 + 5064), 0.30000001, a1 + 181816);
  sub_10042B40(*(float *)(dword_1031FB44 + 5064), "%.0f", 1.0, 9.0, 0, a1 + 181816);
  sub_10044260(0.0, 0.18000001, a1 + 181816);
  sub_10042B40(0.0, "%.0f", 1.0, 9.0, 1, a1 + 181816);
  sub_10044260(-17.7777, 0.18000001, a1 + 181816);
  sub_10042B40(-17.7777, "%.0f", 1.0, 9.0, 2, a1 + 181816);
  sub_10044260(*(float *)(dword_1031FB44 + 5068), 0.30000001, a1 + 181816);
  sub_10042B40(*(float *)(dword_1031FB44 + 5068), "%.0f", 1.0, 9.0, 3, a1 + 181816);
  *(float *)(a1 + 181972) = 0.5;
  *(float *)(a1 + 181932) = 736.0;
  *(float *)(a1 + 181936) = *(float *)(a1 + 181936) - 26.0;
  *(float *)(a1 + 193144) = 0.5;
  *(float *)(a1 + 193112) = 736.0;
  *(float *)(a1 + 182252) = 8.0;
  *(float *)(a1 + 182244) = *(float *)(a1 + 182244) + 24.0;
  sub_10042D60(a1 + 892, 1, 1, a1 + 181816);
  *(_BYTE *)(a1 + 384) = 3;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001E5E0) --------------------------------------------------------
char __usercall sub_1001E5E0@<al>(int a1@<esi>)
{
  float v1; // ST40_4@1
  float v2; // ST40_4@1
  float v3; // ST40_4@1
  float v4; // ST40_4@1
  unsigned __int8 v5; // bl@1
  float v6; // ST40_4@1
  double v7; // st7@1
  float v8; // ST40_4@1
  float v9; // ST40_4@1
  float v10; // ST40_4@1
  float v11; // ST40_4@1
  float v12; // ST40_4@1
  float v13; // ST40_4@1
  char result; // al@1
  float v15; // ST40_4@1
  double v16; // st6@1

  sub_10044E50(a1 + 85376, (int)"ALT A", dword_1031FB44 + 5880, *(float *)(a1 + 428), 535.0, 30.0, 121.0);
  *(_WORD *)(a1 + 96826) = 22;
  *(_BYTE *)(a1 + 96832) = 1;
  *(_DWORD *)(a1 + 96828) = byte_100B8180;
  sub_10042D60(a1 + 592, 1, 1, a1 + 85376);
  v1 = *(float *)(a1 + 85492) + 2.0;
  *(float *)(a1 + 85492) = v1;
  *(float *)(a1 + 85496) = *(float *)(a1 + 85496) - 8.0;
  *(float *)(a1 + 96676) = *(float *)(a1 + 96676) - 8.0;
  *(float *)(a1 + 96672) = v1;
  *(float *)(a1 + 96704) = 0.5;
  sub_10042DB0(dword_1031FB44 + 20816, a1 + 85376);
  v2 = *(float *)(dword_1031FB44 + 5888) - *(float *)(dword_1031FB44 + 5884);
  sub_10044300(v2, 0.0, 0.30000001, a1 + 85376);
  v3 = *(float *)(dword_1031FB44 + 5888) - *(float *)(dword_1031FB44 + 5884);
  sub_10042C30(v3, "%.0f", 1.0, 9.0, a1 + 85376);
  sub_10044E50(a1 + 97032, (int)"BATT A", dword_1031FB44 + 6044, *(float *)(a1 + 432), 535.0, 30.0, 121.0);
  *(_WORD *)(a1 + 108482) = 22;
  *(_BYTE *)(a1 + 108488) = 1;
  *(_DWORD *)(a1 + 108484) = byte_100B8180;
  sub_10042D60(a1 + 604, 1, 1, a1 + 97032);
  sub_10042DB0(dword_1031FB44 + 20844, a1 + 97032);
  v4 = *(float *)(dword_1031FB44 + 6052) - *(float *)(dword_1031FB44 + 6048);
  v5 = sub_10044300(v4, 0.0, 0.30000001, a1 + 97032);
  v6 = *(float *)(dword_1031FB44 + 6052) - *(float *)(dword_1031FB44 + 6048);
  sub_10042C30(v6, "%.0f", 1.0, 9.0, a1 + 97032);
  sub_10065690(0.0, -0.30000001, 1.0, a1 + 98364, v5, a1 + 107968);
  sub_10064F60(0.0, "%.0f", 1.0, 9.0, 22, a1 + 98364, v5);
  v7 = *(float *)(a1 + 97148) + 4.0;
  *(_BYTE *)(a1 + 107964) = v5 + 1;
  v8 = v7;
  *(float *)(a1 + 97148) = v8;
  *(float *)(a1 + 97152) = *(float *)(a1 + 97152) - 8.0;
  *(float *)(a1 + 108332) = *(float *)(a1 + 108332) - 8.0;
  *(float *)(a1 + 108328) = v8;
  *(float *)(a1 + 108360) = 0.5;
  sub_10044E50(a1 + 120956, (int)"MAIN V", dword_1031FB44 + 6208, *(float *)(a1 + 440), 535.0, 30.0, 121.0);
  *(_WORD *)(a1 + 132406) = 21;
  *(_BYTE *)(a1 + 132412) = 1;
  *(_DWORD *)(a1 + 132408) = byte_100B8180;
  sub_10042D60(a1 + 616, 1, 1, a1 + 120956);
  sub_10042DB0(dword_1031FB44 + 20872, a1 + 120956);
  v9 = *(float *)(dword_1031FB44 + 6216) - *(float *)(dword_1031FB44 + 6212);
  sub_10044300(v9, 0.0, 0.30000001, a1 + 120956);
  v10 = *(float *)(dword_1031FB44 + 6216) - *(float *)(dword_1031FB44 + 6212);
  sub_10042C30(v10, "%.0f", 1.0, 9.0, a1 + 120956);
  v11 = *(float *)(a1 + 121072) + 6.0;
  *(float *)(a1 + 121072) = v11;
  *(float *)(a1 + 121076) = *(float *)(a1 + 121076) - 8.0;
  *(float *)(a1 + 132256) = *(float *)(a1 + 132256) - 8.0;
  *(float *)(a1 + 132252) = v11;
  *(float *)(a1 + 132284) = 0.5;
  sub_10044E50(a1 + 132612, (int)"ESS V", dword_1031FB44 + 6208, *(float *)(a1 + 444), 535.0, 30.0, 121.0);
  *(_WORD *)(a1 + 144062) = 21;
  *(_BYTE *)(a1 + 144068) = 1;
  *(_DWORD *)(a1 + 144064) = byte_100B8180;
  sub_10042D60(a1 + 628, 1, 1, a1 + 132612);
  sub_10042DB0(dword_1031FB44 + 20872, a1 + 132612);
  v12 = *(float *)(dword_1031FB44 + 6216) - *(float *)(dword_1031FB44 + 6212);
  sub_10044300(v12, 0.0, 0.30000001, a1 + 132612);
  v13 = *(float *)(dword_1031FB44 + 6216) - *(float *)(dword_1031FB44 + 6212);
  sub_10042C30(v13, "%.0f", 1.0, 9.0, a1 + 132612);
  result = 3;
  v15 = *(float *)(a1 + 132728) + 4.0;
  *(_BYTE *)(a1 + 372) = 3;
  *(_BYTE *)(a1 + 373) = 3;
  *(float *)(a1 + 132728) = v15;
  *(_BYTE *)(a1 + 375) = 3;
  v16 = *(float *)(a1 + 132732);
  *(_BYTE *)(a1 + 376) = 3;
  *(float *)(a1 + 132732) = v16 - 8.0;
  *(float *)(a1 + 143912) = *(float *)(a1 + 143912) - 8.0;
  *(float *)(a1 + 143908) = v15;
  *(float *)(a1 + 143940) = 0.5;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001EB90) --------------------------------------------------------
void __usercall sub_1001EB90(int a1@<esi>)
{
  float v1; // ST40_4@1
  unsigned __int8 v2; // bl@1
  float v3; // ST40_4@1
  float v4; // ST40_4@1

  sub_10044E50(a1 + 108688, (int)"AUX A", dword_1031FB44 + 7028, *(float *)(a1 + 436), 535.0, 30.0, 121.0);
  *(_WORD *)(a1 + 120138) = 22;
  *(_BYTE *)(a1 + 120144) = 1;
  *(_DWORD *)(a1 + 120140) = byte_100B8180;
  sub_10042DB0(dword_1031FB44 + 21012, a1 + 108688);
  sub_10042D60(a1 + 640, 1, 1, a1 + 108688);
  v1 = *(float *)(dword_1031FB44 + 7036) - *(float *)(dword_1031FB44 + 7032);
  v2 = sub_10044300(v1, 0.0, 0.30000001, a1 + 108688);
  v3 = *(float *)(dword_1031FB44 + 7036) - *(float *)(dword_1031FB44 + 7032);
  sub_10042C30(v3, "%.0f", 1.0, 9.0, a1 + 108688);
  sub_10065690(0.0, -0.30000001, 1.0, a1 + 110020, v2, a1 + 119624);
  sub_10064F60(0.0, "%.0f", 1.0, 9.0, 22, a1 + 110020, v2);
  v4 = *(float *)(a1 + 108804) + 2.0;
  *(_BYTE *)(a1 + 119620) = v2 + 1;
  *(_BYTE *)(a1 + 374) = 3;
  *(float *)(a1 + 108804) = v4;
  *(float *)(a1 + 108808) = *(float *)(a1 + 108808) - 8.0;
  *(float *)(a1 + 119988) = *(float *)(a1 + 119988) - 8.0;
  *(float *)(a1 + 119984) = v4;
  *(float *)(a1 + 120016) = 0.5;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001ED50) --------------------------------------------------------
void __usercall sub_1001ED50(int a1@<esi>)
{
  double v1; // st7@1
  char v2; // bl@1
  double v3; // st7@3

  sub_10042310(
    a1 + 57156,
    (int)"EGT F",
    dword_1031FB44 + 4896,
    *(float *)(a1 + 396),
    472.0,
    *(float *)(a1 + 424),
    175.0,
    *(_BYTE *)(dword_1031FB44 + 25));
  sub_10041F10(dword_1031FB44 + 20648, a1 + 57156);
  sub_10047B10(a1 + 676, *(_BYTE *)(dword_1031FB44 + 25), 1, a1 + 57172);
  *(_WORD *)(a1 + 58136) = 17;
  *(_BYTE *)(a1 + 58144) = 1;
  *(_DWORD *)(a1 + 58140) = byte_100B8180;
  sub_10041CA0(83.333336, 0.0, 0.80000001, a1 + 57156);
  sub_10041C00(83.333336, 1, (int)"%.0f", 1.0, 9.0, a1 + 57156);
  v1 = *(float *)(a1 + 396);
  *(_BYTE *)(a1 + 58134) = -1;
  *(float *)(a1 + 57276) = v1;
  *(_BYTE *)(a1 + 386) = 3;
  *(float *)(a1 + 57280) = *(float *)(a1 + 57892) - 18.0;
  *(float *)(a1 + 57316) = 0.5;
  sub_10042310(
    a1 + 46620,
    (int)"CHT F",
    dword_1031FB44 + 4732,
    *(float *)(a1 + 400),
    472.0,
    *(float *)(a1 + 424),
    175.0,
    *(_BYTE *)(dword_1031FB44 + 25));
  sub_10041F10(dword_1031FB44 + 20620, a1 + 46620);
  sub_10047B10(a1 + 496, *(_BYTE *)(dword_1031FB44 + 25), 1, a1 + 46636);
  *(_WORD *)(a1 + 47600) = 17;
  *(_BYTE *)(a1 + 47608) = 1;
  *(_DWORD *)(a1 + 47604) = byte_100B8180;
  v2 = sub_10041CA0(55.555557, 0.0, 0.80000001, a1 + 46620);
  sub_10041C00(55.555557, 1, (int)"%.0f", 1.0, 9.0, a1 + 46620);
  if ( *(float *)(dword_1031FB44 + 4740) > 271.11111 )
  {
    sub_10065690(*(float *)(dword_1031FB44 + 4740), 0.80000001, 1.0, a1 + 48208, (unsigned __int8)v2, a1 + 48088);
    sub_10064F60(*(float *)(dword_1031FB44 + 4740), "%.0f", 1.0, 9.0, 17, a1 + 48208, (unsigned __int8)v2);
    *(_BYTE *)(a1 + 51408) = v2 + 1;
  }
  *(float *)(a1 + 46740) = *(float *)(a1 + 400);
  v3 = *(float *)(a1 + 47356);
  *(_BYTE *)(a1 + 47598) = -1;
  *(_BYTE *)(a1 + 388) = 3;
  *(float *)(a1 + 46744) = v3 - 18.0;
  *(float *)(a1 + 46780) = 0.5;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001F030) --------------------------------------------------------
char __usercall sub_1001F030@<al>(int a1@<esi>, float a2)
{
  double v2; // st7@2
  char result; // al@4
  float v4; // [sp+20h] [bp+4h]@4

  if ( LOBYTE(a2) )
    v2 = 738.0;
  else
    v2 = *(float *)(a1 + 412);
  v4 = v2;
  sub_10046920(a1 + 235288, (int)"GAL REM", dword_1031FB44 + 6536, v4, 237.0, 200.0, 9.0);
  *(_WORD *)(a1 + 235804) = 31;
  *(_BYTE *)(a1 + 235812) = 1;
  *(_DWORD *)(a1 + 235808) = byte_100B8180;
  *(_DWORD *)(a1 + 235336) = a1 + 824;
  sub_10046920(a1 + 236512, (int)"GAL USED", dword_1031FB44 + 6536, v4, 264.0, 200.0, 9.0);
  *(_WORD *)(a1 + 237028) = 31;
  *(_DWORD *)(a1 + 237032) = byte_100B8180;
  *(_BYTE *)(a1 + 237036) = 1;
  *(_DWORD *)(a1 + 236560) = a1 + 836;
  sub_10045660(a1 + 237736, (int)"ENDUR", dword_1031FB44 + 6700, v4, 291.0, 200.0, 9.0);
  sub_10045010(a1 + 238952, 1, a1 + 237736);
  sub_10046920(a1 + 239036, (int)"RANGE NM", dword_1031FB44 + 6864, v4, 318.0, 200.0, 9.0);
  *(_WORD *)(a1 + 239552) = 38;
  *(_BYTE *)(a1 + 239560) = 1;
  *(_DWORD *)(a1 + 239556) = byte_100B8180;
  *(_DWORD *)(a1 + 239084) = a1 + 848;
  sub_10046920(a1 + 240260, (int)"MPG", dword_1031FB44 + 6864, v4, 345.0, 200.0, 9.0);
  *(float *)(a1 + 416) = *(float *)(a1 + 404);
  result = 3;
  *(float *)(a1 + 420) = *(float *)(a1 + 408);
  *(_DWORD *)(a1 + 240780) = byte_100B8180;
  *(_BYTE *)(a1 + 240784) = 1;
  *(_WORD *)(a1 + 240776) = 35;
  *(_DWORD *)(a1 + 240308) = a1 + 860;
  *(_BYTE *)(a1 + 390) = 3;
  *(_BYTE *)(a1 + 393) = 3;
  *(_BYTE *)(a1 + 394) = 3;
  *(_BYTE *)(a1 + 391) = 3;
  *(_BYTE *)(a1 + 392) = 3;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001F280) --------------------------------------------------------
int __usercall sub_1001F280@<eax>(char a1@<bl>, int a2@<esi>)
{
  double v2; // st7@2
  double v3; // st7@5
  float v4; // ST34_4@7
  double v5; // st7@7
  float v6; // ST44_4@7
  int result; // eax@7
  double v8; // st7@7
  double v9; // st6@8
  float v10; // [sp+24h] [bp-10h]@4
  float v11; // [sp+28h] [bp-Ch]@4
  float v12; // [sp+2Ch] [bp-8h]@2
  float v13; // [sp+30h] [bp-4h]@2

  if ( a1 )
  {
    v13 = 472.0;
    v12 = *(float *)(a2 + 242208) + 5.0;
    v2 = 180.0;
  }
  else
  {
    v13 = 250.0;
    v12 = 20.0;
    v2 = 215.0;
  }
  v11 = v2;
  v10 = v2;
  if ( *(float *)(dword_1031FB44 + 4248) <= 0.042060129 )
    v3 = 0.0052575162;
  else
    v3 = 0.010515032;
  v4 = v3;
  sub_10042820(a2 + 36508, (int)"FFLOW GPH", dword_1031FB44 + 4240, v13, v12, v11, v10);
  sub_10042990(dword_1031FB44 + 20536, a2 + 36508);
  *(float *)(a2 + 36744) = 165.0;
  v5 = *(float *)(a2 + 36748) - 165.0;
  *(_WORD *)(a2 + 42082) = 33;
  *(float *)(a2 + 36848) = v5;
  *(_BYTE *)(a2 + 42088) = 1;
  *(_DWORD *)(a2 + 42084) = byte_100B8180;
  v6 = 0.5 * v4;
  sub_10062160(v4, v6, -0.2, a2 + 36524);
  sub_10061F10(v4, "%.0f", 1.0, 12.0, -0.2, a2 + 36524);
  sub_10042980((_BYTE *)(dword_1031FB44 + 4240), a2 + 36508);
  result = sub_10060F20(a2 + 484, 1, a2 + 36524);
  v8 = *(float *)(a2 + 36628);
  *(_BYTE *)(a2 + 385) = 3;
  if ( a1 )
    v9 = 10.0;
  else
    v9 = 20.0;
  *(float *)(a2 + 36628) = v8 + v9;
  *(float *)(a2 + 38828) = v9 + *(float *)(a2 + 38828);
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001F450) --------------------------------------------------------
void __usercall sub_1001F450(int a1@<esi>)
{
  char v1; // al@1
  double v2; // st5@3
  float v3; // ST38_4@5
  float v4; // ST40_4@5
  double v5; // st7@5
  double v6; // st5@8
  float v7; // ST38_4@10
  float v8; // ST40_4@10
  double v9; // st7@10
  char v10; // al@11
  double v11; // st7@13
  double v12; // st7@16
  float v13; // ST40_4@18
  float v14; // ST40_4@18
  char v15; // al@19
  double v16; // st7@21
  double v17; // st7@24
  float v18; // ST40_4@26
  float v19; // ST40_4@26
  double v20; // st7@26
  float v21; // [sp+24h] [bp-Ch]@16
  float v22; // [sp+24h] [bp-Ch]@24
  float v23; // [sp+28h] [bp-8h]@15
  float v24; // [sp+28h] [bp-8h]@23

  v1 = *(_BYTE *)(a1 + 242192);
  if ( v1 & 8 )
  {
    if ( v1 & 3 )
      v2 = 339.0;
    else
      v2 = 267.0;
    v3 = v2;
    sub_1004A1A0(a1 + 203844, (int)"AILERON TRIM", dword_1031FB44 + 5388, 492.0, v3, 152.0, 20.0, 0);
    sub_10049040(a1 + 772, 1, 0, a1 + 203844);
    *(_WORD *)(a1 + 208156) = 12;
    *(_BYTE *)(a1 + 208164) = 1;
    v4 = *(float *)(dword_1031FB44 + 5396) - *(float *)(dword_1031FB44 + 5392);
    sub_1004A660(v4, 0.0, -0.60000002, a1 + 203844);
    v5 = *(float *)(a1 + 203856) / 18.5;
    *(_BYTE *)(a1 + 204358) = 2;
    *(_BYTE *)(a1 + 368) = 3;
    *(float *)(a1 + 204304) = v5 * 135.0 * 0.1000000014901161;
  }
  else if ( v1 & 4 )
  {
    if ( v1 & 3 )
      v6 = 339.0;
    else
      v6 = 267.0;
    v7 = v6;
    sub_1004A1A0(a1 + 208336, (int)"RUDDER TRIM", dword_1031FB44 + 5388, 492.0, v7, 152.0, 20.0, 0);
    v8 = *(float *)(dword_1031FB44 + 5396) - *(float *)(dword_1031FB44 + 5392);
    sub_1004A660(v8, 0.0, -0.60000002, a1 + 208336);
    sub_10049040(a1 + 784, 1, 0, a1 + 208336);
    v9 = *(float *)(a1 + 208348) / 18.5;
    *(_WORD *)(a1 + 212648) = 12;
    *(_BYTE *)(a1 + 212656) = 1;
    *(_BYTE *)(a1 + 208850) = 2;
    *(_BYTE *)(a1 + 369) = 3;
    *(float *)(a1 + 208796) = v9 * 135.0 * 0.1000000014901161;
  }
  v10 = *(_BYTE *)(a1 + 242192);
  if ( v10 & 2 )
  {
    if ( v10 & 1 )
      v11 = 624.0;
    else
      v11 = 558.0;
    v23 = v11;
    if ( v10 & 0xC )
    {
      v21 = 185.0;
      v12 = 122.0;
    }
    else
    {
      v21 = 207.0;
      v12 = 152.0;
    }
    v13 = v12;
    sub_1004A1A0(a1 + 221812, (int)"TRIM", dword_1031FB44 + 5552, v23, v21, 20.0, v13, 1);
    sub_10049040(a1 + 796, 1, 0, a1 + 221812);
    *(_WORD *)(a1 + 226124) = 12;
    *(_BYTE *)(a1 + 226132) = 1;
    v14 = *(float *)(dword_1031FB44 + 5560) - *(float *)(dword_1031FB44 + 5556);
    sub_1004A660(v14, 0.0, 0.60000002, a1 + 221812);
    sub_100649E0(a1 + 221944, "ELEV", 21);
    *(float *)(a1 + 221876) = v23;
    *(float *)(a1 + 221928) = v23;
    *(_BYTE *)(a1 + 222326) = 2;
    *(_BYTE *)(a1 + 370) = 3;
    *(float *)(a1 + 221880) = v21 + 14.0;
    *(float *)(a1 + 221932) = v21;
    *(float *)(a1 + 221916) = 1.0;
    *(float *)(a1 + 221968) = 1.0;
    *(float *)(a1 + 221920) = 0.0;
    *(float *)(a1 + 221972) = 0.0;
    *(float *)(a1 + 222276) = 14.0;
  }
  v15 = *(_BYTE *)(a1 + 242192);
  if ( v15 & 1 )
  {
    if ( v15 & 2 )
      v16 = 537.0;
    else
      v16 = 558.0;
    v24 = v16;
    if ( v15 & 0xC )
    {
      v22 = 185.0;
      v17 = 122.0;
    }
    else
    {
      v22 = 207.0;
      v17 = 152.0;
    }
    v18 = v17;
    sub_1004A1A0(a1 + 230796, (int)"FLAPS", dword_1031FB44 + 6372, v24, v22, 20.0, v18, 1);
    sub_10049040(a1 + 808, 1, 0, a1 + 230796);
    *(_WORD *)(a1 + 235108) = 12;
    *(_BYTE *)(a1 + 235116) = 1;
    v19 = (*(float *)(dword_1031FB44 + 6380) - *(float *)(dword_1031FB44 + 6376)) * 0.3333333432674408;
    sub_1004A660(v19, 0.0, 0.60000002, a1 + 230796);
    *(float *)(a1 + 230860) = v24;
    *(float *)(a1 + 230864) = v22;
    *(float *)(a1 + 230900) = 1.0;
    *(_BYTE *)(a1 + 231310) = 2;
    *(float *)(a1 + 230904) = 0.0;
    *(float *)(a1 + 231260) = 14.0;
    sub_10064F60(1.0, "UP", 1.0, 9.0, 0, a1 + 231632, 3);
    sub_10064F60(0.0, "DN", 1.0, 9.0, 0, a1 + 231632, 0);
    v20 = *(float *)(a1 + 230808) + *(float *)(a1 + 230800);
    *(_BYTE *)(a1 + 371) = 3;
    *(float *)(a1 + 231656) = v20;
    *(float *)(a1 + 231680) = 1.0;
    *(float *)(a1 + 231848) = *(float *)(a1 + 230800);
    *(float *)(a1 + 231872) = 0.0;
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001F960) --------------------------------------------------------
int __usercall sub_1001F960@<eax>(int a1@<esi>)
{
  double v1; // st7@2
  float v2; // ST48_4@4
  float v3; // ST4C_4@4
  unsigned __int8 v4; // bl@4
  double v5; // st7@4
  double v6; // st7@4
  double v7; // st7@4
  signed int v8; // ecx@4
  float v9; // ST4C_4@5
  int v10; // ebx@5
  float v11; // ST2C_4@6
  double v12; // st7@6
  double v13; // st7@7
  float v14; // ST48_4@9
  float v15; // ST4C_4@9
  float v16; // ST4C_4@9
  double v17; // st7@9
  float v18; // ST4C_4@9
  int result; // eax@9
  unsigned __int8 v20; // [sp+27h] [bp-9h]@4

  if ( *(float *)(dword_1031FB44 + 5232) >= 117.3477630615234 )
    v1 = 37.854118;
  else
    v1 = 18.927059;
  v2 = v1;
  sub_10042820(a1 + 148760, (int)"L FUEL QTY GAL", dword_1031FB44 + 5224, 480.0, 20.0, 175.0, 175.0);
  v3 = 0.5 * v2;
  *(_WORD *)(a1 + 154334) = 31;
  *(_BYTE *)(a1 + 154340) = 1;
  *(_DWORD *)(a1 + 154336) = byte_100B8180;
  v4 = sub_10062160(v2, v3, -0.2, a1 + 148776);
  v20 = v4;
  sub_10061F10(v2, "%.0f", 1.0, 9.0, -0.2, a1 + 148776);
  sub_10060F20(a1 + 652, 0, a1 + 148776);
  v5 = *(float *)(a1 + 148880) + 15.0;
  *(_DWORD *)(a1 + 154372) = 59;
  *(_DWORD *)(a1 + 160024) = -16777216;
  *(float *)(a1 + 148880) = v5;
  *(float *)(a1 + 160008) = 581.5;
  *(float *)(a1 + 160012) = 121.5;
  *(float *)(a1 + 160016) = 20.0;
  *(float *)(a1 + 160020) = 20.0;
  sub_10042820(a1 + 154380, (int)"R FUEL QTY GAL", dword_1031FB44 + 5224, 660.0, 20.0, 175.0, 175.0);
  *(_WORD *)(a1 + 159954) = 31;
  *(_BYTE *)(a1 + 159960) = 1;
  *(_DWORD *)(a1 + 159956) = byte_100B8180;
  sub_10062160(v2, v3, -0.2, a1 + 154396);
  sub_10061F10(v2, "%.0f", 1.0, 9.0, -0.2, a1 + 154396);
  sub_10060F20(a1 + 664, 0, a1 + 154396);
  v6 = *(float *)(a1 + 154500) + 15.0;
  *(_DWORD *)(a1 + 159992) = 59;
  *(_DWORD *)(a1 + 160044) = -16777216;
  *(float *)(a1 + 154500) = v6;
  *(float *)(a1 + 160028) = 761.5;
  *(float *)(a1 + 160032) = 121.5;
  v7 = 20.0;
  *(float *)(a1 + 160036) = 20.0;
  *(float *)(a1 + 160040) = 20.0;
  v8 = (signed int)(*(float *)(dword_1031FB44 + 5232) * 0.2641720473766327);
  if ( v8 != 10 * (v8 / 10) )
  {
    v9 = (double)(5 * (v8 / 5 + 1)) * 3.785411834716797;
    sub_10061FA0(v9, -0.2, v4, a1 + 148776);
    sub_10061FA0(v9, -0.2, v4, a1 + 154396);
    v10 = a1 + (v4 << 6);
    *(float *)(v10 + 151148) = 2.0;
    *(float *)(v10 + 156768) = 2.0;
    v7 = 20.0;
    *(_BYTE *)(a1 + 154332) = v20 + 1;
    *(_BYTE *)(a1 + 159952) = v20 + 1;
  }
  *(_BYTE *)(a1 + 382) = 3;
  *(_BYTE *)(a1 + 383) = 3;
  v11 = v7;
  sub_10042820(a1 + 160048, (int)"PSI", dword_1031FB44 + 5716, 840.0, v11, 175.0, 175.0);
  *(float *)(a1 + 160284) = 165.0;
  *(_WORD *)(a1 + 165622) = 15;
  v12 = *(float *)(a1 + 160288);
  *(_BYTE *)(a1 + 165628) = 1;
  *(_DWORD *)(a1 + 165624) = byte_100B8180;
  *(float *)(a1 + 160388) = v12 - 165.0;
  sub_10042990(dword_1031FB44 + 20788, a1 + 160048);
  if ( *(float *)(dword_1031FB44 + 5724) <= 172368.98 )
    v13 = 13789.519;
  else
    v13 = 68947.594;
  v14 = v13;
  v15 = 0.5 * v14;
  sub_10062160(v14, v15, -0.2, a1 + 160064);
  sub_10061F10(v14, "%.0f", 1.0, 9.0, -0.2, a1 + 160064);
  sub_10042980((_BYTE *)(dword_1031FB44 + 5716), a1 + 160048);
  v16 = *(float *)(a1 + 160168) + 15.0;
  v17 = v16;
  *(float *)(a1 + 160168) = v16;
  v18 = *(float *)(a1 + 160164) - 66.0;
  *(float *)(a1 + 160164) = v18;
  *(float *)(a1 + 160204) = 0.0;
  *(float *)(a1 + 160256) = 0.0;
  *(float *)(a1 + 160220) = v17 - 12.0 - 2.0;
  *(float *)(a1 + 160216) = v18;
  sub_100649E0(a1 + 160232, "FUEL", 21);
  *(float *)(a1 + 162396) = 1.0;
  *(float *)(a1 + 162400) = 1.0;
  *(float *)(a1 + 162364) = *(float *)(a1 + 162364) + 66.0;
  *(float *)(a1 + 162368) = *(float *)(a1 + 162368) + 12.0;
  result = sub_10060F20(a1 + 904, 1, a1 + 160064);
  *(_BYTE *)(a1 + 377) = 3;
  *(_DWORD *)(a1 + 165660) = 59;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1001FEA0) --------------------------------------------------------
int __usercall sub_1001FEA0@<eax>(int a1@<esi>)
{
  int result; // eax@2
  float v2; // ST1C_4@2
  float v3; // [sp+Ch] [bp-8h]@1

  v3 = 15.0;
  if ( *(_BYTE *)(a1 + 456) )
  {
    result = sub_10046920(a1 + 198128, (int)" PEAK", a1 + 197964, 738.0, 530.0, 40.0, v3);
    *(float *)(a1 + 198348) = 1.0;
    *(float *)(a1 + 198192) = 1.0;
    *(_DWORD *)(a1 + 198176) = a1 + 876;
    *(float *)(a1 + 198452) = 1.0;
    *(float *)(a1 + 198344) = 0.5;
    *(float *)(a1 + 198188) = 0.5;
    *(float *)(a1 + 198448) = 0.5;
    v2 = *(float *)(a1 + 198308) + 15.0 + 3.0;
    *(float *)(a1 + 198160) = v2;
    *(float *)(a1 + 198412) = v2 + 12.0 + 3.0;
    *(float *)(a1 + 198304) = 738.0;
    *(float *)(a1 + 198156) = 738.0;
    *(float *)(a1 + 198408) = 738.0;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 242192) & 0x80 )
      LOBYTE(result) = sub_10046960(a1 + 198128, (int)"", a1 + 197964, 696.0, 447.0, 85.0, v3);
    else
      result = sub_10046920(a1 + 198128, (int)"", a1 + 197964, 717.0, 447.0, 42.0, v3);
    *(float *)(a1 + 198412) = 661.0;
    *(float *)(a1 + 198464) = 661.0;
    *(_DWORD *)(a1 + 198176) = a1 + 876;
    *(_DWORD *)(a1 + 198224) = a1 + 888;
    *(float *)(a1 + 198308) = 447.0;
    *(float *)(a1 + 198160) = 447.0;
    *(float *)(a1 + 198208) = 447.0;
    *(float *)(a1 + 198156) = *(float *)(a1 + 198156) - 5.0;
    *(float *)(a1 + 198204) = *(float *)(a1 + 198204) + 5.0;
  }
  *(_DWORD *)(a1 + 198648) = byte_100B8180;
  *(_BYTE *)(a1 + 198652) = 1;
  *(_WORD *)(a1 + 198644) = 10;
  return result;
}

//----- (10020070) --------------------------------------------------------
void __usercall sub_10020070(int a1@<esi>)
{
  signed int v1; // ebx@2
  float v2; // [sp+1Ch] [bp-4h]@2

  if ( *(_BYTE *)(a1 + 242192) & 0x80 )
  {
    v2 = 0.60000002;
    v1 = 2;
    sub_10044EC0(a1 + 170160, (int)"TIT F", dword_1031FB44 + 5060, 696.0, 472.0, 85.0, 175.0);
  }
  else
  {
    v2 = 0.30000001;
    v1 = 1;
    sub_10044E50(a1 + 170160, (int)"TIT F", dword_1031FB44 + 5060, 717.0, 472.0, 31.0, 175.0);
  }
  *(_WORD *)(a1 + 181610) = 17;
  *(_BYTE *)(a1 + 181616) = 1;
  *(_DWORD *)(a1 + 181612) = byte_100B8180;
  sub_10042D60(a1 + 748, v1, 1, a1 + 170160);
  sub_10042DB0(dword_1031FB44 + 20676, a1 + 170160);
  sub_10044300(500.00003, 41.666668, v2, a1 + 170160);
  sub_10042C30(83.333336, "%.0f", 1.0, 9.0, a1 + 170160);
  *(float *)(a1 + 171540) = 1.0;
  *(_BYTE *)(a1 + 387) = 3;
  *(float *)(a1 + 171924) = 0.0;
  *(float *)(a1 + 175124) = 0.0;
  *(float *)(a1 + 174740) = 1.0;
  *(float *)(a1 + 170276) = 738.0;
  *(float *)(a1 + 170280) = *(float *)(a1 + 170280) - 26.0;
  *(float *)(a1 + 170316) = 0.5;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10020210) --------------------------------------------------------
char __usercall sub_10020210@<al>(char a1@<bl>, int a2@<esi>)
{
  const char *v2; // eax@2
  double v3; // st7@2
  float v4; // ST34_4@4
  float v5; // ST38_4@4
  char result; // al@6
  float v7; // [sp+1Ch] [bp-4h]@2

  if ( a1 )
  {
    v2 = "TRIM";
    v7 = 513.0;
    v3 = 160.0;
  }
  else
  {
    v2 = "ELEV";
    v7 = 599.0;
    v3 = 77.0;
  }
  v4 = v3;
  sub_1004A1A0(a2 + 217320, (int)v2, dword_1031FB44 + 5552, 171.0, v7, 18.0, v4, 1);
  sub_10049040(a2 + 796, 1, 0, a2 + 217320);
  *(_WORD *)(a2 + 221632) = 12;
  *(_BYTE *)(a2 + 221640) = 1;
  v5 = *(float *)(dword_1031FB44 + 5560) - *(float *)(dword_1031FB44 + 5556);
  sub_1004A660(v5, 0.0, 0.60000002, a2 + 217320);
  if ( a1 )
  {
    *(float *)(a2 + 217388) = *(float *)(a2 + 217388) - 8.0;
    sub_100649E0(a2 + 217452, "ELEV", 21);
    *(float *)(a2 + 217440) = *(float *)(a2 + 217440) - 8.0;
  }
  result = 3;
  *(_BYTE *)(a2 + 217834) = 2;
  *(_BYTE *)(a2 + 330) = 3;
  *(_BYTE *)(a2 + 344) = 3;
  *(_BYTE *)(a2 + 364) = 3;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10020350) --------------------------------------------------------
void __usercall sub_10020350(int a1@<esi>, float a2)
{
  double v2; // st7@2
  float v3; // ST38_4@4
  float v4; // [sp+20h] [bp-8h]@2
  float v5; // [sp+2Ch] [bp+4h]@2
  float v6; // [sp+2Ch] [bp+4h]@4

  if ( LOBYTE(a2) )
  {
    v4 = 513.0;
    v5 = 160.0;
    v2 = 14.0;
  }
  else
  {
    v4 = 492.0;
    v5 = 77.0;
    v2 = 0.0;
  }
  v3 = v2;
  sub_1004A1A0(a1 + 226304, (int)"FLAPS", dword_1031FB44 + 6372, 171.0, v4, 18.0, v5, 1);
  sub_10049040(a1 + 808, 1, 0, a1 + 226304);
  *(float *)(a1 + 226372) = *(float *)(a1 + 226372) - v3;
  *(_WORD *)(a1 + 230616) = 12;
  *(_BYTE *)(a1 + 230624) = 1;
  v6 = (*(float *)(dword_1031FB44 + 6380) - *(float *)(dword_1031FB44 + 6376)) * 0.3333333432674408;
  sub_1004A660(v6, 0.0, 0.60000002, a1 + 226304);
  sub_10064F60(1.0, "U", 1.0, 9.0, 0, a1 + 227140, 3);
  sub_10064F60(0.0, "D", 1.0, 9.0, 0, a1 + 227140, 0);
  *(float *)(a1 + 227164) = *(float *)(a1 + 226316) + *(float *)(a1 + 226308);
  *(float *)(a1 + 227188) = 1.0;
  *(float *)(a1 + 227356) = *(float *)(a1 + 226308);
  *(_BYTE *)(a1 + 226818) = 2;
  *(float *)(a1 + 227380) = 0.0;
  *(_BYTE *)(a1 + 332) = 3;
  *(_BYTE *)(a1 + 346) = 3;
  *(_BYTE *)(a1 + 366) = 3;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100204F0) --------------------------------------------------------
signed int __usercall sub_100204F0@<eax>(int a1@<ebx>)
{
  int v1; // esi@1
  float v2; // ST3C_4@1
  float v3; // ST40_4@1
  float v4; // ST44_4@1
  double v5; // st5@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  memcpy((void *)(v1 + 242224), (const void *)(v1 + 242228), 0x24u);
  memcpy((void *)(v1 + 242264), (const void *)(v1 + 242268), 0x24u);
  memcpy((void *)(v1 + 242304), (const void *)(v1 + 242308), 0x24u);
  *(float *)(v1 + 242260) = *(float *)(v1 + 242212);
  *(float *)(v1 + 242300) = *(float *)(v1 + 242216);
  *(float *)(v1 + 242340) = *(float *)(v1 + 242220);
  v2 = sub_1001DC90(v1 + 242224, 10);
  *(float *)(v1 + 242344) = v2;
  v3 = sub_1001DC90(v1 + 242264, 10);
  *(float *)(v1 + 242348) = v3;
  v4 = sub_1001DC90(v1 + 242304, 10);
  *(float *)(v1 + 242352) = v4;
  v5 = 1.5 * v2;
  *(float *)(v1 + 242200) = v3 + v5;
  result = *(_WORD *)(*(_DWORD *)(a1 + 56) + 32);
  *(float *)(v1 + 242204) = (double)result - v5 + v3;
  *(float *)(v1 + 242208) = v4 + v2;
  *(float *)(v1 + 242196) = v4 + (double)*(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - v2;
  return result;
}

//----- (10020610) --------------------------------------------------------
char __usercall sub_10020610@<al>(int a1@<eax>, int a2@<ebx>, int a3, unsigned __int8 a4)
{
  unsigned __int8 v4; // dl@1
  int v5; // ebp@2
  unsigned __int8 v6; // cl@6
  int v7; // ebp@7
  int v8; // edx@7
  char v10; // [sp+0h] [bp-54h]@5
  char v11; // [sp+28h] [bp-2Ch]@3

  v4 = a4;
  if ( (unsigned __int8)a1 < a4 )
  {
    v5 = a3;
    if ( a3 )
      qmemcpy(&v11, (const void *)(a3 + 44 * (unsigned __int8)a1), 0x2Cu);
    if ( a2 )
      qmemcpy(&v10, (const void *)(a2 + 40 * (unsigned __int8)a1), 0x28u);
    LOBYTE(a1) = a1 + 1;
    v6 = a1;
    if ( (unsigned __int8)a1 < a4 )
    {
      a1 = a3 + 44 * (unsigned __int8)a1;
      v7 = a2 + 40 * v6;
      v8 = (unsigned __int8)(a4 - v6);
      do
      {
        if ( a3 )
          qmemcpy((void *)(a1 - 44), (const void *)a1, 0x2Cu);
        if ( a2 )
          qmemcpy((void *)(v7 - 40), (const void *)v7, 0x28u);
        a1 += 44;
        v7 += 40;
        --v8;
      }
      while ( v8 );
      v4 = a4;
      v5 = a3;
    }
    if ( v5 )
    {
      a1 = 44 * v4;
      qmemcpy((void *)(a1 + v5 - 44), &v11, 0x2Cu);
    }
    if ( a2 )
    {
      LOBYTE(a1) = v4;
      qmemcpy((void *)(a2 + 40 * v4 - 40), &v10, 0x28u);
    }
  }
  return a1;
}

//----- (100206F0) --------------------------------------------------------
int __usercall sub_100206F0@<eax>(int result@<eax>, char a2@<dl>, int a3@<ecx>, char a4)
{
  _BYTE *v4; // esi@4
  int v5; // edx@8

  if ( a4 )
  {
    if ( (_BYTE)a3 )
    {
      a3 = (unsigned __int8)a3;
      do
      {
        *(_BYTE *)(*(_DWORD *)result + 24) = 1;
        v4 = *(_BYTE **)result;
        result += 4;
        --a3;
        *v4 = a2;
      }
      while ( a3 );
    }
  }
  else if ( (_BYTE)a3 )
  {
    a3 = (unsigned __int8)a3;
    do
    {
      v5 = *(_DWORD *)result;
      result += 4;
      --a3;
      *(_BYTE *)(v5 + 24) = 0;
    }
    while ( a3 );
  }
  return result;
}

//----- (100207A0) --------------------------------------------------------
char __usercall sub_100207A0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  char v2; // ST0C_1@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 242180) = 0;
  *(_BYTE *)(v1 + 341) = 0;
  *(_DWORD *)(v1 + 165708) = 0;
  *(_DWORD *)(v1 + 165712) = 0;
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 395) = v2;
  sub_1004C170(v2);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (100207F0) --------------------------------------------------------
int __usercall sub_100207F0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  float v2; // ST28_4@1
  int v3; // ST10_4@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(LODWORD(v2));
  sub_1008C160(
    *(float *)(v1 + 242200),
    *(float *)(v1 + 242204),
    *(float *)(v1 + 242208),
    *(float *)(v1 + 242196),
    0.0,
    1.0);
  j_gdi_pvg_matrix_mode(52);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(v3);
  return j_gdi_pvg_viewport(
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 28),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 30),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 32),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 34));
}
// 1008C120: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 1008C150: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 1008C1D0: using guessed type int j_gdi_pvg_push_matrix(void);
// 1008C350: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10020880) --------------------------------------------------------
char __thiscall sub_10020880(int this)
{
  signed int v1; // edx@1
  int v2; // eax@2
  _BYTE *v3; // esi@4
  char result; // al@4

  v1 = 0;
  if ( *(_BYTE *)(dword_1031FB44 + 25) )
  {
    v2 = this + 57248;
    do
    {
      *(float *)(v2 + 5952) = 0.0;
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 4780) = 0;
      ++v1;
      v2 += 4;
    }
    while ( v1 < *(_BYTE *)(dword_1031FB44 + 25) );
  }
  *(float *)(this + 242172) = 0.0;
  v3 = (_BYTE *)(this + 63224);
  *(float *)(this + 242184) = 0.0;
  *(float *)(this + 242176) = 0.0;
  *(float *)(this + 242188) = 0.0;
  *(_DWORD *)(this + 170216) = 0;
  *(_DWORD *)(this + 165708) = 0;
  *(_DWORD *)(this + 170220) = 0;
  *(_DWORD *)(this + 165712) = 0;
  result = sub_1004CCA0(this + 63224, 1);
  *v3 = *(_BYTE *)(dword_1031FB44 + 25);
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10020910) --------------------------------------------------------
char __cdecl sub_10020910(int a1)
{
  double v1; // st7@1
  int v2; // ebp@1
  char v3; // bl@1
  double v4; // st6@2
  double v5; // st6@5
  char v6; // al@7
  double v7; // st6@7
  int v8; // eax@10
  char v9; // cl@10
  int v10; // eax@13
  char v11; // al@15
  int v12; // eax@16
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@19
  char result; // al@20
  char v17; // [sp+8h] [bp-4h]@1
  char v18; // [sp+10h] [bp+4h]@1
  float v19; // [sp+10h] [bp+4h]@16
  float v20; // [sp+10h] [bp+4h]@18

  v1 = 0.0;
  v2 = a1;
  *(float *)(a1 + 448) = 0.0;
  qmemcpy(byte_10168B80, &unk_100C00C0, 0x1B8u);
  qmemcpy(&unk_10168DE8, &unk_100C0288, 0x190u);
  dword_10168B84[0] = a1 + 7136;
  dword_10168BB0 = a1 + 18964;
  dword_10168BDC = a1 + 144268;
  dword_10168B8C[0] = (int)"MAN IN";
  dword_10168BB8 = (int)"RPM";
  dword_10168BE4 = (int)"FUEL QTY GAL";
  dword_10168C10 = (int)"FFLOW GPH";
  dword_10168C3C = (int)"OIL PSI";
  dword_10168C68 = (int)"OIL F";
  dword_10168C94 = (int)"EGT F";
  dword_10168CC0 = (int)"CHT F";
  dword_10168C08 = a1 + 30792;
  dword_10168C34 = a1 + 74040;
  dword_10168C60 = a1 + 63316;
  dword_10168C8C = a1 + 52664;
  dword_10168CB8 = a1 + 42128;
  v3 = 9;
  v17 = 10;
  v18 = 9;
  flt_10168E8C = *(float *)(dword_1031FB44 + 4412) - *(float *)(dword_1031FB44 + 4408);
  flt_10168EB4 = *(float *)(dword_1031FB44 + 4576) - *(float *)(dword_1031FB44 + 4572);
  flt_10168EDC = *(float *)(dword_1031FB44 + 4904) - *(float *)(dword_1031FB44 + 4900);
  flt_10168F04 = *(float *)(dword_1031FB44 + 4740) - *(float *)(dword_1031FB44 + 4736);
  if ( *(float *)(dword_1031FB44 + 5232) >= 117.3477630615234 )
    v4 = 37.854118;
  else
    v4 = 18.927059;
  flt_10168E3C = v4;
  flt_10168E48 = flt_10168E3C;
  if ( *(float *)(dword_1031FB44 + 4248) >= 0.02839058637619019 )
    v5 = 0.010515032;
  else
    v5 = 0.0052575162;
  flt_10168E64 = v5;
  flt_10168E70 = *(float *)(dword_1031FB44 + 4248);
  v6 = *(_BYTE *)(v2 + 242192);
  v7 = 18.5;
  if ( v6 & 0x40 )
  {
    qmemcpy(&unk_10168CE0, &unk_100BFFCC, 0x2Cu);
    dword_10168CE4 = v2 + 165668;
    dword_10168CEC = (int)"TIT F";
    flt_10168F2C = *(float *)(dword_1031FB44 + 5068) - *(float *)(dword_1031FB44 + 5064);
    flt_10168F34 = -0.30000001;
    if ( !(*(_BYTE *)(v2 + 242192) & 0x80) )
    {
      flt_10168CFC = 18.5;
      byte_10168CE8 = 2;
      flt_10168D00 = 14.0;
      flt_10168F34 = -0.60000002;
    }
    sub_1001D950(0xAu, byte_10168C89, (int)byte_10168B80, (char *)&unk_10168DE8);
    LOBYTE(v8) = 6;
    sub_10020610(v8, (int)&unk_10168DE8, (int)byte_10168B80, 0xAu);
    v9 = 0;
    *(_BYTE *)(v2 + 326) = 0;
    *(_BYTE *)(v2 + 328) = 0;
  }
  else
  {
    if ( v6 & 0x20 )
    {
      dword_10168CE4 = v2 + 193472;
      dword_10168CEC = (int)"CARB F";
      v9 = 0;
      flt_10168F2C = *(float *)(dword_1031FB44 + 5068) - *(float *)(dword_1031FB44 + 5064);
      *(_BYTE *)(v2 + 325) = 0;
      goto LABEL_15;
    }
    flt_10168CFC = 0.0;
    dword_10168CE4 = 0;
    byte_10168D08 = 0;
    *(_BYTE *)(v2 + 325) = 0;
    *(_BYTE *)(v2 + 326) = 0;
    sub_1001D950(0xAu, byte_10168CE1, (int)byte_10168B80, (char *)&unk_10168DE8);
    LOBYTE(v10) = 8;
    sub_10020610(v10, (int)&unk_10168DE8, (int)byte_10168B80, 0xAu);
    v7 = 18.5;
    v1 = 0.0;
    v9 = 0;
  }
  v18 = 8;
  v3 = 8;
  v17 = 9;
LABEL_15:
  v11 = *(_BYTE *)(v2 + 242192);
  if ( v11 & 8 )
  {
    v12 = 11 * (unsigned __int8)v3;
    byte_10168B80[v12 * 4] = 26;
    byte_10168B82[v12 * 4] = 9;
    flt_10168B9C[v12] = v7;
    dword_10168B8C[v12] = (int)"AILERON TRIM";
    byte_10168BA8[v12 * 4] = 1;
    dword_10168B84[v12] = v2 + 199352;
    v19 = *(float *)(dword_1031FB44 + 5396) - *(float *)(dword_1031FB44 + 5392);
    flt_10168DEC[10 * (unsigned __int8)v3] = v19;
    *(_BYTE *)(v2 + 331) = v9;
  }
  else if ( v11 & 4 )
  {
    v13 = 11 * (unsigned __int8)v3;
    byte_10168B80[v13 * 4] = 27;
    byte_10168B82[v13 * 4] = 9;
    flt_10168B9C[v13] = v7;
    dword_10168B8C[v13] = (int)"RUDDER TRIM";
    byte_10168BA8[v13 * 4] = 1;
    dword_10168B84[v13] = v2 + 212828;
    v20 = *(float *)(dword_1031FB44 + 5396) - *(float *)(dword_1031FB44 + 5392);
    flt_10168DEC[10 * (unsigned __int8)v3] = v20;
    *(_BYTE *)(v2 + 329) = v9;
  }
  else
  {
    v14 = 11 * (unsigned __int8)v3;
    dword_10168B84[v14] = 0;
    byte_10168BA8[v14 * 4] = 0;
    flt_10168B9C[v14] = v1;
    *(_BYTE *)(v2 + 329) = 0;
    *(_BYTE *)(v2 + 331) = 0;
    sub_1001D950(v17, byte_10168B81[v14 * 4], (int)byte_10168B80, (char *)&unk_10168DE8);
    LOBYTE(v15) = v18;
    sub_10020610(v15, (int)&unk_10168DE8, (int)byte_10168B80, v17--);
    *(float *)(v2 + 448) = 687.0;
    v9 = 0;
  }
  result = v17;
  *(_BYTE *)(v2 + 330) = v9;
  *(_BYTE *)(v2 + 332) = v9;
  return result;
}
// 10168B84: using guessed type int dword_10168B84[];
// 10168B8C: using guessed type int dword_10168B8C[];
// 10168B9C: using guessed type float flt_10168B9C[];
// 10168BB0: using guessed type int dword_10168BB0;
// 10168BB8: using guessed type int dword_10168BB8;
// 10168BDC: using guessed type int dword_10168BDC;
// 10168BE4: using guessed type int dword_10168BE4;
// 10168C08: using guessed type int dword_10168C08;
// 10168C10: using guessed type int dword_10168C10;
// 10168C34: using guessed type int dword_10168C34;
// 10168C3C: using guessed type int dword_10168C3C;
// 10168C60: using guessed type int dword_10168C60;
// 10168C68: using guessed type int dword_10168C68;
// 10168C89: using guessed type char byte_10168C89;
// 10168C8C: using guessed type int dword_10168C8C;
// 10168C94: using guessed type int dword_10168C94;
// 10168CB8: using guessed type int dword_10168CB8;
// 10168CC0: using guessed type int dword_10168CC0;
// 10168CE1: using guessed type char byte_10168CE1;
// 10168CE4: using guessed type int dword_10168CE4;
// 10168CE8: using guessed type char byte_10168CE8;
// 10168CEC: using guessed type int dword_10168CEC;
// 10168CFC: using guessed type float flt_10168CFC;
// 10168D00: using guessed type float flt_10168D00;
// 10168D08: using guessed type char byte_10168D08;
// 10168DEC: using guessed type float flt_10168DEC[];
// 10168E3C: using guessed type float flt_10168E3C;
// 10168E48: using guessed type float flt_10168E48;
// 10168E64: using guessed type float flt_10168E64;
// 10168E70: using guessed type float flt_10168E70;
// 10168E8C: using guessed type float flt_10168E8C;
// 10168EB4: using guessed type float flt_10168EB4;
// 10168EDC: using guessed type float flt_10168EDC;
// 10168F04: using guessed type float flt_10168F04;
// 10168F2C: using guessed type float flt_10168F2C;
// 10168F34: using guessed type float flt_10168F34;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10020D70) --------------------------------------------------------
signed int __usercall sub_10020D70@<eax>(int a1@<esi>)
{
  signed int result; // eax@1
  float v2; // ST40_4@2

  result = dword_1031FB44 + 7192;
  if ( *(_BYTE *)(dword_1031FB44 + 7192) )
  {
    sub_10061B00(a1 + 928, dword_1031FB44 + 7336, dword_1031FB44 + 7192, 7.0, 15.0, 138.0, 138.0);
    sub_10060F80(dword_1031FB44 + 21040, a1 + 928);
    *(float *)(a1 + 1148) = 180.0;
    *(_WORD *)(a1 + 6486) = 8;
    *(float *)(a1 + 1152) = 320.0;
    *(float *)(a1 + 1252) = 140.0;
    *(float *)(a1 + 2988) = 180.0;
    sub_10060E40((_BYTE *)(dword_1031FB44 + 7192), a1 + 928);
    sub_10060F20(a1 + 916, 1, a1 + 928);
    v2 = *(float *)(a1 + 948) - *(float *)(a1 + 944);
    sub_10062160(v2, 0.0, -0.2, a1 + 928);
    *(_DWORD *)(a1 + 3004) = 53;
    *(float *)(a1 + 3264) = 1.0;
    *(float *)(a1 + 3260) = 0.5;
    *(float *)(a1 + 3268) = 24.0;
    *(float *)(a1 + 3228) = *(float *)(a1 + 3228) + 46.0;
    *(float *)(a1 + 3232) = *(float *)(a1 + 2976) + 7.0;
    *(float *)(a1 + 1076) = 15.0;
    *(float *)(a1 + 1028) = *(float *)(a1 + 2972) + 15.0;
    *(float *)(a1 + 1032) = *(float *)(a1 + 2976) + 4.0;
    *(float *)(a1 + 1068) = 1.0;
    *(float *)(a1 + 952) = *(float *)(a1 + 952) - 5.0;
    *(float *)(a1 + 956) = *(float *)(a1 + 956) - 5.0;
    *(float *)(a1 + 964) = *(float *)(a1 + 940) * 0.6000000238418579;
    sub_10046920(a1 + 18352, (int)"MAN IN", dword_1031FB44 + 3912, 7.0, 132.0, 128.0, 15.0);
    *(float *)(a1 + 18576) = 13.0;
    *(_WORD *)(a1 + 18868) = 5;
    *(_BYTE *)(a1 + 18876) = 1;
    *(_DWORD *)(a1 + 18872) = &unk_100B8DC0;
    sub_100465F0(a1 + 460, 1, a1 + 18352);
    sub_10046920(a1 + 30180, (int)"RPM", dword_1031FB44 + 4076, 7.0, 172.0, 128.0, 15.0);
    *(float *)(a1 + 30404) = 13.0;
    *(_WORD *)(a1 + 30696) = 6;
    *(_BYTE *)(a1 + 30704) = 1;
    *(_DWORD *)(a1 + 30700) = &unk_100B8DC0;
    result = sub_100465F0(a1 + 472, 1, a1 + 30180);
    if ( *(_BYTE *)(a1 + 242193) )
    {
      sub_10046920(a1 + 6524, dword_1031FB44 + 7336, dword_1031FB44 + 7192, 240.0, 240.0, 128.0, 15.0);
      *(float *)(a1 + 6748) = 15.0;
      *(float *)(a1 + 6592) = 15.0;
      *(float *)(a1 + 6740) = 0.5;
      *(_WORD *)(a1 + 7040) = 8;
      *(float *)(a1 + 6584) = 0.5;
      *(_BYTE *)(a1 + 7048) = 1;
      *(_DWORD *)(a1 + 7044) = &unk_100B8DC0;
      *(float *)(a1 + 6744) = 1.0;
      *(float *)(a1 + 6588) = 0.0;
      *(float *)(a1 + 6552) = *(float *)(a1 + 6700);
      *(float *)(a1 + 6556) = *(float *)(a1 + 6704) + 15.0;
      result = sub_100465F0(a1 + 916, 1, a1 + 6524);
      *(_BYTE *)(a1 + 367) = 3;
    }
    *(_BYTE *)(a1 + 317) = 0;
    *(_BYTE *)(a1 + 318) = 0;
    *(_BYTE *)(a1 + 334) = 0;
    *(_BYTE *)(a1 + 335) = 0;
    *(_BYTE *)(a1 + 348) = 0;
    *(_BYTE *)(a1 + 349) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 316) = 0;
    *(_BYTE *)(a1 + 319) = 0;
    *(_BYTE *)(a1 + 320) = 0;
    *(_BYTE *)(a1 + 333) = 0;
    *(_BYTE *)(a1 + 336) = 0;
    *(_BYTE *)(a1 + 337) = 0;
    *(_BYTE *)(a1 + 347) = 0;
    *(_BYTE *)(a1 + 350) = 0;
    *(_BYTE *)(a1 + 351) = 0;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021150) --------------------------------------------------------
char __usercall sub_10021150@<al>(int a1@<eax>)
{
  char v1; // cl@1
  char v2; // cl@8

  qmemcpy(&unk_10168AA0, &unk_100C0418, 0xDCu);
  flt_10168ABC = flt_10168BC8 + flt_10168BC0 + flt_10168BD0 - flt_10168B94;
  dword_10168AD0 = a1 + 35284;
  dword_10168AFC = a1 + 61952;
  dword_10168B28 = a1 + 51416;
  dword_10168AD8 = (int)"FFLOW GPH";
  dword_10168B04 = (int)"EGT F";
  dword_10168B30 = (int)"CHT F";
  v1 = 7;
  if ( *(_BYTE *)(dword_1031FB44 + 25) != 4 )
    v1 = 9;
  byte_10168B2C = v1;
  byte_10168B00 = v1;
  if ( *(_BYTE *)(a1 + 242192) & 0x40 )
  {
    qmemcpy(&unk_10168B50, &unk_100C0094, 0x2Cu);
    if ( !(*(_BYTE *)(a1 + 242192) & 0x80) )
      flt_10168B6C = 18.5;
    byte_10168AF9 = 3;
    flt_10168B14 = 80.0;
    flt_10168B40 = 80.0;
  }
  else
  {
    flt_10168B14 = 128.0;
    dword_10168B54 = a1 + 198740;
    flt_10168B40 = 128.0;
    dword_10168B5C = (int)" PEAK";
    byte_10168AF9 = 2;
    *(_BYTE *)(a1 + 339) = 0;
  }
  v2 = *(_BYTE *)(a1 + 242192);
  if ( v2 & 8 || (*(_BYTE *)(a1 + 343) = 0, !(v2 & 4)) )
    *(_BYTE *)(a1 + 345) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_BYTE *)(a1 + 346) = 0;
  return 5;
}
// 10168ABC: using guessed type float flt_10168ABC;
// 10168AD0: using guessed type int dword_10168AD0;
// 10168AD8: using guessed type int dword_10168AD8;
// 10168AF9: using guessed type char byte_10168AF9;
// 10168AFC: using guessed type int dword_10168AFC;
// 10168B00: using guessed type char byte_10168B00;
// 10168B04: using guessed type int dword_10168B04;
// 10168B14: using guessed type float flt_10168B14;
// 10168B28: using guessed type int dword_10168B28;
// 10168B2C: using guessed type char byte_10168B2C;
// 10168B30: using guessed type int dword_10168B30;
// 10168B40: using guessed type float flt_10168B40;
// 10168B54: using guessed type int dword_10168B54;
// 10168B5C: using guessed type int dword_10168B5C;
// 10168B6C: using guessed type float flt_10168B6C;
// 10168B94: using guessed type float flt_10168B94;
// 10168BC0: using guessed type float flt_10168BC0;
// 10168BC8: using guessed type float flt_10168BC8;
// 10168BD0: using guessed type float flt_10168BD0;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021290) --------------------------------------------------------
char __usercall sub_10021290@<al>(int a1@<eax>)
{
  char v1; // cl@1

  qmemcpy(&unk_10168D38, &unk_100C0508, 0xB0u);
  flt_10168D54 = flt_10168BC8 + flt_10168BC0 + flt_10168BD0 - flt_10168B94;
  qmemcpy(&unk_10168F78, &unk_100C05B8, 0xDCu);
  qmemcpy(&unk_101689C0, &unk_100C06A8, 0xDCu);
  dword_10168DC0 = a1 + 241484;
  dword_10168F7C = a1 + 73428;
  dword_10168FA8 = a1 + 84152;
  dword_10168FD4 = a1 + 120344;
  dword_10169000 = a1 + 84764;
  dword_1016902C = a1 + 35896;
  dword_101689C4 = a1 + 235900;
  dword_101689F0 = a1 + 237124;
  dword_10168A1C = a1 + 238344;
  dword_10168DC8 = (int)"TTL TIME IN SVC";
  dword_10168F84 = (int)"OIL F";
  dword_10168FB0 = (int)"OIL PSI";
  dword_10168FDC = (int)"MAIN V";
  dword_10169008 = (int)"ALT A";
  dword_10169034 = (int)"FFLOW GPH";
  dword_10168A48 = a1 + 239648;
  dword_10168A74 = a1 + 240872;
  dword_101689CC = (int)"GAL REM";
  dword_101689F8 = (int)"GAL USED";
  dword_10168A24 = (int)"ENDUR";
  dword_10168A50 = (int)"RANGE NM";
  dword_10168A7C = (int)"MPG";
  v1 = *(_BYTE *)(a1 + 242192);
  if ( !(v1 & 8) )
  {
    if ( v1 & 4 )
    {
      *(_BYTE *)(a1 + 363) = 0;
      *(_BYTE *)(a1 + 364) = 0;
      *(_BYTE *)(a1 + 366) = 0;
      return 4;
    }
    *(_BYTE *)(a1 + 363) = 0;
  }
  *(_BYTE *)(a1 + 365) = 0;
  *(_BYTE *)(a1 + 364) = 0;
  *(_BYTE *)(a1 + 366) = 0;
  return 4;
}
// 101689C4: using guessed type int dword_101689C4;
// 101689CC: using guessed type int dword_101689CC;
// 101689F0: using guessed type int dword_101689F0;
// 101689F8: using guessed type int dword_101689F8;
// 10168A1C: using guessed type int dword_10168A1C;
// 10168A24: using guessed type int dword_10168A24;
// 10168A48: using guessed type int dword_10168A48;
// 10168A50: using guessed type int dword_10168A50;
// 10168A74: using guessed type int dword_10168A74;
// 10168A7C: using guessed type int dword_10168A7C;
// 10168B94: using guessed type float flt_10168B94;
// 10168BC0: using guessed type float flt_10168BC0;
// 10168BC8: using guessed type float flt_10168BC8;
// 10168BD0: using guessed type float flt_10168BD0;
// 10168D54: using guessed type float flt_10168D54;
// 10168DC0: using guessed type int dword_10168DC0;
// 10168DC8: using guessed type int dword_10168DC8;
// 10168F7C: using guessed type int dword_10168F7C;
// 10168F84: using guessed type int dword_10168F84;
// 10168FA8: using guessed type int dword_10168FA8;
// 10168FB0: using guessed type int dword_10168FB0;
// 10168FD4: using guessed type int dword_10168FD4;
// 10168FDC: using guessed type int dword_10168FDC;
// 10169000: using guessed type int dword_10169000;
// 10169008: using guessed type int dword_10169008;
// 1016902C: using guessed type int dword_1016902C;
// 10169034: using guessed type int dword_10169034;

//----- (10021420) --------------------------------------------------------
int __cdecl sub_10021420(int a1)
{
  signed int v1; // ecx@1
  int result; // eax@2
  unsigned __int8 v3; // bl@5
  int v4; // esi@6

  sub_10020880(a1);
  v1 = 2;
  if ( *(_BYTE *)(a1 + 242180) == 2 )
  {
    *(_BYTE *)(a1 + 242180) = 0;
    result = dword_1031FB44;
    v3 = 0;
    if ( *(_BYTE *)(dword_1031FB44 + 25) )
    {
      do
      {
        v4 = 52 * v3 + a1;
        sub_10064B00((char *)(v4 + 57344), 0x15u, "%d", v3 + 1);
        sub_10064B00((char *)(v4 + 62124), 0x15u, "%d", v3++ + 1);
        *(float *)(v4 + 62156) = 9.0;
        *(float *)(v4 + 57376) = 9.0;
        result = dword_1031FB44;
      }
      while ( v3 < *(_BYTE *)(dword_1031FB44 + 25) );
    }
    *(float *)(a1 + 242212) = 0.0;
    *(_BYTE *)(a1 + 341) = 0;
    *(float *)(a1 + 242216) = 0.0;
    *(float *)(a1 + 242220) = 0.0;
  }
  else
  {
    *(_BYTE *)(a1 + 242180) = 2;
    result = a1 + 242172;
    do
    {
      *(_DWORD *)(result - 71956) = result;
      *(_DWORD *)(result - 76464) = result;
      result += 4;
      --v1;
    }
    while ( v1 );
    *(_BYTE *)(a1 + 341) = 3;
    *(float *)(a1 + 242212) = 95.0;
    *(float *)(a1 + 242216) = *(float *)(a1 + 452);
    *(float *)(a1 + 242220) = 100.0;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021520) --------------------------------------------------------
void __usercall sub_10021520(int a1@<esi>, char a2, float a3)
{
  double v3; // st7@1
  signed int v4; // ecx@1
  unsigned __int8 v5; // al@2
  float v6; // ST20_4@2
  unsigned __int8 v7; // al@2
  char v8; // al@3

  sub_10049630((float *)(a1 + 30792));
  sub_10049630((float *)(a1 + 63316));
  sub_10049630((float *)(a1 + 74040));
  sub_10049630((float *)(a1 + 52664));
  sub_10049630((float *)(a1 + 42128));
  sub_10049630((float *)(a1 + 193472));
  *(float *)(a1 + 21788) = 71.0;
  *(float *)(a1 + 21812) = 0.5;
  *(_BYTE *)(a1 + 144964) = 2;
  v3 = *(float *)(a1 + 21792);
  *(_DWORD *)(a1 + 144968) = -16711681;
  *(_BYTE *)(a1 + 145028) = 2;
  *(_DWORD *)(a1 + 145032) = -16711681;
  *(_BYTE *)(a1 + 144974) = 1;
  *(float *)(a1 + 21792) = v3 - 35.0;
  *(_BYTE *)(a1 + 145038) = 1;
  *(float *)(a1 + 144920) = 10.0;
  *(float *)(a1 + 144924) = 10.0;
  *(float *)(a1 + 144916) = *(float *)(a1 + 144724) - *(float *)(a1 + 144732) + 5.0;
  *(float *)(a1 + 144984) = 10.0;
  *(float *)(a1 + 144988) = 10.0;
  *(float *)(a1 + 144980) = *(float *)(a1 + 144796) + *(float *)(a1 + 144788) - 5.0;
  v4 = (signed int)(*(float *)(dword_1031FB44 + 5232) * 0.2641720473766327);
  if ( v4 % 10 )
  {
    v5 = *(_BYTE *)(a1 + 148304);
    v6 = (double)(5 * (v4 / 5 + 1)) * 3.785411834716797;
    *(_BYTE *)(a1 + 148304) = v5 + 1;
    sub_10065690(v6, -0.30000001, 1.0, a1 + 145104, v5, a1 + 148460);
    v7 = *(_BYTE *)(a1 + 148304);
    *(_BYTE *)(a1 + 148304) = v7 + 1;
    sub_10065690(v6, 0.30000001, 1.0, a1 + 145104, v7, a1 + 148460);
  }
  v8 = *(_BYTE *)(a1 + 242192);
  if ( v8 & 0x40 )
  {
    if ( v8 >= 0 )
      sub_10049630((float *)(a1 + 165668));
    else
      *(float *)(a1 + 165736) = *(float *)(a1 + 165736) - 15.0;
  }
  if ( 0.0 == *(float *)(a1 + 448) )
    *(float *)(a1 + 448) = flt_10168B68[11 * (unsigned __int8)a2] - flt_10168B74[11 * (unsigned __int8)a2] - a3 * 0.5;
}
// 10168B68: using guessed type float flt_10168B68[];
// 10168B74: using guessed type float flt_10168B74[];
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021760) --------------------------------------------------------
signed int __usercall sub_10021760@<eax>(int a1@<esi>)
{
  float v1; // ST2C_4@2
  float v2; // ST2C_4@3
  signed int result; // eax@4
  double v4; // st6@4
  double v5; // st7@4
  double v6; // st7@4

  if ( *(_BYTE *)(a1 + 242192) & 0x40 )
  {
    v1 = flt_10168B6C + flt_10168B64 + 2.0;
    sub_10046960(a1 + 198740, (int)"", a1 + 197964, flt_10168B60, v1, flt_10168B68[0], 15.0);
    sub_100465F0(a1 + 868, 2, a1 + 198740);
  }
  else
  {
    v2 = flt_10168B6C + flt_10168B64 + 2.0;
    sub_10046920(a1 + 198740, (int)" PEAK", a1 + 197964, flt_10168B60, v2, flt_10168B68[0], flt_10168B6C);
    sub_100465F0(a1 + 868, 1, a1 + 198740);
  }
  *(float *)(a1 + 198960) = 1.0;
  result = -16711681;
  *(float *)(a1 + 198920) = *(float *)(a1 + 198772);
  v4 = *(float *)(a1 + 198916);
  *(_BYTE *)(a1 + 166374) = 3;
  *(float *)(a1 + 199020) = v4;
  *(_DWORD *)(a1 + 166368) = -16711681;
  *(_BYTE *)(a1 + 166364) = 1;
  *(_BYTE *)(a1 + 166438) = 3;
  *(float *)(a1 + 199060) = 1.0;
  *(_DWORD *)(a1 + 166432) = -16711681;
  v5 = *(float *)(a1 + 198772);
  *(_BYTE *)(a1 + 166428) = 0;
  *(float *)(a1 + 199024) = v5;
  *(_WORD *)(a1 + 199256) = 10;
  v6 = *(float *)(a1 + 198772);
  *(_BYTE *)(a1 + 199264) = 1;
  *(float *)(a1 + 199076) = v6;
  *(_DWORD *)(a1 + 199260) = byte_100B8180;
  *(float *)(a1 + 199112) = 0.0;
  *(float *)(a1 + 199072) = *(float *)(a1 + 198916);
  *(float *)(a1 + 166312) = *(float *)(a1 + 166120);
  *(float *)(a1 + 166316) = *(float *)(a1 + 166124);
  *(float *)(a1 + 166324) = *(float *)(a1 + 166132) * 1.25;
  *(float *)(a1 + 166320) = *(float *)(a1 + 166128);
  *(float *)(a1 + 166376) = *(float *)(a1 + 166184);
  *(float *)(a1 + 166380) = *(float *)(a1 + 166188);
  *(float *)(a1 + 166388) = 1.25 * *(float *)(a1 + 166196);
  *(float *)(a1 + 166384) = *(float *)(a1 + 166192);
  return result;
}
// 10168B60: using guessed type float flt_10168B60;
// 10168B64: using guessed type float flt_10168B64;
// 10168B68: using guessed type float flt_10168B68[];
// 10168B6C: using guessed type float flt_10168B6C;

//----- (10021930) --------------------------------------------------------
signed int __usercall sub_10021930@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st6@1

  v1 = a1;
  *(float *)(a1 + 241700) = 0.5;
  *(float *)(a1 + 241660) = flt_10168DD4 * 0.5 + flt_10168DCC;
  *(float *)(a1 + 241704) = 0.0;
  *(float *)(a1 + 241664) = flt_10168DD0;
  *(float *)(a1 + 241544) = 1.0;
  *(float *)(a1 + 241512) = flt_10168DD4 + flt_10168DCC - 36.0;
  *(float *)(a1 + 241548) = 1.0;
  v2 = flt_10168DD8 + flt_10168DD0;
  *(_DWORD *)(a1 + 241532) = a1 + 242096;
  *(float *)(a1 + 241516) = v2;
  *(float *)(a1 + 241804) = 1.0;
  *(float *)(a1 + 241764) = flt_10168DD4 + flt_10168DCC;
  *(float *)(v1 + 241768) = *(float *)(v1 + 241516);
  sub_100649E0(a1 + 241780, "HRS", 21);
  return sub_10045010(v1 + 238952, 1, v1 + 238344);
}
// 10168DCC: using guessed type float flt_10168DCC;
// 10168DD0: using guessed type float flt_10168DD0;
// 10168DD4: using guessed type float flt_10168DD4;
// 10168DD8: using guessed type float flt_10168DD8;

//----- (10021A00) --------------------------------------------------------
void __usercall sub_10021A00(int a1@<esi>)
{
  float *v1; // ecx@9
  double v2; // st7@9
  double v3; // st6@9
  float *v4; // ecx@12
  double v5; // st7@12
  double v6; // st6@12
  char v7; // [sp+2h] [bp-Ah]@6
  char v8; // [sp+3h] [bp-9h]@5
  float v9; // [sp+4h] [bp-8h]@1
  float v10; // [sp+8h] [bp-4h]@9

  if ( sub_100664A0(&v9) )
    *(float *)(a1 + 656) = v9;
  if ( sub_10066510(&v9) )
    *(float *)(a1 + 668) = v9;
  v9 = *(float *)(dword_1031FB44 + 5232) * 0.08695652335882187;
  if ( !sub_10067000(0xCCu, &v8) || !sub_10067000(0xCDu, &v7) )
    goto LABEL_16;
  if ( v8 )
  {
    if ( !v7 )
    {
      v1 = (float *)(a1 + 160000);
      v2 = v9;
      v10 = *(float *)(a1 + 656) - v9;
      v3 = v10;
      *(float *)(a1 + 160000) = v10;
      if ( v3 < 0.0 )
        *v1 = v2 + *(float *)(a1 + 656);
      *(_DWORD *)(a1 + 144308) = v1;
      *(_DWORD *)(a1 + 160024) = -16711681;
      goto LABEL_17;
    }
LABEL_16:
    *(_DWORD *)(a1 + 144308) = 0;
    *(_DWORD *)(a1 + 144312) = 0;
    *(_DWORD *)(a1 + 160024) = -16777216;
    *(_DWORD *)(a1 + 160044) = -16777216;
    goto LABEL_17;
  }
  if ( !v7 )
    goto LABEL_16;
  v4 = (float *)(a1 + 160004);
  v5 = v9;
  v10 = *(float *)(a1 + 668) - v9;
  v6 = v10;
  *(float *)(a1 + 160004) = v10;
  if ( v6 < 0.0 )
    *v4 = v5 + *(float *)(a1 + 668);
  *(_DWORD *)(a1 + 144312) = v4;
  *(_DWORD *)(a1 + 160044) = -16711681;
LABEL_17:
  if ( sub_10066930(a1, 0x70u, &v9) )
    *(float *)(a1 + 776) = v9;
  if ( sub_10066930(a1, 0x67u, &v9) )
    *(float *)(a1 + 788) = v9;
  if ( sub_10066930(a1, 0x68u, &v9) )
    *(float *)(a1 + 800) = v9;
  if ( sub_10066930(a1, 0x69u, &v9) )
    *(float *)(a1 + 812) = v9;
  *(float *)(a1 + 242096) = sub_1004C070();
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021BE0) --------------------------------------------------------
int __usercall sub_10021BE0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edi@1

  v1 = a1;
  v2 = (unsigned __int8)sub_10066EE0(a1 + 460, 3u, *(_BYTE *)(dword_1031FB44 + 25));
  sub_10049040(v1 + 12 * v2 + 496, 1, 1, v1 + 42128);
  return sub_10064B00((char *)(v1 + 42612), 7u, "%d", v2 + 1);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021C40) --------------------------------------------------------
int __usercall sub_10021C40@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  double v3; // st4@9
  double v4; // st5@9
  double v5; // st3@12
  float v6; // ST34_4@14
  bool v7; // c0@14
  bool v8; // c3@14
  double v9; // st5@14
  float v10; // ST34_4@18
  float v11; // ST34_4@22
  double v12; // st7@22
  float v13; // ST34_4@24
  double v14; // st7@24
  float v15; // ST34_4@26
  int v16; // edi@29
  float v18; // [sp+8h] [bp-4h]@8
  float v19; // [sp+8h] [bp-4h]@16

  v1 = a1;
  v2 = *(_BYTE *)(a1 + 242180);
  if ( !v2 )
  {
    *(_BYTE *)(v1 + 58134) = -1;
LABEL_28:
    *(_BYTE *)(v1 + 62914) = sub_10066EE0(v1 + 460, 0x12u, *(_BYTE *)(dword_1031FB44 + 25));
    *(_BYTE *)(v1 + 52378) = sub_10066EE0(v1 + 460, 3u, *(_BYTE *)(dword_1031FB44 + 25));
    goto LABEL_29;
  }
  if ( v2 == 2 )
  {
    if ( *(_BYTE *)(v1 + 457) )
    {
      if ( *(float *)(v1 + 242172) < (double)*(float *)(v1 + 752) )
      {
        *(float *)(v1 + 242172) = *(float *)(v1 + 752);
        *(float *)(v1 + 242184) = *(float *)(v1 + 488);
      }
      if ( *(float *)(v1 + 242176) < (double)*(float *)(v1 + 764) )
      {
        *(float *)(v1 + 242176) = *(float *)(v1 + 764);
        *(float *)(v1 + 242188) = *(float *)(v1 + 488);
      }
      v18 = *(float *)(v1 + 752) * 1.799999952316284 + 32.0 - (*(float *)(v1 + 242172) * 1.799999952316284 + 32.0);
      if ( v18 <= 0.0 )
      {
        v3 = 0.0;
        v4 = 0.0;
      }
      else
      {
        v3 = 0.0;
        v4 = 0.0;
        v18 = 0.0;
      }
      *(float *)(v1 + 872) = v18;
      if ( v18 <= -500.0 )
      {
        v18 = -500.0;
        v5 = -500.0;
      }
      else
      {
        v5 = -500.0;
      }
      *(float *)(v1 + 872) = v18;
      v6 = *(float *)(v1 + 764) * 1.799999952316284 + 32.0 - (1.799999952316284 * *(float *)(v1 + 242176) + 32.0);
      v7 = v6 < v4;
      v8 = v6 == v4;
      v9 = v6;
      if ( !v7 && !v8 )
        v9 = v3;
      v19 = v9;
      *(float *)(v1 + 884) = v19;
      if ( v19 <= -500.0 )
      {
        v10 = v5;
        *(float *)(v1 + 884) = v10;
      }
      else
      {
        *(float *)(v1 + 884) = v19;
      }
      goto LABEL_28;
    }
    if ( *(_BYTE *)(v1 + 242193) )
      sub_10047850(v1 + 63224, v1 + 57172);
    else
      sub_10047850(v1 + 63224, v1 + 61952);
    v11 = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 63258) + 680) * 1.799999952316284
        + 32.0
        - (1.799999952316284 * *(float *)(v1 + 4 * *(_BYTE *)(v1 + 63258) + 63268)
         + 32.0);
    v12 = v11;
    if ( v11 > 0.0 )
      v12 = 0.0;
    v13 = v12;
    v14 = v13;
    *(float *)(v1 + 872) = v13;
    if ( v13 <= -500.0 )
      v14 = -500.0;
    v15 = v14;
    *(float *)(v1 + 872) = v15;
  }
LABEL_29:
  v16 = (unsigned __int8)sub_10066EE0(v1 + 460, 0x12u, *(_BYTE *)(dword_1031FB44 + 25));
  sub_10049040(v1 + 12 * v16 + 676, 1, 1, v1 + 52664);
  return sub_10064B00((char *)(v1 + 53148), 7u, "%d", v16 + 1);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10021F10) --------------------------------------------------------
int __usercall sub_10021F10@<eax>(float a1@<ecx>, int a2@<edi>)
{
  float *v2; // eax@1
  signed int v3; // ecx@1
  unsigned int v4; // esi@5
  double v5; // st7@6
  int v6; // eax@6
  int v7; // ecx@7
  int v8; // eax@10
  char v9; // dl@11
  char v11; // [sp-4h] [bp-8h]@11
  float v12; // [sp+0h] [bp-4h]@1

  v12 = a1;
  v2 = (float *)(a2 + 464);
  v3 = 39;
  do
  {
    *v2 = 9.8999998e24;
    v2 += 3;
    --v3;
  }
  while ( v3 );
  if ( sub_10066790(0x5Eu, &v12) )
    *(float *)(a2 + 920) = v12;
  v4 = 0;
  do
  {
    v5 = sub_1004C3E0(word_100BFF6A[v4]);
    v6 = (unsigned __int8)byte_100BFF68[v4 * 2];
    v4 += 2;
    *(float *)(a2 + 12 * v6 + 464) = v5;
  }
  while ( v4 < 50 );
  if ( sub_100663D0(&v12) )
    *(float *)(a2 + 488) = v12;
  if ( *(float *)(a2 + 480) < 500.0 )
  {
    v7 = *(_DWORD *)(a2 + 242100);
    v8 = a2 + 242100;
    if ( !*(_BYTE *)(v7 + 24) )
    {
      v11 = 1;
      v9 = 10;
LABEL_15:
      LOBYTE(v7) = 18;
      sub_100206F0(v8, v9, v7, v11);
      goto LABEL_16;
    }
  }
  if ( *(float *)(a2 + 480) >= 500.0 )
  {
    v8 = a2 + 242100;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 242100) + 24) == 1 )
    {
      v11 = 0;
      v9 = 0;
      goto LABEL_15;
    }
  }
LABEL_16:
  sub_10021BE0(a2);
  return sub_10021C40(a2);
}
// 100BFF6A: using guessed type __int16 word_100BFF6A[];

//----- (10022010) --------------------------------------------------------
void __usercall sub_10022010(int a1@<edi>)
{
  int v1; // edx@1
  int v2; // ecx@1
  int v3; // eax@5
  double v4; // st7@7
  float v5; // [sp+0h] [bp-Ch]@0
  char v6; // [sp+3h] [bp-9h]@3
  float v7; // [sp+4h] [bp-8h]@1
  float v8; // [sp+8h] [bp-4h]@1

  v8 = 0.0;
  v7 = 0.0;
  *(float *)(a1 + 824) = sub_1004C0C0();
  *(float *)(a1 + 836) = sub_1004C0D0(v2, v1);
  *(_DWORD *)(a1 + 238952) = sub_1004BF40();
  *(float *)(a1 + 848) = sub_1004BFF0(v5);
  if ( !sub_1006CA40(&v8) || !sub_100663D0(&v7) || (v6 = 1, 0.0 == v7) )
    v6 = 0;
  v3 = *(_DWORD *)(a1 + 238952);
  if ( v3 != 0x7FFFFFFF )
    *(_DWORD *)(a1 + 238952) = sub_1001DD30(a1 + 238956, 0x14u, v3);
  v4 = -1.0;
  if ( 9.8999998e24 == *(float *)(a1 + 848) )
    *(float *)(a1 + 848) = -1.0;
  if ( v6 )
    v4 = v8 / v7;
  *(float *)(a1 + 860) = v4;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);

//----- (100220F0) --------------------------------------------------------
int __usercall sub_100220F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  float v5; // ST28_4@3
  float v6; // ST28_4@3
  float v7; // ST28_4@3
  float v8; // ST28_4@3
  float v9; // ST14_4@3
  float v10; // ST28_4@3
  float v11; // ST28_4@3
  float v12; // ST14_4@3
  float v13; // ST28_4@3
  char v14; // bl@3
  int v15; // eax@5
  char v16; // al@8
  int result; // eax@14
  int v18; // [sp+14h] [bp-8h]@0

  v1 = a1;
  v2 = (float *)"QC";
  v3 = a1 + 464;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&unk_100C0094 );
  sub_1001D9A0(v1);
  *(_DWORD *)(v1 + 316) = 50529027;
  *(_DWORD *)(v1 + 320) = 50529027;
  *(_DWORD *)(v1 + 324) = 50529027;
  *(_DWORD *)(v1 + 328) = 50529027;
  *(_BYTE *)(v1 + 332) = 3;
  *(_DWORD *)(v1 + 333) = 50529027;
  *(_DWORD *)(v1 + 337) = 50529027;
  *(_DWORD *)(v1 + 341) = 50529027;
  *(_WORD *)(v1 + 345) = 771;
  *(_DWORD *)(v1 + 347) = 50529027;
  *(_DWORD *)(v1 + 351) = 50529027;
  *(_DWORD *)(v1 + 355) = 50529027;
  *(_DWORD *)(v1 + 359) = 50529027;
  *(_DWORD *)(v1 + 363) = 50529027;
  *(_DWORD *)(v1 + 367) = 0;
  *(_DWORD *)(v1 + 371) = 0;
  *(_DWORD *)(v1 + 375) = 0;
  *(_DWORD *)(v1 + 379) = 0;
  *(_WORD *)(v1 + 383) = 0;
  *(_DWORD *)(v1 + 385) = 0;
  *(_DWORD *)(v1 + 389) = 0;
  *(_WORD *)(v1 + 393) = 0;
  *(float *)(v1 + 197968) = -500.0;
  *(_DWORD *)(v1 + 198016) = 0;
  *(float *)(v1 + 197972) = 0.0;
  *(float *)(v1 + 197976) = 0.0;
  *(_BYTE *)(v1 + 197964) = 1;
  *(_BYTE *)(v1 + 198056) = 10;
  sub_100649E0(v1 + 198108, "Peak", 16);
  LOBYTE(v18) = sub_10020910(v1);
  v5 = sub_1004CF90(COERCE_FLOAT(byte_10168B80), (int)&unk_10168DE8, v1 + 460, v18, 10.0, 676.0);
  sub_10021520(v1, v18, v5);
  LOBYTE(v18) = sub_10021150(v1);
  v6 = *(float *)(v1 + 448) - 10.0;
  sub_1004CF90(COERCE_FLOAT(&unk_10168AA0), 0, v1 + 460, v18, 10.0, v6);
  sub_10021760(v1);
  LOBYTE(v18) = sub_10021290(v1);
  v7 = *(float *)(v1 + 448) - 10.0;
  sub_1004CF90(COERCE_FLOAT(&unk_10168D38), 0, v1 + 460, v18, 10.0, v7);
  v8 = flt_10168D80 + flt_10168D78 - 5.0;
  v9 = v8;
  v10 = flt_10168D78 + 11.0;
  sub_1004CF90(COERCE_FLOAT(&unk_10168F78), 0, v1 + 460, 5, v10, v9);
  v11 = flt_10168DAC + flt_10168DA4 - 5.0;
  v12 = v11;
  v13 = flt_10168DA4 + 11.0;
  sub_1004CF90(COERCE_FLOAT(&unk_101689C0), 0, v1 + 460, 5, v13, v12);
  sub_10021930(v1);
  v14 = *(_BYTE *)(v1 + 242192);
  if ( v14 & 2 )
    sub_10020210(~v14 & 1, v1);
  v15 = *(_BYTE *)(v1 + 242192);
  if ( v15 & 1 )
  {
    LOBYTE(v15) = ~((unsigned __int8)v15 >> 1);
    sub_10020350(v1, COERCE_FLOAT(v15 & 0xFFFFFF01));
  }
  if ( *(_BYTE *)(v1 + 242193) )
  {
    sub_1001DDD0(v1);
    sub_1001F280(0, v1);
    sub_1001F960(v1);
    sub_1001E5E0(v1);
    sub_1001ED50(v1);
    sub_1001F030(v1, 0.0);
    sub_1001FEA0(v1);
    v16 = *(_BYTE *)(v1 + 242192);
    if ( v16 & 0x40 )
    {
      sub_10020070(v1);
    }
    else if ( v16 & 0x20 )
    {
      sub_1001E3B0(v1);
    }
    sub_1001F450(v1);
    if ( *(_BYTE *)(v1 + 242192) & 0x10 )
      sub_1001EB90(v1);
  }
  sub_10020D70(v1);
  *(_DWORD *)(v1 + 242100) = v1 + 12704;
  *(_DWORD *)(v1 + 242104) = v1 + 78364;
  *(_DWORD *)(v1 + 242108) = v1 + 46452;
  *(_DWORD *)(v1 + 242112) = v1 + 52496;
  *(_DWORD *)(v1 + 242116) = v1 + 52524;
  *(_DWORD *)(v1 + 242120) = v1 + 52552;
  *(_DWORD *)(v1 + 242124) = v1 + 52580;
  *(_DWORD *)(v1 + 242128) = v1 + 52608;
  *(_DWORD *)(v1 + 242132) = v1 + 52636;
  *(_DWORD *)(v1 + 242136) = v1 + 84680;
  *(_DWORD *)(v1 + 242140) = v1 + 18316;
  *(_DWORD *)(v1 + 242144) = v1 + 84116;
  *(_DWORD *)(v1 + 242148) = v1 + 47716;
  *(_DWORD *)(v1 + 242152) = v1 + 47744;
  *(_DWORD *)(v1 + 242156) = v1 + 47772;
  result = v1 + 47800;
  *(_DWORD *)(v1 + 242160) = v1 + 47800;
  *(_DWORD *)(v1 + 242164) = v1 + 47828;
  *(_DWORD *)(v1 + 242168) = v1 + 47856;
  return result;
}
// 10168D78: using guessed type float flt_10168D78;
// 10168D80: using guessed type float flt_10168D80;
// 10168DA4: using guessed type float flt_10168DA4;
// 10168DAC: using guessed type float flt_10168DAC;

//----- (100224E0) --------------------------------------------------------
void __usercall sub_100224E0(int a1@<eax>, void *a2@<ecx>)
{
  int v2; // edi@1
  int v3; // esi@1
  char v4; // al@1
  bool v5; // zf@1

  v2 = a1;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = sub_1004BF10(a2);
  v5 = *(_BYTE *)(v3 + 242193) == 0;
  *(_BYTE *)(v3 + 395) = v4;
  if ( v5 )
    goto LABEL_20;
  sub_100207F0(v2);
  if ( *(_BYTE *)(v3 + 242180) != 2 || 95.0 != *(float *)(v3 + 242344) )
    sub_100653C0(v2, *(_WORD **)(v2 + 52), (char *)&unk_100C0938, v3 + 204, v3 + 367, 255);
  sub_100653C0(v2, *(_WORD **)(v2 + 52), (char *)&unk_100C09D0, v3 + 276, v3 + 385, 255);
  sub_10012690();
  if ( !*(_BYTE *)(v3 + 242193) )
  {
LABEL_20:
    if ( !*(_BYTE *)(v3 + 395) )
      goto LABEL_19;
  }
  if ( *(_BYTE *)(v3 + 242180) == 2 && 95.0 == *(float *)(v3 + 242344) )
LABEL_19:
    sub_100653C0(v2, *(_WORD **)(v2 + 52), (char *)&unk_100C0788, v3, v3 + 316, 255);
  if ( !*(_BYTE *)(v3 + 242193) )
  {
    if ( *(_BYTE *)(v3 + 395) == 1 )
      sub_100653C0(v2, *(_WORD **)(v2 + 52), (char *)&unk_100C0818, v3 + 68, v3 + 333, 255);
    if ( !*(_BYTE *)(v3 + 242193) && *(_BYTE *)(v3 + 395) == 2 )
      sub_100653C0(v2, *(_WORD **)(v2 + 52), (char *)&unk_100C0890, v3 + 124, v3 + 347, 255);
  }
  *(_BYTE *)(v2 + 6) = 2;
}

//----- (10022630) --------------------------------------------------------
char __usercall sub_10022630@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@4
  signed int v4; // ecx@4
  signed int v5; // eax@6
  char result; // al@8
  char v7; // [sp+Fh] [bp-5h]@1
  int v8; // [sp+10h] [bp-4h]@4

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 242356, 0);
  sub_1008D070(9, &v7);
  v2 = *(_DWORD *)(a1 + 64) != 9;
  *(_BYTE *)(v1 + 242193) = *(_DWORD *)(a1 + 64) == 9;
  if ( v2 )
  {
    sub_100011B0(a1, 0, 0, 210, 686, 3);
  }
  else
  {
    sub_100522C0(1);
    sub_100011B0(a1, 0, 0, 1024, 686, 3);
    sub_10032790(a1, &unk_100BFE88, 5u, 3, 1u);
  }
  *(float *)(v1 + 242200) = 0.0;
  v8 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 32);
  v3 = v1 + 242264;
  *(float *)(v1 + 242204) = (double)v8;
  *(float *)(v1 + 242208) = 0.0;
  v8 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 34);
  v4 = 10;
  *(float *)(v1 + 242196) = (double)v8;
  *(float *)(v1 + 242212) = 0.0;
  *(float *)(v1 + 242216) = 0.0;
  *(float *)(v1 + 242220) = 0.0;
  *(float *)(v1 + 242344) = 0.0;
  *(float *)(v1 + 242348) = 0.0;
  *(float *)(v1 + 242352) = 0.0;
  do
  {
    *(float *)(v3 - 40) = 0.0;
    v3 += 4;
    --v4;
    *(float *)(v3 - 4) = 0.0;
    *(float *)(v3 + 36) = 0.0;
  }
  while ( v4 );
  v5 = sub_1004BF40();
  if ( v5 == 0x7FFFFFFF )
    v5 = 0;
  *(_DWORD *)(v1 + 238956) = v5;
  *(_DWORD *)(v1 + 238960) = v5;
  *(_DWORD *)(v1 + 238964) = v5;
  *(_DWORD *)(v1 + 238968) = v5;
  *(_DWORD *)(v1 + 238972) = v5;
  *(_DWORD *)(v1 + 238976) = v5;
  *(_DWORD *)(v1 + 238980) = v5;
  *(_DWORD *)(v1 + 238984) = v5;
  *(_DWORD *)(v1 + 238988) = v5;
  *(_DWORD *)(v1 + 238992) = v5;
  *(_DWORD *)(v1 + 238996) = v5;
  *(_DWORD *)(v1 + 239000) = v5;
  *(_DWORD *)(v1 + 239004) = v5;
  *(_DWORD *)(v1 + 239008) = v5;
  *(_DWORD *)(v1 + 239012) = v5;
  *(_DWORD *)(v1 + 239016) = v5;
  *(_DWORD *)(v1 + 239020) = v5;
  *(_DWORD *)(v1 + 239024) = v5;
  *(_DWORD *)(v1 + 239028) = v5;
  *(_DWORD *)(v1 + 239032) = v5;
  *(_BYTE *)(v1 + 242180) = 0;
  sub_1004CCA0(v1 + 63224, 1);
  *(_DWORD *)(v1 + 63228) = v1 + 680;
  *(_DWORD *)(v1 + 63232) = v1 + 692;
  *(_DWORD *)(v1 + 63236) = v1 + 704;
  *(_DWORD *)(v1 + 63240) = v1 + 716;
  *(_DWORD *)(v1 + 63248) = v1 + 740;
  *(_DWORD *)(v1 + 63244) = v1 + 728;
  *(_DWORD *)(v1 + 63252) = v1 + 488;
  *(_BYTE *)(v1 + 63224) = *(_BYTE *)(dword_1031FB44 + 25);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_DWORD *)(v1 + 16) = v1 + 30180;
  *(_DWORD *)(v1 + 20) = v1 + 144268;
  *(_DWORD *)(v1 + 24) = v1 + 30792;
  *(_DWORD *)(v1 + 28) = v1 + 74040;
  *(_DWORD *)(v1 + 32) = v1 + 63316;
  *(_DWORD *)(v1 + 36) = v1 + 165668;
  *(_DWORD *)(v1 + 40) = v1 + 193472;
  *(_DWORD *)(v1 + 48) = v1 + 52664;
  *(_DWORD *)(v1 + 44) = v1 + 42128;
  *(_DWORD *)(v1 + 52) = v1 + 199352;
  *(_DWORD *)(v1 + 56) = v1 + 217320;
  *(_DWORD *)(v1 + 64) = v1 + 226304;
  *(_DWORD *)v1 = v1 + 928;
  *(_DWORD *)(v1 + 4) = v1 + 7136;
  *(_DWORD *)(v1 + 8) = v1 + 18964;
  *(_DWORD *)(v1 + 12) = v1 + 18352;
  *(_DWORD *)(v1 + 60) = v1 + 212828;
  *(_DWORD *)(v1 + 68) = v1 + 928;
  *(_DWORD *)(v1 + 72) = v1 + 7136;
  *(_DWORD *)(v1 + 76) = v1 + 18964;
  *(_DWORD *)(v1 + 124) = v1 + 928;
  *(_DWORD *)(v1 + 140) = v1 + 30180;
  *(_DWORD *)(v1 + 128) = v1 + 7136;
  *(_DWORD *)(v1 + 132) = v1 + 18964;
  *(_DWORD *)(v1 + 84) = v1 + 30180;
  *(_DWORD *)(v1 + 152) = v1 + 120344;
  *(_DWORD *)(v1 + 88) = v1 + 35284;
  *(_DWORD *)(v1 + 164) = v1 + 235900;
  *(_DWORD *)(v1 + 92) = v1 + 165668;
  *(_DWORD *)(v1 + 144) = v1 + 73428;
  *(_DWORD *)(v1 + 148) = v1 + 84152;
  *(_DWORD *)(v1 + 176) = v1 + 239648;
  *(_DWORD *)(v1 + 104) = v1 + 51416;
  *(_DWORD *)(v1 + 156) = v1 + 84764;
  *(_DWORD *)(v1 + 160) = v1 + 35896;
  *(_DWORD *)(v1 + 188) = v1 + 199352;
  *(_DWORD *)(v1 + 96) = v1 + 61952;
  *(_DWORD *)(v1 + 168) = v1 + 237124;
  *(_DWORD *)(v1 + 172) = v1 + 238344;
  *(_DWORD *)(v1 + 192) = v1 + 217320;
  *(_DWORD *)(v1 + 100) = v1 + 198740;
  *(_DWORD *)(v1 + 180) = v1 + 240872;
  *(_DWORD *)(v1 + 184) = v1 + 241484;
  *(_DWORD *)(v1 + 196) = v1 + 212828;
  *(_DWORD *)(v1 + 80) = v1 + 18352;
  *(_DWORD *)(v1 + 136) = v1 + 18352;
  *(_DWORD *)(v1 + 108) = v1 + 199352;
  *(_DWORD *)(v1 + 204) = v1 + 6524;
  *(_DWORD *)(v1 + 248) = v1 + 12732;
  *(_DWORD *)(v1 + 252) = v1 + 24560;
  *(_DWORD *)(v1 + 112) = v1 + 217320;
  *(_DWORD *)(v1 + 256) = v1 + 67808;
  *(_DWORD *)(v1 + 260) = v1 + 78532;
  *(_DWORD *)(v1 + 224) = v1 + 85376;
  *(_DWORD *)(v1 + 116) = v1 + 212828;
  *(_DWORD *)(v1 + 228) = v1 + 97032;
  *(_DWORD *)(v1 + 232) = v1 + 108688;
  *(_DWORD *)(v1 + 236) = v1 + 120956;
  *(_DWORD *)(v1 + 120) = v1 + 226304;
  *(_DWORD *)(v1 + 200) = v1 + 226304;
  *(_DWORD *)(v1 + 240) = v1 + 132612;
  *(_DWORD *)(v1 + 264) = v1 + 148760;
  *(_DWORD *)(v1 + 268) = v1 + 154380;
  *(_DWORD *)(v1 + 244) = v1 + 160048;
  *(_DWORD *)(v1 + 208) = v1 + 203844;
  *(_DWORD *)(v1 + 216) = v1 + 221812;
  *(_DWORD *)(v1 + 220) = v1 + 230796;
  *(_DWORD *)(v1 + 212) = v1 + 208336;
  *(_DWORD *)(v1 + 272) = v1 + 181816;
  *(_DWORD *)(v1 + 288) = v1 + 46620;
  *(_DWORD *)(v1 + 280) = v1 + 57156;
  *(_DWORD *)(v1 + 284) = v1 + 170160;
  *(_DWORD *)(v1 + 276) = v1 + 36508;
  *(_DWORD *)(v1 + 292) = v1 + 198128;
  *(_DWORD *)(v1 + 296) = v1 + 235288;
  *(_DWORD *)(v1 + 300) = v1 + 236512;
  *(_DWORD *)(v1 + 304) = v1 + 237736;
  *(_DWORD *)(v1 + 308) = v1 + 239036;
  *(_DWORD *)(v1 + 312) = v1 + 240260;
  sub_100220F0(v1);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0788, v1, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0938, v1 + 204, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C09D0, v1 + 276, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 100);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10022C70) --------------------------------------------------------
void __cdecl sub_10022C70(int a1)
{
  float v1; // ecx@0
  int v2; // ebp@1
  int v3; // eax@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // edx@6
  const char *v7; // eax@7
  int v8; // edx@7
  char v9; // cl@8
  const char *v10; // eax@10
  int v11; // edx@10
  char v12; // cl@11
  double v13; // st7@16
  bool v14; // zf@32
  float v15; // [sp+28h] [bp+4h]@40

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(v3 + 12);
  v5 = *(_DWORD *)(v3 + 12);
  sub_10021F10(v1, v5);
  sub_10021A00(v4);
  sub_10022010(v5);
  sub_1004C380(v4 + 460, 0x27u);
  if ( *(_BYTE *)(v4 + 242180) == 2 && *(_BYTE *)(v4 + 457) )
  {
    if ( *(float *)(v4 + 242184) <= (double)*(float *)(v4 + 488) )
    {
      strcpy((char *)(v4 + 198424), "RICH");
      strcpy((char *)(v4 + 199036), "  R  ");
    }
    else
    {
      sub_100649E0(v4 + 198424, "LEAN", 21);
      sub_100649E0(v4 + 199036, "  L  ", 21);
    }
    v6 = v4 + 198476;
    if ( *(float *)(v4 + 242188) <= (double)*(float *)(v4 + 488) )
    {
      v10 = "RICH";
      v11 = v6 - (_DWORD)"RICH";
      do
      {
        v12 = *v10;
        v10[v11] = *v10;
        ++v10;
      }
      while ( v12 );
      strcpy((char *)(v4 + 199088), "  R  ");
    }
    else
    {
      v7 = "LEAN";
      v8 = v6 - (_DWORD)"LEAN";
      do
      {
        v9 = *v7;
        v7[v8] = *v7;
        ++v7;
      }
      while ( v9 );
      strcpy((char *)(v4 + 199088), "  L  ");
    }
  }
  if ( *(_BYTE *)(v4 + 242193) )
  {
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0694, (int)&unk_100C0A2C, 0, 255);
    sub_100204F0(a1);
    sub_100207F0(a1);
    if ( (unsigned __int8)sub_1001DD80(*(float *)(v4 + 242344)) )
    {
      if ( 95.0 == *(float *)(v4 + 242344) )
      {
        sub_1001F280(1, v4);
        sub_1001F030(v4, COERCE_FLOAT(1));
        *(float *)(v4 + 416) = 672.0;
        *(_BYTE *)(v4 + 389) = 3;
        v13 = 332.0;
      }
      else
      {
        sub_1001F280(0, v4);
        sub_1001F030(v4, 0.0);
        *(float *)(v4 + 416) = *(float *)(v4 + 404);
        *(_BYTE *)(v4 + 389) = 0;
        v13 = *(float *)(v4 + 408);
      }
      *(float *)(v4 + 420) = v13;
    }
    if ( *(_BYTE *)(v4 + 242180) != 2 || 95.0 != *(float *)(v4 + 242344) )
    {
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0938, v4 + 204, v4 + 367, 255);
      sub_100680A0(v4 + 160008);
      sub_100680A0(v4 + 160028);
      sub_1006BEE0((int)"ELECTRICAL", 20.0, 480.0, 445.0, 186.0);
    }
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C09D0, v4 + 276, v4 + 385, 255);
    sub_1006BEE0((int)"FUEL CALC", *(float *)(v4 + 416), 207.0, *(float *)(v4 + 420), 152.0);
    sub_1006BEE0((int)"TEMPERATURE", 472.0, 394.0, 532.0, 272.0);
    sub_10012690();
  }
  if ( !*(_BYTE *)(v4 + 242193) && !*(_BYTE *)(v4 + 395)
    || *(_BYTE *)(v4 + 242180) == 2 && 95.0 == *(float *)(v4 + 242344) )
  {
    if ( *(_BYTE *)(v4 + 242192) & 0x40 )
      sub_10048A00(flt_10168CC4, flt_10168CC8, v4 + 165668);
    if ( !*(_BYTE *)(v4 + 242193) )
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C04F4, (int)&unk_100C0A24, 0, 255);
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0788, v4, v4 + 316, 255);
    sub_1001DB90(v4);
  }
  v14 = *(_BYTE *)(v4 + 242193) == 0;
  if ( !*(_BYTE *)(v4 + 242193) )
  {
    if ( *(_BYTE *)(v4 + 395) == 1 )
    {
      if ( *(_BYTE *)(v4 + 242192) & 0x40 )
        sub_10048A00(flt_10168B60, flt_10168B64, v4 + 165668);
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C04F4, (int)&unk_100C0A24, 0, 255);
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0818, v4 + 68, v4 + 333, 255);
      sub_1001DB90(v4);
    }
    v14 = *(_BYTE *)(v4 + 242193) == 0;
  }
  if ( v14 && *(_BYTE *)(v4 + 395) == 2 )
  {
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C04F4, (int)&unk_100C0A24, 0, 255);
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C0890, v4 + 124, v4 + 347, 255);
    sub_1006BF20((int)"SYSTEM", 7.0, flt_10168D78, 135.0, flt_10168D80);
    sub_1006BF20((int)"FUEL", 7.0, flt_10168DA4, 135.0, flt_10168DAC);
    v15 = flt_10168DD0 + 12.0 + 6.0;
    sub_100682A0(7.0, v15, 135.0, v15, -1, 1.0);
    sub_1001DB90(v4);
  }
  *(_BYTE *)(v2 + 6) = 2;
}
// 10168B60: using guessed type float flt_10168B60;
// 10168B64: using guessed type float flt_10168B64;
// 10168CC4: using guessed type float flt_10168CC4;
// 10168CC8: using guessed type float flt_10168CC8;
// 10168D78: using guessed type float flt_10168D78;
// 10168D80: using guessed type float flt_10168D80;
// 10168DA4: using guessed type float flt_10168DA4;
// 10168DAC: using guessed type float flt_10168DAC;
// 10168DD0: using guessed type float flt_10168DD0;

//----- (100231D0) --------------------------------------------------------
void __cdecl sub_100231D0(int a1)
{
  char v1; // bl@11
  __int16 v2; // dx@13
  int v3; // esi@16
  void *v4; // ecx@1
  int v5; // ecx@5

  v4 = (void *)**(_WORD **)(a1 + 52);
  switch ( v4 )
  {
    case 0x8015u:
    case 0x8016u:
      sub_100224E0(a1, v4);
      break;
    case 0x8018u:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 242193) )
        sub_100522C0(0);
      break;
    case 0x8041u:
      sub_10022630(a1);
      break;
    case 0x8022u:
    case 0x8078u:
      sub_10022C70(a1);
      break;
    default:
      return;
    case 0x8033u:
      v5 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      v1 = *(_BYTE *)(v5 + 242180);
      if ( v1 != 2 || *(_BYTE *)(v5 + 457) )
      {
        v2 = ++*(_BYTE *)(v5 + 62914) % (signed __int16)*(_BYTE *)(dword_1031FB44 + 25);
        *(_BYTE *)(v5 + 62914) = v2;
        *(_BYTE *)(v5 + 52378) = v2;
        if ( v1 != 2 )
          *(_BYTE *)(v5 + 242180) = 1;
      }
      break;
    case 0x8038u:
      sub_10021420(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12));
      break;
    case 0x8039u:
      sub_100207A0(a1);
      break;
    case 0x806Eu:
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      switch ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) )
      {
        case 0x40:
          if ( sub_10032250(a1, 0x40u) == 1 )
          {
            *(_BYTE *)(v3 + 61947) = 1;
            *(_BYTE *)(v3 + 51411) = 1;
            *(_BYTE *)(v3 + 181604) = 1;
          }
          else
          {
            *(_BYTE *)(v3 + 61947) = 0;
            *(_BYTE *)(v3 + 51411) = 0;
            *(_BYTE *)(v3 + 181604) = 0;
          }
          break;
        case 0x41:
          sub_10021420(v3);
          break;
        case 0x42:
          sub_1004C220();
          sub_1004C0E0();
          break;
        case 0x43:
          sub_1004C2B0();
          sub_1004C0E0();
          break;
        case 0x44:
          sub_1004C0E0();
          JUMPOUT(&loc_1004C350);
          return;
        default:
          return;
      }
      return;
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100232D0) --------------------------------------------------------
char __usercall sub_100232D0@<al>(int a1@<esi>)
{
  char result; // al@4

  if ( *(_BYTE *)(a1 + 2) )
    sub_100011B0(a1, 0, 0, 279, 742, 1);
  else
    sub_100011B0(a1, 0, 0, 151, 686, 1);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10023320) --------------------------------------------------------
int __usercall sub_10023320@<eax>(void *a1@<ecx>, int a2@<esi>)
{
  __int16 v2; // ax@3
  __int16 v3; // cx@3
  _WORD *v4; // ST04_4@5
  int result; // eax@5
  char *v6; // [sp-10h] [bp-1Ch]@3
  void *v7; // [sp-Ch] [bp-18h]@3
  __int16 v8; // [sp+0h] [bp-Ch]@5
  __int16 v9; // [sp+2h] [bp-Ah]@5
  int v10; // [sp+4h] [bp-8h]@1

  v10 = 0;
  if ( sub_10052230(a1) != 1 && *(_BYTE *)(a2 + 2) )
  {
    v7 = &unk_100C1238;
    v2 = v10 + 279;
    v3 = HIWORD(v10) + 742;
    v6 = (char *)&unk_100C11A8;
  }
  else
  {
    v7 = &unk_100C124C;
    v2 = v10 + 151;
    v3 = HIWORD(v10) + 686;
    v6 = (char *)&unk_100C11E8;
  }
  v4 = *(_WORD **)(a2 + 52);
  v8 = v2;
  v9 = v3;
  sub_1004AA20(a2, v4, v6, (int)v7, 0, 255);
  result = sub_1004B2B0(a2, (int)&v10, (int)&v8, 0);
  *(_BYTE *)(a2 + 6) = 2;
  return result;
}

//----- (100233F0) --------------------------------------------------------
int sub_100233F0()
{
  return (*(_BYTE *)dword_1031FB44 != 16) + 13;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10023410) --------------------------------------------------------
int __usercall sub_10023410@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@2
  float v3; // ST4C_4@2
  float v4; // ST38_4@2
  float v5; // ST4C_4@2
  float v6; // ST4C_4@2
  float v7; // ST4C_4@3
  float v8; // ST4C_4@4
  float v9; // ST4C_4@5
  double v10; // st7@5
  double v11; // st7@6
  float v12; // ST4C_4@6
  float v13; // ST4C_4@6
  float v14; // ST34_4@7
  float v15; // ST4C_4@7
  float v16; // ST4C_4@7
  float v18; // [sp+0h] [bp-20h]@1
  float v19; // [sp+0h] [bp-20h]@4
  float v20; // [sp+4h] [bp-1Ch]@1
  float v21; // [sp+4h] [bp-1Ch]@4
  float v22; // [sp+8h] [bp-18h]@1
  float v23; // [sp+8h] [bp-18h]@4
  float v24; // [sp+8h] [bp-18h]@5
  float v25; // [sp+Ch] [bp-14h]@1
  float v26; // [sp+Ch] [bp-14h]@4
  float v27; // [sp+Ch] [bp-14h]@5
  int v28; // [sp+10h] [bp-10h]@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v25 = 18.0;
  v22 = 130.0;
  v20 = 343.0;
  v18 = 10.0;
  if ( *(_BYTE *)(v1 + 127984) )
  {
    sub_1004A1A0(v1 + 28700, (int)"FUEL PSI", dword_1031FB44 + 4404, v18, v20, v22, v25, 0);
    sub_100490F0(dword_1031FB44 + 20564, v1 + 28700);
    *(_WORD *)(v1 + 33012) = 15;
    sub_10049040(v1 + 300, 1, 1, v1 + 28700);
    sub_10049630((float *)(v1 + 28700));
    v7 = *(float *)(v1 + 28724) - *(float *)(v1 + 28720);
    sub_1004A660(v7, 0.0, -0.80000001, v1 + 28700);
  }
  else
  {
    sub_1004A1A0(v1 + 28700, (int)"FFLOW GPH", dword_1031FB44 + 4568, v18, v20, v22, v25, 0);
    sub_100490F0(dword_1031FB44 + 20592, v1 + 28700);
    sub_10049630((float *)(v1 + 28700));
    *(_WORD *)(v1 + 33012) = 33;
    sub_10049040(v1 + 312, 1, 1, v1 + 28700);
    v2 = *(float *)(v1 + 28724) - *(float *)(v1 + 28720);
    v3 = 0.1000000014901161 * v2;
    v4 = v3;
    v5 = v2;
    sub_1004A660(v5, v4, -0.80000001, v1 + 28700);
    v6 = *(float *)(v1 + 28724) - *(float *)(v1 + 28720);
    sub_100488B0(v6, "%.0f", 1.0, 9.0, v1 + 28700);
  }
  sub_10049090(0, v1 + 28700);
  sub_1004A1A0(v1 + 44228, (int)"CHT F", dword_1031FB44 + 5388, 10.0, 545.0, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20732, v1 + 44228);
  sub_10049040(v1 + 432, 1, 1, v1 + 44228);
  sub_10049630((float *)(v1 + 44228));
  sub_10049090(0, v1 + 44228);
  *(_WORD *)(v1 + 48540) = 17;
  v8 = *(float *)(v1 + 44252) - *(float *)(v1 + 44248);
  sub_1004A660(v8, 0.0, -0.80000001, v1 + 44228);
  v26 = 18.0;
  v23 = 130.0;
  v21 = 497.0;
  v19 = 10.0;
  if ( *(_BYTE *)(v1 + 127985) )
  {
    sub_1004A1A0(v1 + 60808, (int)"TIT F", dword_1031FB44 + 5060, v19, v21, v23, v26, 0);
    v28 = v1 + 60808;
    v27 = -0.80000001;
    v24 = 0.0;
    v9 = *(float *)(v1 + 60832) - *(float *)(v1 + 60828);
    v10 = v9;
  }
  else
  {
    sub_1004A1A0(v1 + 60808, (int)"EGT F", dword_1031FB44 + 5060, v19, v21, v23, v26, 0);
    v11 = *(float *)(v1 + 60832) - *(float *)(v1 + 60828);
    v28 = v1 + 60808;
    v27 = -0.80000001;
    v12 = 0.1000000014901161 * v11;
    v24 = v12;
    v13 = v11;
    v10 = v13;
  }
  v14 = v10;
  sub_1004A660(v14, v24, v27, v28);
  sub_100490F0(dword_1031FB44 + 20676, v1 + 60808);
  sub_10049040(v1 + 348, 1, 1, v1 + 60808);
  sub_10049630((float *)(v1 + 60808));
  sub_10049090(0, v1 + 60808);
  *(_WORD *)(v1 + 65120) = 17;
  sub_1004A1A0(v1 + 72240, (int)"OIL F", dword_1031FB44 + 4896, 10.0, 449.0, 130.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20648, v1 + 72240);
  sub_10049040(v1 + 336, 1, 1, v1 + 72240);
  sub_10049630((float *)(v1 + 72240));
  sub_10049090(0, v1 + 72240);
  *(_WORD *)(v1 + 76552) = 17;
  v15 = *(float *)(v1 + 72264) - *(float *)(v1 + 72260);
  sub_1004A660(v15, 0.0, -0.80000001, v1 + 72240);
  sub_1004A1A0(v1 + 82964, (int)"OIL PSI", dword_1031FB44 + 4732, 10.0, 401.0, 130.0, 18.0, 0);
  sub_10049040(v1 + 324, 1, 1, v1 + 82964);
  sub_10049630((float *)(v1 + 82964));
  sub_10049090(0, v1 + 82964);
  *(_WORD *)(v1 + 87276) = 15;
  v16 = *(float *)(v1 + 82988) - *(float *)(v1 + 82984);
  return sub_1004A660(v16, 0.0, -0.80000001, v1 + 82964);
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100238E0) --------------------------------------------------------
int __usercall sub_100238E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float v2; // ST54_4@1
  float v3; // ST54_4@1
  float v4; // ST54_4@1
  float v5; // ST54_4@3
  float v6; // ST54_4@3
  double v7; // st7@3
  float v8; // ST54_4@3
  const char *v9; // eax@3
  float v10; // ST54_4@6
  double v11; // st7@6
  float v12; // ST54_4@6
  float v13; // ST38_4@6
  float v14; // ST54_4@6
  float v15; // ST54_4@6
  double v16; // st7@7
  float v17; // ST54_4@7
  float v18; // ST38_4@7
  float v19; // ST54_4@7
  float v20; // ST54_4@7
  float v21; // ST54_4@7
  double v22; // st7@8
  float v23; // ST54_4@8
  float v24; // ST54_4@8
  float v25; // ST54_4@8
  float v26; // ST54_4@8
  float v27; // ST54_4@14
  float v28; // ST54_4@14
  float v29; // ST54_4@14
  int v30; // eax@14
  int v31; // eax@14
  int result; // eax@14

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10042820(v1 + 600, (int)"MAN IN HG", dword_1031FB44 + 3912, 10.0, 10.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20480, v1 + 600);
  *(_WORD *)(v1 + 6174) = 5;
  sub_10062160(16931.934, 3386.3867, -0.2, v1 + 616);
  sub_10061F10(16931.934, "%.0f", 1.0, 12.0, -0.2, v1 + 616);
  sub_10060F20(v1 + 252, 1, v1 + 616);
  *(float *)(v1 + 2920) = *(float *)(v1 + 2920) + 20.0;
  *(float *)(v1 + 720) = *(float *)(v1 + 720) + 20.0;
  sub_10042820(v1 + 11840, (int)"RPM", dword_1031FB44 + 4076, 245.0, 10.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20508, v1 + 11840);
  *(_WORD *)(v1 + 17414) = 6;
  v2 = *(float *)(v1 + 11876) - *(float *)(v1 + 11872);
  sub_10062160(v2, 100.0, -0.2, v1 + 11856);
  v3 = *(float *)(v1 + 11876) - *(float *)(v1 + 11872);
  sub_10061F10(v3, "%.0f", 1.0, 12.0, -0.2, v1 + 11856);
  sub_10061FA0(2200.0, -0.2, 7, v1 + 11856);
  sub_10060FA0(2200.0, "%.0f", 1.0, 12.0, -0.2, 2, v1 + 11856);
  sub_10060F20(v1 + 264, 1, v1 + 11856);
  v4 = *(float *)(v1 + 11852) * 0.75 + *(float *)(v1 + 11844);
  *(float *)(v1 + 14160) = v4;
  *(float *)(v1 + 11960) = v4 - 6.0;
  if ( *(_BYTE *)dword_1031FB44 == 15 )
  {
    sub_10061FA0(*(float *)(v1 + 11876), -0.2, *(_BYTE *)(v1 + 17412), v1 + 11856);
    ++*(_BYTE *)(v1 + 17412);
  }
  sub_10042820(v1 + 66620, (int)&word_100B8D60, dword_1031FB44 + 4896, 10.0, 245.0, 215.0, 215.0);
  *(float *)(v1 + 66856) = 140.0;
  *(float *)(v1 + 66860) = 240.0;
  *(float *)(v1 + 66960) = 100.0;
  *(float *)(v1 + 66668) = *(float *)(v1 + 66644) * 0.4000000059604645;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4896), v1 + 66620);
  *(float *)(v1 + 68976) = 18.0;
  v5 = *(float *)(v1 + 66628) * 0.3499999940395355 + *(float *)(v1 + 66620);
  *(float *)(v1 + 68936) = v5;
  *(float *)(v1 + 68968) = 0.5;
  *(float *)(v1 + 66776) = 0.5;
  *(float *)(v1 + 66736) = v5;
  *(float *)(v1 + 68940) = *(float *)(v1 + 66632) * 0.75 + *(float *)(v1 + 66624);
  *(float *)(v1 + 66740) = *(float *)(v1 + 66632) * 0.6000000238418579 + *(float *)(v1 + 66624);
  sub_10042990(dword_1031FB44 + 20648, v1 + 66620);
  sub_10060F20(v1 + 336, 1, v1 + 66636);
  *(_WORD *)(v1 + 72194) = 17;
  v6 = *(float *)(v1 + 66656) - *(float *)(v1 + 66652);
  sub_10062160(v6, 0.0, -0.2, v1 + 66636);
  sub_10042820(v1 + 77344, (int)"PSI", dword_1031FB44 + 4732, 10.0, 245.0, 215.0, 215.0);
  *(float *)(v1 + 77580) = 40.0;
  *(float *)(v1 + 77584) = -60.0;
  *(float *)(v1 + 77684) = -100.0;
  *(float *)(v1 + 77384) = *(float *)(v1 + 77368) * 0.6000000238418579 + *(float *)(v1 + 77360);
  *(float *)(v1 + 77392) = *(float *)(v1 + 77368) * 0.4000000059604645;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4732), v1 + 77344);
  *(float *)(v1 + 79700) = 18.0;
  v7 = *(float *)(v1 + 77352);
  *(_DWORD *)(v1 + 82956) = 59;
  v8 = v7 * 0.6499999761581421 + *(float *)(v1 + 77344);
  *(float *)(v1 + 79660) = v8;
  *(float *)(v1 + 79692) = 0.5;
  *(float *)(v1 + 77500) = 0.5;
  *(float *)(v1 + 77460) = v8;
  *(float *)(v1 + 79664) = *(float *)(v1 + 77356) * 0.75 + *(float *)(v1 + 77348);
  *(float *)(v1 + 77464) = *(float *)(v1 + 77356) * 0.6000000238418579 + *(float *)(v1 + 77348);
  sub_10042990(dword_1031FB44 + 20620, v1 + 77344);
  sub_10060F20(v1 + 324, 1, v1 + 77360);
  *(_WORD *)(v1 + 82918) = 15;
  sub_10062160(999740.12, 0.0, -0.2, v1 + 77360);
  v9 = (const char *)&unk_100BCE04;
  if ( !*(_BYTE *)(v1 + 127984) )
    v9 = "FFLOW GPH";
  sub_10042820(v1 + 23080, (int)v9, dword_1031FB44 + 4568, 245.0, 245.0, 215.0, 215.0);
  sub_10042990(dword_1031FB44 + 20592, v1 + 23080);
  *(_WORD *)(v1 + 28654) = 33;
  sub_10060F20(v1 + 312, 1, v1 + 23096);
  if ( *(_BYTE *)(v1 + 127984) )
  {
    *(float *)(v1 + 23316) = 140.0;
    *(float *)(v1 + 23320) = 240.0;
    *(float *)(v1 + 23420) = 100.0;
    *(float *)(v1 + 23128) = *(float *)(v1 + 23104) * 0.4000000059604645;
    sub_10042980((_BYTE *)(dword_1031FB44 + 4568), v1 + 23080);
    *(float *)(v1 + 25436) = 18.0;
    v10 = *(float *)(v1 + 23088) * 0.3499999940395355 + *(float *)(v1 + 23080);
    *(float *)(v1 + 25396) = v10;
    *(float *)(v1 + 25428) = 0.5;
    *(float *)(v1 + 23236) = 0.5;
    *(float *)(v1 + 23196) = v10;
    *(float *)(v1 + 25400) = *(float *)(v1 + 23092) * 0.75 + *(float *)(v1 + 23084);
    *(float *)(v1 + 23200) = *(float *)(v1 + 23092) * 0.6000000238418579 + *(float *)(v1 + 23084);
    v11 = *(float *)(v1 + 23116) - *(float *)(v1 + 23112);
    v12 = 0.1000000014901161 * v11;
    v13 = v12;
    v14 = v11 * 0.2000000029802322;
    sub_10062160(v14, v13, -0.2, v1 + 23096);
    v15 = *(float *)(v1 + 23116) - *(float *)(v1 + 23112);
    sub_10061F10(v15, "%.0f", 1.0, 12.0, -0.2, v1 + 23096);
  }
  else
  {
    v16 = *(float *)(v1 + 23116) - *(float *)(v1 + 23112);
    v17 = 0.1000000014901161 * v16;
    v18 = v17;
    v19 = v16 * 0.2000000029802322;
    sub_10062160(v19, v18, -0.2, v1 + 23096);
    v20 = (*(float *)(v1 + 23116) - *(float *)(v1 + 23112)) * 0.2000000029802322;
    sub_10061F10(v20, "%.0f", 1.0, 12.0, -0.2, v1 + 23096);
    v21 = *(float *)(v1 + 23092) * 0.75 + *(float *)(v1 + 23084);
    *(float *)(v1 + 25400) = v21;
    *(float *)(v1 + 23200) = v21 - 6.0;
  }
  sub_10042820(v1 + 33812, (int)"PSI", dword_1031FB44 + 4404, 245.0, 245.0, 215.0, 215.0);
  *(float *)(v1 + 34048) = 40.0;
  *(float *)(v1 + 34052) = -60.0;
  *(float *)(v1 + 34152) = -100.0;
  *(float *)(v1 + 33852) = *(float *)(v1 + 33836) * 0.6000000238418579 + *(float *)(v1 + 33828);
  *(float *)(v1 + 33860) = *(float *)(v1 + 33836) * 0.4000000059604645;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4404), v1 + 33812);
  *(float *)(v1 + 36168) = 18.0;
  v22 = *(float *)(v1 + 33820) * 0.6499999761581421;
  *(_DWORD *)(v1 + 39424) = 59;
  v23 = v22 + *(float *)(v1 + 33812);
  *(float *)(v1 + 36128) = v23;
  *(float *)(v1 + 36160) = 0.5;
  *(float *)(v1 + 33968) = 0.5;
  *(float *)(v1 + 33928) = v23;
  *(float *)(v1 + 36132) = *(float *)(v1 + 33824) * 0.75 + *(float *)(v1 + 33816);
  *(float *)(v1 + 33932) = *(float *)(v1 + 33824) * 0.6000000238418579 + *(float *)(v1 + 33816);
  sub_10060F20(v1 + 300, 1, v1 + 33828);
  sub_10042990(dword_1031FB44 + 20564, v1 + 33812);
  *(_WORD *)(v1 + 39386) = 15;
  v24 = *(float *)(v1 + 33848) - *(float *)(v1 + 33844);
  sub_10062160(v24, 0.0, -0.2, v1 + 33828);
  sub_10042820(v1 + 90524, (int)"L FUEL QTY", dword_1031FB44 + 4240, 27.0, 480.0, 180.0, 180.0);
  *(float *)(v1 + 90644) = *(float *)(v1 + 90644) + 15.0;
  *(_WORD *)(v1 + 96098) = 31;
  sub_100649E0(v1 + 90708, "GAL", 21);
  *(float *)(v1 + 90696) = *(float *)(v1 + 90696) + 30.0;
  sub_10060F20(v1 + 276, 0, v1 + 90540);
  v25 = *(float *)(v1 + 90560) - *(float *)(v1 + 90556);
  sub_10062160(v25, 18.927059, -0.2, v1 + 90540);
  sub_10061F10(37.854118, "%.0f", 1.0, 12.0, -0.2, v1 + 90540);
  sub_10060FA0(*(float *)(v1 + 90560), "F", 1.0, 12.0, -0.2, 5, v1 + 90540);
  sub_10042820(v1 + 96144, (int)"R FUEL QTY", dword_1031FB44 + 4240, 262.0, 480.0, 180.0, 180.0);
  *(_WORD *)(v1 + 101718) = 31;
  *(float *)(v1 + 96264) = *(float *)(v1 + 96264) + 15.0;
  sub_100649E0(v1 + 96328, "GAL", 21);
  *(float *)(v1 + 96316) = *(float *)(v1 + 96316) + 30.0;
  sub_10060F20(v1 + 288, 0, v1 + 96160);
  v26 = *(float *)(v1 + 96180) - *(float *)(v1 + 96176);
  sub_10062160(v26, 18.927059, -0.2, v1 + 96160);
  sub_10061F10(37.854118, "%.0f", 1.0, 12.0, -0.2, v1 + 96160);
  sub_10060FA0(*(float *)(v1 + 96180), "F", 1.0, 12.0, -0.2, 5, v1 + 96160);
  if ( *(_BYTE *)(v1 + 127985) )
    sub_10042310(v1 + 39432, (int)"CHT F", dword_1031FB44 + 5388, 856.0, 80.0, 151.0, 245.0, *(_BYTE *)(v1 + 127980));
  else
    sub_10042310(v1 + 39432, (int)"CHT F", dword_1031FB44 + 5388, 805.0, 80.0, 205.0, 245.0, *(_BYTE *)(v1 + 127980));
  sub_10041F10(dword_1031FB44 + 20732, v1 + 39432);
  sub_10047B10(v1 + 432, *(_BYTE *)(v1 + 127980), 1, v1 + 39448);
  *(_WORD *)(v1 + 40412) = 17;
  *(_BYTE *)(v1 + 40410) = -1;
  *(float *)(v1 + 39556) = 50.0;
  *(float *)(v1 + 39552) = *(float *)(v1 + 39432);
  *(float *)(v1 + 39592) = 0.5;
  *(float *)(v1 + 39596) = 1.0;
  sub_10041CA0(55.555557, 27.777779, 0.80000001, v1 + 39432);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 39432);
  sub_10042310(v1 + 54764, (int)"TIT F", dword_1031FB44 + 5060, 525.0, 80.0, 30.0, 245.0, 1);
  sub_10041F10(dword_1031FB44 + 20676, v1 + 54764);
  sub_10047B10(v1 + 348, 1, 1, v1 + 54780);
  *(_WORD *)(v1 + 55744) = 17;
  *(_BYTE *)(v1 + 55742) = -1;
  *(float *)(v1 + 54888) = 50.0;
  *(float *)(v1 + 54884) = 525.0;
  *(float *)(v1 + 54924) = 0.5;
  *(float *)(v1 + 54928) = 1.0;
  *(_BYTE *)(v1 + 54952) = 0;
  sub_10041CA0(55.555557, 27.777779, 0.80000001, v1 + 54764);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 54764);
  if ( *(_BYTE *)(v1 + 127985) )
    sub_10042310(v1 + 49968, (int)"EGT F", dword_1031FB44 + 5224, 635.0, 80.0, 151.0, 245.0, *(_BYTE *)(v1 + 127980));
  else
    sub_10042310(v1 + 49968, (int)"EGT F", dword_1031FB44 + 5224, 525.0, 80.0, 205.0, 245.0, *(_BYTE *)(v1 + 127980));
  sub_10041F10(dword_1031FB44 + 20704, v1 + 49968);
  sub_10047B10(v1 + 360, *(_BYTE *)(v1 + 127980), 1, v1 + 49984);
  *(_WORD *)(v1 + 50948) = 17;
  *(_BYTE *)(v1 + 50946) = -1;
  *(float *)(v1 + 50092) = *(float *)(v1 + 49972) - 30.0;
  *(float *)(v1 + 50088) = *(float *)(v1 + 49968);
  *(float *)(v1 + 50128) = 0.5;
  *(float *)(v1 + 50132) = 1.0;
  sub_10041CA0(55.555557, 27.777779, 0.80000001, v1 + 49968);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 49968);
  sub_10046920(v1 + 65392, (int)" PEAK", dword_1031FB44 + 6536, 495.0, 360.0, 100.0, 15.0);
  sub_100465F0(v1 + 564, 1, v1 + 65392);
  *(_WORD *)(v1 + 65908) = 10;
  sub_10046920(v1 + 88068, (int)"BAT1 AMPS", dword_1031FB44 + 5716, 840.0, 450.0, 170.0, 15.0);
  sub_100465F0(v1 + 504, 1, v1 + 88068);
  sub_10046630(dword_1031FB44 + 20788, v1 + 88068);
  *(_WORD *)(v1 + 88584) = 23;
  sub_10046920(v1 + 89300, (int)"VOLTS1", dword_1031FB44 + 5552, 840.0, 425.0, 170.0, 15.0);
  sub_100465F0(v1 + 516, 1, v1 + 89300);
  sub_10046630(dword_1031FB44 + 20760, v1 + 89300);
  *(_WORD *)(v1 + 89816) = 21;
  sub_10046920(v1 + 106256, (int)"GAL REM", dword_1031FB44 + 6864, 840.0, 515.0, 170.0, 15.0);
  *(_WORD *)(v1 + 106772) = 31;
  *(_DWORD *)(v1 + 106304) = v1 + 556;
  *(_WORD *)(v1 + 107480) = 4142;
  *(_DWORD *)(v1 + 107484) = -1;
  *(_DWORD *)(v1 + 107488) = 0;
  *(float *)(v1 + 107492) = 15.0;
  *(float *)(v1 + 107496) = 60.0;
  *(_DWORD *)(v1 + 107500) = sub_10065060(*(float *)(v1 + 107492));
  *(float *)(v1 + 107504) = 1.0;
  *(float *)(v1 + 107508) = 1.0;
  *(_DWORD *)(v1 + 107512) = 0x7FFFFFFF;
  *(float *)(v1 + 107516) = 1010.0;
  *(float *)(v1 + 107520) = 540.0;
  sub_10046920(v1 + 107604, (int)"RANGE NM", dword_1031FB44 + 6700, 840.0, 565.0, 170.0, 15.0);
  sub_100465F0(v1 + 576, 1, v1 + 107604);
  *(_WORD *)(v1 + 108120) = 38;
  sub_1004A1A0(v1 + 109452, (int)"RUDDER TRIM", dword_1031FB44 + 5880, 480.0, 626.0, 240.0, 30.0, 0);
  v27 = *(float *)(v1 + 109476) - *(float *)(v1 + 109472);
  sub_1004A660(v27, 0.0, -0.80000001, v1 + 109452);
  v28 = *(float *)(v1 + 109476) - *(float *)(v1 + 109472);
  sub_100488B0(v28, "%.0f", 1.0, 12.0, v1 + 109452);
  sub_10049090(0, v1 + 109452);
  *(float *)(v1 + 109912) = 20.0;
  sub_100649E0(v1 + 110324, "L", 2);
  sub_100649E0(v1 + 110388, "R", 2);
  v29 = *(float *)(v1 + 113648) - *(float *)(v1 + 113656);
  *(float *)(v1 + 110312) = v29;
  *(float *)(v1 + 110376) = v29;
  *(float *)(v1 + 110336) = 1.0;
  *(float *)(v1 + 110400) = 1.0;
  sub_10049040(v1 + 528, 1, 0, v1 + 109452);
  *(_WORD *)(v1 + 113764) = 2;
  sub_10047070(v1 + 127420, (int)"FLAPS", dword_1031FB44 + 6208, 560.0, 470.0, 80.0, 40.0, COERCE_FLOAT(1));
  sub_1004A1A0(v1 + 118436, (int)"TRIM", dword_1031FB44 + 6044, 750.0, 426.0, 30.0, 230.0, 1);
  v30 = sub_10048890(v1 + 118436);
  sub_10065690(*(float *)(v1 + 118456), -0.80000001, 1.0, v1 + 119272, v30, v1 + 122628);
  v31 = sub_10048890(v1 + 118436);
  sub_10065690(*(float *)(v1 + 118460), -0.80000001, 1.0, v1 + 119272, v31, v1 + 122628);
  sub_10064F60(*(float *)(v1 + 118460), "DN", 0.0, 9.0, *(_WORD *)(v1 + 122748), v1 + 119272, 0);
  sub_10064F60(*(float *)(v1 + 118456), "UP", 0.0, 9.0, *(_WORD *)(v1 + 122748), v1 + 119272, 1);
  sub_100649E0(v1 + 118568, "ELEV", 5);
  *(float *)(v1 + 118504) = *(float *)(v1 + 118504) - 5.0;
  *(float *)(v1 + 118556) = *(float *)(v1 + 118556) - 5.0;
  sub_10049040(v1 + 540, 1, 0, v1 + 118436);
  sub_10049090(0, v1 + 118436);
  *(float *)(v1 + 118900) = 20.0;
  *(_WORD *)(v1 + 122748) = 3;
  sub_10046920(v1 + 108224, (int)byte_100B8180, dword_1031FB44 + 6372, 925.0, 630.0, 0.0, 15.0);
  result = v1 + 109448;
  *(_DWORD *)(v1 + 108272) = v1 + 109448;
  *(float *)(v1 + 108284) = 0.5;
  *(_WORD *)(v1 + 108740) = 12;
  return result;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10024E60) --------------------------------------------------------
void __usercall sub_10024E60(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@2
  float v3; // ST40_4@4
  float v4; // ST40_4@4
  float v5; // ST44_4@4
  double v6; // st7@4
  double v7; // st7@4
  bool v8; // zf@6
  float v9; // ST44_4@6
  int v10; // ST34_4@9
  double v11; // st7@9
  double v12; // st7@9
  float v13; // ST44_4@11
  float v14; // [sp+20h] [bp-4h]@2
  float v15; // [sp+20h] [bp-4h]@4
  float v16; // [sp+20h] [bp-4h]@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 127985) )
  {
    v14 = 45.0;
    v2 = 15.0;
  }
  else
  {
    v2 = 0.0;
    v14 = 0.0;
  }
  v3 = v2;
  v4 = 125.0 - v3;
  v5 = v14 + 349.0;
  sub_100483D0(v1 + 59560, (int)"EGT F", dword_1031FB44 + 5224, 10.0, v5, 130.0, v4, *(_BYTE *)(v1 + 127980));
  sub_10047B60(dword_1031FB44 + 20704, v1 + 59560);
  sub_10047B10(v1 + 360, *(_BYTE *)(v1 + 127980), 1, v1 + 59560);
  v6 = *(float *)(v1 + 60228);
  *(_WORD *)(v1 + 60524) = 17;
  v15 = v6;
  v7 = 140.0;
  if ( v15 > 140.0 )
    v7 = v15;
  v8 = *(_BYTE *)(v1 + 127985) == 0;
  v9 = v7;
  *(float *)(v1 + 60228) = v9;
  if ( v8 )
    *(_BYTE *)(v1 + 59660) = 16;
  else
    *(_BYTE *)(v1 + 59660) = 12;
  *(float *)(v1 + 60536) = (*(float *)(v1 + 59584) - *(float *)(v1 + 59580)) / (double)*(_BYTE *)(v1 + 59660);
  sub_10046920(v1 + 66004, (int)" PEAK", dword_1031FB44 + 6536, 10.0, 529.0, 130.0, 15.0);
  sub_100465F0(v1 + 564, 1, v1 + 66004);
  v10 = *(_BYTE *)(v1 + 127980);
  *(_WORD *)(v1 + 66520) = 10;
  *(_DWORD *)(v1 + 66524) = &word_100B8D60;
  sub_100483D0(v1 + 48720, (int)"CHT F", dword_1031FB44 + 5388, 10.0, 542.0, 130.0, 110.0, v10);
  sub_10047B60(dword_1031FB44 + 20732, v1 + 48720);
  sub_10047B10(v1 + 432, *(_BYTE *)(v1 + 127980), 1, v1 + 48720);
  v11 = *(float *)(v1 + 49388);
  *(_WORD *)(v1 + 49684) = 17;
  v16 = v11;
  v12 = 140.0;
  if ( v16 > 140.0 )
    v12 = v16;
  v13 = v12;
  *(_BYTE *)(v1 + 48820) = 12;
  *(float *)(v1 + 49388) = v13;
  *(float *)(v1 + 49696) = (*(float *)(v1 + 48744) - *(float *)(v1 + 48740)) / 12.0;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100250E0) --------------------------------------------------------
int __usercall sub_100250E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float v2; // ST54_4@1
  float v3; // ST54_4@1
  float v4; // ST54_4@1
  float v5; // ST54_4@1
  float v6; // ST54_4@1
  float v7; // ST54_4@1
  float v8; // ST54_4@1
  float v9; // ST54_4@1
  int v10; // eax@1
  int v11; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10042820(v1 + 6220, (int)"MAN IN", dword_1031FB44 + 3912, -1.0, -8.0, 150.0, 150.0);
  sub_10042990(dword_1031FB44 + 20480, v1 + 6220);
  *(_WORD *)(v1 + 11794) = 5;
  *(_BYTE *)(v1 + 11837) = 1;
  sub_10060F20(v1 + 252, 1, v1 + 6236);
  v2 = *(float *)(v1 + 6256) - *(float *)(v1 + 6252);
  sub_10062160(v2, 0.0, -0.2, v1 + 6236);
  v3 = *(float *)(v1 + 6256) - *(float *)(v1 + 6252);
  sub_10061F10(v3, "%.0f", 1.0, 9.0, -0.2, v1 + 6236);
  *(float *)(v1 + 6340) = *(float *)(v1 + 6340) - 15.0;
  *(float *)(v1 + 8540) = *(float *)(v1 + 8540) - 15.0;
  *(float *)(v1 + 8612) = *(float *)(v1 + 8592);
  *(float *)(v1 + 8616) = *(float *)(v1 + 8600) + 8.0;
  *(float *)(v1 + 8676) = *(float *)(v1 + 8656);
  *(float *)(v1 + 8680) = *(float *)(v1 + 8664) + 8.0;
  sub_10060F50(-1.0, 2.0, 150.0, 110.0, v1 + 6236);
  sub_10042820(v1 + 17460, (int)"RPM", dword_1031FB44 + 4076, -1.0, 116.0, 150.0, 150.0);
  sub_10042990(dword_1031FB44 + 20508, v1 + 17460);
  *(_WORD *)(v1 + 23034) = 6;
  *(_BYTE *)(v1 + 23077) = 1;
  v4 = *(float *)(v1 + 17496) - *(float *)(v1 + 17492);
  sub_10062160(v4, 0.0, -0.2, v1 + 17476);
  v5 = *(float *)(v1 + 17496) - *(float *)(v1 + 17492);
  sub_10061F10(v5, "%.0f", 1.0, 9.0, -0.2, v1 + 17476);
  sub_10061FA0(2200.0, -0.2, 2, v1 + 17476);
  sub_10060FA0(2200.0, "%.0f", 1.0, 9.0, -0.2, 2, v1 + 17476);
  ++*(_BYTE *)(v1 + 23032);
  sub_10060F20(v1 + 264, 1, v1 + 17476);
  *(float *)(v1 + 17580) = *(float *)(v1 + 17580) - 15.0;
  *(float *)(v1 + 19780) = *(float *)(v1 + 19780) - 15.0;
  *(float *)(v1 + 19852) = *(float *)(v1 + 19832);
  *(float *)(v1 + 19856) = *(float *)(v1 + 19840) + 8.0;
  *(float *)(v1 + 19916) = *(float *)(v1 + 19896) - 6.0;
  *(float *)(v1 + 19920) = *(float *)(v1 + 19904) + 8.0;
  sub_10060F50(-1.0, 126.0, 150.0, 110.0, v1 + 17476);
  sub_1004A1E0(v1 + 101764, (int)"FUEL QTY GAL", dword_1031FB44 + 4240, 10.0, 266.0, 130.0, 37.0, 0);
  *(_WORD *)(v1 + 106076) = 31;
  sub_10049040(v1 + 276, 2, 0, v1 + 101764);
  sub_10049090(0, v1 + 101764);
  v6 = *(float *)(v1 + 101788) - *(float *)(v1 + 101784);
  sub_1004A630(v6, 18.927059, -0.40000001, v1 + 101764);
  sub_100488B0(37.854118, "%.0f", 1.0, 9.0, v1 + 101764);
  sub_10064F60(
    *(float *)(v1 + 101788),
    "F",
    1.0,
    9.0,
    *(_WORD *)(v1 + 106076),
    v1 + 102600,
    ((unsigned int)*(_BYTE *)(v1 + 105800) >> 1) - 1);
  *(float *)(((unsigned int)*(_BYTE *)(v1 + 105800) >> 1 << 6) + v1 + 102560) = *(float *)(v1 + 102624);
  sub_10046920(v1 + 89912, (int)"VOLTS1", dword_1031FB44 + 5552, 10.0, 609.0, 130.0, 15.0);
  sub_100465F0(v1 + 516, 1, v1 + 89912);
  sub_10046630(dword_1031FB44 + 20760, v1 + 89912);
  *(_WORD *)(v1 + 90428) = 21;
  sub_10046920(v1 + 88680, (int)"BAT1 AMPS", dword_1031FB44 + 5716, 10.0, 632.0, 130.0, 15.0);
  sub_100465F0(v1 + 504, 1, v1 + 88680);
  sub_10046630(dword_1031FB44 + 20788, v1 + 88680);
  *(_WORD *)(v1 + 89196) = 23;
  sub_1004A1A0(v1 + 113944, (int)"RUDDER TRIM", dword_1031FB44 + 5880, 10.0, 662.0, 130.0, 18.0, 0);
  v7 = *(float *)(v1 + 113968) - *(float *)(v1 + 113964);
  sub_1004A660(v7, 0.0, -0.80000001, v1 + 113944);
  v8 = *(float *)(v1 + 113968) - *(float *)(v1 + 113964);
  sub_100488B0(v8, "%.0f", 1.0, 9.0, v1 + 113944);
  sub_100649E0(v1 + 114816, "L", 2);
  sub_100649E0(v1 + 114880, "R", 2);
  v9 = *(float *)(v1 + 118140) - *(float *)(v1 + 118148);
  *(float *)(v1 + 114804) = v9;
  *(float *)(v1 + 114868) = v9;
  *(float *)(v1 + 114828) = 1.0;
  *(float *)(v1 + 114892) = 1.0;
  sub_10049040(v1 + 528, 1, 0, v1 + 113944);
  sub_10049090(0, v1 + 113944);
  *(_WORD *)(v1 + 118256) = 2;
  sub_10047070(v1 + 127700, (int)"FLAPS", dword_1031FB44 + 6208, 156.0, 490.0, 45.0, 25.0, COERCE_FLOAT(1));
  *(_BYTE *)(v1 + 127749) = 0;
  sub_1004A1A0(v1 + 122928, (int)"TRIM", dword_1031FB44 + 6044, 165.0, 559.0, 15.0, 120.0, 1);
  v10 = sub_10048890(v1 + 122928);
  sub_10065690(*(float *)(v1 + 122948), -0.80000001, 1.0, v1 + 123764, v10, v1 + 127120);
  v11 = sub_10048890(v1 + 122928);
  sub_10065690(*(float *)(v1 + 122952), -0.80000001, 1.0, v1 + 123764, v11, v1 + 127120);
  sub_10064F60(*(float *)(v1 + 122952), "DN", 0.0, 9.0, *(_WORD *)(v1 + 127240), v1 + 123764, 0);
  sub_10064F60(*(float *)(v1 + 122948), "UP", 0.0, 9.0, *(_WORD *)(v1 + 127240), v1 + 123764, 1);
  sub_100649E0(v1 + 123060, "ELEV", 5);
  *(float *)(v1 + 122992) = *(float *)(v1 + 122992) + 5.0;
  *(float *)(v1 + 123044) = *(float *)(v1 + 123044) + 5.0;
  *(float *)(v1 + 122996) = *(float *)(v1 + 122996) - 3.0;
  *(float *)(v1 + 123048) = *(float *)(v1 + 123048) - 3.0;
  sub_10049040(v1 + 540, 1, 0, v1 + 122928);
  result = sub_10049090(0, v1 + 122928);
  *(_WORD *)(v1 + 127240) = 3;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10025980) --------------------------------------------------------
int __usercall sub_10025980@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1
  bool v3; // zf@1
  float v4; // ST40_4@2
  float v5; // ST40_4@2
  float v6; // ST40_4@2
  float v7; // ST40_4@2
  float v8; // ST40_4@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10046920(v1 + 76732, (int)"OIL F", dword_1031FB44 + 4896, 10.0, 376.0, 130.0, 15.0);
  sub_100465F0(v1 + 336, 1, v1 + 76732);
  sub_10046630(dword_1031FB44 + 20648, v1 + 76732);
  *(_WORD *)(v1 + 77248) = 17;
  sub_10046920(v1 + 87456, (int)"OIL PSI", dword_1031FB44 + 4732, 10.0, 346.0, 130.0, 15.0);
  sub_100465F0(v1 + 324, 1, v1 + 87456);
  sub_10046630(dword_1031FB44 + 20620, v1 + 87456);
  *(_WORD *)(v1 + 87972) = 15;
  sub_10046920(v1 + 33192, (int)"FFLOW GPH", dword_1031FB44 + 4568, 10.0, 476.0, 130.0, 15.0);
  sub_100465F0(v1 + 312, 1, v1 + 33192);
  sub_10046630(dword_1031FB44 + 20592, v1 + 33192);
  *(_WORD *)(v1 + 33708) = 33;
  sub_10046920(v1 + 106868, (int)"GAL REM", dword_1031FB44 + 6864, 10.0, 506.0, 130.0, 15.0);
  *(_DWORD *)(v1 + 106916) = v1 + 556;
  *(_WORD *)(v1 + 107384) = 31;
  result = sub_10046920(v1 + 108836, (int)"ENG", dword_1031FB44 + 6372, 10.0, 406.0, 130.0, 15.0);
  v3 = *(_BYTE *)(v1 + 127984) == 0;
  *(_DWORD *)(v1 + 108884) = v1 + 109448;
  *(_WORD *)(v1 + 109352) = 12;
  *(_DWORD *)(v1 + 109356) = " HRS";
  if ( !v3 )
  {
    v4 = *(float *)(v1 + 76736) + 50.0;
    sub_10046480(*(float *)(v1 + 76732), v4, v1 + 76732);
    v5 = *(float *)(v1 + 87460) + 50.0;
    sub_10046480(*(float *)(v1 + 87456), v5, v1 + 87456);
    v6 = *(float *)(v1 + 108840) + 50.0;
    sub_10046480(*(float *)(v1 + 108836), v6, v1 + 108836);
    v7 = *(float *)(v1 + 33196) + 50.0;
    sub_10046480(*(float *)(v1 + 33192), v7, v1 + 33192);
    v8 = *(float *)(v1 + 106872) + 50.0;
    result = sub_10046480(*(float *)(v1 + 106868), v8, v1 + 106868);
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10025CE0) --------------------------------------------------------
char __usercall sub_10025CE0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  unsigned __int8 v2; // al@1
  int v3; // eax@1
  double v4; // st7@3
  float v5; // ST08_4@4
  double v6; // st7@7
  float v7; // ST08_4@9
  int v9; // [sp+8h] [bp-8h]@3
  int v10; // [sp+8h] [bp-8h]@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 66616) = 0;
  *(_BYTE *)(v1 + 190) = 0;
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 127983) = v2;
  v3 = v2 - 1;
  if ( !v3 )
  {
    sub_10048A00(10.0, 371.0, v1 + 60808);
    v6 = 341.0;
    v10 = v1 + 33192;
    goto LABEL_9;
  }
  if ( v3 == 1 )
  {
    if ( *(_BYTE *)(v1 + 127984) )
    {
      sub_10046480(10.0, 526.0, v1 + 33192);
      v4 = 586.0;
      v9 = v1 + 60808;
      goto LABEL_4;
    }
    sub_10048A00(10.0, 536.0, v1 + 60808);
    v6 = 476.0;
    v10 = v1 + 33192;
LABEL_9:
    v7 = v6;
    sub_10046480(10.0, v7, v10);
    goto LABEL_10;
  }
  v4 = 497.0;
  v9 = v1 + 60808;
LABEL_4:
  v5 = v4;
  sub_10048A00(10.0, v5, v9);
LABEL_10:
  sub_1004C170(*(_BYTE *)(v1 + 127983));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10025E20) --------------------------------------------------------
void __usercall sub_10025E20(char a1@<bl>, int a2@<esi>)
{
  int v2; // edi@1
  double v3; // st7@17
  float v4; // [sp+14h] [bp-40h]@16
  float v5; // [sp+1Ch] [bp-38h]@1
  float v6; // [sp+20h] [bp-34h]@1
  int v7; // [sp+24h] [bp-30h]@1
  int v8; // [sp+28h] [bp-2Ch]@1
  char v9; // [sp+2Ch] [bp-28h]@5
  float v10; // [sp+44h] [bp-10h]@1
  float v11; // [sp+48h] [bp-Ch]@1
  float v12; // [sp+4Ch] [bp-8h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v5 = 75.0;
  v7 = -16777216;
  v6 = 0.0;
  v8 = -1;
  v10 = 0.5;
  v11 = 0.5;
  v12 = 12.0;
  if ( *(_BYTE *)(v2 + 127982) )
  {
    if ( a1 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C18DC, (int)&unk_100C1E44, 0, 255);
      sub_1006BEE0((int)"TEMPERATURE", 480.0, 20.0, 540.0, 350.0);
      sub_1006BEE0((int)"ELECTRICAL", 830.0, 395.0, 190.0, 65.0);
      sub_1006BEE0((int)"FUEL CALC", 830.0, 485.0, 190.0, 90.0);
      sub_1006BEE0((int)"ENGINE HOURS", 830.0, 600.0, 190.0, 40.0);
    }
    sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1CF8, v2, v2 + 88, 255);
    v7 = 0;
    if ( *(_BYTE *)(v2 + 127984) )
    {
      v5 = 352.5;
      v6 = 277.25;
      sub_100649E0((int)&v9, "FUEL", 5);
      sub_1006BEC0(a2, (int)&v5);
    }
    v5 = 117.5;
    v6 = 277.25;
    sub_100649E0((int)&v9, "OIL", 4);
    sub_1006BEC0(a2, (int)&v5);
  }
  else
  {
    if ( a1 )
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C19E0, (int)&unk_100C1E4C, 0, 255);
    sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C19B4, v2 + 112, v2 + 132, 255);
    if ( *(_BYTE *)(v2 + 127983) == 1 )
    {
      if ( a1 )
        sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1CA0, (int)&unk_100C1E78, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1C74, v2 + 168, v2 + 188, 255);
    }
    else if ( *(_BYTE *)(v2 + 127983) == 2 )
    {
      if ( a1 )
        sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1BC8, (int)&unk_100C1E6C, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1E08, v2 + 196, v2 + 224, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1DC8, v2 + 232, v2 + 248, 255);
      v4 = 1.0;
      if ( *(_BYTE *)(v2 + 127984) )
      {
        sub_100682A0(10.0, 491.0, 140.0, 491.0, -1, v4);
        v3 = 491.0;
      }
      else
      {
        sub_100682A0(10.0, 441.0, 140.0, 441.0, -1, v4);
        v3 = 441.0;
      }
      v6 = v3;
      sub_100649E0((int)&v9, "FUEL CALC", 10);
      sub_1006BEC0(a2, (int)&v5);
    }
    else
    {
      if ( a1 )
        sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1AF0, (int)&unk_100C1E60, 0, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1B9C, v2 + 140, v2 + 160, 255);
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C1DC8, v2 + 232, v2 + 248, 255);
    }
  }
}

//----- (10026250) --------------------------------------------------------
char __usercall sub_10026250@<al>(int a1@<eax>)
{
  int v1; // esi@1
  signed int v2; // ecx@1
  int v3; // eax@2
  char *v4; // edi@4
  char result; // al@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  if ( *(_BYTE *)(v1 + 127980) )
  {
    v3 = v1 + 54856;
    do
    {
      *(_DWORD *)(v3 - 4796) = 0;
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4780) = 0;
      ++v2;
      v3 += 4;
    }
    while ( v2 < *(_BYTE *)(v1 + 127980) );
  }
  v4 = (char *)(v1 + 65300);
  result = sub_1004CCA0(v1 + 65300, 1);
  if ( *(_BYTE *)(v1 + 127985) )
  {
    *v4 = 1;
  }
  else
  {
    result = *(_BYTE *)(v1 + 127980);
    *v4 = result;
  }
  return result;
}

//----- (100262C0) --------------------------------------------------------
char __usercall sub_100262C0@<al>(int a1@<eax>)
{
  int v1; // ebp@1
  char result; // al@1
  bool v3; // zf@3
  signed int v4; // edi@4
  int v5; // esi@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10026250(a1);
  result = 2;
  if ( *(_BYTE *)(v1 + 66616) == 2 )
  {
    v3 = *(_BYTE *)(v1 + 127980) == 0;
    *(_BYTE *)(v1 + 66616) = 0;
    *(_BYTE *)(v1 + 99) = 0;
    *(_BYTE *)(v1 + 190) = 0;
    if ( !v3 )
    {
      v4 = 1;
      v5 = v1 + 50188;
      do
      {
        sprintf((char *)(v5 - 32), "%d", v4);
        *(float *)v5 = 9.0;
        result = sprintf((char *)(v5 + 9544), "%d", v4);
        *(float *)(v5 + 9576) = 9.0;
        ++v4;
        v5 += 52;
      }
      while ( v4 - 1 < *(_BYTE *)(v1 + 127980) );
    }
    *(_BYTE *)(v1 + 54952) = 0;
    *(_BYTE *)(v1 + 55742) = -1;
  }
  else
  {
    *(_BYTE *)(v1 + 66616) = 2;
    result = 3;
    *(_BYTE *)(v1 + 99) = 3;
    *(_BYTE *)(v1 + 190) = 3;
  }
  return result;
}

//----- (10026370) --------------------------------------------------------
int __usercall sub_10026370@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@4
  char v3; // al@5
  double v4; // st7@5
  float v5; // ST24_4@6
  double v6; // st7@6
  float v7; // ST24_4@8
  double v8; // st7@8
  unsigned __int8 v9; // al@10
  float v10; // ST24_4@10
  char v11; // al@10
  unsigned __int8 v12; // ST18_1@11

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( !*(_BYTE *)(v1 + 66616) )
  {
    v12 = *(_BYTE *)(v1 + 127980);
    *(_BYTE *)(v1 + 50946) = -1;
    *(_BYTE *)(v1 + 60522) = sub_10066EE0(v1 + 252, 9u, v12);
    v11 = sub_10066EE0(v1 + 252, 0xFu, *(_BYTE *)(v1 + 127980));
LABEL_12:
    *(_BYTE *)(v1 + 49682) = v11;
    goto LABEL_13;
  }
  if ( *(_BYTE *)(v1 + 66616) == 2 )
  {
    if ( *(_BYTE *)(v1 + 127985) )
    {
      sub_10047850(v1 + 65300, v1 + 54780);
      v3 = sub_10066EE0(v1 + 252, 9u, *(_BYTE *)(v1 + 127980));
      v4 = *(float *)(v1 + 352);
      *(_BYTE *)(v1 + 60522) = v3;
      v2 = v4 - *(float *)(v1 + 65344);
    }
    else
    {
      sub_10047850(v1 + 65300, v1 + 49984);
      sub_10047850(v1 + 65300, v1 + 59560);
      v2 = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 65334) + 364) - *(float *)(v1 + 4 * *(_BYTE *)(v1 + 65334) + 65344);
    }
    v5 = v2;
    v6 = v5;
    if ( v5 > 0.0 )
      v6 = 0.0;
    v7 = v6;
    v8 = v7;
    *(float *)(v1 + 568) = v7;
    if ( v7 <= -500.0 )
      v8 = -500.0;
    v9 = *(_BYTE *)(v1 + 127980);
    v10 = v8;
    *(float *)(v1 + 568) = v10 * 1.799999952316284;
    v11 = sub_10066EE0(v1 + 252, 0xFu, v9);
    goto LABEL_12;
  }
LABEL_13:
  sub_10049040(v1 + 12 * (*(_BYTE *)(v1 + 49682) + 36), 1, 1, v1 + 44228);
  return sprintf((char *)(v1 + 44712), "%d", *(_BYTE *)(v1 + 49682) + 1);
}

//----- (10026500) --------------------------------------------------------
void __usercall sub_10026500(float a1@<esi>, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  float *v4; // eax@1
  signed int v5; // ecx@1
  unsigned int v6; // esi@3
  double v7; // st7@4
  int v8; // eax@4
  int v9; // edx@11
  int v10; // ecx@11
  int v11; // eax@11
  double v12; // st7@13
  int v13; // ST2C_4@13
  int v14; // esi@13
  double v15; // st7@14
  float v16; // ST28_4@15
  double v17; // st7@23
  int v18; // [sp-20h] [bp-44h]@27
  const char *v19; // [sp-1Ch] [bp-40h]@27
  float v20; // [sp+Ch] [bp-18h]@3
  float v21; // [sp+18h] [bp-Ch]@7
  int v22; // [sp+1Ch] [bp-8h]@5
  float v23; // [sp+20h] [bp-4h]@13

  v2 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v4 = (float *)(v3 + 256);
  v5 = 29;
  do
  {
    *v4 = 9.8999998e24;
    v4 += 3;
    --v5;
  }
  while ( v5 );
  v20 = a1;
  v6 = 0;
  do
  {
    v7 = sub_1004C3E0(word_100C18F2[v6]);
    v8 = (unsigned __int8)byte_100C18F0[v6 * 2];
    v6 += 2;
    *(float *)(v3 + 12 * v8 + 256) = v7;
  }
  while ( v6 < 40 );
  if ( sub_10031F70(100.0, *(float *)(v3 + 508), (int)&v22) )
  {
    sub_100666C0(v3 + 89292, v22);
    *(float *)(v3 + 508) = (double)*(signed int *)(v3 + 89296) / 100.0;
  }
  if ( sub_100664A0(&v21) )
    *(float *)(v3 + 280) = v21;
  if ( sub_10066510(&v21) )
    *(float *)(v3 + 292) = v21;
  *(float *)(v3 + 556) = sub_1004C0C0();
  *(float *)(v3 + 592) = sub_1004C0D0(v10, v9);
  v11 = sub_1004BF40();
  *(_DWORD *)(v3 + 107512) = v11;
  if ( v11 != 0x7FFFFFFF )
    *(_DWORD *)(v3 + 107512) = sub_100296D0(v3 + 107524, 0x14u, v11);
  v23 = sub_1004BFF0(v20);
  v12 = v23;
  v14 = v13;
  *(float *)(v3 + 580) = v23;
  if ( 9.8999998e24 == v12 )
  {
    v15 = -1.0;
  }
  else
  {
    v16 = v12;
    if ( !sub_10031F70(100.0, v16, (int)&v22) )
      goto LABEL_18;
    sub_100666C0(v3 + 108216, v22);
    v15 = (double)*(signed int *)(v3 + 108220) / 100.0;
  }
  *(float *)(v3 + 580) = v15;
LABEL_18:
  *(float *)(v3 + 109448) = sub_1004C070();
  if ( sub_10066930(v14, 0x67u, &v21) )
    *(float *)(v3 + 532) = v21;
  if ( sub_10066930(v14, 0x68u, &v21) )
    *(float *)(v3 + 544) = v21;
  if ( sub_10066930(v14, 0x69u, &v21) )
  {
    *(float *)(v3 + 127464) = v21;
    v17 = v21;
  }
  else
  {
    v17 = 9.8999998e24;
    *(float *)(v3 + 127464) = 9.8999998e24;
  }
  *(float *)(v3 + 127744) = v17;
  if ( sub_10067000(0x61u, &a2) && (_BYTE)a2 )
  {
    sub_100649E0(v3 + 88872, "BAT1 AMPS", 21);
    sub_100649E0(v3 + 88260, "BAT1 AMPS", 21);
    sub_100649E0(v3 + 90104, "VOLTS1", 21);
    v19 = "VOLTS1";
    v18 = v3 + 89492;
  }
  else
  {
    sub_100649E0(v3 + 88872, "BAT2 AMPS", 21);
    sub_100649E0(v3 + 88260, "BAT2 AMPS", 21);
    sub_100649E0(v3 + 90104, "VOLTS2", 21);
    v19 = "VOLTS2";
    v18 = v3 + 89492;
  }
  sub_100649E0(v18, v19, 21);
  if ( sub_100663D0(&v21) )
    *(float *)(v3 + 316) = v21;
  sub_10026370(v2);
  if ( sub_10031F70(100000.0, *(float *)(v3 + 316), (int)&v22) )
  {
    sub_100666C0(v3 + 33804, v22);
    *(float *)(v3 + 316) = (double)*(signed int *)(v3 + 33808) / 100000.0;
  }
  sub_1004C380(v3 + 252, 0x1Du);
}
// 10026500: could not find valid save-restore pair for esi
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100C18F2: using guessed type __int16 word_100C18F2[];

//----- (10026850) --------------------------------------------------------
char __usercall sub_10026850@<al>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@1
  float *v3; // ecx@1
  int v4; // eax@1
  double v5; // st6@2
  int v6; // ebp@3
  _DWORD *v7; // edi@4
  int v8; // ecx@6
  int v9; // eax@6
  signed int v10; // edi@6
  char v11; // bl@7
  int v12; // ecx@8
  int v13; // eax@8
  signed int v14; // edi@8
  char v15; // bl@9
  bool v16; // zf@10
  char result; // al@10

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = (float *)"QC";
  v4 = v2 + 256;
  do
  {
    v5 = *v3;
    ++v3;
    *(float *)(v4 - 4) = v5;
    v4 += 12;
    *(float *)(v4 - 12) = 1.0;
    *(float *)(v4 - 8) = 1.0;
  }
  while ( (signed int)v3 < (signed int)&unk_100C19B4 );
  *(_BYTE *)(v2 + 127980) = *(_BYTE *)(dword_1031FB44 + 25);
  sub_100238E0(v1);
  sub_100250E0(v1);
  sub_10023410(v1);
  sub_10024E60(v1);
  sub_10025980(v1);
  v6 = 0;
  if ( sub_100233F0() > 0 )
  {
    v7 = (_DWORD *)(v2 + 127996);
    do
    {
      *((_BYTE *)v7 - 8) = 1;
      *v7 = 0;
      sub_1006E420((int)(v7 + 1));
      ++v6;
      v7 += 11;
    }
    while ( v6 < sub_100233F0() );
  }
  *(_DWORD *)(v2 + 127996) = v2 + 19440;
  *(_BYTE *)(v2 + 127989) = *(_BYTE *)(dword_1031FB44 + 4076);
  *(_BYTE *)(v2 + 128028) = 14;
  *(_DWORD *)(v2 + 127992) = v2 + 272;
  *(_DWORD *)(v2 + 128040) = v2 + 83336;
  *(_BYTE *)(v2 + 128033) = *(_BYTE *)(dword_1031FB44 + 4732);
  *(_DWORD *)(v2 + 128036) = v2 + 332;
  *(_DWORD *)(v2 + 128084) = v2 + 72612;
  *(_BYTE *)(v2 + 128072) = 14;
  *(_BYTE *)(v2 + 128077) = *(_BYTE *)(dword_1031FB44 + 4896);
  *(_DWORD *)(v2 + 128080) = v2 + 344;
  *(_BYTE *)(v2 + 128116) = 14;
  v8 = v2 + 440;
  v9 = v2 + 128121;
  v10 = 6;
  do
  {
    *(_DWORD *)(v9 + 7) = v2 + 44600;
    v11 = *(_BYTE *)(dword_1031FB44 + 5388);
    *(_DWORD *)(v9 + 3) = v8;
    *(_BYTE *)v9 = v11;
    *(_BYTE *)(v9 + 39) = 14;
    v8 += 12;
    v9 += 44;
    --v10;
  }
  while ( v10 );
  v12 = v2 + 284;
  v13 = v2 + 128385;
  v14 = 2;
  do
  {
    *(_DWORD *)(v13 + 7) = v2 + 102136;
    v15 = *(_BYTE *)(dword_1031FB44 + 4240);
    *(_DWORD *)(v13 + 3) = v12;
    *(_BYTE *)v13 = v15;
    *(_BYTE *)(v13 + 39) = 11;
    v12 += 12;
    v13 += 44;
    --v14;
  }
  while ( v14 );
  v16 = *(_BYTE *)(v2 + 127985) == 0;
  *(_DWORD *)(v2 + 128480) = v2 + 90348;
  *(_BYTE *)(v2 + 128473) = *(_BYTE *)(dword_1031FB44 + 5552);
  *(_DWORD *)(v2 + 128476) = v2 + 524;
  *(_BYTE *)(v2 + 128512) = 14;
  *(_DWORD *)(v2 + 128524) = v2 + 89116;
  result = *(_BYTE *)(dword_1031FB44 + 5716);
  *(_BYTE *)(v2 + 128517) = result;
  *(_BYTE *)(v2 + 128556) = 14;
  *(_DWORD *)(v2 + 128520) = v2 + 512;
  if ( !v16 )
  {
    *(_DWORD *)(v2 + 128568) = v2 + 61180;
    result = *(_BYTE *)(dword_1031FB44 + 5060);
    *(_BYTE *)(v2 + 128561) = result;
    *(_BYTE *)(v2 + 128600) = 14;
    *(_DWORD *)(v2 + 128564) = v2 + 356;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10026AB0) --------------------------------------------------------
void __usercall sub_10026AB0(int a1@<eax>)
{
  int v1; // esi@1

  v1 = a1;
  sub_10025E20(0, a1);
  *(_BYTE *)(v1 + 6) = 2;
}

//----- (10026AD0) --------------------------------------------------------
char __usercall sub_10026AD0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // zf@1
  signed int v3; // eax@4
  _BYTE *v4; // ebx@6
  void *v5; // ecx@22
  char result; // al@22
  float v7; // [sp+Ch] [bp-20h]@0
  float v8; // [sp+18h] [bp-14h]@18
  int v9; // [sp+1Ch] [bp-10h]@18
  int v10; // [sp+20h] [bp-Ch]@13
  _DWORD *v11; // [sp+24h] [bp-8h]@13
  int v12; // [sp+28h] [bp-4h]@15

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 128604, 0);
  *(_BYTE *)(v1 + 127981) = 0;
  *(_BYTE *)(v1 + 127982) = *(_DWORD *)(a1 + 64) == 9;
  *(_BYTE *)(v1 + 127985) = *(_BYTE *)dword_1031FB44 != 16;
  v2 = *(_BYTE *)(v1 + 127982) == 0;
  *(_BYTE *)(v1 + 127984) = *(_BYTE *)dword_1031FB44 == 15;
  if ( v2 )
  {
    sub_100011B0(a1, 0, 0, 210, 686, 3);
  }
  else
  {
    sub_100522C0(1);
    sub_100011B0(a1, 0, 0, 1024, 686, 3);
    sub_10032790(a1, &unk_100C1840, 4u, 3, 1u);
  }
  v3 = sub_1004BF40();
  if ( v3 == 0x7FFFFFFF )
    v3 = 0;
  *(_DWORD *)(v1 + 107524) = v3;
  *(_DWORD *)(v1 + 107528) = v3;
  *(_DWORD *)(v1 + 107532) = v3;
  *(_DWORD *)(v1 + 107536) = v3;
  *(_DWORD *)(v1 + 107540) = v3;
  *(_DWORD *)(v1 + 107544) = v3;
  *(_DWORD *)(v1 + 107548) = v3;
  *(_DWORD *)(v1 + 107552) = v3;
  *(_DWORD *)(v1 + 107556) = v3;
  *(_DWORD *)(v1 + 107560) = v3;
  *(_DWORD *)(v1 + 107564) = v3;
  *(_DWORD *)(v1 + 107568) = v3;
  *(_DWORD *)(v1 + 107572) = v3;
  *(_DWORD *)(v1 + 107576) = v3;
  *(_DWORD *)(v1 + 107580) = v3;
  *(_DWORD *)(v1 + 107584) = v3;
  *(_DWORD *)(v1 + 107588) = v3;
  *(_DWORD *)(v1 + 107592) = v3;
  *(_DWORD *)(v1 + 107596) = v3;
  v4 = (_BYTE *)(v1 + 65300);
  *(_DWORD *)(v1 + 107600) = v3;
  *(_BYTE *)(v1 + 66616) = 0;
  sub_1004CCA0(v1 + 65300, 1);
  v2 = *(_BYTE *)(v1 + 127985) == 0;
  *(_DWORD *)(v1 + 65328) = v1 + 316;
  if ( v2 )
  {
    *v4 = *(_BYTE *)(v1 + 127980);
    *(_DWORD *)(v1 + 65304) = v1 + 364;
    *(_DWORD *)(v1 + 65308) = v1 + 376;
    *(_DWORD *)(v1 + 65312) = v1 + 388;
    *(_DWORD *)(v1 + 65316) = v1 + 400;
    *(_DWORD *)(v1 + 65320) = v1 + 412;
    *(_DWORD *)(v1 + 65324) = v1 + 424;
  }
  else
  {
    *v4 = 1;
    *(_DWORD *)(v1 + 65304) = v1 + 352;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_DWORD *)(v1 + 8) = v1 + 66620;
  *(_DWORD *)v1 = v1 + 600;
  *(_DWORD *)(v1 + 4) = v1 + 11840;
  *(_DWORD *)(v1 + 20) = v1 + 33812;
  *(_DWORD *)(v1 + 12) = v1 + 77344;
  *(_DWORD *)(v1 + 16) = v1 + 23080;
  *(_DWORD *)(v1 + 32) = v1 + 39432;
  *(_DWORD *)(v1 + 24) = v1 + 90524;
  *(_DWORD *)(v1 + 28) = v1 + 96144;
  *(_DWORD *)(v1 + 44) = v1 + 65392;
  *(_DWORD *)(v1 + 40) = v1 + 49968;
  *(_DWORD *)(v1 + 36) = v1 + 54764;
  *(_DWORD *)(v1 + 56) = v1 + 106256;
  *(_DWORD *)(v1 + 52) = v1 + 88068;
  *(_DWORD *)(v1 + 48) = v1 + 89300;
  *(_DWORD *)(v1 + 72) = v1 + 109452;
  *(_DWORD *)(v1 + 64) = v1 + 107480;
  *(_DWORD *)(v1 + 68) = v1 + 107604;
  *(_DWORD *)(v1 + 60) = "ENDURANCE";
  *(_DWORD *)(v1 + 84) = v1 + 108224;
  *(_DWORD *)(v1 + 76) = v1 + 118436;
  *(_DWORD *)(v1 + 80) = v1 + 127420;
  *(_DWORD *)(v1 + 88) = 50529027;
  *(_DWORD *)(v1 + 92) = 50529027;
  *(_DWORD *)(v1 + 96) = 50529027;
  *(_DWORD *)(v1 + 100) = 50529027;
  *(_DWORD *)(v1 + 104) = 50529027;
  *(_WORD *)(v1 + 108) = 771;
  v2 = *(_BYTE *)(v1 + 127985) == 0;
  *(_BYTE *)(v1 + 99) = 0;
  if ( v2 )
    *(_BYTE *)(v1 + 97) = 0;
  if ( !*(_BYTE *)(v1 + 127984) )
    *(_BYTE *)(v1 + 93) = 0;
  *(_DWORD *)(v1 + 112) = v1 + 6220;
  *(_DWORD *)(v1 + 116) = v1 + 17460;
  *(_DWORD *)(v1 + 120) = v1 + 101764;
  *(_DWORD *)(v1 + 124) = v1 + 122928;
  *(_DWORD *)(v1 + 128) = v1 + 127700;
  *(_DWORD *)(v1 + 132) = 50529027;
  *(_BYTE *)(v1 + 136) = 3;
  *(_DWORD *)(v1 + 140) = v1 + 28700;
  v10 = v1 + 140;
  *(_DWORD *)(v1 + 144) = v1 + 82964;
  *(_DWORD *)(v1 + 152) = v1 + 44228;
  *(_DWORD *)(v1 + 148) = v1 + 72240;
  *(_DWORD *)(v1 + 156) = v1 + 60808;
  *(_DWORD *)(v1 + 160) = 50529027;
  *(_BYTE *)(v1 + 164) = 3;
  v11 = (_DWORD *)(v1 + 168);
  *v11 = v1 + 33192;
  *(_DWORD *)(v1 + 180) = v1 + 59560;
  *(_DWORD *)(v1 + 184) = v1 + 48720;
  *(_DWORD *)(v1 + 176) = v1 + 66004;
  *(_DWORD *)(v1 + 172) = v1 + 60808;
  *(_DWORD *)(v1 + 188) = 50529027;
  *(_BYTE *)(v1 + 192) = 3;
  if ( !*(_BYTE *)(v1 + 127985) )
    *(_BYTE *)(v1 + 189) = 0;
  *(_DWORD *)(v1 + 196) = v1 + 28700;
  v12 = v1 + 196;
  *(_DWORD *)(v1 + 200) = v1 + 87456;
  *(_DWORD *)(v1 + 204) = v1 + 76732;
  *(_DWORD *)(v1 + 220) = v1 + 60808;
  *(_BYTE *)(v1 + 190) = 0;
  *(_DWORD *)(v1 + 208) = v1 + 108836;
  *(_DWORD *)(v1 + 212) = v1 + 33192;
  *(_DWORD *)(v1 + 216) = v1 + 106868;
  *(_DWORD *)(v1 + 224) = 50529027;
  *(_WORD *)(v1 + 228) = 771;
  *(_BYTE *)(v1 + 230) = 3;
  if ( *(_BYTE *)(v1 + 127984) )
    *(_BYTE *)(v1 + 230) = 0;
  else
    *(_BYTE *)(v1 + 224) = 0;
  *(_DWORD *)(v1 + 236) = v1 + 89912;
  *(_DWORD *)(v1 + 232) = "ELECTRICAL";
  *(_DWORD *)(v1 + 240) = v1 + 88680;
  *(_DWORD *)(v1 + 244) = v1 + 113944;
  *(_DWORD *)(v1 + 248) = 50529027;
  sub_10026850(a1);
  v9 = 0;
  v8 = sub_1004C3E0(3u);
  if ( 9.8999998e24 == v8 )
    v8 = 0.0;
  sub_10031F70(100.0, v8, (int)&v9);
  sub_10066730(v1 + 89292, v9, 1.0, 0.125);
  v8 = 0.0;
  v9 = 0;
  sub_100663D0(&v8);
  sub_10031F70(100000.0, v8, (int)&v9);
  sub_10066730(v1 + 33804, v9, 1.0, 0.125);
  v8 = sub_1004BFF0(v7);
  if ( 9.8999998e24 == v8 )
    v8 = 0.0;
  v9 = 0;
  sub_10031F70(100.0, v8, (int)&v9);
  sub_10066730(v1 + 108216, v9, 1.0, 0.125);
  *(_BYTE *)(v1 + 127983) = sub_1004BF10(v5);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C1CF8, v1, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C1B9C, v10, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C1C74, (int)v11, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C1E08, v12, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C19B4, v1 + 112, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C1DC8, v1 + 232, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10027150) --------------------------------------------------------
char __usercall sub_10027150@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@5
  int v3; // ST04_4@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( *(_BYTE *)(v1 + 66616) != 2 )
    {
      v2 = (unsigned __int8)(*(_BYTE *)(v1 + 60522) + 1) % (signed __int16)*(_BYTE *)(v1 + 127980);
      *(_BYTE *)(v1 + 66616) = 1;
      *(_BYTE *)(v1 + 60522) = v2;
      *(_BYTE *)(v1 + 49682) = v2;
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    sub_100262C0(a1);
  }
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v3, -32734);
}

//----- (10027210) --------------------------------------------------------
void __usercall sub_10027210(int a1@<eax>)
{
  int v1; // esi@1

  v1 = a1;
  sub_10026500(*(float *)&a1, a1);
  sub_10025E20(1, v1);
  *(_BYTE *)(v1 + 6) = 2;
}

//----- (10027230) --------------------------------------------------------
void __cdecl sub_10027230(int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      sub_10026AB0(a1);
      break;
    case 0x8018:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 127982) )
        sub_100522C0(0);
      break;
    case 0x8041:
      sub_10026AD0(a1);
      break;
    case 0x8022:
    case 0x8078:
      sub_10027210(a1);
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 127981) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 127981) = 0;
      break;
    case 0x8039:
      sub_10025CE0(a1);
      break;
    case 0x8033:
    case 0x8038:
      sub_10027150(a1);
      break;
    case 0x806E:
      switch ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) )
      {
        case 0x40:
          sub_100262C0(a1);
          break;
        case 0x41:
          sub_1004C220();
          sub_1004C0E0();
          break;
        case 0x42:
          sub_1004C2B0();
          sub_1004C0E0();
          break;
        case 0x43:
          sub_1004C0E0();
          JUMPOUT(&loc_1004C350);
          return;
        default:
          return;
      }
      return;
    case 0x8017:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8036:
    case 0x8037:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8048:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return;
  }
}

//----- (10027330) --------------------------------------------------------
int __usercall sub_10027330@<eax>(_BYTE *a1@<ecx>, int a2@<esi>)
{
  bool v2; // zf@1
  int result; // eax@4

  v2 = *(_BYTE *)(a2 + 61) == 0;
  *(_BYTE *)(a2 + 692) = 1;
  *(_BYTE *)(a2 + 693) = 0;
  if ( v2 )
    *(_DWORD *)(a2 + 696) = 9;
  else
    *(_DWORD *)(a2 + 696) = *(_DWORD *)(a2 + 700) + 11;
  *(_DWORD *)(a2 + 700) = 0;
  sub_100649E0(a2 + 708, a1, 16);
  result = *(_DWORD *)(a2 + 696) + 14;
  *(_BYTE *)(a2 + 724) = 0;
  *(_DWORD *)(a2 + 704) = result;
  *(float *)(a2 + 732) = (double)result;
  *(float *)(a2 + 756) = 0.0;
  return result;
}

//----- (100273B0) --------------------------------------------------------
signed int __usercall sub_100273B0@<eax>(char a1@<al>, int a2@<esi>, int a3, int a4)
{
  char v4; // bl@1
  signed int v5; // eax@2
  double v6; // st7@4
  double v7; // st7@4
  signed int result; // eax@5

  *(float *)(a2 + 740) = 15.0;
  v4 = a1 & 0x80;
  *(_DWORD *)(a2 + 736) = 4;
  if ( !(a1 & 0x80) || (v5 = -256, !*(_BYTE *)(a2 + 9)) )
    v5 = -16711681;
  *(float *)(a2 + 752) = 0.0;
  *(_DWORD *)(a2 + 748) = v5;
  *(float *)(a2 + 728) = 50.0;
  sub_10065670(a4, a2 + 728);
  v6 = *(float *)(a2 + 740);
  *(_DWORD *)(a2 + 736) = 2;
  v7 = (double)(signed int)v6 + *(float *)(a2 + 732);
  *(_DWORD *)(a2 + 748) = -1;
  *(float *)(a2 + 732) = v7;
  *(float *)(a2 + 756) = 1.0;
  *(float *)(a2 + 740) = 12.0;
  *(float *)(a2 + 752) = 1.0;
  sub_10065670(a3, a2 + 728);
  *(float *)(a2 + 732) = (double)*(signed int *)(a2 + 704);
  *(_DWORD *)(a2 + 736) = 4;
  *(float *)(a2 + 756) = 0.0;
  *(float *)(a2 + 740) = 15.0;
  if ( !v4 || (result = -256, !*(_BYTE *)(a2 + 9)) )
    result = -16711681;
  *(_DWORD *)(a2 + 748) = result;
  return result;
}

//----- (100274B0) --------------------------------------------------------
char __usercall sub_100274B0@<al>(int a1@<esi>, unsigned __int8 a2, char a3)
{
  char result; // al@4
  int v4; // edi@5
  double v5; // st7@6
  signed int v6; // eax@7
  unsigned __int8 v7; // [sp+23h] [bp-6Dh]@4
  char v8; // [sp+28h] [bp-68h]@9
  float v9; // [sp+40h] [bp-50h]@9
  float v10; // [sp+44h] [bp-4Ch]@10
  char v11; // [sp+78h] [bp-18h]@1

  *(float *)(a1 + 740) = 12.0;
  *(float *)(a1 + 752) = 0.5;
  *(float *)(a1 + 728) = 74.0;
  *(float *)(a1 + 760) = 0.0;
  *(_DWORD *)(a1 + 736) = 2;
  *(_DWORD *)(a1 + 748) = -1;
  sub_100649E0((int)&v11, "LONGEST RUNWAY", 17);
  if ( a2 > 1u && **(_BYTE **)(a1 + 688) > 1 )
    sub_10064B30(&v11, &unk_100B8EB0, 17);
  result = sub_10065670((int)&v11, a1 + 728);
  v7 = 0;
  if ( a2 )
  {
    do
    {
      v4 = *(_DWORD *)(a1 + 688);
      if ( v7 >= (signed int)*(_BYTE *)v4 )
        break;
      *(_DWORD *)(a1 + 704) += (signed int)*(float *)(a1 + 740) + 7;
      v5 = (double)*(signed int *)(a1 + 704);
      *(_DWORD *)(a1 + 736) = 4;
      *(float *)(a1 + 732) = v5;
      *(float *)(a1 + 740) = 15.0;
      if ( a3 & 0x80 )
      {
        v6 = -256;
        if ( *(_BYTE *)(a1 + 9) )
          continue;
      }
      v6 = -16711681;
      *(_DWORD *)(a1 + 748) = v6;
      sub_1004E100(*(_DWORD *)(v4 + 204), *(_BYTE *)(v7 + v4 + 2), (int)&v8);
      sub_1003E7B0(*(_DWORD *)(*(_DWORD *)(a1 + 688) + 204), *(_BYTE *)(v7 + *(_DWORD *)(a1 + 688) + 2), (int)&v11);
      sub_10065670((int)&v11, a1 + 728);
      *(_DWORD *)(a1 + 704) += (signed int)*(float *)(a1 + 740) + 7;
      *(float *)(a1 + 732) = (double)*(signed int *)(a1 + 704);
      if ( v9 >= 9.9999996e24 || v10 >= 9.9999996e24 )
        sub_100649E0((int)&v11, "__x__", 17);
      else
        sprintf(&v11, "%.0fx%.0f", 3.280839895013123 * v9, v10 * 3.280839895013123);
      sub_10065670((int)&v11, a1 + 728);
      result = v7++ + 1;
    }
    while ( v7 < a2 );
  }
  return result;
}

//----- (100276E0) --------------------------------------------------------
int __usercall sub_100276E0@<eax>(int a1@<eax>, float a2, float a3, float a4, float a5)
{
  float v5; // ST08_4@1
  float v6; // ST08_4@1
  float v8; // [sp+10h] [bp+8h]@1
  float v9; // [sp+18h] [bp+10h]@1
  float v10; // [sp+18h] [bp+10h]@1
  float v11; // [sp+18h] [bp+10h]@1

  j_gdi_pvg_color_u32(a1);
  j_gdi_pvg_begin(68);
  sub_1008C2F0(a2, a3);
  v9 = a3 + a5;
  v5 = v9;
  v10 = a4 * 0.25 + a2;
  sub_1008C2F0(v10, v5);
  v11 = a4 * 0.5 + a2;
  sub_1008C2F0(v11, a3);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(64);
  sub_1008C2F0(a2, a3);
  v6 = a3;
  v8 = a2 + a4;
  sub_1008C2F0(v8, v6);
  return j_gdi_pvg_end();
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (100277B0) --------------------------------------------------------
signed int __fastcall sub_100277B0(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  float *v3; // edi@1
  int v4; // eax@3
  signed int result; // eax@4
  char v6; // [sp+Ch] [bp-18h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 688);
  *(float *)(a1 + 740) = 12.0;
  *(float *)(a1 + 752) = 0.5;
  *(float *)(a1 + 728) = 74.0;
  v3 = (float *)(a1 + 728);
  *(_DWORD *)(a1 + 736) = 2;
  *(_DWORD *)(a1 + 748) = -1;
  sub_100649E0((int)&v6, (_BYTE *)(v2 + 126), 17);
  if ( v6 != 95 )
  {
    sub_10064B30(&v6, " WX", 17);
    sub_10064B30(&v6, (_BYTE *)(*(_DWORD *)(v1 + 688) + 177), 17);
  }
  sub_10065670((int)&v6, v1 + 728);
  *(_DWORD *)(v1 + 704) += (signed int)*(float *)(v1 + 740) + 7;
  v4 = *(_DWORD *)(v1 + 688);
  *(float *)(v1 + 732) = (double)*(signed int *)(v1 + 704);
  if ( *(_BYTE *)(v4 + 143) )
  {
    result = sub_100273B0(0, v1, v4 + 160, v4 + 143);
  }
  else
  {
    *(float *)(v1 + 752) = 0.5;
    *(_DWORD *)(v1 + 736) = 2;
    *v3 = 74.0;
    *(_DWORD *)(v1 + 748) = -1;
    *(float *)(v1 + 740) = 12.0;
    result = sub_10065670((int)"NONE WITHIN 50NM", v1 + 728);
  }
  return result;
}

//----- (10027910) --------------------------------------------------------
int __usercall sub_10027910@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  float v2; // ST1C_4@1
  double v3; // st5@1
  float v4; // ST1C_4@1
  float v5; // ST08_4@1
  int result; // eax@1

  v1 = (signed int)*(float *)(a1 + 740) + (signed int)*(float *)(a1 + 732) + 8;
  v2 = (double)*(signed int *)(a1 + 696);
  *(_DWORD *)(a1 + 700) = v1;
  v3 = v2;
  *(_BYTE *)(a1 + 692) = 0;
  v4 = (double)v1 - v2;
  v5 = v3;
  result = sub_1006BEE0(a1 + 708, 1.0, v5, 146.0, v4);
  ++*(_BYTE *)(a1 + 61);
  return result;
}

//----- (100279A0) --------------------------------------------------------
BOOL __usercall sub_100279A0@<eax>(unsigned __int8 *a1@<edi>, unsigned int a2@<esi>)
{
  char v2; // al@1
  unsigned __int8 v3; // bl@1
  bool v4; // zf@5
  unsigned int v6; // [sp+0h] [bp-30h]@0
  char v7; // [sp+Bh] [bp-25h]@1
  unsigned __int8 v8; // [sp+Ch] [bp-24h]@1
  char v9; // [sp+10h] [bp-20h]@2
  char v10; // [sp+18h] [bp-18h]@2
  char v11; // [sp+19h] [bp-17h]@3
  char v12; // [sp+1Ah] [bp-16h]@5
  char v13; // [sp+1Bh] [bp-15h]@9

  v2 = sub_1004DF70(v6);
  v3 = 0;
  v7 = v2;
  v8 = 0;
  if ( v2 )
  {
    while ( 1 )
    {
      sub_1004DFC0(a2, v8, (unsigned int)&v9);
      if ( v10 != 65 )
        goto LABEL_10;
      if ( v11 == 83 )
        goto LABEL_7;
      if ( v11 != 84 )
        break;
      v4 = v12 == 73;
LABEL_8:
      if ( v4 && v13 == 83 )
      {
LABEL_11:
        v2 = v7;
        goto LABEL_12;
      }
LABEL_10:
      v8 = ++v3;
      if ( v3 >= (unsigned __int8)v7 )
        goto LABEL_11;
    }
    if ( v11 != 87 )
      goto LABEL_10;
LABEL_7:
    v4 = v12 == 79;
    goto LABEL_8;
  }
LABEL_12:
  *a1 = v3;
  return v3 < (unsigned __int8)v2;
}

//----- (10027A30) --------------------------------------------------------
char __usercall sub_10027A30@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  char v2; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 8) = v2;
  if ( v2 != 3 && v2 != 4 )
    *(_BYTE *)(v1 + 8) = 3;
  sub_1004C170(*(_BYTE *)(v1 + 8));
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10027A70) --------------------------------------------------------
char __usercall sub_10027A70@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  char result; // al@1

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 840, 0);
  v2 = v1;
  *(float *)(v1 + 576) = 185200.0;
  *(_DWORD *)(v1 + 268) = 0x3FFFF;
  *(_DWORD *)(v1 + 580) = 0x3FFFF;
  *(_DWORD *)(v1 + 4) = 0x3FFFF;
  *(_DWORD *)v1 = 0x3FFFF;
  *(_BYTE *)(v1 + 764) = 0;
  *(_BYTE *)(v1 + 10) = 0;
  *(_BYTE *)(v1 + 27) = 0;
  *(_BYTE *)(v1 + 44) = 0;
  *(_BYTE *)(v1 + 836) = 1;
  *(_BYTE *)(v1 + 62) = 0;
  dword_1016905C = -16711681;
  dword_10169060 = -16711936;
  dword_10169064 = -256;
  dword_10169068 = -65281;
  sub_100011B0(a1, 0, 0, 151, 686, 3);
  *(float *)(v2 + 752) = 0.5;
  *(_BYTE *)(v2 + 8) = 3;
  *(_DWORD *)(v2 + 748) = -1;
  *(float *)(v2 + 728) = 74.0;
  *(_DWORD *)(v2 + 744) = -16777216;
  *(float *)(v2 + 732) = 0.0;
  *(_DWORD *)(v2 + 736) = 2;
  *(float *)(v2 + 756) = 0.0;
  *(float *)(v2 + 760) = 0.0;
  *(float *)(v2 + 740) = 12.0;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 250);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1016905C: using guessed type int dword_1016905C;
// 10169060: using guessed type int dword_10169060;
// 10169064: using guessed type int dword_10169064;
// 10169068: using guessed type int dword_10169068;

//----- (10027B90) --------------------------------------------------------
char __usercall sub_10027B90@<al>(void *a1@<edi>, int a2@<esi>, unsigned int a3)
{
  size_t v3; // eax@1
  char result; // al@3
  unsigned __int8 i; // bl@3
  double v6; // st7@6
  int v7; // edx@13
  char v8; // [sp+7h] [bp-5Dh]@5
  int v9; // [sp+8h] [bp-5Ch]@5
  float v10; // [sp+Ch] [bp-58h]@1
  float v11; // [sp+10h] [bp-54h]@5
  char v12; // [sp+14h] [bp-50h]@6
  float v13; // [sp+2Ch] [bp-38h]@6

  v10 = 9.9999996e24;
  v3 = a2;
  if ( a2 >= 5 )
    v3 = 5;
  result = (unsigned int)memset(a1, -1, v3);
  for ( i = 0; i < a2; *((_BYTE *)a1 + v7) = v8 )
  {
    if ( i >= 5u )
      return result;
    v8 = -1;
    v11 = v10;
    LOBYTE(v9) = 0;
    v10 = 0.0;
    do
    {
      sub_1004E100(a3, v9, (int)&v12);
      v6 = v13;
      if ( v11 > (double)v13 && v10 < v6 )
        goto LABEL_11;
      if ( v10 == v6 && sub_1006E440(&v9, 1u, (int)a1, 1, a2, -1) == -1 )
      {
        v6 = v13;
LABEL_11:
        v10 = v6;
        v8 = v9;
      }
      LOBYTE(v9) = v9 + 1;
    }
    while ( (char)v9 < a2 );
    result = v8;
    v7 = i++;
  }
  return result;
}

//----- (10027CA0) --------------------------------------------------------
signed int __thiscall sub_10027CA0(int this)
{
  char *v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@1
  unsigned int v4; // ebp@1
  signed int result; // eax@1
  char v6; // al@3
  signed int v7; // edi@5
  char *v8; // ebx@6
  __int64 v9; // ST28_8@10
  char v10; // al@10
  const char *v11; // esi@14
  char v12; // [sp+13h] [bp-185h]@3
  int v13; // [sp+14h] [bp-184h]@1
  const char *v14; // [sp+18h] [bp-180h]@1
  unsigned int v15; // [sp+1Ch] [bp-17Ch]@7
  int v16; // [sp+24h] [bp-174h]@2
  int v17; // [sp+28h] [bp-170h]@3
  int v18; // [sp+32h] [bp-166h]@3
  unsigned int v19; // [sp+3Ch] [bp-15Ch]@11
  char v20; // [sp+44h] [bp-154h]@11
  int v21; // [sp+58h] [bp-140h]@9
  int v22; // [sp+5Ch] [bp-13Ch]@11
  unsigned int v23; // [sp+78h] [bp-120h]@10
  char v24; // [sp+DCh] [bp-BCh]@10
  char v25; // [sp+FCh] [bp-9Ch]@14
  char v26; // [sp+120h] [bp-78h]@13
  unsigned int v27; // [sp+148h] [bp-50h]@13
  char v28; // [sp+16Ch] [bp-2Ch]@14

  v1 = (char *)this;
  v2 = this + 38;
  v3 = this + 1;
  *(_BYTE *)(this + 18) = 0;
  v14 = (const char *)(this + 55);
  *(_BYTE *)(this + 55) = 0;
  *(_BYTE *)(this + 1) = 0;
  v4 = 0xFFFF;
  v13 = this + 38;
  sub_100649E0(this + 38, "____", 17);
  result = sub_1006C790();
  if ( (unsigned __int8)result > 1u )
  {
    sub_1004EFB0(&v16);
    if ( v16 > 0 )
    {
      sub_1004F490(v17, v3, &v12);
      v6 = sub_1004F2A0(v18);
      *v1 = v6;
      if ( (unsigned __int8)v6 > 2u )
        *v1 = 2;
      v7 = 0;
      if ( *v1 )
      {
        v8 = v1 + 18;
        do
        {
          sub_1004F380(v18, v7, &v15);
          sub_10064B00(v8, 0xAu, "%3i.%03i", v15 / 0x3E8, v15 % 0x3E8);
          ++v7;
          v8 += 10;
        }
        while ( v7 < (unsigned __int8)*v1 );
        v2 = v13;
      }
    }
    result = sub_1004EBE0((int)&v21);
    if ( v21 > 0 )
    {
      sub_1004D8B0(v23, (int)&v24);
      LODWORD(v9) = v23;
      v10 = sub_1004EB40(v9);
      if ( v10 )
      {
        if ( v10 == 3 )
        {
          sub_1004E7F0(v23, (int)&v26);
          v4 = v27;
          sub_100649E0(v2, "VOR", 17);
        }
      }
      else
      {
        sub_1004DFC0(v23, v22, (unsigned int)&v19);
        v4 = v19;
        sub_100649E0(v2, &v20, 17);
      }
      sub_10064B70(v2, 0);
      sub_10064B00(&v28, 0x28u, " %3i.%03i", v4 / 0x3E8, v4 % 0x3E8);
      v11 = v14;
      sub_100649E0((int)v14, &v25, 17);
      result = sub_10064B30(v11, &v28, 17);
    }
  }
  return result;
}

//----- (10027EA0) --------------------------------------------------------
void __usercall sub_10027EA0(int a1@<eax>)
{
  int v1; // esi@1
  char *v2; // edi@1
  signed int v3; // ecx@1
  int v4; // edx@2
  void *v5; // ecx@6
  int v6; // eax@10
  int v7; // ebx@11
  unsigned __int8 v8; // [sp+Fh] [bp-11h]@10
  __int16 v9; // [sp+10h] [bp-10h]@2
  unsigned __int8 v10; // [sp+12h] [bp-Eh]@2
  unsigned __int8 v11; // [sp+13h] [bp-Dh]@2
  unsigned int v12; // [sp+14h] [bp-Ch]@6
  unsigned int v13; // [sp+18h] [bp-8h]@5
  char *v14; // [sp+1Ch] [bp-4h]@1

  v1 = a1;
  v2 = (char *)(a1 + 10);
  strncpy((char *)(a1 + 10), " __:__:__", 6u);
  *(_BYTE *)(v1 + 16) = 0;
  strncpy((char *)(v1 + 27), " __:__:__", 6u);
  *(_BYTE *)(v1 + 33) = 0;
  v14 = (char *)(v1 + 44);
  sub_10064B00((char *)(v1 + 44), 0x11u, " __:__:__");
  v3 = *(_DWORD *)(v1 + 572);
  if ( v3 != 0x7FFFFFFF )
  {
    v9 = v3 / 3600;
    v4 = v3 % 60;
    v10 = v3 % 3600 / 60;
    v11 = v3 % 60;
    if ( v3 <= 3600 )
      sub_10064B00(v2, 0x11u, " %02d:%02d", v3 % 3600 / 60, (unsigned __int8)v4);
    else
      sub_10064B00(v2, 0x11u, " %02d:%02d", v9, v3 % 3600 / 60);
    if ( sub_10051BD0((char *)&v13) )
    {
      v12 = v13 + *(_DWORD *)(v1 + 572) - 86400 * (v13 / 0x15180);
      v5 = (void *)v12;
      if ( v12 > 0x15180 )
      {
        v5 = (void *)(86400
                    * (((signed int)(((unsigned __int64)(1037155065i64 * (signed int)v12) >> 32) - v12) >> 16)
                     + ((unsigned int)(((unsigned __int64)(1037155065i64 * (signed int)v12) >> 32) - v12) >> 31))
                    + v12);
        v12 += 86400
             * (((signed int)(((unsigned __int64)(1037155065i64 * (signed int)v12) >> 32) - v12) >> 16)
              + ((unsigned int)(((unsigned __int64)(1037155065i64 * (signed int)v12) >> 32) - v12) >> 31));
      }
      if ( sub_10051FD0(v5) == 1 )
        sub_1006E660((signed int *)&v12, v12);
      v9 = v12 / 0xE10;
      v10 = v12 % 0xE10 / 0x3C;
      sub_1003B810(&v9, &v8);
      v6 = (unsigned __int8)sub_10064B00((char *)(v1 + 27), 0x11u, " %02d:%02d", v9, v10) + v1;
      *(_BYTE *)(v6 + 27) = byte_100C2549[v8];
      *(_BYTE *)(v6 + 28) = 0;
    }
  }
  v7 = sub_1006E5D0(2u);
  *(_BYTE *)(v1 + 836) = sub_1003E920(2u) != 0.0;
  if ( v7 != 0x7FFFFFFF )
  {
    v10 = ((signed int)(v7 % 3600 + ((unsigned __int64)(-2004318071i64 * (v7 % 3600)) >> 32)) >> 5)
        + ((unsigned int)(v7 % 3600 + ((unsigned __int64)(-2004318071i64 * (v7 % 3600)) >> 32)) >> 31);
    v9 = v7 / 3600;
    v11 = v7
        - 60
        * (((signed int)(v7 + ((unsigned __int64)(-2004318071i64 * v7) >> 32)) >> 5)
         + ((unsigned int)(v7 + ((unsigned __int64)(-2004318071i64 * v7) >> 32)) >> 31));
    sub_10064B00(v14, 0x11u, " %02d:%02d:%02d", v9, v10, v11);
  }
}

//----- (10028100) --------------------------------------------------------
int __usercall sub_10028100@<eax>(int a1@<ecx>, int a2@<edi>)
{
  int v2; // eax@1
  int result; // eax@1
  void *v4; // ecx@2
  unsigned __int8 v5; // al@4
  unsigned __int8 v6; // al@5
  int v7; // esi@8
  unsigned __int8 v8; // al@8
  int v9; // eax@8
  unsigned int v10; // eax@8
  unsigned int v11; // ecx@8
  int v12; // eax@14
  int v13; // eax@17
  int v14; // [sp+0h] [bp-4h]@1

  v14 = a1;
  *(_BYTE *)(a2 + 1) = 0;
  v2 = sub_1006E710(9u);
  result = sub_1008C850(v2, 5000);
  if ( !result )
  {
    if ( sub_1006EC00(1u, 9) || sub_10052210(v4) == 4 )
    {
      v5 = sub_1006E6D0(9);
      if ( sub_1006E980(9, v5) )
      {
        v6 = sub_1006E6D0(9);
        if ( sub_1006E8A0(9, &v14, v6) )
        {
          if ( (unsigned __int8)sub_1006EAB0() )
          {
            if ( sub_1006E9E0(9) )
            {
              v7 = v14;
              v8 = sub_1006E6D0(9);
              v9 = sub_1006E910(9, 0, v8);
              v10 = v14 + v9;
              v11 = *(_WORD *)(v7 + 3) + v14 + 4 * *(_WORD *)(v7 + 3);
              v14 = v11;
              if ( v10 < v11 )
              {
                while ( *(_BYTE *)v10 != *(_BYTE *)(a2 + 248)
                     || *(_BYTE *)(v10 + 1) != *(_BYTE *)(a2 + 249)
                     || *(_BYTE *)(v10 + 2) != *(_BYTE *)(a2 + 250)
                     || *(_BYTE *)(v10 + 3) != *(_BYTE *)(a2 + 251) )
                {
                  v10 += 5;
                  if ( v10 >= v11 )
                  {
                    v12 = sub_1006E710(9u);
                    return sub_1008C830(v12);
                  }
                }
                if ( v10 < v11 )
                  *(_BYTE *)(a2 + 1) = *(_BYTE *)(v10 + 4);
              }
            }
          }
        }
      }
    }
    v13 = sub_1006E710(9u);
    result = sub_1008C830(v13);
  }
  return result;
}

//----- (10028240) --------------------------------------------------------
int __thiscall sub_10028240(void *this)
{
  int v1; // esi@1
  unsigned __int8 v2; // al@1
  int v3; // eax@5
  int v4; // eax@7
  double v5; // st6@7
  float v6; // ST48_4@14
  unsigned __int8 v7; // al@14
  float v8; // ST48_4@18
  float v9; // ST48_4@18
  float v10; // ST4C_4@18
  int v11; // eax@24
  char v12; // al@24
  unsigned __int8 v13; // al@24
  _BYTE *v14; // eax@24
  int result; // eax@27
  char *v16; // [sp-Ch] [bp-94h]@25
  int v17; // [sp-4h] [bp-8Ch]@21
  char *v18; // [sp-4h] [bp-8Ch]@25
  const char *v19; // [sp+0h] [bp-88h]@21
  float v20; // [sp+24h] [bp-64h]@1
  float v21; // [sp+24h] [bp-64h]@18
  int v22; // [sp+28h] [bp-60h]@5
  float v23; // [sp+2Ch] [bp-5Ch]@17
  int v24; // [sp+30h] [bp-58h]@5
  float v25; // [sp+34h] [bp-54h]@5
  float v26; // [sp+38h] [bp-50h]@2
  int v27; // [sp+3Ch] [bp-4Ch]@5
  char v28; // [sp+40h] [bp-48h]@2
  char v29; // [sp+50h] [bp-38h]@2
  char v30; // [sp+58h] [bp-30h]@2
  char v31; // [sp+61h] [bp-27h]@4
  char v32; // [sp+64h] [bp-24h]@5
  char v33; // [sp+7Ch] [bp-Ch]@14

  v1 = (int)this;
  v2 = sub_1006C790();
  v20 = 9.8999998e24;
  *(_DWORD *)(v1 + 196) = 0x7FFFFFFF;
  if ( v2 <= 1u )
  {
    sub_100649E0(v1 + 7, " ____", 17);
    sub_100649E0(v1 + 24, " ____", 17);
    sub_100649E0(v1 + 75, " ____", 17);
    return sub_100649E0(v1 + 92, " ____", 17);
  }
  sub_1006C7C0(0, (int)&v28);
  sub_10095920((int)&v28, (int)&v29);
  sub_1008DF20((int)&v30);
  if ( sub_1006CA40(&v26) )
    v20 = v26;
  if ( v31 == 1 )
  {
    LOBYTE(v3) = sub_1008DED0();
    sub_1008BAE0((int)&v28, v1 + 216, v3, (float *)&v22, (int)&v25);
    if ( sub_1008BA30(COERCE_FLOAT(v32 - 1), (int)&v24, (int)&v27) )
      *(_DWORD *)(v1 + 196) = v27;
  }
  else
  {
    LOBYTE(v4) = sub_1008DED0();
    sub_1008BAE0((int)&v28, v1 + 216, v4, (float *)&v22, (int)&v25);
    v24 = v22;
    v5 = v20;
    if ( v20 != 9.8999998e24 && v5 > 0.0 )
      *(_DWORD *)(v1 + 196) = (signed int)(*(float *)&v22 / v5 + 0.5);
  }
  if ( *(float *)&v22 * 0.0005399568034557236 >= 10.0 )
    sub_10064B00((char *)(v1 + 75), 0x11u, " %.0f NM", *(float *)&v22 * 0.0005399568034557236);
  else
    sub_10064B00((char *)(v1 + 75), 0x11u, " %.1f NM", *(float *)&v22 * 0.0005399568034557236);
  if ( *(float *)&v22 * 0.0005399568034557236 < 200.0 )
  {
    v6 = v25 + 3.141592741012573;
    v7 = sub_1006EC70(v6);
    sub_1006ECC0(v7, &v33);
    sub_10064B30((const char *)(v1 + 75), word_100C2700, 17);
    sub_10064B30((const char *)(v1 + 75), &v33, 17);
  }
  if ( *(float *)&v22 <= 0.0 || 9.8999998e24 == v20 || !sub_1006C9E0(&v23) )
  {
    v19 = " ____";
    v17 = v1 + 92;
    goto LABEL_23;
  }
  v8 = *(float *)(v1 + 232) - v23;
  v23 = v8 * 3.280839895013123;
  v9 = v20 * 1.943844492440605;
  v10 = v9 * 6076.115485564304 / 60.0 * v23 / (3.280839895013123 * *(float *)&v22);
  v21 = (double)sub_10095660((signed int)v10, 10);
  if ( v21 <= -5000.0 || v21 >= 5000.0 )
  {
    v19 = " ____";
    v17 = v1 + 92;
LABEL_23:
    sub_100649E0(v17, v19, 17);
    goto LABEL_24;
  }
  sub_10064B00((char *)(v1 + 92), 0x11u, " %.0f FPM", v21);
LABEL_24:
  v11 = sub_10095A00(v25);
  sub_10064B00((char *)(v1 + 7), 0x11u, " %03d", v11);
  v12 = sub_1008DED0();
  v13 = sub_1006CCA0(v12);
  v14 = (_BYTE *)sub_1006C650(v13);
  sub_10064B30((const char *)(v1 + 7), v14, 17);
  if ( *(float *)&v24 * 0.0005399568034557236 >= 10.0 )
  {
    v18 = " %.0f NM";
    v16 = (char *)(v1 + 24);
  }
  else
  {
    v18 = " %.1f NM";
    v16 = (char *)(v1 + 24);
  }
  result = sub_10064B00(v16, 0x11u, v18, *(float *)&v24 * 0.0005399568034557236);
  *(float *)(v1 + 200) = *(float *)&v24;
  return result;
}

//----- (10028610) --------------------------------------------------------
char __usercall sub_10028610@<al>(char result@<al>, int a2@<edx>, char a3@<cl>)
{
  signed int v3; // eax@6
  float v4; // ST14_4@11

  switch ( a3 )
  {
    case 1:
      result = sub_100273B0(result, a2, (int)"BRG:", *(_DWORD *)(a2 + 688) + 7);
      break;
    case 3:
      result = sub_100273B0(result, a2, (int)"FPL:", *(_DWORD *)(a2 + 688) + 24);
      break;
    case 4:
      result = sub_100273B0(result, a2, *(_DWORD *)(a2 + 688) + 292, *(_DWORD *)(a2 + 688) + 41);
      break;
    case 5:
      *(float *)(a2 + 740) = 15.0;
      *(_DWORD *)(a2 + 736) = 4;
      if ( result >= 0 || (v3 = -256, !*(_BYTE *)(a2 + 9)) )
        v3 = -16711681;
      *(_DWORD *)(a2 + 748) = v3;
      *(float *)(a2 + 752) = 0.5;
      *(float *)(a2 + 728) = 74.0;
      result = sub_10065670(*(_DWORD *)(a2 + 688) + 248, a2 + 728);
      break;
    case 6:
      result = *(_BYTE *)(*(_DWORD *)(a2 + 688) + 1);
      if ( result && (unsigned __int8)result <= 4u )
      {
        v4 = *(float *)(a2 + 732) + 1.0;
        result = sub_100276E0(
                   dword_10169058[(unsigned __int8)result],
                   105.7,
                   v4,
                   *(float *)(a2 + 740),
                   *(float *)(a2 + 740));
      }
      break;
    case 7:
      *(float *)(a2 + 740) = 12.0;
      *(_DWORD *)(a2 + 736) = 2;
      *(float *)(a2 + 752) = 0.5;
      *(_DWORD *)(a2 + 748) = -1;
      *(float *)(a2 + 728) = 74.0;
      if ( result < 0 && *(_BYTE *)(a2 + 9) )
        *(_DWORD *)(a2 + 748) = -256;
      else
        *(_DWORD *)(a2 + 748) = -16711681;
      result = sub_10065670(*(_DWORD *)(a2 + 688) + 58, a2 + 728);
      break;
    case 8:
      result = sub_100274B0(a2, result & 0x7F, result & 0x80);
      break;
    case 9:
      result = sub_100273B0(result, a2, (int)"POS:", *(_DWORD *)(a2 + 688) + 75);
      break;
    case 2:
      result = sub_100273B0(result, a2, (int)"VSR:", *(_DWORD *)(a2 + 688) + 92);
      break;
    case 0xA:
      result = sub_100273B0(result, a2, (int)"TPA:", *(_DWORD *)(a2 + 688) + 109);
      break;
    case 0xB:
      result = sub_100277B0(a2);
      break;
    case 0xC:
      result = sub_100273B0(result, a2, (int)"ETE:", a2 + 10);
      break;
    case 0xD:
      result = sub_100273B0(result, a2, (int)"ETA:", a2 + 27);
      break;
    case 0xE:
      if ( *(_BYTE *)(a2 + 836) )
        result = sub_100273B0(result, a2, (int)"FLT:", a2 + 44);
      else
        result = sub_100273B0(result, a2, (int)"PWR:", a2 + 44);
      break;
    default:
      return result;
  }
  return result;
}
// 10169058: using guessed type int dword_10169058[];

//----- (100288C0) --------------------------------------------------------
void __cdecl sub_100288C0(int a1)
{
  unsigned int v1; // ecx@0
  unsigned int v2; // ebx@1
  char v3; // al@2
  unsigned __int8 v4; // al@2
  double v5; // st7@8
  int v6; // eax@9
  char v7; // al@12
  int v8; // ebx@13
  bool v9; // zf@13
  char v10; // dl@17
  unsigned int v11; // eax@21
  unsigned int v12; // eax@22
  char *v13; // eax@23
  int v14; // eax@24
  char v15; // [sp+1Eh] [bp-102h]@11
  char v16; // [sp+1Fh] [bp-101h]@2
  int v17; // [sp+20h] [bp-100h]@8
  float v18; // [sp+24h] [bp-FCh]@24
  char v19; // [sp+28h] [bp-F8h]@24
  int v20; // [sp+2Ch] [bp-F4h]@13
  int v21; // [sp+34h] [bp-ECh]@13
  int v22[25]; // [sp+38h] [bp-E8h]@14
  unsigned int v23; // [sp+9Ch] [bp-84h]@22
  char v24; // [sp+A4h] [bp-7Ch]@25
  char v25; // [sp+B8h] [bp-68h]@24
  char v26; // [sp+D8h] [bp-48h]@24
  char v27; // [sp+FCh] [bp-24h]@2
  char v28; // [sp+10Ch] [bp-14h]@2

  v2 = v1;
  *(_DWORD *)(a1 + 204) = v1;
  if ( v1 != 0x3FFFF )
  {
    sub_1004F7C0(v1, (int)&v27, &v16);
    v28 = 0;
    sub_100649E0(a1 + 58, &v27, 17);
    sub_1004D8B0(v2, a1 + 216);
    v3 = sub_1004E3E0(v2);
    *(_BYTE *)a1 = v3;
    sub_10027B90((void *)(a1 + 2), v3, v2);
    v4 = sub_1004D150(v2);
    sub_1004DFC0(v2, v4, a1 + 284);
    sub_10064B70(a1 + 292, 0);
    if ( strstr("MULTICOM", (const char *)(a1 + 292)) || strstr("UNICOM", (const char *)(a1 + 292)) )
      sub_100649E0(a1 + 292, "CTAF", 11);
    if ( *(_BYTE *)(a1 + 292) == 45 )
    {
      sub_100649E0(a1 + 292, "----:", 11);
      sub_100649E0(a1 + 41, " ---.---", 17);
    }
    else
    {
      sub_10064B30((const char *)(a1 + 292), ":", 11);
      sub_10064B00(
        (char *)(a1 + 41),
        0x11u,
        " %3d.%03d",
        *(_DWORD *)(a1 + 284) / 0x3E8u,
        *(_DWORD *)(a1 + 284) % 0x3E8u);
    }
    v5 = *(float *)(a1 + 232) * 3.280839895013123;
    v17 = *(_DWORD *)(a1 + 240);
    if ( v17 <= 0 )
      v6 = sub_10095660((signed int)(v5 + 1000.0), 50);
    else
      v6 = (signed int)(v5 + (double)v17);
    sub_10064B00((char *)(a1 + 109), 0x11u, " %d FT", v6);
    if ( (unsigned __int8)sub_100279A0((unsigned __int8 *)&v15, *(_DWORD *)(a1 + 204)) )
    {
      v7 = v15;
      *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
      *(_BYTE *)(a1 + 212) = v7;
    }
    else
    {
      sub_10095920(a1 + 216, (int)&v20);
      sub_1004F4F0(0, (int)&v20, 92600.0, 0, (int)&v21);
      v8 = 0;
      v9 = v21 == 0;
      if ( v21 > 0 )
      {
        while ( !(unsigned __int8)sub_100279A0((unsigned __int8 *)&v15, v22[v8]) )
        {
          if ( ++v8 >= v21 )
            goto LABEL_18;
        }
        v10 = v15;
        *(_DWORD *)(a1 + 208) = v22[v8];
        *(_BYTE *)(a1 + 212) = v10;
LABEL_18:
        v9 = v8 == v21;
      }
      if ( v9 )
        *(_DWORD *)(a1 + 208) = 0x3FFFF;
    }
    v11 = *(_DWORD *)(a1 + 208);
    if ( v11 == 0x3FFFF )
    {
      *(_BYTE *)(a1 + 143) = 0;
      *(_BYTE *)(a1 + 126) = 0;
      *(_BYTE *)(a1 + 177) = 0;
      *(_BYTE *)(a1 + 160) = 0;
    }
    else
    {
      sub_1004DFC0(v11, *(_BYTE *)(a1 + 212), (unsigned int)&v23);
      v12 = *(_DWORD *)(a1 + 208);
      if ( v12 == *(_DWORD *)(a1 + 204) )
      {
        v13 = sub_1006ED10(0x726u);
        sub_100649E0(a1 + 126, v13, 17);
        *(_BYTE *)(a1 + 177) = 0;
      }
      else
      {
        sub_1004D8B0(v12, (int)&v25);
        sub_100649E0(a1 + 126, &v26, 17);
        LOBYTE(v14) = sub_1008DED0();
        sub_1008BAE0(a1 + 216, (int)&v25, v14, &v18, (int)&v19);
        sub_10064B00((char *)(a1 + 177), 0x11u, " - %.0fNM", v18 * 0.0005399567889980972);
      }
      sub_10064B70((int)&v24, 0);
      sub_100649E0(a1 + 160, &v24, 17);
      sub_10064B30((const char *)(a1 + 160), ":", 17);
      sub_10064B00((char *)(a1 + 143), 0x11u, " %3d.%03d", v23 / 0x3E8, v23 % 0x3E8);
    }
  }
}
// 100288C0: using guessed type int var_E8[25];

//----- (10028C60) --------------------------------------------------------
int __cdecl sub_10028C60(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned __int8 v3; // al@3
  int v4; // edi@9
  int v5; // ecx@9
  bool v6; // zf@12
  char v7; // cl@17
  unsigned __int8 v8; // bl@17
  bool v9; // cf@22
  double v10; // st7@22
  double v11; // st7@25
  int v12; // ecx@30
  double v13; // st7@44
  int result; // eax@48
  char v15; // [sp+Ah] [bp-Ah]@1
  char v16; // [sp+Bh] [bp-9h]@27
  int v17; // [sp+Ch] [bp-8h]@11
  int v18; // [sp+10h] [bp-4h]@6

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v15 = 1;
  *(_BYTE *)(v2 + 9) = sub_1008E200();
  *(_BYTE *)(v2 + 61) = 0;
  sub_100653C0(v1, *(_WORD **)(v1 + 52), (char *)&unk_100C2578, (int)&unk_100C2634, 0, 255);
  if ( *(_DWORD *)(a1 + 64) == 5 )
    sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C2590, (int)&unk_100C263C, 0, 255);
  v3 = (*(_BYTE *)(v2 + 62))++;
  if ( v3 <= 0x14u )
  {
    *(_BYTE *)(v2 + 63) = 0;
  }
  else
  {
    *(_BYTE *)(v2 + 62) = 0;
    *(_BYTE *)(v2 + 63) = 1;
  }
  v18 = sub_1004FEA0(0);
  if ( *(_DWORD *)(v2 + 268) != v18 )
    sub_100288C0(v2 + 64);
  sub_10027330("NRST APT", v2);
  if ( *(_DWORD *)(v2 + 268) == 0x3FFFF )
  {
    *(float *)(v2 + 752) = 0.5;
    *(float *)(v2 + 728) = 74.0;
    *(_DWORD *)(v2 + 736) = 2;
    *(float *)(v2 + 740) = 12.0;
    *(_DWORD *)(v2 + 748) = -1;
    sub_10065670((int)"NONE WITHIN", v2 + 728);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
    v17 = *(_DWORD *)(v2 + 704);
    v13 = (double)v17;
    *(_DWORD *)(v2 + 736) = 2;
    *(float *)(v2 + 732) = v13;
    *(_DWORD *)(v2 + 748) = -1;
    *(float *)(v2 + 752) = 0.5;
    *(float *)(v2 + 728) = 74.0;
    *(float *)(v2 + 740) = 12.0;
    sub_10065670((int)"200 NM", v2 + 728);
  }
  else
  {
    v4 = v2 + 64;
    sub_10028240((void *)(v2 + 64));
    if ( *(_BYTE *)(v2 + 63) )
      sub_10028100(v5, v4);
    *(_DWORD *)(v2 + 688) = v4;
    sub_10028610(-128, v2, 5);
    sub_10028610(0, v2, 6);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10028610(-128, v2, 7);
    if ( *(_DWORD *)(v2 + 268) != *(_DWORD *)(v2 + 580) )
    {
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(-128, v2, 9);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(-128, v2, 2);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(-128, v2, 1);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v6 = *(_BYTE *)(v2 + 8) == 3;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      if ( v6 )
      {
        sub_10028610(-128, v2, 10);
        *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
        v17 = *(_DWORD *)(v2 + 704);
        *(float *)(v2 + 732) = (double)v17;
      }
      sub_10028610(-128, v2, 4);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(-127, v2, 8);
    }
  }
  sub_10027910(v2);
  sub_10027CA0(v2 + 764);
  if ( *(_BYTE *)(v2 + 8) == 3 )
  {
    sub_10027330("NRST FREQS", v2);
    if ( *(_BYTE *)(v2 + 782) )
    {
      *(float *)(v2 + 752) = 0.5;
      *(float *)(v2 + 728) = 74.0;
      *(_DWORD *)(v2 + 736) = 2;
      *(_DWORD *)(v2 + 748) = -1;
      *(float *)(v2 + 740) = 12.0;
      sub_10065670((int)"ARTCC", v2 + 728);
      v7 = *(_BYTE *)(v2 + 9);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      *(_DWORD *)(v2 + 736) = 4;
      *(float *)(v2 + 740) = 15.0;
      *(_DWORD *)(v2 + 748) = v7 != 0 ? -256 : -16711681;
      sub_10065670(v2 + 765, v2 + 728);
      v8 = 0;
      if ( *(_BYTE *)(v2 + 764) )
      {
        do
        {
          if ( v8 >= 2u )
            break;
          *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
          v17 = *(_DWORD *)(v2 + 704);
          *(float *)(v2 + 732) = (double)v17;
          sub_10065670(v2 + 10 * v8++ + 782, v2 + 728);
        }
        while ( v8 < *(_BYTE *)(v2 + 764) );
      }
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
    }
    if ( *(_BYTE *)(v2 + 819) )
    {
      *(float *)(v2 + 752) = 0.5;
      *(float *)(v2 + 728) = 74.0;
      *(_DWORD *)(v2 + 736) = 2;
      *(float *)(v2 + 740) = 12.0;
      *(_DWORD *)(v2 + 748) = -1;
      sub_10065670(v2 + 802, v2 + 728);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v9 = *(_BYTE *)(v2 + 9) != 0;
      v17 = *(_DWORD *)(v2 + 704);
      v10 = (double)v17;
      *(_DWORD *)(v2 + 736) = 4;
      *(float *)(v2 + 732) = v10;
      *(float *)(v2 + 740) = 15.0;
      *(_DWORD *)(v2 + 748) = v9 ? -256 : -16711681;
      sub_10065670(v2 + 819, v2 + 728);
    }
    if ( !*(_BYTE *)(v2 + 782) && !*(_BYTE *)(v2 + 819) )
    {
      *(float *)(v2 + 752) = 0.5;
      *(float *)(v2 + 728) = 74.0;
      *(_DWORD *)(v2 + 736) = 2;
      *(float *)(v2 + 740) = 12.0;
      *(_DWORD *)(v2 + 748) = -1;
      sub_10065670((int)"NONE WITHIN", v2 + 728);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      v11 = (double)v17;
      *(_DWORD *)(v2 + 736) = 2;
      *(float *)(v2 + 732) = v11;
      *(_DWORD *)(v2 + 748) = -1;
      *(float *)(v2 + 752) = 0.5;
      *(float *)(v2 + 728) = 74.0;
      *(float *)(v2 + 740) = 12.0;
      sub_10065670((int)"200 NM", v2 + 728);
    }
    sub_10027910(v2);
    v1 = a1;
  }
  sub_1004FC50(v1, &v16, &v18);
  if ( *(_DWORD *)(v2 + 580) != v18 )
    sub_100288C0(v2 + 376);
  *(_DWORD *)(v2 + 688) = v2 + 376;
  sub_10027330("DEST APT", v2);
  if ( *(_DWORD *)(v2 + 580) == 0x3FFFF )
  {
    *(float *)(v2 + 740) = 12.0;
    *(float *)(v2 + 752) = 0.5;
    *(_DWORD *)(v2 + 736) = 2;
    *(_DWORD *)(v2 + 748) = -1;
    *(float *)(v2 + 728) = 74.0;
    sub_10065670((int)"NO DESTINATION", v2 + 728);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10065670((int)"AIRPORT", v2 + 728);
  }
  else
  {
    sub_10028240((void *)(v2 + 376));
    if ( *(_BYTE *)(v2 + 63) )
      sub_10028100(v12, v2 + 376);
    sub_10028610(0, v2, 5);
    sub_10028610(0, v2, 6);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10028610(0, v2, 7);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
    v6 = *(_BYTE *)(v2 + 8) == 4;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    if ( v6 || *(_DWORD *)(v2 + 268) == *(_DWORD *)(v2 + 580) || !*(_BYTE *)(v2 + 764) )
    {
      sub_10028610(-128, v2, 9);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(-128, v2, 2);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
    }
    sub_10028610(-128, v2, 1);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10028610(-128, v2, 3);
    if ( *(_BYTE *)(v2 + 8) == 4 || *(_BYTE *)(v2 + 764) <= 1u || *(_DWORD *)(v2 + 268) == *(_DWORD *)(v2 + 580) )
    {
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(0, v2, 10);
    }
    if ( *(_BYTE *)(v2 + 8) == 4 || *(_DWORD *)(v2 + 268) == *(_DWORD *)(v2 + 580) )
    {
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(0, v2, 4);
      *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
      v17 = *(_DWORD *)(v2 + 704);
      *(float *)(v2 + 732) = (double)v17;
      sub_10028610(0, v2, 11);
      v15 = 2;
    }
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 11;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10028610(v15, v2, 8);
  }
  sub_10027910(v2);
  sub_10027EA0(v2);
  sub_10027330("TIME", v2);
  if ( *(_DWORD *)(v2 + 580) != 0x3FFFF )
  {
    sub_10028610(-128, v2, 12);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
    sub_10028610(-128, v2, 13);
    *(_DWORD *)(v2 + 704) += (signed int)*(float *)(v2 + 740) + 7;
    v17 = *(_DWORD *)(v2 + 704);
    *(float *)(v2 + 732) = (double)v17;
  }
  sub_10028610(0, v2, 14);
  sub_10027910(v2);
  result = *(_DWORD *)(v1 + 56);
  *(_BYTE *)(result + 230) = -1;
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}

//----- (10029620) --------------------------------------------------------
char __cdecl sub_10029620(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32833:
      LOBYTE(v1) = sub_10027A70(a1);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_10028C60(a1);
      break;
    case 32825:
      LOBYTE(v1) = sub_10027A30(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (100296D0) --------------------------------------------------------
int __usercall sub_100296D0@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3)
{
  unsigned int v3; // edi@1
  signed int v4; // eax@1

  v3 = 0;
  memcpy((void *)a1, (const void *)(a1 + 4), 4 * a2 - 4);
  v4 = 0;
  for ( *(_DWORD *)(a1 + 4 * a2 - 4) = a3; v4 < (signed int)a2; ++v4 )
    v3 += *(_DWORD *)(a1 + 4 * v4);
  return v3 / a2;
}

//----- (10029710) --------------------------------------------------------
int __usercall sub_10029710@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int v5; // ST4C_4@3
  double v6; // st6@3
  double v7; // st7@3
  double v8; // st7@3
  double v9; // st7@3
  int v10; // eax@3
  int v11; // eax@3
  int v12; // ST4C_4@3
  int v13; // ST4C_4@3
  double v14; // st7@3
  int v15; // ST4C_4@4
  double v16; // st7@4
  int v17; // ST4C_4@5
  float v18; // ST28_4@6
  signed int v19; // eax@6
  int v20; // ST4C_4@6
  int v21; // ST50_4@6
  float v22; // ST50_4@6
  float v23; // ST50_4@6
  int result; // eax@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"QC";
  v3 = v1 + 232;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&unk_100C2FA8 );
  *(float *)(v1 + 184160) = 0.0;
  *(_DWORD *)(v1 + 184168) = 2;
  *(float *)(v1 + 184164) = 0.0;
  *(_DWORD *)(v1 + 184176) = 0;
  *(_DWORD *)(v1 + 184180) = -1;
  *(float *)(v1 + 184172) = 12.0;
  *(float *)(v1 + 184184) = 0.5;
  *(float *)(v1 + 184188) = 1.0;
  *(float *)(v1 + 184192) = 40.0;
  sub_10042820(v1 + 588, (int)"MAN IN HG", dword_1031FB44 + 3912, 10.0, 10.0, 225.0, 225.0);
  sub_10042990(dword_1031FB44 + 20480, v1 + 588);
  *(_WORD *)(v1 + 6162) = 5;
  *(_BYTE *)(v1 + 6168) = 1;
  *(_DWORD *)(v1 + 6164) = &unk_100B8DC0;
  sub_10062160(16931.934, 3386.3867, -0.2, v1 + 604);
  sub_10061F10(16931.934, "%.0f", 1.0, 12.0, -0.2, v1 + 604);
  sub_10060F20(v1 + 228, 1, v1 + 604);
  *(float *)(v1 + 2908) = *(float *)(v1 + 2908) + 20.0;
  *(float *)(v1 + 708) = *(float *)(v1 + 708) + 20.0;
  sub_10042820(v1 + 11828, (int)"RPM", dword_1031FB44 + 4076, 255.0, 10.0, 225.0, 225.0);
  sub_10042990(dword_1031FB44 + 20508, v1 + 11828);
  *(_WORD *)(v1 + 17402) = 6;
  *(_BYTE *)(v1 + 17408) = 1;
  *(_DWORD *)(v1 + 17404) = &unk_100B8DC0;
  v5 = sub_10062160(500.0, 100.0, -0.2, v1 + 11844);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 12.0, -0.2, v1 + 11844);
  sub_10060F20(v1 + 240, 1, v1 + 11844);
  sub_10060FA0(1500.0, "x100", 1.0, 12.0, -0.60000002, v5, v1 + 11844);
  v6 = *(float *)(v1 + 14148) + 20.0;
  *(_BYTE *)(v1 + 17400) = v5 + 1;
  *(float *)(v1 + 14148) = v6;
  *(float *)(v1 + 11948) = *(float *)(v1 + 11948) + 20.0;
  sub_10042820(v1 + 55572, (int)&word_100B8D60, dword_1031FB44 + 4568, 10.0, 255.0, 225.0, 225.0);
  *(float *)(v1 + 55808) = 140.0;
  *(float *)(v1 + 55812) = 240.0;
  *(float *)(v1 + 55912) = 100.0;
  *(float *)(v1 + 55620) = *(float *)(v1 + 55596) * 0.5;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4568), v1 + 55572);
  sub_10042990(dword_1031FB44 + 20592, v1 + 55572);
  sub_10060F20(v1 + 336, 1, v1 + 55588);
  *(float *)(v1 + 57928) = 18.0;
  v7 = *(float *)(v1 + 57888);
  *(_WORD *)(v1 + 61146) = 17;
  *(_BYTE *)(v1 + 61152) = 1;
  *(_DWORD *)(v1 + 61148) = &unk_100B8DC0;
  *(float *)(v1 + 57888) = v7 - 35.0;
  *(float *)(v1 + 55688) = *(float *)(v1 + 55688) - 35.0;
  *(float *)(v1 + 57892) = *(float *)(v1 + 57892) + 20.0;
  *(float *)(v1 + 55692) = *(float *)(v1 + 55692) + 15.0;
  sub_10062160(144.44446, 0.0, -0.2, v1 + 55588);
  sub_10042820(v1 + 66296, (int)"PSI", dword_1031FB44 + 4732, 10.0, 255.0, 225.0, 225.0);
  *(float *)(v1 + 66532) = 40.0;
  *(float *)(v1 + 66536) = -60.0;
  *(float *)(v1 + 66636) = -100.0;
  v8 = *(float *)(v1 + 66320) * 0.5;
  *(float *)(v1 + 66336) = *(float *)(v1 + 66312) + v8;
  *(float *)(v1 + 66344) = v8;
  sub_10042980((_BYTE *)(dword_1031FB44 + 4732), v1 + 66296);
  sub_10042990(dword_1031FB44 + 20620, v1 + 66296);
  sub_10060F20(v1 + 348, 1, v1 + 66312);
  *(float *)(v1 + 68652) = 18.0;
  v9 = *(float *)(v1 + 68612);
  *(_WORD *)(v1 + 71870) = 15;
  *(_BYTE *)(v1 + 71876) = 1;
  *(_DWORD *)(v1 + 71872) = &unk_100B8DC0;
  *(float *)(v1 + 68612) = v9 + 30.0;
  *(_DWORD *)(v1 + 71908) = 59;
  *(float *)(v1 + 66412) = *(float *)(v1 + 66412) + 30.0;
  *(float *)(v1 + 68616) = *(float *)(v1 + 68616) + 20.0;
  *(float *)(v1 + 66416) = *(float *)(v1 + 66416) + 15.0;
  sub_10062160(999740.12, 0.0, -0.2, v1 + 66312);
  sub_10042820(v1 + 23068, (int)"FFLOW GPH", dword_1031FB44 + 4240, 255.0, 255.0, 225.0, 225.0);
  sub_10042990(dword_1031FB44 + 20536, v1 + 23068);
  *(_WORD *)(v1 + 28642) = 33;
  *(_BYTE *)(v1 + 28648) = 1;
  *(_DWORD *)(v1 + 28644) = &unk_100B8DC0;
  sub_10062160(0.0052575162, 0.0026287581, -0.2, v1 + 23084);
  sub_10061F10(0.0052575162, "%.0f", 1.0, 12.0, -0.2, v1 + 23084);
  sub_10060F20(v1 + 252, 1, v1 + 23084);
  *(float *)(v1 + 25388) = *(float *)(v1 + 25388) + 20.0;
  *(float *)(v1 + 23188) = *(float *)(v1 + 23188) + 20.0;
  sub_10042820(v1 + 138360, (int)"L FUEL QTY", dword_1031FB44 + 5224, 32.0, 500.0, 180.0, 180.0);
  *(float *)(v1 + 138480) = *(float *)(v1 + 138480) + 15.0;
  *(_WORD *)(v1 + 143934) = 31;
  *(_BYTE *)(v1 + 143940) = 1;
  *(_DWORD *)(v1 + 143936) = &unk_100B8DC0;
  sub_100649E0(v1 + 138544, "GAL", 21);
  *(float *)(v1 + 138532) = *(float *)(v1 + 138532) + 30.0;
  sub_10060F20(v1 + 420, 0, v1 + 138376);
  v10 = sub_10062160(37.854118, 18.927059, -0.2, v1 + 138376);
  sub_10061FA0(*(float *)(v1 + 138396), -0.2, v10 - 1, v1 + 138376);
  sub_10061F10(37.854118, "%.0f", 1.0, 12.0, -0.2, v1 + 138376);
  sub_100649E0(v1 + 141088, "F", 2);
  sub_10042820(v1 + 143980, (int)"R FUEL QTY", dword_1031FB44 + 5224, 277.0, 500.0, 180.0, 180.0);
  *(float *)(v1 + 144100) = *(float *)(v1 + 144100) + 15.0;
  *(_WORD *)(v1 + 149554) = 31;
  *(_BYTE *)(v1 + 149560) = 1;
  *(_DWORD *)(v1 + 149556) = &unk_100B8DC0;
  sub_100649E0(v1 + 144164, "GAL", 21);
  *(float *)(v1 + 144152) = *(float *)(v1 + 144152) + 30.0;
  sub_10060F20(v1 + 432, 0, v1 + 143996);
  v11 = sub_10062160(37.854118, 18.927059, -0.2, v1 + 143996);
  sub_10061FA0(*(float *)(v1 + 144016), -0.2, v11 - 1, v1 + 143996);
  sub_10061F10(37.854118, "%.0f", 1.0, 12.0, -0.2, v1 + 143996);
  sub_100649E0(v1 + 146708, "F", 2);
  sub_100427E0(v1 + 33180, (int)"CHT F", dword_1031FB44 + 4404, 560.0, 115.0, 140.0, 180.0);
  sub_10041F10(dword_1031FB44 + 20564, v1 + 33180);
  sub_10047B10(v1 + 264, 6, 1, v1 + 33196);
  *(_WORD *)(v1 + 34160) = 17;
  *(_BYTE *)(v1 + 34168) = 1;
  *(_DWORD *)(v1 + 34164) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 34158) = -1;
  sub_10041CA0(27.777779, 0.0, 0.80000001, v1 + 33180);
  sub_10041C00(55.555557, 2, (int)"%.0f", 1.0, 12.0, v1 + 33180);
  *(float *)(v1 + 33304) = 55.0;
  *(float *)(v1 + 33300) = 630.0;
  *(float *)(v1 + 33340) = 0.5;
  sub_100427E0(v1 + 43716, (int)"EGT F", dword_1031FB44 + 5388, 850.0, 115.0, 140.0, 180.0);
  sub_10041F10(dword_1031FB44 + 20732, v1 + 43716);
  sub_10047B10(v1 + 444, 6, 1, v1 + 43732);
  *(_WORD *)(v1 + 44696) = 17;
  *(_BYTE *)(v1 + 44704) = 1;
  *(_DWORD *)(v1 + 44700) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 44694) = -1;
  sub_10041CA0(55.555557, 0.0, 0.80000001, v1 + 43716);
  sub_10041C00(55.555557, 1, (int)"%.0f", 1.0, 12.0, v1 + 43716);
  *(float *)(v1 + 43840) = *(float *)(v1 + 33304);
  *(float *)(v1 + 43836) = 920.0;
  *(float *)(v1 + 43876) = 0.5;
  sub_10046920(v1 + 54344, (int)" PEAK", dword_1031FB44 + 6372, 800.0, 65.0, 0.0, 15.0);
  sub_100465F0(v1 + 576, 1, v1 + 54344);
  *(float *)(v1 + 54560) = 0.5;
  *(_WORD *)(v1 + 54860) = 10;
  *(float *)(v1 + 54404) = 0.5;
  *(_BYTE *)(v1 + 54868) = 1;
  *(_DWORD *)(v1 + 54864) = &unk_100B8DC0;
  *(float *)(v1 + 54376) = *(float *)(v1 + 54376) + 21.0;
  sub_10044E50(v1 + 154092, (int)"TIT F", dword_1031FB44 + 5552, 850.0, 89.0, 40.0, 206.0);
  sub_10042DB0(dword_1031FB44 + 20760, v1 + 154092);
  sub_10042D60(v1 + 516, 1, 1, v1 + 154092);
  *(float *)(v1 + 154212) = *(float *)(v1 + 33304);
  *(_WORD *)(v1 + 165542) = 17;
  *(_BYTE *)(v1 + 165548) = 1;
  *(_DWORD *)(v1 + 165544) = &unk_100B8DC0;
  sub_10044300(27.777779, 0.0, 0.40000001, v1 + 154092);
  sub_10042C30(55.555557, "%.0f", 1.0, 9.0, v1 + 154092);
  sub_10044E50(v1 + 113824, (int)"ESS BUS", dword_1031FB44 + 6536, 545.0, 420.0, 30.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20928, v1 + 113824);
  sub_10042D60(v1 + 396, 1, 1, v1 + 113824);
  *(_WORD *)(v1 + 125274) = 21;
  *(_BYTE *)(v1 + 125280) = 1;
  *(_DWORD *)(v1 + 125276) = &unk_100C31AC;
  sub_10044300(33.0, 0.0, 0.40000001, v1 + 113824);
  sub_10044E50(v1 + 125480, (int)"EMER BATT", dword_1031FB44 + 6700, 645.0, 420.0, 30.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20956, v1 + 125480);
  sub_10042D60(v1 + 408, 1, 1, v1 + 125480);
  *(_WORD *)(v1 + 136930) = 21;
  *(_BYTE *)(v1 + 136936) = 1;
  *(_DWORD *)(v1 + 136932) = &unk_100C31AC;
  sub_10044300(33.0, 0.0, 0.40000001, v1 + 125480);
  sub_10044E50(v1 + 77020, (int)"MAIN ALT", dword_1031FB44 + 4896, 745.0, 420.0, 30.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20648, v1 + 77020);
  *(_WORD *)(v1 + 88470) = 22;
  *(_BYTE *)(v1 + 88476) = 1;
  *(_DWORD *)(v1 + 88472) = &unk_100C31A0;
  sub_10042D60(v1 + 360, 1, 1, v1 + 77020);
  *(float *)&v12 = *(float *)(v1 + 77044) - *(float *)(v1 + 77040);
  sub_10044300(*(float *)&v12, 0.0, 0.40000001, v1 + 77020);
  sub_10064F60(0.0, "%.0f", 1.0, 9.0, *(_WORD *)(v1 + 88470), v1 + 78352, 0);
  sub_10044E50(v1 + 88676, (int)"STBY ALT", dword_1031FB44 + 5060, 845.0, 420.0, 30.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20676, v1 + 88676);
  *(_WORD *)(v1 + 100126) = 22;
  *(_BYTE *)(v1 + 100132) = 1;
  *(_DWORD *)(v1 + 100128) = &unk_100C31A0;
  sub_10042D60(v1 + 372, 1, 1, v1 + 88676);
  sub_10044300(26.0, 0.0, 0.40000001, v1 + 88676);
  sub_10064F60(0.0, "%.0f", 1.0, 9.0, *(_WORD *)(v1 + 100126), v1 + 90008, 0);
  sub_10044E50(v1 + 100332, (int)"BATT", dword_1031FB44 + 5716, 945.0, 420.0, 30.0, 95.0);
  sub_10042DB0(dword_1031FB44 + 20788, v1 + 100332);
  sub_10042D60(v1 + 384, 1, 1, v1 + 100332);
  *(_WORD *)(v1 + 111782) = 22;
  *(_BYTE *)(v1 + 111788) = 1;
  *(_DWORD *)(v1 + 111784) = &unk_100C31A0;
  sub_10044300(100.0, 0.0, 0.40000001, v1 + 100332);
  sub_10044260(0.0, 0.40000001, v1 + 100332);
  sub_10064F60(0.0, "%.0f", 1.0, 9.0, *(_WORD *)(v1 + 111782), v1 + 101664, 2);
  sub_10046920(v1 + 174736, (int)"GAL REM", dword_1031FB44 + 6044, 570.0, 595.0, 0.0, 15.0);
  *(_WORD *)(v1 + 175252) = 31;
  *(_BYTE *)(v1 + 175260) = 1;
  *(_DWORD *)(v1 + 175256) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 174784) = v1 + 544;
  *(float *)(v1 + 174952) = 0.5;
  *(float *)(v1 + 174768) = *(float *)(v1 + 174768) + 3.0;
  *(float *)(v1 + 174796) = 0.5;
  *(float *)(v1 + 174800) = 0.0;
  sub_10046920(v1 + 175960, (int)"GAL USED", dword_1031FB44 + 6044, 570.0, 645.0, 0.0, 15.0);
  *(_WORD *)(v1 + 176476) = 31;
  *(_DWORD *)(v1 + 176480) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 176484) = 1;
  *(_DWORD *)(v1 + 176008) = v1 + 556;
  *(float *)(v1 + 176176) = 0.5;
  *(float *)(v1 + 175992) = *(float *)(v1 + 175992) + 3.0;
  *(float *)(v1 + 176020) = 0.5;
  *(float *)(v1 + 176024) = 0.0;
  *(_WORD *)(v1 + 177184) = 4142;
  *(_DWORD *)(v1 + 177188) = -1;
  *(_DWORD *)(v1 + 177192) = 0;
  *(float *)(v1 + 177196) = 15.0;
  *(float *)(v1 + 177200) = 60.0;
  *(_DWORD *)(v1 + 177204) = sub_10065060(*(float *)(v1 + 177196));
  *(float *)(v1 + 177208) = 0.5;
  *(float *)(v1 + 177212) = 0.0;
  *(_DWORD *)(v1 + 177216) = 0x7FFFFFFF;
  *(float *)(v1 + 177220) = 690.0;
  *(float *)(v1 + 177224) = 598.0;
  sub_10046920(v1 + 177308, (int)"RANGE NM", dword_1031FB44 + 6208, 690.0, 645.0, 0.0, 15.0);
  *(_WORD *)(v1 + 177824) = 38;
  *(_BYTE *)(v1 + 177832) = 1;
  *(_DWORD *)(v1 + 177828) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 177356) = v1 + 568;
  *(float *)(v1 + 177524) = 0.5;
  *(float *)(v1 + 177340) = *(float *)(v1 + 177340) + 3.0;
  *(float *)(v1 + 177368) = 0.5;
  *(float *)(v1 + 177372) = 0.0;
  sub_10042820(v1 + 177920, (int)"CABIN F", dword_1031FB44 + 5880, 830.0, 545.0, 130.0, 130.0);
  *(_WORD *)(v1 + 183494) = 17;
  *(_BYTE *)(v1 + 183500) = 1;
  *(_DWORD *)(v1 + 183496) = &unk_100B8DC0;
  sub_10060F20(v1 + 528, 1, v1 + 177936);
  sub_10042990(dword_1031FB44 + 20816, v1 + 177920);
  *(float *)(v1 + 180276) = 15.0;
  sub_10062160(22.222223, 5.5555558, -0.2, v1 + 177936);
  sub_10061F10(22.222223, "%.0f", 1.0, 9.0, -0.2, v1 + 177936);
  *(float *)(v1 + 178040) = *(float *)(v1 + 178040) + 3.0;
  *(float *)(v1 + 180240) = *(float *)(v1 + 180240) + 3.0;
  sub_100428D0(v1 + 6208, (int)"MAN IN", dword_1031FB44 + 3912, -7.0, -10.0, 160.0, 160.0);
  sub_10042990(dword_1031FB44 + 20480, v1 + 6208);
  *(_WORD *)(v1 + 11782) = 5;
  *(_BYTE *)(v1 + 11788) = 1;
  *(_DWORD *)(v1 + 11784) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 11825) = 1;
  sub_10060F20(v1 + 228, 1, v1 + 6224);
  sub_10062160(16931.934, 0.0, -0.2, v1 + 6224);
  sub_10061F10(16931.934, "%.0f", 1.0, 9.0, -0.2, v1 + 6224);
  sub_100428D0(v1 + 17448, (int)"RPM", dword_1031FB44 + 4076, -7.0, 105.0, 160.0, 160.0);
  sub_10042990(dword_1031FB44 + 20508, v1 + 17448);
  *(_WORD *)(v1 + 23022) = 6;
  *(_BYTE *)(v1 + 23028) = 1;
  *(_DWORD *)(v1 + 23024) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 23065) = 1;
  v13 = sub_10062160(500.0, 0.0, -0.2, v1 + 17464);
  sub_10061F10(500.0, "%.0f", 0.0099999998, 9.0, -0.2, v1 + 17464);
  sub_10060F20(v1 + 240, 1, v1 + 17464);
  sub_10060FA0(1500.0, "x100", 1.0, 9.0, -0.55000001, v13, v1 + 17464);
  *(_BYTE *)(v1 + 23020) = v13 + 1;
  sub_1004A1A0(v1 + 61192, (int)"OIL F", dword_1031FB44 + 4568, 5.0, 404.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20592, v1 + 61192);
  sub_10049040(v1 + 336, 1, 1, v1 + 61192);
  sub_10049630((float *)(v1 + 61192));
  *(_WORD *)(v1 + 65504) = 17;
  *(_BYTE *)(v1 + 65512) = 1;
  *(_DWORD *)(v1 + 65508) = &unk_100B8DC0;
  sub_1004A660(144.44446, 0.0, -0.80000001, v1 + 61192);
  sub_1004A1A0(v1 + 71916, (int)"OIL PSI", dword_1031FB44 + 4732, 5.0, 459.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20620, v1 + 71916);
  sub_10049040(v1 + 348, 1, 1, v1 + 71916);
  sub_10049630((float *)(v1 + 71916));
  *(_WORD *)(v1 + 76228) = 15;
  *(_BYTE *)(v1 + 76236) = 1;
  *(_DWORD *)(v1 + 76232) = &unk_100B8DC0;
  sub_1004A660(999740.12, 0.0, -0.80000001, v1 + 71916);
  sub_1004A1A0(v1 + 28688, (int)"FFLOW GPH", dword_1031FB44 + 4240, 5.0, 339.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20536, v1 + 28688);
  sub_10049630((float *)(v1 + 28688));
  *(_WORD *)(v1 + 33000) = 33;
  *(_BYTE *)(v1 + 33008) = 1;
  *(_DWORD *)(v1 + 33004) = &unk_100B8DC0;
  sub_10049040(v1 + 252, 1, 1, v1 + 28688);
  sub_1004A660(0.0052575162, 0.0026287581, -0.80000001, v1 + 28688);
  v14 = *(float *)(v1 + 28712) - *(float *)(v1 + 28708);
  if ( *(_BYTE *)(v1 + 174732) )
  {
    *(float *)&v15 = v14 * 0.3333333432674408;
    v16 = *(float *)&v15;
  }
  else
  {
    *(float *)&v17 = v14 * 0.25;
    v16 = *(float *)&v17;
  }
  v18 = v16;
  sub_100488B0(v18, "%.0f", 1.0, 9.0, v1 + 28688);
  sub_1004A1E0(v1 + 149600, (int)"FUEL QTY GAL", dword_1031FB44 + 5224, 5.0, 255.0, 135.0, 37.0, 0);
  *(_WORD *)(v1 + 153912) = 31;
  *(_BYTE *)(v1 + 153920) = 1;
  *(_DWORD *)(v1 + 153916) = &unk_100B8DC0;
  sub_10049630((float *)(v1 + 149600));
  sub_10049040(v1 + 420, 2, 0, v1 + 149600);
  v19 = sub_1004A630(37.854118, 0.0, -0.40000001, v1 + 149600);
  v20 = v19;
  v21 = v19 / 2;
  sub_10065690(193.056, 0.40000001, 1.0, v1 + 150436, v19 / 2 - 1, v1 + 153792);
  sub_10065690(193.056, -0.40000001, 1.0, v1 + 150436, v20 - 1, v1 + 153792);
  sub_100488B0(37.854118, "%.0f", 1.0, 9.0, v1 + 149600);
  sub_100649E0((v21 << 6) + v1 + 150408, "F", 2);
  sub_1004A1A0(v1 + 37976, (int)"CHT F", dword_1031FB44 + 4404, 5.0, 569.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20564, v1 + 37976);
  sub_10049040(v1 + 264, 1, 1, v1 + 37976);
  sub_10049630((float *)(v1 + 37976));
  *(_WORD *)(v1 + 42288) = 17;
  *(_BYTE *)(v1 + 42296) = 1;
  *(_DWORD *)(v1 + 42292) = &unk_100B8DC0;
  sub_1004A660(250.00002, 0.0, -0.80000001, v1 + 37976);
  sub_1004A1A0(v1 + 48512, (int)"EGT F", dword_1031FB44 + 5388, 5.0, 514.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20732, v1 + 48512);
  sub_10049040(v1 + 444, 6, 1, v1 + 48512);
  sub_10049630((float *)(v1 + 48512));
  *(_WORD *)(v1 + 52824) = 17;
  *(_BYTE *)(v1 + 52832) = 1;
  *(_DWORD *)(v1 + 52828) = &unk_100B8DC0;
  sub_1004A660(333.33334, 0.0, -0.80000001, v1 + 48512);
  sub_1004A1A0(v1 + 165748, (int)"TIT F", dword_1031FB44 + 5552, 5.0, 514.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20760, v1 + 165748);
  sub_10049040(v1 + 516, 1, 1, v1 + 165748);
  *(_WORD *)(v1 + 170060) = 17;
  *(_BYTE *)(v1 + 170068) = 1;
  sub_10049630((float *)(v1 + 165748));
  v22 = *(float *)(v1 + 165772) - *(float *)(v1 + 165768);
  sub_1004A660(v22, 0.0, -0.80000001, v1 + 165748);
  sub_10046920(v1 + 137136, (int)"ESS BUS", dword_1031FB44 + 6536, 5.0, 647.0, 135.0, 15.0);
  sub_100465F0(v1 + 396, 1, v1 + 137136);
  sub_10046630(dword_1031FB44 + 20928, v1 + 137136);
  *(_WORD *)(v1 + 137652) = 21;
  *(_BYTE *)(v1 + 137660) = 1;
  *(_DWORD *)(v1 + 137656) = &unk_100C3168;
  sub_10046920(v1 + 137748, (int)"EMER BATT", dword_1031FB44 + 6700, 5.0, 624.0, 135.0, 15.0);
  sub_100465F0(v1 + 408, 1, v1 + 137748);
  sub_10046630(dword_1031FB44 + 20956, v1 + 137748);
  *(_WORD *)(v1 + 138264) = 21;
  *(_BYTE *)(v1 + 138272) = 1;
  *(_DWORD *)(v1 + 138268) = &unk_100C3168;
  sub_10046920(v1 + 111988, (int)"MAIN ALT", dword_1031FB44 + 4896, 5.0, 670.0, 135.0, 15.0);
  sub_100465F0(v1 + 360, 1, v1 + 111988);
  sub_10046630(dword_1031FB44 + 20648, v1 + 111988);
  *(_WORD *)(v1 + 112504) = 22;
  *(_BYTE *)(v1 + 112512) = 1;
  *(_DWORD *)(v1 + 112508) = &unk_100C3160;
  sub_10046920(v1 + 112600, (int)"STBY ALT", dword_1031FB44 + 5060, 5.0, 670.0, 135.0, 15.0);
  sub_100465F0(v1 + 372, 1, v1 + 112600);
  sub_10046630(dword_1031FB44 + 20676, v1 + 112600);
  *(_WORD *)(v1 + 113116) = 22;
  *(_BYTE *)(v1 + 113124) = 1;
  *(_DWORD *)(v1 + 113120) = &unk_100C3160;
  sub_10048850(v1 + 42468, (int)"CHT F", dword_1031FB44 + 4404, 5.0, 550.0, 140.0, 100.0);
  sub_10047B60(dword_1031FB44 + 20564, v1 + 42468);
  sub_10047B10(v1 + 264, 6, 1, v1 + 42468);
  *(_WORD *)(v1 + 43432) = 17;
  *(_BYTE *)(v1 + 43440) = 1;
  *(_DWORD *)(v1 + 43436) = &unk_100B8DC0;
  sub_10048850(v1 + 53004, (int)"EGT F", dword_1031FB44 + 5388, 5.0, 405.0, 140.0, 100.0);
  sub_10047B60(dword_1031FB44 + 20732, v1 + 53004);
  sub_10047B10(v1 + 444, 6, 1, v1 + 53004);
  *(_WORD *)(v1 + 53968) = 17;
  *(_BYTE *)(v1 + 53976) = 1;
  *(_DWORD *)(v1 + 53972) = &unk_100B8DC0;
  sub_1004A1A0(v1 + 170240, (int)"TIT F", dword_1031FB44 + 5552, 5.0, 405.0, 135.0, 18.0, 0);
  sub_100490F0(dword_1031FB44 + 20760, v1 + 170240);
  sub_10049040(v1 + 516, 1, 1, v1 + 170240);
  *(_WORD *)(v1 + 174552) = 17;
  *(_BYTE *)(v1 + 174560) = 1;
  sub_10049630((float *)(v1 + 170240));
  v23 = *(float *)(v1 + 170264) - *(float *)(v1 + 170260);
  sub_1004A660(v23, 0.0, -0.80000001, v1 + 170240);
  sub_10046920(v1 + 54956, (int)" PEAK", dword_1031FB44 + 6372, 5.0, 397.0, 135.0, 15.0);
  sub_100465F0(v1 + 576, 1, v1 + 54956);
  *(_WORD *)(v1 + 55472) = 10;
  *(_BYTE *)(v1 + 55480) = 1;
  *(_DWORD *)(v1 + 55476) = &unk_100B8DC0;
  sub_10046920(v1 + 175348, (int)"GAL REM", dword_1031FB44 + 6044, 5.0, 453.0, 135.0, 15.0);
  *(_DWORD *)(v1 + 175396) = v1 + 544;
  *(_WORD *)(v1 + 175864) = 31;
  *(_BYTE *)(v1 + 175872) = 1;
  *(_DWORD *)(v1 + 175868) = &unk_100B8DC0;
  sub_10046920(v1 + 176572, (int)"GAL USED", dword_1031FB44 + 6044, 5.0, 430.0, 135.0, 15.0);
  *(_DWORD *)(v1 + 176620) = v1 + 556;
  *(_WORD *)(v1 + 177088) = 31;
  *(_DWORD *)(v1 + 177092) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 177096) = 1;
  sub_10046920(v1 + 76408, (int)"OIL PSI", dword_1031FB44 + 4732, 5.0, 518.0, 135.0, 15.0);
  sub_100465F0(v1 + 348, 1, v1 + 76408);
  sub_10046630(dword_1031FB44 + 20620, v1 + 76408);
  *(_WORD *)(v1 + 76924) = 15;
  *(_BYTE *)(v1 + 76932) = 1;
  *(_DWORD *)(v1 + 76928) = &unk_100B8DC0;
  sub_10046920(v1 + 65684, (int)"OIL F", dword_1031FB44 + 4568, 5.0, 541.0, 135.0, 15.0);
  sub_100465F0(v1 + 336, 1, v1 + 65684);
  sub_10046630(dword_1031FB44 + 20592, v1 + 65684);
  *(_WORD *)(v1 + 66200) = 17;
  *(_BYTE *)(v1 + 66208) = 1;
  *(_DWORD *)(v1 + 66204) = &unk_100B8DC0;
  sub_10046920(v1 + 183540, (int)"CABIN F", dword_1031FB44 + 5880, 5.0, 564.0, 135.0, 15.0);
  sub_100465F0(v1 + 528, 1, v1 + 183540);
  sub_10046630(dword_1031FB44 + 20816, v1 + 183540);
  *(_WORD *)(v1 + 184056) = 17;
  *(_BYTE *)(v1 + 184064) = 1;
  *(_DWORD *)(v1 + 184060) = &unk_100B8DC0;
  sub_10046920(v1 + 113212, (int)"BATT", dword_1031FB44 + 5716, 5.0, 601.0, 135.0, 15.0);
  sub_100465F0(v1 + 384, 1, v1 + 113212);
  result = sub_10046630(dword_1031FB44 + 20788, v1 + 113212);
  *(_WORD *)(v1 + 113728) = 22;
  *(_BYTE *)(v1 + 113736) = 1;
  *(_DWORD *)(v1 + 113732) = &unk_100C3160;
  if ( *(_BYTE *)(v1 + 174732) )
  {
    result = sub_10061FA0(*(float *)(v1 + 6244), -0.2, *(_BYTE *)(v1 + 11780), v1 + 6224);
    ++*(_BYTE *)(v1 + 11780);
  }
  return result;
}
// 100B8D60: using guessed type __int16 word_100B8D60;
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002B9B0) --------------------------------------------------------
char __usercall sub_1002B9B0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  char v2; // ST0C_1@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 55568) = 0;
  *(_BYTE *)(v1 + 195) = 0;
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 184158) = v2;
  sub_1004C170(v2);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1002B9F0) --------------------------------------------------------
char __usercall sub_1002B9F0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  bool v2; // al@3
  bool v3; // al@5
  signed int v4; // eax@9
  void *v5; // ecx@14
  char result; // al@16

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 184196, 0);
  v2 = *(_BYTE *)dword_1031FB44 == 9 || *(_BYTE *)dword_1031FB44 == 11;
  *(_BYTE *)(v1 + 174732) = v2;
  *(_BYTE *)(v1 + 184156) = 0;
  v3 = *(_DWORD *)(a1 + 64) == 9;
  *(_BYTE *)(v1 + 184157) = v3;
  if ( v3 )
  {
    sub_100522C0(1);
    sub_100011B0(a1, 0, 0, 1024, 686, 3);
    sub_10032790(a1, &unk_100C2E30, 4u, 3, 1u);
    if ( *(_BYTE *)(v1 + 174732) )
      sub_10032270(a1, 0x40u, 2);
  }
  else
  {
    sub_100011B0(a1, 0, 0, 151, 686, 3);
  }
  v4 = sub_1004BF40();
  if ( v4 == 0x7FFFFFFF )
    v4 = 0;
  *(_DWORD *)(v1 + 177228) = v4;
  *(_DWORD *)(v1 + 177232) = v4;
  *(_DWORD *)(v1 + 177236) = v4;
  *(_DWORD *)(v1 + 177240) = v4;
  *(_DWORD *)(v1 + 177244) = v4;
  *(_DWORD *)(v1 + 177248) = v4;
  *(_DWORD *)(v1 + 177252) = v4;
  *(_DWORD *)(v1 + 177256) = v4;
  *(_DWORD *)(v1 + 177260) = v4;
  *(_DWORD *)(v1 + 177264) = v4;
  *(_DWORD *)(v1 + 177268) = v4;
  *(_DWORD *)(v1 + 177272) = v4;
  *(_DWORD *)(v1 + 177276) = v4;
  *(_DWORD *)(v1 + 177280) = v4;
  *(_DWORD *)(v1 + 177284) = v4;
  *(_DWORD *)(v1 + 177288) = v4;
  *(_DWORD *)(v1 + 177292) = v4;
  *(_DWORD *)(v1 + 177296) = v4;
  *(_DWORD *)(v1 + 177300) = v4;
  *(_DWORD *)(v1 + 177304) = v4;
  *(_BYTE *)(v1 + 55568) = 0;
  sub_1004CCA0(v1 + 54252, 1);
  *(_DWORD *)(v1 + 54256) = v1 + 448;
  *(_DWORD *)(v1 + 54260) = v1 + 460;
  *(_DWORD *)(v1 + 54264) = v1 + 472;
  *(_DWORD *)(v1 + 54268) = v1 + 484;
  *(_DWORD *)(v1 + 54272) = v1 + 496;
  *(_DWORD *)(v1 + 54276) = v1 + 508;
  *(_DWORD *)(v1 + 54280) = v1 + 256;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_DWORD *)v1 = v1 + 588;
  *(_DWORD *)(v1 + 4) = v1 + 11828;
  *(_DWORD *)(v1 + 8) = v1 + 55572;
  *(_DWORD *)(v1 + 12) = v1 + 66296;
  *(_DWORD *)(v1 + 16) = v1 + 23068;
  *(_DWORD *)(v1 + 20) = v1 + 138360;
  *(_DWORD *)(v1 + 24) = v1 + 143980;
  *(_DWORD *)(v1 + 28) = v1 + 33180;
  *(_DWORD *)(v1 + 32) = v1 + 43716;
  *(_DWORD *)(v1 + 36) = v1 + 154092;
  *(_DWORD *)(v1 + 40) = v1 + 54344;
  *(_DWORD *)(v1 + 52) = v1 + 77020;
  *(_DWORD *)(v1 + 56) = v1 + 88676;
  *(_DWORD *)(v1 + 60) = v1 + 100332;
  *(_DWORD *)(v1 + 44) = v1 + 113824;
  *(_DWORD *)(v1 + 48) = v1 + 125480;
  *(_DWORD *)(v1 + 64) = v1 + 174736;
  *(_DWORD *)(v1 + 68) = v1 + 175960;
  *(_DWORD *)(v1 + 72) = v1 + 177184;
  *(_DWORD *)(v1 + 76) = v1 + 177308;
  *(_DWORD *)(v1 + 80) = v1 + 177920;
  *(_DWORD *)(v1 + 84) = 50529027;
  *(_DWORD *)(v1 + 88) = 50529027;
  *(_DWORD *)(v1 + 92) = 50529027;
  *(_DWORD *)(v1 + 96) = 50529027;
  *(_DWORD *)(v1 + 100) = 50529027;
  *(_BYTE *)(v1 + 104) = 3;
  *(_DWORD *)(v1 + 108) = v1 + 6208;
  *(_DWORD *)(v1 + 112) = v1 + 17448;
  *(_BYTE *)(v1 + 94) = 0;
  *(_DWORD *)(v1 + 120) = v1 + 28688;
  *(_DWORD *)(v1 + 116) = v1 + 149600;
  *(_DWORD *)(v1 + 124) = 50529027;
  *(_DWORD *)(v1 + 128) = v1 + 61192;
  *(_DWORD *)(v1 + 132) = v1 + 71916;
  *(_DWORD *)(v1 + 140) = v1 + 37976;
  *(_DWORD *)(v1 + 136) = v1 + 48512;
  *(_DWORD *)(v1 + 144) = v1 + 165748;
  *(_DWORD *)(v1 + 148) = 50529027;
  *(_BYTE *)(v1 + 152) = 3;
  *(_DWORD *)(v1 + 164) = v1 + 111988;
  *(_DWORD *)(v1 + 168) = v1 + 112600;
  *(_DWORD *)(v1 + 160) = v1 + 137136;
  *(_DWORD *)(v1 + 156) = v1 + 137748;
  *(_DWORD *)(v1 + 172) = 50529027;
  *(_DWORD *)(v1 + 176) = v1 + 53004;
  *(_DWORD *)(v1 + 180) = v1 + 42468;
  *(_DWORD *)(v1 + 184) = v1 + 170240;
  *(_DWORD *)(v1 + 188) = v1 + 54956;
  *(_BYTE *)(v1 + 175) = 0;
  *(_DWORD *)(v1 + 192) = 50529027;
  *(_DWORD *)(v1 + 196) = v1 + 176572;
  *(_DWORD *)(v1 + 200) = v1 + 175348;
  *(_DWORD *)(v1 + 204) = v1 + 76408;
  *(_DWORD *)(v1 + 208) = v1 + 65684;
  *(_BYTE *)(v1 + 195) = 0;
  *(_DWORD *)(v1 + 212) = v1 + 183540;
  *(_DWORD *)(v1 + 216) = v1 + 113212;
  *(_DWORD *)(v1 + 220) = 50529027;
  *(_WORD *)(v1 + 224) = 771;
  if ( *(_BYTE *)(v1 + 174732) )
  {
    *(_BYTE *)(v1 + 92) = 0;
    *(_BYTE *)(v1 + 150) = 0;
    *(_BYTE *)(v1 + 192) = 0;
  }
  else
  {
    *(_BYTE *)(v1 + 93) = 0;
    *(_BYTE *)(v1 + 152) = 0;
    *(_BYTE *)(v1 + 194) = 0;
  }
  sub_10029710(a1);
  *(_DWORD *)(v1 + 184152) = 0;
  if ( *(_DWORD *)(a1 + 64) == 5 )
    sub_1008CB30(9138, v1 + 184152, 4);
  *(_BYTE *)(v1 + 184158) = sub_1004BF10(v5);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C2FE0, v1, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C308C, v1 + 128, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C30B8, v1 + 156, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C30DC, v1 + 176, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3100, v1 + 196, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C2FBC, v1 + 108, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 100);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002BEF0) --------------------------------------------------------
int __usercall sub_1002BEF0@<eax>(char a1@<al>, int a2@<edi>)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  if ( *(_BYTE *)(v2 + 184157) )
  {
    if ( a1 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C2F1C, (int)&unk_100C3134, 0, 255);
      sub_1006BEE0((int)"TEMPERATURE", 510.0, 20.0, 500.0, 300.0);
      sub_1006BEE0((int)"ELECTRICAL", 510.0, 355.0, 500.0, 175.0);
      sub_1006BEE0((int)"FUEL CALC", 510.0, 565.0, 240.0, 110.0);
      *(float *)(v2 + 184160) = 690.0;
      *(float *)(v2 + 184164) = 595.0;
      sub_10065670((int)"ENDUR", v2 + 184160);
    }
    sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C2FE0, v2, v2 + 84, 255);
    *(float *)(v2 + 184160) = 122.5;
    *(float *)(v2 + 184164) = 395.625;
    result = sub_10065670((int)"OIL", v2 + 184160);
  }
  else
  {
    if ( a1 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C2FA8, (int)&unk_100C313C, 0, 255);
      sub_100682A0(151.0, 0.0, 151.0, 686.0, -1, 1.0);
    }
    sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C2FBC, v2 + 108, v2 + 124, 255);
    if ( *(_BYTE *)(v2 + 184158) == 1 )
    {
      result = sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C30DC, v2 + 176, v2 + 192, 255);
    }
    else if ( *(_BYTE *)(v2 + 184158) == 2 )
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C3100, v2 + 196, v2 + 220, 255);
      sub_100682A0(5.0, 401.0, 30.0, 401.0, -1, 1.0);
      sub_100682A0(115.0, 401.0, 146.0, 401.0, -1, 1.0);
      *(float *)(v2 + 184160) = 72.0;
      *(float *)(v2 + 184164) = 407.0;
      *(float *)(v2 + 184184) = 0.5;
      sub_10065670((int)"FUEL CALC", v2 + 184160);
      result = sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C30B8, v2 + 156, v2 + 172, 255);
    }
    else
    {
      sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C308C, v2 + 128, v2 + 148, 255);
      result = sub_100653C0(a2, *(_WORD **)(a2 + 52), (char *)&unk_100C30B8, v2 + 156, v2 + 172, 255);
    }
  }
  return result;
}

//----- (1002C200) --------------------------------------------------------
char __usercall sub_1002C200@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 43808) = 0;
  *(_DWORD *)(v1 + 53080) = 0;
  *(_DWORD *)(v1 + 43812) = 0;
  *(_DWORD *)(v1 + 53084) = 0;
  *(_DWORD *)(v1 + 43816) = 0;
  *(_DWORD *)(v1 + 53088) = 0;
  *(_DWORD *)(v1 + 43820) = 0;
  *(_DWORD *)(v1 + 53092) = 0;
  *(_DWORD *)(v1 + 43824) = 0;
  *(_DWORD *)(v1 + 53096) = 0;
  *(_DWORD *)(v1 + 43828) = 0;
  *(_DWORD *)(v1 + 53100) = 0;
  return sub_1004CCA0(v1 + 54252, 1);
}

//----- (1002C270) --------------------------------------------------------
char __usercall sub_1002C270@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@2
  signed int v3; // edi@3
  int v4; // esi@3
  signed int v5; // ebx@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1002C200(a1);
  if ( *(_BYTE *)(v1 + 55568) == 2 )
  {
    v3 = 1;
    *(_BYTE *)(v1 + 55568) = 0;
    *(_BYTE *)(v1 + 94) = 0;
    *(_BYTE *)(v1 + 195) = 0;
    v4 = v1 + 43936;
    v5 = 6;
    do
    {
      sprintf((char *)(v4 - 32), "%d", v3);
      *(float *)v4 = 9.0;
      result = sprintf((char *)(v4 + 9240), "%d", v3);
      *(float *)(v4 + 9272) = 9.0;
      ++v3;
      v4 += 52;
      --v5;
    }
    while ( v5 );
  }
  else
  {
    *(_BYTE *)(v1 + 55568) = 2;
    result = 3;
    *(_BYTE *)(v1 + 94) = 3;
    *(_BYTE *)(v1 + 195) = 3;
  }
  return result;
}

//----- (1002C310) --------------------------------------------------------
char __usercall sub_1002C310@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@2
  float v3; // ST20_4@3
  double v4; // st7@3
  float v5; // ST20_4@5
  double v6; // st7@5
  float v7; // ST20_4@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 55568) )
  {
    result = *(_BYTE *)(v1 + 55568) - 2;
    if ( *(_BYTE *)(v1 + 55568) == 2 )
    {
      sub_10047850(v1 + 54252, v1 + 43732);
      sub_10047850(v1 + 54252, v1 + 53004);
      v3 = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 54286) + 448) - *(float *)(v1 + 4 * *(_BYTE *)(v1 + 54286) + 54296);
      v4 = v3;
      if ( v3 > 0.0 )
        v4 = 0.0;
      v5 = v4;
      v6 = v5;
      *(float *)(v1 + 580) = v5;
      if ( v5 <= -500.0 )
        v6 = -500.0;
      v7 = v6;
      *(float *)(v1 + 580) = v7 * 1.799999952316284;
      result = sub_10066EE0(v1 + 228, 3u, 6u);
      *(_BYTE *)(v1 + 43430) = result;
    }
  }
  else
  {
    *(_BYTE *)(v1 + 44694) = -1;
    *(_BYTE *)(v1 + 53966) = sub_10066EE0(v1 + 228, 0x12u, 6u);
    result = sub_10066EE0(v1 + 228, 3u, 6u);
    *(_BYTE *)(v1 + 43430) = result;
  }
  return result;
}

//----- (1002C410) --------------------------------------------------------
char __cdecl sub_1002C410(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  float *v3; // eax@1
  signed int v4; // ecx@1
  unsigned int v5; // esi@3
  double v6; // st7@4
  int v7; // eax@4
  int v8; // edx@11
  int v9; // ecx@11
  int v10; // eax@11
  int *v11; // esi@18
  unsigned int v12; // edx@26
  char result; // al@26
  char v14; // dl@27
  float v15; // [sp+0h] [bp-1Ch]@0
  float v16; // [sp+10h] [bp-Ch]@5
  __int64 v17; // [sp+14h] [bp-8h]@26
  float v18; // [sp+20h] [bp+4h]@13

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = (float *)(v2 + 232);
  v4 = 30;
  do
  {
    *v3 = 9.8999998e24;
    v3 += 3;
    --v4;
  }
  while ( v4 );
  v5 = 0;
  do
  {
    v6 = sub_1004C3E0(word_100C2EC2[v5]);
    v7 = (unsigned __int8)byte_100C2EC0[v5 * 2];
    v5 += 2;
    *(float *)(v2 + 12 * v7 + 232) = v6;
  }
  while ( v5 < 46 );
  sub_1004A690(v2 + 264, 6u, v2 + 37976);
  if ( sub_100664A0(&v16) )
    *(float *)(v2 + 424) = v16;
  if ( sub_10066510(&v16) )
    *(float *)(v2 + 436) = v16;
  if ( sub_100663D0(&v16) )
    *(float *)(v2 + 256) = v16;
  *(float *)(v2 + 544) = sub_1004C0C0();
  *(float *)(v2 + 556) = sub_1004C0D0(v9, v8);
  v10 = sub_1004BF40();
  *(_DWORD *)(v2 + 177216) = v10;
  if ( v10 != 0x7FFFFFFF )
    *(_DWORD *)(v2 + 177216) = sub_100296D0(v2 + 177228, 0x14u, v10);
  v18 = sub_1004BFF0(v15);
  *(float *)(v2 + 568) = v18;
  if ( 9.8999998e24 == v18 )
    *(float *)(v2 + 568) = -1.0;
  sub_1002C310(v1);
  sub_1004C380(v2 + 228, 0x1Eu);
  if ( *(float *)(v2 + 248) >= 500.0 )
  {
    *(_BYTE *)(v2 + 2580) = *(_BYTE *)(dword_1031FB44 + 4005);
    *(_BYTE *)(v2 + 8200) = *(_BYTE *)(dword_1031FB44 + 4005);
    *(_BYTE *)(v2 + 68280) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v2 + 72292) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v2 + 76848) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v2 + 114316) = *(_BYTE *)(dword_1031FB44 + 6628);
    *(_BYTE *)(v2 + 137576) = *(_BYTE *)(dword_1031FB44 + 6628);
  }
  else
  {
    *(_BYTE *)(v2 + 2580) = 10;
    *(_BYTE *)(v2 + 8200) = 10;
    *(_BYTE *)(v2 + 68280) = 10;
    *(_BYTE *)(v2 + 72292) = 10;
    *(_BYTE *)(v2 + 76848) = 10;
    *(_BYTE *)(v2 + 114316) = 10;
    *(_BYTE *)(v2 + 137576) = 10;
  }
  v11 = (int *)(v2 + 184152);
  sub_1008CA60(9138, v2 + 184152, 4);
  if ( *(_DWORD *)(v1 + 64) == 5 )
  {
    if ( !*v11 && *(float *)(dword_1031FB44 + 5072) < (double)*(float *)(v2 + 380) )
    {
      *v11 = sub_1008C780();
LABEL_24:
      sub_1008CB30(9138, v2 + 184152, 4);
      goto LABEL_25;
    }
    if ( *(float *)(dword_1031FB44 + 5072) >= (double)*(float *)(v2 + 380) )
    {
      *v11 = 0;
      goto LABEL_24;
    }
  }
LABEL_25:
  if ( *v11
    && (v12 = sub_1008C780() - *v11,
        v17 = (signed __int64)*(float *)(dword_1031FB44 + 6872),
        result = -24 * v17,
        v12 > 1000 * (signed int)v17) )
  {
    v14 = *(_BYTE *)(dword_1031FB44 + 5153);
    *(_BYTE *)(v2 + 89176) = v14;
    *(_BYTE *)(v2 + 113048) = v14;
  }
  else
  {
    result = 10;
    *(_BYTE *)(v2 + 89176) = 10;
    *(_BYTE *)(v2 + 113048) = 10;
  }
  return result;
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100C2EC2: using guessed type __int16 word_100C2EC2[];
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002C720) --------------------------------------------------------
char __usercall sub_1002C720@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@5
  int v3; // ST04_4@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( *(_BYTE *)(v1 + 55568) != 2 )
    {
      v2 = (unsigned __int8)(*(_BYTE *)(v1 + 53966) + 1) % 6;
      *(_BYTE *)(v1 + 55568) = 1;
      *(_BYTE *)(v1 + 53966) = v2;
      *(_BYTE *)(v1 + 43430) = v2;
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    sub_1002C270(a1);
  }
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v3, -32734);
}

//----- (1002C860) --------------------------------------------------------
char __cdecl sub_1002C860(int a1)
{
  int v1; // esi@6
  float *v2; // ecx@21
  char result; // al@1

  result = a1;
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      result = sub_1002BEF0(0, a1);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8018:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 184157) )
        result = sub_100522C0(0);
      break;
    case 0x8041:
      result = sub_1002B9F0(a1);
      break;
    case 0x8022:
    case 0x8078:
      v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_1002C410(a1);
      v2 = *(float **)(v1 + 88716);
      if ( 9.8999998e24 == *v2 || *(float *)(dword_1031FB44 + 5108) >= (double)*v2 )
      {
        *(_BYTE *)(v1 + 174) = 3;
        *(_BYTE *)(v1 + 175) = 0;
        result = sub_1002BEF0(1, a1);
        *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        *(_BYTE *)(v1 + 174) = 0;
        *(_BYTE *)(v1 + 175) = 3;
        result = sub_1002BEF0(1, a1);
        *(_BYTE *)(a1 + 6) = 2;
      }
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 184156) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 184156) = 0;
      break;
    case 0x8039:
      result = sub_1002B9B0(a1);
      break;
    case 0x8033:
    case 0x8038:
      result = sub_1002C720(a1);
      break;
    case 0x806E:
      switch ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) )
      {
        case 0x40:
          result = sub_1002C270(a1);
          break;
        case 0x41:
          sub_1004C220();
          result = sub_1004C0E0();
          break;
        case 0x42:
          sub_1004C2B0();
          result = sub_1004C0E0();
          break;
        case 0x43:
          sub_1004C0E0();
          JUMPOUT(&loc_1004C350);
          return result;
        default:
          return result;
      }
      return result;
    case 0x8017:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8036:
    case 0x8037:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8048:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return result;
  }
  return result;
}
// 1002C860: could not find valid save-restore pair for esi
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002C960) --------------------------------------------------------
int __usercall sub_1002C960@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  double v2; // st7@2
  double v3; // st7@5
  float v4; // ST14_4@7
  double v5; // st7@8
  double v6; // st7@11
  double v7; // st7@14
  float v9; // [sp+Ch] [bp-24h]@1
  float v10; // [sp+10h] [bp-20h]@4
  int v11; // [sp+14h] [bp-1Ch]@4
  float v12; // [sp+18h] [bp-18h]@4
  int v13; // [sp+1Ch] [bp-14h]@4
  int v14; // [sp+20h] [bp-10h]@4
  float v15; // [sp+24h] [bp-Ch]@1
  float v16; // [sp+28h] [bp-8h]@1
  float v17; // [sp+2Ch] [bp-4h]@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v15 = 0.5;
  v16 = 0.5;
  v9 = 71.0;
  if ( *(_BYTE *)(v1 + 70386) )
    v2 = 329.0;
  else
    v2 = 289.0;
  v10 = v2;
  v12 = 12.0;
  v11 = sub_10065060(12.0);
  v13 = -14671840;
  v14 = -1;
  v17 = sub_1008D010(v11, (int)"SYSTEM", 12.0);
  j_gdi_pvg_color_u32(-1);
  sub_1008C110(1.0);
  j_gdi_pvg_begin(64);
  if ( *(_BYTE *)(v1 + 70386) )
  {
    sub_1008C2F0(7.0, 329.0);
    sub_1008C2F0(135.0, 329.0);
    sub_1008C2F0(7.0, 409.0);
    sub_1008C2F0(135.0, 409.0);
    sub_1008C2F0(7.0, 564.0);
    v3 = 564.0;
  }
  else
  {
    sub_1008C2F0(7.0, 289.0);
    sub_1008C2F0(135.0, 289.0);
    sub_1008C2F0(7.0, 369.0);
    sub_1008C2F0(135.0, 369.0);
    sub_1008C2F0(7.0, 524.0);
    v3 = 524.0;
  }
  v4 = v3;
  sub_1008C2F0(135.0, v4);
  j_gdi_pvg_end();
  sub_10065B50(a1, (int)"SYSTEM", (int)&v9);
  if ( *(_BYTE *)(v1 + 70386) )
    v5 = 409.0;
  else
    v5 = 369.0;
  v10 = v5;
  v17 = sub_1008D010(v11, (int)"FUEL CALC", v12);
  sub_10065B50(a1, (int)"FUEL CALC", (int)&v9);
  if ( *(_BYTE *)(v1 + 70386) )
    v6 = 564.0;
  else
    v6 = 524.0;
  v10 = v6;
  v17 = sub_1008D010(v11, (int)"ELECTRICAL", v12);
  sub_10065B50(a1, (int)"ELECTRICAL", (int)&v9);
  v15 = 0.0;
  v16 = 1.0;
  v9 = 7.0;
  if ( *(_BYTE *)(v1 + 70386) )
    v7 = 514.0;
  else
    v7 = 474.0;
  v10 = v7;
  return sub_10065B50(a1, (int)"ENDUR", (int)&v9);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1002CC10) --------------------------------------------------------
double __usercall sub_1002CC10@<st0>(int a1@<edi>, signed int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@2
  int v4; // eax@2
  double v5; // st7@3
  float v6; // ST04_4@3
  float v7; // ST04_4@3
  float v8; // ST04_4@3
  double v9; // st7@5
  float v11; // [sp+4h] [bp-4h]@1

  v11 = 0.0;
  v2 = 0;
  if ( a2 >= 4 )
  {
    v3 = ((unsigned int)(a2 - 4) >> 2) + 1;
    v4 = a1 + 8;
    v2 = 4 * v3;
    do
    {
      v5 = *(float *)(v4 - 8);
      v4 += 16;
      --v3;
      v6 = v5 + v11;
      v7 = v6 + *(float *)(v4 - 20);
      v8 = v7 + *(float *)(v4 - 16);
      v11 = v8 + *(float *)(v4 - 12);
    }
    while ( v3 );
  }
  for ( ; v2 < a2; v11 = v9 + v11 )
    v9 = *(float *)(a1 + 4 * v2++);
  return (float)(v11 / (double)a2);
}

//----- (1002CCA0) --------------------------------------------------------
int __usercall sub_1002CCA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  bool v5; // zf@6
  double v6; // st7@6
  double v7; // st7@6
  float v8; // ST50_4@10
  float v9; // ST50_4@10
  double v10; // st7@18
  double v11; // st7@58
  int result; // eax@61
  float v13; // [sp+8h] [bp-20h]@12
  float v14; // [sp+8h] [bp-20h]@18
  float v15; // [sp+8h] [bp-20h]@24
  float v16; // [sp+8h] [bp-20h]@30
  float v17; // [sp+8h] [bp-20h]@36
  float v18; // [sp+8h] [bp-20h]@42
  float v19; // [sp+Ch] [bp-1Ch]@6
  float v20; // [sp+Ch] [bp-1Ch]@12
  float v21; // [sp+Ch] [bp-1Ch]@15
  float v22; // [sp+Ch] [bp-1Ch]@18
  float v23; // [sp+Ch] [bp-1Ch]@21
  float v24; // [sp+Ch] [bp-1Ch]@24
  float v25; // [sp+Ch] [bp-1Ch]@27
  float v26; // [sp+Ch] [bp-1Ch]@30
  float v27; // [sp+Ch] [bp-1Ch]@33
  float v28; // [sp+Ch] [bp-1Ch]@36
  float v29; // [sp+Ch] [bp-1Ch]@39
  float v30; // [sp+Ch] [bp-1Ch]@42
  float v31; // [sp+Ch] [bp-1Ch]@48
  float v32; // [sp+Ch] [bp-1Ch]@51
  float v33; // [sp+Ch] [bp-1Ch]@54
  float v34; // [sp+Ch] [bp-1Ch]@60
  int v35; // [sp+10h] [bp-18h]@3
  float v36; // [sp+10h] [bp-18h]@6
  float v37; // [sp+10h] [bp-18h]@15
  float v38; // [sp+10h] [bp-18h]@21
  float v39; // [sp+10h] [bp-18h]@27
  float v40; // [sp+10h] [bp-18h]@33
  float v41; // [sp+10h] [bp-18h]@39
  float v42; // [sp+10h] [bp-18h]@48
  float v43; // [sp+10h] [bp-18h]@51
  float v44; // [sp+10h] [bp-18h]@54
  float v45; // [sp+10h] [bp-18h]@60

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"QC";
  v3 = v1 + 192;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)dword_100C38F8 );
  sub_10061B00(v1 + 548, (int)"MAN IN HG", dword_1031FB44 + 3912, 7.0, 2.0, 128.0, 128.0);
  sub_100612A0((int)&unk_100C3988, 6, 0.0, v1 + 548);
  *(_WORD *)(v1 + 6106) = 5;
  *(_BYTE *)(v1 + 6112) = 1;
  *(_DWORD *)(v1 + 6108) = &unk_100B8DC0;
  sub_10060F20(v1 + 188, 1, v1 + 548);
  *(float *)(v1 + 2872) = 16931.934;
  sub_10061B00(v1 + 6144, (int)"RPM", dword_1031FB44 + 4076, 7.0, 134.0, 128.0, 128.0);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 6144);
  sub_100612A0((int)&unk_100C39E8, 8, 0.0, v1 + 6144);
  *(_WORD *)(v1 + 11702) = 6;
  *(_BYTE *)(v1 + 11708) = 1;
  *(_DWORD *)(v1 + 11704) = &unk_100B8DC0;
  sub_10060F20(v1 + 200, 1, v1 + 6144);
  sub_1004A1A0(v1 + 11740, (int)"FFLOW GPH", dword_1031FB44 + 4240, 7.0, 285.0, 135.0, 18.5, 0);
  v35 = v1 + 11740;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10049310((int)&unk_100C3B18, 0xFu, 0, v35);
  else
    sub_10049310((int)&unk_100C3A68, 0xBu, 0, v35);
  *(_WORD *)(v1 + 16052) = 33;
  *(_BYTE *)(v1 + 16060) = 1;
  *(_DWORD *)(v1 + 16056) = &unk_100B8DC0;
  sub_10049040(v1 + 212, 1, 1, v1 + 11740);
  *(float *)(v1 + 15808) = 0.052575164;
  sub_10049630((float *)(v1 + 11740));
  *(float *)(v1 + 12392) = 13.5;
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  *(float *)(v1 + 12396) = 16.65;
  v6 = *(float *)(v1 + 15932);
  *(_BYTE *)(v1 + 12436) = 0;
  *(float *)(v1 + 12384) = v6;
  *(_DWORD *)(v1 + 12440) = -16711681;
  v7 = *(float *)(v1 + 15936);
  *(_BYTE *)(v1 + 12446) = 2;
  *(_BYTE *)(v1 + 12416) = 0;
  *(float *)(v1 + 12388) = v7 + 1.0;
  *(float *)(v1 + 12432) = 0.0;
  sub_10046920(v1 + 16232, (int)"FFLOW GPH", dword_1031FB44 + 4240, 7.0, 283.0, 128.0, 15.0);
  *(float *)(v1 + 16288) = 0.052575164;
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  v36 = 15.0;
  v19 = 128.0;
  *(_WORD *)(v1 + 16748) = 33;
  *(_BYTE *)(v1 + 16756) = 1;
  *(_DWORD *)(v1 + 16752) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 16280) = v1 + 220;
  if ( v5 )
    sub_10046920(v1 + 16844, (int)"FFLOW GPH", dword_1031FB44 + 4240, 7.0, 399.0, v19, v36);
  else
    sub_10046920(v1 + 16844, (int)"FFLOW GPH", dword_1031FB44 + 4240, 7.0, 439.0, v19, v36);
  *(float *)(v1 + 16900) = 0.052575164;
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  *(_WORD *)(v1 + 17360) = 33;
  *(_BYTE *)(v1 + 17368) = 1;
  *(_DWORD *)(v1 + 17364) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 16892) = v1 + 220;
  if ( v5 )
  {
    *(_BYTE *)(*(_DWORD *)(v1 + 168) + 1) = 0;
    *(_BYTE *)(*(_DWORD *)(v1 + 172) + 1) = 0;
    **(_BYTE **)(v1 + 176) = 0;
  }
  else
  {
    sub_1004A1A0(v1 + 33816, (int)"TIT C", dword_1031FB44 + 5880, 7.0, 340.0, 135.0, 18.5, 0);
    v8 = *(float *)(v1 + 33840) - *(float *)(v1 + 33836);
    sub_1004A660(v8, 0.0, -0.80000001, v1 + 33816);
    *(_WORD *)(v1 + 38128) = 17;
    *(_BYTE *)(v1 + 38136) = 1;
    sub_100490F0(dword_1031FB44 + 20816, v1 + 33816);
    sub_10049040(v1 + 536, 1, 1, v1 + 33816);
    *(float *)(v1 + 33920) = 0.0;
    *(float *)(v1 + 33880) = *(float *)(v1 + 33816);
    sub_1004A1A0(v1 + 38308, (int)"TIT C", dword_1031FB44 + 5880, 7.0, 289.0, 135.0, 18.5, 0);
    v9 = *(float *)(v1 + 38332) - *(float *)(v1 + 38328);
    sub_1004A660(v9, 0.0, -0.80000001, v1 + 38308);
    *(_WORD *)(v1 + 42620) = 17;
    *(_BYTE *)(v1 + 42628) = 1;
    sub_100490F0(dword_1031FB44 + 20816, v1 + 38308);
    sub_10049040(v1 + 536, 1, 1, v1 + 38308);
    *(float *)(v1 + 38412) = 0.0;
    *(float *)(v1 + 38372) = *(float *)(v1 + 38308);
    sub_10042310(v1 + 24528, (int)"TIT C", dword_1031FB44 + 5880, 75.0, 301.0, 35.0, 84.0, 1);
    sub_10041F10(dword_1031FB44 + 20816, v1 + 24528);
    sub_10047B10(v1 + 536, 1, 1, v1 + 24544);
    *(float *)(v1 + 24648) = 7.0;
    *(float *)(v1 + 24652) = 310.0;
    *(_WORD *)(v1 + 25508) = 17;
    *(float *)(v1 + 24688) = 0.0;
    *(_BYTE *)(v1 + 25516) = 1;
    *(_DWORD *)(v1 + 25512) = &unk_100B8DC0;
    *(float *)(v1 + 24692) = 1.0;
    *(_BYTE *)(v1 + 25506) = 0;
    *(_BYTE *)(v1 + 25504) = 0;
    *(float *)(v1 + 25212) = 13.0;
    *(_BYTE *)(v1 + 29319) = 1;
    *(float *)(v1 + 25216) = 317.0;
    *(float *)(v1 + 25244) = 0.0;
    *(float *)(v1 + 25248) = 0.0;
    sub_10041CA0(100.0, 0.0, 0.80000001, v1 + 24528);
  }
  v20 = 18.5;
  v13 = 135.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_1004A1A0(v1 + 17540, (int)"CHT", dword_1031FB44 + 4404, 7.0, 384.0, v13, v20, 0);
  else
    sub_1004A1A0(v1 + 17540, (int)"CHT", dword_1031FB44 + 4404, 7.0, 343.0, v13, v20, 0);
  sub_10049310((int)&unk_100C3C08, 2u, 0, v1 + 17540);
  *(_WORD *)(v1 + 21852) = 18;
  *(_BYTE *)(v1 + 21860) = 1;
  sub_10049040(v1 + 224, 1, 0, v1 + 17540);
  v37 = 84.0;
  v21 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10048850(v1 + 22032, (int)"CHT C", dword_1031FB44 + 4404, 7.0, 564.0, v21, v37);
  else
    sub_10048850(v1 + 22032, (int)"CHT C", dword_1031FB44 + 4404, 7.0, 503.0, v21, v37);
  v10 = *(float *)(v1 + 22056) - *(float *)(v1 + 22052);
  *(_BYTE *)(v1 + 22132) = 12;
  *(_WORD *)(v1 + 22996) = 17;
  *(_BYTE *)(v1 + 23004) = 1;
  *(_DWORD *)(v1 + 23000) = &unk_100B8DC0;
  *(float *)(v1 + 23008) = v10 / 12.0;
  sub_10047B60(dword_1031FB44 + 20564, v1 + 22032);
  sub_10047B10(v1 + 224, 6, 1, v1 + 22032);
  v22 = 18.5;
  v14 = 135.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_1004A1A0(v1 + 43508, (int)"OIL TEMP", dword_1031FB44 + 4568, 7.0, 428.0, v14, v22, 0);
  else
    sub_1004A1A0(v1 + 43508, (int)"OIL TEMP", dword_1031FB44 + 4568, 7.0, 391.0, v14, v22, 0);
  sub_10049310((int)&unk_100C3C28, 2u, 0, v1 + 43508);
  *(_WORD *)(v1 + 47820) = 18;
  *(_BYTE *)(v1 + 47828) = 1;
  sub_10049040(v1 + 296, 1, 0, v1 + 43508);
  v38 = 15.0;
  v23 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046920(v1 + 48000, (int)"OIL C", dword_1031FB44 + 4568, 7.0, 359.0, v23, v38);
  else
    sub_10046920(v1 + 48000, (int)"OIL C", dword_1031FB44 + 4568, 7.0, 319.0, v23, v38);
  *(float *)(v1 + 48056) = 150.0;
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  v24 = 18.5;
  v15 = 135.0;
  *(_WORD *)(v1 + 48516) = 17;
  *(_BYTE *)(v1 + 48524) = 1;
  *(_DWORD *)(v1 + 48520) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 48048) = v1 + 304;
  if ( v5 )
    sub_1004A1A0(v1 + 48612, (int)"OIL PRES", dword_1031FB44 + 4732, 7.0, 439.0, v15, v24, 0);
  else
    sub_1004A1A0(v1 + 48612, (int)"OIL PRES", dword_1031FB44 + 4732, 7.0, 472.0, v15, v24, 0);
  sub_10049310((int)&unk_100C3C48, 2u, 0, v1 + 48612);
  *(_WORD *)(v1 + 52924) = 15;
  *(_BYTE *)(v1 + 52932) = 1;
  sub_10049040(v1 + 308, 1, 0, v1 + 48612);
  v39 = 15.0;
  v25 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046920(v1 + 53104, (int)"OIL PSI", dword_1031FB44 + 4732, 7.0, 384.0, v25, v39);
  else
    sub_10046920(v1 + 53104, (int)"OIL PSI", dword_1031FB44 + 4732, 7.0, 344.0, v25, v39);
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  v26 = 37.0;
  v16 = 135.0;
  *(_WORD *)(v1 + 53620) = 15;
  *(_BYTE *)(v1 + 53628) = 1;
  *(_DWORD *)(v1 + 53624) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 53152) = v1 + 316;
  if ( v5 )
    sub_1004A1E0(v1 + 53716, (int)"ALT LOAD", dword_1031FB44 + 4896, 7.0, 487.0, v16, v26, 0);
  else
    sub_1004A1E0(v1 + 53716, (int)"ALT LOAD", dword_1031FB44 + 4896, 7.0, 516.0, v16, v26, 0);
  sub_10049310((int)&unk_100C3C68, 4u, 0, v1 + 53716);
  *(_WORD *)(v1 + 58028) = 25;
  *(_BYTE *)(v1 + 58036) = 1;
  sub_10049040(v1 + 320, 2, 0, v1 + 53716);
  strcpy((char *)(v1 + 54200), "1");
  strcpy((char *)(v1 + 54264), (const char *)&unk_100C31D8);
  v40 = 15.0;
  v27 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046960(v1 + 58208, (int)"ALT LOAD %", dword_1031FB44 + 4896, 7.0, 594.0, v27, v40);
  else
    sub_10046960(v1 + 58208, (int)"ALT LOAD %", dword_1031FB44 + 4896, 7.0, 554.0, v27, v40);
  *(float *)(v1 + 58264) = 150.0;
  *(_DWORD *)(v1 + 58304) = v1 + 340;
  *(float *)(v1 + 58312) = 150.0;
  *(_WORD *)(v1 + 58724) = 22;
  *(_BYTE *)(v1 + 58732) = 1;
  *(_DWORD *)(v1 + 58728) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 58256) = v1 + 328;
  strcpy((char *)(v1 + 58504), "1");
  strcpy((char *)(v1 + 58556), (const char *)&unk_100C31D8);
  v28 = 37.0;
  v17 = 135.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_1004A1E0(v1 + 58908, (int)"BUS VOLTS", dword_1031FB44 + 5060, 7.0, 575.0, v17, v28, 0);
  else
    sub_1004A1E0(v1 + 58908, (int)"BUS VOLTS", dword_1031FB44 + 5060, 7.0, 554.0, v17, v28, 0);
  sub_10049310((int)&unk_100C3CA8, 4u, 0, v1 + 58908);
  *(_WORD *)(v1 + 63220) = 21;
  *(_BYTE *)(v1 + 63228) = 1;
  sub_10049040(v1 + 344, 2, 0, v1 + 58908);
  strcpy((char *)(v1 + 59392), "1");
  strcpy((char *)(v1 + 59456), (const char *)&unk_100C31D8);
  v41 = 15.0;
  v29 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046960(v1 + 63400, (int)"BUS VOLTS", dword_1031FB44 + 5060, 7.0, 639.0, v29, v41);
  else
    sub_10046960(v1 + 63400, (int)"BUS VOLTS", dword_1031FB44 + 5060, 7.0, 594.0, v29, v41);
  *(_WORD *)(v1 + 63916) = 21;
  *(_BYTE *)(v1 + 63924) = 1;
  *(_DWORD *)(v1 + 63920) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 63448) = v1 + 352;
  *(_DWORD *)(v1 + 63496) = v1 + 364;
  strcpy((char *)(v1 + 63696), "1");
  strcpy((char *)(v1 + 63748), (const char *)&unk_100C31D8);
  v30 = 37.0;
  v18 = 135.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_1004A1E0(v1 + 64012, (int)"FUEL QTY GAL", dword_1031FB44 + 5224, 7.0, 634.0, v18, v30, 0);
  else
    sub_1004A1E0(v1 + 64012, (int)"FUEL QTY GAL", dword_1031FB44 + 5224, 7.0, 621.0, v18, v30, 0);
  sub_10049310((int)&unk_100C3CE8, 0x12u, 0, v1 + 64012);
  *(_WORD *)(v1 + 68324) = 31;
  *(_BYTE *)(v1 + 68332) = 1;
  sub_10049040(v1 + 368, 2, 0, v1 + 64012);
  *(_DWORD *)(v1 + 64904) = -65536;
  *(_DWORD *)(v1 + 64968) = -65536;
  *(float *)(v1 + 65220) = 12.0;
  *(float *)(v1 + 65476) = 12.0;
  *(float *)(v1 + 65732) = 12.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_100483D0(v1 + 23280, (int)"EGT C", dword_1031FB44 + 5388, 7.0, 432.0, 128.0, 84.0, 6);
  else
    sub_10048850(v1 + 23280, (int)"EGT C", dword_1031FB44 + 5388, 7.0, 333.0, 128.0, 84.0);
  *(_BYTE *)(v1 + 23380) = 12;
  *(float *)(v1 + 24256) = (*(float *)(v1 + 23304) - *(float *)(v1 + 23300)) / 12.0;
  *(_WORD *)(v1 + 24244) = 17;
  *(_BYTE *)(v1 + 24252) = 1;
  *(_DWORD *)(v1 + 24248) = &unk_100B8DC0;
  sub_10047B60(dword_1031FB44 + 20732, v1 + 23280);
  sub_10047B10(v1 + 392, 6, 1, v1 + 23280);
  v42 = 15.0;
  v31 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046920(v1 + 42800, (int)"PEAK", dword_1031FB44 + 5552, 7.0, 424.0, v31, v42);
  else
    sub_10046920(v1 + 42800, (int)"PEAK", dword_1031FB44 + 5552, 7.0, 308.0, v31, v42);
  *(_WORD *)(v1 + 43316) = 17;
  *(_BYTE *)(v1 + 43324) = 1;
  v43 = 15.0;
  *(_DWORD *)(v1 + 43320) = 0;
  v32 = 128.0;
  *(_DWORD *)(v1 + 42848) = v1 + 468;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046920(v1 + 68504, (int)"GAL REM", dword_1031FB44 + 5552, 7.0, 464.0, v32, v43);
  else
    sub_10046920(v1 + 68504, (int)"GAL REM", dword_1031FB44 + 5552, 7.0, 424.0, v32, v43);
  *(_WORD *)(v1 + 69020) = 31;
  *(_BYTE *)(v1 + 69028) = 1;
  v44 = 15.0;
  *(_DWORD *)(v1 + 69024) = &unk_100B8DC0;
  v33 = 128.0;
  *(_DWORD *)(v1 + 68552) = v1 + 480;
  if ( *(_BYTE *)(v1 + 70386) )
    sub_10046920(v1 + 69116, (int)"GAL USED", dword_1031FB44 + 5552, 7.0, 489.0, v33, v44);
  else
    sub_10046920(v1 + 69116, (int)"GAL USED", dword_1031FB44 + 5552, 7.0, 449.0, v33, v44);
  *(_WORD *)(v1 + 69632) = 31;
  *(_BYTE *)(v1 + 69640) = 1;
  *(_DWORD *)(v1 + 69636) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 69164) = v1 + 492;
  *(_WORD *)(v1 + 69728) = 4142;
  *(_DWORD *)(v1 + 69732) = -1;
  *(_DWORD *)(v1 + 69736) = 0;
  *(float *)(v1 + 69740) = 15.0;
  *(float *)(v1 + 69744) = 60.0;
  *(_DWORD *)(v1 + 69748) = sub_10065060(*(float *)(v1 + 69740));
  *(float *)(v1 + 69752) = 1.0;
  *(float *)(v1 + 69756) = 1.0;
  *(_DWORD *)(v1 + 69760) = 0x7FFFFFFF;
  v5 = *(_BYTE *)(v1 + 70386) == 0;
  *(float *)(v1 + 69764) = 135.0;
  if ( v5 )
    v11 = 474.0;
  else
    v11 = 514.0;
  *(float *)(v1 + 69768) = v11;
  v45 = 15.0;
  v34 = 128.0;
  if ( *(_BYTE *)(v1 + 70386) )
    result = sub_10046920(v1 + 69772, (int)"RANGE NM", dword_1031FB44 + 5552, 7.0, 539.0, v34, v45);
  else
    result = sub_10046920(v1 + 69772, (int)"RANGE NM", dword_1031FB44 + 5552, 7.0, 499.0, v34, v45);
  *(_WORD *)(v1 + 70288) = 38;
  *(_BYTE *)(v1 + 70296) = 1;
  *(_DWORD *)(v1 + 70292) = &unk_100B8DC0;
  *(_DWORD *)(v1 + 69820) = v1 + 504;
  *(float *)(v1 + 69828) = 18520000.0;
  return result;
}
// 100C38F8: using guessed type int dword_100C38F8[];
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002DF80) --------------------------------------------------------
int __usercall sub_1002DF80@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3814, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 124),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 104),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 168),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1002DFF0) --------------------------------------------------------
char __usercall sub_1002DFF0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  signed int v4; // eax@1
  _BYTE *v5; // ebx@6
  bool v6; // zf@6
  char result; // al@9

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 70396, 0);
  v2 = v1;
  *(_BYTE *)(v1 + 70384) = 0;
  *(_BYTE *)(v1 + 70386) = sub_1006C420(0x1Fu);
  sub_100011B0(a1, 0, 0, 151, 686, 3);
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(v3 + 230) = -1;
  *(_BYTE *)(v2 + 70385) = sub_1004BF10((void *)v3);
  *(_DWORD *)(v2 + 124) = &unk_100C3EE8;
  *(_DWORD *)(v2 + 128) = &unk_100C3EBC;
  *(_DWORD *)(v2 + 132) = &unk_100C3F38;
  *(_DWORD *)(v2 + 108) = v2 + 40;
  *(_DWORD *)(v2 + 112) = v2 + 60;
  *(_DWORD *)(v2 + 168) = v2 + 144;
  *(_DWORD *)(v2 + 176) = v2 + 152;
  *(_DWORD *)(v2 + 172) = v2 + 163;
  *(_DWORD *)(v2 + 104) = v2 + 8;
  *(_BYTE *)(v2 + 144) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 168) + 7) = 3;
  **(_BYTE **)(v2 + 172) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 172) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 172) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 172) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 172) + 4) = 3;
  v4 = 0;
  do
    *(_BYTE *)(v4++ + *(_DWORD *)(v2 + 176)) = 3;
  while ( v4 < 11 );
  if ( *(_BYTE *)(v2 + 70386) )
    *(_BYTE *)(*(_DWORD *)(v2 + 176) + 6) = 0;
  else
    *(_BYTE *)(*(_DWORD *)(v2 + 176) + 7) = 0;
  sub_1002CCA0(a1);
  v5 = (_BYTE *)(v2 + 43412);
  *(_BYTE *)(v2 + 70387) = -1;
  *(_BYTE *)(v2 + 43504) = 0;
  sub_1004CCA0(v2 + 43412, 1);
  v6 = *(_BYTE *)(v2 + 70386) == 0;
  *(_DWORD *)(v2 + 43440) = v2 + 216;
  if ( v6 )
  {
    *(_DWORD *)(v2 + 43416) = v2 + 396;
    *(_DWORD *)(v2 + 43420) = v2 + 408;
    *(_DWORD *)(v2 + 43424) = v2 + 420;
    *v5 = 6;
    *(_DWORD *)(v2 + 43428) = v2 + 432;
    *(_DWORD *)(v2 + 43432) = v2 + 444;
    *(_DWORD *)(v2 + 43436) = v2 + 456;
  }
  else
  {
    *v5 = 1;
    *(_DWORD *)(v2 + 43416) = v2 + 540;
  }
  *(_DWORD *)(v2 + 70392) = 0;
  *(_DWORD *)(v2 + 70388) = 0;
  *(_DWORD *)(v2 + 17460) = 1017923390;
  *(_DWORD *)(v2 + 17464) = 1017923390;
  *(_DWORD *)(v2 + 17468) = 1017923390;
  *(_DWORD *)(v2 + 17472) = 1017923390;
  *(_DWORD *)(v2 + 17476) = 1017923390;
  *(_DWORD *)(v2 + 17480) = 1017923390;
  *(_DWORD *)(v2 + 17484) = 1017923390;
  *(_DWORD *)(v2 + 17488) = 1017923390;
  *(_DWORD *)(v2 + 17492) = 1017923390;
  *(_DWORD *)(v2 + 17496) = 1017923390;
  *(_DWORD *)(v2 + 17500) = 1017923390;
  *(_DWORD *)(v2 + 17504) = 1017923390;
  *(_DWORD *)(v2 + 17508) = 1017923390;
  *(_DWORD *)(v2 + 17512) = 1017923390;
  *(_DWORD *)(v2 + 17516) = 1017923390;
  *(_DWORD *)(v2 + 17520) = 1017923390;
  *(_DWORD *)(v2 + 17524) = 1017923390;
  *(_DWORD *)(v2 + 17528) = 1017923390;
  *(_DWORD *)(v2 + 17532) = 1017923390;
  *(_DWORD *)(v2 + 17536) = 1017923390;
  *(_DWORD *)(v2 + 58820) = 0;
  *(_DWORD *)(v2 + 58824) = 0;
  *(_DWORD *)(v2 + 58828) = 0;
  *(_DWORD *)(v2 + 58832) = 0;
  *(_DWORD *)(v2 + 58836) = 0;
  *(_DWORD *)(v2 + 58840) = 0;
  *(_DWORD *)(v2 + 58844) = 0;
  *(_DWORD *)(v2 + 58848) = 0;
  *(_DWORD *)(v2 + 58852) = 0;
  *(_DWORD *)(v2 + 58856) = 0;
  *(_DWORD *)(v2 + 58860) = 0;
  *(_DWORD *)(v2 + 58864) = 0;
  *(_DWORD *)(v2 + 58868) = 0;
  *(_DWORD *)(v2 + 58872) = 0;
  *(_DWORD *)(v2 + 58876) = 0;
  *(_DWORD *)(v2 + 58880) = 0;
  *(_DWORD *)(v2 + 58884) = 0;
  *(_DWORD *)(v2 + 58888) = 0;
  *(_DWORD *)(v2 + 58892) = 0;
  *(_DWORD *)(v2 + 58896) = 0;
  *(_DWORD *)(v2 + 58900) = 0;
  *(_DWORD *)(v2 + 58904) = 0;
  *(_DWORD *)v2 = v2 + 548;
  *(_DWORD *)(v2 + 4) = v2 + 6144;
  *(_DWORD *)(v2 + 8) = v2 + 11740;
  *(_DWORD *)(v2 + 12) = v2 + 33816;
  *(_DWORD *)(v2 + 16) = v2 + 17540;
  *(_DWORD *)(v2 + 20) = v2 + 43508;
  *(_DWORD *)(v2 + 24) = v2 + 48612;
  *(_DWORD *)(v2 + 28) = v2 + 53716;
  *(_DWORD *)(v2 + 32) = v2 + 58908;
  *(_DWORD *)(v2 + 36) = v2 + 64012;
  *(_DWORD *)(v2 + 40) = v2 + 16232;
  *(_DWORD *)(v2 + 44) = v2 + 24528;
  *(_DWORD *)(v2 + 56) = v2 + 42800;
  *(_DWORD *)(v2 + 52) = v2 + 22032;
  *(_DWORD *)(v2 + 48) = v2 + 23280;
  *(_DWORD *)(v2 + 60) = v2 + 38308;
  *(_DWORD *)(v2 + 64) = v2 + 48000;
  *(_DWORD *)(v2 + 68) = v2 + 53104;
  *(_DWORD *)(v2 + 72) = v2 + 16844;
  *(_DWORD *)(v2 + 76) = v2 + 68504;
  *(_DWORD *)(v2 + 80) = v2 + 69116;
  *(_DWORD *)(v2 + 84) = v2 + 69728;
  *(_DWORD *)(v2 + 88) = v2 + 69728;
  *(_DWORD *)(v2 + 92) = v2 + 69772;
  *(_DWORD *)(v2 + 96) = v2 + 58208;
  *(_DWORD *)(v2 + 100) = v2 + 63400;
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3814, v2, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3EE8, v2 + 8, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3EBC, v2 + 40, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3F38, v2 + 60, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 50);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1002E460) --------------------------------------------------------
char __usercall sub_1002E460@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 23356) = 0;
  *(_DWORD *)(v1 + 24620) = 0;
  *(_DWORD *)(v1 + 23360) = 0;
  *(_DWORD *)(v1 + 24624) = 0;
  *(_DWORD *)(v1 + 23364) = 0;
  *(_DWORD *)(v1 + 24628) = 0;
  *(_DWORD *)(v1 + 23368) = 0;
  *(_DWORD *)(v1 + 24632) = 0;
  *(_DWORD *)(v1 + 23372) = 0;
  *(_DWORD *)(v1 + 24636) = 0;
  *(_DWORD *)(v1 + 23376) = 0;
  *(_DWORD *)(v1 + 24640) = 0;
  result = sub_1004CCA0(v1 + 43412, 1);
  *(_BYTE *)(v1 + 43412) = *(_BYTE *)(v1 + 70386) != 0 ? 1 : 6;
  return result;
}

//----- (1002E4E0) --------------------------------------------------------
char __usercall sub_1002E4E0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // edx@2
  int v4; // ecx@3
  float *v5; // esi@3
  int v6; // edi@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1002E460(a1);
  LOBYTE(v2) = 2;
  if ( *(_BYTE *)(v1 + 43504) == 2 )
  {
    v4 = *(_DWORD *)(v1 + 172);
    v2 = 0;
    *(_BYTE *)(v1 + 43504) = 0;
    *(_BYTE *)(v4 + 4) = 0;
    *(_BYTE *)(v1 + 24716) = 0;
    v5 = (float *)(v1 + 23484);
    do
    {
      v6 = v2 + 1;
      sprintf((char *)v5 - 32, "%d", v2 + 1);
      *v5 = 9.0;
      v2 = v6;
      v5 += 13;
    }
    while ( v6 < 6 );
  }
  else
  {
    v3 = *(_DWORD *)(v1 + 172);
    *(_BYTE *)(v1 + 43504) = 2;
    *(_BYTE *)(v3 + 4) = 3;
  }
  return v2;
}

//----- (1002E550) --------------------------------------------------------
int __usercall sub_1002E550@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 v3; // cl@1
  int v4; // ST08_4@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_10066EE0(v1 + 188, 3u, 6u);
  v3 = *(_BYTE *)(v1 + 43504);
  if ( !v3 || v3 > 2u )
    *(_BYTE *)(v1 + 22994) = v2;
  *(_DWORD *)(v1 + 17568) = v1 + 4 * (3 * (unsigned __int8)v2 + 57);
  v4 = *(_BYTE *)(v1 + 22994) + 1;
  *(_DWORD *)(v1 + 17592) = v1 + 12 * (unsigned __int8)v2 + 232;
  return sprintf((char *)(v1 + 18024), "%d", v4);
}

//----- (1002E5C0) --------------------------------------------------------
char __usercall sub_1002E5C0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@2
  char v3; // al@4
  double v4; // st7@4
  float v5; // ST20_4@6
  double v6; // st7@6
  float v7; // ST20_4@8
  double v8; // st7@8
  float v9; // ST20_4@10

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 43504) )
  {
    result = *(_BYTE *)(v1 + 43504) - 2;
    if ( *(_BYTE *)(v1 + 43504) == 2 )
    {
      if ( *(_BYTE *)(v1 + 70386) )
      {
        sub_10047850(v1 + 43412, v1 + 24544);
        v3 = sub_10066EE0(v1 + 188, 0x11u, 6u);
        v4 = *(float *)(v1 + 540) - *(float *)(v1 + 43456);
        *(_BYTE *)(v1 + 24242) = v3;
      }
      else
      {
        sub_10047850(v1 + 43412, v1 + 23280);
        v4 = *(float *)(v1 + 4 * (3 * *(_BYTE *)(v1 + 43446) + 99))
           - *(float *)(v1 + 4 * *(_BYTE *)(v1 + 43446) + 43456);
      }
      v5 = v4;
      v6 = v5;
      if ( v5 > 0.0 )
        v6 = 0.0;
      v7 = v6;
      v8 = v7;
      *(float *)(v1 + 468) = v7;
      if ( v7 <= -500.0 )
        v8 = -500.0;
      v9 = v8;
      *(float *)(v1 + 468) = v9;
      result = sub_10066EE0(v1 + 188, 3u, 6u);
      *(_BYTE *)(v1 + 22994) = result;
    }
  }
  else
  {
    *(_BYTE *)(v1 + 24242) = sub_10066EE0(v1 + 188, 0x11u, 6u);
    result = sub_10066EE0(v1 + 188, 3u, 6u);
    *(_BYTE *)(v1 + 22994) = result;
  }
  return result;
}

//----- (1002E6E0) --------------------------------------------------------
void __cdecl sub_1002E6E0(float a1)
{
  int v1; // ebp@1
  int v2; // esi@1
  float *v3; // eax@1
  signed int v4; // ecx@1
  unsigned int v5; // edi@3
  double v6; // st7@4
  int v7; // eax@4
  bool v8; // zf@11
  int v9; // eax@13
  int v10; // ebx@15
  int v11; // edi@16
  double v12; // st7@16
  int v13; // edx@22
  int v14; // ecx@22
  double v15; // st6@25
  double v16; // st7@25
  int *v17; // [sp+4h] [bp-3Ch]@16
  float v18; // [sp+10h] [bp-30h]@0
  float v19; // [sp+1Ch] [bp-24h]@12
  float v20; // [sp+20h] [bp-20h]@15
  int v21; // [sp+24h] [bp-1Ch]@13
  int v22; // [sp+28h] [bp-18h]@15
  float v23; // [sp+2Ch] [bp-14h]@15
  float v24; // [sp+30h] [bp-10h]@15
  float v25; // [sp+34h] [bp-Ch]@15
  float v26; // [sp+38h] [bp-8h]@15
  float v27; // [sp+3Ch] [bp-4h]@15

  v1 = LODWORD(a1);
  v2 = *(_DWORD *)(*(_DWORD *)(LODWORD(a1) + 56) + 12);
  v3 = (float *)(v2 + 192);
  v4 = 30;
  do
  {
    *v3 = 9.8999998e24;
    v3 += 3;
    --v4;
  }
  while ( v4 );
  v5 = 0;
  do
  {
    v6 = sub_1004C3E0(word_100C382A[v5]);
    v7 = (unsigned __int8)byte_100C3828[v5 * 2] + 16;
    v5 += 2;
    *(float *)(v2 + 12 * v7) = v6;
  }
  while ( v5 < 44 );
  if ( sub_100664A0(&a1) )
    *(float *)(v2 + 372) = a1;
  if ( sub_10066510(&a1) )
    *(float *)(v2 + 384) = a1;
  if ( sub_100663D0(&a1) )
  {
    *(float *)(v2 + 216) = a1;
    *(float *)(v2 + 528) = a1;
  }
  v8 = *(_BYTE *)(v2 + 70386) == 0;
  *(_DWORD *)(v2 + 11780) = 0;
  if ( v8 && sub_10051BA0(&v19) )
  {
    v21 = (signed int)sub_100956A0(v19, 609.60004);
    v9 = sub_1006E440(&v21, 4u, (int)dword_100C38F8, 16, 9, 8);
    if ( v9 < 1 )
      v9 = 1;
    v10 = 4 * v9;
    *(float *)&v22 = (double)dword_100C38E8[4 * v9];
    v23 = flt_100C38F4[4 * v9];
    v24 = 1.0;
    v25 = (double)dword_100C38F8[4 * v9];
    v26 = flt_100C3904[4 * v9];
    v27 = 1.0;
    v20 = sub_10065120(v19, (int)&v22, 2);
    if ( *(float *)(v2 + 520) < 2510.0 )
    {
      if ( v20 >= (double)*(float *)(v2 + 532) )
        goto LABEL_20;
      v11 = v2 + 17460;
      memcpy((void *)(v2 + 17460), (const void *)(v2 + 17464), 0x4Cu);
      v23 = flt_100C38F0[v10];
      v12 = flt_100C3900[v10];
      v17 = &v22;
    }
    else
    {
      v11 = v2 + 17460;
      memcpy((void *)(v2 + 17460), (const void *)(v2 + 17464), 0x4Cu);
      v23 = flt_100C38EC[v10];
      v12 = flt_100C38FC[v10];
      v17 = &v22;
    }
    v26 = v12;
    *(float *)(v2 + 17536) = sub_10065120(v19, (int)v17, 2);
    *(float *)(v2 + 17456) = sub_1002CC10(v11, 20);
    *(_DWORD *)(v2 + 11780) = v2 + 17456;
  }
LABEL_20:
  sub_1002E550(v1);
  sub_1002E5C0(v1);
  if ( 9.8999998e24 != *(float *)(v2 + 336) )
    *(float *)(v2 + 336) = *(float *)(v2 + 336) * 5.0;
  *(float *)(v2 + 480) = sub_1004C0C0();
  *(float *)(v2 + 492) = sub_1004C0D0(v14, v13);
  *(_DWORD *)(v2 + 69760) = sub_1004BF40();
  *(float *)(v2 + 504) = sub_1004BFF0(v18);
  if ( 9.8999998e24 != *(float *)(v2 + 324) )
  {
    memcpy((void *)(v2 + 58820), (const void *)(v2 + 58824), 0x54u);
    *(float *)(v2 + 58904) = *(float *)(v2 + 324);
    *(float *)(v2 + 324) = sub_1002CC10(v2 + 58820, 22);
  }
  sub_1004C380(v2 + 188, 0x1Eu);
  v20 = *(float *)(v2 + 328);
  if ( v20 >= 0.0 )
  {
    v15 = 0.0;
    v16 = 0.0;
  }
  else
  {
    v15 = 0.0;
    v16 = 0.0;
    v20 = 0.0;
  }
  *(float *)(v2 + 328) = v20;
  a1 = *(float *)(v2 + 340);
  if ( a1 >= v16 )
  {
    *(float *)(v2 + 340) = a1;
  }
  else
  {
    v20 = v15;
    *(float *)(v2 + 340) = v20;
  }
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100C382A: using guessed type __int16 word_100C382A[];
// 100C38E8: using guessed type int dword_100C38E8[];
// 100C38EC: using guessed type float flt_100C38EC[];
// 100C38F0: using guessed type float flt_100C38F0[];
// 100C38F4: using guessed type float flt_100C38F4[];
// 100C38F8: using guessed type int dword_100C38F8[];
// 100C38FC: using guessed type float flt_100C38FC[];
// 100C3900: using guessed type float flt_100C3900[];
// 100C3904: using guessed type float flt_100C3904[];

//----- (1002EA40) --------------------------------------------------------
void __usercall sub_1002EA40(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ecx@13
  int v3; // eax@20

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(float *)(v1 + 208) >= 500.0 )
  {
    *(_BYTE *)(v1 + 43884) = *(_BYTE *)(dword_1031FB44 + 4660);
    *(_BYTE *)(v1 + 48440) = *(_BYTE *)(dword_1031FB44 + 4660);
    *(_BYTE *)(v1 + 48988) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v1 + 48996) = *(_BYTE *)(dword_1031FB44 + 4825);
    *(_BYTE *)(v1 + 53544) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v1 + 53552) = *(_BYTE *)(dword_1031FB44 + 4825);
    *(_BYTE *)(v1 + 59292) = *(_BYTE *)(dword_1031FB44 + 5153);
    *(_BYTE *)(v1 + 63848) = *(_BYTE *)(dword_1031FB44 + 5153);
  }
  else
  {
    *(_BYTE *)(v1 + 43884) = 10;
    *(_BYTE *)(v1 + 48440) = 10;
    *(_BYTE *)(v1 + 48988) = 10;
    *(_BYTE *)(v1 + 48996) = 10;
    *(_BYTE *)(v1 + 53544) = 10;
    *(_BYTE *)(v1 + 53552) = 10;
    *(_BYTE *)(v1 + 59292) = 10;
    *(_BYTE *)(v1 + 63848) = 10;
  }
  if ( *(_DWORD *)(v1 + 70392) || *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 208) )
  {
    if ( *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 208) )
      *(_DWORD *)(v1 + 70392) = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 70392) = sub_1008C780();
  }
  if ( *(_DWORD *)(v1 + 70392) && (unsigned int)(sub_1008C780() - *(_DWORD *)(v1 + 70392)) > 0x3A980 )
    *(_BYTE *)(v1 + 8128) = 11;
  else
    *(_BYTE *)(v1 + 8128) = *(_BYTE *)(dword_1031FB44 + 4170);
  v2 = dword_1031FB44;
  if ( *(_DWORD *)(v1 + 70388) || *(float *)(dword_1031FB44 + 4908) >= (double)*(float *)(v1 + 340) )
  {
    if ( *(float *)(dword_1031FB44 + 4908) < (double)*(float *)(v1 + 340) )
      goto LABEL_19;
    *(_DWORD *)(v1 + 70388) = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 70388) = sub_1008C780();
  }
  v2 = dword_1031FB44;
LABEL_19:
  if ( *(_DWORD *)(v1 + 70388)
    && (v3 = sub_1008C780(),
        v2 = dword_1031FB44,
        v3 - *(_DWORD *)(v1 + 70388) > 1000 * (unsigned int)(signed __int64)*(float *)(dword_1031FB44 + 5724))
    || *(float *)(v2 + 4908) < (double)*(float *)(v1 + 328) )
  {
    *(_BYTE *)(v1 + 54100) = *(_BYTE *)(v2 + 4989);
    *(_BYTE *)(v1 + 58656) = *(_BYTE *)(dword_1031FB44 + 4989);
  }
  else
  {
    *(_BYTE *)(v1 + 54100) = 10;
    *(_BYTE *)(v1 + 58656) = 10;
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1002ECA0) --------------------------------------------------------
char __usercall sub_1002ECA0@<al>(int a1@<ebx>)
{
  int v1; // ebp@1
  int v2; // eax@1
  float *v3; // esi@1
  int v4; // edi@2
  char v5; // ST0C_1@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1004C150(0);
  *(_BYTE *)(v1 + 43504) = 0;
  *(_BYTE *)(v1 + 167) = 0;
  *(_BYTE *)(v1 + 24716) = 0;
  sub_1002E460(a1);
  v2 = 0;
  v3 = (float *)(v1 + 23484);
  do
  {
    v4 = v2 + 1;
    sprintf((char *)v3 - 32, "%d", v2 + 1);
    *v3 = 9.0;
    v2 = v4;
    v3 += 13;
  }
  while ( v4 < 6 );
  v5 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 70385) = v5;
  sub_1004C170(v5);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (1002ED30) --------------------------------------------------------
char __usercall sub_1002ED30@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@5
  int v3; // ST04_4@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( *(_BYTE *)(v1 + 43504) != 2 )
    {
      v2 = (unsigned __int8)(*(_BYTE *)(v1 + 24242) + 1) % 6;
      *(_BYTE *)(v1 + 43504) = 1;
      *(_BYTE *)(v1 + 24242) = v2;
      *(_BYTE *)(v1 + 22994) = v2;
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    sub_1002E4E0(a1);
  }
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v3, -32734);
}

//----- (1002F050) --------------------------------------------------------
char __cdecl sub_1002F050(int a1)
{
  int v1; // esi@4
  void *v2; // ecx@4
  float v3; // ST38_4@11
  float v4; // ST38_4@11
  float v5; // ST38_4@11
  float v6; // ST38_4@11
  float v7; // ST38_4@11
  int v8; // eax@11
  signed int v9; // ecx@11
  double v10; // st7@12
  char result; // al@1

  result = a1;
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      result = sub_1002DF80(a1);
      break;
    case 0x8041:
      result = sub_1002DFF0(a1);
      break;
    case 0x8022:
    case 0x8078:
      v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_1002E6E0(*(float *)&a1);
      sub_1002EA40(a1);
      if ( sub_10052210(v2) == 2 && *(_BYTE *)(v1 + 70384) )
      {
        *(float *)(v1 + 192) = (*(float *)(v1 + 568) + *(float *)(v1 + 564)) * 0.5;
        *(float *)(v1 + 204) = (*(float *)(v1 + 6164) + *(float *)(v1 + 6160)) * 0.5;
        *(float *)(v1 + 216) = (*(float *)(v1 + 11764) + *(float *)(v1 + 11760)) * 0.5;
        *(float *)(v1 + 540) = (*(float *)(v1 + 33840) + *(float *)(v1 + 33836)) * 0.5;
        v3 = (*(float *)(v1 + 17564) + *(float *)(v1 + 17560)) * 0.5;
        *(float *)(v1 + 228) = v3;
        *(float *)(v1 + 240) = v3;
        *(float *)(v1 + 252) = v3;
        *(float *)(v1 + 264) = v3;
        *(float *)(v1 + 276) = v3;
        *(float *)(v1 + 288) = v3;
        *(float *)(v1 + 300) = (*(float *)(v1 + 43532) + *(float *)(v1 + 43528)) * 0.5;
        *(float *)(v1 + 312) = (*(float *)(v1 + 48636) + *(float *)(v1 + 48632)) * 0.5;
        v4 = (*(float *)(v1 + 53740) + *(float *)(v1 + 53736)) * 0.5;
        *(float *)(v1 + 324) = v4;
        *(float *)(v1 + 336) = v4;
        v5 = (*(float *)(v1 + 58932) + *(float *)(v1 + 58928)) * 0.5;
        *(float *)(v1 + 348) = v5;
        *(float *)(v1 + 360) = v5;
        v6 = (*(float *)(v1 + 29348) + *(float *)(v1 + 29344)) * 0.5;
        *(float *)(v1 + 396) = v6;
        *(float *)(v1 + 408) = v6;
        *(float *)(v1 + 420) = v6;
        *(float *)(v1 + 432) = v6;
        *(float *)(v1 + 444) = v6;
        *(float *)(v1 + 456) = v6;
        *(float *)(v1 + 468) = (*(float *)(v1 + 42824) + *(float *)(v1 + 42820)) * 0.5;
        *(float *)(v1 + 480) = (*(float *)(v1 + 68528) + *(float *)(v1 + 68524)) * 0.5;
        *(float *)(v1 + 492) = (*(float *)(v1 + 69140) + *(float *)(v1 + 69136)) * 0.5;
        *(float *)(v1 + 504) = (*(float *)(v1 + 69796) + *(float *)(v1 + 69792)) * 0.5;
        v7 = 0.5 * (*(float *)(v1 + 64036) + *(float *)(v1 + 64032));
        v8 = v1 + 196;
        v9 = 3;
        *(float *)(v1 + 372) = v7;
        *(float *)(v1 + 384) = v7;
        do
        {
          v10 = *(float *)(v8 - 4);
          v8 += 120;
          --v9;
          *(float *)(v8 - 120) = v10;
          *(float *)(v8 - 108) = *(float *)(v8 - 112);
          *(float *)(v8 - 96) = *(float *)(v8 - 100);
          *(float *)(v8 - 84) = *(float *)(v8 - 88);
          *(float *)(v8 - 72) = *(float *)(v8 - 76);
          *(float *)(v8 - 60) = *(float *)(v8 - 64);
          *(float *)(v8 - 48) = *(float *)(v8 - 52);
          *(float *)(v8 - 36) = *(float *)(v8 - 40);
          *(float *)(v8 - 24) = *(float *)(v8 - 28);
          *(float *)(v8 - 12) = *(float *)(v8 - 16);
        }
        while ( v9 );
      }
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3E08, (int)&unk_100C3F2C, 0, 255);
      if ( *(_BYTE *)(v1 + 70385) == 2 )
        sub_1002C960(a1);
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C3814, v1, 0, 255);
      result = sub_100653C0(
                 a1,
                 *(_WORD **)(a1 + 52),
                 *(char **)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 124),
                 *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 104),
                 *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 70385) + 168),
                 255);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8039:
      result = sub_1002ECA0(a1);
      break;
    case 0x8033:
    case 0x8038:
      result = sub_1002ED30(a1);
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 70384) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 70384) = 0;
      break;
    case 0x8061:
      result = sub_1004C150(0);
      break;
    case 0x8017:
    case 0x8018:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8036:
    case 0x8037:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8048:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806E:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return result;
  }
  return result;
}

//----- (1002F140) --------------------------------------------------------
int __usercall sub_1002F140@<eax>(int a1@<esi>)
{
  float v2; // [sp+18h] [bp-24h]@1
  float v3; // [sp+1Ch] [bp-20h]@1
  int v4; // [sp+20h] [bp-1Ch]@1
  float v5; // [sp+24h] [bp-18h]@1
  int v6; // [sp+28h] [bp-14h]@1
  int v7; // [sp+2Ch] [bp-10h]@1
  float v8; // [sp+30h] [bp-Ch]@1
  float v9; // [sp+34h] [bp-8h]@1
  float v10; // [sp+38h] [bp-4h]@1

  v8 = 0.5;
  v9 = 0.5;
  v2 = 71.0;
  v3 = 297.0;
  v5 = 12.0;
  v4 = sub_10065060(12.0);
  v6 = -14671840;
  v7 = -1;
  sub_100682A0(7.0, 297.0, 135.0, 297.0, -1, 1.0);
  sub_100682A0(7.0, 428.0, 135.0, 428.0, -1, 1.0);
  sub_100682A0(7.0, 534.0, 135.0, 534.0, -1, 1.0);
  v10 = sub_1008D010(v4, (int)"SYSTEM", 12.0);
  sub_10065B50(a1, (int)"SYSTEM", (int)&v2);
  v3 = 428.0;
  v10 = sub_1008D010(v4, (int)"FUEL CALC", v5);
  sub_10065B50(a1, (int)"FUEL CALC", (int)&v2);
  v3 = 534.0;
  v10 = sub_1008D010(v4, (int)"ELECTRICAL", v5);
  sub_10065B50(a1, (int)"ELECTRICAL", (int)&v2);
  v2 = 71.0;
  v3 = 322.0;
  v10 = sub_1008D010(v4, (int)"OIL", v5);
  sub_10065B50(a1, (int)"OIL", (int)&v2);
  v10 = sub_1008D010(v4, (int)"L", v5);
  v2 = 7.0;
  v8 = 0.0;
  sub_10065B50(a1, (int)"L", (int)&v2);
  v2 = 135.0;
  v8 = 1.0;
  v10 = sub_1008D010(v4, (int)"R", v5);
  return sub_10065B50(a1, (int)"R", (int)&v2);
}

//----- (1002F380) --------------------------------------------------------
int __usercall sub_1002F380@<eax>(void *a1@<edx>, signed int a2@<ecx>, int a3)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a3;
    memset32(a1, a3, a2);
  }
  return result;
}

//----- (1002F390) --------------------------------------------------------
int __usercall sub_1002F390@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  int v5; // ebp@3
  float v6; // ST5C_4@4
  long double v7; // ST60_8@4
  float v8; // ST5C_4@4
  int result; // eax@5
  unsigned int v10; // [sp+24h] [bp-10h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)"QCQC";
  v3 = v1 + 200;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)dword_100C4710 );
  sub_10061B00(v1 + 772, (int)byte_100B8180, dword_1031FB44 + 3912, 7.0, -8.0, 128.0, 128.0);
  *(float *)(v1 + 992) = 130.0;
  *(float *)(v1 + 996) = 230.0;
  *(float *)(v1 + 1096) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 772);
  sub_100612A0((int)&unk_100C47B0, 6, 0.0, v1 + 772);
  *(_WORD *)(v1 + 6330) = 5;
  *(_DWORD *)(v1 + 6332) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 6336) = 1;
  sub_10060F20(v1 + 196, 0, v1 + 772);
  *(float *)(v1 + 3148) = *(float *)(v1 + 3148) + 5.0;
  *(float *)(v1 + 3152) = *(float *)(v1 + 3152) - 10.0;
  *(float *)(v1 + 3172) = 0.0;
  *(float *)(v1 + 3468) = *(float *)(v1 + 3468) + 8.0;
  *(float *)(v1 + 3472) = *(float *)(v1 + 3472) - 8.0;
  *(float *)(v1 + 3492) = 0.0;
  *(float *)(v1 + 804) = 64.0;
  sub_10061B00(v1 + 6368, (int)byte_100B8180, dword_1031FB44 + 3912, 7.0, -8.0, 128.0, 128.0);
  *(float *)(v1 + 6588) = 50.0;
  *(float *)(v1 + 6592) = -50.0;
  *(float *)(v1 + 6692) = -100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 3912), v1 + 6368);
  sub_100612A0((int)&unk_100C47B0, 6, 0.0, v1 + 6368);
  *(_WORD *)(v1 + 11926) = 5;
  *(_DWORD *)(v1 + 11928) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 11932) = 1;
  sub_10060F20(v1 + 208, 0, v1 + 6368);
  *(float *)(v1 + 8744) = *(float *)(v1 + 8744) - 5.0;
  *(float *)(v1 + 8748) = *(float *)(v1 + 8748) - 10.0;
  *(float *)(v1 + 8768) = 1.0;
  *(float *)(v1 + 9064) = *(float *)(v1 + 9064) - 8.0;
  *(float *)(v1 + 9068) = *(float *)(v1 + 9068) - 8.0;
  *(float *)(v1 + 9088) = 1.0;
  *(float *)(v1 + 6392) = 135.0;
  *(float *)(v1 + 6400) = -64.0;
  sub_10046960(v1 + 11964, (int)&unk_100C4EA0, dword_1031FB44 + 3912, 7.0, 115.0, 128.0, 15.0);
  *(float *)(v1 + 12032) = 18.0;
  *(float *)(v1 + 12080) = 18.0;
  *(_WORD *)(v1 + 12480) = 5;
  *(_DWORD *)(v1 + 12484) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 12488) = 1;
  *(_DWORD *)(v1 + 12012) = v1 + 204;
  *(_DWORD *)(v1 + 12060) = v1 + 216;
  *(_DWORD *)(v1 + 12208) = 1210076745;
  *(float *)(v1 + 12144) = 37.0;
  *(float *)(v1 + 12196) = 77.0;
  *(_WORD *)(v1 + 12212) = 71;
  *(float *)(v1 + 12016) = 16931.934;
  *(float *)(v1 + 12064) = 16931.934;
  sub_10061B00(v1 + 12576, (int)byte_100B8180, dword_1031FB44 + 4076, 7.0, 132.0, 128.0, 128.0);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 12576);
  *(float *)(v1 + 12796) = 130.0;
  *(_BYTE *)(v1 + 12980) = 4;
  *(float *)(v1 + 12800) = 230.0;
  *(float *)(v1 + 12896) = *(float *)(dword_1031FB44 + 4088);
  *(float *)(v1 + 12900) = 45.0;
  *(float *)(v1 + 12908) = *(float *)(dword_1031FB44 + 4092);
  *(float *)(v1 + 12912) = 90.0;
  *(float *)(v1 + 12920) = *(float *)(dword_1031FB44 + 4084);
  *(float *)(v1 + 12924) = 100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 12576);
  sub_100612A0((int)&unk_100C4810, 8, 0.0, v1 + 12576);
  *(_WORD *)(v1 + 18134) = 6;
  *(_DWORD *)(v1 + 18136) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 18140) = 1;
  sub_10060F20(v1 + 220, 1, v1 + 12576);
  *(float *)(v1 + 14916) = 18.0;
  *(float *)(v1 + 14876) = 7.0;
  *(_BYTE *)(v1 + 15416) = 0;
  *(float *)(v1 + 14880) = 255.0;
  *(float *)(v1 + 14908) = 0.0;
  *(float *)(v1 + 14952) = *(float *)(v1 + 14952) + 5.0;
  *(float *)(v1 + 14956) = *(float *)(v1 + 14956) - 10.0;
  *(float *)(v1 + 14976) = 0.0;
  *(float *)(v1 + 12608) = 64.0;
  sub_10061B00(v1 + 18172, (int)byte_100B8180, dword_1031FB44 + 4076, 7.0, 132.0, 128.0, 128.0);
  sub_10060F80(dword_1031FB44 + 20508, v1 + 18172);
  *(float *)(v1 + 18392) = 50.0;
  *(_BYTE *)(v1 + 18576) = 4;
  *(float *)(v1 + 18396) = -50.0;
  *(float *)(v1 + 18492) = *(float *)(dword_1031FB44 + 4088);
  *(float *)(v1 + 18496) = -45.0;
  *(float *)(v1 + 18504) = *(float *)(dword_1031FB44 + 4092);
  *(float *)(v1 + 18508) = -90.0;
  *(float *)(v1 + 18516) = *(float *)(dword_1031FB44 + 4084);
  *(float *)(v1 + 18520) = -100.0;
  sub_10060E40((_BYTE *)(dword_1031FB44 + 4076), v1 + 18172);
  sub_100612A0((int)&unk_100C4810, 8, 0.0, v1 + 18172);
  *(_WORD *)(v1 + 23730) = 6;
  *(_DWORD *)(v1 + 23732) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 23736) = 1;
  sub_10060F20(v1 + 232, 1, v1 + 18172);
  *(float *)(v1 + 20512) = 18.0;
  *(float *)(v1 + 20472) = 135.0;
  *(float *)(v1 + 20476) = 255.0;
  *(float *)(v1 + 20504) = 1.0;
  *(float *)(v1 + 20548) = *(float *)(v1 + 20548) - 5.0;
  *(float *)(v1 + 20552) = *(float *)(v1 + 20552) - 10.0;
  *(float *)(v1 + 20572) = 1.0;
  *(float *)(v1 + 20996) = 71.0;
  *(float *)(v1 + 21000) = *(float *)(v1 + 21000) - 10.0;
  *(float *)(v1 + 21020) = 0.5;
  *(float *)(v1 + 18196) = 135.0;
  *(float *)(v1 + 18204) = -64.0;
  sub_10046960(v1 + 23768, (int)"RPM", dword_1031FB44 + 4076, 7.0, 255.0, 128.0, 15.0);
  *(float *)(v1 + 23800) = -20.0;
  *(float *)(v1 + 23848) = -20.0;
  *(float *)(v1 + 23948) = 177.0;
  *(_WORD *)(v1 + 24284) = 7;
  *(_DWORD *)(v1 + 24288) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 24292) = 1;
  *(_DWORD *)(v1 + 23816) = v1 + 228;
  *(_DWORD *)(v1 + 23864) = v1 + 240;
  v10 = 0;
  v5 = v1 + 62860;
  do
  {
    v6 = (double)(signed int)v10 * 45.0 + 180.0;
    v7 = v6 * 0.01745329251994333;
    v8 = cos(v7);
    *(float *)&v7 = sin(v7);
    *(_DWORD *)(v5 + 24) = 0;
    *(_DWORD *)(v5 + 20) = 0;
    *(_BYTE *)(v5 + 28) = 0;
    *(_DWORD *)(v5 + 48) = -1;
    v5 += 64;
    *(float *)(v5 - 72) = v8 * 30.0 + 71.0;
    ++v10;
    *(float *)(v5 - 64) = 30.0 * *(float *)&v7 + 233.0;
    *(float *)(v5 - 68) = v8 * 25.0 + 71.0;
    *(float *)(v5 - 60) = 25.0 * *(float *)&v7 + 233.0;
    *(float *)(v5 - 56) = 2.0;
    *(float *)(v5 - 52) = 0.0;
    *(float *)(v5 - 48) = 0.0;
    *(float *)(v5 - 28) = 0.0;
    *(float *)(v5 - 24) = 0.0;
    *(float *)(v5 - 20) = 0.0;
  }
  while ( v10 < 5 );
  sub_1004A1E0(v1 + 24380, (int)byte_100B8180, dword_1031FB44 + 4240, 7.0, 321.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C4890, 0x16u, 0, v1 + 24380);
  *(_WORD *)(v1 + 28692) = 33;
  *(_DWORD *)(v1 + 28696) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 28700) = 1;
  sub_10049040(v1 + 244, 2, 0, v1 + 24380);
  *(float *)(v1 + 25032) = 17.5;
  *(float *)(v1 + 25036) = 24.65;
  *(float *)(v1 + 25024) = *(float *)(v1 + 28572);
  *(float *)(v1 + 25028) = *(float *)(v1 + 28576) - 1.0;
  *(_BYTE *)(v1 + 25076) = 1;
  *(_DWORD *)(v1 + 25080) = -16711681;
  *(_BYTE *)(v1 + 25086) = 3;
  *(float *)(v1 + 25096) = 17.5;
  *(float *)(v1 + 25100) = 24.65;
  *(float *)(v1 + 25088) = *(float *)(v1 + 28572);
  *(float *)(v1 + 25092) = *(float *)(v1 + 28576);
  *(_BYTE *)(v1 + 25140) = 0;
  *(_DWORD *)(v1 + 25144) = -16711681;
  *(_BYTE *)(v1 + 25150) = 3;
  sub_10046960(v1 + 28872, (int)"FFLOW", dword_1031FB44 + 4240, 7.0, 299.0, 128.0, 15.0);
  *(_WORD *)(v1 + 29388) = 33;
  *(_DWORD *)(v1 + 29392) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 29396) = 1;
  *(_DWORD *)(v1 + 28920) = v1 + 252;
  *(_DWORD *)(v1 + 28968) = v1 + 264;
  *(_DWORD *)(v1 + 29116) = 4739143;
  *(float *)(v1 + 28928) = 0.042060129;
  *(float *)(v1 + 28976) = 0.042060129;
  sub_1004A1E0(v1 + 29652, (int)"CHT", dword_1031FB44 + 4404, 7.0, 395.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C49F0, 4u, 0, v1 + 29652);
  *(_WORD *)(v1 + 33964) = 18;
  *(_BYTE *)(v1 + 33972) = 1;
  *(_DWORD *)(v1 + 29680) = v1 + 272;
  *(_DWORD *)(v1 + 29704) = v1 + 276;
  *(_DWORD *)(v1 + 29684) = v1 + 344;
  *(_DWORD *)(v1 + 29708) = v1 + 348;
  *(_WORD *)(v1 + 30136) = 76;
  *(_WORD *)(v1 + 30200) = 82;
  sub_10048850(v1 + 34144, (int)byte_100B8180, dword_1031FB44 + 4404, 3.0, 561.0, 64.0, 84.0);
  *(_BYTE *)(v1 + 34244) = 12;
  *(float *)(v1 + 35120) = (*(float *)(v1 + 34168) - *(float *)(v1 + 34164)) / 12.0;
  *(_WORD *)(v1 + 35108) = 18;
  *(_DWORD *)(v1 + 35112) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 35116) = 1;
  sub_10047B10(v1 + 268, 6, 0, v1 + 34144);
  sub_10048850(v1 + 35392, (int)byte_100B8180, dword_1031FB44 + 4404, 80.0, 561.0, 64.0, 84.0);
  *(_BYTE *)(v1 + 35492) = 12;
  *(float *)(v1 + 36368) = (*(float *)(v1 + 35416) - *(float *)(v1 + 35412)) / 12.0;
  *(_WORD *)(v1 + 36356) = 18;
  *(_DWORD *)(v1 + 36360) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 36364) = 1;
  sub_10047B10(v1 + 340, 6, 0, v1 + 35392);
  sub_10046960(v1 + 36640, (int)"CHT C", dword_1031FB44 + 4404, 7.0, 684.0, 128.0, 15.0);
  *(_WORD *)(v1 + 37156) = 17;
  *(_DWORD *)(v1 + 37160) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 37164) = 1;
  *(_DWORD *)(v1 + 36688) = v1 + 288;
  *(_DWORD *)(v1 + 36736) = v1 + 384;
  *(float *)(v1 + 36668) = *(float *)(v1 + 36668) - 5.0;
  *(float *)(v1 + 36716) = *(float *)(v1 + 36716) + 7.0;
  *(float *)(v1 + 36672) = 684.0;
  *(float *)(v1 + 36720) = 684.0;
  *(float *)(v1 + 36860) = 1.0;
  sub_10046630(dword_1031FB44 + 20564, v1 + 36640);
  sub_1004A1E0(v1 + 40544, (int)"OIL TEMP", dword_1031FB44 + 4568, 7.0, 455.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C4A30, 4u, 0, v1 + 40544);
  *(_WORD *)(v1 + 44856) = 18;
  *(_BYTE *)(v1 + 44864) = 1;
  sub_10049040(v1 + 412, 2, 0, v1 + 40544);
  sub_10046960(v1 + 45036, (int)&unk_100BD954, dword_1031FB44 + 4568, 7.0, 353.0, 128.0, 15.0);
  *(_WORD *)(v1 + 45552) = 17;
  *(_DWORD *)(v1 + 45556) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 45560) = 1;
  *(_DWORD *)(v1 + 45084) = v1 + 420;
  *(_DWORD *)(v1 + 45132) = v1 + 432;
  *(float *)(v1 + 45068) = 353.0;
  *(float *)(v1 + 45116) = 353.0;
  *(float *)(v1 + 45256) = 1.0;
  *(float *)(v1 + 45092) = 150.0;
  *(float *)(v1 + 45140) = 150.0;
  sub_1004A1E0(v1 + 45648, (int)"OIL PRES", dword_1031FB44 + 4732, 7.0, 515.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C4A70, 4u, 0, v1 + 45648);
  sub_10049040(v1 + 436, 2, 0, v1 + 45648);
  *(_WORD *)(v1 + 49960) = 15;
  sub_10046960(v1 + 50140, (int)"PSI", dword_1031FB44 + 4732, 7.0, 378.0, 128.0, 15.0);
  sub_100465F0(v1 + 436, 2, v1 + 50140);
  sub_10046630(dword_1031FB44 + 20620, v1 + 50140);
  *(_WORD *)(v1 + 50656) = 15;
  sub_1004A1E0(v1 + 50752, (int)"ALT LOAD", dword_1031FB44 + 4896, 7.0, 575.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C4AB0, 4u, 0, v1 + 50752);
  *(_WORD *)(v1 + 55064) = 25;
  *(_BYTE *)(v1 + 55072) = 1;
  sub_10049040(v1 + 460, 2, 0, v1 + 50752);
  sub_10046960(v1 + 55244, (int)&unk_100C4E38, dword_1031FB44 + 4896, 7.0, 569.0, 128.0, 15.0);
  *(_WORD *)(v1 + 55760) = 22;
  *(_DWORD *)(v1 + 55764) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 55768) = 1;
  *(_DWORD *)(v1 + 55292) = v1 + 468;
  *(_DWORD *)(v1 + 55340) = v1 + 480;
  *(float *)(v1 + 55300) = 150.0;
  *(float *)(v1 + 55348) = 150.0;
  *(_DWORD *)(v1 + 55488) = *(_DWORD *)"LOAD %";
  *(_WORD *)(v1 + 55492) = *(_WORD *)" %";
  *(_BYTE *)(v1 + 55494) = aLoad[6];
  *(_WORD *)(v1 + 55540) = 76;
  *(_WORD *)(v1 + 55592) = 82;
  sub_10046960(v1 + 55856, (int)&unk_100B8EDC, dword_1031FB44 + 5060, 7.0, 612.0, 128.0, 15.0);
  *(_WORD *)(v1 + 56372) = 21;
  *(_DWORD *)(v1 + 56376) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 56380) = 1;
  *(_DWORD *)(v1 + 56100) = *(_DWORD *)"VOLTS";
  *(_WORD *)(v1 + 56104) = *(_WORD *)"S";
  *(_WORD *)(v1 + 56152) = 76;
  *(_WORD *)(v1 + 56204) = 82;
  *(_DWORD *)(v1 + 55904) = v1 + 492;
  *(_DWORD *)(v1 + 55952) = v1 + 504;
  sub_1004A1E0(v1 + 56468, (int)"FUEL QTY GAL", dword_1031FB44 + 5224, 7.0, 635.0, 135.0, 37.0, 0);
  sub_10049310((int)&unk_100C4B30, 0x12u, 0, v1 + 56468);
  *(_WORD *)(v1 + 60780) = 31;
  *(_BYTE *)(v1 + 60788) = 1;
  sub_10049040(v1 + 508, 2, 0, v1 + 56468);
  *(_DWORD *)(v1 + 57360) = -65536;
  *(_DWORD *)(v1 + 57424) = -65536;
  *(float *)(v1 + 57676) = 12.0;
  *(float *)(v1 + 57932) = 12.0;
  *(float *)(v1 + 58188) = 12.0;
  sub_10048850(v1 + 37252, (int)byte_100B8180, dword_1031FB44 + 5388, 3.0, 421.0, 64.0, 84.0);
  *(_BYTE *)(v1 + 37352) = 12;
  *(float *)(v1 + 38228) = (*(float *)(v1 + 37276) - *(float *)(v1 + 37272)) / 12.0;
  *(_WORD *)(v1 + 38216) = 18;
  *(_DWORD *)(v1 + 38220) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 38224) = 1;
  *(_BYTE *)(v1 + 38225) = 1;
  sub_10047B10(v1 + 532, 6, 0, v1 + 37252);
  sub_10048850(v1 + 38500, (int)byte_100B8180, dword_1031FB44 + 5388, 80.0, 421.0, 64.0, 84.0);
  *(_BYTE *)(v1 + 38600) = 12;
  *(float *)(v1 + 39476) = (*(float *)(v1 + 38524) - *(float *)(v1 + 38520)) / 12.0;
  *(_WORD *)(v1 + 39464) = 18;
  *(_DWORD *)(v1 + 39468) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 39472) = 1;
  *(_BYTE *)(v1 + 39473) = 1;
  sub_10047B10(v1 + 604, 6, 0, v1 + 38500);
  sub_10046960(v1 + 39748, (int)"EGT C", dword_1031FB44 + 5388, 7.0, 544.0, 128.0, 15.0);
  *(_WORD *)(v1 + 40264) = 17;
  *(_DWORD *)(v1 + 40268) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 40272) = 1;
  *(_DWORD *)(v1 + 39796) = v1 + 552;
  *(_DWORD *)(v1 + 39844) = v1 + 648;
  *(float *)(v1 + 39776) = *(float *)(v1 + 39776) - 5.0;
  *(float *)(v1 + 39824) = *(float *)(v1 + 39824) + 7.0;
  *(float *)(v1 + 39780) = 544.0;
  *(float *)(v1 + 39828) = 544.0;
  *(float *)(v1 + 39968) = 1.0;
  sub_10046630(dword_1031FB44 + 20732, v1 + 39748);
  sub_10046960(v1 + 60960, (int)"PEAK C", dword_1031FB44 + 5552, 7.0, 396.0, 128.0, 15.0);
  *(_WORD *)(v1 + 61476) = 17;
  *(_DWORD *)(v1 + 61480) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 61484) = 1;
  *(_DWORD *)(v1 + 61008) = v1 + 680;
  *(_DWORD *)(v1 + 61056) = v1 + 692;
  *(float *)(v1 + 60988) = *(float *)(v1 + 60988) - 8.0;
  *(float *)(v1 + 61036) = *(float *)(v1 + 61036) + 9.0;
  *(float *)(v1 + 60992) = 408.0;
  *(float *)(v1 + 61040) = 408.0;
  sub_10046920(v1 + 61572, (int)"GAL REM", dword_1031FB44 + 5552, 7.0, 459.0, 128.0, 15.0);
  *(_WORD *)(v1 + 62088) = 31;
  *(_DWORD *)(v1 + 62092) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 62096) = 1;
  *(_DWORD *)(v1 + 61620) = v1 + 704;
  result = sub_10046920(v1 + 62184, (int)"GAL USED", dword_1031FB44 + 5552, 7.0, 484.0, 128.0, 15.0);
  *(_WORD *)(v1 + 62700) = 31;
  *(_DWORD *)(v1 + 62704) = &unk_100B8DC0;
  *(_BYTE *)(v1 + 62708) = 1;
  *(_DWORD *)(v1 + 62232) = v1 + 716;
  return result;
}
// 100C4710: using guessed type int dword_100C4710[];
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10030760) --------------------------------------------------------
int __usercall sub_10030760@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4D04, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_100653C0(
             a1,
             *(_WORD **)(a1 + 52),
             *(char **)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 132),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 112),
             *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 176),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100307E0) --------------------------------------------------------
char __usercall sub_100307E0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  char result; // al@1

  v1 = sub_100015A0(a1, *(char **)(a1 + 56), 63172, 0);
  v2 = v1;
  *(_BYTE *)(v1 + 62796) = 0;
  sub_100011B0(a1, 0, 0, 151, 686, 3);
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(v3 + 230) = -1;
  *(_BYTE *)(v2 + 62797) = sub_1004BF10((void *)v3);
  *(_DWORD *)(v2 + 116) = v2 + 52;
  *(_DWORD *)(v2 + 120) = v2 + 88;
  *(_DWORD *)(v2 + 112) = v2 + 24;
  *(_DWORD *)(v2 + 132) = &unk_100C4D38;
  *(_DWORD *)(v2 + 136) = &unk_100C4D78;
  *(_DWORD *)(v2 + 140) = &unk_100C4DC4;
  sub_1002F390(a1);
  *(_BYTE *)(v2 + 62798) = -1;
  *(_BYTE *)(v2 + 62799) = -1;
  *(_BYTE *)(v2 + 62800) = 0;
  sub_1004CCA0(v2 + 40360, 1);
  *(_DWORD *)(v2 + 40364) = v2 + 536;
  *(_DWORD *)(v2 + 40388) = v2 + 248;
  *(_DWORD *)(v2 + 40376) = v2 + 572;
  *(_DWORD *)(v2 + 40368) = v2 + 548;
  *(_DWORD *)(v2 + 40372) = v2 + 560;
  *(_BYTE *)(v2 + 40360) = 6;
  *(_DWORD *)(v2 + 40380) = v2 + 584;
  *(_DWORD *)(v2 + 40384) = v2 + 596;
  sub_1004CCA0(v2 + 40452, 1);
  *(_DWORD *)(v2 + 40480) = v2 + 260;
  *(_DWORD *)(v2 + 40464) = v2 + 632;
  *(_DWORD *)(v2 + 40456) = v2 + 608;
  *(_DWORD *)(v2 + 40460) = v2 + 620;
  *(_DWORD *)(v2 + 40476) = v2 + 668;
  *(_BYTE *)(v2 + 40452) = 6;
  *(_DWORD *)(v2 + 40468) = v2 + 644;
  *(_DWORD *)(v2 + 40472) = v2 + 656;
  *(_DWORD *)(v2 + 29488) = 1017923390;
  *(_DWORD *)(v2 + 29492) = 1017923390;
  *(_DWORD *)(v2 + 29496) = 1017923390;
  *(_DWORD *)(v2 + 29500) = 1017923390;
  *(_DWORD *)(v2 + 29504) = 1017923390;
  *(_DWORD *)(v2 + 29508) = 1017923390;
  *(_DWORD *)(v2 + 29512) = 1017923390;
  *(_DWORD *)(v2 + 29516) = 1017923390;
  *(_DWORD *)(v2 + 29520) = 1017923390;
  *(_DWORD *)(v2 + 29524) = 1017923390;
  *(_DWORD *)(v2 + 29528) = 1017923390;
  *(_DWORD *)(v2 + 29532) = 1017923390;
  *(_DWORD *)(v2 + 29536) = 1017923390;
  *(_DWORD *)(v2 + 29540) = 1017923390;
  *(_DWORD *)(v2 + 29544) = 1017923390;
  *(_DWORD *)(v2 + 29548) = 1017923390;
  *(_DWORD *)(v2 + 29552) = 1017923390;
  *(_DWORD *)(v2 + 29556) = 1017923390;
  *(_DWORD *)(v2 + 29560) = 1017923390;
  *(_DWORD *)(v2 + 29564) = 1017923390;
  *(_DWORD *)(v2 + 29572) = 1017923390;
  *(_DWORD *)(v2 + 29576) = 1017923390;
  *(_DWORD *)(v2 + 29580) = 1017923390;
  *(_DWORD *)(v2 + 29584) = 1017923390;
  *(_DWORD *)(v2 + 29588) = 1017923390;
  *(_DWORD *)(v2 + 29592) = 1017923390;
  *(_DWORD *)(v2 + 29596) = 1017923390;
  *(_DWORD *)(v2 + 29600) = 1017923390;
  *(_DWORD *)(v2 + 29604) = 1017923390;
  *(_DWORD *)(v2 + 29608) = 1017923390;
  *(_DWORD *)(v2 + 29612) = 1017923390;
  *(_DWORD *)(v2 + 29616) = 1017923390;
  *(_DWORD *)(v2 + 29620) = 1017923390;
  *(_DWORD *)(v2 + 29624) = 1017923390;
  *(_DWORD *)(v2 + 29628) = 1017923390;
  *(_DWORD *)(v2 + 29632) = 1017923390;
  *(_DWORD *)(v2 + 29636) = 1017923390;
  *(_DWORD *)(v2 + 29640) = 1017923390;
  *(_DWORD *)(v2 + 29644) = 1017923390;
  *(_DWORD *)(v2 + 29648) = 1017923390;
  *(float *)(v2 + 62812) = 0.0;
  *(float *)(v2 + 62816) = 0.0;
  *(float *)(v2 + 62820) = 0.0;
  *(float *)(v2 + 62824) = 0.0;
  *(float *)(v2 + 62828) = 0.0;
  *(float *)(v2 + 62832) = 0.0;
  *(float *)(v2 + 62836) = 0.0;
  *(float *)(v2 + 62840) = 0.0;
  *(float *)(v2 + 62844) = 0.0;
  *(float *)(v2 + 62848) = 0.0;
  *(_DWORD *)(v2 + 4) = v2 + 772;
  *(_DWORD *)(v2 + 16) = v2 + 12576;
  *(_DWORD *)(v2 + 32) = v2 + 29652;
  *(_DWORD *)(v2 + 36) = v2 + 40544;
  *(_DWORD *)(v2 + 8) = v2 + 6368;
  *(_DWORD *)v2 = v2 + 11964;
  *(_DWORD *)(v2 + 40) = v2 + 45648;
  *(_DWORD *)(v2 + 20) = v2 + 18172;
  *(_DWORD *)(v2 + 12) = v2 + 23768;
  *(_DWORD *)(v2 + 44) = v2 + 50752;
  *(_DWORD *)(v2 + 28) = v2 + 28872;
  *(_DWORD *)(v2 + 56) = v2 + 28872;
  *(_DWORD *)(v2 + 24) = v2 + 24380;
  *(_DWORD *)(v2 + 48) = v2 + 56468;
  *(_DWORD *)(v2 + 52) = v2 + 24380;
  *(_DWORD *)(v2 + 60) = v2 + 60960;
  *(_DWORD *)(v2 + 64) = v2 + 37252;
  *(_DWORD *)(v2 + 68) = v2 + 38500;
  *(_DWORD *)(v2 + 72) = v2 + 39748;
  *(_DWORD *)(v2 + 76) = v2 + 34144;
  *(_DWORD *)(v2 + 80) = v2 + 35392;
  *(_DWORD *)(v2 + 84) = v2 + 36640;
  *(_DWORD *)(v2 + 88) = v2 + 45036;
  *(_DWORD *)(v2 + 92) = v2 + 50140;
  *(_DWORD *)(v2 + 96) = v2 + 61572;
  *(_DWORD *)(v2 + 100) = v2 + 62184;
  *(_DWORD *)(v2 + 104) = v2 + 55244;
  *(_DWORD *)(v2 + 108) = v2 + 55856;
  *(_DWORD *)(v2 + 176) = v2 + 152;
  *(_DWORD *)(v2 + 184) = v2 + 159;
  *(_DWORD *)(v2 + 180) = v2 + 165;
  *(_BYTE *)(v2 + 152) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 176) + 6) = 3;
  **(_BYTE **)(v2 + 180) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 5) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 6) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 7) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 180) + 8) = 3;
  **(_BYTE **)(v2 + 184) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 184) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 184) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 184) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 184) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v2 + 184) + 5) = 3;
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4D04, v2, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4D38, v2 + 24, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4D78, v2 + 52, 0, 255);
  sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4DC4, v2 + 88, 0, 255);
  sub_10001750(a1, *(_DWORD *)(a1 + 56), 50);
  result = sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10030D10) --------------------------------------------------------
char __usercall sub_10030D10@<al>(int a1@<eax>)
{
  int v1; // esi@1
  _BYTE *v2; // edi@1
  char result; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (_BYTE *)(v1 + 40360);
  *(_DWORD *)(v1 + 37328) = 0;
  *(_DWORD *)(v1 + 38576) = 0;
  *(_DWORD *)(v1 + 37332) = 0;
  *(_DWORD *)(v1 + 38580) = 0;
  *(_DWORD *)(v1 + 37336) = 0;
  *(_DWORD *)(v1 + 38584) = 0;
  *(_DWORD *)(v1 + 37340) = 0;
  *(_DWORD *)(v1 + 38588) = 0;
  *(_DWORD *)(v1 + 37344) = 0;
  *(_DWORD *)(v1 + 38592) = 0;
  *(_DWORD *)(v1 + 37348) = 0;
  *(_DWORD *)(v1 + 38596) = 0;
  sub_1004CCA0(v1 + 40360, 1);
  v1 += 40452;
  result = sub_1004CCA0(v1, 1);
  *v2 = 6;
  *(_BYTE *)v1 = 6;
  return result;
}

//----- (10030D90) --------------------------------------------------------
char __usercall sub_10030D90@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char result; // al@1
  int v3; // edx@2
  int v4; // ecx@3
  signed int v5; // edi@3
  int v6; // esi@3
  signed int v7; // ebx@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10030D10(a1);
  result = 2;
  if ( *(_BYTE *)(v1 + 62800) == 2 )
  {
    v4 = *(_DWORD *)(v1 + 180);
    *(_BYTE *)(v1 + 62800) = 0;
    v5 = 1;
    *(_BYTE *)(v4 + 2) = 0;
    v6 = v1 + 38672;
    v7 = 6;
    do
    {
      sprintf((char *)(v6 - 1248), "%d", v5);
      result = sprintf((char *)v6, "%d", v5);
      *(float *)(v6 - 1216) = 9.0;
      *(float *)(v6 + 32) = 9.0;
      ++v5;
      v6 += 52;
      --v7;
    }
    while ( v7 );
  }
  else
  {
    v3 = *(_DWORD *)(v1 + 180);
    *(_BYTE *)(v1 + 62800) = 2;
    *(_BYTE *)(v3 + 2) = 3;
  }
  return result;
}

//----- (10030E20) --------------------------------------------------------
int __usercall sub_10030E20@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ebx@1
  char v3; // al@1
  unsigned __int8 v4; // cl@1
  int v5; // ecx@4
  int v6; // eax@4
  int v7; // edx@4
  int result; // eax@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (unsigned __int8)sub_10066EE0(v1 + 196, 6u, 6u);
  v3 = sub_10066EE0(v1 + 196, 0xCu, 6u);
  v4 = *(_BYTE *)(v1 + 62800);
  if ( !v4 || v4 > 2u )
  {
    *(_BYTE *)(v1 + 35106) = v2;
    *(_BYTE *)(v1 + 36354) = v3;
  }
  *(_DWORD *)(v1 + 29680) = v1 + 12 * v2 + 272;
  *(_DWORD *)(v1 + 29704) = v1 + 4 * (3 * v2 + 69);
  v5 = v1 + 12 * (unsigned __int8)v3 + 344;
  *(_DWORD *)(v1 + 29708) = v1 + 4 * (3 * (unsigned __int8)v3 + 87);
  v6 = *(_BYTE *)(v1 + 35106) + 23;
  *(_DWORD *)(v1 + 29684) = v5;
  v7 = v1 + 12 * v6;
  result = 3 * (*(_BYTE *)(v1 + 36354) + 29);
  *(_DWORD *)(v1 + 36688) = v7;
  *(_DWORD *)(v1 + 36736) = v1 + 4 * result;
  return result;
}

//----- (10030EE0) --------------------------------------------------------
int __usercall sub_10030EE0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // bl@1
  int v3; // eax@3
  double v4; // st6@5
  double v5; // st7@5
  double v6; // st5@8
  int v7; // eax@10
  double v8; // st7@11
  double v9; // rt2@11
  double v10; // st5@11
  double v11; // st6@11
  bool v12; // c0@13
  bool v13; // c3@13
  double v14; // st7@13
  float v15; // ST40_4@15
  int result; // eax@15
  char v17; // [sp+Fh] [bp-5h]@1
  float v18; // [sp+10h] [bp-4h]@4
  float v19; // [sp+10h] [bp-4h]@10

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_10066EE0(v1 + 196, 0x1Cu, 6u);
  v17 = sub_10066EE0(v1 + 196, 0x22u, 6u);
  if ( !*(_BYTE *)(v1 + 62800) )
  {
    *(_BYTE *)(v1 + 38214) = sub_10066EE0(v1 + 196, 0x1Cu, 6u);
    *(_BYTE *)(v1 + 39462) = sub_10066EE0(v1 + 196, 0x22u, 6u);
    *(_BYTE *)(v1 + 35106) = sub_10066EE0(v1 + 196, 6u, 6u);
    *(_BYTE *)(v1 + 36354) = sub_10066EE0(v1 + 196, 0xCu, 6u);
    *(_DWORD *)(v1 + 39796) = v1 + 12 * ((unsigned __int8)v2 + 45);
    v3 = (unsigned __int8)v17;
    goto LABEL_17;
  }
  if ( *(_BYTE *)(v1 + 62800) != 2 )
  {
    *(_DWORD *)(v1 + 39796) = v1 + 12 * (*(_BYTE *)(v1 + 38214) + 45);
    v3 = *(_BYTE *)(v1 + 39462);
LABEL_17:
    result = v3 + 51;
    *(_DWORD *)(v1 + 39844) = v1 + 12 * result;
    return result;
  }
  sub_10047850(v1 + 40360, v1 + 37252);
  sub_10047850(v1 + 40452, v1 + 38500);
  v18 = *(float *)(v1 + 12 * *(_BYTE *)(v1 + 40394) + 536) - *(float *)(v1 + 4 * *(_BYTE *)(v1 + 40394) + 40404);
  if ( v18 <= 0.0 )
  {
    v4 = 0.0;
    v5 = 0.0;
  }
  else
  {
    v4 = 0.0;
    v5 = 0.0;
    v18 = 0.0;
  }
  *(float *)(v1 + 680) = v18;
  if ( v18 <= -500.0 )
  {
    v18 = -500.0;
    v6 = -500.0;
  }
  else
  {
    v6 = -500.0;
  }
  v7 = *(_BYTE *)(v1 + 40486);
  *(float *)(v1 + 680) = v18;
  v19 = *(float *)(v1 + 12 * v7 + 608) - *(float *)(v1 + 4 * v7 + 40496);
  if ( v19 <= v5 )
  {
    v11 = v6;
    v8 = -500.0;
  }
  else
  {
    v8 = -500.0;
    v9 = v6;
    v10 = v4;
    v11 = v9;
    v19 = v10;
  }
  *(float *)(v1 + 692) = v19;
  v12 = v19 < v8;
  v13 = v19 == v8;
  v14 = v19;
  if ( v12 || v13 )
    v14 = v11;
  v15 = v14;
  *(float *)(v1 + 692) = v15;
  *(_BYTE *)(v1 + 36354) = v17;
  result = 3 * ((unsigned __int8)v17 + 51);
  *(_BYTE *)(v1 + 35106) = v2;
  *(_DWORD *)(v1 + 39796) = v1 + 12 * ((unsigned __int8)v2 + 45);
  *(_DWORD *)(v1 + 39844) = v1 + 12 * ((unsigned __int8)v17 + 51);
  return result;
}

//----- (10031100) --------------------------------------------------------
void __cdecl sub_10031100(int a1)
{
  int v1; // esi@1
  float *v2; // eax@1
  signed int v3; // ecx@1
  unsigned int v4; // edi@3
  double v5; // st7@4
  int v6; // eax@4
  int v7; // eax@14
  int v8; // ebx@16
  float *v9; // ebp@17
  float *v10; // ebx@25
  float *v11; // ecx@32
  float *v12; // eax@33
  double v13; // st7@35
  int v14; // edx@39
  int v15; // ecx@39
  double v16; // st6@40
  double v17; // st7@40
  float v18; // [sp+1Ch] [bp-2Ch]@5
  float v19; // [sp+20h] [bp-28h]@13
  float v20; // [sp+24h] [bp-24h]@17
  int v21; // [sp+28h] [bp-20h]@16
  int v22; // [sp+2Ch] [bp-1Ch]@14
  int v23; // [sp+30h] [bp-18h]@16
  float v24; // [sp+34h] [bp-14h]@16
  float v25; // [sp+38h] [bp-10h]@16
  float v26; // [sp+3Ch] [bp-Ch]@16
  float v27; // [sp+40h] [bp-8h]@16
  float v28; // [sp+44h] [bp-4h]@16
  float v29; // [sp+4Ch] [bp+4h]@39
  float v30; // [sp+4Ch] [bp+4h]@42
  float v31; // [sp+4Ch] [bp+4h]@43

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 200);
  v3 = 48;
  do
  {
    *v2 = 9.8999998e24;
    v2 += 3;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  do
  {
    v5 = sub_1004C3E0(word_100C45BA[v4]);
    v6 = (unsigned __int8)byte_100C45B8[v4 * 2];
    v4 += 2;
    *(float *)(v1 + 12 * v6 + 200) = v5;
  }
  while ( v4 < 76 );
  if ( sub_100664A0(&v18) )
    *(float *)(v1 + 512) = v18;
  if ( sub_10066510(&v18) )
    *(float *)(v1 + 524) = v18;
  if ( sub_100663D0(&v18) )
  {
    *(float *)(v1 + 248) = v18;
    *(float *)(v1 + 752) = v18;
  }
  if ( sub_100663F0(&v18) )
  {
    *(float *)(v1 + 260) = v18;
    *(float *)(v1 + 764) = v18;
  }
  if ( !sub_10051BA0(&v19) )
  {
    *(_DWORD *)(v1 + 24420) = 0;
    *(_DWORD *)(v1 + 24424) = 0;
    goto LABEL_39;
  }
  v22 = (signed int)sub_100956A0(v19, 609.60004);
  v7 = sub_1006E440(&v22, 4u, (int)dword_100C4710, 16, 10, 9);
  if ( v7 < 1 )
    v7 = 1;
  v8 = 4 * v7;
  *(float *)&v23 = (double)dword_100C4700[4 * v7];
  v24 = flt_100C470C[4 * v7];
  v25 = 1.0;
  v26 = (double)dword_100C4710[4 * v7];
  v27 = flt_100C471C[4 * v7];
  v28 = 1.0;
  *(float *)&v21 = sub_10065120(v19, (int)&v23, 2);
  if ( *(float *)(v1 + 732) >= 2510.0 )
  {
    memcpy((void *)(v1 + 29488), (const void *)(v1 + 29492), 0x4Cu);
    v24 = flt_100C4704[v8];
    v27 = flt_100C4714[v8];
    v20 = sub_10065120(v19, (int)&v23, 2);
    v9 = (float *)(v1 + 29484);
    *(float *)(v1 + 29564) = v20;
    *(float *)(v1 + 29484) = sub_1002CC10(v1 + 29488, 20);
    if ( !*(_DWORD *)(v1 + 24420) )
    {
      sub_1002F380((void *)(v1 + 29488), 20, SLODWORD(v20));
      *v9 = *(float *)(v1 + 29488);
      *(_DWORD *)(v1 + 24420) = v9;
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if ( *(float *)&v21 < (double)*(float *)(v1 + 756) )
  {
    memcpy((void *)(v1 + 29488), (const void *)(v1 + 29492), 0x4Cu);
    v24 = flt_100C4708[v8];
    v27 = flt_100C4718[v8];
    v20 = sub_10065120(v19, (int)&v23, 2);
    v9 = (float *)(v1 + 29484);
    *(float *)(v1 + 29564) = v20;
    *(float *)(v1 + 29484) = sub_1002CC10(v1 + 29488, 20);
    if ( !*(_DWORD *)(v1 + 24420) )
    {
      sub_1002F380((void *)(v1 + 29488), 20, SLODWORD(v20));
      *v9 = *(float *)(v1 + 29488);
    }
LABEL_22:
    *(_DWORD *)(v1 + 24420) = v9;
    goto LABEL_24;
  }
  *(_DWORD *)(v1 + 24420) = 0;
LABEL_24:
  if ( *(float *)(v1 + 744) < 2510.0 )
  {
    if ( *(float *)&v21 >= (double)*(float *)(v1 + 768) )
    {
      *(_DWORD *)(v1 + 24424) = 0;
      goto LABEL_32;
    }
    memcpy((void *)(v1 + 29572), (const void *)(v1 + 29576), 0x4Cu);
    v24 = flt_100C4708[v8];
    v27 = flt_100C4718[v8];
    *(float *)&v21 = sub_10065120(v19, (int)&v23, 2);
    v10 = (float *)(v1 + 29568);
    *(float *)(v1 + 29648) = *(float *)&v21;
    *(float *)(v1 + 29568) = sub_1002CC10(v1 + 29572, 20);
    if ( !*(_DWORD *)(v1 + 24424) )
    {
      sub_1002F380((void *)(v1 + 29572), 20, v21);
      *v10 = *(float *)(v1 + 29572);
    }
    goto LABEL_30;
  }
  memcpy((void *)(v1 + 29572), (const void *)(v1 + 29576), 0x4Cu);
  v24 = flt_100C4704[v8];
  v27 = flt_100C4714[v8];
  v20 = sub_10065120(v19, (int)&v23, 2);
  v10 = (float *)(v1 + 29568);
  *(float *)(v1 + 29648) = v20;
  *(float *)(v1 + 29568) = sub_1002CC10(v1 + 29572, 20);
  if ( *(_DWORD *)(v1 + 24424) )
  {
LABEL_30:
    *(_DWORD *)(v1 + 24424) = v10;
    goto LABEL_32;
  }
  sub_1002F380((void *)(v1 + 29572), 20, SLODWORD(v20));
  *v10 = *(float *)(v1 + 29572);
  *(_DWORD *)(v1 + 24424) = v10;
LABEL_32:
  v11 = *(float **)(v1 + 24420);
  if ( v11 )
  {
    v12 = *(float **)(v1 + 24424);
    if ( v12 )
    {
      if ( *v12 != *v11 )
      {
        v21 = *(int *)(v1 + 29564);
        v20 = *(float *)(v1 + 29648);
        v13 = *(float *)&v21;
        if ( v20 >= (double)*(float *)&v21 )
          v13 = v20;
        v18 = v13;
        *(float *)(v1 + 29564) = v18;
        *(float *)(v1 + 29648) = v18;
        *(float *)(v1 + 29484) = sub_1002CC10(v1 + 29488, 20);
        *(float *)(v1 + 29568) = sub_1002CC10(v1 + 29572, 20);
      }
    }
  }
LABEL_39:
  sub_10030E20(a1);
  sub_10030EE0(a1);
  *(float *)(v1 + 704) = sub_1004C0C0();
  *(float *)(v1 + 716) = sub_1004C0D0(v15, v14);
  sub_1004C380(v1 + 196, 0x30u);
  v29 = *(float *)(v1 + 468);
  if ( v29 >= 0.0 )
  {
    v16 = 0.0;
    v17 = 0.0;
  }
  else
  {
    v16 = 0.0;
    v17 = 0.0;
    v29 = 0.0;
  }
  *(float *)(v1 + 468) = v29;
  v30 = *(float *)(v1 + 480);
  if ( v30 >= v17 )
  {
    *(float *)(v1 + 480) = v30;
  }
  else
  {
    v31 = v16;
    *(float *)(v1 + 480) = v31;
  }
}
// 1004C0C0: using guessed type double sub_1004C0C0(void);
// 1004C0D0: using guessed type double __fastcall sub_1004C0D0(_DWORD, _DWORD);
// 100C45BA: using guessed type __int16 word_100C45BA[];
// 100C4700: using guessed type int dword_100C4700[];
// 100C4704: using guessed type float flt_100C4704[];
// 100C4708: using guessed type float flt_100C4708[];
// 100C470C: using guessed type float flt_100C470C[];
// 100C4710: using guessed type int dword_100C4710[];
// 100C4714: using guessed type float flt_100C4714[];
// 100C4718: using guessed type float flt_100C4718[];
// 100C471C: using guessed type float flt_100C471C[];

//----- (10031690) --------------------------------------------------------
unsigned __int8 __usercall sub_10031690@<al>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned __int8 result; // al@27
  unsigned __int8 v3; // cl@27

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( 9.8999998e24 != *(float *)(v1 + 228) || 9.8999998e24 != *(float *)(v1 + 240) )
    *(_BYTE *)(v1 + 56320) = *(_BYTE *)(dword_1031FB44 + 5155);
  else
    *(_BYTE *)(v1 + 56320) = 10;
  if ( *(float *)(v1 + 228) >= 500.0 || *(float *)(v1 + 240) >= 500.0 )
  {
    *(_BYTE *)(v1 + 40920) = *(_BYTE *)(dword_1031FB44 + 4660);
    *(_BYTE *)(v1 + 45476) = *(_BYTE *)(dword_1031FB44 + 4660);
    *(_BYTE *)(v1 + 46024) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v1 + 46032) = *(_BYTE *)(dword_1031FB44 + 4825);
    *(_BYTE *)(v1 + 50580) = *(_BYTE *)(dword_1031FB44 + 4824);
    *(_BYTE *)(v1 + 50588) = *(_BYTE *)(dword_1031FB44 + 4825);
    *(_BYTE *)(v1 + 56304) = *(_BYTE *)(dword_1031FB44 + 5153);
  }
  else
  {
    *(_BYTE *)(v1 + 40920) = 10;
    *(_BYTE *)(v1 + 45476) = 10;
    *(_BYTE *)(v1 + 46024) = 10;
    *(_BYTE *)(v1 + 46032) = 10;
    *(_BYTE *)(v1 + 50580) = 10;
    *(_BYTE *)(v1 + 50588) = 10;
    *(_BYTE *)(v1 + 56304) = 10;
  }
  if ( *(_DWORD *)(v1 + 62804) || *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 228) )
  {
    if ( *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 228) )
      *(_DWORD *)(v1 + 62804) = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 62804) = sub_1008C780();
  }
  if ( *(_DWORD *)(v1 + 62804) && (unsigned int)(sub_1008C780() - *(_DWORD *)(v1 + 62804)) > 0x3A980 )
    *(_BYTE *)(v1 + 14560) = 11;
  else
    *(_BYTE *)(v1 + 14560) = *(_BYTE *)(dword_1031FB44 + 4170);
  if ( *(_DWORD *)(v1 + 62808) || *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 240) )
  {
    if ( *(float *)(dword_1031FB44 + 4092) >= (double)*(float *)(v1 + 240) )
      *(_DWORD *)(v1 + 62808) = 0;
  }
  else
  {
    *(_DWORD *)(v1 + 62808) = sub_1008C780();
  }
  if ( *(_DWORD *)(v1 + 62808) && (unsigned int)(sub_1008C780() - *(_DWORD *)(v1 + 62808)) > 0x3A980 )
    *(_BYTE *)(v1 + 20156) = 11;
  else
    *(_BYTE *)(v1 + 20156) = *(_BYTE *)(dword_1031FB44 + 4170);
  result = *(_BYTE *)(v1 + 14560);
  v3 = *(_BYTE *)(v1 + 20156);
  if ( result <= v3 )
    *(_BYTE *)(v1 + 24224) = v3;
  else
    *(_BYTE *)(v1 + 24224) = result;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (100318E0) --------------------------------------------------------
void __usercall sub_100318E0(int a1@<ebx>)
{
  int v1; // esi@1
  float v2; // ST34_4@3
  float v3; // [sp+20h] [bp-20h]@3
  float v4; // [sp+24h] [bp-1Ch]@3
  float v5; // [sp+28h] [bp-18h]@3
  float v6; // [sp+2Ch] [bp-14h]@3
  float v7; // [sp+30h] [bp-10h]@3
  float v8; // [sp+34h] [bp-Ch]@3
  float v9; // [sp+38h] [bp-8h]@3
  int v10; // [sp+3Ch] [bp-4h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( 9.8999998e24 != *(float *)(v1 + 236) && 9.8999998e24 != *(float *)(v1 + 224) )
  {
    v2 = (*(float *)(v1 + 236) - *(float *)(v1 + 224)) * 0.5;
    sub_1003B160(90.0, -90.0);
    memcpy((void *)(v1 + 62812), (const void *)(v1 + 62816), 0x24u);
    *(float *)(v1 + 62848) = v2;
    v10 = -1;
    v3 = 71.0;
    v4 = 233.0;
    v5 = 30.0;
    v8 = 10.0;
    v6 = 0.64999998;
    v7 = 0.75;
    v9 = 270.0 - sub_1002CC10(v1 + 62812, 10);
    sub_10069C80(a1, v1 + 62852, 5u, 1);
    sub_100671C0((int)&v3);
    sub_10067EE0(39.0, 201.0, 64.0, 64.0, 59);
  }
}

//----- (10031A20) --------------------------------------------------------
char __cdecl sub_10031A20(int a1)
{
  int v1; // ebp@1
  signed int v2; // edi@1
  int v3; // esi@1
  signed int v4; // ebx@1
  char v5; // ST14_1@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1004C150(0);
  *(_BYTE *)(v1 + 62800) = 0;
  *(_BYTE *)(v1 + 167) = 0;
  sub_10030D10(a1);
  v2 = 1;
  v3 = v1 + 38672;
  v4 = 6;
  do
  {
    sprintf((char *)(v3 - 1248), "%d", v2);
    sprintf((char *)v3, "%d", v2);
    *(float *)(v3 - 1216) = 9.0;
    *(float *)(v3 + 32) = 9.0;
    ++v2;
    v3 += 52;
    --v4;
  }
  while ( v4 );
  v5 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  *(_BYTE *)(v1 + 62797) = v5;
  sub_1004C170(v5);
  return sub_10001DD0(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10031AD0) --------------------------------------------------------
char __usercall sub_10031AD0@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@5
  int v3; // ST04_4@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( **(_WORD **)(a1 + 52) == 32819 )
  {
    if ( *(_BYTE *)(v1 + 62800) != 2 )
    {
      v2 = (unsigned __int8)(*(_BYTE *)(v1 + 38214) + 1) % 6;
      *(_BYTE *)(v1 + 62800) = 1;
      *(_BYTE *)(v1 + 38214) = v2;
      *(_BYTE *)(v1 + 35106) = v2;
      *(_BYTE *)(v1 + 39462) = v2;
      *(_BYTE *)(v1 + 36354) = v2;
    }
  }
  else if ( **(_WORD **)(a1 + 52) == 32824 )
  {
    sub_10030D90(a1);
  }
  v3 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10001DD0(a1, v3, -32734);
}

//----- (10031E80) --------------------------------------------------------
void __cdecl sub_10031E80(int a1)
{
  int v1; // edi@4
  void *v2; // ecx@4
  float v3; // ST3C_4@12
  double v4; // st6@12
  float v5; // ST3C_4@12
  float v6; // ST3C_4@12
  float v7; // ST3C_4@12
  float v8; // ST3C_4@12
  float v9; // ST3C_4@12
  float v10; // ST3C_4@12
  int v11; // eax@12
  signed int v12; // ecx@12
  float v13; // ST3C_4@12
  float v14; // ST3C_4@12
  float v15; // ST3C_4@12
  double v16; // st7@13

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      sub_10030760(a1);
      break;
    case 0x8041:
      sub_100307E0(a1);
      break;
    case 0x8022:
    case 0x8078:
      v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_10031100(a1);
      sub_10031690(a1);
      if ( sub_10052210(v2) == 2 && *(_BYTE *)(v1 + 62796) )
      {
        *(float *)(v1 + 200) = (*(float *)(v1 + 792) + *(float *)(v1 + 788)) * 0.5;
        *(float *)(v1 + 212) = (*(float *)(v1 + 6388) + *(float *)(v1 + 6384)) * 0.5;
        *(float *)(v1 + 224) = (*(float *)(v1 + 12596) + *(float *)(v1 + 12592)) * 0.5;
        *(float *)(v1 + 236) = (*(float *)(v1 + 18192) + *(float *)(v1 + 18188)) * 0.5;
        v3 = (*(float *)(v1 + 24404) + *(float *)(v1 + 24400)) * 0.5;
        *(float *)(v1 + 248) = v3;
        *(float *)(v1 + 260) = v3;
        v4 = *(float *)(v1 + 29676) + *(float *)(v1 + 29672);
        v5 = v4 * 0.5;
        *(float *)(v1 + 272) = v5;
        *(float *)(v1 + 284) = v5;
        *(float *)(v1 + 296) = v5;
        *(float *)(v1 + 308) = v5;
        *(float *)(v1 + 320) = v5;
        *(float *)(v1 + 332) = v5;
        v6 = v4 / 3.0;
        *(float *)(v1 + 344) = v6;
        *(float *)(v1 + 356) = v6;
        *(float *)(v1 + 368) = v6;
        *(float *)(v1 + 380) = v6;
        *(float *)(v1 + 392) = v6;
        *(float *)(v1 + 404) = v6;
        v7 = (*(float *)(v1 + 40568) + *(float *)(v1 + 40564)) * 0.5;
        *(float *)(v1 + 416) = v7;
        *(float *)(v1 + 428) = v7;
        v8 = (*(float *)(v1 + 45672) + *(float *)(v1 + 45668)) * 0.5;
        *(float *)(v1 + 440) = v8;
        *(float *)(v1 + 452) = v8;
        v9 = (*(float *)(v1 + 50776) + *(float *)(v1 + 50772)) * 0.5;
        *(float *)(v1 + 464) = v9;
        *(float *)(v1 + 476) = v9;
        v10 = (*(float *)(v1 + 37276) + *(float *)(v1 + 37272)) * 0.5;
        *(float *)(v1 + 536) = v10;
        *(float *)(v1 + 548) = v10;
        *(float *)(v1 + 560) = v10;
        *(float *)(v1 + 572) = v10;
        *(float *)(v1 + 584) = v10;
        *(float *)(v1 + 596) = v10;
        v11 = v1 + 204;
        v12 = 6;
        v13 = (*(float *)(v1 + 38524) + *(float *)(v1 + 38520)) / 3.0;
        *(float *)(v1 + 608) = v13;
        *(float *)(v1 + 620) = v13;
        *(float *)(v1 + 632) = v13;
        *(float *)(v1 + 644) = v13;
        *(float *)(v1 + 656) = v13;
        *(float *)(v1 + 668) = v13;
        v14 = (*(float *)(v1 + 60984) + *(float *)(v1 + 60980)) * 0.5;
        *(float *)(v1 + 680) = v14;
        *(float *)(v1 + 692) = v14;
        *(float *)(v1 + 704) = (*(float *)(v1 + 61596) + *(float *)(v1 + 61592)) * 0.5;
        *(float *)(v1 + 716) = (*(float *)(v1 + 62208) + *(float *)(v1 + 62204)) * 0.5;
        v15 = 0.5 * (*(float *)(v1 + 56492) + *(float *)(v1 + 56488));
        *(float *)(v1 + 512) = v15;
        *(float *)(v1 + 524) = v15;
        do
        {
          v16 = *(float *)(v11 - 4);
          v11 += 96;
          --v12;
          *(float *)(v11 - 96) = v16;
          *(float *)(v11 - 84) = *(float *)(v11 - 88);
          *(float *)(v11 - 72) = *(float *)(v11 - 76);
          *(float *)(v11 - 60) = *(float *)(v11 - 64);
          *(float *)(v11 - 48) = *(float *)(v11 - 52);
          *(float *)(v11 - 36) = *(float *)(v11 - 40);
          *(float *)(v11 - 24) = *(float *)(v11 - 28);
          *(float *)(v11 - 12) = *(float *)(v11 - 16);
        }
        while ( v12 );
      }
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4C50, (int)&unk_100C4DF8, 0, 255);
      if ( *(_BYTE *)(v1 + 62797) == 2 )
        sub_1002F140(a1);
      sub_100653C0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100C4D04, v1, 0, 255);
      sub_100653C0(
        a1,
        *(_WORD **)(a1 + 52),
        *(char **)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 132),
        *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 112),
        *(_DWORD *)(v1 + 4 * *(_BYTE *)(v1 + 62797) + 176),
        255);
      sub_100318E0(a1);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8039:
      sub_10031A20(a1);
      break;
    case 0x8033:
    case 0x8038:
      sub_10031AD0(a1);
      break;
    case 0x8034:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 62796) = 1;
      break;
    case 0x8035:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 62796) = 0;
      break;
    case 0x8061:
      JUMPOUT(&loc_10030D00);
      return;
    case 0x8017:
    case 0x8018:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8036:
    case 0x8037:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8048:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806E:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return;
  }
}

//----- (10031F70) --------------------------------------------------------
char __cdecl sub_10031F70(float a1, float a2, int a3)
{
  double v3; // st7@1
  char result; // al@3

  v3 = a1;
  if ( a1 <= 0.0 || 9.899999762399947e24 / v3 <= a2 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = (signed int)(v3 * a2);
    result = 1;
  }
  return result;
}

//----- (10031FC0) --------------------------------------------------------
char __cdecl sub_10031FC0(char a1)
{
  return sub_1008F8C0(a1, -122);
}

//----- (10031FE0) --------------------------------------------------------
char sub_10031FE0()
{
  sub_1008F870();
  return sub_10031FC0(0);
}

//----- (10031FF0) --------------------------------------------------------
_WORD *__cdecl sub_10031FF0(int a1)
{
  _WORD *result; // eax@1

  result = *(_WORD **)(a1 + 52);
  if ( *result == -32711 )
  {
    result = (_WORD *)sub_10001530(a1, (int)sub_10002B50);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = result;
  }
  return result;
}

//----- (10032090) --------------------------------------------------------
char __cdecl sub_10032090(unsigned int a1)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == 32918 )
  {
    sub_10052360();
    sub_1006ED80();
    sub_1004BEC0(a1, 1, sub_10002B50, 0);
    result = 1;
  }
  else if ( **(_WORD **)(a1 + 52) == 32920 )
  {
    sub_1008C7E0(4, 1, 0, 0);
    result = 1;
  }
  return result;
}

//----- (100320E0) --------------------------------------------------------
_WORD *__usercall sub_100320E0@<eax>(int a1@<edi>, int a2)
{
  char v2; // al@1
  _WORD *result; // eax@2

  v2 = *(_BYTE *)(a2 + 2);
  if ( v2 )
  {
    dword_101C5C74 = 18285286;
    dword_101C5C78 = 33554440;
    dword_101C5C70 = (int)&unk_10169070;
    *(_WORD *)(a2 + 16) = 279;
    if ( v2 == 1 )
    {
      *(_WORD *)(a2 + 14) = 686;
      sub_10002980(18285286, a1, a2);
      result = sub_10002AE0(a2);
    }
    else
    {
      *(_WORD *)(a2 + 14) = 742;
      sub_10002980(18285286, a1, a2);
      result = sub_10002AE0(a2);
    }
  }
  else
  {
    dword_101C5C70 = (int)&unk_10169070;
    dword_101C5C74 = 13763246;
    dword_101C5C78 = 16777224;
    *(_WORD *)(a2 + 14) = 686;
    *(_WORD *)(a2 + 16) = 210;
    sub_10002980(13763246, a1, a2);
    result = sub_10002AE0(a2);
  }
  return result;
}
// 101C5C70: using guessed type int dword_101C5C70;
// 101C5C74: using guessed type int dword_101C5C74;
// 101C5C78: using guessed type int dword_101C5C78;

//----- (10032190) --------------------------------------------------------
char __cdecl sub_10032190(int a1)
{
  int v1; // eax@1
  __int16 v2; // cx@2
  __int16 v4; // [sp+4h] [bp-D0h]@3
  int v5; // [sp+8h] [bp-CCh]@6

  v1 = sub_10001530(a1, (int)sub_10002B50);
  if ( v1 )
  {
    v2 = **(_WORD **)(a1 + 52);
    if ( v2 == -32749 )
    {
      v4 = -32747;
    }
    else if ( v2 == -32748 )
    {
      v4 = -32746;
    }
    v5 = v1;
    LOBYTE(v1) = sub_100016A0(a1, (int)&v4, 204);
  }
  return v1;
}

//----- (10032210) --------------------------------------------------------
char sub_10032210()
{
  char result; // al@1

  result = 0;
  byte_102BA90C = 0;
  byte_102BA90D = 0;
  return result;
}
// 102BA90C: using guessed type char byte_102BA90C;
// 102BA90D: using guessed type char byte_102BA90D;

//----- (10032220) --------------------------------------------------------
void __cdecl sub_10032220(unsigned int a1)
{
  sub_1004BEC0(a1, -1, sub_10002B50, 0);
}

//----- (10032250) --------------------------------------------------------
char __cdecl sub_10032250(int a1, unsigned __int8 a2)
{
  return *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2);
}

//----- (10032270) --------------------------------------------------------
int __cdecl sub_10032270(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = *(_DWORD *)(a1 + 56);
  if ( result == *(_DWORD *)(a1 + 48) )
  {
    v4 = *(_DWORD *)(result + 264);
    if ( v4 )
    {
      result = 10 * a2;
      if ( *(_BYTE *)(result + v4 + 4) != a3 )
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + result + 4) = a3;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
      }
    }
  }
  return result;
}

//----- (100322C0) --------------------------------------------------------
char __cdecl sub_100322C0(int a1, unsigned __int8 a2, __int16 a3)
{
  int v3; // esi@1
  char result; // al@1
  int v5; // ecx@2

  v3 = *(_DWORD *)(a1 + 56);
  result = 0;
  if ( v3 == *(_DWORD *)(a1 + 48) )
  {
    v5 = 10 * a2;
    if ( *(_WORD *)(v5 + *(_DWORD *)(v3 + 264)) != a3 )
    {
      *(_WORD *)(v5 + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264)) = a3;
      result = 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (10032310) --------------------------------------------------------
int __cdecl sub_10032310(int a1, unsigned __int8 a2)
{
  int v2; // ebp@1
  int v3; // ecx@1
  int v4; // edi@1
  char v5; // bl@1
  char v6; // cl@1
  int result; // eax@1
  bool v8; // zf@1
  unsigned __int8 v9; // dl@4
  int v10; // esi@5
  int v11; // ecx@5
  char v12; // [sp+10h] [bp+4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
  v4 = 10 * a2;
  v5 = *(_BYTE *)(v3 + v4 + 7);
  v6 = *(_BYTE *)(v3 + v4 + 6);
  result = *(_DWORD *)(a1 + 56);
  v8 = result == *(_DWORD *)(a1 + 48);
  v12 = v6;
  if ( v8 )
  {
    if ( v6 == -1 )
    {
      result = *(_DWORD *)(result + 264) + v4 + 2;
      *(_BYTE *)result = *(_BYTE *)result == 0;
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
    else
    {
      v9 = 0;
      if ( *(_BYTE *)(result + 257) )
      {
        do
        {
          v10 = *(_DWORD *)(result + 264);
          v11 = v10 + 10 * v9;
          if ( *(_BYTE *)(v10 + 10 * v9 + 7) == v5 && *(_BYTE *)(v11 + 6) == v12 )
          {
            if ( v9 == a2 )
            {
              if ( !*(_BYTE *)(v10 + v4 + 2) )
                *(_BYTE *)(v11 + 2) = 1;
            }
            else
            {
              *(_BYTE *)(v11 + 2) = 0;
            }
          }
          result = *(_DWORD *)(v2 + 56);
          ++v9;
        }
        while ( v9 < *(_BYTE *)(result + 257) );
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (100323E0) --------------------------------------------------------
char __usercall sub_100323E0@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  _BYTE *v3; // edx@2
  signed int v4; // esi@2
  unsigned __int8 v5; // bl@4
  int v6; // edx@5

  if ( a2 == *(_DWORD *)(a1 + 48) )
  {
    v3 = (_BYTE *)(a2 + 316);
    a1 = a2 + 268;
    v4 = 12;
    do
    {
      *(_DWORD *)a1 = 0;
      *v3 = -1;
      a1 += 4;
      ++v3;
      --v4;
    }
    while ( v4 );
    v5 = 0;
    if ( *(_BYTE *)(a2 + 257) )
    {
      do
      {
        v6 = *(_DWORD *)(a2 + 264) + 10 * v5;
        LOBYTE(a1) = a3;
        if ( *(_BYTE *)(v6 + 7) == a3 )
        {
          a1 = (unsigned __int8)(*(_BYTE *)(v6 + 5) - 1);
          *(_DWORD *)(a2 + 4 * a1 + 268) = v6;
          *(_BYTE *)(a1 + a2 + 316) = v5;
        }
        ++v5;
      }
      while ( v5 < *(_BYTE *)(a2 + 257) );
    }
    *(_BYTE *)(a2 + 330) = 1;
  }
  return a1;
}

//----- (10032470) --------------------------------------------------------
char __cdecl sub_10032470(int a1, unsigned __int8 a2)
{
  char result; // al@1

  result = a1;
  if ( *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 48) )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 7) = -1;
    result = sub_100323E0(a1, *(_DWORD *)(a1 + 56), 0);
  }
  return result;
}

//----- (100324A0) --------------------------------------------------------
char __cdecl sub_100324A0(int a1, unsigned __int8 a2, char a3)
{
  char result; // al@1

  result = 0;
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) != a3 )
  {
    sub_10032310(a1, a2);
    result = 1;
  }
  return result;
}

//----- (100324E0) --------------------------------------------------------
int __usercall sub_100324E0@<eax>(int a1@<eax>, char a2@<bl>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-4h]@0

  sub_100323E0(a1, *(_DWORD *)(a1 + 56), v4);
  result = a3;
  *(_BYTE *)(a3 + 260) = a2;
  return result;
}

//----- (10032500) --------------------------------------------------------
int __cdecl sub_10032500(int a1, char a2)
{
  return sub_100324E0(a1, a2, *(_DWORD *)(a1 + 56));
}

//----- (10032520) --------------------------------------------------------
int __cdecl sub_10032520(int a1)
{
  void *v1; // ecx@1
  int result; // eax@3
  int v3; // ebp@3
  int v4; // edi@11
  int v5; // ecx@15
  int v6; // ecx@17
  char v7; // [sp+1h] [bp-7h]@1
  char v8; // [sp+2h] [bp-6h]@9
  char v9; // [sp+3h] [bp-5h]@11
  char v10; // [sp+4h] [bp-4h]@7

  sub_1008D070(9, &v7);
  if ( v7 == 8 )
    v7 = sub_10052230(v1) != 1 ? 6 : 0;
  result = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 328) )
    {
      result = sub_1008C710();
      if ( result != 1 )
      {
        if ( v7 == 7 )
        {
          if ( sub_10066E70(0, &v10) )
          {
            sub_10032270(a1, 0x1Au, 0);
            sub_1008CA60(10016, (int)&v8, 1);
            sub_100324A0(a1, 0x1Au, v8 != 0);
          }
          else
          {
            sub_10032270(a1, 0x1Au, 1);
          }
        }
        if ( sub_1006C3C0(16) )
        {
          v4 = sub_1006E440(&v7, 1u, (int)&unk_100C8A28, 2, 3, 0);
          if ( sub_10067000(0xBCu, &v9) && v9 )
            sub_10032270(a1, byte_100C8A29[2 * v4], 0);
          else
            sub_10032270(a1, byte_100C8A29[2 * v4], 1);
        }
        sub_10032270(a1, 1u, 1);
        sub_10032270(a1, 2u, 1);
        sub_10032270(a1, 4u, 1);
        sub_10032270(a1, 9u, 1);
        sub_10032270(a1, 3u, 1);
        sub_10032270(a1, 8u, 1);
        if ( byte_101C5C7C )
        {
          v5 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_DWORD *)(v5 + 264) + 247) = 0;
        }
        if ( sub_10052130((void *)v5) )
        {
          sub_10032270(a1, 1u, 0);
          sub_10032270(a1, 2u, 0);
          sub_10032270(a1, 4u, 0);
          sub_10032270(a1, 9u, 0);
          if ( byte_101C5C7C )
          {
            v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
            *(_BYTE *)(v6 + 247) = -1;
          }
        }
        if ( sub_10052150((void *)v6) )
        {
          sub_10032270(a1, 1u, 0);
          sub_10032270(a1, 2u, 0);
          sub_10032270(a1, 3u, 0);
          sub_10032270(a1, 8u, 0);
          if ( byte_101C5C7C )
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 247) = -1;
        }
        if ( sub_1006EAF0(1u) )
        {
          sub_100322C0(a1, 0x11u, 5253);
          sub_100322C0(a1, 0x12u, 1910);
        }
        else
        {
          sub_100322C0(a1, 0x11u, 4718);
          sub_100322C0(a1, 0x12u, 7152);
        }
        result = sub_100324E0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 260), *(_DWORD *)(a1 + 56));
      }
    }
  }
  *(_DWORD *)(a1 + 56) = v3;
  return result;
}
// 101C5C7C: using guessed type char byte_101C5C7C;

//----- (10032790) --------------------------------------------------------
int __cdecl sub_10032790(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5)
{
  void *v5; // ecx@3
  signed int v6; // ecx@10
  signed int v7; // edx@10
  signed int v8; // ecx@13
  signed int v9; // edx@13
  signed int v10; // ecx@16
  signed int v11; // edx@16
  signed int v12; // ecx@19
  signed int v13; // edx@19
  signed int v14; // ecx@22
  signed int v15; // edx@22
  signed int v16; // ecx@25
  signed int v17; // edx@25
  signed int v18; // ecx@30
  signed int v19; // edx@30
  signed int v20; // ecx@39
  signed int v21; // edx@39
  signed int v22; // ecx@42
  signed int v23; // edx@42
  int v24; // eax@45
  signed int v25; // ecx@45
  signed int v26; // edx@45
  signed int v27; // ecx@48
  signed int v28; // edx@48
  signed int v29; // ecx@52
  signed int v30; // edx@52
  signed int v31; // ecx@55
  signed int v32; // edx@55
  int v33; // eax@59
  signed int v34; // ecx@59
  signed int v35; // edx@59
  signed int v36; // ecx@62
  signed int v37; // edx@62
  signed int v38; // ecx@65
  signed int v39; // edx@65
  char v40; // al@84
  void *v41; // ecx@85
  void *v42; // ecx@90
  void *v43; // ecx@94
  void *v44; // ecx@97
  void *v45; // ecx@98
  void *v46; // ecx@99
  int result; // eax@108
  int v48; // [sp+0h] [bp-1560h]@0
  char v49; // [sp+Dh] [bp-1553h]@3
  char v50; // [sp+Eh] [bp-1552h]@1
  char v51; // [sp+Fh] [bp-1551h]@72
  void *v52; // [sp+10h] [bp-1550h]@84
  void *v53; // [sp+14h] [bp-154Ch]@1
  int v54; // [sp+18h] [bp-1548h]@1
  char v55; // [sp+1Ch] [bp-1544h]@27
  char v56; // [sp+ABCh] [bp-AA4h]@27
  char v57; // [sp+AF9h] [bp-A67h]@28

  v53 = a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 257) = a3 + (a5 << 6);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 328) = a5;
  v50 = 0;
  v54 = a3;
  if ( 10 * (a3 + (unsigned __int8)(a5 << 6)) > 0 )
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) = sub_100027C0(a1, 10 * (a3 + (unsigned __int8)(a5 << 6)));
  sub_1008D070(9, &v49);
  if ( sub_10052230(v5) == 1 )
  {
    switch ( v49 )
    {
      case 8:
        v49 = 0;
        break;
      case 0xD:
        v49 = 14;
        break;
      case 0x13:
      case 0x15:
      case 0x16:
        v49 = 2;
        break;
      default:
        break;
    }
  }
  if ( a5 << 6 )
  {
    memcpy_0(*(void **)(*(_DWORD *)(a1 + 56) + 264), &unk_100C81B8, 0xF0u);
    switch ( v49 )
    {
      case 0:
      case 1:
      case 2:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C82A8, 0xBEu);
        v6 = 430;
        v7 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v6 + 7) = -1;
          v6 += 10;
          --v7;
        }
        while ( v7 );
        break;
      case 0xE:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8368, 0x28u);
        v8 = 280;
        v9 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v8 + 7) = -1;
          v8 += 10;
          --v9;
        }
        while ( v9 );
        break;
      case 3:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8390, 0xBEu);
        v10 = 430;
        v11 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v10 + 7) = -1;
          v10 += 10;
          --v11;
        }
        while ( v11 );
        break;
      case 4:
      case 5:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C85B8, 0x122u);
        v12 = 530;
        v13 = 11;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v12 + 7) = -1;
          v12 += 10;
          --v13;
        }
        while ( v13 );
        break;
      case 0xF:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C86E0, 0xA0u);
        v14 = 400;
        v15 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v14 + 7) = -1;
          v14 += 10;
          --v15;
        }
        while ( v15 );
        break;
      case 0xB:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8450, 0xB4u);
        v16 = 420;
        v17 = 22;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v16 + 7) = -1;
          v16 += 10;
          --v17;
        }
        while ( v17 );
        memset(&v55, 0, 0xAA0u);
        sub_1008CAC0(6767, &v56, 2720, &v55);
        if ( *(_BYTE *)(dword_1031FB38 + 1716) && v57 != 47 )
        {
          sub_10032270(a1, 0x1Bu, 2);
          sub_10032270(a1, 0x1Cu, 2);
        }
        break;
      case 0x14:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8508, 0xAAu);
        v18 = 410;
        v19 = 23;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v18 + 7) = -1;
          v18 += 10;
          --v19;
        }
        while ( v19 );
        break;
      case 6:
      case 8:
      case 0xD:
      case 0x13:
      case 0x15:
      case 0x16:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8780, 0x1Eu);
        if ( v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
        {
          sub_100322C0(a1, 0x18u, 2405);
          sub_100322C0(a1, 0x19u, 2405);
        }
        v20 = 270;
        v21 = 37;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v20 + 7) = -1;
          v20 += 10;
          --v21;
        }
        while ( v21 );
        break;
      case 7:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C87A0, 0x28u);
        v22 = 280;
        v23 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v22 + 7) = -1;
          v22 += 10;
          --v23;
        }
        while ( v23 );
        break;
      case 9:
        v24 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v24 = 886;
        *(_DWORD *)(v24 + 4) = 16711938;
        *(_WORD *)(v24 + 8) = 255;
        v25 = 250;
        v26 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v25 + 7) = -1;
          v25 += 10;
          --v26;
        }
        while ( v26 );
        break;
      case 0xA:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C87D8, 0x104u);
        v27 = 500;
        v28 = 14;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v27 + 7) = -1;
          v27 += 10;
          --v28;
        }
        while ( v28 );
        if ( sub_10052230((void *)v27) == 1 )
        {
          sub_10032270(a1, 0x1Cu, 2);
          sub_10032270(a1, 0x1Du, 2);
          sub_10032270(a1, 0x1Eu, 2);
          sub_10032270(a1, 0x1Fu, 2);
          sub_10032270(a1, 0x20u, 2);
          sub_10032270(a1, 0x21u, 2);
        }
        break;
      case 0x11:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C88DC, 0x3Cu);
        v29 = 300;
        v30 = 34;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v29 + 7) = -1;
          v29 += 10;
          --v30;
        }
        while ( v30 );
        break;
      case 0xC:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8918, 0x64u);
        v31 = 340;
        v32 = 30;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v31 + 7) = -1;
          v31 += 10;
          --v32;
        }
        while ( v32 );
        if ( sub_10052230((void *)v31) == 1 )
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 248) = 3;
        break;
      case 0x10:
        v33 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v33 = 6274;
        *(_DWORD *)(v33 + 4) = 16711938;
        *(_WORD *)(v33 + 8) = 255;
        v34 = 250;
        v35 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v34 + 7) = -1;
          v34 += 10;
          --v35;
        }
        while ( v35 );
        break;
      case 0x12:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100C8988, 0xA0u);
        v36 = 400;
        v37 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v36 + 7) = -1;
          v36 += 10;
          --v37;
        }
        while ( v37 );
        break;
      default:
        v38 = 240;
        v39 = 40;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v38 + 7) = -1;
          v38 += 10;
          --v39;
        }
        while ( v39 );
        break;
    }
  }
  if ( a3 )
    memcpy_0((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 640 * a5), v53, 10 * v54);
  if ( a5 )
  {
    nullsub_1(a1, v48);
    if ( v49 == 1 )
    {
      sub_100322C0(a1, 0x1Au, 6274);
      sub_100322C0(a1, 0x20u, 6274);
      sub_100322C0(a1, 0x25u, 6274);
      sub_100322C0(a1, 0x1Bu, 2801);
      sub_100322C0(a1, 0x21u, 2801);
      sub_100322C0(a1, 0x26u, 2801);
    }
    sub_1008D070(133, &v51);
    if ( sub_1006C3C0(16) != 1 || v51 != 1 )
    {
      if ( v49 == 6 || v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
      {
        sub_10032270(a1, 0x1Au, 2);
      }
      else if ( v49 == 7 )
      {
        sub_10032270(a1, 0x1Bu, 2);
      }
      else
      {
        sub_10032270(a1, 0x17u, 2);
      }
    }
    sub_1008D070(39, &v52);
    v40 = (char)v52;
    if ( !((unsigned __int8)v52 & 4) )
      goto LABEL_96;
    v41 = v52;
    LOBYTE(v41) = (unsigned __int8)v52 & 3;
    if ( ((unsigned __int8)v52 & 3) == 1 )
    {
      if ( sub_10052230(v41) != 1 && sub_1006F3C0(v41) & 3 )
        goto LABEL_96;
      v40 = (char)v52;
    }
    if ( v40 & 3 )
      goto LABEL_93;
    if ( sub_10052230(v41) == 1 || sub_1006F3C0(v42) & 3 )
    {
      v40 = (char)v52;
LABEL_93:
      if ( v40 < 0 )
      {
        sub_10032470(a1, 3u);
        sub_10032470(a1, 4u);
        v50 = 1;
      }
      else
      {
        sub_10032470(a1, 1u);
        sub_10032470(a1, 2u);
        sub_10032470(a1, 0x18u);
      }
      goto LABEL_97;
    }
LABEL_96:
    sub_10032470(a1, 1u);
    sub_10032470(a1, 2u);
    sub_10032470(a1, 3u);
    sub_10032470(a1, 4u);
LABEL_97:
    if ( !sub_1006F480(v43) || sub_1006F3C0(v44) & 3 || sub_10052210(v45) & 2 || sub_10052230(v46) == 1 )
    {
      sub_10032470(a1, 6u);
      if ( v49 == 10 )
        sub_10032470(a1, 0x1Au);
    }
    else if ( v50 )
    {
      if ( (unsigned __int16)v52 & 0x200 )
        sub_10032470(a1, 0x18u);
      else
        byte_101C5C7C = 1;
    }
    sub_10032520(a1);
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259) = 0;
  result = sub_10032500(a1, a4);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 329) = 1;
  return result;
}
// 101C5C7C: using guessed type char byte_101C5C7C;
// 1031FB38: using guessed type int dword_1031FB38;

//----- (100330C0) --------------------------------------------------------
#error "100330C5: call analysis failed (funcsize=28)"

//----- (100330F0) --------------------------------------------------------
#error "1003310E: call analysis failed (funcsize=35)"

//----- (10033190) --------------------------------------------------------
char __usercall sub_10033190@<al>(int a1@<ebx>, int a2@<esi>, int a3, _WORD *a4)
{
  int v4; // ebp@1
  __int16 v5; // dx@1
  int v6; // eax@1
  char result; // al@2
  __int16 *v8; // edi@5
  signed int v9; // ecx@6
  __int16 v10; // dx@6
  int v11; // eax@6
  __int16 v12; // cx@7
  __int16 v13; // dx@7
  __int16 v14; // cx@9
  __int16 v15; // dx@9
  __int16 *v16; // [sp+4h] [bp-48h]@5
  int v17; // [sp+Ch] [bp-40h]@5
  __int16 v18; // [sp+10h] [bp-3Ch]@5
  __int16 v19; // [sp+14h] [bp-38h]@7
  __int16 v20; // [sp+18h] [bp-34h]@7
  int v21; // [sp+1Ch] [bp-30h]@10
  _WORD *v22; // [sp+20h] [bp-2Ch]@1
  __int16 v23; // [sp+28h] [bp-24h]@5

  v4 = a3;
  *(_WORD *)(a3 + 394) = 1;
  v5 = word_101CAB28[15];
  v22 = a4;
  *(_WORD *)(a3 + 428) = v5;
  *(_WORD *)(a3 + 430) = word_101CAB28[15];
  v6 = *(_DWORD *)(a2 + 4) & 0x18;
  if ( v6 == 16 )
    result = 3;
  else
    result = (v6 == 8) + 1;
  if ( result )
  {
    v16 = &v18;
    v8 = &v23;
    v17 = (unsigned __int8)result;
    do
    {
      v8[1] = *(_WORD *)(a2 + 10);
      v9 = *(_WORD *)(a2 + 8);
      v10 = *(_WORD *)(a1 + 2);
      *v8 = *(_WORD *)(a2 + 8) / 4;
      v16[1] = v10;
      v11 = *(_DWORD *)(a2 + 4) & 0x18;
      *((_DWORD *)v8 - 1) = 96;
      v8[2] = 2447;
      if ( v11 == 16 )
      {
        v12 = *(_WORD *)(a2 + 8) / 6;
        v13 = *(_WORD *)a1;
        v18 = v12 + *(_WORD *)a1 - v23 / 2 - 5;
        v19 = v13 + 3 * v12 - v23 / 2;
        v4 = a3;
        v20 = v13 + 5 * v12 + 5 - v23 / 2;
      }
      else if ( v11 == 8 )
      {
        v14 = *(_WORD *)(a2 + 8) / 6;
        v15 = *(_WORD *)a1;
        v18 = v14 + *(_WORD *)a1 - v23 / 2;
        v4 = a3;
        v19 = v15 + 5 * v14 - v23 / 2;
      }
      else
      {
        v21 = v23 / 2;
        v18 = *(_WORD *)a1 + v9 / 2 - v23 / 2;
      }
      result = sub_1003F840(v4, (int)(v8 - 2), (int)v16, 0, v22);
      v16 += 2;
      v8 += 6;
      --v17;
    }
    while ( v17 );
  }
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10033340) --------------------------------------------------------
char __usercall sub_10033340@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  __int16 v12; // cx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10
  char v26[20]; // [sp+2Dh] [bp-17h]@22

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1003AAE0(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1003AAE0(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1003A690(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1003AE60(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1003AE60(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_102BA90E != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  v13 = v25;
  HIWORD(v16) = *(_WORD *)(v23 + 2) - 6;
  LOWORD(v16) = v12;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)v26;
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_1003F3B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10033340: using guessed type char var_18[20];

//----- (10033510) --------------------------------------------------------
char __usercall sub_10033510@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v5; // [sp+0h] [bp-34h]@1
  __int16 v6; // [sp+2h] [bp-32h]@1
  __int16 v7; // [sp+4h] [bp-30h]@1
  __int16 v8; // [sp+6h] [bp-2Eh]@1
  float v9; // [sp+8h] [bp-2Ch]@1
  float v10; // [sp+Ch] [bp-28h]@1
  char v11; // [sp+10h] [bp-24h]@1
  char v12; // [sp+20h] [bp-14h]@1

  sub_1003AA80(*(_BYTE *)(a4 + 13), (int)&v11, (int)&v12);
  v10 = *(float *)(a2 + 8);
  v9 = *(float *)(a2 + 4);
  v7 = 0;
  v8 = 0;
  v5 = 0;
  v6 = 0;
  sub_10040B30(a3, (int)&v11, (int *)&v5, &v9, a1);
  return sub_10040B30(a3, (int)&v12, (int *)&v7, &v10, a1);
}

//----- (100335A0) --------------------------------------------------------
char __usercall sub_100335A0@<al>(int a1@<edx>, const void *a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  char *v8; // esi@5
  __int16 v9; // cx@12
  int v10; // eax@12
  int v11; // eax@13
  int v12; // edx@13
  int v13; // esi@13
  int v14; // eax@13
  int v15; // eax@15
  int v16; // edx@15
  int v17; // esi@15
  int v18; // esi@18
  char *v19; // edi@18
  float *v20; // ebx@18
  double v21; // st7@21
  int v22; // edx@23
  char v24; // [sp+13h] [bp-5Dh]@4
  int v25; // [sp+14h] [bp-5Ch]@5
  int v26; // [sp+14h] [bp-5Ch]@18
  const void *v27; // [sp+18h] [bp-58h]@1
  __int16 v28; // [sp+1Ch] [bp-54h]@13
  __int16 v29; // [sp+1Eh] [bp-52h]@12
  __int16 v30; // [sp+20h] [bp-50h]@13
  __int16 v31; // [sp+22h] [bp-4Eh]@13
  __int16 v32; // [sp+24h] [bp-4Ch]@13
  __int16 v33; // [sp+26h] [bp-4Ah]@13
  int v34; // [sp+28h] [bp-48h]@1
  int v35; // [sp+2Ch] [bp-44h]@1
  float v36[3]; // [sp+30h] [bp-40h]@23
  char v37; // [sp+3Ch] [bp-34h]@18
  char v38; // [sp+40h] [bp-30h]@5

  v35 = a3;
  v5 = *(_DWORD *)(a4 + 4) & 0x18;
  v27 = a2;
  v34 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v24 = v6;
  if ( v6 )
  {
    v7 = 0;
    v8 = &v38;
    v25 = (unsigned __int8)v6;
    do
    {
      sub_1003ADC0(*(_BYTE *)(a4 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)v27 + v7) )
      {
        switch ( sub_1003AAE0(a4, v27, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_102BA90E != 0 ? 37135 : 37352;
            break;
          case 2:
            *(_DWORD *)v8 = 37217;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 37263;
      }
      ++v7;
      v8 += 16;
      --v25;
    }
    while ( v25 );
  }
  v9 = *(_WORD *)(a4 + 10) + *(_WORD *)(a5 + 2) + 20;
  v10 = *(_DWORD *)(a4 + 4) & 0x18;
  v29 = *(_WORD *)(a4 + 10) + *(_WORD *)(a5 + 2) + 20;
  if ( v10 == 16 )
  {
    v11 = *(_WORD *)(a4 + 8) / 6;
    v12 = *(_WORD *)a5;
    v28 = v12 + v11 - 4;
    v13 = v11 + v12 + 2 * v11 + 1;
    v14 = v11 + v12 + 4 * v11 + 6;
    v30 = v13;
    v32 = v14;
    v31 = v9;
    v33 = v9;
  }
  else if ( v10 == 8 )
  {
    v15 = *(_WORD *)(a4 + 8) / 6;
    v16 = *(_WORD *)a5;
    v17 = v16 + v15 + 1;
    v14 = v15 + v16 + 4 * v15 - 1;
    v28 = v17;
    v30 = v14;
    v31 = v9;
  }
  else
  {
    LOWORD(v14) = *(_WORD *)a5 + *(_WORD *)(a4 + 8) / 2 + 1;
    v28 = *(_WORD *)a5 + *(_WORD *)(a4 + 8) / 2 + 1;
  }
  if ( v24 )
  {
    v18 = 0;
    v19 = &v37;
    v20 = (float *)((char *)v27 + 60);
    v26 = (unsigned __int8)v24;
    do
    {
      if ( *((_BYTE *)v27 + v18) && sub_1003AAE0(a4, v27, v18) )
        v21 = *v20;
      else
        v21 = 9.8999998e24;
      v22 = v34;
      v36[v18] = v21;
      LOBYTE(v14) = sub_10040B30(v35, (int)v19, (int *)&v28 + v18, &v36[v18], v22);
      ++v18;
      ++v20;
      v19 += 16;
      --v26;
    }
    while ( v26 );
  }
  return v14;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 100335A0: using guessed type float var_40[3];

//----- (100337A0) --------------------------------------------------------
int __usercall sub_100337A0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v4; // cx@1
  int result; // eax@1
  signed int v6; // ecx@3
  __int16 v7; // ax@5
  __int16 v8; // ax@7
  __int16 v9; // dx@7
  __int16 v10; // ax@10
  __int16 v11; // ax@12
  int v12; // [sp+4h] [bp-8h]@1
  __int16 v13; // [sp+8h] [bp-4h]@3
  __int16 v14; // [sp+Ah] [bp-2h]@1

  v4 = *(_WORD *)(a2 + 2) + *(_WORD *)(a3 + 10);
  HIWORD(v12) = *(_WORD *)(a2 + 2);
  result = *(_DWORD *)(a3 + 4) & 0x18;
  v14 = v4;
  if ( result == 16 )
  {
    if ( !*(_BYTE *)a4 )
    {
      v6 = *(_WORD *)(a3 + 8);
      LOWORD(v12) = *(_WORD *)a2 - 5;
      v13 = v12 + v6 / 3;
      result = sub_1004B2B0(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v7 = *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = v7 + *(_WORD *)a2;
      v13 = v12 + v7;
      result = sub_1004B2B0(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 2) )
    {
      v8 = *(_WORD *)(a3 + 8) / 3;
      v9 = *(_WORD *)a2 + 2 * v8 + 5;
LABEL_15:
      LOWORD(v12) = v9;
      v13 = v9 + v8;
      return sub_1004B2B0(a1, (int)&v12, (int)&v13, 0);
    }
  }
  else
  {
    if ( result != 8 )
    {
      if ( *(_BYTE *)a4 )
        return result;
      v8 = *(_WORD *)(a3 + 8) / 3;
      v9 = v8 + *(_WORD *)a2;
      goto LABEL_15;
    }
    if ( !*(_BYTE *)a4 )
    {
      v10 = *(_WORD *)a2 + *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = *(_WORD *)a2;
      v13 = v10;
      result = sub_1004B2B0(a1, (int)&v12, (int)&v13, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v11 = *(_WORD *)(a3 + 8) / 3;
      LOWORD(v12) = *(_WORD *)a2 + 2 * v11;
      v13 = v12 + v11;
      result = sub_1004B2B0(a1, (int)&v12, (int)&v13, 0);
    }
  }
  return result;
}

//----- (10033960) --------------------------------------------------------
int __usercall sub_10033960@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  float *v6; // edi@1
  float *v7; // edx@1
  signed int v8; // ecx@1
  double v9; // st7@3
  __int64 v10; // rax@8
  int v11; // ecx@8
  int v12; // eax@8
  __int16 v13; // si@9
  __int16 v14; // cx@9
  __int16 v15; // ST28_2@9
  __int16 v16; // di@11
  __int16 v17; // cx@11
  __int16 v18; // ST28_2@11
  __int16 v19; // si@12
  __int16 v20; // di@12
  int v21; // esi@14
  int v22; // eax@16
  int v23; // eax@17
  int v24; // eax@22
  double v25; // st7@22
  float v26; // ST10_4@22
  int v27; // eax@22
  int v28; // edi@23
  bool v29; // zf@25
  char v31; // [sp+17h] [bp-61h]@9
  unsigned __int8 v32; // [sp+17h] [bp-61h]@22
  int v33; // [sp+18h] [bp-60h]@14
  __int16 v34; // [sp+24h] [bp-54h]@9
  __int16 v35; // [sp+26h] [bp-52h]@22
  __int16 v36; // [sp+28h] [bp-50h]@9
  __int16 v37; // [sp+2Ch] [bp-4Ch]@9
  int v38; // [sp+30h] [bp-48h]@1
  int v39; // [sp+34h] [bp-44h]@9
  __int16 v40; // [sp+38h] [bp-40h]@9
  __int16 v41; // [sp+3Ch] [bp-3Ch]@9
  char *v42; // [sp+40h] [bp-38h]@9
  int v43; // [sp+44h] [bp-34h]@9
  int v44; // [sp+48h] [bp-30h]@9
  int v45; // [sp+4Ch] [bp-2Ch]@22
  int v46; // [sp+50h] [bp-28h]@8
  int v47; // [sp+54h] [bp-24h]@8
  __int16 v48; // [sp+58h] [bp-20h]@8
  __int16 v49; // [sp+5Ah] [bp-1Eh]@8
  float v50[3]; // [sp+5Ch] [bp-1Ch]@1
  int v51; // [sp+68h] [bp-10h]@8
  __int16 v52; // [sp+6Ch] [bp-Ch]@8
  int v53; // [sp+6Eh] [bp-Ah]@8

  v5 = a1;
  v38 = a2;
  *(_WORD *)(a3 + 396) = 2;
  v6 = v50;
  v7 = (float *)(a5 + 48);
  v8 = 3;
  do
  {
    if ( *(float *)(a5 + 8) >= (double)*v7 )
    {
      if ( *(float *)(a5 + 4) <= (double)*v7 )
        v9 = *v7;
      else
        v9 = *(float *)(a5 + 4);
    }
    else
    {
      v9 = *(float *)(a5 + 8);
    }
    *v6 = v9;
    ++v7;
    ++v6;
    --v8;
  }
  while ( v8 );
  v10 = *(_WORD *)(v5 + 8);
  v48 = 0;
  v11 = (((BYTE4(v10) & 3) + (signed int)v10) >> 2) - 10;
  v12 = *(_DWORD *)(v5 + 4) & 0x18;
  v46 = 105;
  v47 = 1423;
  v49 = 6;
  v51 = 96;
  LOWORD(v53) = 2;
  v52 = v11;
  if ( v12 == 16 )
  {
    v13 = *(_WORD *)a4;
    v14 = *(_WORD *)(v5 + 8) / 6;
    v15 = *(_WORD *)(v5 + 8) / 8;
    LOWORD(v39) = *(_WORD *)a4 + v15 + v14 - 2;
    v40 = 3 * v14 + v13 + v15 + 3;
    v41 = v13 + 5 * v14 + v15 + 8;
    v43 = a5 + 79;
    v42 = (char *)(a5 + 72);
    v44 = a5 + 86;
    v34 = v13 - v52 / 2 + v14 - 5;
    v31 = 3;
    v36 = v13 + 3 * v14 - v52 / 2;
    v37 = 5 * v14 - v52 / 2 + v13 + 5;
  }
  else if ( v12 == 8 )
  {
    v16 = *(_WORD *)a4;
    v17 = *(_WORD *)(v5 + 8) / 6;
    v18 = *(_WORD *)(v5 + 8) / 8;
    LOWORD(v39) = *(_WORD *)a4 + v18 + v17 + 3;
    v40 = 5 * v17 + v16 + v18 + 3;
    v42 = (char *)(a5 + 72);
    v43 = a5 + 79;
    v31 = 2;
    v34 = v17 + v16 - v52 / 2;
    v36 = v16 + 5 * v17 - v52 / 2;
  }
  else
  {
    v19 = *(_WORD *)a4;
    v20 = *(_WORD *)(v5 + 8) / 2;
    LOWORD(v39) = *(_WORD *)a4 + *(_WORD *)(v5 + 8) / 8 + v20 + 3;
    v42 = (char *)(a5 + 72);
    v31 = 1;
    v34 = v20 + v19 - (signed __int16)v11 / 2;
  }
  if ( v31 )
  {
    v21 = 0;
    v33 = (unsigned __int8)v31;
    do
    {
      if ( *(_BYTE *)(v21 + a5) )
      {
        v22 = (unsigned __int8)sub_1003AAE0(v5, (const void *)a5, v21) - 1;
        if ( v22 )
        {
          v23 = v22 - 1;
          if ( v23 )
          {
            if ( v23 == 1 )
              HIWORD(v53) = 2312;
          }
          else
          {
            HIWORD(v53) = 2411;
          }
        }
        else
        {
          HIWORD(v53) = 2543;
        }
        v24 = sub_100349D0(a4, a5, v5, v50[v21]);
        v25 = *(float *)(a5 + 4);
        v45 = v24;
        v26 = v25;
        v27 = sub_100349D0(a4, a5, v5, v26);
        v32 = (v27 - v45) / ((signed __int16)v53 + 1);
        *(&v35 + 2 * v21) = sub_100349D0(a4, a5, v5, *(float *)(a5 + 4)) - 3;
        if ( v32 )
        {
          v28 = v32;
          do
          {
            sub_1003F840(a3, (int)&v51, (int)(&v34 + 2 * v21), 0, (_WORD *)v38);
            *(&v35 + 2 * v21) += -1 - v53;
            --v28;
          }
          while ( v28 );
        }
        v29 = (*(_DWORD *)(v5 + 4) & 0x100) == 0;
        *((_WORD *)&v39 + 2 * v21 + 1) = *(_WORD *)(a4 + 2) + 12;
        if ( !v29 )
          sub_1003F3B0(a3, (int)&v46, (int)(&v39 + v21), (&v42)[4 * v21], v38);
      }
      ++v21;
      --v33;
    }
    while ( v33 );
  }
  return sub_100337A0(a3, a4, v5, a5);
}
// 10033960: using guessed type float var_1C[3];

//----- (10033CF0) --------------------------------------------------------
char __usercall sub_10033CF0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4)
{
  int v4; // eax@1
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // edx@2
  __int16 v8; // ST30_2@2
  __int16 v9; // ax@4
  __int16 v10; // cx@4
  int v11; // eax@6
  __int16 v12; // ax@9
  __int16 v13; // ax@11
  __int16 v14; // ax@11
  __int16 v15; // ST28_2@13
  __int16 v16; // ax@13
  __int16 v17; // ST28_2@13
  __int16 v18; // ax@13
  bool v19; // zf@13
  char v21; // [sp+Bh] [bp-25h]@2
  __int16 v22; // [sp+Ch] [bp-24h]@9
  __int16 v23; // [sp+Ch] [bp-24h]@11
  int v24; // [sp+10h] [bp-20h]@8
  int v25; // [sp+14h] [bp-1Ch]@7
  __int16 v26; // [sp+18h] [bp-18h]@11
  __int16 *v27; // [sp+1Ch] [bp-14h]@7
  signed int v28; // [sp+20h] [bp-10h]@8
  __int16 v29; // [sp+24h] [bp-Ch]@2
  __int16 v30; // [sp+26h] [bp-Ah]@2
  __int16 v31; // [sp+28h] [bp-8h]@2

  v4 = *(_DWORD *)(a1 + 4) & 0x18;
  if ( v4 == 16 )
  {
    v5 = *(_WORD *)(a1 + 8) / 6;
    v6 = *(_WORD *)(a1 + 8) / 8;
    v29 = *a4 - v6 + v5 - 5;
    v7 = 3 * v5 - v6;
    v8 = v6;
    LOWORD(v6) = *a4;
    v21 = 3;
    v30 = *a4 + v7;
    v31 = v6 + 5 * v5 + 5 - v8;
  }
  else if ( v4 == 8 )
  {
    v9 = *(_WORD *)(a1 + 8) / 6;
    v10 = *(_WORD *)(a1 + 8) / 8;
    v29 = v9 + *a4 - v10;
    v21 = 2;
    v30 = *a4 + 5 * v9 - v10;
  }
  else
  {
    v21 = 1;
    v29 = *a4 + *(_WORD *)(a1 + 8) / 2 - *(_WORD *)(a1 + 8) / 8;
  }
  LOBYTE(v11) = v21;
  if ( v21 )
  {
    v27 = &v29;
    v25 = (unsigned __int8)v21;
    do
    {
      v24 = (unsigned __int16)*v27;
      v28 = 2;
      do
      {
        *(_WORD *)(a3 + 440) = word_101CAB28[15];
        *(_WORD *)(a3 + 442) = word_101CAB28[15];
        *(_WORD *)(a3 + 428) = word_101CAB28[15];
        *(_WORD *)(a3 + 430) = word_101CAB28[15];
        v22 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 16));
        v12 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 20));
        if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
        {
          *(_WORD *)(a3 + 440) = word_101CAB28[11];
          *(_WORD *)(a3 + 442) = word_101CAB28[11];
          *(_WORD *)(a3 + 428) = word_101CAB28[11];
          *(_WORD *)(a3 + 430) = word_101CAB28[11];
          sub_100903C0(a3 + 392, v24, v12, 3, v22 - v12, 1);
        }
        v13 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 12));
        *(_WORD *)(a3 + 440) = word_101CAB28[8];
        *(_WORD *)(a3 + 442) = word_101CAB28[8];
        *(_WORD *)(a3 + 428) = word_101CAB28[8];
        *(_WORD *)(a3 + 430) = word_101CAB28[8];
        sub_100903C0(a3 + 392, v24, v22, 3, v13 - v22, 1);
        v23 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 24));
        v14 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 28));
        v26 = v14;
        if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
        {
          *(_WORD *)(a3 + 440) = word_101CAB28[11];
          *(_WORD *)(a3 + 442) = word_101CAB28[11];
          *(_WORD *)(a3 + 428) = word_101CAB28[11];
          *(_WORD *)(a3 + 430) = word_101CAB28[11];
          sub_100903C0(a3 + 392, v24, v14, 3, v23 - v14, 1);
          v14 = v26;
        }
        v15 = v14;
        v16 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 32));
        *(_WORD *)(a3 + 440) = word_101CAB28[8];
        *(_WORD *)(a3 + 442) = word_101CAB28[8];
        *(_WORD *)(a3 + 428) = word_101CAB28[8];
        *(_WORD *)(a3 + 430) = word_101CAB28[8];
        sub_100903C0(a3 + 392, v24, v16, 3, v15 - v16, 1);
        v17 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 20));
        v18 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 24));
        *(_WORD *)(a3 + 440) = word_101CAB28[4];
        *(_WORD *)(a3 + 442) = word_101CAB28[4];
        *(_WORD *)(a3 + 428) = word_101CAB28[4];
        *(_WORD *)(a3 + 430) = word_101CAB28[4];
        sub_100903C0(a3 + 392, v24, v18, 3, v17 - v18, 1);
        v11 = *(_WORD *)(a1 + 8) / 4;
        v19 = v28-- == 1;
        v24 = v24 + v11 - 3;
      }
      while ( !v19 );
      ++v27;
      --v25;
    }
    while ( v25 );
  }
  return v11;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10034180) --------------------------------------------------------
char __cdecl sub_10034180(int a1, int a2, _WORD *a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1003A640(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_10033190((int)a3, a2, a1, a5);
      sub_10033CF0(a2, a4, a1, a3);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10033510((int)a5, a4, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_100335A0((int)a5, (const void *)a4, a1, a2, (int)a3);
      sub_10033340((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_10033960(a2, (int)a5, a1, (int)a3, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_100335A0((int)a5, (const void *)a4, a1, a2, (int)a3);
      sub_10033340((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_13;
    default:
LABEL_13:
      result = 1;
      break;
  }
  return result;
}

//----- (10034330) --------------------------------------------------------
char __usercall sub_10034330@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  __int16 v12; // cx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10
  char v26[20]; // [sp+2Dh] [bp-17h]@22

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1003AAE0(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1003AAE0(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1003A690(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1003AE60(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1003AE60(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_102BA90E != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  v13 = v25;
  HIWORD(v16) = *(_WORD *)(a3 + 10) + *(_WORD *)(v23 + 2) + 18;
  LOWORD(v16) = v12;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)v26;
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_1003F3B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10034330: using guessed type char var_18[20];

//----- (10034500) --------------------------------------------------------
char __usercall sub_10034500@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // esi@1
  signed int v6; // eax@1
  signed __int16 v7; // si@1
  float v8; // ST24_4@1
  double v9; // st7@1
  int v10; // edi@1
  char v11; // bl@1
  double v12; // st6@1
  unsigned int v13; // eax@1
  double v14; // st5@2
  int v15; // ebp@3
  int v16; // ebx@3
  int v17; // esi@3
  signed int v18; // edi@3
  char result; // al@4
  __int16 v20; // [sp+10h] [bp-64h]@1
  signed int v21; // [sp+14h] [bp-60h]@1
  float v22; // [sp+18h] [bp-5Ch]@1
  int v23; // [sp+1Ch] [bp-58h]@1
  __int16 v24; // [sp+20h] [bp-54h]@3
  __int16 v25; // [sp+22h] [bp-52h]@3
  float v26; // [sp+24h] [bp-50h]@1
  int v27; // [sp+28h] [bp-4Ch]@1
  int v28; // [sp+2Ch] [bp-48h]@1
  __int16 v29; // [sp+30h] [bp-44h]@2
  __int16 v30[7]; // [sp+32h] [bp-42h]@2
  float v31[4]; // [sp+40h] [bp-34h]@2
  char v32; // [sp+50h] [bp-24h]@1
  int v33; // [sp+54h] [bp-20h]@3
  char v34; // [sp+60h] [bp-14h]@1
  int v35; // [sp+64h] [bp-10h]@3

  v5 = a1;
  v27 = a3;
  v28 = a2;
  sub_1003AA80(*(_BYTE *)(a1 + 13), (int)&v34, (int)&v32);
  v6 = *(_WORD *)(v5 + 8);
  v22 = *(float *)(a5 + 8);
  v7 = *(_WORD *)(v5 + 10);
  v8 = *(float *)(a5 + 4);
  v9 = v8;
  v23 = *(_WORD *)a4;
  v10 = v6 / 2;
  v11 = 1;
  v21 = 1;
  v26 = (v22 - v8) / 5.0;
  v12 = v26;
  v20 = *(_WORD *)(a4 + 2);
  v13 = 0;
  do
  {
    v14 = (double)v21++;
    *(__int16 *)((char *)&v29 + v13 * 2) = v23 + v10 + 2;
    v31[v13 / 2] = v14 * v12 + v9;
    v30[v13] = v7 + v20 - v7 / 5 * (unsigned __int8)v11++ + 2;
    v13 += 2;
  }
  while ( (unsigned __int8)v11 < 5u );
  v15 = v28;
  v16 = v27;
  v33 = 34191;
  v35 = 34191;
  v24 = v23 + v10 + 2;
  v25 = v20 + 2;
  sub_10040B30(v27, (int)&v32, (int *)&v24, &v22, v28);
  v17 = 0;
  v18 = 4;
  do
  {
    result = sub_10040B30(v16, (int)&v34, (int *)((char *)&v29 + v17 * 4), &v31[v17], v15);
    ++v17;
    --v18;
  }
  while ( v18 );
  return result;
}
// 10034500: using guessed type float var_34[4];
// 10034500: using guessed type __int16 var_42[7];

//----- (10034680) --------------------------------------------------------
char __usercall sub_10034680@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  char *v8; // esi@5
  int v9; // eax@12
  int v10; // ecx@12
  int v11; // esi@12
  char result; // al@12
  int v13; // esi@13
  char *v14; // edi@13
  float *v15; // ebp@13
  double v16; // st7@16
  char v17; // [sp+Fh] [bp-61h]@4
  int v18; // [sp+10h] [bp-60h]@5
  int v19; // [sp+10h] [bp-60h]@13
  int v20; // [sp+14h] [bp-5Ch]@1
  int v21; // [sp+1Ch] [bp-54h]@1
  __int16 v22; // [sp+24h] [bp-4Ch]@12
  __int16 v23; // [sp+26h] [bp-4Ah]@12
  __int16 v24; // [sp+28h] [bp-48h]@12
  __int16 v25; // [sp+2Ah] [bp-46h]@12
  float v26[3]; // [sp+30h] [bp-40h]@18
  char v27; // [sp+3Ch] [bp-34h]@13
  char v28; // [sp+40h] [bp-30h]@5

  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v21 = a2;
  v20 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v17 = v6;
  if ( v6 )
  {
    v7 = 0;
    v8 = &v28;
    v18 = (unsigned __int8)v6;
    do
    {
      sub_1003ADC0(*(_BYTE *)(a3 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)a5 + v7) )
      {
        switch ( sub_1003AAE0(a3, a5, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_102BA90E != 0 ? 37135 : 37352;
            break;
          case 2:
            *(_DWORD *)v8 = 37217;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 37263;
      }
      ++v7;
      v8 += 16;
      --v18;
    }
    while ( v18 );
  }
  v9 = *(_WORD *)(a3 + 8) / 6;
  v10 = *(_WORD *)v21;
  v11 = v10 + v9 - 8;
  v24 = v9 + v10 + 4 * v9 + 11;
  LOWORD(v9) = *(_WORD *)(a3 + 10) + *(_WORD *)(v21 + 2);
  v22 = v11;
  LOWORD(v9) = v9 + 18;
  v23 = v9;
  v25 = v9;
  result = v17;
  if ( v17 )
  {
    v13 = 0;
    v14 = &v27;
    v15 = (float *)((char *)a5 + 60);
    v19 = (unsigned __int8)v17;
    do
    {
      if ( *((_BYTE *)a5 + v13) && sub_1003AAE0(a3, a5, v13) )
        v16 = *v15;
      else
        v16 = 9.8999998e24;
      v26[v13] = v16;
      result = sub_10040B30(a4, (int)v14, (int *)&v22 + v13, &v26[v13], v20);
      ++v13;
      ++v15;
      v14 += 16;
      --v19;
    }
    while ( v19 );
  }
  return result;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10034680: using guessed type float var_40[3];

//----- (10034810) --------------------------------------------------------
__int16 __usercall sub_10034810@<ax>(int a1@<edi>, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  __int16 result; // ax@1
  signed int v6; // eax@2
  __int16 v7; // bx@2
  __int16 v8; // ST2C_2@2
  __int16 v9; // si@2
  __int16 v10; // ST18_2@2
  __int16 v11; // [sp+Ch] [bp-4h]@1
  int i; // [sp+14h] [bp+4h]@1

  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_101CAB28[15];
  *(_WORD *)(a1 + 430) = word_101CAB28[15];
  v3 = a2;
  v4 = *(_BYTE *)(a2 + 12);
  result = *(_WORD *)a3 + *(_WORD *)(a2 + 8) / 4 - 4;
  v11 = *(_WORD *)a3 + *(_WORD *)(a2 + 8) / 4 - 4;
  for ( i = 0; i < v4; ++i )
  {
    v6 = (signed int)((double)*(_WORD *)(v3 + 8) * 0.12);
    v7 = v6;
    v8 = *(_WORD *)a3 + 3 * (*(_WORD *)(v3 + 8) / 4 + 3) - v6;
    LOWORD(v6) = i * (*(_WORD *)(v3 + 10) / (v4 - 1));
    v9 = *(_WORD *)(a3 + 2) + v6;
    v10 = *(_WORD *)(a3 + 2) + v6;
    *(_WORD *)(a1 + 438) = v11;
    *(_WORD *)(a1 + 436) = v9;
    sub_10090620(a1 + 392, v7 + v11, v10, 0);
    *(_WORD *)(a1 + 438) = v8;
    *(_WORD *)(a1 + 436) = v9;
    sub_10090620(a1 + 392, v7 + v8, v9, 0);
    v4 = *(_BYTE *)(v3 + 12);
    result = i + 1;
  }
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10034940) --------------------------------------------------------
int __usercall sub_10034940@<eax>(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<esi>, _BYTE *a4)
{
  _BYTE *v4; // ebp@1
  _BYTE *v5; // eax@2
  int v6; // ecx@2
  int result; // eax@2
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  __int16 v10; // [sp+4h] [bp-4h]@2
  __int16 v11; // [sp+6h] [bp-2h]@2

  v4 = a4;
  if ( !*a4 )
  {
    v5 = (_BYTE *)*a2;
    v6 = *a2 + 24;
    a4 = v5;
    v11 = *(_WORD *)(a3 + 10) + HIWORD(v5);
    v10 = v6;
    result = sub_1004B2B0(a1, (int)&a4, (int)&v10, 0);
  }
  if ( !v4[1] )
  {
    v8 = *(_WORD *)(a3 + 8);
    a4 = (_BYTE *)*a2;
    v9 = HIWORD(a4) + *(_WORD *)(a3 + 10);
    LOWORD(a4) = v8 - 24 + (_WORD)a4;
    v10 = (_WORD)a4 + 24;
    v11 = v9;
    result = sub_1004B2B0(a1, (int)&a4, (int)&v10, 0);
  }
  return result;
}

//----- (100349D0) --------------------------------------------------------
int __usercall sub_100349D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, float a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v7; // [sp+8h] [bp+4h]@2

  v4 = *(_WORD *)(a1 + 2);
  v5 = v4 + *(_WORD *)(a3 + 10);
  if ( *(float *)(a2 + 8) - *(float *)(a2 + 4) != 0.0 )
  {
    *(float *)&v7 = (a4 - *(float *)(a2 + 4)) / (*(float *)(a2 + 8) - *(float *)(a2 + 4));
    v5 -= (signed int)(*(float *)&v7 * (double)(v5 - v4 - 1));
  }
  return v5;
}

//----- (10034A30) --------------------------------------------------------
void __cdecl sub_10034A30(int a1, int a2, int a3, int a4, float a5, float a6)
{
  char v6; // [sp+15h] [bp-133h]@1
  char v7; // [sp+16h] [bp-132h]@1
  char v8; // [sp+17h] [bp-131h]@1
  float v9; // [sp+18h] [bp-130h]@2
  float v10; // [sp+1Ch] [bp-12Ch]@5
  int v11; // [sp+20h] [bp-128h]@11
  __int16 v12; // [sp+24h] [bp-124h]@11
  __int16 v13; // [sp+26h] [bp-122h]@11
  __int16 v14; // [sp+28h] [bp-120h]@11
  __int16 v15; // [sp+2Ah] [bp-11Eh]@11
  __int16 v16; // [sp+2Ch] [bp-11Ch]@11
  __int16 v17; // [sp+2Eh] [bp-11Ah]@11
  __int16 v18; // [sp+30h] [bp-118h]@11
  __int16 v19; // [sp+32h] [bp-116h]@11
  __int16 v20; // [sp+34h] [bp-114h]@11
  __int16 v21; // [sp+36h] [bp-112h]@11
  __int16 v22; // [sp+38h] [bp-110h]@11
  __int16 v23; // [sp+3Ah] [bp-10Eh]@11
  __int16 v24; // [sp+3Ch] [bp-10Ch]@11
  __int16 v25; // [sp+3Eh] [bp-10Ah]@11
  __int16 v26; // [sp+40h] [bp-108h]@11
  __int16 v27; // [sp+42h] [bp-106h]@11
  float v28; // [sp+44h] [bp-104h]@1
  char v29; // [sp+48h] [bp-100h]@11

  v28 = 0.93199998;
  v7 = 0;
  sub_1008D070(7, &v8);
  sub_1008CC30(9041, &v6, 1, &v7);
  if ( v6 )
  {
    sub_1008CC30(9040, &v9, 4, &v28);
  }
  else
  {
    sub_1008CC30(9040, &v9, 4, &v28);
    v6 = 0;
    sub_1008CBF0(9040, (int)&v9, 4);
    sub_1008CBF0(9041, (int)&v6, 1);
  }
  if ( v8 )
  {
    v10 = v9;
  }
  else
  {
    if ( !sub_10066790(0x57u, &v10) )
      v10 = v9;
    if ( v10 != v9 )
    {
      v6 = 1;
      sub_1008CBF0(9040, (int)&v9, 4);
      sub_1008CBF0(9041, (int)&v6, 1);
    }
  }
  if ( *(_BYTE *)(a2 + 13) == 13 )
  {
    *(_WORD *)(a1 + 440) = word_101CAB28[6];
    *(_WORD *)(a1 + 442) = word_101CAB28[6];
    LOWORD(v11) = (signed int)a5;
    HIWORD(v11) = sub_100349D0(a3, a4, a2, v10);
    v12 = (signed int)a5;
    v14 = v11 - 5;
    v16 = v11 - 5;
    v20 = v11 - 5;
    v22 = v11 - 5;
    v13 = HIWORD(v11) - 6;
    v15 = HIWORD(v11) - 6;
    v23 = HIWORD(v11) + 6;
    v25 = HIWORD(v11) + 6;
    v17 = HIWORD(v11) - 4;
    v21 = HIWORD(v11) + 4;
    v18 = v11 - 2;
    v19 = HIWORD(v11);
    v24 = (signed int)a5;
    v26 = (signed int)a5;
    v27 = HIWORD(v11);
    sub_10090B70(a1 + 392, 9, (int)&v11, 64, (int)&v29);
    LOWORD(v11) = (signed int)(a6 + 1.0);
    HIWORD(v11) = sub_100349D0(a3, a4, a2, v10);
    v12 = (signed int)(a6 + 1.0);
    v13 = HIWORD(v11) - 6;
    v15 = HIWORD(v11) - 6;
    v14 = v11 + 5;
    v16 = v11 + 5;
    v17 = HIWORD(v11) - 4;
    v18 = v11 + 2;
    v19 = HIWORD(v11);
    v20 = v11 + 5;
    v22 = v11 + 5;
    v23 = HIWORD(v11) + 6;
    v25 = HIWORD(v11) + 6;
    v21 = HIWORD(v11) + 4;
    v24 = (signed int)(a6 + 1.0);
    v26 = (signed int)(a6 + 1.0);
    v27 = HIWORD(v11);
    sub_10090B70(a1 + 392, 9, (int)&v11, 64, (int)&v29);
  }
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10034D00) --------------------------------------------------------
signed int __usercall sub_10034D00@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  _BYTE *v6; // esi@1
  float *v7; // edx@1
  float *v8; // ecx@1
  double v9; // st7@4
  int v10; // eax@10
  int v11; // ecx@10
  int v12; // edx@10
  int v13; // ecx@10
  unsigned __int8 v14; // al@10
  int v15; // esi@11
  int v16; // eax@12
  int v17; // eax@13
  __int16 v18; // ax@18
  char *v19; // ebx@18
  _WORD *v20; // ST10_4@18
  __int16 *v21; // esi@18
  __int16 v22; // ax@18
  __int16 v23; // bx@21
  signed int result; // eax@23
  unsigned __int8 v25; // [sp+17h] [bp-129h]@10
  int v26; // [sp+1Ch] [bp-124h]@18
  __int16 v27; // [sp+20h] [bp-120h]@19
  __int16 v28; // [sp+22h] [bp-11Eh]@21
  __int16 v29; // [sp+24h] [bp-11Ch]@21
  __int16 v30; // [sp+26h] [bp-11Ah]@21
  __int16 v31; // [sp+28h] [bp-118h]@21
  __int16 v32; // [sp+2Ah] [bp-116h]@21
  int v33; // [sp+2Ch] [bp-114h]@1
  int v34; // [sp+30h] [bp-110h]@1
  _WORD *v35; // [sp+34h] [bp-10Ch]@1
  __int16 v36; // [sp+38h] [bp-108h]@10
  char v37[2]; // [sp+3Ah] [bp-106h]@18
  __int16 v38; // [sp+3Ch] [bp-104h]@10
  float v39[3]; // [sp+44h] [bp-FCh]@1
  char v40; // [sp+50h] [bp-F0h]@21
  int v41; // [sp+130h] [bp-10h]@10
  __int16 v42; // [sp+134h] [bp-Ch]@10
  __int16 v43; // [sp+136h] [bp-Ah]@18
  __int16 v44; // [sp+138h] [bp-8h]@15

  v5 = a1;
  v35 = (_WORD *)a2;
  v34 = a1;
  *(_WORD *)(a3 + 396) = 2;
  v6 = (_BYTE *)a5;
  v7 = v39;
  v8 = (float *)(a5 + 48);
  v33 = 3;
  do
  {
    if ( *v6 )
    {
      if ( *(float *)(a5 + 8) >= (double)*v8 )
      {
        if ( *(float *)(a5 + 4) <= (double)*v8 )
          v9 = *v8;
        else
          v9 = *(float *)(a5 + 4);
      }
      else
      {
        v9 = *(float *)(a5 + 8);
      }
      *v7 = v9;
    }
    ++v6;
    ++v8;
    ++v7;
    --v33;
  }
  while ( v33 );
  v10 = *(_WORD *)(v5 + 8) / 6;
  v11 = *(_WORD *)a4;
  v12 = v11 + v10 - 10;
  v13 = v10 + 2 + v11 + 4 * (v10 + 2);
  v14 = 0;
  *(_WORD *)(a3 + 426) = 2;
  *(_WORD *)(a3 + 424) = 2;
  v41 = 96;
  v42 = 4;
  v36 = v12;
  v38 = v13;
  v25 = 0;
  do
  {
    v15 = v14;
    if ( !*(_BYTE *)(v14 + a5) )
      goto LABEL_22;
    v16 = (unsigned __int8)sub_1003AAE0(v5, (const void *)a5, v14) - 1;
    if ( !v16 )
    {
LABEL_17:
      v44 = 2543;
      *(_WORD *)(a3 + 440) = word_101CAB28[15];
      *(_WORD *)(a3 + 442) = word_101CAB28[15];
      goto LABEL_18;
    }
    v17 = v16 - 1;
    if ( v17 )
    {
      if ( v17 != 1 )
        goto LABEL_17;
      v44 = 2312;
      *(_WORD *)(a3 + 440) = word_101CAB28[15];
      *(_WORD *)(a3 + 442) = word_101CAB28[8];
    }
    else
    {
      v44 = 2411;
      *(_WORD *)(a3 + 440) = word_101CAB28[15];
      *(_WORD *)(a3 + 442) = word_101CAB28[11];
    }
LABEL_18:
    v18 = sub_100349D0(a4, a5, v5, v39[v15]);
    v19 = &v37[4 * v15];
    v43 = *(_WORD *)(v34 + 10) + *(_WORD *)(a4 + 2) - v18;
    v20 = v35;
    *(_WORD *)v19 = v18;
    v21 = &v36 + 2 * v15;
    sub_1003F840(a3, (int)&v41, (int)v21, 0, v20);
    v22 = *v21 + 1;
    LOWORD(v26) = *v21 + 1;
    if ( v25 )
      v27 = v26 - 11;
    else
      v27 = v26 + 12;
    v23 = *(_WORD *)v19;
    v29 = v22;
    v31 = v22;
    HIWORD(v26) = v23;
    v30 = v23 + 12;
    v28 = v23;
    v32 = v23;
    sub_10090B70(a3 + 392, 4, (int)&v26, 56, (int)&v40);
    v5 = v34;
    v14 = v25;
LABEL_22:
    v25 = ++v14;
  }
  while ( v14 < 2u );
  sub_10034940(a3, (_DWORD *)a4, v5, (_BYTE *)a5);
  result = 1;
  *(_WORD *)(a3 + 426) = 1;
  *(_WORD *)(a3 + 424) = 1;
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];
// 10034D00: using guessed type float var_FC[3];
// 10034D00: using guessed type char var_106[2];

//----- (10034FC0) --------------------------------------------------------
int __usercall sub_10034FC0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, __int16 *a4)
{
  __int16 v4; // cx@1
  __int16 v5; // ax@1
  __int16 v6; // ax@2
  __int16 v7; // ST0C_2@3
  __int16 v8; // ax@4
  __int16 v9; // ax@4
  __int16 v10; // ST24_2@6
  __int16 v11; // ax@6
  __int16 v12; // ST04_2@6
  __int16 v13; // ST24_2@6
  __int16 v14; // ax@6
  int result; // eax@6
  __int16 v16; // [sp+8h] [bp-1Ch]@2
  __int16 v17; // [sp+8h] [bp-1Ch]@4
  __int16 *v18; // [sp+Ch] [bp-18h]@1
  __int16 v19; // [sp+10h] [bp-14h]@4
  signed int v20; // [sp+14h] [bp-10h]@1
  __int16 v21; // [sp+18h] [bp-Ch]@1
  __int16 v22; // [sp+1Ah] [bp-Ah]@1

  v4 = *a4;
  v5 = *(_WORD *)(a1 + 8) / 4;
  v21 = *a4 + v5 - 4;
  v22 = v5 + v4 + 2 * v5 + 5;
  v18 = &v21;
  v20 = 2;
  do
  {
    *(_WORD *)(a3 + 440) = word_101CAB28[15];
    *(_WORD *)(a3 + 442) = word_101CAB28[15];
    *(_WORD *)(a3 + 428) = word_101CAB28[15];
    *(_WORD *)(a3 + 430) = word_101CAB28[15];
    v16 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 16));
    v6 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 20));
    if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
    {
      *(_WORD *)(a3 + 440) = word_101CAB28[11];
      *(_WORD *)(a3 + 442) = word_101CAB28[11];
      *(_WORD *)(a3 + 428) = word_101CAB28[11];
      v7 = *v18;
      *(_WORD *)(a3 + 430) = word_101CAB28[11];
      sub_100903C0(a3 + 392, v7, v6, 6, v16 - v6, 1);
    }
    v8 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 12));
    *(_WORD *)(a3 + 440) = word_101CAB28[8];
    *(_WORD *)(a3 + 442) = word_101CAB28[8];
    *(_WORD *)(a3 + 428) = word_101CAB28[8];
    *(_WORD *)(a3 + 430) = word_101CAB28[8];
    sub_100903C0(a3 + 392, *v18, v16, 6, v8 - v16, 1);
    v17 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 24));
    v9 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 28));
    v19 = v9;
    if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 13) & 1 )
    {
      *(_WORD *)(a3 + 440) = word_101CAB28[11];
      *(_WORD *)(a3 + 442) = word_101CAB28[11];
      *(_WORD *)(a3 + 428) = word_101CAB28[11];
      *(_WORD *)(a3 + 430) = word_101CAB28[11];
      sub_100903C0(a3 + 392, *v18, v9, 6, v17 - v9, 1);
      v9 = v19;
    }
    v10 = v9;
    v11 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 32));
    *(_WORD *)(a3 + 440) = word_101CAB28[8];
    *(_WORD *)(a3 + 442) = word_101CAB28[8];
    *(_WORD *)(a3 + 428) = word_101CAB28[8];
    v12 = *v18;
    *(_WORD *)(a3 + 430) = word_101CAB28[8];
    sub_100903C0(a3 + 392, v12, v11, 6, v10 - v11, 1);
    v13 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 20));
    v14 = sub_100349D0((int)a4, a2, a1, *(float *)(a2 + 24));
    *(_WORD *)(a3 + 440) = word_101CAB28[4];
    *(_WORD *)(a3 + 442) = word_101CAB28[4];
    *(_WORD *)(a3 + 428) = word_101CAB28[4];
    *(_WORD *)(a3 + 430) = word_101CAB28[4];
    result = sub_100903C0(a3 + 392, *v18, v14, 6, v13 - v14, 1);
    ++v18;
    --v20;
  }
  while ( v20 );
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10035360) --------------------------------------------------------
void __usercall sub_10035360(int a1@<esi>, int a2, int a3, int a4)
{
  __int16 *v4; // ebp@1
  __int16 v5; // ax@1
  signed int v6; // kr00_4@1
  __int16 v7; // dx@1
  __int16 v8; // ST2C_2@1
  __int16 v9; // di@1
  __int16 v10; // bx@1
  float v11; // ST1C_4@1
  float v12; // ST18_4@1
  int v13; // [sp+20h] [bp+8h]@1

  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_101CAB28[15];
  *(_WORD *)(a1 + 430) = word_101CAB28[15];
  v4 = (__int16 *)a3;
  v5 = *(_WORD *)(a3 + 2);
  v13 = (unsigned __int16)(v5 + *(_WORD *)(a2 + 10));
  v6 = *(_WORD *)(a2 + 8);
  v7 = *v4;
  v8 = v5;
  *(_WORD *)(a1 + 436) = v5;
  v9 = v7 + v6 / 4 - 4;
  v10 = v6 / 4 + 3 + v7 + 2 * (v6 / 4 + 3);
  *(_WORD *)(a1 + 438) = v9;
  sub_10090620(a1 + 392, v9, v13, 0);
  *(_WORD *)(a1 + 438) = v10;
  *(_WORD *)(a1 + 436) = v8;
  sub_10090620(a1 + 392, v10, v13, 0);
  v11 = (double)v10;
  v12 = (double)v9;
  sub_10034A30(a1, a2, (int)v4, a4, v12, v11);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10035460) --------------------------------------------------------
char __cdecl sub_10035460(int a1, int a2, __int16 *a3, int a4, _WORD *a5)
{
  _BYTE *v5; // ecx@2
  int v6; // eax@2
  signed int v7; // edx@2
  double v8; // st7@3
  char result; // al@4

  switch ( *a5 )
  {
    case 0x8041:
      v5 = (_BYTE *)(a4 + 93);
      v6 = a4 + 60;
      v7 = 3;
      do
      {
        v8 = *(float *)(v6 - 12);
        v6 += 4;
        *(float *)(v6 - 4) = v8;
        *v5++ = 0;
        --v7;
      }
      while ( v7 );
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1003A640(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_10035360(a1, a2, (int)a3, a4);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_10034810(a1, a2, (int)a3);
      sub_10034FC0(a2, a4, a1, a3);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10034500(a2, (int)a5, a1, (int)a3, a4);
      sub_10034330((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_10034D00(a2, (int)a5, a1, (int)a3, a4);
      if ( !(*(_DWORD *)(a2 + 4) & 0x800) )
        goto LABEL_16;
      sub_10034680((int)a5, (int)a3, a2, a1, (const void *)a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10034680((int)a5, (int)a3, a2, a1, (const void *)a4);
      sub_10034330((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_16;
    default:
LABEL_16:
      result = 1;
      break;
  }
  return result;
}

//----- (10035630) --------------------------------------------------------
char __usercall sub_10035630@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // eax@1
  char v6; // cl@2
  bool v7; // al@3
  int v8; // edi@5
  int v9; // ebx@5
  unsigned int v10; // eax@10
  char *v11; // eax@12
  char *v12; // edx@12
  char v13; // cl@13
  char v14; // al@15
  char *v15; // edi@29
  char v16; // al@30
  unsigned int v17; // edi@45
  int v18; // eax@45
  __int16 v19; // ax@46
  int v20; // eax@48
  __int16 v21; // cx@48
  char *v22; // eax@51
  char v23; // cl@52
  int v24; // edi@56
  int v25; // esi@56
  char v27; // [sp+Eh] [bp-42h]@2
  char v28; // [sp+Fh] [bp-41h]@4
  int v29; // [sp+10h] [bp-40h]@46
  int v30; // [sp+14h] [bp-3Ch]@1
  int v31; // [sp+18h] [bp-38h]@53
  int v32; // [sp+1Ch] [bp-34h]@39
  __int16 v33; // [sp+20h] [bp-30h]@53
  __int16 v34; // [sp+22h] [bp-2Eh]@53
  int v35; // [sp+24h] [bp-2Ch]@1
  int v36; // [sp+28h] [bp-28h]@1
  char v37[4]; // [sp+2Ch] [bp-24h]@12
  char v38; // [sp+40h] [bp-10h]@32

  v36 = a3;
  v5 = *(_DWORD *)(a4 + 4) & 0x18;
  v30 = a2;
  v35 = a1;
  if ( v5 == 16 )
  {
    v6 = 3;
    v27 = 3;
  }
  else
  {
    v7 = v5 == 8;
    v27 = v7 + 1;
    v6 = v7 + 1;
  }
  v28 = 0;
  if ( v6 )
  {
    v8 = 0;
    v9 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1003AAE0(a4, (const void *)a5, v8) > (unsigned __int8)v28 )
        v28 = sub_1003AAE0(a4, (const void *)a5, v8);
      ++v8;
      --v9;
    }
    while ( v9 );
    v6 = v27;
  }
  v10 = *(_DWORD *)(a4 + 4);
  if ( !(~(unsigned __int8)(*(_DWORD *)(a4 + 4) >> 7) & 1) )
  {
    if ( !(v10 & 0x1000) )
      return v10;
    sub_1003AE60(*(_BYTE *)(a4 + 13), v37);
    goto LABEL_36;
  }
  if ( !(~(unsigned __int8)(v10 >> 14) & 1) )
  {
    v11 = sub_1006ED10(*(_WORD *)(a5 + 40));
    v12 = v37;
    do
    {
      v13 = *v11;
      *v12++ = *v11++;
    }
    while ( v13 );
    goto LABEL_26;
  }
  v14 = *(_BYTE *)(a4 + 13);
  if ( v14 != 2 || v6 != 1 )
  {
    if ( v14 != 3 || v6 != 1 )
    {
      if ( v14 != 8 && v14 != 7 || v6 != 1 )
      {
        sub_1003A690(a4, a5, v37);
LABEL_26:
        v6 = v27;
        goto LABEL_27;
      }
      strcpy(v37, "OIL");
    }
    else
    {
      strcpy(v37, "FPRES");
    }
  }
  else
  {
    strcpy(v37, "FFLOW");
  }
LABEL_27:
  if ( !(*(_DWORD *)(a4 + 4) & 0x1000) )
    goto LABEL_37;
  if ( v6 == 2 )
  {
    sub_1003AE60(*(_BYTE *)(a4 + 13), &v38);
    goto LABEL_33;
  }
  v15 = (char *)&v36 + 3;
  do
    v16 = (v15++)[1];
  while ( v16 );
  *(_WORD *)v15 = 32;
  sub_1003AE60(*(_BYTE *)(a4 + 13), &v37[strlen(v37)]);
LABEL_36:
  v6 = v27;
LABEL_37:
  if ( v6 != 1 )
  {
LABEL_33:
    switch ( v28 )
    {
      case 3:
        v32 = byte_102BA90E != 0 ? 35087 : 35304;
        break;
      case 2:
        v32 = 35169;
        break;
      default:
        v32 = 35215;
        break;
    }
    goto LABEL_45;
  }
  switch ( v28 )
  {
    case 3:
      v32 = byte_102BA90E != 0 ? 2319 : 2536;
      break;
    case 2:
      v32 = 2401;
      break;
    default:
      v32 = 2447;
      break;
  }
LABEL_45:
  v17 = *(_DWORD *)(a4 + 4);
  v18 = *(_DWORD *)(a4 + 4) & 0x18;
  if ( v18 == 16 )
  {
    v19 = *(_WORD *)(v30 + 2) - 8;
    LOWORD(v29) = *(_WORD *)v30 + *(_WORD *)(a4 + 8) / 2;
    HIWORD(v29) = v19;
  }
  else
  {
    if ( v18 == 8 )
    {
      v20 = v30;
      v21 = *(_WORD *)v30 + *(_WORD *)(a4 + 8) / 2 + 1;
    }
    else
    {
      v20 = v30;
      v21 = *(_WORD *)v30;
    }
    HIWORD(v29) = *(_WORD *)(v20 + 2) + 19;
    LOWORD(v29) = v21;
  }
  v22 = v37;
  do
    v23 = *v22++;
  while ( v23 );
  v34 = (_WORD)v22 - (unsigned int)&v37[1];
  v31 = 105;
  v33 = 0;
  if ( v27 == 2 && v17 & 0x1000 && ~(unsigned __int8)(v17 >> 7) & 1 )
  {
    v24 = v35;
    v25 = v36;
    sub_1003F3B0(v36, (int)&v31, (int)&v29, &v38, v35);
    HIWORD(v29) = *(_WORD *)(v30 + 2);
    LOBYTE(v10) = sub_1003F3B0(v25, (int)&v31, (int)&v29, v37, v24);
  }
  else
  {
    LOBYTE(v10) = sub_1003F3B0(v36, (int)&v31, (int)&v29, v37, v35);
  }
  return v10;
}
// 102BA90E: using guessed type char byte_102BA90E;

//----- (100359D0) --------------------------------------------------------
char __usercall sub_100359D0@<al>(int a1@<eax>, int a2@<ecx>, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // eax@1
  char result; // al@2
  _WORD *v7; // esi@5
  _BYTE *v8; // edi@5
  int v9; // ebx@5
  __int16 v10; // dx@7
  __int16 v11; // [sp+4h] [bp-Ch]@7
  __int16 v12; // [sp+6h] [bp-Ah]@4
  __int16 v13; // [sp+8h] [bp-8h]@7
  int v14; // [sp+Ah] [bp-6h]@4

  v5 = *(_DWORD *)(a1 + 4) & 0x18;
  if ( v5 == 16 )
    result = 3;
  else
    result = (v5 == 8) + 1;
  LOWORD(v14) = *(_WORD *)(a2 + 2) + 4;
  v12 = v14 + 18;
  if ( result )
  {
    v7 = a5;
    v8 = a4;
    v9 = (unsigned __int8)result;
    do
    {
      if ( !*v8 )
      {
        v10 = *v7 - 36;
        v11 = *v7 + 12;
        v13 = v10;
        result = sub_1004B2B0(a3, (int)&v13, (int)&v11, 0);
      }
      ++v8;
      v7 += 2;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (10035A60) --------------------------------------------------------
char __usercall sub_10035A60@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  _BYTE *v5; // ebx@1
  int v6; // eax@1
  char *v7; // esi@5
  int v8; // edi@5
  int v9; // edx@7
  int v10; // edi@9
  int *v11; // esi@9
  signed int v12; // eax@22
  char v13; // dl@25
  __int16 v14; // cx@29
  char *v15; // eax@29
  int v16; // ecx@31
  int v17; // eax@31
  signed int v18; // edi@32
  __int16 v19; // si@32
  int v20; // edx@32
  int v21; // eax@34
  int v22; // esi@37
  char *v23; // edi@37
  float *v24; // ebx@37
  double v25; // st7@40
  float *v26; // ecx@42
  char v28; // [sp+13h] [bp-61h]@2
  int v29; // [sp+14h] [bp-60h]@9
  int v30; // [sp+14h] [bp-60h]@37
  int v31; // [sp+1Ch] [bp-58h]@1
  __int16 v32; // [sp+24h] [bp-50h]@31
  char v33; // [sp+26h] [bp-4Eh]@29
  __int16 v34; // [sp+28h] [bp-4Ch]@35
  __int16 v35; // [sp+2Ch] [bp-48h]@32
  int v36; // [sp+30h] [bp-44h]@1
  char v37[12]; // [sp+34h] [bp-40h]@42
  char v38; // [sp+40h] [bp-34h]@5
  unsigned int v39; // [sp+44h] [bp-30h]@9
  char v40; // [sp+48h] [bp-2Ch]@37

  v5 = (_BYTE *)a5;
  v6 = *(_DWORD *)(a4 + 4) & 0x18;
  v31 = a2;
  v36 = a1;
  if ( v6 == 16 )
    v28 = 3;
  else
    v28 = (v6 == 8) + 1;
  if ( v28 )
  {
    v7 = &v38;
    v8 = (unsigned __int8)v28;
    do
    {
      sub_1003ADC0(*(_BYTE *)(a4 + 13), (int)v7);
      v7 += 16;
      --v8;
    }
    while ( v8 );
  }
  LOBYTE(v9) = v28;
  if ( (unsigned __int8)v28 <= 1u )
  {
    if ( v28 != 1 )
      goto LABEL_28;
    if ( *(_BYTE *)a5 )
    {
      switch ( sub_1003AAE0(a4, (const void *)a5, 0) )
      {
        case 3:
          v12 = byte_102BA90E != 0 ? 20751 : 20968;
          break;
        case 2:
          v12 = 20833;
          break;
        default:
          goto LABEL_24;
      }
    }
    else
    {
LABEL_24:
      v12 = 20879;
    }
    v13 = ~*(_BYTE *)(a4 + 6);
    v39 = v12;
    if ( !(v13 & 1) )
      v39 = *(_DWORD *)(a5 + 44) | v12 & 0xFFFF3FFF;
  }
  else
  {
    if ( !v28 )
      goto LABEL_31;
    v10 = 0;
    v11 = (int *)&v39;
    v29 = (unsigned __int8)v28;
    do
    {
      if ( *(_BYTE *)(v10 + a5) )
      {
        switch ( sub_1003AAE0(a4, (const void *)a5, v10) )
        {
          case 3:
            *v11 = byte_102BA90E != 0 ? 37135 : 37352;
            break;
          case 2:
            *v11 = 37217;
            break;
          default:
            goto LABEL_14;
        }
      }
      else
      {
LABEL_14:
        *v11 = 37263;
      }
      if ( !(~*(_BYTE *)(a4 + 6) & 1) )
        *v11 = *(_DWORD *)(a5 + 44) | *v11 & 0xFFFF3FFF;
      ++v10;
      v11 += 4;
      --v29;
    }
    while ( v29 );
  }
  LOBYTE(v9) = v28;
LABEL_28:
  if ( (_BYTE)v9 )
  {
    v14 = *(_WORD *)(v31 + 2) + 19;
    v15 = &v33;
    v9 = (unsigned __int8)v9;
    do
    {
      *(_WORD *)v15 = v14;
      v15 += 4;
      --v9;
    }
    while ( v9 );
  }
LABEL_31:
  v16 = *(_WORD *)v31;
  v17 = *(_DWORD *)(a4 + 4) & 0x18;
  v32 = v16 + *(_WORD *)(a4 + 8);
  if ( v17 == 16 )
  {
    v18 = *(_WORD *)(a4 + 8);
    v19 = *(_WORD *)(a4 + 8) / 6;
    v32 = v16 + v19 + 1;
    v20 = v18 / 2 + v16 + 1;
    v35 = v19 + v16 + 4 * v19 + 1;
  }
  else
  {
    if ( v17 != 8 )
      goto LABEL_36;
    v21 = *(_WORD *)(a4 + 8) / 6;
    v32 = v16 + v21 - 7;
    v20 = v21 + v16 + 4 * v21 + 9;
  }
  v34 = v20;
LABEL_36:
  if ( v28 )
  {
    v22 = 0;
    v23 = &v40;
    v24 = (float *)(a5 + 60);
    v30 = (unsigned __int8)v28;
    do
    {
      if ( *(_BYTE *)(v22 + a5) && sub_1003AAE0(a4, (const void *)a5, v22) )
        v25 = *v24;
      else
        v25 = 9.8999998e24;
      v26 = (float *)&v37[4 * v22];
      *v26 = v25;
      if ( 9.8999998e24 != *v26 && *(_BYTE *)(v22 + a5) )
      {
        if ( *(_DWORD *)(a4 + 4) & 0x40000 )
          *(_WORD *)v23 &= 0xFDFFu;
        sub_10040B30(a3, (int)(v23 - 8), (int *)&v32 + v22, (float *)&v37[4 * v22], v36);
      }
      ++v22;
      ++v24;
      v23 += 16;
      --v30;
    }
    while ( v30 );
    v5 = (_BYTE *)a5;
  }
  return sub_100359D0(a4, v31, a3, v5, &v32);
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10035A60: using guessed type char var_40[12];

//----- (10035D60) --------------------------------------------------------
char __cdecl sub_10035D60(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1003A640(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), a3);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10035A60((int)a5, a3, a1, a2, a4);
      sub_10035630((int)a5, a3, a1, a2, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10035A60((int)a5, a3, a1, a2, a4);
      sub_10035630((int)a5, a3, a1, a2, a4);
      goto LABEL_11;
    default:
LABEL_11:
      result = 1;
      break;
  }
  return result;
}

//----- (10035EC0) --------------------------------------------------------
char __usercall sub_10035EC0@<al>(__int16 a1@<bx>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  void *v6; // ecx@3
  char *v7; // eax@4
  int v8; // eax@6
  __int16 v9; // ST14_2@6
  int v10; // ST18_4@6
  __int16 v11; // dx@19
  __int16 v12; // cx@20
  __int16 v13; // dx@20
  const char *v15; // [sp-8h] [bp-58h]@9
  int v16; // [sp+0h] [bp-50h]@0
  __int16 v17; // [sp+Ch] [bp-44h]@3
  __int16 v18; // [sp+Eh] [bp-42h]@3
  int v19; // [sp+10h] [bp-40h]@19
  __int16 v20; // [sp+18h] [bp-38h]@19
  __int16 v21; // [sp+1Ah] [bp-36h]@19
  void *v22; // [sp+1Ch] [bp-34h]@3
  int v23; // [sp+20h] [bp-30h]@6
  int v24; // [sp+24h] [bp-2Ch]@6
  int v25; // [sp+28h] [bp-28h]@3
  char v26; // [sp+2Ch] [bp-24h]@12

  if ( *a6 == -32734 || *a6 == -32648 )
  {
    v17 = *(_WORD *)(a2 + 426);
    v6 = *(void **)(a2 + 428);
    v18 = *(_WORD *)(a2 + 424);
    v25 = *(_WORD *)(a2 + 396);
    v22 = v6;
    if ( sub_1006E630(v6) )
      v7 = sub_1004AB50(0x800u);
    else
      v7 = sub_1004AB50(0x400u);
    v23 = *(_DWORD *)v7;
    v24 = *(_DWORD *)sub_1004AB50(0x1000u);
    *(_WORD *)(a2 + 396) = 2;
    *(_WORD *)(a2 + 426) = 2;
    *(_WORD *)(a2 + 424) = 2;
    *(_WORD *)(a2 + 428) = word_101CAB28[12];
    *(_WORD *)(a2 + 430) = word_101CAB28[15];
    sub_100903C0(a2 + 392, *(_WORD *)a4 + 1, *(_WORD *)(a4 + 2) + 19, 48, 26, 0);
    *(_WORD *)(a2 + 438) = *(_WORD *)a4 + *(_WORD *)(a3 + 4) / 2;
    v8 = v23;
    *(_WORD *)(a2 + 436) = *(_WORD *)(a4 + 2) + 12;
    sub_1008F8E0(a2 + 392, v8, "FLAPS", *(_WORD *)(a3 + 4), 1, v9, v10);
    if ( !*(_BYTE *)a5 )
    {
      v11 = *(_WORD *)(a4 + 2) + 19;
      LOWORD(v19) = *(_WORD *)a4 + 1;
      HIWORD(v19) = v11;
      v20 = v19 + 48;
      v21 = v11 + 26;
      sub_1004B2B0(a2, (int)&v19, (int)&v20, 0);
      goto LABEL_20;
    }
    if ( *(float *)(a5 + 8) <= (double)*(float *)(a5 + 4) && *(float *)(a5 + 12) >= (double)*(float *)(a5 + 4) )
    {
      v15 = "UP";
LABEL_17:
      sprintf(&v26, v15);
      goto LABEL_18;
    }
    if ( *(float *)(a5 + 16) > (double)*(float *)(a5 + 4) || *(float *)(a5 + 20) < (double)*(float *)(a5 + 4) )
    {
      if ( *(float *)(a5 + 24) > (double)*(float *)(a5 + 4) || *(float *)(a5 + 28) < (double)*(float *)(a5 + 4) )
      {
        v15 = "///";
        goto LABEL_17;
      }
      sprintf(&v26, "DN");
    }
    else
    {
      sprintf(&v26, "T/O");
    }
LABEL_18:
    *(_WORD *)(a2 + 428) = word_101CAB28[12];
    *(_WORD *)(a2 + 430) = word_101CAB28[6];
    *(_WORD *)(a2 + 438) = *(_WORD *)a4 + *(_WORD *)(a3 + 4) / 2;
    *(_WORD *)(a2 + 436) = *(_WORD *)(a4 + 2) + 38;
    sub_1008F8E0(a2 + 392, v24, &v26, *(_WORD *)(a3 + 4), 1, a1, v16);
LABEL_20:
    *(_WORD *)(a2 + 396) = v25;
    v12 = (signed __int16)v22;
    *(_WORD *)(a2 + 426) = v17;
    v13 = HIWORD(v22);
    *(_WORD *)(a2 + 424) = v18;
    *(_WORD *)(a2 + 428) = v12;
    *(_WORD *)(a2 + 430) = v13;
  }
  return 1;
}
// 10035EC0: could not find valid save-restore pair for ebx
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10036190) --------------------------------------------------------
int __usercall sub_10036190@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // ebx@1
  signed int v6; // eax@2
  __int16 v7; // dx@2
  int v8; // eax@2
  __int16 v9; // ax@4
  __int16 v10; // di@4
  signed int v11; // ecx@4
  __int16 v12; // ax@5
  __int16 v13; // si@5
  signed int v14; // eax@7
  int v15; // edx@7
  int v16; // eax@7
  int v17; // eax@9
  int v18; // edi@9
  int v19; // esi@9
  signed int v20; // ecx@9
  __int16 v22; // [sp+10h] [bp-20h]@0
  __int16 v23; // [sp+12h] [bp-1Eh]@0
  __int16 v24; // [sp+14h] [bp-1Ch]@0
  __int16 v25; // [sp+16h] [bp-1Ah]@0
  __int16 v26; // [sp+18h] [bp-18h]@0
  __int16 v27; // [sp+1Ah] [bp-16h]@0
  __int16 v28; // [sp+20h] [bp-10h]@0
  __int16 v29; // [sp+22h] [bp-Eh]@0
  __int16 v30; // [sp+28h] [bp-8h]@0
  __int16 v31; // [sp+2Ah] [bp-6h]@0

  v3 = a3;
  *(_WORD *)(a3 + 394) = 1;
  v4 = a1;
  *(_WORD *)(a3 + 428) = word_101CAB28[15];
  *(_WORD *)(a3 + 430) = word_101CAB28[15];
  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 & 0x200000 )
  {
    if ( (v5 & 0x200000) == 0x200000 )
    {
      v14 = (signed int)((double)(10 * *(_WORD *)(a2 + 8)) * 0.2);
      v15 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * ((signed __int16)v14 + 5)) >> 32) >> 2)
                             + ((unsigned int)((unsigned __int64)(1717986919i64 * ((signed __int16)v14 + 5)) >> 32) >> 31));
      HIWORD(a3) = *(_WORD *)(v4 + 2);
      v25 = *(_WORD *)(v4 + 2);
      v27 = *(_WORD *)(v4 + 2);
      v16 = v5 & 0x18;
      v23 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      v31 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      v29 = *(_WORD *)(v4 + 2) + *(_WORD *)(a2 + 10);
      if ( v16 != 8 && v16 != 16 )
      {
        LOWORD(v19) = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
        LOWORD(a3) = *(_WORD *)v4;
        v24 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
        v22 = *(_WORD *)v4;
        v30 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
      }
      else
      {
        v17 = *(_WORD *)(a2 + 8);
        v18 = *(_WORD *)v4;
        v19 = v17 - v15 + v18;
        v20 = 10 * (signed __int16)v17 / 2 + 5;
        LOWORD(a3) = v18 + v15;
        v24 = v18 + v20 / 10;
        v22 = v18 + v15;
        v30 = v18 + v20 / 10;
      }
      v28 = v19;
      v26 = v19;
    }
  }
  else
  {
    v6 = (signed int)((double)(10 * *(_WORD *)(a2 + 10)) * 0.2);
    v7 = ((signed int)((unsigned __int64)(1717986919i64 * ((signed __int16)v6 + 5)) >> 32) >> 2)
       + ((unsigned int)((unsigned __int64)(1717986919i64 * ((signed __int16)v6 + 5)) >> 32) >> 31);
    LOWORD(a3) = *(_WORD *)v4;
    v24 = *(_WORD *)v4;
    v26 = *(_WORD *)v4;
    v8 = v5 & 0x18;
    v22 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    v30 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    v28 = *(_WORD *)v4 + *(_WORD *)(a2 + 8);
    if ( v8 != 8 && v8 != 16 )
    {
      v12 = *(_WORD *)(v4 + 2);
      v13 = *(_WORD *)(a2 + 10);
      HIWORD(a3) = *(_WORD *)(v4 + 2);
      v27 = v12 + v13;
      v25 = v12 + v13;
      v23 = *(_WORD *)(v4 + 2);
      v29 = v12 + v13;
      v31 = v12 + v13;
    }
    else
    {
      v9 = *(_WORD *)(a2 + 10);
      v10 = *(_WORD *)(v4 + 2);
      v11 = 10 * v9 / 2 + 5;
      HIWORD(a3) = v10 + v7;
      v27 = v9 - v7 + v10;
      v25 = v10 + v11 / 10;
      v23 = v10 + v7;
      v29 = v9 - v7 + v10;
      v31 = v10 + v11 / 10;
    }
  }
  *(_WORD *)(v3 + 438) = a3;
  *(_WORD *)(v3 + 436) = HIWORD(a3);
  sub_10090620(v3 + 392, v26, v27, 0);
  *(_WORD *)(v3 + 438) = v22;
  *(_WORD *)(v3 + 436) = v23;
  sub_10090620(v3 + 392, v28, v29, 0);
  *(_WORD *)(v3 + 438) = v24;
  *(_WORD *)(v3 + 436) = v25;
  return sub_10090620(v3 + 392, v30, v31, 2);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10036450) --------------------------------------------------------
char __usercall sub_10036450@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  int v7; // edi@5
  int v8; // ebx@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  char *v12; // eax@15
  char v13; // cl@16
  void *v14; // ecx@24
  int v15; // eax@25
  __int16 v16; // ax@27
  signed int v17; // eax@30
  char *v18; // eax@31
  char v20; // [sp+Bh] [bp-35h]@4
  int v21; // [sp+Ch] [bp-34h]@1
  int v22; // [sp+10h] [bp-30h]@31
  int v23; // [sp+14h] [bp-2Ch]@34
  int v24; // [sp+18h] [bp-28h]@21
  __int16 v25; // [sp+1Ch] [bp-24h]@36
  __int16 v26; // [sp+1Eh] [bp-22h]@33
  int v27; // [sp+20h] [bp-20h]@1
  int v28; // [sp+24h] [bp-1Ch]@1
  char v29[20]; // [sp+28h] [bp-18h]@10
  char v30[20]; // [sp+29h] [bp-17h]@33

  v28 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v21 = a2;
  v27 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v20 = 0;
  if ( v6 )
  {
    v7 = 0;
    v8 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1003AAE0(a3, a5, v7) > (unsigned __int8)v20 )
        v20 = sub_1003AAE0(a3, a5, v7);
      ++v7;
      --v8;
    }
    while ( v8 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1003A690(a3, (int)a5, v29);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v28 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1003AE60(*(_BYTE *)(a3 + 13), &v29[strlen(v29)]);
    }
    else if ( *(_BYTE *)(a3 + 13) == 20 )
    {
      v12 = (char *)&v28 + 3;
      do
        v13 = (v12++)[1];
      while ( v13 );
      *(_DWORD *)v12 = 1296389152;
      *((_WORD *)v12 + 2) = 80;
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1003AE60(*(_BYTE *)(a3 + 13), v29);
  }
  switch ( v20 )
  {
    case 3:
      v24 = byte_102BA90E != 0 ? 2319 : 2536;
      break;
    case 2:
      v24 = 2401;
      break;
    default:
      v24 = 2447;
      break;
  }
  v14 = (void *)(*(_DWORD *)(a3 + 4) >> 17);
  if ( ~(_BYTE)v14 & 1 )
  {
    v17 = *(_WORD *)(a3 + 8);
    v14 = (void *)v21;
    v24 |= 0x8000u;
    v16 = *(_WORD *)v21 + v17 / 2;
  }
  else
  {
    v15 = *(_DWORD *)(a3 + 4) & 0xC000;
    if ( v15 )
    {
      if ( v15 == 0x4000 )
      {
        v14 = (void *)v21;
        v16 = *(_WORD *)v21 + *(_WORD *)(a3 + 8);
        v24 |= 0x4000u;
      }
      else
      {
        v16 = *(_WORD *)v21 + *(_WORD *)(a3 + 8) / 2;
        v24 |= 0x8000u;
      }
    }
    else
    {
      v16 = *(_WORD *)v21;
    }
  }
  LOWORD(v22) = v16;
  v18 = v29;
  do
    LOBYTE(v14) = *v18++;
  while ( (_BYTE)v14 );
  v26 = (_WORD)v18 - (unsigned int)v30;
  if ( sub_1006E630(v14) )
  {
    HIWORD(v22) = *(_WORD *)(v21 + 2) - 7;
    v23 = 4;
  }
  else
  {
    HIWORD(v22) = *(_WORD *)(v21 + 2) - 6;
    v23 = 3;
  }
  v25 = 0;
  LOBYTE(v9) = sub_1003F3B0(v28, (int)&v23, (int)&v22, v29, v27);
  return v9;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10036450: using guessed type char var_18[20];

//----- (100366D0) --------------------------------------------------------
char __usercall sub_100366D0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  __int16 v7; // cx@1
  __int16 v8; // dx@1
  __int16 v10; // [sp+8h] [bp-38h]@1
  __int16 v11; // [sp+Ah] [bp-36h]@1
  __int16 v12; // [sp+Ch] [bp-34h]@1
  __int16 v13; // [sp+Eh] [bp-32h]@1
  float v14; // [sp+10h] [bp-30h]@1
  float v15; // [sp+14h] [bp-2Ch]@1
  int v16; // [sp+18h] [bp-28h]@1
  char v17; // [sp+1Ch] [bp-24h]@1
  char v18; // [sp+2Ch] [bp-14h]@1

  v5 = a1;
  v16 = a5;
  sub_1003AA80(*(_BYTE *)(a1 + 13), (int)&v17, (int)&v18);
  v6 = *(_WORD *)(v5 + 10) + *(_WORD *)(a2 + 2);
  v7 = *(_WORD *)a2;
  v15 = *(float *)(a4 + 8);
  v8 = *(_WORD *)(v5 + 8);
  v14 = *(float *)(a4 + 4);
  v13 = v6 + 14;
  v11 = v6 + 14;
  v10 = v7;
  v12 = v7 + v8 + 1;
  sub_10040B30(a3, (int)&v17, (int *)&v10, &v14, a5);
  return sub_10040B30(a3, (int)&v18, (int *)&v12, &v15, a5);
}

//----- (10036790) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __usercall sub_10036790@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  char v3; // al@1
  int v4; // ebx@4
  int v5; // eax@4
  __int16 v6; // bp@6
  __int16 v7; // ST22_2@6
  int result; // eax@6
  __int16 v9; // ax@7
  __int16 v10; // ST22_2@7
  signed int v11; // ecx@8
  signed int i; // ebx@8
  __int16 v13; // ax@9
  int v14; // ebx@11
  int v15; // eax@11
  __int16 v16; // bp@13
  __int16 v17; // ax@14
  __int16 v18; // ST20_2@14
  signed int v19; // ecx@15
  signed int j; // ebx@15
  __int16 v21; // ax@16
  signed int v22; // [sp+0h] [bp-10h]@4
  signed int v23; // [sp+0h] [bp-10h]@11
  __int16 v24; // [sp+0h] [bp-10h]@13
  __int16 v25; // [sp+2h] [bp-Eh]@6
  int v26; // [sp+8h] [bp-8h]@0
  __int16 v27; // [sp+Ch] [bp-4h]@0 OVERLAPPED

  v3 = 0;
  if ( !(*(_DWORD *)(a2 + 4) & 0x200000) )
    v3 = 1;
  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_101CAB28[15];
  *(_WORD *)(a1 + 430) = word_101CAB28[15];
  if ( v3 )
  {
    v22 = 10 * *(_WORD *)(a2 + 10);
    v4 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v22 / 2 + 5)) >> 32) >> 2)
                          + ((unsigned int)((unsigned __int64)(1717986919i64 * (v22 / 2 + 5)) >> 32) >> 31));
    v5 = *(_DWORD *)(a2 + 4) & 0x18;
    if ( v5 != 8 && v5 != 16 )
    {
      v9 = *(_WORD *)(a2 + 10);
      v6 = v9 + *(_WORD *)(a3 + 2);
      v10 = v9 + *(_WORD *)(a3 + 2);
      result = ((signed __int16)(signed int)((double)(10 * v9) * 0.7) + 5) / 10;
      v25 = v10 - result;
    }
    else
    {
      v6 = *(_WORD *)(a3 + 2) + ((signed __int16)(signed int)((double)v22 * 0.75) + 5) / 10;
      v7 = v6;
      result = *(_DWORD *)(&v27 - 1) - v4;
      v25 = v6 - v4;
    }
    v11 = *(_BYTE *)(a2 + 12);
    for ( i = 1; i <= v11; ++i )
    {
      v13 = *(_WORD *)a3 + (unsigned int)(i * *(_WORD *)(a2 + 8) / (v11 + 1));
      *(_WORD *)(a1 + 436) = v6;
      *(_WORD *)(a1 + 438) = v13;
      result = sub_10090620(a1 + 392, v13, v25, 0);
      v11 = *(_BYTE *)(a2 + 12);
    }
  }
  else
  {
    v23 = 10 * *(_WORD *)(a2 + 8);
    v14 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v23 / 2 + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64 * (v23 / 2 + 5)) >> 32) >> 31));
    v15 = *(_DWORD *)(a2 + 4) & 0x18;
    if ( v15 != 8 && v15 != 16 )
    {
      v17 = *(_WORD *)(a2 + 8);
      v16 = v17 + *(_WORD *)a3;
      v18 = v17 + *(_WORD *)a3;
      result = ((signed __int16)(signed int)((double)(10 * v17) * 0.7) + 5) / 10;
      v24 = v18 - result;
    }
    else
    {
      v16 = *(_WORD *)a3 + ((signed __int16)(signed int)((double)v23 * 0.75) + 5) / 10;
      LOWORD(v26) = v16;
      result = v26 - v14;
      v24 = v16 - v14;
    }
    v19 = *(_BYTE *)(a2 + 12);
    for ( j = 1; j <= v19; ++j )
    {
      v21 = *(_WORD *)(a3 + 2) + (unsigned int)(j * *(_WORD *)(a2 + 10) / (v19 + 1));
      *(_WORD *)(a1 + 438) = v16;
      *(_WORD *)(a1 + 436) = v21;
      result = sub_10090620(a1 + 392, v24, v21, 0);
      v19 = *(_BYTE *)(a2 + 12);
    }
  }
  return result;
}
// 10036790: variables would overlap: ST24_2.2 and ST22_4.4
// 10036790: failed to widen chains
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10036A40) --------------------------------------------------------
int __usercall sub_10036A40@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int result; // eax@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  bool v7; // zf@5
  __int16 v8; // cx@8
  __int16 v9; // dx@8
  __int16 v10; // [sp+4h] [bp-Ch]@4
  __int16 v11; // [sp+6h] [bp-Ah]@4
  int v12; // [sp+8h] [bp-8h]@1

  result = *(_DWORD *)a1;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v12 = *(_DWORD *)a1;
  if ( v5 == 8 || v5 == 16 )
  {
    v7 = *(_BYTE *)a4 == 0;
    v10 = v12 + *(_WORD *)(a3 + 8);
    if ( v7 )
    {
      v11 = HIWORD(v12) + *(_WORD *)(a3 + 10) / 2;
      result = sub_1004B2B0(a2, (int)&v12, (int)&v10, 0);
    }
    if ( !*(_BYTE *)(a4 + 1) )
    {
      v8 = *(_WORD *)(a3 + 10);
      v9 = *(_WORD *)(a1 + 2);
      HIWORD(v12) += *(_WORD *)(a3 + 10) / 2;
      v11 = v8 + v9;
      result = sub_1004B2B0(a2, (int)&v12, (int)&v10, 0);
    }
  }
  else if ( !*(_BYTE *)a4 )
  {
    v6 = v12 + *(_WORD *)(a3 + 8);
    v11 = *(_WORD *)(a3 + 10) + HIWORD(result);
    v10 = v6;
    result = sub_1004B2B0(a2, (int)&v12, (int)&v10, 0);
  }
  return result;
}

//----- (10036B20) --------------------------------------------------------
int __usercall sub_10036B20@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>, float a4)
{
  int v4; // esi@1
  char v5; // al@1
  bool v6; // zf@2
  int v7; // eax@2
  int v8; // ecx@3
  int v9; // esi@3
  float v10; // ST10_4@6
  float v11; // ST10_4@6
  int v13; // eax@8
  int v14; // esi@9
  int v15; // ecx@9
  float v16; // ST10_4@13
  int v17; // [sp+10h] [bp-4h]@0

  v4 = a1;
  v5 = ((unsigned __int8)*(_DWORD *)(a2 + 4) >> 1) & 1;
  if ( !(*(_DWORD *)(a2 + 4) & 0x200000) )
  {
    v6 = v5 == 0;
    v7 = *(_WORD *)v4;
    if ( v6 )
    {
      v9 = v7 + 1;
      v8 = v7 + *(_WORD *)(a2 + 8);
    }
    else
    {
      v8 = v7 + 1;
      v9 = v7 + *(_WORD *)(a2 + 8);
    }
    if ( *(float *)(a3 + 8) - *(float *)(a3 + 4) != 0.0 )
    {
      v10 = (a4 - *(float *)(a3 + 4)) / (*(float *)(a3 + 8) - *(float *)(a3 + 4));
      v11 = (double)(v8 - v9) * v10;
      return v9 + (signed int)sub_10095970(v11, 1.0);
    }
    return v9;
  }
  if ( (*(_DWORD *)(a2 + 4) & 0x200000) == 0x200000 )
  {
    v6 = v5 == 0;
    v13 = *(_WORD *)(v4 + 2);
    if ( v6 )
    {
      v15 = v13 + 1;
      v14 = v13 + *(_WORD *)(a2 + 10);
    }
    else
    {
      v14 = v13 + 1;
      v15 = v13 + *(_WORD *)(a2 + 10);
    }
    if ( *(float *)(a3 + 8) - *(float *)(a3 + 4) == 0.0 )
      return v15;
    v16 = (a4 - *(float *)(a3 + 4)) / (*(float *)(a3 + 8) - *(float *)(a3 + 4));
    return v14 - (signed int)(v16 * (double)(v14 - v15));
  }
  return v17;
}

//----- (10036C30) --------------------------------------------------------
int __usercall sub_10036C30@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4)
{
  int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // ecx@2
  int v7; // eax@2
  double v8; // st7@4
  signed int v9; // ecx@6
  int v10; // eax@6
  double v11; // st7@8
  char *v12; // eax@11
  __int16 v13; // ax@12
  float v14; // ST18_4@12
  double v15; // st7@14
  float v16; // ST18_4@14
  __int16 v17; // dx@14
  __int16 v18; // ax@14
  double v19; // st7@14
  float v20; // ST18_4@14
  __int16 v21; // ax@14
  double v22; // st7@16
  float v23; // ST18_4@16
  __int16 v24; // ax@16
  __int16 v25; // ST10_2@16
  __int16 v26; // dx@16
  __int16 v27; // ax@16
  double v28; // st7@16
  float v29; // ST18_4@16
  __int16 v30; // ax@16
  bool v31; // zf@16
  char *v33; // [sp+Ch] [bp-1Ch]@2
  int v34; // [sp+10h] [bp-18h]@14
  __int16 v35; // [sp+14h] [bp-14h]@14
  int v36; // [sp+18h] [bp-10h]@2
  int v37; // [sp+20h] [bp-8h]@2
  char *v38; // [sp+2Ch] [bp+4h]@2

  v4 = a4;
  v5 = a1;
  if ( *(_DWORD *)(a4 + 4) & 0x200000 )
  {
    v33 = (char *)&v36 + 2;
    v9 = *(_WORD *)(a4 + 8);
    v38 = (char *)&v37 + 2;
    v10 = *(_DWORD *)(v4 + 4) & 0x18;
    if ( v10 != 8 && v10 != 16 )
    {
      LOWORD(v36) = *(_WORD *)a2 + v9 / 2;
      LOWORD(v37) = ((signed int)((unsigned __int64)(1717986919i64 * (10 * v9 / 2 + 5)) >> 32) >> 2)
                  + ((unsigned int)((unsigned __int64)(1717986919i64 * (10 * v9 / 2 + 5)) >> 32) >> 31)
                  + v36;
    }
    else
    {
      v11 = (double)(10 * *(_WORD *)(v4 + 8));
      LOWORD(v36) = *(_WORD *)a2 + *(_WORD *)(v4 + 8) / 2 - (5 - (signed int)(-0.15 * v11)) / 10;
      LOWORD(v37) = v36 + ((signed __int16)(signed int)(v11 * 0.3) + 5) / 10;
    }
  }
  else
  {
    v33 = (char *)&v37;
    v6 = *(_WORD *)(a4 + 10);
    v38 = (char *)&v36;
    v7 = *(_DWORD *)(v4 + 4) & 0x18;
    if ( v7 != 8 && v7 != 16 )
    {
      HIWORD(v36) = *(_WORD *)(a2 + 2) + v6 / 2;
      HIWORD(v37) = ((signed int)((unsigned __int64)(1717986919i64 * (10 * v6 / 2 + 5)) >> 32) >> 2)
                  + ((unsigned int)((unsigned __int64)(1717986919i64 * (10 * v6 / 2 + 5)) >> 32) >> 31)
                  + HIWORD(v36);
    }
    else
    {
      v8 = (double)(10 * *(_WORD *)(v4 + 10));
      HIWORD(v36) = *(_WORD *)(a2 + 2) + *(_WORD *)(v4 + 10) / 2 - (5 - (signed int)(-0.15 * v8)) / 10;
      HIWORD(v37) = HIWORD(v36) + ((signed __int16)(signed int)(v8 * 0.3) + 5) / 10;
    }
  }
  if ( *(_BYTE *)(v4 + 4) & 2 )
  {
    v12 = v38;
    v38 = v33;
    v33 = v12;
  }
  v13 = sub_10036B20(a2, v4, v5, *(float *)(v5 + 16));
  v14 = *(float *)(v5 + 20);
  *(_WORD *)v38 = v13;
  *(_WORD *)v33 = sub_10036B20(a2, v4, v5, v14);
  *(_WORD *)(a3 + 440) = word_101CAB28[11];
  *(_WORD *)(a3 + 442) = word_101CAB28[11];
  *(_WORD *)(a3 + 428) = word_101CAB28[11];
  *(_WORD *)(a3 + 430) = word_101CAB28[11];
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
    sub_100903C0(a3 + 392, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
  v15 = *(float *)(v5 + 12);
  *(_WORD *)v33 = *(_WORD *)v38;
  v16 = v15;
  *(_WORD *)v38 = sub_10036B20(a2, v4, v5, v16);
  *(_WORD *)(a3 + 440) = word_101CAB28[8];
  *(_WORD *)(a3 + 442) = word_101CAB28[8];
  *(_WORD *)(a3 + 428) = word_101CAB28[8];
  v17 = HIWORD(v37);
  *(_WORD *)(a3 + 430) = word_101CAB28[8];
  v34 = a3 + 392;
  sub_100903C0(a3 + 392, v36, SHIWORD(v36), v37 - v36, v17 - HIWORD(v36), 1);
  v18 = sub_10036B20(a2, v4, v5, *(float *)(v5 + 24));
  v19 = *(float *)(v5 + 28);
  *(_WORD *)v38 = v18;
  v20 = v19;
  v21 = sub_10036B20(a2, v4, v5, v20);
  *(_WORD *)v33 = v21;
  *(_WORD *)(a3 + 440) = word_101CAB28[11];
  *(_WORD *)(a3 + 442) = word_101CAB28[11];
  *(_WORD *)(a3 + 428) = word_101CAB28[11];
  *(_WORD *)(a3 + 430) = word_101CAB28[11];
  v35 = v21;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_100903C0(v34, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
    v21 = v35;
  }
  v22 = *(float *)(v5 + 32);
  *(_WORD *)v38 = v21;
  v23 = v22;
  *(_WORD *)v33 = sub_10036B20(a2, v4, v5, v23);
  *(_WORD *)(a3 + 440) = word_101CAB28[8];
  *(_WORD *)(a3 + 442) = word_101CAB28[8];
  *(_WORD *)(a3 + 428) = word_101CAB28[8];
  v24 = HIWORD(v36);
  v25 = HIWORD(v37) - HIWORD(v36);
  v26 = v37;
  *(_WORD *)(a3 + 430) = word_101CAB28[8];
  sub_100903C0(v34, v36, v24, v26 - v36, v25, 1);
  v27 = sub_10036B20(a2, v4, v5, *(float *)(v5 + 20));
  v28 = *(float *)(v5 + 24);
  *(_WORD *)v38 = v27;
  v29 = v28;
  v30 = sub_10036B20(a2, v4, v5, v29);
  v31 = (*(_DWORD *)(v4 + 4) & 0x800000) == 0;
  *(_WORD *)v33 = v30;
  if ( v31 )
  {
    *(_WORD *)(a3 + 440) = word_101CAB28[4];
    *(_WORD *)(a3 + 442) = word_101CAB28[4];
    *(_WORD *)(a3 + 428) = word_101CAB28[4];
    *(_WORD *)(a3 + 430) = word_101CAB28[4];
  }
  else
  {
    *(_WORD *)(a3 + 440) = word_101CAB28[15];
    *(_WORD *)(a3 + 442) = word_101CAB28[15];
    *(_WORD *)(a3 + 428) = word_101CAB28[15];
    *(_WORD *)(a3 + 430) = word_101CAB28[15];
  }
  return sub_100903C0(v34, v36, SHIWORD(v36), v37 - v36, HIWORD(v37) - HIWORD(v36), 1);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10037190) --------------------------------------------------------
signed int __usercall sub_10037190@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4)
{
  int v4; // edi@1
  _BYTE *v5; // ebx@1
  float *v6; // edx@1
  float *v7; // ecx@1
  double v8; // st7@4
  float v9; // ebx@12
  int v10; // eax@12
  __int16 v11; // ax@14
  __int16 v12; // cx@14
  unsigned int v13; // edx@15
  bool v14; // zf@16
  unsigned __int16 v15; // ax@17
  __int16 v16; // dx@17
  int v17; // eax@17
  float v18; // ecx@17
  __int16 v19; // dx@22
  int v20; // ecx@22
  __int16 v21; // ax@26
  __int16 v22; // ax@27
  char v23; // al@28
  __int16 v24; // cx@30
  __int16 v25; // ax@33
  int v26; // eax@37
  unsigned __int16 v27; // cx@40
  __int16 v28; // bx@40
  char v29; // al@40
  int v30; // eax@41
  int v31; // ecx@41
  __int16 v32; // ax@45
  int v33; // ST14_4@45
  __int16 v34; // cx@46
  char v35; // al@47
  __int16 v36; // ax@49
  __int16 v37; // ax@52
  int v38; // ST14_4@52
  char v39; // cl@52
  int v40; // ebx@57
  __int16 v41; // ax@57
  signed int result; // eax@62
  __int16 v43; // [sp+4h] [bp-134h]@0
  int v44; // [sp+8h] [bp-130h]@0
  char v45; // [sp+10h] [bp-128h]@22
  char v46; // [sp+11h] [bp-127h]@22
  int v47; // [sp+14h] [bp-124h]@1
  int v48; // [sp+18h] [bp-120h]@1
  float v49; // [sp+1Ch] [bp-11Ch]@3
  __int16 v50; // [sp+20h] [bp-118h]@17
  __int16 v51; // [sp+22h] [bp-116h]@20
  __int16 v52; // [sp+24h] [bp-114h]@17
  __int16 v53; // [sp+26h] [bp-112h]@18
  __int16 v54; // [sp+28h] [bp-110h]@17
  __int16 v55; // [sp+2Ah] [bp-10Eh]@18
  __int16 v56; // [sp+2Ch] [bp-10Ch]@17
  __int16 v57; // [sp+2Eh] [bp-10Ah]@20
  int v58; // [sp+30h] [bp-108h]@1
  int v59; // [sp+34h] [bp-104h]@1
  __int16 v60; // [sp+38h] [bp-100h]@57
  __int16 v61; // [sp+3Ah] [bp-FEh]@57
  __int16 v62; // [sp+3Ch] [bp-FCh]@57
  __int16 v63; // [sp+3Eh] [bp-FAh]@57
  __int16 v64; // [sp+40h] [bp-F8h]@57
  __int16 v65; // [sp+42h] [bp-F6h]@57
  __int16 v66; // [sp+44h] [bp-F4h]@57
  __int16 v67; // [sp+46h] [bp-F2h]@57
  __int16 v68; // [sp+48h] [bp-F0h]@57
  __int16 v69; // [sp+4Ah] [bp-EEh]@57
  float v70; // [sp+4Ch] [bp-ECh]@1
  float v71; // [sp+50h] [bp-E8h]@40
  float v72; // [sp+54h] [bp-E4h]@57
  char v73; // [sp+58h] [bp-E0h]@21

  v4 = a1;
  *(_WORD *)(a2 + 396) = 2;
  v58 = FNT_get_fnt_hdr(3);
  v48 = 10 * *(_WORD *)(a3 + 10);
  v47 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v48 / 2 + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64 * (v48 / 2 + 5)) >> 32) >> 31));
  v59 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                          * ((signed __int16)(signed int)((double)v48 * 0.2) + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v48 * 0.2) + 5)) >> 32) >> 31));
  v5 = (_BYTE *)v4;
  v6 = &v70;
  v7 = (float *)(v4 + 48);
  v48 = 3;
  do
  {
    if ( *v5 == 1 )
    {
      v49 = *v7;
      if ( (LODWORD(v49) & 0x7F800000) == 2139095040 )
      {
        v8 = *(float *)(v4 + 4);
      }
      else if ( *(float *)(v4 + 8) >= (double)*v7 )
      {
        if ( *(float *)(v4 + 4) <= (double)*v7 )
          v8 = *v7;
        else
          v8 = *(float *)(v4 + 4);
      }
      else
      {
        v8 = *(float *)(v4 + 8);
      }
      *v6 = v8;
    }
    ++v5;
    ++v7;
    ++v6;
    --v48;
  }
  while ( v48 );
  LODWORD(v9) = (unsigned __int16)(*(_WORD *)(a4 + 2) - 4);
  v10 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v10 != 8 && v10 != 16 )
  {
    v48 = 10 * *(_WORD *)(a3 + 10);
    v13 = (unsigned __int64)(1717986919i64 * ((signed __int16)(signed int)((double)v48 * 1.8) + 5)) >> 32;
    v11 = *(_WORD *)(a3 + 10);
    v12 = *(_WORD *)(a4 + 2);
    v48 = (unsigned __int16)(((signed int)v13 >> 2) + (v13 >> 31));
  }
  else
  {
    v48 = 10 * *(_WORD *)(a3 + 10);
    v11 = *(_WORD *)(a4 + 2);
    v48 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v48 * 0.9) + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64
                                                              * ((signed __int16)(signed int)((double)v48 * 0.9) + 5)) >> 32) >> 31));
    v12 = v47;
  }
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v14 = *(_BYTE *)v4 == 1;
  v47 = (unsigned __int16)(v12 + v11);
  if ( v14 )
  {
    v15 = sub_10036B20(a4, a3, v4, v70);
    LODWORD(v18) = v15;
    v52 = (signed __int16)v48 / 2 + v15;
    v16 = v15 - (signed __int16)v48 / 2;
    v17 = *(_DWORD *)(a3 + 4);
    v49 = v18;
    v50 = LOWORD(v18);
    v56 = LOWORD(v18);
    LOWORD(v18) = v47;
    v54 = v16;
    if ( (v17 & 0x18) == 16 )
    {
      LODWORD(v18) = v47 - v59 + 1;
      v53 = LOWORD(v9) - v59 + 1;
      v55 = LOWORD(v9) - v59 + 1;
    }
    else
    {
      v53 = LOWORD(v9);
      v55 = LOWORD(v9);
    }
    v57 = LOWORD(v18);
    v51 = LOWORD(v18);
    if ( v17 & 0x1000000 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[6];
      *(_WORD *)(a2 + 430) = word_101CAB28[6];
      *(_WORD *)(a2 + 440) = word_101CAB28[6];
      *(_WORD *)(a2 + 442) = word_101CAB28[6];
      sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[6];
        v19 = word_101CAB28[1];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v20 = v58;
        *(_WORD *)(a2 + 430) = v19;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1008F8E0(a2 + 392, v20, &v45, 0, 1, v43, v44);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_101CAB28[1];
      *(_WORD *)(a2 + 430) = word_101CAB28[1];
      sub_10091260(a2 + 392, 4, (int)&v50, 2);
      goto LABEL_36;
    }
    if ( sub_1003AAE0(a3, (const void *)v4, 0) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[8];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[8];
      sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[8];
        v21 = word_101CAB28[15];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 430) = v21;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1008F8E0(a2 + 392, v58, &v45, 0, 1, v43, v44);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      v22 = word_101CAB28[15];
      goto LABEL_35;
    }
    v23 = sub_1003AAE0(a3, (const void *)v4, 0);
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    if ( v23 == 2 )
    {
      *(_WORD *)(a2 + 430) = word_101CAB28[11];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[11];
      sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        v24 = word_101CAB28[11];
LABEL_33:
        *(_WORD *)(a2 + 428) = v24;
        v25 = word_101CAB28[1];
        *(_WORD *)(a2 + 438) = LOWORD(v49) + 1;
        *(_WORD *)(a2 + 430) = v25;
        *(_WORD *)(a2 + 436) = LOWORD(v9) + 10;
        v45 = *(_BYTE *)(v4 + 72);
        v46 = 0;
        sub_1008F8E0(a2 + 392, v58, &v45, 0, 1, v43, v44);
        goto LABEL_34;
      }
    }
    else
    {
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[15];
      sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        v24 = word_101CAB28[15];
        goto LABEL_33;
      }
    }
LABEL_34:
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_101CAB28[1];
    v22 = word_101CAB28[1];
LABEL_35:
    *(_WORD *)(a2 + 430) = v22;
    sub_10091260(a2 + 392, 4, (int)&v50, 2);
LABEL_36:
    *(_WORD *)(a2 + 424) = 2;
    *(_WORD *)(a2 + 426) = 2;
  }
  v26 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v26 != 8 && v26 != 16 || !*(_BYTE *)(v4 + 1) )
    goto LABEL_55;
  v27 = *(_WORD *)(a4 + 2) + *(_WORD *)(a3 + 10) + 4;
  LODWORD(v49) = (unsigned __int16)v47;
  v47 = v27;
  v28 = sub_10036B20(a4, a3, v4, v71);
  v29 = *(_DWORD *)(a3 + 4) & 0x18;
  v50 = v28;
  v52 = (signed __int16)v48 / 2 + v28;
  v54 = v28 - (signed __int16)v48 / 2;
  v56 = v28;
  if ( v29 == 16 )
  {
    v30 = LODWORD(v49) + v59 - 1;
    v31 = v47 + v59 - 1;
  }
  else
  {
    LOWORD(v30) = LOWORD(v49);
    LOWORD(v31) = v47;
  }
  v57 = v30;
  v51 = v30;
  v55 = v31;
  v53 = v31;
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  if ( sub_1003AAE0(a3, (const void *)v4, 1) == 3 )
  {
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    *(_WORD *)(a2 + 430) = word_101CAB28[8];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[8];
    sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[8];
      v32 = v47 - 2;
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      *(_WORD *)(a2 + 436) = v32;
      v33 = v58;
      *(_WORD *)(a2 + 438) = v28 + 1;
      v45 = *(_BYTE *)(v4 + 79);
      v46 = 0;
      sub_1008F8E0(a2 + 392, v33, &v45, 0, 1, v43, v44);
    }
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    v34 = word_101CAB28[15];
    goto LABEL_54;
  }
  v35 = sub_1003AAE0(a3, (const void *)v4, 1);
  *(_WORD *)(a2 + 428) = word_101CAB28[15];
  if ( v35 == 2 )
  {
    *(_WORD *)(a2 + 430) = word_101CAB28[11];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[11];
    sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v36 = word_101CAB28[11];
LABEL_52:
      *(_WORD *)(a2 + 428) = v36;
      v37 = v47 - 2;
      *(_WORD *)(a2 + 430) = word_101CAB28[1];
      *(_WORD *)(a2 + 436) = v37;
      v38 = v58;
      *(_WORD *)(a2 + 438) = v28 + 1;
      v39 = *(_BYTE *)(v4 + 79);
      v46 = 0;
      v45 = v39;
      sub_1008F8E0(a2 + 392, v38, &v45, 0, 1, v43, v44);
      goto LABEL_53;
    }
  }
  else
  {
    *(_WORD *)(a2 + 430) = word_101CAB28[15];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[15];
    sub_10090B70(a2 + 392, 3, (int)&v50, 56, (int)&v73);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v36 = word_101CAB28[15];
      goto LABEL_52;
    }
  }
LABEL_53:
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 428) = word_101CAB28[1];
  v34 = word_101CAB28[1];
LABEL_54:
  *(_WORD *)(a2 + 430) = v34;
  sub_10091260(a2 + 392, 4, (int)&v50, 2);
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v9 = v49;
LABEL_55:
  if ( (*(_DWORD *)(a3 + 4) & 0x18) == 16 && *(_BYTE *)(v4 + 2) )
  {
    v47 = (unsigned __int16)(LOWORD(v9) + v59 - 3);
    v40 = 3 - v59 + LODWORD(v9);
    v41 = sub_10036B20(a4, a3, v4, v72);
    v62 = (signed __int16)v48 / 2 + v41 - 4;
    v60 = v41;
    v64 = v41;
    v68 = v41;
    v66 = v41 - (signed __int16)v48 / 2 + 4;
    v61 = v40;
    v69 = v40;
    v63 = ((signed __int16)v40 + (signed __int16)v47) / 2;
    v65 = v47;
    v67 = ((signed __int16)v40 + (signed __int16)v47) / 2;
    *(_WORD *)(a2 + 426) = 2;
    *(_WORD *)(a2 + 424) = 2;
    if ( sub_1003AAE0(a3, (const void *)v4, 2) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[8];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[8];
      sub_10091260(a2 + 392, 5, (int)&v60, 2);
      sub_10090B70(a2 + 392, 3, (int)&v60, 56, (int)&v73);
    }
    else if ( sub_1003AAE0(a3, (const void *)v4, 2) == 2 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[11];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[11];
      sub_10091260(a2 + 392, 5, (int)&v60, 2);
      sub_10090B70(a2 + 392, 3, (int)&v60, 56, (int)&v73);
    }
    else
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      sub_10091260(a2 + 392, 5, (int)&v60, 2);
    }
  }
  result = 1;
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  return result;
}
// 1008BA0E: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10037D30) --------------------------------------------------------
signed int __usercall sub_10037D30@<eax>(int a1@<eax>, int a2@<esi>, int a3, __int16 *a4)
{
  int v4; // edi@1
  _BYTE *v5; // ebx@1
  float *v6; // edx@1
  float *v7; // ecx@1
  double v8; // st7@4
  float v9; // ebx@12
  int v10; // eax@12
  __int16 v11; // ax@14
  __int16 v12; // cx@14
  unsigned int v13; // edx@15
  bool v14; // zf@16
  unsigned __int16 v15; // ax@17
  __int16 v16; // dx@17
  int v17; // eax@17
  float v18; // ecx@17
  __int16 v19; // dx@22
  __int16 v20; // cx@22
  int v21; // ecx@22
  __int16 v22; // ax@26
  __int16 v23; // dx@26
  __int16 v24; // ax@27
  char v25; // al@28
  __int16 v26; // ax@30
  __int16 v27; // cx@30
  __int16 v28; // dx@30
  int v29; // eax@37
  unsigned __int16 v30; // cx@40
  __int16 v31; // bx@40
  char v32; // al@40
  int v33; // eax@41
  int v34; // ecx@41
  __int16 v35; // ax@45
  int v36; // ST14_4@45
  __int16 v37; // cx@46
  char v38; // al@47
  __int16 v39; // ax@49
  __int16 v40; // ax@52
  int v41; // ST14_4@52
  char v42; // cl@52
  int v43; // ebx@57
  __int16 v44; // ax@57
  signed int result; // eax@62
  __int16 v46; // [sp+4h] [bp-134h]@0
  int v47; // [sp+8h] [bp-130h]@0
  char v48; // [sp+10h] [bp-128h]@22
  char v49; // [sp+11h] [bp-127h]@22
  int v50; // [sp+14h] [bp-124h]@1
  int v51; // [sp+18h] [bp-120h]@1
  float v52; // [sp+1Ch] [bp-11Ch]@3
  __int16 v53; // [sp+20h] [bp-118h]@20
  __int16 v54; // [sp+22h] [bp-116h]@17
  __int16 v55; // [sp+24h] [bp-114h]@18
  __int16 v56; // [sp+26h] [bp-112h]@17
  __int16 v57; // [sp+28h] [bp-110h]@18
  __int16 v58; // [sp+2Ah] [bp-10Eh]@17
  __int16 v59; // [sp+2Ch] [bp-10Ch]@20
  __int16 v60; // [sp+2Eh] [bp-10Ah]@17
  int v61; // [sp+30h] [bp-108h]@1
  int v62; // [sp+34h] [bp-104h]@1
  __int16 v63; // [sp+38h] [bp-100h]@57
  __int16 v64; // [sp+3Ah] [bp-FEh]@57
  __int16 v65; // [sp+3Ch] [bp-FCh]@57
  __int16 v66; // [sp+3Eh] [bp-FAh]@57
  __int16 v67; // [sp+40h] [bp-F8h]@57
  __int16 v68; // [sp+42h] [bp-F6h]@57
  __int16 v69; // [sp+44h] [bp-F4h]@57
  __int16 v70; // [sp+46h] [bp-F2h]@57
  __int16 v71; // [sp+48h] [bp-F0h]@57
  __int16 v72; // [sp+4Ah] [bp-EEh]@57
  float v73; // [sp+4Ch] [bp-ECh]@1
  float v74; // [sp+50h] [bp-E8h]@40
  float v75; // [sp+54h] [bp-E4h]@57
  char v76; // [sp+58h] [bp-E0h]@21

  v4 = a1;
  *(_WORD *)(a2 + 396) = 2;
  v61 = FNT_get_fnt_hdr(3);
  v51 = 10 * *(_WORD *)(a3 + 8);
  v50 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64 * (v51 / 2 + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64 * (v51 / 2 + 5)) >> 32) >> 31));
  v62 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                          * ((signed __int16)(signed int)((double)v51 * 0.2) + 5)) >> 32) >> 2)
                         + ((unsigned int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v51 * 0.2) + 5)) >> 32) >> 31));
  v5 = (_BYTE *)v4;
  v6 = &v73;
  v7 = (float *)(v4 + 48);
  v51 = 3;
  do
  {
    if ( *v5 == 1 )
    {
      v52 = *v7;
      if ( (LODWORD(v52) & 0x7F800000) == 2139095040 )
      {
        v8 = *(float *)(v4 + 4);
      }
      else if ( *(float *)(v4 + 8) >= (double)*v7 )
      {
        if ( *(float *)(v4 + 4) <= (double)*v7 )
          v8 = *v7;
        else
          v8 = *(float *)(v4 + 4);
      }
      else
      {
        v8 = *(float *)(v4 + 8);
      }
      *v6 = v8;
    }
    ++v5;
    ++v7;
    ++v6;
    --v51;
  }
  while ( v51 );
  LODWORD(v9) = (unsigned __int16)(*a4 - 4);
  v10 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v10 != 8 && v10 != 16 )
  {
    v51 = 10 * *(_WORD *)(a3 + 8);
    v13 = (unsigned __int64)(1717986919i64 * ((signed __int16)(signed int)((double)v51 * 1.8) + 5)) >> 32;
    v11 = *(_WORD *)(a3 + 8);
    v12 = *a4;
    v51 = (unsigned __int16)(((signed int)v13 >> 2) + (v13 >> 31));
  }
  else
  {
    v51 = 10 * *(_WORD *)(a3 + 8);
    v11 = *a4;
    v51 = (unsigned __int16)(((signed int)((unsigned __int64)(1717986919i64
                                                            * ((signed __int16)(signed int)((double)v51 * 0.9) + 5)) >> 32) >> 2)
                           + ((unsigned int)((unsigned __int64)(1717986919i64
                                                              * ((signed __int16)(signed int)((double)v51 * 0.9) + 5)) >> 32) >> 31));
    v12 = v50;
  }
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v14 = *(_BYTE *)v4 == 1;
  v50 = (unsigned __int16)(v12 + v11);
  if ( v14 )
  {
    v15 = sub_10036B20((int)a4, a3, v4, v73);
    LODWORD(v18) = v15;
    v56 = (signed __int16)v51 / 2 + v15;
    v16 = v15 - (signed __int16)v51 / 2;
    v17 = *(_DWORD *)(a3 + 4);
    v52 = v18;
    v54 = LOWORD(v18);
    v60 = LOWORD(v18);
    LOWORD(v18) = v50;
    v58 = v16;
    if ( (v17 & 0x18) == 16 )
    {
      LODWORD(v18) = v50 - v62 + 1;
      v55 = LOWORD(v9) - v62 + 1;
      v57 = LOWORD(v9) - v62 + 1;
    }
    else
    {
      v55 = LOWORD(v9);
      v57 = LOWORD(v9);
    }
    v59 = LOWORD(v18);
    v53 = LOWORD(v18);
    if ( v17 & 0x1000000 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[6];
      *(_WORD *)(a2 + 430) = word_101CAB28[6];
      *(_WORD *)(a2 + 440) = word_101CAB28[6];
      *(_WORD *)(a2 + 442) = word_101CAB28[6];
      sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[6];
        v19 = word_101CAB28[1];
        v20 = LOWORD(v52);
        *(_WORD *)(a2 + 438) = LOWORD(v9) + 6;
        *(_WORD *)(a2 + 436) = v20 + 3;
        v21 = v61;
        *(_WORD *)(a2 + 430) = v19;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1008F8E0(a2 + 392, v21, &v48, 0, 1, v46, v47);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_101CAB28[1];
      *(_WORD *)(a2 + 430) = word_101CAB28[1];
      sub_10091260(a2 + 392, 4, (int)&v53, 2);
      goto LABEL_36;
    }
    if ( sub_1003AAE0(a3, (const void *)v4, 0) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[8];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[8];
      sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[8];
        v22 = word_101CAB28[15];
        v23 = LOWORD(v52) + 1;
        *(_WORD *)(a2 + 438) = LOWORD(v9) + 10;
        *(_WORD *)(a2 + 430) = v22;
        *(_WORD *)(a2 + 436) = v23;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1008F8E0(a2 + 392, v61, &v48, 0, 1, v46, v47);
      }
      *(_WORD *)(a2 + 426) = 1;
      *(_WORD *)(a2 + 424) = 1;
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      v24 = word_101CAB28[15];
      goto LABEL_35;
    }
    v25 = sub_1003AAE0(a3, (const void *)v4, 0);
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    if ( v25 == 2 )
    {
      *(_WORD *)(a2 + 430) = word_101CAB28[11];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[11];
      sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[11];
        v26 = word_101CAB28[1];
        v27 = LOWORD(v9) + 10;
        v28 = LOWORD(v52) + 1;
LABEL_33:
        *(_WORD *)(a2 + 438) = v27;
        *(_WORD *)(a2 + 430) = v26;
        *(_WORD *)(a2 + 436) = v28;
        v48 = *(_BYTE *)(v4 + 72);
        v49 = 0;
        sub_1008F8E0(a2 + 392, v61, &v48, 0, 1, v46, v47);
        goto LABEL_34;
      }
    }
    else
    {
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[15];
      sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
      if ( *(_DWORD *)(a3 + 4) & 0x100 )
      {
        *(_WORD *)(a2 + 428) = word_101CAB28[15];
        v26 = word_101CAB28[1];
        v27 = LOWORD(v9) + 6;
        v28 = LOWORD(v52) + 3;
        goto LABEL_33;
      }
    }
LABEL_34:
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_101CAB28[1];
    v24 = word_101CAB28[1];
LABEL_35:
    *(_WORD *)(a2 + 430) = v24;
    sub_10091260(a2 + 392, 4, (int)&v53, 2);
LABEL_36:
    *(_WORD *)(a2 + 424) = 2;
    *(_WORD *)(a2 + 426) = 2;
  }
  v29 = *(_DWORD *)(a3 + 4) & 0x18;
  if ( v29 != 8 && v29 != 16 || !*(_BYTE *)(v4 + 1) )
    goto LABEL_55;
  v30 = *a4 + *(_WORD *)(a3 + 8) + 4;
  LODWORD(v52) = (unsigned __int16)v50;
  v50 = v30;
  v31 = sub_10036B20((int)a4, a3, v4, v74);
  v32 = *(_DWORD *)(a3 + 4) & 0x18;
  v54 = v31;
  v56 = (signed __int16)v51 / 2 + v31;
  v58 = v31 - (signed __int16)v51 / 2;
  v60 = v31;
  if ( v32 == 16 )
  {
    v33 = LODWORD(v52) + v62 - 1;
    v34 = v50 + v62 - 1;
  }
  else
  {
    LOWORD(v33) = LOWORD(v52);
    LOWORD(v34) = v50;
  }
  v59 = v33;
  v53 = v33;
  v57 = v34;
  v55 = v34;
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  if ( sub_1003AAE0(a3, (const void *)v4, 1) == 3 )
  {
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    *(_WORD *)(a2 + 430) = word_101CAB28[8];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[8];
    sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[8];
      v35 = v50 - 5;
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      *(_WORD *)(a2 + 438) = v35;
      v36 = v61;
      *(_WORD *)(a2 + 436) = v31 + 4;
      v48 = *(_BYTE *)(v4 + 79);
      v49 = 0;
      sub_1008F8E0(a2 + 392, v36, &v48, 0, 1, v46, v47);
    }
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
    *(_WORD *)(a2 + 428) = word_101CAB28[15];
    v37 = word_101CAB28[15];
    goto LABEL_54;
  }
  v38 = sub_1003AAE0(a3, (const void *)v4, 1);
  *(_WORD *)(a2 + 428) = word_101CAB28[15];
  if ( v38 == 2 )
  {
    *(_WORD *)(a2 + 430) = word_101CAB28[11];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[11];
    sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v39 = word_101CAB28[11];
LABEL_52:
      *(_WORD *)(a2 + 428) = v39;
      v40 = v50 - 5;
      *(_WORD *)(a2 + 430) = word_101CAB28[1];
      *(_WORD *)(a2 + 438) = v40;
      v41 = v61;
      *(_WORD *)(a2 + 436) = v31 + 4;
      v42 = *(_BYTE *)(v4 + 79);
      v49 = 0;
      v48 = v42;
      sub_1008F8E0(a2 + 392, v41, &v48, 0, 1, v46, v47);
      goto LABEL_53;
    }
  }
  else
  {
    *(_WORD *)(a2 + 430) = word_101CAB28[15];
    *(_WORD *)(a2 + 440) = word_101CAB28[15];
    *(_WORD *)(a2 + 442) = word_101CAB28[15];
    sub_10090B70(a2 + 392, 3, (int)&v53, 56, (int)&v76);
    if ( *(_DWORD *)(a3 + 4) & 0x100 )
    {
      v39 = word_101CAB28[15];
      goto LABEL_52;
    }
  }
LABEL_53:
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 428) = word_101CAB28[1];
  v37 = word_101CAB28[1];
LABEL_54:
  *(_WORD *)(a2 + 430) = v37;
  sub_10091260(a2 + 392, 4, (int)&v53, 2);
  *(_WORD *)(a2 + 426) = 2;
  *(_WORD *)(a2 + 424) = 2;
  v9 = v52;
LABEL_55:
  if ( (*(_DWORD *)(a3 + 4) & 0x18) == 16 && *(_BYTE *)(v4 + 2) )
  {
    v50 = (unsigned __int16)(LOWORD(v9) + v62 - 3);
    v43 = 3 - v62 + LODWORD(v9);
    v44 = sub_10036B20((int)a4, a3, v4, v75);
    v66 = (signed __int16)v51 / 2 + v44 - 4;
    v64 = v44;
    v68 = v44;
    v72 = v44;
    v70 = v44 - (signed __int16)v51 / 2 + 4;
    v63 = v43;
    v71 = v43;
    v65 = ((signed __int16)v43 + (signed __int16)v50) / 2;
    v67 = v50;
    v69 = ((signed __int16)v43 + (signed __int16)v50) / 2;
    *(_WORD *)(a2 + 426) = 2;
    *(_WORD *)(a2 + 424) = 2;
    if ( sub_1003AAE0(a3, (const void *)v4, 2) == 3 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[8];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[8];
      sub_10091260(a2 + 392, 5, (int)&v63, 2);
      sub_10090B70(a2 + 392, 3, (int)&v63, 56, (int)&v76);
    }
    else if ( sub_1003AAE0(a3, (const void *)v4, 2) == 2 )
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[11];
      *(_WORD *)(a2 + 440) = word_101CAB28[15];
      *(_WORD *)(a2 + 442) = word_101CAB28[11];
      sub_10091260(a2 + 392, 5, (int)&v63, 2);
      sub_10090B70(a2 + 392, 3, (int)&v63, 56, (int)&v76);
    }
    else
    {
      *(_WORD *)(a2 + 428) = word_101CAB28[15];
      *(_WORD *)(a2 + 430) = word_101CAB28[15];
      sub_10091260(a2 + 392, 5, (int)&v63, 2);
    }
  }
  result = 1;
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  return result;
}
// 1008BA0E: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (100388E0) --------------------------------------------------------
char __cdecl sub_100388E0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@4
  int v9; // ecx@4
  char result; // al@4
  int v11; // [sp+Ch] [bp-4h]@1

  v5 = *(_DWORD *)(a2 + 4);
  v6 = *a3;
  v7 = *(_DWORD *)(a2 + 4) & 0x800;
  v11 = *a3;
  if ( v7 )
    HIWORD(v11) = HIWORD(v6) + 26;
  switch ( *a5 )
  {
    case 0x8041:
      v8 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v9 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v8;
      *(_DWORD *)(a4 + 68) = v9;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( v5 & 0x200 )
        sub_1003A640(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)&v11);
      sub_10036190((int)&v11, a2, a1);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_10036790(a1, a2, (int)&v11);
      sub_10036C30(a4, (int)&v11, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_100366D0(a2, (int)&v11, a1, a4, (int)a5);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10035D60(a1, a2, (int)a3, a4, a5);
      else
        sub_10036450((int)a5, (int)&v11, a2, a1, (const void *)a4);
      sub_10036A40((int)&v11, a1, a2, a4);
      if ( *(_DWORD *)(a2 + 4) & 0x200000 )
      {
        sub_10037D30(a4, a1, a2, (__int16 *)&v11);
        result = 1;
      }
      else
      {
        sub_10037190(a4, a1, a2, (int)&v11);
        result = 1;
      }
      break;
    case 0x8015:
    case 0x8016:
      if ( v7 != 2048 )
      {
        sub_10036450((int)a5, (int)&v11, a2, a1, (const void *)a4);
        goto LABEL_20;
      }
      sub_10035D60(a1, a2, (int)a3, a4, a5);
      result = 1;
      break;
    default:
LABEL_20:
      result = 1;
      break;
  }
  return result;
}

//----- (10038B10) --------------------------------------------------------
int __usercall sub_10038B10@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  _WORD *v5; // ebx@1
  double v6; // st7@1
  __int16 v7; // cx@1
  int v8; // ebp@1
  double v9; // ST34_8@3
  signed int v10; // eax@3
  signed int v11; // eax@3
  __int16 v12; // cx@3
  int result; // eax@4
  int v14; // ecx@6
  int v15; // eax@6
  int v16; // edx@6
  int v17; // ebx@6
  int v18; // ecx@6
  double v19; // st6@7
  __int16 *v20; // ecx@10
  __int16 v21; // ax@11
  double v22; // st6@25
  int v23; // ecx@26
  bool v24; // zf@27
  int v25; // ecx@31
  signed int v26; // ST3C_4@33
  int v27; // eax@33
  __int16 v28; // ax@36
  int v29; // ebx@39
  bool v30; // sf@39
  unsigned __int8 v31; // of@39
  int v32; // [sp+4h] [bp-20h]@4
  float v33; // [sp+8h] [bp-1Ch]@1
  int v34; // [sp+Ch] [bp-18h]@4
  signed int v35; // [sp+10h] [bp-14h]@26
  unsigned __int16 v36; // [sp+18h] [bp-Ch]@1
  int v37; // [sp+18h] [bp-Ch]@6
  __int16 v38; // [sp+1Ch] [bp-8h]@1
  __int16 v39; // [sp+20h] [bp-4h]@1
  int v40; // [sp+28h] [bp+4h]@5

  v5 = (_WORD *)a1;
  v33 = *(float *)(a3 + 12) - *(float *)(a3 + 8);
  v6 = v33;
  v36 = *(_WORD *)a1;
  v7 = *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1);
  v8 = a4;
  v39 = (*(_WORD *)(a2 + 12) - *(_BYTE *)a3 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (*(_BYTE *)(a3 + 1) * *(_BYTE *)a3);
  v38 = v7 + *(_WORD *)(a1 + 2) - 1;
  if ( *(_DWORD *)(a2 + 8) & 0x4000000 && 0.0 != v6 )
  {
    v9 = (double)(signed __int16)(v7 + *(_WORD *)(a1 + 2) - 1);
    v10 = (signed int)(v9 - (*(float *)(a3 + 16) - *(float *)(a3 + 8)) / v6 * (double)(signed __int16)(v7 - 1));
    *(_WORD *)(a4 + 428) = word_101CAB28[11];
    *(_WORD *)(a4 + 430) = word_101CAB28[11];
    *(_WORD *)(a4 + 438) = *v5;
    *(_WORD *)(a4 + 436) = v10;
    sub_10090620(a4 + 392, *v5 + *(_WORD *)(a2 + 12), v10, 2);
    v11 = (signed int)(v9
                     - (*(float *)(a3 + 20) - *(float *)(a3 + 8))
                     / v33
                     * (double)(signed __int16)(*(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) - 1));
    *(_WORD *)(a4 + 428) = word_101CAB28[8];
    *(_WORD *)(a4 + 430) = word_101CAB28[8];
    v12 = *v5;
    *(_WORD *)(a4 + 436) = v11;
    *(_WORD *)(a4 + 438) = v12;
    sub_10090620(a4 + 392, *v5 + *(_WORD *)(a2 + 12), v11, 2);
    v6 = v33;
  }
  *(_WORD *)(a4 + 440) = HIWORD(a5);
  *(_WORD *)(a4 + 442) = HIWORD(a5);
  *(_WORD *)(a4 + 428) = HIWORD(a5);
  *(_WORD *)(a4 + 430) = HIWORD(a5);
  result = v36;
  v32 = v36;
  v34 = 0;
  if ( *(_BYTE *)a3 )
  {
    while ( 1 )
    {
      v40 = 0;
      if ( *(_BYTE *)(a3 + 1) )
        break;
LABEL_39:
      v29 = *(_BYTE *)a3;
      result = v34 + 1;
      v31 = __OFSUB__(v34 + 1, v29);
      v30 = v34 + 1 - v29 < 0;
      v32 += (*(_WORD *)(a2 + 12) - v29 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (v29 * *(_BYTE *)(a3 + 1)) + 5;
      ++v34;
      if ( !(v30 ^ v31) )
        return result;
    }
    while ( 1 )
    {
      v14 = *(_BYTE *)a3;
      v37 = (unsigned __int16)(v38 - *(_WORD *)(a2 + 14));
      v15 = (*(_WORD *)(a2 + 12) - v14 * (2 * *(_BYTE *)(a3 + 1) + 3) + 5) / (v14 * *(_BYTE *)(a3 + 1));
      v16 = v40;
      v17 = v34;
      v18 = v34 + v40 * v14;
      v32 += v40 * (v15 + 2);
      if ( *(_BYTE *)(v18 + *(_DWORD *)(a3 + 4)) )
        break;
LABEL_38:
      v40 = v16 + 1;
      if ( v16 + 1 >= *(_BYTE *)(a3 + 1) )
        goto LABEL_39;
    }
    v19 = *(float *)(*(_DWORD *)(a3 + 28) + 4 * v18);
    if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) || *(float *)(a3 + 16) < v19 && *(_DWORD *)(a2 + 8) & 0x4000000 )
    {
      if ( *(float *)(a3 + 16) < v19 && *(float *)(a3 + 20) >= v19 && *(_DWORD *)(a2 + 8) & 0x4000000 )
      {
        *(_WORD *)(v8 + 440) = word_101CAB28[11];
        *(_WORD *)(v8 + 442) = word_101CAB28[11];
        v20 = word_101CAB28;
        if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) )
        {
          *(_WORD *)(v8 + 428) = word_101CAB28[11];
          v21 = word_101CAB28[11];
          goto LABEL_22;
        }
      }
      else
      {
        if ( *(float *)(a3 + 20) >= v19 || !(*(_DWORD *)(a2 + 8) & 0x4000000) )
        {
          v21 = HIWORD(a5);
          *(_WORD *)(v8 + 440) = HIWORD(a5);
          *(_WORD *)(v8 + 442) = HIWORD(a5);
          *(_WORD *)(v8 + 428) = HIWORD(a5);
          goto LABEL_22;
        }
        *(_WORD *)(v8 + 440) = word_101CAB28[8];
        *(_WORD *)(v8 + 442) = word_101CAB28[8];
        v20 = word_101CAB28;
        if ( v34 != *(_BYTE *)(*(_DWORD *)(a3 + 44) + v40) )
        {
          *(_WORD *)(v8 + 428) = word_101CAB28[8];
          v21 = word_101CAB28[8];
          goto LABEL_22;
        }
      }
    }
    else
    {
      *(_WORD *)(v8 + 440) = word_101CAB28[6];
      *(_WORD *)(v8 + 442) = word_101CAB28[6];
      v20 = word_101CAB28;
    }
    *(_WORD *)(v8 + 428) = v20[6];
    v21 = word_101CAB28[6];
LABEL_22:
    *(_WORD *)(v8 + 430) = v21;
    if ( *(float *)(a3 + 12) < v19 )
      v19 = *(float *)(a3 + 12);
    if ( 0.0 != v6 )
    {
      v22 = (v19 - *(float *)(a3 + 8)) / v6 * (double)*(_BYTE *)(a2 + 16) + 0.5;
      if ( (signed int)v22 > 0 )
      {
        LOWORD(v23) = *(_WORD *)(a2 + 14);
        v35 = (signed int)v22;
        do
        {
          sub_100903C0(v8 + 392, v32, v37, v39, v23, 1);
          v23 = *(_WORD *)(a2 + 14);
          v24 = v35-- == 1;
          v37 += -1 - v23;
        }
        while ( !v24 );
        v6 = v33;
        v17 = v34;
      }
      v16 = v40;
    }
    if ( *(_DWORD *)(a2 + 8) & 0x8000000 )
    {
      v25 = v16 * *(_BYTE *)(a3 + 1);
      if ( *(_BYTE *)(v25 + *(_DWORD *)(a3 + 40) + v17) )
      {
        if ( 0.0 != v6 )
        {
          v26 = *(_BYTE *)(a2 + 16);
          v27 = (signed int)((*(float *)(*(_DWORD *)(a3 + 36) + 4 * (v17 + v25)) - *(float *)(a3 + 8))
                           / v6
                           * (double)v26
                           + 0.5
                           - 1.0);
          if ( v27 >= v26 )
            v27 = *(_BYTE *)(a2 + 16) - 1;
          if ( v27 >= 0 )
          {
            v28 = v38 - v27 * (*(_WORD *)(a2 + 14) + 1) - *(_WORD *)(a2 + 14);
            *(_WORD *)(v8 + 440) = word_101CAB28[1];
            *(_WORD *)(v8 + 442) = word_101CAB28[1];
            sub_100903C0(v8 + 392, v32, v28, v39, *(_WORD *)(a2 + 14), 1);
            v6 = v33;
          }
          v16 = v40;
        }
      }
    }
    goto LABEL_38;
  }
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10039060) --------------------------------------------------------
char __usercall sub_10039060@<al>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ST14_2@1
  int v7; // eax@1
  unsigned int v8; // ST08_4@1
  char *v9; // eax@1
  int v10; // ST04_4@1
  signed int v11; // eax@1
  unsigned __int8 v12; // bl@1
  int v13; // ecx@1
  int v14; // eax@1
  __int16 v15; // bp@1
  int v16; // ecx@1
  __int16 v17; // ax@1
  signed int v18; // ebx@1
  _BYTE *v19; // ecx@3
  char v21; // [sp+Ch] [bp-20h]@3
  char v22; // [sp+Dh] [bp-1Fh]@1
  int v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@1
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+1Ch] [bp-10h]@1
  __int16 v27; // [sp+20h] [bp-Ch]@1
  int v28; // [sp+22h] [bp-Ah]@5
  int v29; // [sp+28h] [bp-4h]@1
  int v30; // [sp+34h] [bp+8h]@1

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  v22 = 0;
  v25 = sub_1004AB90(v6);
  v7 = sub_1004B470((*(_DWORD *)(v5 + 4) >> 10) & 0xF, 0);
  v8 = *(_DWORD *)(v5 + 4);
  v23 = v7;
  v9 = sub_1004AB50(v8);
  v10 = *(_DWORD *)(v5 + 4);
  v24 = *((_DWORD *)v9 + 1);
  v26 = BYTE2(v23);
  v27 = 0;
  v11 = sub_1004ABC0(v10);
  v12 = *(_BYTE *)(a2 + 1);
  v13 = *(_BYTE *)a2;
  v29 = v11;
  v14 = (unsigned __int16)(v12 * ((unsigned int)((*(_WORD *)(v5 + 12) - v13 * (2 * v12 + 3) + 5) / (v12 * v13)) + 2) - 2);
  v23 = v14;
  v15 = *(_WORD *)a4 + (signed __int16)v14 / 2;
  v16 = *((_DWORD *)sub_1004AB50(*(_DWORD *)(v5 + 8)) + 1);
  v17 = *(_BYTE *)(v5 + 16);
  v18 = 0;
  v30 = (unsigned __int16)(*(_WORD *)(a4 + 2) + *(_WORD *)(v16 + 22) + v17 * (*(_WORD *)(v5 + 14) + 1) + 2);
  if ( *(_BYTE *)a2 )
  {
    v23 += 5;
    do
    {
      v19 = *(_BYTE **)(a2 + 44);
      v21 = v18 + 49;
      if ( v18 != *v19 || *(_BYTE *)(a2 + 1) != 1 )
      {
        v28 = a5;
      }
      else
      {
        HIWORD(v28) = word_101CAB28[6];
        LOWORD(v28) = a5;
      }
      *(_WORD *)(a3 + 438) = v15;
      *(_WORD *)(a3 + 436) = v30;
      LOBYTE(v17) = sub_1004B430(a3, &v21, &v24);
      v15 += v23;
      ++v18;
    }
    while ( v18 < *(_BYTE *)a2 );
  }
  return v17;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (100391D0) --------------------------------------------------------
int __usercall sub_100391D0@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4)
{
  __int16 v4; // cx@1
  int result; // eax@1
  int v6; // esi@1
  __int16 v7; // dx@1
  __int16 v8; // dx@1
  int v9; // ebp@1
  bool v10; // zf@1
  signed int v11; // ebx@2
  int v12; // ecx@3
  int v13; // eax@3
  int v14; // ecx@3
  int v15; // ebx@7
  int v16; // [sp+8h] [bp-8h]@1
  __int16 v17; // [sp+Ch] [bp-4h]@3
  __int16 v18; // [sp+Eh] [bp-2h]@1

  v4 = *(_WORD *)a1;
  result = *(_WORD *)(a1 + 2);
  v6 = a4;
  v7 = *(_WORD *)(a4 + 14);
  LOWORD(v16) = v4;
  v8 = result + *(_BYTE *)(a4 + 16) * (v7 + 1) - 1;
  v9 = 0;
  v10 = *(_BYTE *)a2 == 0;
  HIWORD(v16) = result;
  v18 = v8;
  if ( !v10 )
  {
    do
    {
      v11 = 0;
      if ( *(_BYTE *)(a2 + 1) )
      {
        do
        {
          v12 = *(_BYTE *)a2;
          v13 = (*(_WORD *)(a4 + 12) - v12 * (2 * *(_BYTE *)(a2 + 1) + 3) + 5) / (v12 * *(_BYTE *)(a2 + 1));
          v14 = *(_DWORD *)(a2 + 4) + v11 * v12;
          LOWORD(v16) = v11 * (v13 + 2) + v16;
          v17 = v16 + v13;
          if ( !*(_BYTE *)(v14 + v9) )
            sub_1004B2B0(a3, (int)&v16, (int)&v17, 0);
          ++v11;
        }
        while ( v11 < *(_BYTE *)(a2 + 1) );
        v6 = a4;
      }
      v15 = *(_BYTE *)a2;
      ++v9;
      result = (*(_WORD *)(v6 + 12) - v15 * (2 * *(_BYTE *)(a2 + 1) + 3) + 5) / (v15 * *(_BYTE *)(a2 + 1)) + 5;
      LOWORD(v16) = result + v16;
    }
    while ( v9 < v15 );
  }
  return result;
}

//----- (100392D0) --------------------------------------------------------
char __cdecl sub_100392D0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // eax@4
  int v6; // esi@4
  unsigned int v7; // eax@4
  char *v8; // eax@5
  int v9; // edi@5
  unsigned __int8 v10; // bl@6
  int v11; // eax@7
  int v12; // ecx@7

  if ( *a5 == 32802 )
  {
LABEL_4:
    v5 = sub_1004AB20(*(_DWORD *)(a2 + 4));
    v6 = v5;
    *(_WORD *)(a1 + 440) = v5;
    *(_WORD *)(a1 + 442) = v5;
    v7 = *(_DWORD *)(a2 + 8);
    if ( v7 & 0x2000000 )
    {
      v8 = sub_1004AB50(v7);
      v9 = a3;
      sub_100916F0(
        a1 + 392,
        *(_WORD *)a3,
        *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 12),
        *(_WORD *)(*((_DWORD *)v8 + 1) + 22) + *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) + 2);
    }
    else
    {
      sub_100916F0(
        a1 + 392,
        *(_WORD *)a3,
        *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 12),
        *(_BYTE *)(a2 + 16) * (*(_WORD *)(a2 + 14) + 1) - 1);
      v9 = a3;
    }
    sub_10038B10(v9, a2, a4, a1, v6);
    if ( *(_DWORD *)(a2 + 8) & 0x2000000 )
      sub_10039060(a2, a4, a1, a3, v6);
    if ( *(_DWORD *)(a2 + 8) & 0x10000000 )
      sub_100391D0(a3, a4, a1, a2);
    return 1;
  }
  if ( *a5 != 32833 )
  {
    if ( *a5 == 32888 )
      goto LABEL_4;
    return 1;
  }
  v10 = *(_BYTE *)a4 * *(_BYTE *)(a4 + 1);
  *(_DWORD *)(a4 + 28) = sub_100027C0(a1, 4 * v10);
  if ( !v10 )
    return 1;
  v11 = 0;
  v12 = v10;
  do
  {
    *(float *)(v11 + *(_DWORD *)(a4 + 28)) = *(float *)(v11 + *(_DWORD *)(a4 + 32));
    v11 += 4;
    --v12;
  }
  while ( v12 );
  return 1;
}

//----- (10039450) --------------------------------------------------------
__int16 __usercall sub_10039450@<ax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4)
{
  int v4; // eax@1
  __int16 result; // ax@3

  v4 = *(_WORD *)(a3 + 8) / 2;
  if ( v4 >= *(_WORD *)(a3 + 10) / 2 )
    LOWORD(v4) = *(_WORD *)(a3 + 10) / 2;
  *a4 = v4;
  *(_WORD *)a2 = *(_WORD *)a1 + *(_WORD *)(a3 + 8) / 2;
  result = *(_WORD *)(a1 + 2) + *(_WORD *)(a3 + 10) / 2;
  *(_WORD *)(a2 + 2) = result;
  return result;
}

//----- (100394A0) --------------------------------------------------------
signed __int16 __usercall sub_100394A0@<ax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5)
{
  signed __int16 result; // ax@1
  __int16 v6; // di@2
  __int16 v7; // bx@2
  __int16 v8; // ST28_2@2
  signed int v9; // eax@2
  int v10; // [sp+14h] [bp-2Ch]@2
  int v11; // [sp+18h] [bp-28h]@2
  double v12; // [sp+20h] [bp-20h]@2
  double v13; // [sp+28h] [bp-18h]@2
  double v14; // [sp+30h] [bp-10h]@2
  long double v15; // [sp+38h] [bp-8h]@2

  result = a5;
  if ( a4 != a5 )
  {
    sub_10039450(a1, (int)&v11, a3, &v10);
    v6 = v10;
    v7 = v11;
    v15 = (double)a4 * 0.01745329251994333;
    v12 = (double)(signed __int16)v10;
    v13 = (double)(signed __int16)v11;
    v8 = (signed int)(cos(v15) * v12 + v13);
    v14 = (double)SHIWORD(v11);
    v9 = (signed int)(v14 - sin(v15) * v12);
    v10 = a5;
    *(_WORD *)(a2 + 426) = 3;
    *(_WORD *)(a2 + 424) = 3;
    *(_WORD *)(a2 + 396) = 2;
    *(_WORD *)(a2 + 438) = v8;
    *(_WORD *)(a2 + 436) = v9;
    v15 = (double)a5 * 0.01745329251994333;
    sub_100917E0(
      a2 + 392,
      v7,
      SHIWORD(v11),
      v6,
      1,
      (signed int)(cos(v15) * v12 + v13),
      (signed int)(v14 - sin(v15) * v12));
    result = 1;
    *(_WORD *)(a2 + 426) = 1;
    *(_WORD *)(a2 + 424) = 1;
  }
  return result;
}

//----- (10039600) --------------------------------------------------------
int __usercall sub_10039600@<eax>(int a1@<edx>, int a2, int a3, __int16 a4, __int16 a5)
{
  int v5; // eax@1
  double v6; // st7@2
  bool v7; // sf@4
  unsigned __int8 v8; // of@4
  long double v9; // st7@11
  double v10; // st6@11
  signed int v11; // eax@11
  double v12; // st5@11
  long double v13; // st4@11
  int result; // eax@13
  __int16 v15; // [sp+Ch] [bp-3Ch]@1
  double v16; // [sp+10h] [bp-38h]@2
  int v17; // [sp+18h] [bp-30h]@1
  __int16 v18; // [sp+1Ch] [bp-2Ch]@1
  __int16 v19; // [sp+1Eh] [bp-2Ah]@11
  int v20; // [sp+20h] [bp-28h]@11
  long double v21; // [sp+28h] [bp-20h]@11
  double v22; // [sp+30h] [bp-18h]@11
  long double v23; // [sp+38h] [bp-10h]@11
  double v24; // [sp+40h] [bp-8h]@11

  *(_WORD *)(a2 + 396) = 2;
  *(_WORD *)(a2 + 426) = 3;
  *(_WORD *)(a2 + 424) = 3;
  sub_10039450(a1, (int)&v18, a3, &v15);
  v5 = *(_BYTE *)(a3 + 12);
  v17 = 0;
  if ( v5 > 0 )
  {
    while ( 1 )
    {
      *(float *)&v16 = 210.0 - (double)v17 * 225.0 / (double)(v5 - 1);
      v6 = *(float *)&v16;
      if ( *(float *)&v16 < 0.0 )
      {
        *(float *)&v16 = v6 + 360.0;
        v6 = *(float *)&v16;
      }
      v8 = __OFSUB__(a4, a5);
      v7 = (signed __int16)(a4 - a5) < 0;
      if ( a4 <= a5 )
        goto LABEL_8;
      LODWORD(v16) = a4;
      if ( (double)a4 < v6 )
        break;
      LODWORD(v16) = a5;
      if ( (double)a5 > v6 )
        break;
LABEL_11:
      v21 = v6 * 0.01745329251994333;
      v23 = cos(v21);
      v22 = (double)v15;
      v24 = (double)v18;
      v16 = (double)v19;
      v9 = sin(v21);
      v10 = v16;
      v11 = (signed int)(v16 - v22 * v9);
      LODWORD(v16) = v15 - 7;
      v12 = (double)SLODWORD(v16);
      *(_WORD *)(a2 + 438) = (signed int)(v23 * v22 + v24);
      v13 = v23;
      *(_WORD *)(a2 + 436) = v11;
      LOWORD(v20) = (signed int)(v13 * v12 + v24);
      HIWORD(v20) = (signed int)(v10 - v9 * v12);
      sub_10090620(a2 + 392, v20, SHIWORD(v20), 0);
LABEL_12:
      v5 = *(_BYTE *)(a3 + 12);
      if ( ++v17 >= v5 )
        goto LABEL_13;
    }
    v8 = __OFSUB__(a4, a5);
    v7 = (signed __int16)(a4 - a5) < 0;
LABEL_8:
    if ( !(v7 ^ v8) )
      goto LABEL_12;
    LODWORD(v16) = a4;
    if ( (double)a4 < v6 )
    {
      LODWORD(v16) = a5;
      if ( (double)a5 > v6 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_13:
  result = a2;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 426) = 1;
  return result;
}

//----- (10039810) --------------------------------------------------------
signed __int16 __usercall sub_10039810@<ax>(int a1@<eax>, int a2, int a3)
{
  *(_WORD *)(a1 + 394) = 1;
  *(_WORD *)(a1 + 428) = word_101CAB28[15];
  *(_WORD *)(a1 + 430) = word_101CAB28[15];
  return sub_100394A0(a3, a1, a2, 210, 345);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10039860) --------------------------------------------------------
char __usercall sub_10039860@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4, const void *a5)
{
  int v5; // eax@1
  char v6; // al@2
  char v7; // bl@4
  int v8; // edi@5
  int v9; // eax@9
  char *v10; // edi@11
  char v11; // al@12
  int v12; // ecx@20
  char *v13; // eax@20
  char v14; // cl@21
  int v16; // [sp+Ch] [bp-38h]@20
  int v17; // [sp+10h] [bp-34h]@5
  int v18; // [sp+14h] [bp-30h]@22
  int v19; // [sp+18h] [bp-2Ch]@17
  __int16 v20; // [sp+1Ch] [bp-28h]@22
  __int16 v21; // [sp+1Eh] [bp-26h]@22
  int v22; // [sp+20h] [bp-24h]@1
  int v23; // [sp+24h] [bp-20h]@1
  int v24; // [sp+28h] [bp-1Ch]@1
  char v25[20]; // [sp+2Ch] [bp-18h]@10
  char v26[20]; // [sp+2Dh] [bp-17h]@22

  v24 = a4;
  v5 = *(_DWORD *)(a3 + 4) & 0x18;
  v23 = a2;
  v22 = a1;
  if ( v5 == 16 )
    v6 = 3;
  else
    v6 = (v5 == 8) + 1;
  v7 = 0;
  if ( v6 )
  {
    v8 = 0;
    v17 = (unsigned __int8)v6;
    do
    {
      if ( (unsigned __int8)sub_1003AAE0(a3, a5, v8) > (unsigned __int8)v7 )
        v7 = sub_1003AAE0(a3, a5, v8);
      ++v8;
      --v17;
    }
    while ( v17 );
  }
  v9 = *(_DWORD *)(a3 + 4);
  if ( ~(unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7) & 1 )
  {
    sub_1003A690(a3, (int)a5, v25);
    if ( *(_DWORD *)(a3 + 4) & 0x1000 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 32;
      sub_1003AE60(*(_BYTE *)(a3 + 13), &v25[strlen(v25)]);
    }
  }
  else
  {
    if ( !(v9 & 0x1000) )
      return v9;
    sub_1003AE60(*(_BYTE *)(a3 + 13), v25);
  }
  switch ( v7 )
  {
    case 3:
      v19 = byte_102BA90E != 0 ? 35087 : 35304;
      break;
    case 2:
      v19 = 35169;
      break;
    default:
      v19 = 35215;
      break;
  }
  v12 = *(_WORD *)(a3 + 10);
  LOWORD(v16) = *(_WORD *)v23 + *(_WORD *)(a3 + 8) / 2;
  HIWORD(v16) = *(_WORD *)(v23 + 2)
              + 2
              * (((unsigned __int64)(1431655766i64 * v12) >> 32)
               + ((unsigned int)((unsigned __int64)(1431655766i64 * v12) >> 32) >> 31));
  v13 = v25;
  do
    v14 = *v13++;
  while ( v14 );
  v21 = (_WORD)v13 - (unsigned int)v26;
  v18 = 105;
  v20 = 0;
  LOBYTE(v9) = sub_1003F3B0(v24, (int)&v18, (int)&v16, v25, v22);
  return v9;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10039860: using guessed type char var_18[20];

//----- (10039A40) --------------------------------------------------------
char __usercall sub_10039A40@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@1
  __int16 v7; // dx@1
  __int16 v8; // cx@1
  __int16 v10; // [sp+Ch] [bp-38h]@1
  __int16 v11; // [sp+Eh] [bp-36h]@1
  __int16 v12; // [sp+10h] [bp-34h]@1
  __int16 v13; // [sp+12h] [bp-32h]@1
  float v14; // [sp+14h] [bp-30h]@1
  float v15; // [sp+18h] [bp-2Ch]@1
  int v16; // [sp+1Ch] [bp-28h]@1
  char v17; // [sp+20h] [bp-24h]@1
  char v18; // [sp+30h] [bp-14h]@1

  v5 = a2;
  v6 = a1;
  v16 = a5;
  sub_1003AA80(*(_BYTE *)(a2 + 13), (int)&v17, (int)&v18);
  v7 = *(_WORD *)(v5 + 8);
  v8 = *(_WORD *)v6;
  v15 = *(float *)(a4 + 8);
  LOWORD(v5) = *(_WORD *)(v5 + 10);
  v14 = *(float *)(a4 + 4);
  LOWORD(v6) = *(_WORD *)(v6 + 2);
  v12 = v8 + v7 + 11;
  v10 = v8 - 7;
  v13 = (signed __int16)v5 / 2 + v6 + 28;
  v11 = v6 + v5 - 21;
  sub_10040B30(a3, (int)&v17, (int *)&v10, &v14, a5);
  return sub_10040B30(a3, (int)&v18, (int *)&v12, &v15, a5);
}

//----- (10039B10) --------------------------------------------------------
char __usercall sub_10039B10@<al>(int a1@<edx>, int a2@<ecx>, int a3, const void *a4, int a5)
{
  int v5; // eax@1
  int v6; // ebx@2
  int v7; // edi@5
  char *v8; // esi@5
  int v9; // ebp@5
  __int16 v10; // ax@12
  __int16 v11; // ax@12
  int v12; // esi@13
  char *v13; // edi@13
  float *v14; // ebp@13
  double v15; // st7@17
  int v17; // [sp+10h] [bp-60h]@1
  int v18; // [sp+1Ch] [bp-54h]@1
  __int16 v19; // [sp+24h] [bp-4Ch]@12
  __int16 v20; // [sp+26h] [bp-4Ah]@12
  float v21[3]; // [sp+30h] [bp-40h]@19
  char v22; // [sp+3Ch] [bp-34h]@13
  char v23; // [sp+40h] [bp-30h]@5

  v18 = a1;
  v5 = *(_DWORD *)(a2 + 4) & 0x18;
  v17 = a2;
  if ( v5 == 16 )
    LOBYTE(v6) = 3;
  else
    LOBYTE(v6) = (v5 == 8) + 1;
  if ( (_BYTE)v6 )
  {
    v7 = 0;
    v8 = &v23;
    v9 = (unsigned __int8)v6;
    do
    {
      sub_1003ADC0(*(_BYTE *)(a2 + 13), (int)(v8 - 4));
      if ( *((_BYTE *)a4 + v7) )
      {
        switch ( sub_1003AAE0(v17, a4, v7) )
        {
          case 3:
            *(_DWORD *)v8 = byte_102BA90E != 0 ? 40207 : 40424;
            break;
          case 2:
            *(_DWORD *)v8 = 40289;
            break;
          default:
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        *(_DWORD *)v8 = 40335;
      }
      a2 = v17;
      ++v7;
      v8 += 16;
      --v9;
    }
    while ( v9 );
  }
  v10 = *(_WORD *)(a2 + 10) + *(_WORD *)(v18 + 2);
  v19 = *(_WORD *)v18 + *(_WORD *)(a2 + 8) / 2;
  v11 = v10 - 17;
  v20 = v11;
  if ( (_BYTE)v6 )
  {
    v12 = 0;
    v13 = &v22;
    v14 = (float *)((char *)a4 + 60);
    v6 = (unsigned __int8)v6;
    while ( 1 )
    {
      v15 = *((_BYTE *)a4 + v12) && sub_1003AAE0(a2, a4, v12) ? *v14 : 9.8999998e24;
      v21[v12] = v15;
      LOBYTE(v11) = sub_10040B30(a3, (int)v13, (int *)&v19 + v12, &v21[v12], a5);
      ++v12;
      ++v14;
      v13 += 16;
      if ( !--v6 )
        break;
      a2 = v17;
    }
  }
  return v11;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 10039B10: using guessed type float var_40[3];

//----- (10039C90) --------------------------------------------------------
int __usercall sub_10039C90@<eax>(int result@<eax>, int a2@<ecx>, int a3)
{
  if ( *(_BYTE *)(a2 + 12) > 1u )
  {
    *(_WORD *)(result + 428) = word_101CAB28[15];
    *(_WORD *)(result + 430) = word_101CAB28[15];
    result = sub_10039600(a3, result, a2, 210, 345);
  }
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10039CE0) --------------------------------------------------------
int __usercall sub_10039CE0@<eax>(int *a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // eax@1
  __int16 v4; // dx@1
  __int16 v6; // [sp+0h] [bp-8h]@1
  __int16 v7; // [sp+2h] [bp-6h]@1
  int v8; // [sp+4h] [bp-4h]@1

  v3 = *a1;
  v4 = v3 + *(_WORD *)(a2 + 8);
  v8 = v3;
  v7 = *(_WORD *)(a2 + 10) + HIWORD(v3);
  v6 = v4;
  return sub_1004B2B0(a3, (int)&v8, (int)&v6, 0);
}

//----- (10039D20) --------------------------------------------------------
double __cdecl sub_10039D20(float a1)
{
  int v1; // ecx@0
  double result; // st7@2
  float v3; // ST00_4@3
  float v4; // ST00_4@3
  float v5; // ST00_4@4

  if ( *(float *)(v1 + 8) - *(float *)(v1 + 4) == 0.0 )
  {
    result = (float)210.0;
  }
  else
  {
    v3 = (a1 - *(float *)(v1 + 4)) / (*(float *)(v1 + 8) - *(float *)(v1 + 4));
    v4 = 210.0 - v3 * 225.0;
    result = v4;
    if ( v4 < 0.0 )
    {
      v5 = result + 360.0;
      result = v5;
    }
  }
  return result;
}

//----- (10039D90) --------------------------------------------------------
signed int __cdecl sub_10039D90(int a1, int a2, int a3, int a4)
{
  float *v4; // edx@1
  float *v5; // ecx@1
  signed int v6; // esi@1
  double v7; // st7@3
  char v8; // al@8
  __int16 v9; // cx@13
  long double v10; // st7@13
  __int16 v11; // di@13
  int v12; // esi@13
  double v13; // st7@13
  double v14; // st7@13
  signed int result; // eax@13
  double v16; // [sp+14h] [bp-60h]@13
  int v17; // [sp+1Ch] [bp-58h]@13
  double v18; // [sp+24h] [bp-50h]@13
  int v19; // [sp+30h] [bp-44h]@13
  long double v20; // [sp+34h] [bp-40h]@13
  double v21; // [sp+3Ch] [bp-38h]@13
  long double v22; // [sp+44h] [bp-30h]@13
  long double v23; // [sp+4Ch] [bp-28h]@1
  int v24; // [sp+60h] [bp-14h]@13
  int v25; // [sp+64h] [bp-10h]@13
  __int16 v26; // [sp+68h] [bp-Ch]@13
  __int16 v27; // [sp+6Ah] [bp-Ah]@13
  __int16 v28; // [sp+6Ch] [bp-8h]@13
  __int16 v29; // [sp+6Eh] [bp-6h]@13
  int v30; // [sp+70h] [bp-4h]@13

  *(_WORD *)(a1 + 396) = 2;
  v4 = (float *)&v23;
  v5 = (float *)(a4 + 48);
  v6 = 3;
  do
  {
    if ( *(float *)(a4 + 8) >= (double)*v5 )
    {
      if ( *(float *)(a4 + 4) <= (double)*v5 )
        v7 = *v5;
      else
        v7 = *(float *)(a4 + 4);
    }
    else
    {
      v7 = *(float *)(a4 + 8);
    }
    *v4 = v7;
    ++v5;
    ++v4;
    --v6;
  }
  while ( v6 );
  v8 = sub_1003AAE0(a2, (const void *)a4, 0);
  *(_WORD *)(a1 + 426) = 3;
  *(_WORD *)(a1 + 424) = 3;
  if ( v8 == 3 )
  {
    *(_WORD *)(a1 + 428) = word_101CAB28[15];
    *(_WORD *)(a1 + 430) = word_101CAB28[8];
  }
  else if ( v8 == 2 )
  {
    *(_WORD *)(a1 + 428) = word_101CAB28[15];
    *(_WORD *)(a1 + 430) = word_101CAB28[11];
  }
  else
  {
    *(_WORD *)(a1 + 428) = word_101CAB28[15];
    *(_WORD *)(a1 + 430) = word_101CAB28[15];
  }
  sub_10039450(a3, (int)&v17, a2, &v16);
  *(float *)&v18 = sub_10039D20(*(float *)&v23);
  v9 = HIWORD(v17);
  v10 = *(float *)&v18 * 0.01745329251994333;
  v11 = v17;
  v22 = v10;
  *(_WORD *)(a1 + 438) = v17;
  *(_WORD *)(a1 + 436) = v9;
  v12 = SLOWORD(v16);
  v20 = cos(v10);
  v23 = (double)(SLOWORD(v16) - 16);
  v19 = SLOWORD(v16);
  v21 = (double)v11;
  v17 = SHIWORD(v17);
  LOWORD(v24) = (signed int)(v20 * v23 + v21);
  v16 = (double)v17;
  v22 = sin(v22);
  HIWORD(v24) = (signed int)(v16 - v22 * v23);
  sub_10090620(a1 + 392, v24, SHIWORD(v24), 0);
  v13 = (double)(v12 - 8);
  LOWORD(v17) = (signed int)(v20 * v13 + v21);
  HIWORD(v17) = (signed int)(v16 - v13 * v22);
  v23 = (*(float *)&v18 + 90.0) * 0.01745329251994333;
  LOWORD(v25) = (signed int)(cos(v23) * 4.0 + (double)(signed __int16)v17);
  v18 = (double)SHIWORD(v17);
  v14 = (double)v19;
  HIWORD(v25) = (signed int)(v18 - sin(v23) * 4.0);
  v26 = (signed int)(v20 * v14 + v21);
  v27 = (signed int)(v16 - v14 * v22);
  v29 = 2 * HIWORD(v17) - HIWORD(v25);
  v28 = 2 * v17 - v25;
  v30 = v24;
  sub_10091260(a1 + 392, 5, (int)&v24, 2);
  result = 1;
  *(_WORD *)(a1 + 426) = 1;
  *(_WORD *)(a1 + 424) = 1;
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003A080) --------------------------------------------------------
signed int __usercall sub_1003A080@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4)
{
  int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // eax@1
  __int16 v7; // ST2C_2@3
  signed int v8; // eax@3
  __int16 v9; // cx@3
  signed int v10; // eax@6
  __int16 v11; // ST2C_2@6
  signed int v12; // eax@7
  __int16 v13; // di@7
  signed int result; // eax@7
  __int16 v15; // [sp+Ch] [bp-4h]@1
  __int16 v16; // [sp+Ch] [bp-4h]@3
  int v17; // [sp+14h] [bp+4h]@1
  int v18; // [sp+14h] [bp+4h]@3
  int v19; // [sp+14h] [bp+4h]@3
  int v20; // [sp+14h] [bp+4h]@6
  int v21; // [sp+14h] [bp+4h]@7

  v4 = a4;
  v5 = a1;
  v17 = (unsigned __int16)(signed int)sub_10039D20(*(float *)(a1 + 16));
  v6 = (signed int)sub_10039D20(*(float *)(v5 + 20));
  *(_WORD *)(a3 + 440) = word_101CAB28[11];
  *(_WORD *)(a3 + 442) = word_101CAB28[11];
  *(_WORD *)(a3 + 428) = word_101CAB28[11];
  *(_WORD *)(a3 + 430) = word_101CAB28[11];
  v15 = v6;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_100394A0(a2, a3, v4, v17, v6);
    sub_10039600(a2, a3, v4, v17, v15);
  }
  v7 = v17;
  v8 = (signed int)sub_10039D20(*(float *)(v5 + 12));
  *(_WORD *)(a3 + 440) = word_101CAB28[8];
  *(_WORD *)(a3 + 442) = word_101CAB28[8];
  *(_WORD *)(a3 + 428) = word_101CAB28[8];
  *(_WORD *)(a3 + 430) = word_101CAB28[8];
  v18 = (unsigned __int16)v8;
  sub_100394A0(a2, a3, v4, v8, v7);
  sub_10039600(a2, a3, v4, v18, v7);
  v19 = (unsigned __int16)(signed int)sub_10039D20(*(float *)(v5 + 24));
  v9 = (signed int)sub_10039D20(*(float *)(v5 + 28));
  *(_WORD *)(a3 + 440) = word_101CAB28[11];
  *(_WORD *)(a3 + 442) = word_101CAB28[11];
  *(_WORD *)(a3 + 428) = word_101CAB28[11];
  *(_WORD *)(a3 + 430) = word_101CAB28[11];
  v16 = v9;
  if ( ~(unsigned __int8)(*(_DWORD *)(v4 + 4) >> 13) & 1 )
  {
    sub_100394A0(a2, a3, v4, v19, v9);
    sub_10039600(a2, a3, v4, v19, v16);
    v9 = v16;
  }
  if ( *(float *)(v5 + 8) > (double)*(float *)(v5 + 28) )
  {
    v20 = (unsigned __int16)v9;
    v10 = (signed int)sub_10039D20(*(float *)(v5 + 32));
    *(_WORD *)(a3 + 440) = word_101CAB28[8];
    *(_WORD *)(a3 + 442) = word_101CAB28[8];
    *(_WORD *)(a3 + 428) = word_101CAB28[8];
    v11 = v10;
    *(_WORD *)(a3 + 430) = word_101CAB28[8];
    sub_100394A0(a2, a3, v4, v20, v10);
    sub_10039600(a2, a3, v4, v20, v11);
  }
  v21 = (unsigned __int16)(signed int)sub_10039D20(*(float *)(v5 + 20));
  v12 = (signed int)sub_10039D20(*(float *)(v5 + 24));
  *(_WORD *)(a3 + 440) = word_101CAB28[4];
  v13 = v12;
  *(_WORD *)(a3 + 442) = word_101CAB28[4];
  *(_WORD *)(a3 + 428) = word_101CAB28[4];
  *(_WORD *)(a3 + 430) = word_101CAB28[4];
  sub_100394A0(a2, a3, v4, v21, v12);
  sub_10039600(a2, a3, v4, v21, v13);
  result = 1;
  *(_WORD *)(a3 + 426) = 1;
  *(_WORD *)(a3 + 424) = 1;
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003A3C0) --------------------------------------------------------
char __cdecl sub_1003A3C0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8041:
      v5 = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 60) = *(_DWORD *)(a4 + 48);
      v6 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a4 + 64) = v5;
      *(_DWORD *)(a4 + 68) = v6;
      result = 1;
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_DWORD *)(a2 + 4) & 0x200 )
        sub_1003A640(a1, *(_WORD *)(a2 + 8), *(_WORD *)(a2 + 10), (int)a3);
      sub_10039810(a1, a2, (int)a3);
      if ( *(_BYTE *)(a2 + 4) & 0x40 )
        sub_10039C90(a1, a2, (int)a3);
      sub_1003A080(a4, (int)a3, a1, a2);
      if ( *(_DWORD *)(a2 + 4) & 0x400 )
        sub_10039A40((int)a3, a2, a1, a4, (int)a5);
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10039B10((int)a3, a2, a1, (const void *)a4, (int)a5);
      sub_10039860((int)a5, (int)a3, a2, a1, (const void *)a4);
      if ( *(_BYTE *)a4 != 1 )
      {
        sub_10039CE0(a3, a2, a1);
        if ( *(_BYTE *)a4 != 1 )
          goto LABEL_17;
      }
      sub_10039D90(a1, a2, (int)a3, a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      if ( *(_DWORD *)(a2 + 4) & 0x800 )
        sub_10039B10((int)a3, a2, a1, (const void *)a4, (int)a5);
      sub_10039860((int)a5, (int)a3, a2, a1, (const void *)a4);
      goto LABEL_17;
    default:
LABEL_17:
      result = 1;
      break;
  }
  return result;
}

//----- (1003A5A0) --------------------------------------------------------
char __cdecl sub_1003A5A0(int a1, int a2, int a3, int *a4, _WORD *a5)
{
  signed int v6; // ecx@5
  char v7; // [sp+0h] [bp-1Ch]@5
  float v8; // [sp+4h] [bp-18h]@5
  float v9; // [sp+8h] [bp-14h]@5
  float v10; // [sp+Ch] [bp-10h]@5
  float v11; // [sp+10h] [bp-Ch]@5
  float v12; // [sp+14h] [bp-8h]@5
  float v13; // [sp+18h] [bp-4h]@5
  signed int v14; // [sp+30h] [bp+14h]@5

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  j_gdi_pvg_color_u32(-1);
  if ( a2 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v14 = *(_WORD *)a3;
    v7 = 0;
    v8 = (double)v14;
    v9 = (double)v6;
    v10 = *(float *)(a2 + 4);
    v11 = *(float *)(a2 + 8);
    v12 = 0.0;
    v13 = 0.0;
    if ( a4 )
    {
      sub_10064E50(*a4, (int)&v7);
      return 2;
    }
    sub_10064CF0(*(_DWORD *)(a2 + 12), (int)&v7);
  }
  return 2;
}
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1003A640) --------------------------------------------------------
int __cdecl sub_1003A640(int a1, __int16 a2, __int16 a3, int a4)
{
  *(_WORD *)(a1 + 440) = word_101CAB28[12];
  *(_WORD *)(a1 + 442) = word_101CAB28[12];
  return sub_100916F0(a1 + 392, *(_WORD *)a4, *(_WORD *)(a4 + 2), a2, a3);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003A690) --------------------------------------------------------
char *__cdecl sub_1003A690(int a1, int a2, _BYTE *a3)
{
  char *result; // eax@2
  _BYTE *v4; // edx@2
  char v5; // cl@3
  _BYTE *v6; // edx@6
  char v7; // cl@7
  _BYTE *v8; // edx@9
  char v9; // cl@10
  _BYTE *v10; // edx@12
  char v11; // cl@13
  _BYTE *v12; // edx@15
  char v13; // cl@16
  _BYTE *v14; // edx@18
  char v15; // cl@19
  _BYTE *v16; // edx@21
  char v17; // cl@22
  _BYTE *v18; // edx@24
  char v19; // cl@25
  _BYTE *v20; // edx@27
  char v21; // cl@28
  _BYTE *v22; // edx@30
  char v23; // cl@31
  _BYTE *v24; // edx@33
  char v25; // cl@34
  _BYTE *v26; // edx@36
  char v27; // cl@37
  _BYTE *v28; // edx@39
  char v29; // cl@40
  _BYTE *v30; // edx@42
  char v31; // cl@43
  _BYTE *v32; // edx@45
  char v33; // cl@46
  _BYTE *v34; // edx@48
  char v35; // cl@49
  _BYTE *v36; // edx@51
  char v37; // cl@52
  _BYTE *v38; // edx@54
  char v39; // cl@55
  _BYTE *v40; // edx@57
  char v41; // cl@58
  _BYTE *v42; // edx@60
  char v43; // cl@61
  _BYTE *v44; // edx@63
  char v45; // cl@64
  _BYTE *v46; // edx@66
  char v47; // cl@67
  _BYTE *v48; // edx@69
  char v49; // cl@70
  _BYTE *v50; // edx@72
  char v51; // cl@73
  _BYTE *v52; // edx@75
  char v53; // cl@76
  _BYTE *v54; // edx@78
  char v55; // cl@79

  if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 14) & 1 )
  {
    result = (char *)*(_BYTE *)(a1 + 13);
    switch ( result )
    {
      case 0x14u:
        result = sub_1006ED10(0x5FDu);
        v6 = a3;
        do
        {
          v7 = *result;
          *v6++ = *result++;
        }
        while ( v7 );
        break;
      case 0x15u:
        result = sub_1006ED10(0xC01u);
        v8 = a3;
        do
        {
          v9 = *result;
          *v8++ = *result++;
        }
        while ( v9 );
        break;
      case 0x16u:
        result = sub_1006ED10(0x10E6u);
        v10 = a3;
        do
        {
          v11 = *result;
          *v10++ = *result++;
        }
        while ( v11 );
        break;
      case 0x13u:
        result = sub_1006ED10(0xB3Du);
        v12 = a3;
        do
        {
          v13 = *result;
          *v12++ = *result++;
        }
        while ( v13 );
        break;
      case 0xFu:
        result = sub_1006ED10(0xFE2u);
        v14 = a3;
        do
        {
          v15 = *result;
          *v14++ = *result++;
        }
        while ( v15 );
        break;
      case 0xDu:
        result = sub_1006ED10(0x123Au);
        v16 = a3;
        do
        {
          v17 = *result;
          *v16++ = *result++;
        }
        while ( v17 );
        break;
      case 0xEu:
        result = sub_1006ED10(0x1240u);
        v18 = a3;
        do
        {
          v19 = *result;
          *v18++ = *result++;
        }
        while ( v19 );
        break;
      case 0u:
        result = sub_1006ED10(0x1650u);
        v20 = a3;
        do
        {
          v21 = *result;
          *v20++ = *result++;
        }
        while ( v21 );
        break;
      case 1u:
        result = sub_1006ED10(0x116Eu);
        v22 = a3;
        do
        {
          v23 = *result;
          *v22++ = *result++;
        }
        while ( v23 );
        break;
      case 2u:
        result = sub_1006ED10(0xAFEu);
        v24 = a3;
        do
        {
          v25 = *result;
          *v24++ = *result++;
        }
        while ( v25 );
        break;
      case 3u:
        result = sub_1006ED10(0xB0Cu);
        v26 = a3;
        do
        {
          v27 = *result;
          *v26++ = *result++;
        }
        while ( v27 );
        break;
      case 4u:
        result = sub_1006ED10(0xB23u);
        v28 = a3;
        do
        {
          v29 = *result;
          *v28++ = *result++;
        }
        while ( v29 );
        break;
      case 5u:
        result = sub_1006ED10(0x822u);
        v30 = a3;
        do
        {
          v31 = *result;
          *v30++ = *result++;
        }
        while ( v31 );
        break;
      case 0x12u:
        result = sub_1006ED10(0x19B3u);
        v32 = a3;
        do
        {
          v33 = *result;
          *v32++ = *result++;
        }
        while ( v33 );
        break;
      case 6u:
        result = sub_1006ED10(0x553u);
        v34 = a3;
        do
        {
          v35 = *result;
          *v34++ = *result++;
        }
        while ( v35 );
        break;
      case 7u:
        result = sub_1006ED10(0x1307u);
        v36 = a3;
        do
        {
          v37 = *result;
          *v36++ = *result++;
        }
        while ( v37 );
        break;
      case 8u:
        result = sub_1006ED10(0x1303u);
        v38 = a3;
        do
        {
          v39 = *result;
          *v38++ = *result++;
        }
        while ( v39 );
        break;
      case 9u:
        result = sub_1006ED10(0x2CAu);
        v40 = a3;
        do
        {
          v41 = *result;
          *v40++ = *result++;
        }
        while ( v41 );
        break;
      case 0xAu:
        result = sub_1006ED10(0x3EBu);
        v42 = a3;
        do
        {
          v43 = *result;
          *v42++ = *result++;
        }
        while ( v43 );
        break;
      case 0xBu:
        result = sub_1006ED10(0xC06u);
        v44 = a3;
        do
        {
          v45 = *result;
          *v44++ = *result++;
        }
        while ( v45 );
        break;
      case 0xCu:
        result = sub_1006ED10(0x46Au);
        v46 = a3;
        do
        {
          v47 = *result;
          *v46++ = *result++;
        }
        while ( v47 );
        break;
      case 0x10u:
        result = sub_1006ED10(0xE44u);
        v48 = a3;
        do
        {
          v49 = *result;
          *v48++ = *result++;
        }
        while ( v49 );
        break;
      case 0x11u:
        result = sub_1006ED10(0x1AB6u);
        v50 = a3;
        do
        {
          v51 = *result;
          *v50++ = *result++;
        }
        while ( v51 );
        break;
      case 0x17u:
        result = sub_1006ED10(0x1950u);
        v52 = a3;
        do
        {
          v53 = *result;
          *v52++ = *result++;
        }
        while ( v53 );
        break;
      case 0x1Bu:
        result = sub_1006ED10(0x5ABu);
        v54 = a3;
        do
        {
          v55 = *result;
          *v54++ = *result++;
        }
        while ( v55 );
        break;
      default:
        *a3 = 0;
        break;
    }
  }
  else
  {
    result = sub_1006ED10(*(_WORD *)(a2 + 40));
    v4 = a3;
    do
    {
      v5 = *result;
      *v4++ = *result++;
    }
    while ( v5 );
  }
  return result;
}

//----- (1003AA80) --------------------------------------------------------
int __cdecl sub_1003AA80(unsigned __int8 a1, int a2, int a3)
{
  int result; // eax@1

  *(_WORD *)(a2 + 8) = *((_WORD *)*(&off_100CD488 + a1) + 2);
  *(_BYTE *)(a2 + 10) = 4;
  *(_DWORD *)a2 = 89;
  *(_DWORD *)(a2 + 4) = 1423;
  *(_BYTE *)(a2 + 11) = 0;
  *(_WORD *)(a2 + 12) = 0;
  *(_DWORD *)a3 = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  result = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 12) = result;
  *(_DWORD *)(a3 + 4) = 17807;
  return result;
}
// 100CD488: using guessed type void *off_100CD488;

//----- (1003AAE0) --------------------------------------------------------
char __cdecl sub_1003AAE0(int a1, const void *a2, int a3)
{
  int v3; // edx@1
  char v4; // dl@1
  char result; // al@2
  double v6; // st7@3
  double v7; // st6@3
  float v8; // ST1C_4@3
  double v9; // st5@3
  char v10; // bl@5
  double v11; // st3@9
  double v12; // st4@9
  bool v13; // c0@9
  bool v14; // c3@9
  double v15; // st3@9
  double v16; // st2@9
  char v17; // cl@11
  char v18; // al@15
  bool v19; // c0@16
  double v20; // st5@16
  double v21; // st2@18
  double v22; // st7@18
  double v23; // st5@18
  double v24; // st4@18
  double v25; // st3@18
  bool v26; // c0@20
  double v27; // st5@20
  double v28; // st2@22
  bool v29; // c0@26
  bool v30; // c3@26
  double v31; // st6@26
  double v32; // rt2@31
  double v33; // st4@31
  double v34; // st7@31
  double v35; // rtt@35
  double v36; // st5@35
  double v37; // st7@35
  float v38; // [sp+14h] [bp-6Ch]@1
  char v39[4]; // [sp+1Ch] [bp-64h]@1
  float v40; // [sp+20h] [bp-60h]@3
  float v41; // [sp+24h] [bp-5Ch]@3
  float v42; // [sp+28h] [bp-58h]@3
  float v43; // [sp+2Ch] [bp-54h]@4
  float v44; // [sp+30h] [bp-50h]@6
  float v45; // [sp+34h] [bp-4Ch]@9
  float v46; // [sp+38h] [bp-48h]@9
  float v47; // [sp+3Ch] [bp-44h]@9
  float v48[8]; // [sp+58h] [bp-28h]@1
  char v49[3]; // [sp+79h] [bp-7h]@24

  v3 = *(_DWORD *)(a1 + 4) >> 13;
  qmemcpy(v39, a2, 0x60u);
  v4 = ~(_BYTE)v3 & 1;
  v38 = v48[a3];
  if ( !v39[a3] )
    return 0;
  v6 = v41;
  v7 = v40;
  v8 = (v41 - v40) * 0.0015999999595806;
  v9 = v8;
  if ( v8 < v42 - v40 )
    goto LABEL_8;
  if ( v43 - v7 <= v9 )
  {
    if ( v44 - v7 > v9 )
    {
      v10 = (v4 != 0) + 1;
      goto LABEL_9;
    }
LABEL_8:
    v10 = 1;
    goto LABEL_9;
  }
  v10 = 3;
LABEL_9:
  v11 = v6 - v47;
  v12 = v47;
  v13 = v11 < v9;
  v14 = v11 == v9;
  v15 = v45;
  v16 = v46;
  if ( !v13 && !v14 )
    goto LABEL_44;
  if ( v6 - v16 > v9 )
  {
    v17 = 3;
    goto LABEL_15;
  }
  if ( v6 - v15 > v9 )
    v17 = (v4 != 0) + 1;
  else
LABEL_44:
    v17 = 1;
LABEL_15:
  v18 = *(_BYTE *)(a1 + 13);
  if ( v18 )
  {
    if ( v18 == 1 )
    {
      v26 = v16 - v15 < v9;
      v27 = v46;
      if ( v26 )
      {
        v45 = v15 + *(float *)(dword_1031FB44 + 32) - v16;
        v15 = v45;
      }
      v28 = *(float *)(dword_1031FB44 + 32) - v27;
      v47 = v12 + v28;
      v22 = v15;
      v41 = v41 + v28;
      v46 = v27 + v28;
      v23 = v47;
      v24 = v46;
      v25 = v41;
    }
    else
    {
      v25 = v41;
      v22 = v45;
      v23 = v47;
      v24 = v46;
    }
  }
  else
  {
    v19 = v16 - v15 < v9;
    v20 = v46;
    if ( v19 )
    {
      v45 = v15 + *(float *)(dword_1031FB44 + 28) - v16;
      v15 = v45;
    }
    v21 = *(float *)(dword_1031FB44 + 28) - v20;
    v47 = v12 + v21;
    v22 = v15;
    v41 = v41 + v21;
    v46 = v20 + v21;
    v23 = v47;
    v24 = v46;
    v25 = v41;
  }
  result = v49[a3];
  if ( !result || (*(_DWORD *)(a1 + 4) & 7) != 4 )
  {
    v29 = v38 < v7;
    v30 = v38 == v7;
    v31 = v38;
    if ( v29 || v30 )
      return v10;
    if ( v25 <= v31 )
      return v17;
    if ( v44 > v31 )
    {
      v34 = v24;
    }
    else
    {
      v32 = v24;
      v33 = v22;
      v34 = v32;
      if ( v33 >= v31 )
        return 1;
    }
    if ( v43 > v31 )
    {
      v37 = v23;
    }
    else
    {
      v35 = v23;
      v36 = v34;
      v37 = v35;
      if ( v36 >= v31 )
        return (v4 != 0) + 1;
    }
    if ( v42 <= v31 && v31 <= v37 )
      return 3;
    return 1;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;
// 1003AAE0: using guessed type char var_64[4];
// 1003AAE0: using guessed type float var_28[8];
// 1003AAE0: using guessed type char var_7[3];

//----- (1003ADC0) --------------------------------------------------------
int __cdecl sub_1003ADC0(unsigned __int8 a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_BYTE *)(a2 + 10) = *((_BYTE *)*(&off_100CD488 + a1) + 8);
  *(_WORD *)(a2 + 8) = *((_WORD *)*(&off_100CD488 + a1) + 3);
  *(_BYTE *)(a2 + 11) = *((_BYTE *)*(&off_100CD488 + a1) + 9);
  *(_DWORD *)(a2 + 4) = 40335;
  *(_DWORD *)a2 = 89;
  *(_WORD *)(a2 + 12) = 0;
  return result;
}
// 100CD488: using guessed type void *off_100CD488;

//----- (1003AE10) --------------------------------------------------------
double __cdecl sub_1003AE10(int a1, int a2)
{
  double result; // st7@4

  if ( *(_BYTE *)(a1 + 13) >= 0x1Cu )
    sub_10051A40(".\\cdp_utl_gauge.c", 801, 1, 0);
  if ( ~(unsigned __int8)(*(_DWORD *)(a1 + 4) >> 15) & 1 )
    result = *(float *)*(&off_100CD488 + *(_BYTE *)(a1 + 13));
  else
    result = *(float *)(a2 + 36);
  return result;
}
// 100CD488: using guessed type void *off_100CD488;

//----- (1003AE60) --------------------------------------------------------
char *__cdecl sub_1003AE60(unsigned __int8 a1, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  char *result; // eax@1
  char v4; // cl@3
  char v5; // cl@6
  char v6; // cl@9
  char v7; // cl@12
  char v8; // cl@15
  char v9; // cl@18
  char v10; // cl@21
  char v11; // cl@24
  char v12; // cl@27
  char v13; // [sp+8h] [bp-14h]@1
  unsigned int v14; // [sp+10h] [bp-Ch]@2

  v2 = a2;
  sub_1003ADC0(a1, (int)&v13);
  result = (char *)(a1 - 1);
  switch ( a1 )
  {
    case 2u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 0xFu:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x17u:
      result = sub_1006C690(v14, 0);
      do
      {
        v4 = *result;
        *v2++ = *result++;
      }
      while ( v4 );
      break;
    case 1u:
    case 0x11u:
      result = sub_1006C690(0xDu, 0);
      do
      {
        v5 = *result;
        *v2++ = *result++;
      }
      while ( v5 );
      break;
    case 8u:
      result = sub_1006C690(v14, 0);
      do
      {
        v6 = *result;
        *v2++ = *result++;
      }
      while ( v6 );
      break;
    case 0x10u:
      result = sub_1006C690(0xCu, 0);
      do
      {
        v7 = *result;
        *v2++ = *result++;
      }
      while ( v7 );
      break;
    case 9u:
    case 0xAu:
    case 0xBu:
      result = sub_1006C690(0x18u, 0);
      do
      {
        v8 = *result;
        *v2++ = *result++;
      }
      while ( v8 );
      break;
    case 0xCu:
      result = sub_1006C690(0x13u, 0);
      do
      {
        v9 = *result;
        *v2++ = *result++;
      }
      while ( v9 );
      break;
    case 0x16u:
      result = sub_1006C690(0xAu, 0);
      do
      {
        v10 = *result;
        *v2++ = *result++;
      }
      while ( v10 );
      break;
    case 0x1Au:
      result = sub_1006C690(0x26u, 0);
      do
      {
        v11 = *result;
        *v2++ = *result++;
      }
      while ( v11 );
      break;
    case 0x1Bu:
      result = sub_1006C690(0x1Du, 0);
      do
      {
        v12 = *result;
        *v2++ = *result++;
      }
      while ( v12 );
      break;
    default:
      *a2 = 0;
      break;
  }
  return result;
}

//----- (1003B0B0) --------------------------------------------------------
void __cdecl sub_1003B0B0(float a1, float a2, int a3, int a4)
{
  unsigned int v4; // edi@1
  float v5; // ST24_4@1
  float v6; // ST20_4@1
  float v7; // ST28_4@1
  int v8; // ST0C_4@1
  char v9; // [sp+2Ch] [bp-14h]@1
  unsigned int v10; // [sp+34h] [bp-Ch]@1

  sub_1003ADC0(*(_BYTE *)(a3 + 13), (int)&v9);
  v4 = v10;
  v5 = sub_1006D4B0(SLODWORD(a1), v10);
  v6 = sub_1006D4B0(SLODWORD(a2), v4);
  v7 = sub_1003AE10(a3, a4);
  *(float *)&v8 = sub_100665E0(v5, v6, 40, v7);
  sub_1006DAE0(v8, v4);
}

//----- (1003B160) --------------------------------------------------------
int __cdecl sub_1003B160(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (1003B1B0) --------------------------------------------------------
void __cdecl sub_1003B1B0(int a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  double v3; // st7@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@1
  double v7; // st7@1
  double v8; // st7@1
  double v9; // st7@1
  double v10; // st7@1
  size_t v11; // ebp@1
  bool v12; // c3@1
  char *v13; // ebx@1
  int v14; // eax@1
  const char *v15; // edi@20
  char v16; // al@22
  char *v17; // ecx@23
  int v18; // ecx@33
  signed int v19; // ST20_4@33
  _BYTE *v20; // esi@38
  _BYTE *v21; // ST0C_4@39
  float v22; // [sp+20h] [bp-6Ch]@20
  int v23; // [sp+24h] [bp-68h]@1
  int v24; // [sp+28h] [bp-64h]@1
  int v25; // [sp+2Ch] [bp-60h]@1
  float v26; // [sp+30h] [bp-5Ch]@1
  float v27; // [sp+34h] [bp-58h]@1
  int v28; // [sp+38h] [bp-54h]@1
  float v29; // [sp+3Ch] [bp-50h]@1
  int v30; // [sp+40h] [bp-4Ch]@1
  int v31; // [sp+44h] [bp-48h]@1
  float v32; // [sp+48h] [bp-44h]@1
  float v33; // [sp+4Ch] [bp-40h]@1
  float v34; // [sp+50h] [bp-3Ch]@1
  char v35[4]; // [sp+54h] [bp-38h]@1
  int v36; // [sp+58h] [bp-34h]@1
  int v37; // [sp+5Ch] [bp-30h]@1
  int v38; // [sp+60h] [bp-2Ch]@1
  char v39[4]; // [sp+64h] [bp-28h]@1
  int v40; // [sp+68h] [bp-24h]@1
  int v41; // [sp+6Ch] [bp-20h]@1
  int v42; // [sp+70h] [bp-1Ch]@1
  char v43; // [sp+74h] [bp-18h]@22

  v2 = v1;
  v3 = *(float *)(v1 + 12);
  v4 = *(_DWORD *)(v1 + 60);
  v26 = v3;
  v5 = *(_DWORD *)(v2 + 20);
  v6 = *(float *)(v2 + 16);
  v25 = a1;
  v27 = v6;
  v7 = *(float *)(v2 + 36);
  *(_DWORD *)v35 = 0;
  v29 = v7;
  v36 = 0;
  v8 = *(float *)(v2 + 28);
  v37 = 0;
  v32 = v8;
  v38 = 0;
  v9 = *(float *)(v2 + 32);
  *(_DWORD *)v39 = 0;
  v33 = v9;
  v40 = 0;
  v10 = *(float *)(v2 + 40);
  v41 = 0;
  v34 = v10;
  v42 = 0;
  v23 = *(int *)(v2 + 56);
  v31 = *(_DWORD *)(v2 + 24);
  v11 = 0;
  v12 = 9.8999998e24 == *(float *)(v2 + 56);
  v28 = v4;
  v30 = v5;
  LOBYTE(v24) = 31;
  v13 = v35;
  v14 = *(_WORD *)v2;
  if ( v12 )
  {
    v15 = (const char *)sub_10060760(v14);
    v22 = sub_1006D0E0(COERCE_INT(*(float *)(v2 + 48)), *(_WORD *)v2, *(_BYTE *)(v2 + 8), (char *)&v24);
    switch ( *(_WORD *)v2 )
    {
      case 2:
      case 3:
      case 8:
      case 9:
      case 0xA:
      case 0x1C:
      case 0x32:
        if ( v15 )
        {
          sprintf(&v43, v15, v22);
          v16 = v43;
          if ( v43 )
          {
            v17 = &v43;
            do
            {
              if ( (unsigned __int8)v16 >= 0x30u && (unsigned __int8)v16 <= 0x39u )
                ++v11;
              v16 = (v17++)[1];
            }
            while ( v16 );
          }
        }
        else
        {
          v11 = 5;
        }
        memset(v35, 95, v11);
        v35[v11] = 0;
        break;
      default:
        v13 = 0;
        break;
    }
    if ( *(_BYTE *)(v2 + 64) )
    {
      v18 = *(_DWORD *)(v2 + 68);
      v19 = (signed int)(*(float *)(v2 + 36) * 0.5);
      v30 = 0;
      v31 = v18;
      v27 = v27 - (double)v19;
    }
  }
  else
  {
    switch ( v14 )
    {
      case 3:
        if ( *(float *)(v2 + 56) >= 0.0 )
          strcpy(v35, "UP %.2f");
        else
          strcpy(v35, "DN %.2f");
        break;
      case 2:
        if ( *(float *)(v2 + 56) <= 0.0 )
          strcpy(v35, "L %.0f");
        else
          strcpy(v35, "R %.0f");
        break;
      case 8:
      case 10:
      case 50:
        sub_100649E0((int)v35, "%.0f", 16);
        break;
      case 9:
      case 12:
        sub_100649E0((int)v35, "%.1f", 16);
        break;
      case 28:
        if ( *(float *)(v2 + 56) >= 0.0 )
        {
          if ( *(float *)(v2 + 56) <= 0.0 )
            strcpy(v35, "%.0f");
          else
            strcpy(v35, "%.0f");
        }
        else
        {
          strcpy(v35, "%.0f");
        }
        break;
      default:
        v13 = 0;
        break;
    }
    if ( *(_BYTE *)(v2 + 10) )
      v23 = COERCE_UNSIGNED_INT(*(float *)(v2 + 56)) & 0x7FFFFFFF;
    *(float *)&v23 = sub_1006D0E0(v23, *(_WORD *)v2, *(_BYTE *)(v2 + 8), (char *)&v24);
  }
  if ( v13 )
  {
    if ( 9.8999998e24 == *(float *)(v2 + 56) )
      sub_100649E0((int)v39, v35, 16);
    else
      sub_10064B00(v39, 0x10u, v35, v23);
    v20 = *(_BYTE **)(v2 + 4);
    if ( v20 )
    {
      sub_10064B30(v39, v20, 16);
    }
    else
    {
      v21 = (_BYTE *)sub_1006C650(v24);
      sub_10064B30(v39, v21, 16);
    }
    sub_10065B70(v25, (int)v39, (int)&v26);
  }
}

//----- (1003B5E0) --------------------------------------------------------
char __cdecl sub_1003B5E0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  double v7; // st7@2
  int v8; // ecx@2
  double v9; // st7@2
  char result; // al@2
  bool v11; // zf@4
  float *v12; // edi@4
  double v13; // st7@4
  float v14; // [sp+14h] [bp-24h]@2
  float v15; // [sp+18h] [bp-20h]@2
  int v16; // [sp+1Ch] [bp-1Ch]@2
  float v17; // [sp+20h] [bp-18h]@2
  int v18; // [sp+24h] [bp-14h]@2
  int v19; // [sp+28h] [bp-10h]@2
  float v20; // [sp+2Ch] [bp-Ch]@2
  float v21; // [sp+30h] [bp-8h]@2
  float v22; // [sp+34h] [bp-4h]@2
  float v23; // [sp+4Ch] [bp+14h]@4
  float v24; // [sp+4Ch] [bp+14h]@4

  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v5 = *(_DWORD *)(a4 + 20);
      v6 = *(_DWORD *)(a4 + 60);
      v14 = *(float *)(a4 + 12);
      v7 = *(float *)(a4 + 16);
      v18 = v5;
      v15 = v7;
      v17 = *(float *)(a4 + 36);
      v16 = v6;
      v8 = *(_DWORD *)(a4 + 24);
      v20 = *(float *)(a4 + 28);
      v9 = *(float *)(a4 + 32);
      v19 = v8;
      v21 = v9;
      v22 = *(float *)(a4 + 40);
      sub_10065630(a1, (int)byte_100B8180, (int)&v14);
      result = 2;
      break;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        goto LABEL_11;
      v11 = *(_BYTE *)(a4 + 9) == 0;
      v12 = (float *)(a4 + 56);
      v23 = (double)*(_BYTE *)(a5 + 8) * *(float *)(a4 + 52);
      v24 = v23 + *(float *)(a4 + 56);
      v13 = v24;
      *(float *)(a4 + 56) = v24;
      if ( !v11 )
      {
        if ( *(float *)(a4 + 48) >= v13 )
        {
          if ( *(float *)(a4 + 44) > v13 )
            *v12 = *(float *)(a4 + 48);
        }
        else
        {
          *v12 = *(float *)(a4 + 44);
        }
      }
      sub_1003B160(*(float *)(a4 + 48), *(float *)(a4 + 44));
      *v12 = sub_10095970(*v12, COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a4 + 52)) & 0x7FFFFFFF));
      sub_1003B1B0(a1);
      result = 3;
      break;
    case 0x8022:
    case 0x8078:
      sub_1003B1B0(a1);
      goto LABEL_11;
    default:
LABEL_11:
      result = 1;
      break;
  }
  return result;
}

//----- (1003B7B0) --------------------------------------------------------
int __cdecl sub_1003B7B0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // esi@1

  v2 = ((a2 & 0x3F) - 46) << 6;
  v3 = *(int *)((char *)&dword_100CE150 + v2);
  if ( a2 & 0x40 )
    ++v3;
  return v3 * *((_BYTE *)&unk_1031F1E0 + 20 * ((a1 >> 10) & 0xF) + 17)
       + *(int *)((char *)&dword_100CE148 + v2) * *((_BYTE *)&unk_1031F1E0 + 20 * ((a1 >> 10) & 0xF) + 15)
       + *(_WORD *)(*((_DWORD *)&unk_1031F1E0 + 5 * ((a1 >> 10) & 0xF) + 1) + 28)
       * (*(int *)((char *)&dword_100CE148 + v2) + v3 - 1);
}
// 100CE148: using guessed type int dword_100CE148;
// 100CE150: using guessed type int dword_100CE150;

//----- (1003B810) --------------------------------------------------------
char __cdecl sub_1003B810(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@0
  signed __int16 v3; // ax@1
  void *v4; // ecx@1
  signed __int16 v5; // dx@7

  LOBYTE(v3) = sub_10051FD0(v2);
  if ( (_BYTE)v3 )
  {
    if ( sub_10051FA0(v4) )
    {
      *a2 = 35;
      v3 = *a1;
      if ( *a1 < 0x7FFF )
      {
        if ( v3 / 12 & 1 )
          *a2 = 36;
        v3 = *a1 / 12;
        v5 = *a1 % 12;
        *a1 = v5;
        if ( !v5 )
          *a1 = 12;
      }
    }
    else
    {
      LOBYTE(v3) = (_BYTE)a2;
      *a2 = 37;
    }
  }
  else
  {
    *a2 = 38;
  }
  return v3;
}

//----- (1003B880) --------------------------------------------------------
__int16 __usercall sub_1003B880@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ecx@1
  unsigned int v5; // ecx@1
  __int16 result; // ax@1

  v3 = a3 % (3600 * (word_100CE14C[32 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 46)] + 1));
  v4 = v3;
  v3 /= 0xE10u;
  *(_WORD *)a2 = v3;
  v5 = -3600 * (unsigned __int16)v3 + v4;
  *(_BYTE *)(a2 + 2) = v5 / 0x3C;
  result = 60 * (char)(v5 / 0x3C);
  *(_BYTE *)(a2 + 3) = v5 % 0x3C;
  return result;
}
// 100CE14C: using guessed type __int16 word_100CE14C[];

//----- (1003B8E0) --------------------------------------------------------
char *__usercall sub_1003B8E0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  void *v5; // ecx@1
  __int16 v6; // ax@2
  char v8; // [sp+4h] [bp-4h]@1
  char v9; // [sp+6h] [bp-2h]@1

  strncpy(&v8, (const char *)(a2 + *(_DWORD *)(a1 + 56) + 69), 2u);
  v9 = 0;
  v4 = a4 + (unsigned __int8)j__atol(&v8);
  if ( sub_10051FA0(v5) != 1
    || (v6 = *(_WORD *)(a3 + 8) & 0x3F, v6 == 49)
    || v6 == 48
    || v6 == 47
    || v6 == 50
    || v6 == 51
    || v6 == 46 )
  {
    if ( v4 <= 23 )
    {
      if ( v4 < 0 )
        v4 = 23;
    }
    else
    {
      v4 = 0;
    }
  }
  else if ( v4 <= 12 )
  {
    if ( v4 <= 0 )
      v4 = 12;
  }
  else
  {
    v4 = 1;
  }
  sprintf(&v8, "%02u", v4);
  return strncpy((char *)(a2 + *(_DWORD *)(a1 + 56) + 69), &v8, 2u);
}

//----- (1003B9A0) --------------------------------------------------------
int __usercall sub_1003B9A0@<eax>(unsigned int a1@<eax>, char a2@<cl>)
{
  char v2; // bl@1
  int v3; // ebp@1
  __int16 v4; // bx@1
  int v5; // edi@1
  signed int v6; // esi@6
  _BYTE *v7; // eax@7
  int v8; // eax@7

  v2 = a2;
  v3 = *((_DWORD *)sub_1004AB50(a1) + 1);
  v4 = v2 & 0x3F;
  v5 = 0;
  if ( v4 == 52 || v4 == 53 || v4 == 54 || v4 == 55 || v4 == 56 )
  {
    v6 = 0;
    do
    {
      v7 = (_BYTE *)sub_1006C650(byte_100CE3D8[v6]);
      v8 = sub_1008F880(v3, v7, 0);
      if ( v5 <= v8 )
        v5 = v8;
      ++v6;
    }
    while ( v6 < 4 );
  }
  return v5;
}

//----- (1003BA10) --------------------------------------------------------
char __usercall sub_1003BA10@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v5; // cl@1

  v3 = ((*(_BYTE *)(a2 + 8) & 0x3F) - 46) << 6;
  v4 = *(int *)((char *)&dword_100CE150 + v3) + *(int *)((char *)&dword_100CE148 + v3);
  *a1 = v4;
  v5 = *(_BYTE *)(a2 + 8) & 0x3F;
  if ( v5 == 52 || (*(_BYTE *)(a2 + 8) & 0x3F) == 54 )
  {
    LOBYTE(v4) = sub_10051FA0((void *)v5);
    if ( (_BYTE)v4 == 1 )
      ++*a1;
  }
  if ( byte_100CE155[v3] && *(_BYTE *)(a2 + 8) & 0x40 )
  {
    *a3 = 1;
    ++*a1;
  }
  else
  {
    *a3 = 0;
  }
  return v4;
}
// 100CE148: using guessed type int dword_100CE148;
// 100CE150: using guessed type int dword_100CE150;

//----- (1003BA80) --------------------------------------------------------
char __usercall sub_1003BA80@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int v4; // ebp@1
  signed int v5; // eax@1
  int v6; // edi@3
  void *v7; // ecx@5
  __int16 v8; // ax@6
  signed __int16 v9; // ax@8
  __int16 v10; // cx@16
  __int16 v11; // ax@17
  __int16 v12; // cx@22
  __int16 v13; // ax@26
  int v14; // eax@31
  char result; // al@32
  signed int v16; // [sp+Ch] [bp-8h]@1
  signed int v17; // [sp+10h] [bp-4h]@3

  v4 = a3;
  v5 = 0;
  v16 = 0;
  if ( a1 )
  {
    v5 = *a1;
    v16 = *a1;
  }
  v17 = 1;
  v6 = (*(_BYTE *)(a3 + 8) & 0x3F) - 46;
  if ( v5 < 0 )
  {
    v5 = -v5;
    v16 = v5;
    v17 = -1;
  }
  sub_1003B880(a3, (int)&a3, v5);
  if ( sub_10051FA0(v7) != 1 || (v8 = *(_WORD *)(v4 + 8) & 0x3F, v8 != 52) && v8 != 54 )
  {
    v9 = a3;
  }
  else
  {
    v9 = a3;
    if ( (_WORD)a3 == 12 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else if ( (signed __int16)a3 <= 12 )
    {
      if ( !(_WORD)a3 )
        v9 = 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -108;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      v9 -= 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
  }
  v10 = *(_WORD *)(v4 + 8);
  if ( v10 & 0x40 )
  {
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), &a03d02u[64 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    v11 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v11 == 46 || v11 == 47) && !v16 || v17 < 0 )
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 69) = 45;
  }
  else
  {
    v12 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v12 != 50 && v12 != 51 )
      sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), off_100CE118[16 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    else
      sprintf(
        (char *)(*(_DWORD *)(a2 + 56) + 69),
        off_100CE118[16 * v6],
        BYTE2(a3),
        (unsigned __int8)(BYTE3(a3) / 10 + 48),
        (unsigned __int8)((unsigned __int16)(BYTE3(a3) % 10) + 48));
  }
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  v13 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v13 != 46 && v13 != 47 && v13 != 52 && v13 != 48 && v13 != 54
    || (v14 = *(_DWORD *)(a2 + 56), *(_WORD *)(v14 + 240) != a4) )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 4;
  }
  else
  {
    *(_BYTE *)(v14 + 242) = 2;
    result = 4;
  }
  return result;
}
// 100CE118: using guessed type char *off_100CE118[2];

//----- (1003BC70) --------------------------------------------------------
char __cdecl sub_1003BC70(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  char result; // al@4
  unsigned int v5; // [sp+8h] [bp-4h]@1

  v3 = sub_10051BD0((char *)&v5);
  if ( v3 == 1 )
  {
    if ( sub_10051FD0(v2) == 1 )
      sub_1006E640((int *)&v5, v5);
    sub_10073910((int)a1, v5);
    sub_1003B810(a1, a2);
    result = 1;
  }
  else
  {
    *a1 = 0x7FFF;
    sub_1003B810(a1, a2);
    result = v3;
  }
  return result;
}

//----- (1003BCF0) --------------------------------------------------------
char __usercall sub_1003BCF0@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  void *v6; // ecx@1
  int v7; // eax@1
  char v8; // bl@1
  unsigned __int16 v9; // ax@4
  __int16 v10; // ax@7
  __int16 v11; // ax@10
  char result; // al@12
  unsigned __int16 v13; // ax@15
  int v14; // ebp@17
  int v15; // eax@18
  __int16 v16; // ax@19
  int v17; // eax@26
  char *v18; // eax@27
  int v19; // ebx@27
  char v20; // dl@28
  char v21; // bl@29
  char *v22; // eax@29
  char v23; // dl@29
  char v24; // cl@30
  __int16 v25; // bp@33
  void *v26; // ecx@34
  __int16 v27; // di@35
  char *v28; // eax@42
  int v29; // edi@42
  char v30; // dl@43
  char v31; // bl@44
  char *v32; // eax@44
  char v33; // dl@44
  char v34; // cl@45
  int v35; // ecx@46
  unsigned int v36; // kr00_4@48
  __int32 v37; // eax@48
  int v38; // ebx@49
  char *v39; // eax@53
  char v40; // dl@54
  char v41; // bl@55
  char *v42; // eax@55
  char v43; // dl@55
  char v44; // cl@56
  int v45; // ecx@57
  __int16 v46; // ax@57
  const char *v47; // ecx@58
  char v48; // kr08_1@58
  char *v49; // eax@58
  char v50; // dl@58
  char v51; // cl@59
  int v52; // ecx@60
  char v53; // cl@62
  int v54; // edx@65
  __int16 v55; // di@75
  bool v56; // zf@79
  unsigned __int16 v57; // ax@82
  __int16 v58; // ax@85
  __int16 v59; // bp@88
  unsigned __int16 v60; // ax@89
  int v61; // ebp@91
  void *v62; // ecx@91
  __int16 v63; // ax@92
  char *v64; // eax@99
  int v65; // edx@99
  char v66; // cl@100
  char v67; // bl@101
  char *v68; // eax@101
  char v69; // bp@101
  char v70; // cl@102
  int v71; // eax@103
  _BYTE *v72; // ecx@103
  __int16 v73; // ax@103
  __int16 v74; // di@109
  signed __int16 v75; // di@114
  const char *v76; // ecx@117
  char *v77; // eax@117
  int v78; // edi@117
  char v79; // dl@118
  __int16 v80; // bp@123
  __int16 v81; // ax@123
  char v82[2]; // [sp+10h] [bp-10h]@33
  char v83; // [sp+12h] [bp-Eh]@34
  char v84; // [sp+13h] [bp-Dh]@33
  int v85; // [sp+14h] [bp-Ch]@1
  int v86; // [sp+18h] [bp-8h]@1
  int v87; // [sp+1Ch] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v86 = (*(_BYTE *)(a1 + 8) & 0x3F) - 46;
  sub_1003BA10(&v87, a1, &v85);
  v7 = *(_DWORD *)(v5 + 56);
  v8 = 1;
  if ( *(_WORD *)(v7 + 240) != -128 )
  {
    if ( *(_WORD *)(a4 + 10) == 84 )
      *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v7 + 69) != 45) + 43;
    v9 = *(_WORD *)(a4 + 14);
    if ( v9 >= 0x41u && v9 <= 0x5Au || v9 == 32 )
    {
      v10 = *(_WORD *)(v4 + 8) & 0x3F;
      if ( (v10 == 52 || v10 == 54) && sub_10051FA0(v6) == 1 )
      {
        v11 = *(_WORD *)(a4 + 14);
        goto LABEL_11;
      }
    }
    v13 = *(_WORD *)(a4 + 14);
    if ( v13 >= 0x30u && v13 <= 0x39u )
    {
      v14 = v85;
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        v15 = *(_DWORD *)(v5 + 56);
        if ( *(_WORD *)(v15 + 240) == v85 - 1 )
        {
          *(_WORD *)(v15 + 240) = v85;
          v16 = *(_WORD *)(v4 + 8) & 0x3F;
          if ( v16 != 46 && v16 != 47 && v16 != 52 && v16 != 48 && v16 != 54 )
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
          else
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
        }
      }
      v17 = *(_DWORD *)(v5 + 56);
      if ( *(_BYTE *)(v17 + 242) == 2 )
      {
        *(_WORD *)(v17 + v14 + 69) = 12336;
        v18 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v19 = *(_DWORD *)(v5 + 56) + 70;
        do
          v20 = *v18++;
        while ( v20 );
        v21 = (_BYTE)v18 - v19;
        v22 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v23 = (_BYTE)v22 + 1;
        do
          v24 = *v22++;
        while ( v24 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v21 - ((_BYTE)v22 - v23)) - 1;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
      }
      if ( (*(_BYTE *)(v4 + 8) & 0x3F) == 49 )
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v85 + 69), 3u);
        v25 = word_100CE14C[32 * v86];
        v84 = 0;
      }
      else
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v14 + 69), 2u);
        v83 = 0;
        if ( sub_10051FA0(v26) != 1
          || (v27 = *(_WORD *)(v4 + 8) & 0x3F, v27 == 49)
          || v27 == 48
          || v27 == 47
          || v27 == 50
          || v27 == 51
          || (v25 = 12, v27 == 46) )
        {
          v25 = 23;
        }
      }
      v28 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v29 = *(_DWORD *)(v5 + 56) + 70;
      do
        v30 = *v28++;
      while ( v30 );
      v31 = (_BYTE)v28 - v29;
      v32 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
      v33 = (_BYTE)v32 + 1;
      do
        v34 = *v32++;
      while ( v34 );
      v35 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v35 + 240) == (char)(v31 - ((_BYTE)v32 - v33)) - 1 )
      {
        if ( v82[0] == 48 )
        {
          v36 = strlen(v82);
          v37 = j__atol(v82);
          sprintf(v82, "%0*i", v36, 10 * v37);
        }
        v38 = v85;
        v82[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) - v85] = *(_BYTE *)(a4 + 14);
        if ( j__atol(v82) > v25 )
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
        else
          memcpy_0((void *)(*(_DWORD *)(v5 + 56) + v38 + 69), v82, strlen(v82));
        if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v38 + 69)) <= v25 )
        {
LABEL_69:
          if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) == 58 )
          {
            ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
            return 2;
          }
          return 2;
        }
        v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        do
          v40 = *v39++;
        while ( v40 );
        v41 = (_BYTE)v39 - (*(_BYTE *)(v5 + 56) + 70);
        v42 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v43 = (_BYTE)v42 + 1;
        do
          v44 = *v42++;
        while ( v44 );
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)(v41 - ((_BYTE)v42 - v43)) + 1;
      }
      else
      {
        v47 = (const char *)(v35 + 69);
        v48 = strlen(v47);
        v49 = strchr(v47, 58);
        v50 = (_BYTE)v49 + 1;
        do
          v51 = *v49++;
        while ( v51 );
        v52 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
        if ( v52 >= (char)(v48 - ((_BYTE)v49 - v50)) - 1 )
        {
          if ( *(_WORD *)(a4 + 14) > (unsigned __int16)(unsigned __int8)*(&byte_100CE120[(v86 << 6) - v85] + v52) )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        else
        {
          v82[v52 - v85] = *(_BYTE *)(a4 + 14);
          if ( j__atol(v82) > v25 )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = v53;
        v54 = *(_DWORD *)(v5 + 56);
        LOBYTE(v46) = v87 - 1;
        if ( *(_WORD *)(v54 + 240) < v87 - 1 )
          v46 = *(_WORD *)(v54 + 240);
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)v46;
      }
      *(_WORD *)(v45 + 240) = v46;
      goto LABEL_69;
    }
    if ( v13 != 43 && v13 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) != v85 - 1 )
      return 2;
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v85;
    v55 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v55 == 46 || v55 == 47 || v55 == 52 || v55 == 48 )
      goto LABEL_129;
    v56 = v55 == 54;
LABEL_128:
    if ( v56 )
      goto LABEL_129;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
    return 2;
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
    *(_WORD *)(a4 + 14) = 45;
  v57 = *(_WORD *)(a4 + 14);
  if ( v57 >= 0x41u && v57 <= 0x5Au || v57 == 32 )
  {
    v58 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v58 == 52 || v58 == 54) && sub_10051FA0(v6) == 1 )
    {
      v59 = v85;
      sub_1003BA80(a3, v5, v4, v85);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v59;
      v11 = *(_WORD *)(a4 + 14);
LABEL_11:
      if ( v11 == 80 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -107;
        return 2;
      }
      if ( v11 == 65 )
      {
        result = 2;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -108;
        return result;
      }
      return 2;
    }
  }
  v60 = *(_WORD *)(a4 + 14);
  if ( v60 < 0x30u || v60 > 0x39u )
  {
    if ( v60 != 43 && v60 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    v80 = v85;
    v86 = 0;
    sub_1003BA80(&v86, v5, v4, v85);
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v80;
    v81 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v81 == 46 || v81 == 47 || v81 == 52 || v81 == 48 )
    {
LABEL_129:
      result = 2;
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
      return result;
    }
    v56 = v81 == 54;
    goto LABEL_128;
  }
  v61 = v85;
  v86 = 0;
  sub_1003BA80(&v86, v5, v4, v85);
  if ( sub_10051FA0(v62) == 1 )
  {
    v63 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v63 != 49 && v63 != 48 && v63 != 47 && v63 != 50 && v63 != 51 && v63 != 46 )
      *(_WORD *)(*(_DWORD *)(v5 + 56) + v61 + 69) = 12336;
  }
  *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
  v64 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v65 = *(_DWORD *)(v5 + 56) + 70;
  do
    v66 = *v64++;
  while ( v66 );
  v67 = (_BYTE)v64 - v65;
  v68 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) - 1;
  v71 = *(_DWORD *)(v5 + 56);
  v72 = (_BYTE *)*(_WORD *)(v71 + 240);
  v72[v71 + 69] = *(_BYTE *)(a4 + 14);
  v73 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v73 != 46 && v73 != 47 && v73 != 52 && v73 != 48 && v73 != 54 )
    return 2;
  if ( sub_10051FA0(v72) != 1
    || (v74 = *(_WORD *)(v4 + 8) & 0x3F, v74 == 49)
    || v74 == 48
    || v74 == 47
    || v74 == 50
    || v74 == 51
    || (v56 = v74 == 46, v75 = 12, v56) )
  {
    v75 = 23;
  }
  if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v85 + 69)) <= v75 )
    return 2;
  v76 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
  v77 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v78 = *(_DWORD *)(v5 + 56) + 70;
  do
    v79 = *v77++;
  while ( v79 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v77 - v78 - strlen(strchr(v76, 58))) + 1;
  return 2;
}
// 100CE14C: using guessed type __int16 word_100CE14C[];
// 1003BCF0: using guessed type char var_10[2];

//----- (1003C4E0) --------------------------------------------------------
char __usercall sub_1003C4E0@<al>(int a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4)
{
  _BYTE *v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@1
  signed int v7; // ebp@2
  int v8; // ecx@8
  signed int v9; // esi@8
  int v10; // ebx@10
  _BYTE *v11; // edx@11
  __int16 v12; // dx@12
  int v13; // esi@29
  int v14; // esi@33
  char *v15; // ebx@38
  void *v16; // ecx@41
  const char *v17; // ST18_4@49
  char *v18; // ebx@57
  void *v19; // ecx@60
  char *v20; // ebx@68
  _BYTE *v21; // edx@71
  char v22; // cl@72
  int v24; // [sp-8h] [bp-30h]@21
  signed int v25; // [sp-8h] [bp-30h]@28
  int v26; // [sp-4h] [bp-2Ch]@21
  signed int v27; // [sp-4h] [bp-2Ch]@32
  __int16 v28; // [sp+10h] [bp-18h]@8
  unsigned __int8 v29; // [sp+12h] [bp-16h]@8
  unsigned __int8 v30; // [sp+13h] [bp-15h]@8
  int v31; // [sp+14h] [bp-14h]@1
  int v32; // [sp+18h] [bp-10h]@1
  char *v33; // [sp+1Ch] [bp-Ch]@10
  int v34; // [sp+20h] [bp-8h]@10
  int v35; // [sp+24h] [bp-4h]@1

  v4 = (_BYTE *)a1;
  v5 = *(_BYTE *)(a3 + 8) & 0x3F;
  LOBYTE(a1) = 0;
  *(_DWORD *)v4 = 0;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 3) = 0;
  *((_DWORD *)v4 + 4) = 0;
  v35 = v5;
  v6 = v5 - 46;
  v32 = 1;
  LOBYTE(v31) = 31;
  v4[20] = 0;
  if ( v5 == 54 )
    v7 = 0;
  else
    v7 = *a2;
  switch ( v5 )
  {
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
      if ( v7 >= 0x7FFFFFFF )
        goto LABEL_78;
      if ( v7 < 0 )
      {
        v7 = -v7;
        v32 = -1;
      }
      sub_1003B880(a3, (int)&v28, v7);
      v8 = v28;
      v9 = v29;
      if ( v30 + 60 * (v29 + 60 * v28) != v7 || v7 >= 0x7FFFFFFF )
      {
LABEL_78:
        v15 = (&off_100CE11C)[64 * v6];
        do
        {
          LOBYTE(a1) = *v15;
          *v4++ = *v15++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        v10 = v6 << 6;
        v33 = (&off_100CE11C)[v10];
        v34 = (int)v4;
        do
        {
          LOBYTE(a1) = *v33;
          v11 = (_BYTE *)v34;
          ++v33;
          ++v34;
          *v11 = a1;
        }
        while ( (_BYTE)a1 );
        v12 = *(__int16 *)((char *)word_100CE14C + v10);
        if ( v28 <= v12 )
        {
          if ( (a1 = *(_WORD *)(a3 + 8), v34 = a1, LOWORD(a1) = a1 & 0x3F, (_WORD)a1 != 50) && (_WORD)a1 != 51
            || v9 <= v12 )
          {
            if ( v28 || v35 != 47 )
            {
              if ( (_WORD)a1 != 50 && (_WORD)a1 != 51 )
              {
                if ( v35 == 46 || v35 == 47 )
                {
                  v27 = v9;
                  if ( v34 & 0x40 )
                  {
                    v14 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v27);
                    if ( !v7 || v14 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100CE118 + v10), v32 * v8, v9);
                  }
                }
                else
                {
                  v25 = v9;
                  if ( v34 & 0x40 )
                  {
                    v13 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v25, v30);
                    if ( v13 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100CE118 + v10), v32 * v8, v9, v30);
                  }
                }
              }
              else
              {
                v26 = (unsigned __int8)((unsigned __int16)(v30 % 10) + 48);
                v24 = (unsigned __int8)(v30 / 10 + 48);
                if ( v34 & 0x40 )
                {
                  LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v9, v24, v26);
                  if ( !v7 || v32 < 0 )
                    *v4 = 45;
                }
                else
                {
                  LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100CE118 + v10), v9, v24, v26);
                }
              }
            }
            else
            {
              LOBYTE(a1) = sprintf(
                             v4,
                             "%02u:%c%c",
                             v9,
                             (unsigned __int8)(v30 / 10 + 48),
                             (unsigned __int8)((unsigned __int16)(v30 % 10) + 48));
            }
          }
        }
      }
      break;
    case 55:
      if ( !sub_10051BD0((char *)&v34) || v7 >= 86400 )
        goto LABEL_53;
      if ( sub_10051FD0(v16) == 1 )
        sub_1006E640(&v34, v34);
      v7 += 86400
          * (((signed int)(((unsigned __int64)(1037155065i64 * (v34 + v7)) >> 32) - (v34 + v7)) >> 16)
           + ((unsigned int)(((unsigned __int64)(1037155065i64 * (v34 + v7)) >> 32) - (v34 + v7)) >> 31))
          + v34;
      goto LABEL_46;
    case 52:
    case 53:
    case 56:
LABEL_46:
      if ( v7 == -1 || v7 >= 86400 )
      {
LABEL_53:
        v28 = 0x7FFF;
        if ( v5 == 53 || v5 == 56 )
          LOBYTE(v31) = 38;
        else
          sub_1003B810(&v28, &v31);
        v18 = (&off_100CE11C)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v18;
          *v4++ = *v18++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        sub_10073910((int)&v28, v7);
        if ( v5 == 53 )
        {
          v17 = off_100CE118[16 * (v5 - 46)];
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, v17, v28, v29, v30);
        }
        else if ( v5 == 56 )
        {
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, off_100CE118[16 * (v5 - 46)], v28, v29);
        }
        else
        {
          sub_1003B810(&v28, &v31);
          LOBYTE(a1) = sprintf(v4, off_100CE118[16 * (v5 - 46)], v28, v29);
        }
      }
      break;
    case 54:
      if ( sub_1003BC70(&v28, &v31) )
      {
        if ( sub_10051FA0(v19) == 1 )
        {
          if ( v28 && v28 != 12 )
          {
            LOBYTE(a1) = sprintf(v4, "%d:%02d:%02d", v28 % 12, v29, v30);
          }
          else
          {
            sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
            LOBYTE(a1) = sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
          }
        }
        else
        {
          LOBYTE(a1) = sprintf(v4, off_100CE118[16 * (v5 - 46)], v28, v29, v30);
        }
      }
      else
      {
        v20 = (&off_100CE11C)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v20;
          *v4++ = *v20++;
        }
        while ( (_BYTE)a1 );
      }
      break;
    default:
      break;
  }
  if ( ~(unsigned __int8)(*(_WORD *)(a3 + 8) >> 9) & 1 )
  {
    a1 = sub_1006C650(v31);
    v21 = a4;
    do
    {
      v22 = *(_BYTE *)a1;
      *v21++ = *(_BYTE *)a1++;
    }
    while ( v22 );
  }
  else
  {
    *a4 = 0;
  }
  return a1;
}
// 100CE118: using guessed type char *off_100CE118[2];
// 100CE11C: using guessed type char *off_100CE11C;
// 100CE14C: using guessed type __int16 word_100CE14C[];

//----- (1003C9E0) --------------------------------------------------------
char __usercall sub_1003C9E0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // ebx@1
  __int16 v5; // cx@1
  int v6; // ebx@2
  __int16 v7; // ax@4
  char v9; // [sp+4h] [bp-24h]@1
  char v10; // [sp+Ch] [bp-1Ch]@1

  v4 = a2;
  sub_1003C4E0((int)&v10, a1, a4, &v9);
  *(_WORD *)(a3 + 438) = *(_WORD *)v4;
  *(_WORD *)(a3 + 436) = *(_WORD *)(v4 + 2);
  v5 = *(_WORD *)(a4 + 8);
  if ( ~((unsigned int)*(_WORD *)(a4 + 8) >> 9) & 1 )
    v6 = sub_1003B9A0(*(_DWORD *)(a4 + 4), v5);
  else
    v6 = 0;
  v7 = *(_WORD *)(a4 + 10) - v6;
  if ( v6 > 0 )
    v7 -= *(_WORD *)(dword_1031F1E4[5 * ((*(_DWORD *)(a4 + 4) >> 10) & 0xF)] + 28);
  if ( !*(_WORD *)(a4 + 10) )
    v7 = sub_1003B7B0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
  return sub_1004B840(a3, &v10, &v9, v7, v6, *(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (1003CAA0) --------------------------------------------------------
char __cdecl sub_1003CAA0(int a1, int a2, int *a3, signed int *a4, int a5)
{
  signed int *v5; // ecx@1
  int v6; // edx@2
  int v7; // ebx@4
  bool v8; // zf@4
  __int16 v9; // ax@8
  _WORD *v10; // esi@8
  unsigned int v11; // ebx@9
  int v12; // eax@9
  int v13; // eax@11
  __int16 v14; // dx@15
  __int16 v15; // cx@15
  __int64 v16; // rax@18
  int v17; // eax@20
  __int16 v18; // bx@20
  signed int v19; // eax@21
  signed int v20; // edx@29
  int v21; // edx@31
  int v22; // edx@32
  int *v23; // ecx@34
  int v24; // esi@34
  signed int v25; // eax@35
  __int16 v26; // ax@37
  int v27; // esi@39
  void *v28; // ecx@39
  signed __int16 v29; // bx@39
  __int16 v30; // ax@41
  int v31; // edi@55
  int v32; // esi@57
  char v33; // al@58
  __int16 v34; // ax@63
  int v35; // edi@67
  char v36; // al@68
  __int16 v37; // ax@75
  int v38; // eax@77
  char v39; // cl@77
  char v40; // al@79
  int v41; // eax@85
  signed int *v42; // edx@85
  const char *v43; // edx@89
  char v44; // kr00_1@89
  char *v45; // eax@89
  char v46; // dl@89
  char v47; // cl@90
  int v48; // ecx@91
  __int16 v49; // ax@92
  int v50; // ebx@97
  __int16 v51; // ax@101
  int v52; // eax@105
  int v53; // esi@105
  __int16 v54; // cx@107
  char v55; // dl@114
  int v56; // edi@120
  int v57; // edi@129
  __int16 v58; // ax@129
  char v59; // al@131
  char v60; // cl@132
  int v61; // ebx@136
  int v62; // ecx@137
  int v63; // edx@137
  unsigned __int8 v64; // al@137
  __int16 v65; // ax@139
  __int16 v66; // ax@146
  int v67; // eax@151
  int v68; // esi@155
  __int16 v69; // cx@156
  signed int *v70; // edx@156
  int v71; // ecx@156
  int v72; // ecx@157
  int v73; // edx@157
  unsigned __int8 v74; // al@157
  __int16 v75; // ax@159
  int v76; // eax@167
  unsigned __int8 v77; // cl@167
  __int16 v78; // ax@171
  int v79; // eax@176
  int v80; // ebx@181
  int *v81; // eax@194
  unsigned __int8 v82; // ST10_1@194
  const char *v83; // ebx@194
  int v84; // esi@194
  __int16 v85; // ax@194
  char v87; // [sp+13h] [bp-3Dh]@4
  int v88; // [sp+14h] [bp-3Ch]@5
  int v89; // [sp+18h] [bp-38h]@4
  signed int *v90; // [sp+1Ch] [bp-34h]@1
  int v91; // [sp+20h] [bp-30h]@1
  int *v92; // [sp+24h] [bp-2Ch]@1
  int v93; // [sp+28h] [bp-28h]@4
  int v94; // [sp+2Ch] [bp-24h]@5
  int v95; // [sp+30h] [bp-20h]@85
  char v96[24]; // [sp+34h] [bp-1Ch]@35

  v5 = a4;
  v92 = a3;
  v91 = a2;
  v90 = a4;
  if ( a4 )
    v6 = *a4;
  else
    v6 = 0;
  v7 = (*(_BYTE *)(a2 + 8) & 0x3F) - 46;
  v8 = *(_WORD *)a5 == -32703;
  v89 = v6;
  v87 = 1;
  v93 = v7;
  if ( v8 )
  {
    v88 = 0;
    v94 = 0;
  }
  else
  {
    sub_1003BA10(&v94, a2, &v88);
    v5 = v90;
    v6 = v89;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v9 = *(_WORD *)(a2 + 10);
      v10 = (_WORD *)(a1 + 276);
      if ( v9 )
      {
        sub_1004B6E0(a1 + 276, *v92, *(_DWORD *)(a2 + 4), v9);
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4);
        v12 = sub_1003B7B0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
        sub_1004B6E0(a1 + 276, *v92, v11, v12);
      }
      v13 = sub_1003B9A0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      if ( (!*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v13 > 0 )
      {
        v14 = *(_WORD *)(dword_1031F1E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v13 + v14;
        v15 = *(_WORD *)(a1 + 280);
        if ( *(_WORD *)(a2 + 10) > 0 )
          *v10 += v13 + v14;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v16 = (signed __int16)v13 + (signed int)v14 + 1;
          LODWORD(v16) = ((signed int)v16 - HIDWORD(v16)) >> 1;
          *v10 -= v16;
          *(_WORD *)(a1 + 280) = v15 - v16;
        }
      }
      return 2;
    case 0x8048:
      v17 = *(_DWORD *)(a1 + 56);
      v18 = *(_WORD *)(v17 + 240);
      if ( v18 == -128 )
      {
        v19 = *(_WORD *)(a5 + 10);
        if ( v19 > 84 )
        {
          if ( v19 != 0x2000 )
            return v87;
        }
        else if ( v19 != 84 )
        {
          if ( v19 == 32 )
          {
            v93 = 0;
            v87 = sub_1003BA80(&v93, a1, a2, v88);
          }
          else if ( v19 == 56 )
          {
            v87 = sub_1003BA80(v5, a1, a2, v88);
          }
          return v87;
        }
        return sub_1003BCF0(a2, a1, v5, a5);
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 56 )
      {
        if ( v20 == 57 )
        {
          v60 = *(_BYTE *)(a5 + 8);
          if ( v60 < 0 )
          {
            if ( v18 )
            {
              --*(_WORD *)(v17 + 240);
              if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                v61 = v88;
                do
                {
                  v62 = *(_DWORD *)(a1 + 56);
                  v63 = *(_WORD *)(v62 + 240);
                  v64 = *(_BYTE *)(v63 + v62 + 69);
                  if ( v64 >= 0x30u && v64 <= 0x39u )
                  {
                    v65 = *(_WORD *)(a2 + 8) & 0x3F;
                    if ( v65 != 46 && v65 != 47 && v65 != 52 && v65 != 48 && v65 != 54 )
                      break;
                    if ( v63 != v61 + 1 )
                      break;
                  }
                  --*(_WORD *)(v62 + 240);
                }
                while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) );
              }
              v66 = *(_WORD *)(a2 + 8) & 0x3F;
              v87 = 2;
              if ( v66 != 46 && v66 != 47 && v66 != 52 && v66 != 48 && v66 != 54
                || (v67 = *(_DWORD *)(a1 + 56), *(_WORD *)(v67 + 240) != v88) )
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              }
              else
              {
                *(_BYTE *)(v67 + 242) = 2;
              }
            }
            else
            {
              v87 = 2;
            }
            goto LABEL_127;
          }
          if ( v60 <= 0 )
            return v87;
          v68 = v94 - 1;
          if ( v18 >= v94 - 1 )
            return 0;
          v69 = *(_WORD *)(v17 + 240);
          v70 = (signed int *)v69;
          *(_WORD *)(v17 + 240) = v69 + 1;
          v71 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
          v90 = v70;
          if ( v71 < v68 )
          {
            do
            {
              v72 = *(_DWORD *)(a1 + 56);
              v73 = *(_WORD *)(v72 + 240);
              v74 = *(_BYTE *)(v73 + v72 + 69);
              if ( v74 >= 0x30u && v74 <= 0x39u )
              {
                v75 = *(_WORD *)(a2 + 8) & 0x3F;
                if ( v75 != 46 && v75 != 47 && v75 != 52 && v75 != 48 && v75 != 54 )
                  break;
                if ( v73 != v88 + 1 )
                  break;
              }
              ++*(_WORD *)(v72 + 240);
            }
            while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v68 );
          }
          if ( byte_100CE154[64 * v93]
            || (v76 = *(_DWORD *)(a1 + 56), v77 = *(_BYTE *)(*(_WORD *)(v76 + 240) + v76 + 69), v77 >= 0x30u)
            && v77 <= 0x39u )
          {
            v87 = 2;
          }
          else
          {
            *(_WORD *)(v76 + 240) = (char)v90;
            v87 = 0;
          }
          v78 = *(_WORD *)(a2 + 8) & 0x3F;
          if ( v78 != 46 && v78 != 47 && v78 != 52 && v78 != 48 && v78 != 54
            || (v79 = *(_DWORD *)(a1 + 56), *(_WORD *)(v79 + 240) != v88) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
          }
          else
          {
            *(_BYTE *)(v79 + 242) = 2;
          }
        }
        else
        {
          if ( v20 != 84 && v20 != 0x2000 )
            return v87;
          v87 = sub_1003BCF0(a2, a1, v5, a5);
        }
        if ( v87 != 4 && v87 != 2 )
          return v87;
LABEL_127:
        if ( v89 < 0 )
          v89 = -v89;
        v57 = v91;
        sub_1003B880(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 == 52 || v58 == 54 )
        {
          v59 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          goto LABEL_187;
        }
        goto LABEL_192;
      }
      if ( v20 == 56 )
      {
        v90 = (signed int *)(2 * (*(_BYTE *)(a5 + 8) >= 0) - 1);
        if ( v18 >= v88 )
        {
          v43 = (const char *)(v17 + 69);
          v44 = strlen((const char *)(v17 + 69));
          v45 = strchr(v43, 58);
          v46 = (_BYTE)v45 + 1;
          do
            v47 = *v45++;
          while ( v47 );
          v48 = *(_DWORD *)(a1 + 56);
          if ( *(_WORD *)(v48 + 240) < (signed __int16)(char)(v44 - ((_BYTE)v45 - v46)) )
          {
            v49 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v49 == 46 || v49 == 47 || v49 == 52 || v49 == 48 || v49 == 54 )
            {
              v50 = v88;
              *(_WORD *)(v48 + 240) = v88;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
              goto LABEL_100;
            }
            *(_BYTE *)(v48 + 242) = 1;
          }
        }
        v50 = v88;
LABEL_100:
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != v94 - 1
          || (v51 = *(_WORD *)(a2 + 8) & 0x3F, v51 != 52) && v51 != 54
          || sub_10051FA0((void *)(v94 - 1)) != 1 )
        {
          v52 = *(_DWORD *)(a1 + 56);
          v53 = *(_WORD *)(v52 + 240);
          if ( v53 == v50 - 1 )
          {
            v87 = 2;
            *(_BYTE *)(v52 + 69) = 2 * (*(_BYTE *)(v52 + 69) != 45) + 43;
          }
          else
          {
            v54 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v54 != 46 && v54 != 47 && v54 != 52 && v54 != 48 && v54 != 54 || v53 != v50 )
            {
              v55 = *(_BYTE *)(v53 + v52 + 69);
              if ( v55 != 48 || v90 != (signed int *)-1 )
              {
                if ( *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) < (unsigned __int8)*(&byte_100CE120[(v93 << 6) - v50]
                                                                                     + *(_WORD *)(v52 + 240))
                  || v90 != (signed int *)1 )
                {
                  v56 = *(_DWORD *)(a1 + 56);
                  *(_BYTE *)(*(_WORD *)(v56 + 240) + v56 + 69) = sub_10064730(v55, 0x10u, (char)v90);
                  v87 = 2;
                }
                else
                {
                  *(_BYTE *)(v53 + v52 + 69) = 48;
                  v87 = 2;
                }
              }
              else
              {
                *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) = *(&byte_100CE120[(v93 << 6) - v50] + *(_WORD *)(v52 + 240));
                v87 = 2;
              }
            }
            else
            {
              sub_1003B8E0(a1, v50, v91, (int)v90);
              v87 = 2;
            }
          }
        }
        else
        {
          v87 = 2;
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = (*(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) == -108) - 108;
        }
        goto LABEL_127;
      }
      v21 = v20 - 32;
      if ( !v21 )
        goto LABEL_34;
      v22 = v21 - 1;
      if ( v22 )
      {
        if ( v22 != 7 )
          return v87;
LABEL_34:
        v23 = v92;
        v24 = v91;
        *(_WORD *)(v17 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_1003C9E0(v90, (int)v23, a1, v24);
        return 6;
      }
      *(_WORD *)(v17 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      sub_100649E0((int)v96, (_BYTE *)(*(_DWORD *)(a1 + 56) + 69), 21);
      v25 = v94;
      if ( (unsigned int)v94 >= 0x14 )
        v25 = 20;
      v96[v25] = 0;
      v26 = *(_WORD *)(a2 + 8) & 0x3F;
      BYTE3(v89) = 0;
      if ( v26 != 50 && v26 != 51 )
      {
        v27 = v88;
        BYTE2(v89) = 0;
        v29 = j__atol(&v96[v88]);
      }
      else
      {
        v27 = v88;
        BYTE2(v89) = j__atol(&v96[v88]);
        v29 = 0;
      }
      v30 = *(_WORD *)(a2 + 8) & 0x3F;
      LOWORD(v89) = v29;
      if ( v30 != 49
        && v30 != 48
        && v30 != 47
        && v30 != 50
        && v30 != 51
        && v30 != 46
        && v30 != 56
        && v30 != 53
        && sub_10051FA0(v28) == 1 )
      {
        if ( !v29 )
        {
          v29 = 12;
LABEL_54:
          LOWORD(v89) = v29;
          goto LABEL_55;
        }
        if ( v29 > 12 )
        {
          v29 -= 12;
          goto LABEL_54;
        }
      }
LABEL_55:
      v31 = v27 + 3;
      if ( word_100CE14C[32 * v93] <= 99 )
        v31 = v27 + 2;
      v32 = v94;
      if ( v31 < v94 )
      {
        while ( 1 )
        {
          v33 = v96[v31];
          if ( (unsigned __int8)v33 >= 0x30u && (unsigned __int8)v33 <= 0x39u )
            break;
          if ( ++v31 >= v94 )
            goto LABEL_67;
        }
        if ( v31 < v94 )
        {
          v34 = *(_WORD *)(v91 + 8) & 0x3F;
          if ( v34 != 50 && v34 != 51 )
            BYTE2(v89) = j__atol(&v96[v31]);
          else
            BYTE3(v89) = j__atol(&v96[v31]);
        }
      }
LABEL_67:
      v35 = v31 + 2;
      if ( v35 < v32 )
      {
        while ( 1 )
        {
          v36 = v96[v35];
          if ( (unsigned __int8)v36 >= 0x30u && (unsigned __int8)v36 <= 0x39u )
            break;
          if ( ++v35 >= v32 )
            goto LABEL_74;
        }
        if ( v35 < v32 )
          BYTE3(v89) = j__atol(&v96[v35]);
      }
LABEL_74:
      if ( sub_10051FA0(v28) == 1 )
      {
        v37 = *(_WORD *)(v91 + 8) & 0x3F;
        if ( v37 == 52 || v37 == 54 )
        {
          v38 = *(_DWORD *)(a1 + 56);
          v39 = *(_BYTE *)(v38 + 90);
          *(_BYTE *)(v38 + 90) = -108;
          if ( v29 )
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = v39;
          v40 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          if ( v40 == -107 && v29 < 12 )
          {
            v29 += 12;
            LOWORD(v89) = v29;
          }
          if ( v40 == -108 && v29 == 12 )
            LOWORD(v89) = 0;
        }
      }
      sub_10073960(&v95, v89);
      v41 = v95;
      v42 = v90;
      *v90 = v95;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) == 45 )
        *v42 = -v41;
      sub_1003C9E0(v42, (int)v92, a1, v91);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v80 = *(_DWORD *)(a1 + 56), *(_WORD *)(v80 + 240) != -128) )
      {
        if ( v6 < 0 )
          v89 = -v6;
        v57 = v91;
        sub_1003B880(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 != 52 && v58 != 54 )
        {
LABEL_192:
          if ( v58 == 56 )
            LOBYTE(v88) = 38;
        }
        else
        {
          v59 = *(_BYTE *)(v80 + 90);
LABEL_187:
          if ( v59 == -108 )
          {
            LOBYTE(v88) = 35;
          }
          else if ( v59 == -107 )
          {
            LOBYTE(v88) = 36;
          }
          else
          {
            sub_1003B810((signed __int16 *)&v89, &v88);
          }
        }
        sprintf(v96, (const char *)(*(_DWORD *)(a1 + 56) + 69));
        v81 = v92;
        *(_WORD *)(a1 + 438) = *(_WORD *)v92;
        v82 = v88;
        *(_WORD *)(a1 + 436) = *((_WORD *)v81 + 1);
        v83 = (const char *)sub_1006C650(v82);
        v84 = sub_1003B9A0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        v85 = *(_WORD *)(v57 + 10) - v84;
        if ( v84 > 0 )
          v85 -= *(_WORD *)(dword_1031F1E4[5 * ((*(_DWORD *)(v57 + 4) >> 10) & 0xF)] + 28);
        if ( !*(_WORD *)(v57 + 10) )
          v85 = sub_1003B7B0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        sub_1004B840(a1, v96, v83, v85, v84, *(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
      }
      else
      {
        sub_1003C9E0(v90, (int)v92, a1, v91);
      }
      return v87;
    default:
      return v87;
  }
}
// 100CE14C: using guessed type __int16 word_100CE14C[];
// 1031F1E4: using guessed type int dword_1031F1E4[];
// 1003CAA0: using guessed type char var_1C[24];

//----- (1003D5A0) --------------------------------------------------------
BOOL __cdecl sub_1003D5A0(float a1)
{
  return (LODWORD(a1) & 0x7F800000) != 2139095040;
}

//----- (1003D5C0) --------------------------------------------------------
int __usercall sub_1003D5C0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 16);
  *(float *)(result + 24) = 0.5;
  *(float *)(result + 28) = 0.5;
  *(float *)(result + 32) = 0.0;
  *(float *)result = *(float *)(a4 + 12) * 0.5 + (double)*(_WORD *)a2;
  *(float *)(result + 4) = 0.5 * *(float *)(a4 + 8) + (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (1003D620) --------------------------------------------------------
int __usercall sub_1003D620@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebp@1
  int v6; // eax@1
  int v7; // edi@1
  bool v8; // zf@1
  double v9; // st6@1
  float v10; // ST30_4@9
  float v11; // ST1C_4@9
  float v12; // ST30_4@9
  float v13; // ST30_4@9
  float v14; // ST1C_4@9
  float v15; // ST30_4@9
  float v16; // ST30_4@9
  float v17; // ST1C_4@9
  float v18; // ST14_4@9
  int result; // eax@9
  double v20; // st7@10
  float v21; // ST30_4@10
  float v22; // ST10_4@10
  int v23; // ecx@12
  int v24; // edx@12
  int v25; // eax@15
  int v26; // [sp+18h] [bp-68h]@12
  float v27; // [sp+28h] [bp-58h]@1
  float v28; // [sp+30h] [bp-50h]@1
  float v29; // [sp+34h] [bp-4Ch]@1
  float v30; // [sp+38h] [bp-48h]@1
  float v31; // [sp+3Ch] [bp-44h]@1
  int v32; // [sp+40h] [bp-40h]@1
  int v33; // [sp+44h] [bp-3Ch]@1
  float v34; // [sp+48h] [bp-38h]@1
  float v35; // [sp+4Ch] [bp-34h]@1
  float v36; // [sp+50h] [bp-30h]@1
  float v37; // [sp+54h] [bp-2Ch]@1
  float v38; // [sp+58h] [bp-28h]@1
  char v39; // [sp+5Ch] [bp-24h]@15
  float v40; // [sp+84h] [bp+4h]@1
  float v41; // [sp+84h] [bp+4h]@9
  float v42; // [sp+84h] [bp+4h]@9
  float v43; // [sp+84h] [bp+4h]@9
  float v44; // [sp+84h] [bp+4h]@9
  float v45; // [sp+84h] [bp+4h]@10
  float v46; // [sp+84h] [bp+4h]@10

  v4 = a1;
  v5 = a2;
  v33 = *(int *)(a1 + 28);
  v34 = 0.0;
  v35 = 1.0;
  v36 = *(float *)(a1 + 32);
  v37 = *(float *)(a1 + 12) - 6.0;
  v38 = 1.0;
  v31 = *(float *)(a1 + 8) - 5.0;
  v30 = sub_10065120(*(float *)(a1 + 40), (int)&v33, 2);
  v6 = *(_DWORD *)(v4 + 20);
  v7 = *(_DWORD *)(v4 + 24);
  v8 = *(_BYTE *)(a2 + 3) == 0;
  v9 = *(float *)v4 + 3.0;
  v32 = *(_DWORD *)(v4 + 20);
  v28 = v9;
  v29 = *(float *)(v4 + 4) + 3.0;
  v40 = *(float *)(v4 + 4) + *(float *)(v4 + 8);
  v27 = 1.0;
  if ( !v8 && *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 && (byte_102BA90E || byte_1031EB20) )
  {
    v7 = v6;
    v27 = 3.0;
  }
  if ( 9.8999998e24 != *(float *)(v4 + 44) && *(_BYTE *)(v4 + 72) )
    v40 = *(float *)(v4 + 8) * 1.5 + *(float *)(v4 + 4);
  j_gdi_pvg_color_u32(*(_DWORD *)(v4 + 16));
  j_gdi_pvg_begin(72);
  v10 = *(float *)(v4 + 4) - 2.0;
  v11 = v10;
  v12 = *(float *)v4 - 2.0;
  sub_1008C2F0(v12, v11);
  v13 = *(float *)(v4 + 4) - 2.0;
  v14 = v13;
  v15 = *(float *)(v4 + 12) + *(float *)v4 + 2.0;
  sub_1008C2F0(v15, v14);
  v41 = v40 + 2.0;
  v16 = *(float *)(v4 + 12) + *(float *)v4 + 2.0;
  sub_1008C2F0(v16, v41);
  v17 = v41;
  v42 = *(float *)v4 - 2.0;
  sub_1008C2F0(v42, v17);
  j_gdi_pvg_end();
  v43 = *(float *)(v4 + 4) + *(float *)(v4 + 8);
  v18 = v43;
  v44 = *(float *)(v4 + 12) + *(float *)v4;
  sub_10067FF0(*(float *)v4, *(float *)(v4 + 4), v44, v18, v7, v27);
  result = sub_1006AA90((int)&v28, 1);
  if ( *(_BYTE *)(v4 + 72) )
  {
    v20 = sub_10065120(*(float *)(v4 + 44), (int)&v33, 2);
    v21 = v20 + v28;
    v45 = *(float *)(v4 + 8) * 1.5;
    v22 = v45;
    v46 = *(float *)(v4 + 12) * 0.2000000029802322;
    result = sub_10068550(v21, v29, v46, v22, 0.0, *(_DWORD *)(v4 + 24), *(_DWORD *)(v4 + 16));
  }
  if ( *(_BYTE *)(v4 + 73) )
  {
    v23 = *(_DWORD *)(v4 + 60);
    v24 = *(_DWORD *)(v4 + 68);
    v26 = v4 + 48;
    if ( *(float *)(v4 + 40) >= 0.0 )
    {
      sub_10064760(*(float *)(v4 + 40), v24, v23, v26);
      *(_BYTE *)(v4 + *(_DWORD *)(v4 + 68) + 48) = 0;
    }
    else
    {
      sub_10064760(*(float *)(v4 + 40), v24 + 1, v23 + 1, v26);
      *(_BYTE *)(v4 + *(_DWORD *)(v4 + 68) + 49) = 0;
    }
    sub_10064B30((const char *)(v4 + 48), *(_BYTE **)(v4 + 64), 10);
    v25 = sub_1003D5C0((int)&v39, a4, a3, v4);
    result = sub_10065B50(v5, v4 + 48, v25);
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 102BA90E: using guessed type char byte_102BA90E;
// 1031EB20: using guessed type char byte_1031EB20;

//----- (1003D930) --------------------------------------------------------
char __cdecl sub_1003D930(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@6
  int v6; // edx@7
  float *v7; // esi@8
  int v8; // edx@8
  char result; // al@10
  int v10; // edx@12
  float v11; // [sp+20h] [bp+10h]@12

  if ( (COERCE_UNSIGNED_INT(*(float *)a4) & 0x7F800000) != 2139095040
    && (COERCE_UNSIGNED_INT(*(float *)(a4 + 4)) & 0x7F800000) != 2139095040
    && (COERCE_UNSIGNED_INT(*(float *)(a4 + 8)) & 0x7F800000) != 2139095040
    && (COERCE_UNSIGNED_INT(*(float *)(a4 + 12)) & 0x7F800000) != 2139095040
    && (COERCE_UNSIGNED_INT(*(float *)(a4 + 28)) & 0x7F800000) != 2139095040
    && sub_1003D5A0(*(float *)(a4 + 32))
    && sub_1003D5A0(*(float *)(v5 + 44))
    && (v7 = (float *)(v6 + 40), sub_1003D5A0(*(float *)(v6 + 40))) )
  {
    switch ( *(_WORD *)a5 )
    {
      case 0x8040:
        *(float *)(a1 + 304) = *(float *)(v8 + 8) + *(float *)(v8 + 4);
        *(float *)(a1 + 292) = *(float *)v8;
        *(float *)(a1 + 300) = *(float *)(v8 + 12) + *(float *)v8;
        *(float *)(a1 + 296) = *(float *)(v8 + 4);
        *(float *)(a1 + 36) = *(float *)v8;
        *(float *)(a1 + 40) = *(float *)(v8 + 4);
        result = 2;
        break;
      case 0x8048:
        if ( *(_WORD *)(a5 + 10) != 56 )
          goto LABEL_14;
        v11 = *(float *)(v8 + 36) * (double)*(_BYTE *)(a5 + 8);
        *v7 = v11 + *v7;
        sub_1003B160(*(float *)(v8 + 32), *(float *)(v8 + 28));
        sub_1003D620(v10, a1, a2, a3);
        result = 3;
        break;
      case 0x8022:
      case 0x8078:
        sub_1003D620(v8, a1, a2, a3);
        goto LABEL_14;
      default:
LABEL_14:
        result = 1;
        break;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003DB60) --------------------------------------------------------
char __cdecl sub_1003DB60(int a1, int a2, int a3)
{
  __int16 v3; // ax@1
  unsigned int v4; // ecx@1
  int v5; // ebp@1
  __int16 v6; // ax@1
  const char *v8; // [sp+1Ch] [bp+Ch]@1

  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v8 = (const char *)sub_1006C660(*(_WORD *)(a2 + 8), 0);
  v3 = sub_1004B1E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), 0);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  v6 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v6 -= v5;
    if ( v5 > 0 )
      v6 -= *(_WORD *)(dword_1031F1E4[5 * ((v4 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v6 = sub_1003F920(v4, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
  return sub_1004B840(a1, (char *)(*(_DWORD *)(a1 + 56) + 69), v8, v6, v5, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (1003DC30) --------------------------------------------------------
char __cdecl sub_1003DC30(int a1, int a2, int a3, float *a4)
{
  bool v4; // sf@1
  unsigned __int8 v5; // of@1
  __int16 v6; // ax@1
  __int16 v7; // dx@1
  bool v8; // cl@3
  __int16 v9; // ax@5
  char *v10; // edi@12
  char v11; // cl@13
  char *v12; // edi@15
  char v13; // al@16
  char v14; // al@18
  int v15; // eax@21
  size_t v16; // edi@24
  const char *v17; // ebx@25
  __int16 v18; // ax@25
  unsigned int v19; // ecx@25
  int v20; // ebp@25
  __int16 v21; // ax@25
  __int16 v23; // [sp+Ch] [bp-24h]@1
  int v24; // [sp+10h] [bp-20h]@1
  char v25[2]; // [sp+14h] [bp-1Ch]@10
  char v26[12]; // [sp+20h] [bp-10h]@23

  v5 = __OFSUB__(*(_DWORD *)a4, 0x7FFFFFFF);
  v4 = *(_DWORD *)a4 - 0x7FFFFFFF < 0;
  v6 = *(_WORD *)(a2 + 8);
  v7 = *(_WORD *)(a2 + 8);
  v24 = a1;
  v23 = v7;
  v8 = v4 ^ v5 || (v6 & 0x3F) == 8;
  v9 = v6 & 0x3F;
  if ( v9 == 4 )
  {
    v7 &= 0xFDFFu;
    v23 = v7;
  }
  if ( !v8 )
    goto LABEL_33;
  if ( *(_DWORD *)a4 || !(v7 & 0x8000) )
  {
    strcpy(v25, "%");
    if ( v7 & 0x40 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 43;
    }
  }
  else
  {
    strcpy(v25, "-%");
  }
  v12 = (char *)&v24 + 3;
  if ( v9 == 8 )
  {
    do
      v13 = (v12++)[1];
    while ( v13 );
    *(_DWORD *)v12 = 5777968;
  }
  else
  {
    do
      v14 = (v12++)[1];
    while ( v14 );
    *(_DWORD *)v12 = 6564400;
  }
  v15 = v7 & 0x100 ? *(_BYTE *)(a2 + 10) : 0;
  if ( sprintf(v26, v25, v15, *(_DWORD *)a4) > *(_BYTE *)(a2 + 10) )
  {
LABEL_33:
    v16 = *(_BYTE *)(a2 + 10);
    memset(v26, 95, v16);
    v26[v16] = 0;
  }
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v17 = (const char *)sub_1006C660(*(_WORD *)(a2 + 8), a4);
  v18 = sub_1004B1E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
  v19 = *(_DWORD *)(a2 + 4);
  v20 = v18;
  v21 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v21 -= v20;
    if ( v20 > 0 )
      v21 -= *(_WORD *)(dword_1031F1E4[5 * ((v19 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v21 = sub_1003F920(v19, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
  return sub_1004B840(v24, v26, v17, v21, v20, *(_DWORD *)(a2 + 4), v23);
}
// 1031F1E4: using guessed type int dword_1031F1E4[];
// 1003DC30: using guessed type char var_10[12];

//----- (1003DE20) --------------------------------------------------------
char __usercall sub_1003DE20@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>)
{
  const char *v3; // edi@1
  signed int v4; // eax@1
  int v5; // eax@3
  int v6; // ecx@3

  v3 = "%+0*d";
  v4 = *a1 >= 0x7FFFFFFF ? 0 : *a1;
  if ( !(*(_BYTE *)(a3 + 8) & 0x40) )
    v3 = "%0*d";
  v5 = sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, *(_BYTE *)(a3 + 10), v4);
  v6 = *(_BYTE *)(a3 + 10);
  if ( v5 > v6 )
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, v6, 0);
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  return 4;
}

//----- (1003DE90) --------------------------------------------------------
char __usercall sub_1003DE90@<al>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  bool v5; // zf@1
  int v6; // edi@1
  signed int v7; // ebx@1
  int v8; // eax@4
  unsigned __int16 v9; // ax@7
  int v10; // eax@9
  __int16 v11; // cx@9
  char result; // al@10
  char v13; // cl@12
  __int32 v14; // eax@18
  int v15; // eax@21
  int v16; // edx@39
  int v17; // eax@42
  char *v18; // [sp+10h] [bp-8h]@1
  int v19; // [sp+14h] [bp-4h]@1
  char v20; // [sp+1Ch] [bp+4h]@1

  v3 = a3;
  v4 = a1;
  v5 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v6 = a2;
  v20 = 1;
  v7 = 1;
  v19 = 0;
  v18 = "%+0*d";
  if ( v5 )
    v18 = "%0*d";
  if ( *(_WORD *)(v3 + 10) == 84 )
  {
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
      *(_WORD *)(v3 + 14) = 45;
    else
      *(_WORD *)(v3 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
  }
  v9 = *(_WORD *)(v3 + 14);
  if ( v9 < 0x30u || v9 > 0x39u )
  {
    if ( v9 != 43 && v9 != 45 )
    {
      result = 1;
    }
    else if ( sub_1006C620(*(_WORD *)(v4 + 8)) || *(_BYTE *)(v4 + 8) & 0x40 )
    {
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) == -128 )
      {
        sub_1003DE20(&v19, v6, v4);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      }
      if ( *(_WORD *)(v3 + 14) == 45 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) >= 0
        || *(_WORD *)(v3 + 14) == 43 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) <= 0 )
      {
        if ( *(_BYTE *)(v4 + 8) & 0x40 || *(_WORD *)(v3 + 14) == 45 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
        else
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 48;
        v20 = 2;
      }
      v16 = *(_DWORD *)(v6 + 56);
      if ( !*(_WORD *)(v16 + 240)
        && (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) == 43
         || *(_BYTE *)(*(_WORD *)(v16 + 240) + *(_DWORD *)(v6 + 56) + 69) == 45) )
      {
        ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        v17 = *(_BYTE *)(v4 + 10) - 1;
        if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v17 )
          LOWORD(v17) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v17;
      }
      result = v20;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    v10 = *(_DWORD *)(a2 + 56);
    v11 = *(_WORD *)(v10 + 240);
    if ( v11 == -128 )
    {
      sub_1003DE20(&v19, v6, v4);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else if ( v11 == (unsigned __int8)(*(_BYTE *)(v4 + 10) - 1) )
    {
      v13 = *(_BYTE *)(v10 + 69);
      if ( v13 == 48 || (v13 == 43 || v13 == 45) && *(_BYTE *)(v10 + 70) == 48 )
      {
        if ( v13 == 45 )
        {
          *(_BYTE *)(v10 + 69) = 48;
          v7 = -1;
        }
        v14 = j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69));
        sprintf((char *)(*(_DWORD *)(v6 + 56) + 69), v18, *(_BYTE *)(v4 + 10), 10 * v14);
        if ( v7 == -1 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 45;
      }
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(v10 + 240) + v10 + 69) = *(_BYTE *)(v3 + 14);
      ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      v15 = *(_BYTE *)(v4 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v15 )
        LOWORD(v15) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v15;
      result = 2;
    }
  }
  return result;
}

//----- (1003E150) --------------------------------------------------------
char __cdecl sub_1003E150(int a1, int a2)
{
  int v2; // ecx@0
  __int16 v3; // ax@1
  char v5; // [sp+0h] [bp-14h]@1
  int v6; // [sp+4h] [bp-10h]@1
  __int16 v7; // [sp+8h] [bp-Ch]@1
  char v8; // [sp+Ah] [bp-Ah]@1
  char v9; // [sp+Bh] [bp-9h]@1
  __int16 v10; // [sp+Ch] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8);
  v3 = *(_WORD *)(a1 + 12);
  v8 = *(_BYTE *)(a1 + 10);
  v10 = v3;
  v9 = 0;
  return sub_1003DB60(v2, (int)&v5, a2);
}

//----- (1003E1B0) --------------------------------------------------------
char __cdecl sub_1003E1B0(int a1, int a2, int *a3, float *a4, int a5)
{
  char v5; // bl@1
  __int16 v6; // ax@2
  _WORD *v7; // ebx@2
  int v8; // eax@3
  int v9; // edx@5
  __int16 v10; // ax@9
  int v11; // eax@10
  __int16 v12; // cx@10
  char result; // al@11
  int v14; // eax@12
  __int16 v15; // bp@12
  signed int v16; // eax@13
  char v17; // al@19
  __int16 v18; // cx@21
  __int16 v19; // ax@25
  signed int v20; // edx@28
  int v21; // edx@30
  int v22; // edx@31
  char v23; // cl@33
  int v24; // ebx@34
  int v25; // ebx@39
  int v26; // edx@42
  __int16 v27; // ax@42

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v6 = *(_WORD *)(a2 + 12);
      v7 = (_WORD *)(a1 + 276);
      if ( v6 )
      {
        sub_1004B6E0(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v6);
      }
      else
      {
        v8 = sub_1003F920(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
        sub_1004B6E0((int)v7, *a3, *(_DWORD *)(a2 + 4), v8);
      }
      v9 = (signed __int16)sub_1004B1E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v9 > 0 )
      {
        v10 = *(_WORD *)(dword_1031F1E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v9 + v10;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v11 = (v10 + v9 + 1) / 2;
          v12 = *(_WORD *)(a1 + 280) - v11;
          *v7 -= v11;
          *(_WORD *)(a1 + 280) = v12;
        }
      }
      return 2;
    case 0x8048:
      v14 = *(_DWORD *)(a1 + 56);
      v15 = *(_WORD *)(v14 + 240);
      if ( v15 == -128 )
      {
        v16 = *(_WORD *)(a5 + 10);
        if ( v16 > 84 )
        {
          if ( v16 != 0x2000 )
            return v5;
        }
        else if ( v16 != 84 )
        {
          if ( v16 == 32 )
          {
            if ( !*(_DWORD *)a4 )
              return v5;
            v18 = *(_WORD *)(a2 + 8);
            if ( *(_WORD *)(a2 + 8) & 0x400 || (v18 & 0x3F) == 27 )
              return v5;
            v5 = sub_1003DE20(a4, a1, a2);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, *(_BYTE *)(a2 + 10));
            goto LABEL_50;
          }
          if ( v16 != 56 || *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 )
            return v5;
          v17 = sub_1003DE20(a4, a1, a2);
LABEL_49:
          v5 = v17;
LABEL_50:
          if ( v5 != 4 && v5 != 2 )
            return v5;
LABEL_52:
          sub_1003E150(a2, (int)a3);
          return v5;
        }
        v19 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v19 & 0x3F) == 27 )
          return v5;
LABEL_48:
        v17 = sub_1003DE90(a2, a1, a5);
        goto LABEL_49;
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 57 )
      {
        if ( v20 != 84 && v20 != 0x2000 )
          return v5;
        goto LABEL_48;
      }
      if ( v20 == 57 )
      {
        *(_WORD *)(v14 + 240) += *(_BYTE *)(a5 + 8);
        v26 = *(_DWORD *)(a1 + 56);
        v27 = *(_WORD *)(v26 + 240);
        v5 = 2;
        if ( v27 < 0 )
        {
          *(_WORD *)(v26 + 240) = 0;
          sub_1003E150(a2, (int)a3);
          return 2;
        }
        if ( v27 > *(_BYTE *)(a2 + 10) - 1 )
        {
          *(_WORD *)(v26 + 240) = (char)(*(_BYTE *)(a2 + 10) - 1);
          sub_1003E150(a2, (int)a3);
          return 2;
        }
        goto LABEL_52;
      }
      v21 = v20 - 32;
      if ( v21 )
      {
        v22 = v21 - 1;
        if ( v22 )
        {
          if ( v22 != 23 )
            return v5;
          v23 = *(_BYTE *)(a5 + 8);
          if ( v23 >= 0 )
          {
            if ( v23 <= 0 )
              return v5;
            if ( !(*(_BYTE *)(a2 + 8) & 0x40) || v15 )
            {
              v25 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v25 + 240) + v25 + 69) = sub_10064730(*(_BYTE *)(v15 + v14 + 69), 0x10u, 1);
              sub_1003E150(a2, (int)a3);
              result = 2;
            }
            else
            {
              *(_BYTE *)(v14 + 69) = 2 * (*(_BYTE *)(v14 + 69) != 45) + 43;
              sub_1003E150(a2, (int)a3);
              result = 2;
            }
          }
          else
          {
            v24 = *(_DWORD *)(a1 + 56);
            *(_BYTE *)(*(_WORD *)(v24 + 240) + v24 + 69) = sub_10064730(*(_BYTE *)(v15 + v24 + 69), 0x10u, -1);
            sub_1003E150(a2, (int)a3);
            result = 2;
          }
        }
        else
        {
          *(_WORD *)(v14 + 240) = -128;
          *(_DWORD *)a4 = j__atol((const char *)(*(_DWORD *)(a1 + 56) + 69));
          sub_1003DC30(a1, a2, (int)a3, a4);
          result = 3;
        }
      }
      else
      {
        *(_WORD *)(v14 + 240) = -128;
        sub_1003DC30(a1, a2, (int)a3, a4);
        result = 6;
      }
      return result;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1003DC30(a1, a2, (int)a3, a4);
        return v5;
      }
      sub_1003E150(a2, (int)a3);
      return 1;
    default:
      return v5;
  }
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (1003E660) --------------------------------------------------------
char __cdecl sub_1003E660(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // al@3
  __int16 v6; // dx@4
  __int16 v7; // ax@6
  signed __int16 v8; // cx@6
  __int16 v9; // dx@8
  __int16 v10; // bx@8
  __int16 v11; // bp@8
  __int16 v12; // ST2C_2@8
  int v13; // edx@8
  int v14; // ST28_4@8
  __int16 v16; // [sp+0h] [bp-10h]@6
  __int16 v17; // [sp+4h] [bp-Ch]@4

  if ( *a5 == -32734 || *a5 == -32648 )
  {
    v5 = *(_BYTE *)(a2 + 8);
    if ( v5 & 0x20 )
    {
      v6 = *(_WORD *)(a2 + 6);
      v17 = *(_WORD *)(a2 + 4);
    }
    else
    {
      v17 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
      v6 = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6);
    }
    v16 = v6;
    v7 = word_101CAB28[(unsigned __int8)sub_10065CD0(v5 & 0x1F)];
    v8 = 2;
    if ( (*(_BYTE *)(a2 + 8) & 0xC0) != 64 )
      v8 = 1;
    v9 = *(_WORD *)(a1 + 396);
    v10 = *(_WORD *)(a1 + 426);
    v11 = *(_WORD *)(a1 + 424);
    *(_WORD *)(a1 + 426) = v8;
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 428);
    *(_WORD *)(a1 + 424) = v8;
    *(_WORD *)(a1 + 428) = v7;
    *(_WORD *)(a1 + 430) = v7;
    v14 = v13;
    *(_WORD *)(a1 + 396) = 2;
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_10090620(a1 + 392, v17, v16, 2);
    *(_WORD *)(a1 + 426) = v10;
    *(_WORD *)(a1 + 424) = v11;
    *(_WORD *)(a1 + 396) = v12;
    *(_WORD *)(a1 + 428) = v14;
    *(_WORD *)(a1 + 430) = HIWORD(v14);
  }
  return 1;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003E7B0) --------------------------------------------------------
char __cdecl sub_1003E7B0(unsigned int a1, char a2, int a3)
{
  char result; // al@3
  char v4; // bl@3
  signed int v5; // ecx@4
  signed int v6; // ecx@7
  int v7; // ecx@11
  signed int v8; // ebx@12
  int v9; // ecx@13
  int v10; // ecx@16
  char v11; // [sp+Bh] [bp-51h]@3
  int v12; // [sp+Ch] [bp-50h]@1
  char v13; // [sp+10h] [bp-4Ch]@1
  char v14; // [sp+11h] [bp-4Bh]@22
  char v15; // [sp+16h] [bp-46h]@8
  int v16; // [sp+18h] [bp-44h]@12
  char v17; // [sp+1Ch] [bp-40h]@17

  sub_1004E100(a1, a2, (int)&v12);
  if ( v13 || sub_1004D100(a1) == byte_1031F9CA )
  {
    if ( v12 == 1000 )
      result = sub_100649E0(a3, &unk_100CFA74, 5);
    else
      result = sub_100649E0(a3, &v14, 5);
    return result;
  }
  result = sub_1004E3E0(a1);
  v4 = result;
  v11 = result;
  if ( result && (v5 = v12, v12 != 1000) )
  {
    *(_BYTE *)a3 = v12 / 10 + 48;
    result = 10 * (v5 / 10);
    *(_BYTE *)(a3 + 1) = v5 % 10 + 48;
  }
  else
  {
    *(_BYTE *)a3 = 95;
    *(_BYTE *)(a3 + 1) = 95;
  }
  v6 = 2;
  if ( v4 )
  {
    result = v15;
    if ( v15 != 95 && v15 != 32 )
    {
      *(_BYTE *)(a3 + 2) = v15;
      v6 = 3;
    }
  }
  *(_BYTE *)(a3 + v6) = 45;
  v7 = v6 + 1;
  if ( v4 )
  {
    v8 = v16;
    if ( v16 != 1000 )
    {
      *(_BYTE *)(a3 + v7) = v16 / 10 + 48;
      result = 10 * (v8 / 10);
      v9 = v7 + 1;
      *(_BYTE *)(a3 + v9) = v8 % 10 + 48;
      v4 = v11;
      goto LABEL_16;
    }
    v4 = v11;
  }
  *(_BYTE *)(a3 + v7) = 95;
  v9 = v7 + 1;
  *(_BYTE *)(a3 + v9) = 95;
LABEL_16:
  v10 = v9 + 1;
  if ( v4 )
  {
    result = v17;
    if ( v17 != 95 && v17 != 32 )
      *(_BYTE *)(a3 + v10++) = v17;
  }
  *(_BYTE *)(a3 + v10) = 0;
  return result;
}
// 1031F9CA: using guessed type char byte_1031F9CA;

//----- (1003E920) --------------------------------------------------------
double __cdecl sub_1003E920(unsigned __int8 a1)
{
  char v2; // [sp+4h] [bp-60h]@4
  float v3[10]; // [sp+Ch] [bp-58h]@2
  char v4; // [sp+34h] [bp-30h]@4
  float v5[10]; // [sp+3Ch] [bp-28h]@4

  if ( a1 )
    v3[4 * a1] = 15.433242;
  else
    v3[0] = 0.0;
  sub_1008CAC0(2026, &v4, 48, &v2);
  return v5[4 * a1];
}
// 1003E920: using guessed type float var_58[10];
// 1003E920: using guessed type float var_28[10];

//----- (1003E970) --------------------------------------------------------
char __cdecl sub_1003E970(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  char *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_1006ED10(*a4);
    v7 = sub_1004AB90(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_1004B470(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_1004AB20(v10);
    v11 = sub_1004AB50(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *(_DWORD *)v11;
    v24 = v12;
    v14 = sub_1004ABC0(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_1004B4D0(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_1004AB90(*(_DWORD *)(a2 + 4));
    v19 = *(_DWORD *)sub_1004AB50(*(_DWORD *)(a2 + 4));
    v20 = sub_1006ED10(*a4);
    v17 = sub_1008F880(v19, v20, v18);
  }
  sub_1004B6E0(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (1003EAA0) --------------------------------------------------------
void *__cdecl sub_1003EAA0(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (1003EAD0) --------------------------------------------------------
char __cdecl sub_1003EAD0(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_10064990((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_10064940((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (1003EB30) --------------------------------------------------------
int __cdecl sub_1003EB30(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_1004B470(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_1004B470(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (1003EC80) --------------------------------------------------------
char __usercall sub_1003EC80@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_1003EAD0(a4, a3, a1);
    sub_1003EAA0(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (1003ED40) --------------------------------------------------------
char __usercall sub_1003ED40@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_10064730(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_10064730(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_10064730(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (1003EDA0) --------------------------------------------------------
signed int __usercall sub_1003EDA0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_10064730(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_10064730(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_10064730(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_10064730(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_10064730(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (1003EF00) --------------------------------------------------------
signed int __cdecl sub_1003EF00(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_10063C20(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_1003EDA0(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (1003EF60) --------------------------------------------------------
char __cdecl sub_1003EF60(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_1004AB70(*(_DWORD *)(a2 + 4));
  v7 = sub_1004AB90(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_1004B470(v8, v23);
  v9 = sub_1004AB20(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_1004ABC0(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_1008F880(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_1004B7B0(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_10050060(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_100027C0(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_100500D0((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_1003EB30(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_102BA90E || byte_1031EB20) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_100916F0(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_1004B4D0(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_10002420(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_1004B430(a1, a4, &v25);
  }
  return v13;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 1031EB20: using guessed type char byte_1031EB20;

//----- (1003F1C0) --------------------------------------------------------
char __cdecl sub_1003F1C0(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_10063C20(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_1003EAD0(a1, v4, a4);
            sub_1003EAA0(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_1003EAD0(a1, v4, a4);
          return v9;
        }
        return sub_1003EC80(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_1003ED40(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_1003EC80(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_1003ED40(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_1003EC80(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_10064990((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_10064B70(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_1003EF00(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (1003F3B0) --------------------------------------------------------
char __cdecl sub_1003F3B0(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_1004B180(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *(_DWORD *)sub_1004AB50(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_1004B7B0(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_1003EB30(v5, a3, v9, v18, a2);
        sub_1004B6E0(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_1004B6E0(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_1003F1C0(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_1003EF60(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_1003EF60(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_1003EF60(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_1003EF60(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_1003EF60(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (1003F610) --------------------------------------------------------
char __cdecl sub_1003F610(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_101CAB28[1];
  v19 = word_101CAB28[0];
  v20 = word_101CAB28[0];
  v21 = word_101CAB28[0];
  v22 = word_101CAB28[0];
  v6 = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_100C5508;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_100903C0(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 101CAB24: using guessed type float flt_101CAB24;
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003F840) --------------------------------------------------------
char __cdecl sub_1003F840(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_101CAB28[(unsigned __int8)sub_10065CD0(v7)];
    v9 = word_101CAB28[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_101CAB28[(unsigned __int8)sub_10065CD0(v5 & 0x1F)];
    v9 = word_101CAB28[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_1003F610(a1, (int)&v13, a3, (int)&v11, a5);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1003F920) --------------------------------------------------------
int __cdecl sub_1003F920(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_1031F1F1[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_1031F1E4[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += *((_BYTE *)&unk_1031F1E0 + 20 * ((a1 >> 10) & 0xF) + 15) - byte_1031F1F1[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (1003F980) --------------------------------------------------------
char __cdecl sub_1003F980(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  char *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_1006D4B0(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = (char *)sub_1006C660(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_1004B1E0(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_1004AB50(v36);
      v44 += sub_1008F880(*((_DWORD *)v37 + 1), "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_1031F1E4[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_1003F920(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_1004B840(v38, &v57, v46, v40, v44, v39, v51);
}
// 100D1710: using guessed type __int16 word_100D1710;
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (1003FE80) --------------------------------------------------------
char __usercall sub_1003FE80@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_1006D4B0(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (1003FF60) --------------------------------------------------------
char __usercall sub_1003FF60@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_1006C620(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_1003FE80(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_1003FE80(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_1003FE80(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_1003FE80(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (10040A30) --------------------------------------------------------
char __usercall sub_10040A30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  const char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = (const char *)sub_1006C660(*(_WORD *)(a4 + 8), a2);
  v6 = sub_1004B1E0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_1031F1E4[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_1003F920(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_1004B840(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (10040AF0) --------------------------------------------------------
char __usercall sub_10040AF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_1003F980(a3, a1, a4, &v6);
}

//----- (10040B30) --------------------------------------------------------
char __cdecl sub_10040B30(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_1004B6E0(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_1003F920(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_1004B6E0((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_1004B1E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_1031F1E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_1003FE80(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_1003FE80(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_1003FF60(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_1003FF60(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_10040AF0(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_10040A30((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_1006C620(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_10064730(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_10064730(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_1006DAE0(v74, *(_WORD *)(a2 + 8));
      sub_10040AF0(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10040AF0(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_10040A30((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 1031F1E4: using guessed type int dword_1031F1E4[];

//----- (10041420) --------------------------------------------------------
int __usercall sub_10041420@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_100903C0(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_101CAB28[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_101CAB28[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_101CAB28[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_101CAB28[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_100903C0(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10041500) --------------------------------------------------------
char __cdecl sub_10041500(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_101CAB28[(unsigned __int8)sub_10065CD0(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_100903C0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_100903C0(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_100903C0(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_100903C0(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_100903C0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
      *(_WORD *)(a1 + 430) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
      *(_WORD *)(a1 + 440) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
      *(_WORD *)(a1 + 442) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
      sub_10041420(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_101CAB28[1];
      *(_WORD *)(a1 + 430) = word_101CAB28[1];
      *(_WORD *)(a1 + 440) = word_101CAB28[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_101CAB28[1];
      sub_100903C0(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_101CAB28[15];
      *(_WORD *)(a1 + 430) = word_101CAB28[14];
      sub_100903C0(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_101CAB28[13];
      *(_WORD *)(a1 + 430) = word_101CAB28[1];
      sub_100903C0(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_101CAB28[14];
      *(_WORD *)(a1 + 430) = word_101CAB28[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_100903C0(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_100903C0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_100903C0(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_100903C0(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_100903C0(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_100903C0(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_100903C0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_101CAB28[15];
        *(_WORD *)(a1 + 430) = word_101CAB28[15];
        *(_WORD *)(a1 + 440) = word_101CAB28[1];
        *(_WORD *)(a1 + 442) = word_101CAB28[1];
        sub_100903C0(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
    *(_WORD *)(a1 + 430) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
    *(_WORD *)(a1 + 440) = word_101CAB28[(unsigned __int8)sub_10065CD0(15)];
    v15 = sub_10065CD0(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_101CAB28[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_10041420(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_10041420(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10041AB0) --------------------------------------------------------
unsigned int __usercall sub_10041AB0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_1004FF00(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_1008EB80(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 1008BA14: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10041B60) --------------------------------------------------------
char __cdecl sub_10041B60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_10041AB0(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 1008BA14: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10041C00) --------------------------------------------------------
void __cdecl sub_10041C00(float a1, int a2, int a3, float a4, float a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  float v8; // ST2C_4@1
  double v9; // st7@1
  bool v10; // c0@1
  double v11; // st7@1
  float v12; // ST00_4@2
  double v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+4Ch] [bp+18h]@1

  v6 = a6;
  v7 = 0;
  v8 = a1 * 0.5 + *(float *)(a6 + 40);
  v14 = *(int *)(a6 + 36);
  v9 = v8;
  v13 = v9;
  v10 = *(float *)&v14 < v9;
  v11 = *(float *)&v14;
  if ( v10 )
  {
    do
    {
      v12 = v11;
      sub_10064F60(v12, (char *)a3, a4, a5, *(_WORD *)(v6 + 980), v6 + 1588, v7);
      v7 += a2;
      *(float *)&v14 = *(float *)&v14 + a1;
      v11 = *(float *)&v14;
    }
    while ( *(float *)&v14 < v13 );
  }
}

//----- (10041CA0) --------------------------------------------------------
char __cdecl sub_10041CA0(float a1, float a2, float a3, int a4)
{
  int v4; // esi@1
  double v5; // st7@1
  signed int v6; // ecx@2
  double v7; // st6@3
  char v8; // bl@4
  double v9; // st7@4
  double v10; // st6@7
  float v11; // ST28_4@10
  float v12; // ST00_4@10
  float v14; // [sp+28h] [bp-10h]@2
  float v15; // [sp+2Ch] [bp-Ch]@2
  double v16; // [sp+30h] [bp-8h]@4
  float v17; // [sp+40h] [bp+8h]@2
  int v18; // [sp+48h] [bp+10h]@4

  v4 = a4;
  v5 = a2;
  if ( a2 == 0.0 )
  {
    v6 = 0;
    v17 = 0.0;
    v14 = 0.5 * a1 + *(float *)(a4 + 40);
    v15 = a1;
  }
  else
  {
    v14 = v5 * 0.5 + *(float *)(a4 + 40);
    v15 = a2;
    v7 = a1 / v5;
    LODWORD(v17) = (signed int)(v7 + 0.5);
    v6 = (signed int)(v7 + 0.5);
  }
  v8 = 0;
  v18 = *(int *)(a4 + 36);
  v16 = v14;
  v9 = *(float *)&v18;
  if ( *(float *)&v18 < (double)v14 )
  {
    while ( 1 )
    {
      v10 = a3;
      if ( v6 && (unsigned __int8)v8 % v6 )
        v10 = v10 * 0.6000000238418579;
      v11 = v10;
      v12 = v9;
      sub_10065690(v12, v11, 1.0, v4 + 1588, (unsigned __int8)v8++, v4 + 1468);
      *(float *)&v18 = *(float *)&v18 + v15;
      v9 = *(float *)&v18;
      if ( *(float *)&v18 >= v16 )
        break;
      v6 = LODWORD(v17);
    }
  }
  *(_BYTE *)(v4 + 4788) = v8;
  return v8;
}

//----- (10041DB0) --------------------------------------------------------
char __cdecl sub_10041DB0(int a1, float a2, int a3)
{
  double v3; // st7@1
  signed int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // eax@2
  int v7; // ebx@2
  int v8; // esi@2
  float v9; // ST20_4@4
  double v10; // st6@7
  int v11; // eax@7
  int v12; // edx@7
  int v13; // ecx@7
  float v15; // [sp+1Ch] [bp-8h]@1
  float *v16; // [sp+30h] [bp+Ch]@2

  v3 = 0.0;
  v15 = 0.0;
  v4 = 0;
  v5 = a3;
  if ( *(_BYTE *)a1 )
  {
    LOBYTE(v6) = a3 + 96;
    v16 = (float *)(a3 + 608);
    v7 = a1 + 12;
    v8 = v5 + 1264;
    do
    {
      if ( v4 >= 10 )
      {
        *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
        return v6;
      }
      *(float *)(v8 + 8) = *(float *)(v5 + 1476) * a2;
      *(float *)v8 = *(float *)(v5 + 1468);
      *(float *)(v8 + 4) = *(float *)(v5 + 1472) - v15;
      v9 = sub_10065120(*(float *)v7, v5 + 1488, *(_BYTE *)(v5 + 1584));
      ++v4;
      v7 += 4;
      v8 += 20;
      *(float *)(v8 - 8) = -(v9 - v15);
      *(_DWORD *)(v8 - 4) = *(_DWORD *)(v7 + 36);
      *(v16 - 1) = *(float *)(v7 - 4);
      *(_BYTE *)v16 = *(_BYTE *)(a1 + v4 + 91);
      v15 = v9;
      v16 += 2;
      v6 = *(_BYTE *)a1;
    }
    while ( v4 < v6 );
    if ( v4 < 10 )
    {
      v3 = 0.0;
      goto LABEL_7;
    }
    LOBYTE(v6) = *(_BYTE *)a1;
    *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
  }
  else
  {
LABEL_7:
    v10 = 9.8999998e24;
    v11 = v5 + 20 * v4 + 1268;
    v12 = 10 - v4;
    v13 = v5 + 8 * v4 + 604;
    do
    {
      *(_DWORD *)(v11 + 12) = 0;
      *(float *)(v11 - 4) = v3;
      v11 += 20;
      *(float *)(v11 - 20) = v3;
      v13 += 8;
      --v12;
      *(float *)(v11 - 16) = v3;
      *(float *)(v11 - 12) = v3;
      *(_BYTE *)(v13 - 4) = 10;
      *(float *)(v13 - 8) = *(float *)&v10;
    }
    while ( v12 );
    LOBYTE(v6) = a1;
    *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
  }
  return v6;
}

//----- (10041F10) --------------------------------------------------------
int __cdecl sub_10041F10(int a1, int a2)
{
  return sub_10047B60(a1, a2 + 16);
}

//----- (10041F20) --------------------------------------------------------
int __cdecl sub_10041F20(int a1, char a2, float a3, int a4)
{
  int result; // eax@1
  double v5; // st7@1
  double v6; // st6@1
  unsigned __int8 v7; // bl@1
  float *v8; // ebp@2
  int v9; // esi@4
  double v10; // ST2C_8@4
  double v11; // st6@4
  double v12; // st5@6
  int v13; // ecx@6
  int v14; // [sp+1Ch] [bp-Ch]@1
  float v15; // [sp+34h] [bp+Ch]@4

  result = (unsigned __int8)a2;
  v5 = 1.0;
  v6 = 0.5;
  v7 = LOBYTE(a3);
  v14 = 0;
  if ( (signed int)(unsigned __int8)a2 > 0 )
  {
    v8 = (float *)(a1 + 8);
    do
    {
      if ( v7 >= 0x32u )
        break;
      v9 = (v7 << 6) + a4;
      *(float *)(v9 + 1588) = *(float *)(a4 + 1468);
      v10 = *(float *)(a4 + 1472);
      v15 = v10 - sub_10065120(*(v8 - 2), a4 + 1488, *(_BYTE *)(a4 + 1584));
      *(float *)(v9 + 1596) = v15;
      v11 = *(v8 - 1) * *(float *)(a4 + 1476);
      *(_DWORD *)(v9 + 1644) = -1;
      *(_BYTE *)(v9 + 1648) = 0;
      *(float *)(v9 + 1592) = v11 + *(float *)(v9 + 1588);
      *(float *)(((v7 + 25) << 6) + a4) = v15;
      *(float *)(v9 + 1604) = 1.0;
      sub_100649E0(v9 + 1624, v8, 7);
      *(float *)(v9 + 1608) = *(float *)(v9 + 1588);
      *(float *)(v9 + 1612) = *(float *)(v9 + 1596);
      result = v14 + 1;
      *(_DWORD *)(v9 + 1616) = 0;
      *(float *)(v9 + 1640) = 12.0;
      *(_DWORD *)(v9 + 1620) = -1;
      *(float *)(v9 + 1636) = 0.5;
      v8 += 4;
      ++v7;
      *(float *)(v9 + 1632) = 1.0;
      v6 = 0.5;
      v5 = 1.0;
      v14 = result;
    }
    while ( result < (unsigned __int8)a2 );
  }
  *(_BYTE *)(a4 + 4788) = v7;
  if ( v7 < 0x32u )
  {
    v12 = 0.0;
    result = (v7 << 6) + a4 + 1596;
    v13 = (unsigned __int8)(50 - v7);
    do
    {
      *(float *)(result - 8) = 0.0;
      *(_DWORD *)(result + 48) = 0;
      *(float *)result = 0.0;
      *(_BYTE *)(result + 52) = 1;
      *(float *)(result - 4) = 0.0;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result + 4) = 0.0;
      *(_DWORD *)(result + 20) = 0;
      *(_DWORD *)(result + 24) = -1;
      *(float *)(result + 8) = v5;
      result += 64;
      --v13;
      *(float *)(result - 52) = 0.0;
      *(float *)(result - 48) = 0.0;
      *(float *)(result - 24) = v6;
      *(float *)(result - 28) = v6;
      *(float *)(result - 20) = *(float *)&v12;
    }
    while ( v13 );
  }
  return result;
}

//----- (100420E0) --------------------------------------------------------
int __usercall sub_100420E0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4789) != 1 )
    result = sub_1006BF60(result + 1264, *(_BYTE *)(result + 1464));
  return result;
}

//----- (10042100) --------------------------------------------------------
char __usercall sub_10042100@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 4790) != 1 )
    LOBYTE(a1) = sub_100482F0(a4, a5, a2, a1 + 16, a3);
  return a1;
}

//----- (10042130) --------------------------------------------------------
void __usercall sub_10042130(int a1@<esi>, int a2, _WORD *a3)
{
  signed int v3; // ebp@2
  int *v4; // ebx@2
  float **v5; // edi@2
  float *v6; // ecx@3
  char v7; // ST34_1@5
  float v8; // ST38_4@10
  float *v9; // [sp+28h] [bp-Ch]@2

  if ( *(_BYTE *)(a1 + 4791) != 1 )
  {
    v3 = 0;
    v9 = (float *)(a1 + 488);
    v4 = (int *)(a1 + 1104);
    v5 = (float **)(a1 + 704);
    do
    {
      v6 = *v5;
      if ( *v5 )
      {
        if ( 9.8999998e24 == *v6 )
        {
          if ( *(_BYTE *)(a1 + 4790) == 1 || *(_BYTE *)(a1 + 973) == 1 )
            sub_1006A400((int)(v5 - 5));
        }
        else
        {
          v7 = sub_1006E1D0(*v6, a1 + 604, 10, (int)(v4 - 2));
          sub_1006E300(v7, v5 - 2, (int *)v5 - 3, *(_BYTE *)(a1 + 4791), *v4);
          if ( *(_BYTE *)(a1 + 978) == v3 )
            sub_10069340(a2, (int)(v5 - 5), *(_WORD *)(a1 + 980), *(_DWORD *)(a1 + 984), *(_BYTE *)(a1 + 988));
          else
            sub_10068AE0(a2, (int)(v5 - 5), *(_WORD *)(a1 + 980), *(_DWORD *)(a1 + 984), *(_BYTE *)(a1 + 988));
          if ( *a3 == -32648 || *a3 == -32734 )
          {
            v8 = (*(float *)(a2 + 300) - *(float *)(a2 + 292)) * 0.5 + *(float *)(a2 + 292);
            sub_10068320(v8, *v9, v8, *(float *)(a2 + 304), -1, 3.0, 113);
          }
        }
      }
      v9 += 5;
      ++v3;
      v4 += 7;
      v5 += 12;
    }
    while ( v3 < 6 );
  }
}

//----- (100422C0) --------------------------------------------------------
int __usercall sub_100422C0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4792) != 1 )
    result = sub_10069290(result + 1468);
  return result;
}

//----- (100422E0) --------------------------------------------------------
int __usercall sub_100422E0@<eax>(int result@<eax>, int a2@<edx>)
{
  if ( *(_BYTE *)(result + 4793) != 1 )
    result = sub_10069C80(a2, result + 1588, *(_BYTE *)(result + 4788), 0);
  return result;
}

//----- (10042310) --------------------------------------------------------
int __cdecl sub_10042310(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  double v8; // st7@1
  double v9; // st6@1
  double v10; // st3@1
  int v11; // ST1C_4@3
  float v12; // ST10_4@3
  double v13; // st4@3
  double v14; // st4@3
  double v15; // st4@3
  double v16; // st4@3
  double v17; // st4@3
  double v18; // st4@3
  double v19; // st4@3
  double v20; // st4@3
  double v21; // st4@3
  double v22; // st6@3
  float v24; // [sp+30h] [bp+10h]@1
  float v25; // [sp+30h] [bp+10h]@3
  int v26; // [sp+40h] [bp+20h]@3
  int v27; // [sp+40h] [bp+20h]@3
  float v28; // [sp+40h] [bp+20h]@3

  v8 = a4;
  *(float *)a1 = a4;
  v9 = a5;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  v24 = a6 / ((double)a8 + 4.0);
  v10 = v24;
  if ( v24 < 10.0 )
    v10 = (float)10.0;
  *(_BYTE *)(a1 + 1484) = 1;
  v25 = a6 - v10;
  v11 = a8;
  *(float *)(a1 + 1468) = v8;
  *(float *)(a1 + 1472) = v9 + a7;
  *(float *)(a1 + 1476) = v10;
  *(float *)(a1 + 1480) = a7;
  *(float *)(a1 + 1488) = 0.0;
  *(float *)(a1 + 1492) = 0.0;
  *(float *)(a1 + 1496) = 1.0;
  *(float *)(a1 + 1508) = 1.0;
  *(float *)(a1 + 1520) = 1.0;
  *(float *)(a1 + 1532) = 1.0;
  *(float *)(a1 + 1544) = 1.0;
  *(float *)(a1 + 1556) = 1.0;
  *(float *)(a1 + 1568) = 1.0;
  *(float *)(a1 + 1580) = 1.0;
  *(float *)(a1 + 1500) = 0.0;
  *(float *)(a1 + 1504) = 0.0;
  *(float *)(a1 + 1512) = 0.0;
  *(float *)(a1 + 1516) = 0.0;
  *(float *)(a1 + 1524) = 0.0;
  *(float *)(a1 + 1528) = 0.0;
  *(float *)(a1 + 1536) = 0.0;
  *(float *)(a1 + 1540) = 0.0;
  *(float *)(a1 + 1548) = 0.0;
  *(float *)(a1 + 1552) = 0.0;
  *(float *)(a1 + 1560) = 0.0;
  *(float *)(a1 + 1564) = 0.0;
  *(float *)(a1 + 1572) = 0.0;
  *(float *)(a1 + 1576) = 0.0;
  *(_BYTE *)(a1 + 1584) = 2;
  *(float *)(a1 + 1488) = *(float *)(a3 + 4);
  *(float *)(a1 + 1500) = *(float *)(a3 + 8);
  *(float *)(a1 + 1492) = 0.0;
  *(float *)(a1 + 1504) = a7;
  v12 = v9;
  *(float *)&v26 = v10 + v8;
  sub_100483D0(a1 + 16, a2, a3, *(float *)&v26, v12, v25, a7, v11);
  *(float *)(a1 + 684) = *(float *)(a1 + 172);
  *(_DWORD *)(a1 + 692) = 0;
  *(_DWORD *)(a1 + 696) = -1;
  *(_DWORD *)(a1 + 700) = -1;
  *(float *)(a1 + 708) = *(float *)(a3 + 4);
  *(float *)(a1 + 712) = *(float *)(a3 + 8);
  *(float *)(a1 + 716) = 0.5;
  *(float *)(a1 + 720) = 1.0;
  *(_DWORD *)(a1 + 704) = 0;
  *(float *)(a1 + 724) = 15.0;
  v13 = *(float *)(a1 + 224);
  *(_DWORD *)(a1 + 740) = 0;
  *(float *)(a1 + 732) = v13;
  *(_DWORD *)(a1 + 744) = -1;
  *(_DWORD *)(a1 + 748) = -1;
  *(float *)(a1 + 756) = *(float *)(a3 + 4);
  v14 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 752) = 0;
  *(float *)(a1 + 760) = v14;
  *(float *)(a1 + 764) = 0.5;
  *(float *)(a1 + 768) = 1.0;
  *(float *)(a1 + 772) = 15.0;
  v15 = *(float *)(a1 + 276);
  *(_DWORD *)(a1 + 788) = 0;
  *(float *)(a1 + 780) = v15;
  *(_DWORD *)(a1 + 792) = -1;
  *(_DWORD *)(a1 + 796) = -1;
  *(float *)(a1 + 804) = *(float *)(a3 + 4);
  v16 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 800) = 0;
  *(float *)(a1 + 808) = v16;
  *(float *)(a1 + 812) = 0.5;
  *(float *)(a1 + 816) = 1.0;
  *(float *)(a1 + 820) = 15.0;
  v17 = *(float *)(a1 + 328);
  *(_DWORD *)(a1 + 836) = 0;
  *(float *)(a1 + 828) = v17;
  *(_DWORD *)(a1 + 840) = -1;
  *(_DWORD *)(a1 + 844) = -1;
  *(float *)(a1 + 852) = *(float *)(a3 + 4);
  v18 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 848) = 0;
  *(float *)(a1 + 856) = v18;
  *(float *)(a1 + 860) = 0.5;
  *(float *)(a1 + 864) = 1.0;
  *(float *)(a1 + 868) = 15.0;
  v19 = *(float *)(a1 + 380);
  *(_DWORD *)(a1 + 884) = 0;
  *(float *)(a1 + 876) = v19;
  *(_DWORD *)(a1 + 888) = -1;
  *(_DWORD *)(a1 + 892) = -1;
  *(float *)(a1 + 900) = *(float *)(a3 + 4);
  v20 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 896) = 0;
  *(float *)(a1 + 904) = v20;
  *(float *)(a1 + 908) = 0.5;
  *(float *)(a1 + 912) = 1.0;
  *(float *)(a1 + 916) = 15.0;
  v21 = *(float *)(a1 + 432);
  *(_DWORD *)(a1 + 932) = 0;
  *(float *)(a1 + 924) = v21;
  *(_DWORD *)(a1 + 936) = -1;
  *(_DWORD *)(a1 + 940) = -1;
  *(float *)(a1 + 948) = *(float *)(a3 + 4);
  *(float *)(a1 + 952) = *(float *)(a3 + 8);
  *(float *)(a1 + 956) = 0.5;
  *(float *)(a1 + 960) = 1.0;
  *(_DWORD *)(a1 + 944) = 0;
  *(float *)(a1 + 964) = 15.0;
  *(float *)&v27 = a5 - 4.0;
  *(float *)(a1 + 688) = *(float *)&v27;
  v22 = *(float *)&v27;
  v28 = a5 - 30.0;
  *(float *)(a1 + 736) = v28;
  *(float *)(a1 + 832) = v28;
  *(float *)(a1 + 928) = v28;
  *(float *)(a1 + 784) = *(float *)&v22;
  *(float *)(a1 + 880) = *(float *)&v22;
  *(_DWORD *)(a1 + 4789) = 0;
  *(_BYTE *)(a1 + 4793) = 0;
  *(_BYTE *)(a1 + 976) = 1;
  sub_10041DB0(a3, 0.5, a1);
  return sub_10041F20(0, 0, 0.0, a1);
}

//----- (100426F0) --------------------------------------------------------
char __cdecl sub_100426F0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_100420E0(a4);
      sub_100422C0(a4);
      sub_100422E0(a4, a1);
      sub_10042130(a4, a1, a5);
      sub_10042100(a4, a3, a5, a1, a2);
      break;
    case 0x8015:
    case 0x8016:
      sub_10042130(a4, a1, a5);
      sub_10042100(a4, a3, a5, a1, a2);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (100427E0) --------------------------------------------------------
int __cdecl sub_100427E0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_10042310(a1, a2, a3, a4, a5, a6, a7, 6);
}

//----- (10042820) --------------------------------------------------------
int __cdecl sub_10042820(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st5@1
  float v10; // ST20_4@1
  int result; // eax@1
  float v12; // [sp+28h] [bp+10h]@1
  float v13; // [sp+30h] [bp+18h]@1
  float v14; // [sp+34h] [bp+1Ch]@1

  v7 = a7;
  v14 = a7 * 0.8500000238418579;
  v8 = a6;
  v13 = 0.8500000238418579 * a6;
  v9 = a4;
  v10 = v8 * 0.07500000298023224 + a4;
  v12 = 0.07500000298023224 * v7 + a5;
  *(float *)a1 = v9;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = v8;
  *(float *)(a1 + 12) = v7;
  *(_WORD *)(a1 + 5616) = 0;
  result = sub_10061B00(a1 + 16, a2, a3, v10, v12, v13, v14);
  *(_DWORD *)(a1 + 5612) = 60;
  return result;
}

//----- (100428D0) --------------------------------------------------------
int __cdecl sub_100428D0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st5@1
  float v10; // ST20_4@1
  int result; // eax@1
  float v12; // [sp+28h] [bp+10h]@1
  float v13; // [sp+30h] [bp+18h]@1
  float v14; // [sp+34h] [bp+1Ch]@1

  v7 = a7;
  v14 = a7 * 0.8500000238418579;
  v8 = a6;
  v13 = 0.8500000238418579 * a6;
  v9 = a4;
  v10 = v8 * 0.07500000298023224 + a4;
  v12 = 0.07500000298023224 * v7 + a5;
  *(float *)a1 = v9;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = v8;
  *(float *)(a1 + 12) = v7;
  *(_WORD *)(a1 + 5616) = 0;
  result = sub_10061E10(a1 + 16, a2, a3, v10, v12, v13, v14);
  *(_DWORD *)(a1 + 5612) = 60;
  return result;
}

//----- (10042980) --------------------------------------------------------
void __cdecl sub_10042980(_BYTE *a1, int a2)
{
  sub_10060E40(a1, a2 + 16);
}

//----- (10042990) --------------------------------------------------------
int __cdecl sub_10042990(int a1, int a2)
{
  return sub_10060F80(a1, a2 + 16);
}

//----- (100429A0) --------------------------------------------------------
int __cdecl sub_100429A0(int a1, char a2, float a3, int a4)
{
  return sub_100612A0(a1, a2, a3, a4 + 16);
}

//----- (100429B0) --------------------------------------------------------
char __usercall sub_100429B0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 5616) != 1 )
    LOBYTE(a1) = sub_10062070(a4, a5, a2, a1 + 16, a3);
  return a1;
}

//----- (100429E0) --------------------------------------------------------
int __usercall sub_100429E0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 5617) != 1 )
    result = sub_10067EE0(
               *(float *)result,
               *(float *)(result + 4),
               *(float *)(result + 8),
               *(float *)(result + 12),
               *(_DWORD *)(result + 5612));
  return result;
}

//----- (10042A20) --------------------------------------------------------
char __cdecl sub_10042A20(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_100429E0(a4);
      sub_100429B0(a4, a3, a5, a1, a2);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_100429B0(a4, a3, a5, a1, a2);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10042B00) --------------------------------------------------------
double __cdecl sub_10042B00(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (10042B20) --------------------------------------------------------
double __cdecl sub_10042B20(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 <= (double)a1 )
    result = a2;
  return result;
}

//----- (10042B40) --------------------------------------------------------
void __cdecl sub_10042B40(float a1, char *a2, float a3, float a4, int a5, int a6)
{
  int v6; // eax@1
  float *v7; // ebx@1
  float *v8; // edi@1
  int v9; // esi@1
  double v10; // st7@3
  int v11; // edx@3
  double v12; // st7@3
  double v13; // st7@3
  char v14; // [sp+47h] [bp-9h]@3
  double v15; // [sp+48h] [bp-8h]@3

  v6 = a6;
  v7 = flt_100D3940;
  v8 = (float *)(a6 + 11052);
  v9 = (a5 << 6) + a6 + 1356;
  while ( 1 )
  {
    v10 = sub_1006D0E0(SLODWORD(a1), *(_WORD *)(v6 + 11450), *(_BYTE *)(v6 + 11456), &v14);
    sub_10064B00((char *)(v9 + 12), 7u, a2, v10 * a3);
    v11 = *(_BYTE *)v8;
    v15 = *(v8 - 28);
    v12 = sub_10065120(a1, (int)(v8 - 24), v11);
    ++v7;
    v8 += 30;
    *(float *)v9 = v15 - v12;
    v9 += 3200;
    *(float *)(v9 - 3176) = 0.5;
    v13 = *(v7 - 1);
    *(_DWORD *)(v9 - 3196) = 0;
    *(float *)(v9 - 3180) = v13;
    *(_DWORD *)(v9 - 3192) = -1;
    *(float *)(v9 - 3172) = a4;
    if ( (signed int)v7 >= (signed int)byte_100D394C )
      break;
    v6 = a6;
  }
}
// 100D3940: using guessed type float flt_100D3940[];

//----- (10042C30) --------------------------------------------------------
void __cdecl sub_10042C30(float a1, char *a2, float a3, float a4, int a5)
{
  int v5; // esi@1
  double v6; // st7@1
  float *v7; // edi@1
  double v8; // st7@1
  double v9; // st7@3
  int v10; // ST04_4@4
  double v11; // st7@4
  int v12; // edx@4
  double v13; // st7@4
  double v14; // st7@4
  bool v15; // zf@6
  char v16; // [sp+33h] [bp-1Dh]@4
  float v17; // [sp+34h] [bp-1Ch]@2
  int v18; // [sp+38h] [bp-18h]@1
  signed int v19; // [sp+3Ch] [bp-14h]@1
  double v20; // [sp+40h] [bp-10h]@4
  double v21; // [sp+48h] [bp-8h]@1

  v5 = a5 + 1356;
  v6 = a1 * 0.5 + *(float *)(a5 + 24);
  v18 = a5 + 1356;
  v7 = (float *)(a5 + 11052);
  *(float *)&v19 = v6;
  v8 = *(float *)&v19;
  v19 = 3;
  v21 = v8;
  do
  {
    v17 = *(float *)(a5 + 20);
    if ( v17 < v8 )
    {
      v9 = v17;
      do
      {
        *(float *)&v10 = v9;
        v11 = sub_1006D0E0(v10, *(_WORD *)(a5 + 11450), *(_BYTE *)(a5 + 11456), &v16);
        sub_10064B00((char *)(v5 + 12), 7u, a2, v11 * a3);
        v12 = *(_BYTE *)v7;
        v20 = *(v7 - 28);
        v13 = sub_10065120(v17, (int)(v7 - 24), v12);
        v14 = v20 - v13;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)(v5 + 8) = -1;
        *(float *)v5 = v14;
        v5 += 64;
        *(float *)(v5 - 40) = 0.5;
        *(float *)(v5 - 36) = a4;
        v17 = v17 + a1;
        v9 = v17;
      }
      while ( v21 > v17 );
      v8 = v21;
    }
    v5 = v18 + 3200;
    v7 += 30;
    v15 = v19-- == 1;
    v18 += 3200;
  }
  while ( !v15 );
}

//----- (10042D60) --------------------------------------------------------
void __cdecl sub_10042D60(int a1, signed int a2, char a3, int a4)
{
  signed int v4; // esi@1
  int *v5; // edi@2
  int v6; // eax@2
  int *v7; // ecx@2

  v4 = 0;
  if ( a2 > 0 )
  {
    v5 = (int *)(a4 + 11316);
    v6 = a1 + 8;
    v7 = (int *)(a4 + 40);
    do
    {
      if ( v4 >= 3 )
        break;
      *(v7 - 3) = v6 - 4;
      *v7 = v6;
      if ( a3 )
        *v5 = v6;
      ++v4;
      ++v7;
      v6 += 12;
      v5 += 12;
    }
    while ( v4 < a2 );
  }
}

//----- (10042DB0) --------------------------------------------------------
int __cdecl sub_10042DB0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 11320) = *(float *)a1;
  *(float *)(a2 + 11324) = *(float *)(a1 + 4);
  *(float *)(a2 + 11368) = *(float *)a1;
  *(float *)(a2 + 11372) = *(float *)(a1 + 4);
  *(float *)(a2 + 11416) = *(float *)a1;
  *(float *)(a2 + 11420) = *(float *)(a1 + 4);
  return result;
}

//----- (10042DF0) --------------------------------------------------------
int __usercall sub_10042DF0@<eax>(int a1@<edx>, int a2@<ebx>, float a3, float a4, int a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // ST18_4@1
  int v8; // esi@1
  double v9; // ST1C_8@1
  int result; // eax@1
  double v11; // st7@1
  double v12; // st7@1
  int v13; // [sp+30h] [bp+Ch]@1

  v5 = a5;
  v13 = SLODWORD(flt_100D3934[a2]);
  v6 = v5 + 120 * a2;
  v7 = 50 * a2 + a1;
  v8 = (v7 << 6) + v5;
  *(float *)(v8 + 1332) = *(float *)(v6 + 10936);
  v9 = *(float *)(v6 + 10940);
  *(float *)(v8 + 1340) = v9 - sub_10065120(a3, v6 + 10956, *(_BYTE *)(v6 + 11052));
  result = 0;
  v11 = *(float *)&v13 * a4 * *(float *)(v6 + 10944);
  *(_DWORD *)(v8 + 1388) = -1;
  *(_BYTE *)(v8 + 1392) = 0;
  *(_DWORD *)(v8 + 1360) = 0;
  v12 = v11 + *(float *)(v8 + 1332);
  *(_DWORD *)(v8 + 1364) = -1;
  *(float *)(v8 + 1336) = v12;
  *(float *)(((v7 + 21) << 6) + v5) = *(float *)(v8 + 1340);
  *(float *)(v8 + 1348) = 1.0;
  *(float *)(v8 + 1356) = *(float *)(v8 + 1340);
  *(float *)(v8 + 1384) = 9.0;
  *(float *)(v8 + 1380) = 0.5;
  *(float *)(v8 + 1376) = flt_100D3940[a2];
  return result;
}
// 100D3934: using guessed type float flt_100D3934[];
// 100D3940: using guessed type float flt_100D3940[];

//----- (10042EF0) --------------------------------------------------------
int __usercall sub_10042EF0@<eax>(int a1@<esi>, float a2, float a3, float a4, int a5)
{
  int v5; // ebp@1
  double v6; // st7@1
  signed int v7; // ecx@2
  double v8; // st6@3
  char v9; // bl@4
  double v10; // st7@4
  double v11; // st6@7
  float v12; // ST28_4@10
  float v13; // ST28_4@10
  float v14; // ST00_4@10
  signed int v16; // [sp+24h] [bp-18h]@2
  float v17; // [sp+28h] [bp-14h]@2
  float v18; // [sp+2Ch] [bp-10h]@2
  float v19; // [sp+30h] [bp-Ch]@1
  double v20; // [sp+34h] [bp-8h]@4
  float v21; // [sp+44h] [bp+8h]@4

  v5 = a5;
  v19 = flt_100D3934[a5];
  v6 = a3;
  if ( a3 == 0.0 )
  {
    v7 = 0;
    v16 = 0;
    v17 = 0.5 * a2 + *(float *)(a1 + 24);
    v18 = a2;
  }
  else
  {
    v17 = v6 * 0.5 + *(float *)(a1 + 24);
    v18 = a3;
    v8 = a2 / v6;
    v16 = (signed int)(v8 + 0.5);
    v7 = (signed int)(v8 + 0.5);
  }
  v9 = 0;
  v21 = *(float *)(a1 + 20);
  v20 = v17;
  v10 = v21;
  if ( v21 < (double)v17 )
  {
    while ( 1 )
    {
      v11 = a4;
      if ( v7 && (unsigned __int8)v9 % v7 )
        v11 = v11 * 0.6000000238418579;
      v12 = v11;
      v13 = v12 * v19;
      v14 = v10;
      sub_10065690(v14, v13, 1.0, a1 + 3200 * a5 + 1332, (unsigned __int8)v9++, a1 + 120 * a5 + 10936);
      v21 = v21 + v18;
      v10 = v21;
      if ( v21 >= v20 )
        break;
      v7 = v16;
    }
    v5 = a5;
  }
  *(_BYTE *)(a1 + v5 + 10932) = v9;
  return (unsigned __int8)v9;
}
// 100D3934: using guessed type float flt_100D3934[];

//----- (10043030) --------------------------------------------------------
int __usercall sub_10043030@<eax>(int a1@<esi>)
{
  unsigned __int8 v1; // bl@2
  int result; // eax@4

  if ( *(_BYTE *)(a1 + 11440) != 1 )
  {
    v1 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      do
      {
        if ( v1 >= 3u )
          break;
        result = sub_1006BF60(200 * v1 + a1 + 728, *(_BYTE *)(v1 + a1 + 1328));
        ++v1;
      }
      while ( v1 < *(_BYTE *)(a1 + 52) );
    }
  }
  return result;
}

//----- (10043080) --------------------------------------------------------
void __usercall sub_10043080(int a1@<esi>)
{
  signed int v1; // ebp@2
  float *v2; // ecx@4
  int v3; // edi@6
  float *v4; // ebx@6
  double v5; // st7@7
  float v6; // ST2C_4@9
  double v7; // st7@9
  double v8; // st6@9
  double v9; // st7@11
  float v10; // ST2C_4@13
  float v11; // ST2C_4@15
  char v12; // ST38_1@15
  int v13; // edi@15
  float v14; // ST30_4@23
  float v15; // ST14_4@23
  float v16; // ST30_4@23
  int v17; // ecx@25
  float v18; // ST30_4@29
  float v19; // ST30_4@34
  float v20; // ST30_4@34
  float v21; // ST30_4@34
  float v22; // ST1C_4@34
  float v23; // ST30_4@34
  float v24; // ST1C_4@34
  float v25; // ST30_4@34
  float v26; // ST30_4@34
  float v27; // ST30_4@34
  float v28; // ST30_4@34
  double v29; // st7@34
  float v30; // ST30_4@35
  float v31; // ST30_4@35
  float v32; // ST30_4@35
  float v33; // ST1C_4@35
  float v34; // ST30_4@35
  float v35; // ST1C_4@35
  float v36; // ST30_4@35
  float v37; // ST30_4@35
  float v38; // ST30_4@35
  float v39; // ST30_4@35
  float v40; // ST18_4@36
  float *v41; // eax@40
  double v42; // ST30_8@42
  float v43; // ST2C_4@42
  int v44; // ST40_4@42
  float v45; // ST18_4@42
  double v46; // st6@43
  int v47; // ST40_4@44
  float v48; // [sp+Ch] [bp-34h]@33
  float v49; // [sp+10h] [bp-30h]@33
  int v50; // [sp+14h] [bp-2Ch]@20
  int v51; // [sp+14h] [bp-2Ch]@29
  float v52; // [sp+14h] [bp-2Ch]@33
  float v53; // [sp+14h] [bp-2Ch]@34
  float v54; // [sp+24h] [bp-1Ch]@6
  float v55; // [sp+24h] [bp-1Ch]@25
  float v56; // [sp+24h] [bp-1Ch]@42
  float v57; // [sp+28h] [bp-18h]@7
  float v58; // [sp+28h] [bp-18h]@11
  float v59; // [sp+28h] [bp-18h]@25
  float v60; // [sp+28h] [bp-18h]@27
  int v61; // [sp+38h] [bp-8h]@6
  char v62; // [sp+3Ch] [bp-4h]@15

  if ( *(_BYTE *)(a1 + 11441) != 1 )
  {
    v1 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      while ( 1 )
      {
        if ( v1 >= 3 )
          return;
        v2 = *(float **)(a1 + 4 * v1 + 28);
        if ( v2 )
        {
          if ( 9.8999998e24 != *v2 )
            break;
        }
LABEL_45:
        if ( ++v1 >= *(_BYTE *)(a1 + 52) )
          return;
      }
      v3 = a1 + 120 * v1;
      v61 = v3 + 10956;
      v54 = sub_10065120(*v2, v3 + 10956, *(_BYTE *)(a1 + 120 * v1 + 11052));
      v4 = (float *)(a1 + 4 * (5 * v1 + 110));
      *v4 = v54;
      if ( *(_BYTE *)(a1 + 11644) )
      {
        v58 = v54 * -1.0;
        *v4 = v58;
        v9 = 0.0;
        if ( v58 < 0.0 )
          v9 = v58;
        v10 = v9;
        v7 = v10;
        *v4 = v10;
        v8 = *(float *)(v3 + 10948);
        if ( v8 < v10 )
          goto LABEL_15;
      }
      else
      {
        v57 = *(float *)(v3 + 10948);
        v5 = v54;
        if ( v57 <= (double)v54 )
          v5 = v57;
        v6 = v5;
        v7 = v6;
        *v4 = v6;
        v8 = 0.0;
        if ( v6 > 0.0 )
          goto LABEL_15;
      }
      v7 = v8;
LABEL_15:
      v11 = v7;
      *v4 = v11;
      v12 = sub_1006E1D0(**(float **)(a1 + 4 * v1 + 40), 80 * v1 + a1 + 488, 10, a1 + 28 * v1 + 11460);
      v13 = a1 + 20 * v1;
      sub_1006E2C0(v12, &v62, (_DWORD *)(v13 + 444), *(_BYTE *)(a1 + 11441));
      switch ( *(_BYTE *)(a1 + 11544) )
      {
        case 1:
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_100674D0(v13 + 428);
          else
            sub_10069BD0(v13 + 428);
          break;
        case 2:
          sub_10067700(v13 + 428);
          break;
        case 4:
          v50 = v13 + 428;
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_100674D0(v50);
          else
            sub_10069BD0(v50);
          v14 = *(float *)(v13 + 432) - *v4;
          v15 = v14;
          v16 = *(float *)(v13 + 436) + *(float *)(v13 + 428) + 1.0;
          sub_10067FF0(
            *(float *)(v13 + 428),
            *(float *)(v13 + 432),
            v16,
            v15,
            *(_DWORD *)(a1 + 11648),
            *(float *)(a1 + 11652));
          break;
        case 3:
          if ( *v4 < 0.0 )
          {
            *(float *)(32 * v1 + a1 + 11572) = 90.0;
            v17 = a1 + 32 * v1;
            v60 = *(float *)(v17 + 11556) + 1.0 + *v4;
            *v4 = v60;
            v55 = 1.0;
            if ( v60 > 0.0 )
            {
              v55 = v60;
              *v4 = 0.0;
            }
          }
          else
          {
            *(float *)(32 * v1 + a1 + 11572) = 270.0;
            v17 = 32 * v1 + a1;
            v59 = *v4 - (*(float *)(v17 + 11556) - 1.0);
            *v4 = v59;
            v55 = -1.0;
            if ( v59 < 0.0 )
            {
              v55 = v59;
              *v4 = 0.0;
            }
          }
          v18 = *(float *)(v13 + 432) - *v4 - v55;
          *(float *)(32 * (v1 + 361) + a1) = v18;
          sub_100671C0(v17 + 11548);
          v51 = v13 + 428;
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_100674D0(v51);
          else
            sub_10069BD0(v51);
          if ( 0.0 != *v4 )
          {
            j_gdi_pvg_enable(35);
            j_gdi_pvg_color_u32(-16777216);
            j_gdi_pvg_begin(64);
            v52 = *(float *)(v13 + 432);
            v49 = 1.0;
            v48 = *(float *)(v13 + 428);
            if ( *(_BYTE *)(a1 + 11644) )
            {
              v30 = sub_10095740(v48, v49) + 1.0;
              sub_1008C2F0(v30, v52);
              v31 = *(float *)(v13 + 432) - *v4;
              v32 = sub_100956A0(v31, 1.0) - 1.0;
              v33 = v32;
              v34 = sub_10095740(*(float *)(v13 + 428), 1.0) + 1.0;
              sub_1008C2F0(v34, v33);
              v35 = *(float *)(v13 + 432);
              v36 = sub_10095740(*(float *)(v13 + 428), 1.0) + *(float *)(v13 + 436);
              sub_1008C2F0(v36, v35);
              v37 = *(float *)(v13 + 432) - *v4;
              v38 = sub_100956A0(v37, 1.0) - 1.0;
              v53 = v38;
              v39 = sub_10095740(*(float *)(v13 + 428), 1.0) + *(float *)(v13 + 436);
              v29 = v39;
            }
            else
            {
              v19 = sub_10095740(v48, v49) + 1.0;
              sub_1008C2F0(v19, v52);
              v20 = *(float *)(v13 + 432) - *v4;
              v21 = sub_10095740(v20, 1.0) + 1.0;
              v22 = v21;
              v23 = sub_10095740(*(float *)(v13 + 428), 1.0) + 1.0;
              sub_1008C2F0(v23, v22);
              v24 = *(float *)(v13 + 432);
              v25 = sub_10095740(*(float *)(v13 + 428), 1.0) + *(float *)(v13 + 436);
              sub_1008C2F0(v25, v24);
              v26 = *(float *)(v13 + 432) - *v4;
              v27 = sub_10095740(v26, 1.0) + 1.0;
              v53 = v27;
              v28 = sub_10095740(*(float *)(v13 + 428), 1.0) + *(float *)(v13 + 436);
              v29 = v28;
            }
            v40 = v29;
            sub_1008C2F0(v40, v53);
            j_gdi_pvg_end();
            j_gdi_pvg_disable(35);
          }
          break;
        default:
          if ( v1 == 2 )
            sub_10067700(a1 + 468);
          else
            sub_100698D0(v13 + 428);
          break;
      }
      v41 = *(float **)(a1 + 4 * v1 + 56);
      if ( v41 && *(_BYTE *)(a1 + 11443) != 1 )
      {
        v42 = *(float *)(v13 + 432);
        v43 = v42 - sub_10065120(*v41, v61, *(_BYTE *)(a1 + 120 * v1 + 11052));
        *(float *)&v44 = *(float *)(v13 + 432) - *(float *)(a1 + 12);
        v45 = sub_10042B20(*(float *)(v13 + 432), v43);
        v56 = sub_10042B00(v45, *(float *)&v44);
        if ( *(_BYTE *)(a1 + 11644) == 1 )
        {
          v46 = *(float *)(v13 + 432) - v56;
          v56 = v56 + v46 + v46;
        }
        *(float *)&v47 = *(float *)(v13 + 436) + *(float *)(v13 + 436);
        sub_100689C0(*(float *)(v13 + 428), v56, *(float *)&v47, -16711681);
      }
      goto LABEL_45;
    }
  }
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10043770) --------------------------------------------------------
void __cdecl sub_10043770(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // edi@1
  float **v4; // ebx@1
  int v5; // ebp@1
  char v6; // ST40_1@3
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 280;
  v3 = (int *)(a2 + 11468);
  v4 = (float **)(a2 + 40);
  v5 = a2 + 488;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v6 = sub_1006E1D0(**v4, v5, 10, (int)(v3 - 2));
      sub_1006E390(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 11442), *v3);
      sub_1006BEC0(a1, v2 - 8);
    }
    ++v4;
    v5 += 80;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (10043800) --------------------------------------------------------
void __usercall sub_10043800(int a1@<edi>, int a2)
{
  int *v2; // ebp@1
  float **v3; // ebx@1
  int v4; // esi@1
  char v5; // ST4C_1@6
  int v6; // [sp+1Ch] [bp-Ch]@1
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = (int *)(a1 + 11468);
  v3 = (float **)(a1 + 40);
  v6 = a1 + 488;
  v4 = a1 + 11316;
  v7 = 3;
  do
  {
    if ( *(_DWORD *)v4 && (9.8999998e24 != **(float **)v4 || *(_BYTE *)(v4 + 26)) && *(_BYTE *)(a1 + 11444) != 1 )
    {
      v5 = sub_1006E1D0(**v3, v6, 10, (int)(v2 - 2));
      sub_1006E300(v5, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 11444), *v2);
      sub_10068AE0(a2, v4 - 20, *(_WORD *)(a1 + 11450), *(_DWORD *)(a1 + 11452), *(_BYTE *)(a1 + 11456));
    }
    v6 += 80;
    ++v3;
    v2 += 7;
    v4 += 48;
    --v7;
  }
  while ( v7 );
}

//----- (100438E0) --------------------------------------------------------
signed int __usercall sub_100438E0@<eax>(int a1@<ebx>)
{
  signed int v1; // esi@2
  int v2; // edi@3
  signed int result; // eax@5

  if ( *(_BYTE *)(a1 + 11445) != 1 )
  {
    v1 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      v2 = a1 + 10936;
      do
      {
        if ( v1 >= 3 )
          break;
        sub_10069290(v2);
        result = *(_BYTE *)(a1 + 52);
        ++v1;
        v2 += 120;
      }
      while ( v1 < result );
    }
  }
  return result;
}

//----- (10043920) --------------------------------------------------------
void __cdecl sub_10043920(int a1)
{
  int v1; // ebp@1
  signed int v2; // ebx@2
  int v3; // edi@2
  int v4; // esi@2
  float *v5; // ecx@3
  double v6; // st7@5
  char v7; // al@5
  float v8; // ST30_4@6
  float v9; // ST08_4@6
  float v10; // ST08_4@8
  float v11; // ST30_4@9
  float *v12; // [sp+2Ch] [bp-Ch]@2
  double v13; // [sp+30h] [bp-8h]@5
  float v14; // [sp+3Ch] [bp+4h]@5
  float v15; // [sp+3Ch] [bp+4h]@6
  float v16; // [sp+3Ch] [bp+4h]@8

  v1 = a1;
  if ( *(_BYTE *)(a1 + 11446) != 1 )
  {
    v2 = 0;
    v3 = a1 + 10936;
    v4 = a1 + 76;
    v12 = (float *)(a1 + 432);
    do
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && 9.8999998e24 != *v5 )
      {
        v13 = *v12;
        v6 = sub_10065120(*v5, v3 + 20, *(_BYTE *)(v3 + 116));
        v7 = *(_BYTE *)(v4 + 4);
        v14 = v13 - v6;
        if ( v7 == 1 )
        {
          *(float *)(v4 - 8) = *(float *)(v1 + 436);
          v8 = *(float *)(v1 + 436) + *(float *)(v1 + 436);
          *(float *)(v4 - 4) = v8;
          v9 = v14;
          v15 = *(float *)v3 - 1.0;
          sub_10067650(v15, v9, *(float *)(v4 - 8), v8, byte_100D394C[v2], -16711681);
        }
        else if ( v7 == 2 )
        {
          v10 = v13 - v6;
          v16 = *(float *)v3 - 1.0;
          sub_10067650(v16, v10, *(float *)(v4 - 8), *(float *)(v4 - 4), byte_100D394C[v2], -16711681);
        }
        else
        {
          *(float *)(v4 - 8) = *(float *)(v1 + 436);
          v11 = *(float *)(v1 + 436);
          *(float *)(v4 - 4) = v11;
          sub_10069E40(
            *(float *)v3,
            v14,
            *(float *)(v4 - 8),
            v11,
            COERCE_FLOAT(byte_100D394C[v2]),
            -16711681,
            -16777216);
        }
      }
      v12 += 5;
      ++v2;
      v4 += 16;
      v3 += 120;
    }
    while ( v2 < 3 );
  }
}

//----- (10043AC0) --------------------------------------------------------
int __usercall sub_10043AC0@<eax>(int a1@<edi>, int a2@<esi>)
{
  unsigned __int8 v2; // bl@2
  int result; // eax@4

  if ( *(_BYTE *)(a2 + 11447) != 1 )
  {
    v2 = 0;
    if ( *(_BYTE *)(a2 + 52) )
    {
      do
      {
        if ( v2 >= 3u )
          break;
        result = sub_10069C80(a1, 3200 * v2 + a2 + 1332, *(_BYTE *)(v2 + a2 + 10932), 0);
        ++v2;
      }
      while ( v2 < *(_BYTE *)(a2 + 52) );
    }
  }
  return result;
}

//----- (10043B10) --------------------------------------------------------
void __usercall sub_10043B10(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  int v4; // ebp@1
  int v5; // edi@1
  char v6; // al@4
  unsigned __int8 v7; // [sp+23h] [bp-9h]@1
  int v8; // [sp+24h] [bp-8h]@1
  char v9; // [sp+28h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v7 = 0;
  v3 = 0;
  v8 = a1 + 488;
  v4 = a1 + 11460;
  v5 = a1 + 28;
  do
  {
    if ( *(_DWORD *)v5 )
    {
      if ( 9.8999998e24 != **(float **)v5 )
      {
        v6 = sub_1006E1D0(**(float **)(v5 + 12), v8, 10, v4);
        if ( (unsigned __int8)v9 < (unsigned __int8)v6 )
        {
          v9 = v6;
          v7 = v3;
        }
      }
    }
    v8 += 80;
    ++v3;
    v5 += 4;
    v4 += 28;
  }
  while ( v3 < 3u );
  sub_1006E390(v9, (_DWORD *)(v2 + 128), (int *)(v2 + 124), *(_BYTE *)(v2 + 11448), *(_DWORD *)(v2 + 28 * v7 + 11468));
  sub_1006E390(v9, (_DWORD *)(v2 + 180), (int *)(v2 + 176), *(_BYTE *)(v2 + 11448), *(_DWORD *)(v2 + 28 * v7 + 11468));
  sub_1006BEC0(a2, v2 + 116);
  sub_1006BEC0(a2, v2 + 168);
}

//----- (10043C10) --------------------------------------------------------
int __usercall sub_10043C10@<eax>(int result@<eax>)
{
  float v1; // ST00_4@1
  double v2; // st3@1
  float v3; // ST04_4@1
  double v4; // st3@1
  float v5; // ST04_4@1

  *(float *)(result + 11572) = 270.0;
  *(_DWORD *)(result + 11576) = -1;
  *(float *)(result + 11560) = 0.0;
  *(float *)(result + 11564) = 0.0;
  v1 = *(float *)(result + 436) * 1.799999952316284;
  *(float *)(result + 11568) = v1;
  *(float *)(result + 11556) = COERCE_FLOAT(LODWORD(v1) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11548) = *(float *)(result + 436) * 0.5 + *(float *)(result + 428);
  v2 = *(float *)(result + 12) + *(float *)(result + 4);
  *(_DWORD *)(result + 11608) = -1;
  *(float *)(result + 11552) = v2;
  *(float *)(result + 11604) = 270.0;
  *(float *)(result + 11592) = 0.0;
  *(float *)(result + 11596) = 0.0;
  v3 = *(float *)(result + 456) * 1.799999952316284;
  *(float *)(result + 11600) = v3;
  *(float *)(result + 11588) = COERCE_FLOAT(LODWORD(v3) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11580) = *(float *)(result + 456) * 0.5 + *(float *)(result + 448);
  v4 = *(float *)(result + 12) + *(float *)(result + 4);
  *(_DWORD *)(result + 11640) = -1;
  *(float *)(result + 11584) = v4;
  *(float *)(result + 11636) = 270.0;
  *(float *)(result + 11624) = 0.0;
  *(float *)(result + 11628) = 0.0;
  v5 = 1.799999952316284 * *(float *)(result + 476);
  *(float *)(result + 11632) = v5;
  *(float *)(result + 11620) = COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11612) = 0.5 * *(float *)(result + 476) + *(float *)(result + 468);
  *(float *)(result + 11616) = *(float *)(result + 12) + *(float *)(result + 4);
  return result;
}

//----- (10043D60) --------------------------------------------------------
void __usercall sub_10043D60(int a1@<ebx>)
{
  int v1; // edi@2
  int v2; // esi@2
  float **v3; // ebp@2
  int v4; // esi@9
  signed int v5; // edi@9
  signed int v6; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a1 + 11441) == 1 )
  {
    if ( *(_BYTE *)(a1 + 11444) != 1 )
    {
      v4 = a1 + 11316;
      v5 = 3;
      do
      {
        if ( *(_DWORD *)v4 && 9.8999998e24 == **(float **)v4 && !*(_BYTE *)(v4 + 26) )
          sub_1006A400(v4 - 20);
        v4 += 48;
        --v5;
      }
      while ( v5 );
    }
  }
  else
  {
    v1 = a1 + 428;
    v2 = a1 + 10940;
    v3 = (float **)(a1 + 28);
    v6 = 3;
    do
    {
      if ( *v3 )
      {
        if ( 9.8999998e24 == **v3 )
          sub_100659D0(
            *(float *)v1,
            *(float *)v2,
            *(float *)(v1 + 8),
            *(float *)(v2 + 8),
            0.0,
            1.0,
            *(_BYTE *)(a1 + 16));
      }
      ++v3;
      v2 += 120;
      v1 += 20;
      --v6;
    }
    while ( v6 );
  }
}

//----- (10043E30) --------------------------------------------------------
char __usercall sub_10043E30@<al>(int a1@<ebx>, int a2@<edi>, int a3, float a4)
{
  double v4; // st7@1
  signed int v5; // esi@1
  char result; // al@2
  int v7; // eax@4
  int v8; // ebp@4
  float v9; // ST20_4@4
  int v10; // ecx@4
  double v11; // st7@4
  double v12; // st7@5
  int v13; // eax@7
  double v14; // st7@8
  float v15; // ST20_4@8
  float v16; // ST20_4@9
  double v17; // st6@15
  int v18; // eax@15
  int v19; // ecx@15
  int v20; // eax@15
  int v21; // edx@15
  float v22; // [sp+14h] [bp-1Ch]@1
  int v23; // [sp+18h] [bp-18h]@2
  int v24; // [sp+1Ch] [bp-14h]@2
  float v25; // [sp+20h] [bp-10h]@7
  float v26; // [sp+24h] [bp-Ch]@1

  v26 = flt_100D3928[a1];
  v4 = 0.0;
  v5 = 0;
  v22 = 0.0;
  if ( *(_BYTE *)a3 )
  {
    v23 = a3 + 12;
    result = a2 + 104;
    v24 = a2 + 1128;
    do
    {
      if ( v5 >= 10 )
      {
        *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
        return result;
      }
      v7 = a2 + 120 * a1;
      v8 = 10 * a1;
      v9 = v26 * a4 * *(float *)(v7 + 10944);
      v10 = a2 + 20 * (v5 + 10 * a1);
      *(float *)(v10 + 736) = v9;
      *(float *)(v10 + 728) = *(float *)(v7 + 10936) - v9;
      v11 = *(float *)(v7 + 10940);
      if ( *(_BYTE *)(a2 + 11644) )
        v12 = v11 + v22;
      else
        v12 = v11 - v22;
      *(float *)(v10 + 732) = v12;
      v25 = sub_10065120(*(float *)v23, v7 + 10956, *(_BYTE *)(v7 + 11052));
      v13 = v5 + v8 + 37;
      if ( *(_BYTE *)(a2 + 11644) )
      {
        v14 = v25;
        v16 = v25 - v22;
        *(float *)(a2 + 20 * v13) = v16;
      }
      else
      {
        v14 = v25;
        v15 = v22 - v25;
        *(float *)(a2 + 20 * v13) = v15;
      }
      *(_DWORD *)(a2 + 20 * (v5 + 10 * a1) + 744) = *(_DWORD *)(v23 + 40);
      *(float *)(a2 + 8 * (v5 + v8) + 488) = *(float *)v23;
      *(_BYTE *)(a2 + 8 * (v5 + 10 * a1) + 492) = *(_BYTE *)(v5 + a3 + 92);
      if ( a1 == 2 )
        *(float *)v24 = *(float *)(v24 + 8) * 0.5 + *(float *)v24;
      v22 = v14;
      ++v5;
      result = v23 + 4;
      v23 += 4;
      v24 += 20;
    }
    while ( v5 < *(_BYTE *)a3 );
    if ( v5 < 10 )
    {
      v4 = 0.0;
      goto LABEL_15;
    }
    result = *(_BYTE *)a3;
    *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
  }
  else
  {
LABEL_15:
    v17 = 9.8999998e24;
    v18 = v5 + 10 * a1;
    v19 = a2 + 8 * v18 + 488;
    v20 = a2 + 20 * v18 + 732;
    v21 = 10 - v5;
    do
    {
      *(_DWORD *)(v20 + 12) = 0;
      *(float *)(v20 - 4) = v4;
      v20 += 20;
      *(float *)(v20 - 20) = v4;
      v19 += 8;
      --v21;
      *(float *)(v20 - 16) = v4;
      *(float *)(v20 - 12) = v4;
      *(_BYTE *)(v19 - 4) = 10;
      *(float *)(v19 - 8) = *(float *)&v17;
    }
    while ( v21 );
    result = a3;
    *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
  }
  return result;
}
// 100D3928: using guessed type float flt_100D3928[];

//----- (10044040) --------------------------------------------------------
int __usercall sub_10044040@<eax>(int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<ebx>, unsigned __int8 a4, int a5)
{
  int result; // eax@1
  int v6; // edi@1
  double v7; // st7@1
  int v8; // edx@2
  int v9; // ebp@5
  int v10; // esi@5
  double v11; // ST2C_8@6
  double v12; // st7@6
  double v13; // st7@8
  bool v14; // sf@10
  unsigned __int8 v15; // of@10
  double v16; // st6@12
  int v17; // ecx@12
  int v18; // [sp+4h] [bp-30h]@5
  int v19; // [sp+8h] [bp-2Ch]@5
  int i; // [sp+18h] [bp-1Ch]@2
  int v21; // [sp+1Ch] [bp-18h]@1
  float v22; // [sp+20h] [bp-14h]@1
  int v23; // [sp+24h] [bp-10h]@5
  int v24; // [sp+28h] [bp-Ch]@5
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1

  result = a4;
  v6 = a5;
  v21 = 0;
  v22 = flt_100D3934[a5];
  v25 = a2;
  v7 = 0.5;
  if ( (signed int)a4 > 0 )
  {
    v8 = a1 + 4;
    for ( i = v8; a2 < 0x32u; v8 = i )
    {
      v9 = a3 + 120 * v6;
      v24 = a2;
      v23 = 50 * v6 + a2;
      v10 = (v23 << 6) + a3;
      *(float *)(v10 + 1332) = *(float *)(a3 + 120 * v6 + 10936);
      v19 = *(_BYTE *)(v9 + 11052);
      v18 = v9 + 10956;
      if ( *(_BYTE *)(a3 + 11644) )
      {
        v12 = sub_10065120(*(float *)(v8 - 4), v18, v19) + *(float *)(v9 + 10940);
      }
      else
      {
        v11 = *(float *)(v9 + 10940);
        v12 = v11 - sub_10065120(*(float *)(v8 - 4), v18, v19);
      }
      *(float *)(v10 + 1340) = v12;
      v13 = *(float *)i * v22 * *(float *)(v9 + 10944);
      *(_DWORD *)(v10 + 1388) = -1;
      *(float *)(v10 + 1336) = v13 + *(float *)(v10 + 1332);
      *(float *)(((v23 + 21) << 6) + a3) = *(float *)(v10 + 1340);
      *(float *)(v10 + 1348) = 1.0;
      if ( v6 == 2 )
        *(float *)((v24 << 6) + a3 + 7732) = *(float *)(a3 + 11184) * -v22 * *(float *)i
                                           + *(float *)((v24 << 6) + a3 + 7732);
      sub_100649E0(v10 + 1368, (_BYTE *)(i + 4), 7);
      *(float *)(v10 + 1356) = *(float *)(v10 + 1340);
      ++v25;
      *(float *)(v10 + 1384) = 9.0;
      v7 = 0.5;
      i += 16;
      result = v21 + 1;
      *(float *)(v10 + 1380) = 0.5;
      *(_DWORD *)(v10 + 1360) = 0;
      *(_DWORD *)(v10 + 1364) = -1;
      v15 = __OFSUB__(v21 + 1, a4);
      v14 = v21 + 1 - a4 < 0;
      a2 = v25;
      ++v21;
      if ( !(v14 ^ v15) )
        break;
    }
  }
  *(_BYTE *)(a3 + v6 + 10932) = a2;
  if ( a2 < 0x32u )
  {
    v16 = 0.0;
    result = ((a2 + 50 * v6) << 6) + a3 + 1340;
    v17 = (unsigned __int8)(50 - a2);
    do
    {
      *(float *)(result - 8) = 0.0;
      *(_DWORD *)(result + 48) = 0;
      *(float *)result = 0.0;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result - 4) = 0.0;
      *(_DWORD *)(result + 20) = 0;
      *(float *)(result + 4) = 0.0;
      *(_DWORD *)(result + 24) = -1;
      result += 64;
      --v17;
      *(float *)(result - 56) = 1.0;
      *(float *)(result - 52) = 0.0;
      *(float *)(result - 48) = 0.0;
      *(float *)(result - 24) = v7;
      *(float *)(result - 28) = v7;
      *(float *)(result - 20) = *(float *)&v16;
    }
    while ( v17 );
  }
  return result;
}
// 100D3934: using guessed type float flt_100D3934[];

//----- (10044260) --------------------------------------------------------
int __cdecl sub_10044260(float a1, float a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1

  v3 = a3;
  sub_10042DF0(*(_BYTE *)(a3 + 10932), 0, a1, a2, a3);
  sub_10042DF0(*(_BYTE *)(v3 + 10933), 1, a1, a2, v3);
  sub_10042DF0(*(_BYTE *)(v3 + 10934), 2, a1, a2, v3);
  ++*(_BYTE *)(v3 + 10932);
  LOBYTE(result) = *(_BYTE *)(a3 + 10932);
  ++*(_BYTE *)(v3 + 10933);
  ++*(_BYTE *)(v3 + 10934);
  return (unsigned __int8)result;
}

//----- (10044300) --------------------------------------------------------
int __cdecl sub_10044300(float a1, float a2, float a3, int a4)
{
  int v4; // edi@1

  v4 = sub_10042EF0(a4, a1, a2, a3, 0);
  sub_10042EF0(a4, a1, a2, a3, 1);
  sub_10042EF0(a4, a1, a2, a3, 2);
  return v4;
}

//----- (10044380) --------------------------------------------------------
char __cdecl sub_10044380(int a1, float a2, int a3)
{
  return sub_10043E30(2, a3, a1, a2);
}

//----- (100443B0) --------------------------------------------------------
char __cdecl sub_100443B0(int a1, float a2, int a3)
{
  return sub_10043E30(0, a3, a1, a2);
}

//----- (100443D0) --------------------------------------------------------
char __cdecl sub_100443D0(int a1, float a2, int a3)
{
  return sub_10043E30(1, a3, a1, a2);
}

//----- (10044400) --------------------------------------------------------
int __cdecl sub_10044400(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_10044040(a1, a3, a4, a2, 2);
}

//----- (10044420) --------------------------------------------------------
int __cdecl sub_10044420(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_10044040(a1, a3, a4, a2, 0);
}

//----- (10044440) --------------------------------------------------------
int __cdecl sub_10044440(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_10044040(a1, a3, a4, a2, 1);
}

//----- (10044460) --------------------------------------------------------
char __cdecl sub_10044460(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_10043030(a4);
      sub_100438E0(a4);
      sub_10043AC0(a1, a4);
      sub_10043920(a4);
      sub_10043080(a4);
      sub_10043B10(a4, a1);
      sub_10043770(a1, a4);
      sub_10043800(a4, a1);
      sub_10043D60(a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10043B10(a4, a1);
      sub_10043770(a1, a4);
      sub_10043800(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10044560) --------------------------------------------------------
char __cdecl sub_10044560(int a1, float a2, int a3)
{
  sub_100443B0(a1, a2, a3);
  sub_100443D0(a1, a2, a3);
  return sub_10044380(a1, a2, a3);
}

//----- (100445B0) --------------------------------------------------------
int __cdecl sub_100445B0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  sub_10044420(a1, a2, a3, a4);
  sub_10044440(a1, a2, a3, a4);
  return sub_10044400(a1, a2, a3, a4);
}

//----- (100445F0) --------------------------------------------------------
char __usercall sub_100445F0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  int v5; // ecx@1
  signed int v6; // edx@1
  double v7; // st5@3
  int v8; // eax@3
  float v10; // [sp+Ch] [bp+4h]@3

  v5 = a1 + 1376;
  v6 = 50;
  *(float *)(a1 + 10936) = a3 + a5;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 436) = a5 * 0.4000000059604645;
  do
  {
    v5 += 64;
    --v6;
    *(float *)(v5 - 88) = *(float *)(a1 + 10936) + 4.0;
    *(float *)(v5 - 64) = 0.0;
  }
  while ( v6 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v10 = a4 - 4.0;
  *(float *)(a1 + 11300) = v10;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v7 = *(float *)(a2 + 8);
  *(_BYTE *)(a1 + 52) = 1;
  *(float *)(a1 + 11324) = v7;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  *(float *)(a1 + 120) = v10 - 15.0 - 3.0;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 428) = *(float *)a1;
  v8 = sub_10043C10(a1);
  return sub_10044560(a2, 0.2, v8);
}

//----- (100446E0) --------------------------------------------------------
char __usercall sub_100446E0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  double v5; // st7@1
  float *v6; // ecx@1
  signed int v7; // edi@1
  signed int v8; // edx@2
  double v9; // st5@5
  double v10; // st4@5
  double v11; // st2@5
  double v12; // st6@5
  int v13; // eax@5
  float v15; // [sp+18h] [bp+Ch]@1
  float v16; // [sp+18h] [bp+Ch]@3
  float v17; // [sp+18h] [bp+Ch]@5
  float v18; // [sp+18h] [bp+Ch]@5

  v5 = a5;
  v6 = (float *)(a1 + 1352);
  v7 = 3;
  *(float *)(a1 + 10936) = 0.25 * a5 + a3;
  *(float *)(a1 + 11056) = a5 * 0.75 + a3;
  v15 = a5 * 0.1500000059604645;
  *(float *)(a1 + 10944) = v15;
  *(float *)(a1 + 11064) = v15;
  do
  {
    v8 = 50;
    do
    {
      v16 = v5 * 0.5 + a3;
      *v6 = v16;
      v6 += 16;
      --v8;
    }
    while ( v8 );
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v17 = a4 - 4.0;
  v9 = v17;
  *(float *)(a1 + 11300) = v17;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v10 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11352) = 0;
  *(float *)(a1 + 11324) = v10;
  *(_DWORD *)(a1 + 11356) = -1;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  v18 = v5 + a3;
  *(float *)(a1 + 11344) = v18;
  *(float *)(a1 + 11348) = v9;
  *(float *)(a1 + 11368) = *(float *)(a2 + 4);
  v11 = *(float *)(a2 + 8);
  *(_BYTE *)(a1 + 52) = 2;
  *(float *)(a1 + 11372) = v11;
  *(float *)(a1 + 11376) = 1.0;
  *(float *)(a1 + 11380) = 1.0;
  *(float *)(a1 + 11384) = 15.0;
  *(float *)(a1 + 120) = v9 - 15.0 - 3.0;
  v12 = v18;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 324) = *(float *)&v12;
  *(float *)(a1 + 364) = 0.0;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 448) = *(float *)(a1 + 8) + *(float *)a1;
  *(float *)(a1 + 456) = *(float *)(a1 + 456) * -1.0;
  v13 = sub_10043C10(a1);
  return sub_10044560(a2, 0.40000001, v13);
}

//----- (10044870) --------------------------------------------------------
char __usercall sub_10044870@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  double v5; // st7@1
  float *v6; // ecx@1
  signed int v7; // edx@1
  double v8; // st6@1
  double v9; // st5@1
  float *v10; // ecx@3
  signed int v11; // edx@3
  float *v12; // ecx@5
  signed int v13; // edx@5
  double v14; // st4@7
  double v15; // st3@7
  double v16; // st0@7
  double v17; // st6@7
  int v18; // eax@7
  float v20; // [sp+14h] [bp+Ch]@1
  float v21; // [sp+14h] [bp+Ch]@1
  float v22; // [sp+14h] [bp+Ch]@2
  float v23; // [sp+14h] [bp+Ch]@4
  float v24; // [sp+14h] [bp+Ch]@7
  float v25; // [sp+14h] [bp+Ch]@7
  float v26; // [sp+14h] [bp+Ch]@7

  v5 = a5;
  v6 = (float *)(a1 + 1352);
  v7 = 50;
  v8 = a3;
  *(float *)(a1 + 10936) = 0.1500000059604645 * a5 + a3;
  *(float *)(a1 + 11056) = a5 * 0.8500000238418579 + a3;
  v20 = a5 * 0.5 + a3;
  v9 = v20;
  *(float *)(a1 + 11176) = v20;
  v21 = v5 * 0.119999997317791;
  *(float *)(a1 + 10944) = v21;
  *(float *)(a1 + 11064) = v21;
  *(float *)(a1 + 11184) = v21;
  do
  {
    v22 = v5 * 0.3199999928474426 + a3;
    *v6 = v22;
    v6 += 16;
    --v7;
  }
  while ( v7 );
  v10 = (float *)(a1 + 4552);
  v11 = 50;
  do
  {
    v23 = v5 * 0.6800000071525574 + v8;
    *v10 = v23;
    v10 += 16;
    --v11;
  }
  while ( v11 );
  v12 = (float *)(a1 + 7752);
  v13 = 50;
  do
  {
    *v12 = v9;
    v12 += 16;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v24 = a4 - 5.0;
  v14 = v24;
  *(float *)(a1 + 11300) = v24;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v15 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11352) = 0;
  *(float *)(a1 + 11324) = v15;
  *(_DWORD *)(a1 + 11356) = -1;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  v25 = v8 + v5;
  *(float *)(a1 + 11344) = v25;
  *(float *)(a1 + 11348) = v14;
  *(float *)(a1 + 11368) = *(float *)(a2 + 4);
  v16 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11400) = 0;
  *(float *)(a1 + 11372) = v16;
  *(_DWORD *)(a1 + 11404) = -1;
  *(float *)(a1 + 11376) = 1.0;
  *(float *)(a1 + 11380) = 1.0;
  *(float *)(a1 + 11384) = 15.0;
  *(float *)(a1 + 11392) = v9;
  *(float *)(a1 + 11396) = v14;
  *(float *)(a1 + 11416) = *(float *)(a2 + 4);
  *(float *)(a1 + 11420) = *(float *)(a2 + 8);
  *(float *)(a1 + 11424) = 0.5;
  *(float *)(a1 + 11428) = 1.0;
  *(float *)(a1 + 11432) = 15.0;
  *(float *)(a1 + 120) = v14 - 15.0 - 3.0;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 324) = v25;
  *(float *)(a1 + 364) = 0.0;
  *(float *)(a1 + 376) = v9;
  *(float *)(a1 + 416) = 0.5;
  v26 = v5 * 0.05799999833106995;
  *(float *)(a1 + 436) = v26;
  *(float *)(a1 + 456) = -1.0 * v26;
  *(float *)(a1 + 476) = v26;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 448) = *(float *)a1 + *(float *)(a1 + 8);
  v17 = *(float *)(a1 + 8);
  *(_BYTE *)(a1 + 52) = 3;
  *(float *)(a1 + 468) = v17 * 0.5 + *(float *)a1 - v26 * 0.5;
  v18 = sub_10043C10(a1);
  return sub_10044560(a2, 0.40000001, v18);
}

//----- (10044AE0) --------------------------------------------------------
int __usercall sub_10044AE0@<eax>(int a1@<esi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ebp@1
  double v11; // st6@1
  double v12; // st7@6
  int v13; // eax@6
  double v14; // st6@6
  signed int v15; // edx@6
  double v16; // st5@6
  double v17; // st4@6
  double v18; // rt1@7
  double v19; // st4@7
  double v20; // rt2@7
  double v21; // st4@7
  double v22; // rtt@7
  double v23; // rt0@8
  double v24; // st4@8
  double v25; // st5@8
  double v26; // rt1@8
  double v27; // st4@8
  double v28; // st7@8
  double v29; // rt2@8
  double v30; // st4@8
  double v31; // st6@8
  int v32; // eax@9
  double v33; // st4@9
  signed int v34; // edi@9
  double v35; // st3@9
  double v36; // st2@9
  double v37; // rtt@10
  double v38; // st2@10
  double v39; // rt0@10
  double v40; // st2@10
  double v41; // rt1@10
  double v42; // rt2@11
  double v43; // st2@11
  double v44; // st5@11
  double v45; // rtt@12
  double v46; // st2@12
  double v47; // st3@12
  double v48; // rt0@13
  double v49; // rtt@14
  double v50; // st2@14
  double v51; // st4@14
  int v52; // ecx@14
  signed int v53; // edx@14
  double v54; // rt0@15
  double v55; // st2@15
  double v56; // rt1@15
  double v57; // rt2@16
  double v58; // st2@16
  double v59; // st5@16
  double v60; // rtt@16
  double v61; // st2@16
  double v62; // st6@16
  double v63; // rt0@17
  double v64; // st2@17
  double v65; // rt1@17
  double v66; // st2@17
  double v67; // st4@17
  double v68; // st3@18
  double v69; // st7@18
  double v70; // st6@18
  double v71; // st5@18
  int v72; // eax@18
  double v73; // st4@18
  signed int v74; // ecx@18
  double v75; // st3@18
  double v76; // rt2@19
  double v77; // st3@19
  double v78; // st4@19
  double v79; // rtt@19
  double v80; // st3@19
  double v81; // rt0@19
  double v82; // st3@19
  double v83; // rt1@19
  double v84; // st3@19
  double v85; // rt2@19
  double v86; // rtt@20
  double v87; // st3@20
  double v88; // st6@20
  double v89; // rt0@20
  double v90; // st3@20
  double v91; // st7@20
  double v92; // rt1@20
  double v93; // st3@20
  double v94; // st4@20
  double v95; // rt2@20
  double v96; // st3@20
  double v97; // st5@20
  double v98; // rtt@20
  double v99; // st3@20
  double v100; // st6@20
  int v102; // [sp+0h] [bp-10h]@1
  float v103; // [sp+4h] [bp-Ch]@1
  signed int v104; // [sp+8h] [bp-8h]@1
  float v105; // [sp+Ch] [bp-4h]@1
  float v106; // [sp+28h] [bp+18h]@18

  *(float *)(a1 + 11652) = 2.0;
  *(_DWORD *)(a1 + 11648) = -1;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)a1 = a4;
  v7 = a5;
  *(float *)(a1 + 4) = a5;
  v8 = a1 + 432;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 68;
  v10 = a1 + 40;
  *(float *)(a1 + 12) = a7;
  v104 = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  *(float *)(a1 + 24) = *(float *)(a3 + 8);
  *(_WORD *)(a1 + 11450) = 12;
  *(_DWORD *)(a1 + 11452) = &unk_100B8DC0;
  *(_BYTE *)(a1 + 11456) = 1;
  *(_BYTE *)(a1 + 11544) = 0;
  v102 = a1 + 11460;
  v103 = a6 * 0.1000000014901161;
  v11 = v103;
  v105 = v11 + v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 - 12) = 0;
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(float *)v9 = v11;
    *(_DWORD *)(v9 + 8) = 0;
    *(float *)(v9 + 4) = v105;
    *(float *)(v8 - 4) = a4;
    if ( !*(_BYTE *)(a1 + 11644) )
      v7 = v7 + a7;
    *(float *)v8 = v7;
    *(float *)(v8 + 4) = v11;
    *(float *)(v8 + 8) = 0.0;
    sub_1006E420(v102);
    v102 += 28;
    v10 += 4;
    v9 += 16;
    v8 += 20;
    if ( !--v104 )
      break;
    v7 = a5;
    v11 = v103;
  }
  v12 = 1.0;
  v13 = a1 + 11296;
  v14 = 15.0;
  v15 = 3;
  v16 = a5;
  v17 = a4;
  while ( 1 )
  {
    *(float *)v13 = v17;
    *(_DWORD *)(v13 + 20) = 0;
    v23 = v17;
    v24 = v16;
    v25 = v23;
    *(_DWORD *)(v13 + 8) = 0;
    *(float *)(v13 + 4) = v24;
    *(_DWORD *)(v13 + 12) = -1;
    *(_DWORD *)(v13 + 16) = -1;
    *(_BYTE *)(v13 + 46) = 0;
    *(_BYTE *)(v13 + 44) = 0;
    *(_BYTE *)(v13 + 45) = 0;
    *(float *)(v13 + 24) = *(float *)(a3 + 4);
    v13 += 48;
    --v15;
    *(float *)(v13 - 20) = *(float *)(a3 + 8);
    v26 = v24;
    v27 = v12;
    v28 = v26;
    *(float *)(v13 - 16) = v27;
    *(float *)(v13 - 12) = v27;
    v29 = v27;
    v30 = v14;
    v31 = v29;
    *(float *)(v13 - 8) = v30;
    if ( !v15 )
      break;
    v18 = v30;
    v19 = v31;
    v14 = v18;
    v20 = v19;
    v21 = v28;
    v12 = v20;
    v22 = v21;
    v17 = v25;
    v16 = v22;
  }
  v32 = a1 + 10940;
  v33 = a6;
  v34 = 3;
  v35 = a7;
  v36 = 0.0;
  while ( 1 )
  {
    v42 = v36;
    v43 = v25;
    v44 = v42;
    *(float *)(v32 - 4) = v43;
    if ( *(_BYTE *)(a1 + 11644) )
    {
      v48 = v43;
      *(float *)v32 = v28;
      *(float *)(v32 + 8) = v35 * -1.0;
      v46 = v35;
      v47 = v48;
    }
    else
    {
      *(float *)v32 = v28 + v35;
      v45 = v43;
      v46 = v35;
      v47 = v45;
      *(float *)(v32 + 8) = v46;
    }
    v49 = v46;
    v50 = v33;
    v51 = v49;
    *(_BYTE *)(v32 + 12) = 1;
    *(float *)(v32 + 4) = v50;
    v52 = v32 + 24;
    v53 = 8;
    while ( 1 )
    {
      v57 = v50;
      v58 = v44;
      v59 = v57;
      v52 += 12;
      --v53;
      *(float *)(v52 - 20) = v58;
      *(float *)(v52 - 16) = v58;
      v60 = v58;
      v61 = v31;
      v62 = v60;
      *(float *)(v52 - 12) = v61;
      if ( !v53 )
        break;
      v54 = v61;
      v55 = v62;
      v31 = v54;
      v56 = v55;
      v50 = v59;
      v44 = v56;
    }
    *(_BYTE *)(v32 + 112) = 2;
    *(float *)(v32 + 16) = *(float *)(a3 + 4);
    v32 += 120;
    --v34;
    *(float *)(v32 - 92) = *(float *)(a3 + 8);
    v63 = v61;
    v64 = v62;
    v31 = v63;
    *(float *)(v32 - 100) = v64;
    v65 = v64;
    v66 = v51;
    v67 = v65;
    *(float *)(v32 - 88) = v66;
    if ( !v34 )
      break;
    v37 = v66;
    v38 = v47;
    v35 = v37;
    v39 = v38;
    v40 = v59;
    v25 = v39;
    v41 = v40;
    v36 = v67;
    v33 = v41;
  }
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = -1;
  v106 = v47 + v59 * 0.5;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = -1;
  *(float *)(a1 + 116) = v106;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 232) = -1;
  *(float *)(a1 + 120) = v28;
  *(float *)(a1 + 156) = 0.5;
  *(float *)(a1 + 160) = v31;
  *(float *)(a1 + 164) = 12.0;
  *(float *)(a1 + 168) = v106;
  *(float *)(a1 + 172) = v28;
  *(float *)(a1 + 208) = 0.5;
  *(float *)(a1 + 212) = v31;
  *(float *)(a1 + 216) = 12.0;
  v68 = v106;
  *(float *)(a1 + 220) = *(float *)&v68;
  *(float *)(a1 + 224) = v28;
  *(float *)(a1 + 260) = 0.5;
  *(float *)(a1 + 264) = v31;
  *(float *)(a1 + 268) = 12.0;
  sub_100649E0(a1 + 132, (_BYTE *)a2, 21);
  v69 = a5;
  v70 = a4;
  *(_BYTE *)(a1 + 184) = 0;
  v71 = 0.0;
  v72 = a1 + 276;
  v73 = 0.5;
  v74 = 3;
  v75 = 12.0;
  while ( 1 )
  {
    v86 = v75;
    v87 = v70;
    v88 = v86;
    *(_DWORD *)(v72 + 4) = 0;
    *(float *)(v72 - 4) = v87;
    *(_DWORD *)(v72 + 8) = -1;
    v89 = v87;
    v90 = v69;
    v91 = v89;
    *(_BYTE *)(v72 + 12) = 0;
    *(float *)v72 = v90;
    v72 += 52;
    --v74;
    v92 = v90;
    v93 = v73;
    v94 = v92;
    *(float *)(v72 - 16) = v93;
    v95 = v93;
    v96 = v71;
    v97 = v95;
    *(float *)(v72 - 12) = v96;
    v98 = v96;
    v99 = v88;
    v100 = v98;
    *(float *)(v72 - 8) = v99;
    if ( !v74 )
      break;
    v76 = v99;
    v77 = v94;
    v78 = v76;
    v79 = v77;
    v80 = v91;
    v69 = v79;
    v81 = v80;
    v82 = v100;
    v70 = v81;
    v83 = v82;
    v84 = v97;
    v71 = v83;
    v85 = v84;
    v75 = v78;
    v73 = v85;
  }
  *(_DWORD *)(a1 + 11440) = 0;
  *(_DWORD *)(a1 + 11444) = 0;
  *(_WORD *)(a1 + 11448) = 0;
  *(_BYTE *)(a1 + 11449) = 1;
  return sub_100445B0(0, 0, 0, a1);
}

//----- (10044E50) --------------------------------------------------------
char __cdecl sub_10044E50(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_10044AE0(a1, a2, a3, a4, a5, a6, a7);
  return sub_100445F0(a1, a3, a4, a5, a6);
}

//----- (10044EC0) --------------------------------------------------------
char __cdecl sub_10044EC0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_10044AE0(a1, a2, a3, a4, a5, a6, a7);
  return sub_100446E0(a1, a3, a4, a5, a6);
}

//----- (10044F30) --------------------------------------------------------
char __cdecl sub_10044F30(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_10044AE0(a1, a2, a3, a4, a5, a6, a7);
  return sub_10044870(a1, a3, a4, a5, a6);
}

//----- (10044FA0) --------------------------------------------------------
signed int __cdecl sub_10044FA0(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 436);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 436);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (10045010) --------------------------------------------------------
signed int __cdecl sub_10045010(int a1, signed int a2, int a3)
{
  signed int result; // eax@1
  int v4; // ecx@2
  _DWORD *v5; // edx@2

  result = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = (_DWORD *)(a3 + 156);
    do
    {
      if ( result >= 3 )
        break;
      *v5 = v4;
      ++result;
      v4 += 4;
      ++v5;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (10045050) --------------------------------------------------------
int __cdecl sub_10045050(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)(a2 + 16) = (signed __int64)*(float *)a1;
  result = (unsigned __int16)a1 | 0xC00;
  *(_DWORD *)(a2 + 20) = (signed __int64)*(float *)(a1 + 4);
  return result;
}

//----- (100450B0) --------------------------------------------------------
void __usercall sub_100450B0(int a1@<ebx>, int a2)
{
  int v2; // esi@1
  int *v3; // edi@1
  unsigned int **v4; // ebp@1
  unsigned int v5; // eax@4
  float v6; // ST1C_4@5
  char v7; // ST3C_1@5
  signed int v8; // [sp+1Ch] [bp-Ch]@1

  v2 = a1 + 284;
  v3 = (int *)(a1 + 532);
  v4 = (unsigned int **)(a1 + 156);
  v8 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) && *v4 )
    {
      v5 = **v4;
      if ( v5 != 0x7FFFFFFF )
      {
        v6 = (double)v5;
        v7 = sub_1006E1D0(v6, a1 + 432, 10, (int)(v3 - 2));
        sub_1006E390(v7, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a1 + 169), *v3);
        sub_1006BEC0(a2, v2 - 8);
      }
    }
    ++v4;
    v3 += 7;
    v2 += 52;
    --v8;
  }
  while ( v8 );
}

//----- (10045160) --------------------------------------------------------
void __usercall sub_10045160(int a1@<esi>, int a2, int a3, int a4, _WORD *a5)
{
  signed int v5; // ebx@1
  unsigned int **v6; // ecx@2
  int *v7; // ebp@2
  unsigned int *v8; // edi@2
  unsigned int v9; // eax@5
  unsigned int v10; // eax@9
  float v11; // ST14_4@10
  char v12; // ST34_1@10
  int v13; // [sp+1Ch] [bp-Ch]@2

  v5 = 0;
  if ( *(_BYTE *)(a1 + 168) )
  {
    v6 = (unsigned int **)(a1 + 156);
    v7 = (int *)(a1 + 532);
    v13 = a1 + 156;
    v8 = (unsigned int *)(a1 + 56);
    do
    {
      if ( v5 >= 3 )
        break;
      if ( *v6 )
      {
        v9 = **v6;
        if ( v9 > *(_DWORD *)(a1 + 20) || v9 < *(_DWORD *)(a1 + 16) )
          *v8 = 0x7FFFFFFF;
        else
          *v8 = v9;
        v10 = **v6;
        if ( v10 != 0x7FFFFFFF )
        {
          v11 = (double)v10;
          v12 = sub_1006E1D0(v11, a1 + 432, 10, (int)(v7 - 2));
          sub_1006E300(v12, v8 - 7, (int *)v8 - 6, *(_BYTE *)(a1 + 170), *v7);
        }
        sub_100457E0(a2, a3, a4, (int)(v8 - 8), a5);
        v6 = (unsigned int **)v13;
      }
      ++v5;
      ++v6;
      v7 += 7;
      v8 += 11;
      v13 = (int)v6;
    }
    while ( v5 < *(_BYTE *)(a1 + 168) );
  }
}

//----- (10045260) --------------------------------------------------------
void __usercall sub_10045260(int a1@<edi>, int a2)
{
  unsigned __int8 v2; // bl@1
  unsigned int **v3; // ebp@1
  int v4; // esi@1
  unsigned int v5; // eax@3
  float v6; // ST0C_4@4
  char v7; // al@4
  _DWORD *v8; // esi@7
  signed int v9; // ebx@7
  unsigned __int8 v10; // [sp+1Fh] [bp-9h]@1
  char v11; // [sp+20h] [bp-8h]@1

  v11 = 0;
  v10 = 0;
  v2 = 0;
  v3 = (unsigned int **)(a1 + 156);
  v4 = a1 + 524;
  do
  {
    if ( *v3 )
    {
      v5 = **v3;
      if ( v5 != 0x7FFFFFFF )
      {
        v6 = (double)v5;
        v7 = sub_1006E1D0(v6, a1 + 432, 10, v4);
        if ( (unsigned __int8)v11 < (unsigned __int8)v7 )
        {
          v11 = v7;
          v10 = v2;
        }
      }
    }
    ++v2;
    ++v3;
    v4 += 28;
  }
  while ( v2 < 3u );
  v8 = (_DWORD *)(a1 + 184);
  v9 = 2;
  do
  {
    sub_1006E390(v11, v8, v8 - 1, *(_BYTE *)(a1 + 171), *(_DWORD *)(a1 + 28 * (v10 + 19)));
    sub_1006BEC0(a2, (int)(v8 - 3));
    v8 += 13;
    --v9;
  }
  while ( v9 );
}

//----- (10045330) --------------------------------------------------------
int __usercall sub_10045330@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st6@1
  _DWORD *v8; // ebp@1
  int v9; // ebx@1
  float *v10; // esi@1
  double v11; // st5@1
  int v12; // eax@2
  double v13; // st7@3
  double v14; // st6@3
  double v15; // st5@3
  double v16; // st4@3
  double v17; // st3@3
  int v18; // eax@3
  signed int v19; // ecx@3
  double v20; // rt0@4
  double v21; // st3@4
  double v22; // rt1@4
  double v23; // st3@4
  double v24; // rtt@4
  double v25; // st3@4
  double v26; // rt0@4
  double v27; // rt1@5
  double v28; // st3@5
  double v29; // st6@5
  double v30; // rtt@5
  double v31; // st3@5
  double v32; // st4@5
  double v33; // st5@5
  double v34; // st3@5
  double v35; // st7@5
  double v36; // st7@6
  double v37; // st6@6
  double v38; // st5@6
  int v39; // eax@6
  double v40; // st4@6
  signed int v41; // ecx@6
  double v42; // st3@6
  double v43; // rt2@7
  double v44; // st3@7
  double v45; // st5@7
  double v46; // rtt@7
  double v47; // st3@7
  double v48; // rt0@7
  double v49; // st3@7
  double v50; // rt1@7
  double v51; // st3@7
  double v52; // rt2@7
  double v53; // rtt@8
  double v54; // st3@8
  double v55; // st6@8
  double v56; // rt0@8
  double v57; // st3@8
  double v58; // st7@8
  double v59; // rt1@8
  double v60; // st3@8
  double v61; // st5@8
  double v62; // rt2@8
  double v63; // st3@8
  double v64; // st4@8
  double v65; // rtt@8
  double v66; // st3@8
  double v67; // st6@8
  float v69; // [sp+2Ch] [bp+14h]@1
  float v70; // [sp+30h] [bp+18h]@2

  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  v7 = a6;
  v8 = (_DWORD *)(a1 + 156);
  v9 = a1 + 524;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  v10 = (float *)(a1 + 64);
  *(_DWORD *)(a1 + 16) = (signed __int64)*(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 20) = (signed __int64)v11;
  LODWORD(v69) = 3;
  do
  {
    *((_WORD *)v10 - 20) = 4142;
    v70 = a4 + v7;
    *(v10 - 1) = v70;
    *((_DWORD *)v10 - 9) = -1;
    *((_DWORD *)v10 - 8) = 0;
    *v10 = a5;
    *(v10 - 7) = 15.0;
    *(v10 - 6) = 0.0;
    v12 = sub_10065060(15.0);
    *(v10 - 4) = 1.0;
    *((_DWORD *)v10 - 5) = v12;
    *(v10 - 3) = 1.0;
    *((_DWORD *)v10 - 2) = 0x7FFFFFFF;
    sub_1006E420(v9);
    *v8 = 0;
    ++v8;
    v10 += 11;
    v9 += 28;
    --LODWORD(v69);
  }
  while ( v69 != 0.0 );
  v13 = 12.0;
  v14 = a5;
  v15 = a4;
  *(_WORD *)(a1 + 512) = 39;
  v16 = 0.0;
  *(_DWORD *)(a1 + 516) = &unk_100B8DC0;
  v17 = 1.0;
  *(_BYTE *)(a1 + 520) = 1;
  v18 = a1 + 176;
  v19 = 3;
  while ( 1 )
  {
    v27 = v17;
    *(_DWORD *)(v18 + 4) = 0;
    *(float *)(v18 - 4) = v15;
    *(_DWORD *)(v18 + 8) = -1;
    v28 = v14;
    v29 = v15;
    *(_BYTE *)(v18 + 12) = 0;
    *(float *)v18 = v28;
    v18 += 52;
    --v19;
    v30 = v28;
    v31 = v16;
    v32 = v30;
    *(float *)(v18 - 16) = v31;
    v33 = v31;
    *(float *)(v18 - 12) = v27;
    v34 = v13;
    v35 = v27;
    *(float *)(v18 - 8) = v34;
    if ( !v19 )
      break;
    v20 = v34;
    v21 = v35;
    v13 = v20;
    v22 = v21;
    v23 = v29;
    v14 = v32;
    v24 = v23;
    v25 = v33;
    v15 = v24;
    v26 = v25;
    v17 = v22;
    v16 = v26;
  }
  sub_100649E0(a1 + 188, (_BYTE *)a2, 21);
  v36 = a5;
  v37 = a4;
  v38 = 0.0;
  v39 = a1 + 280;
  v40 = 1.0;
  v41 = 3;
  v42 = 12.0;
  while ( 1 )
  {
    v53 = v42;
    v54 = v37;
    v55 = v53;
    *(_DWORD *)(v39 + 4) = 0;
    *(float *)(v39 - 4) = v54;
    *(_DWORD *)(v39 + 8) = -1;
    v56 = v54;
    v57 = v36;
    v58 = v56;
    *(_BYTE *)(v39 + 12) = 0;
    *(float *)v39 = v57;
    v39 += 52;
    --v41;
    v59 = v57;
    v60 = v38;
    v61 = v59;
    *(float *)(v39 - 16) = v60;
    v62 = v60;
    v63 = v40;
    v64 = v62;
    *(float *)(v39 - 12) = v63;
    v65 = v63;
    v66 = v55;
    v67 = v65;
    *(float *)(v39 - 8) = v66;
    if ( !v41 )
      break;
    v43 = v66;
    v44 = v61;
    v45 = v43;
    v46 = v44;
    v47 = v58;
    v36 = v46;
    v48 = v47;
    v49 = v67;
    v37 = v48;
    v50 = v49;
    v51 = v64;
    v40 = v50;
    v52 = v51;
    v42 = v45;
    v38 = v52;
  }
  *(_WORD *)(a1 + 169) = 0;
  *(_BYTE *)(a1 + 171) = 0;
  return sub_10044FA0((_BYTE *)a3, a1);
}

//----- (10045560) --------------------------------------------------------
char __cdecl sub_10045560(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_10045260(a4, a1);
      sub_100450B0(a4, a1);
      sub_10045160(a4, a1, a2, a3, a5);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10045260(a4, a1);
      sub_100450B0(a4, a1);
      sub_10045160(a4, a1, a2, a3, a5);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10045660) --------------------------------------------------------
int __cdecl sub_10045660(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_10045330(a1, a2, a3, a4, a5, a6, a7);
}

//----- (100456A0) --------------------------------------------------------
__int16 __usercall sub_100456A0@<ax>(int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // ecx@1
  __int16 result; // ax@1

  v2 = *(_DWORD *)(a1 + 32);
  *(_WORD *)a2 = v2 / 0xE10;
  v3 = -3600 * (signed __int16)(v2 / 0xE10) + v2;
  *(_BYTE *)(a2 + 2) = v3 / 0x3C;
  result = 60 * (char)(v3 / 0x3C);
  *(_BYTE *)(a2 + 3) = v3 % 0x3C;
  return result;
}

//----- (100456E0) --------------------------------------------------------
const char *__usercall sub_100456E0@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3)
{
  int v3; // edi@1
  char v4; // cl@11
  int v5; // [sp+8h] [bp-4h]@4

  v3 = *result & 0x3F;
  if ( v3 < 46 || v3 > 49 )
  {
    *a3 = 0;
  }
  else if ( *((_DWORD *)result + 8) >= 0x7FFFFFFFu )
  {
    result = "__:__:__";
    do
    {
      v4 = *result;
      result[a3 - "__:__:__"] = *result;
      ++result;
    }
    while ( v4 );
    if ( v3 == 46 || v3 == 47 )
      a3[5] = 0;
  }
  else
  {
    sub_100456A0((int)result, (int)&v5);
    if ( v3 == 47 )
    {
      if ( !(_WORD)v5 )
        return (const char *)sub_10064B00(
                               a3,
                               a2,
                               "%02u:%c%c",
                               BYTE2(v5),
                               (unsigned __int8)(BYTE3(v5) / 10 + 48),
                               (unsigned __int8)((unsigned __int16)(BYTE3(v5) % 10) + 48));
    }
    else if ( v3 != 46 )
    {
      return (const char *)_snprintf(a3, a2, "%01u:%02u:%02u", (signed __int16)v5, BYTE2(v5), BYTE3(v5));
    }
    result = (const char *)_snprintf(a3, a2, "%01u:%02u", (signed __int16)v5, BYTE2(v5));
  }
  return result;
}

//----- (100457E0) --------------------------------------------------------
char __cdecl sub_100457E0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@3
  int v6; // edx@3
  double v7; // st7@3
  double v8; // st7@3
  int v9; // edx@3
  float v11; // [sp+4h] [bp-34h]@3
  float v12; // [sp+8h] [bp-30h]@3
  int v13; // [sp+Ch] [bp-2Ch]@3
  float v14; // [sp+10h] [bp-28h]@3
  int v15; // [sp+14h] [bp-24h]@3
  int v16; // [sp+18h] [bp-20h]@3
  float v17; // [sp+1Ch] [bp-1Ch]@3
  float v18; // [sp+20h] [bp-18h]@3
  float v19; // [sp+24h] [bp-14h]@3
  char v20; // [sp+28h] [bp-10h]@3

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v5 = *(_DWORD *)(a4 + 4);
    v6 = *(_DWORD *)(a4 + 8);
    v14 = *(float *)(a4 + 12);
    v7 = *(float *)(a4 + 24);
    v16 = v5;
    v17 = v7;
    v8 = *(float *)(a4 + 28);
    v15 = v6;
    v9 = *(_DWORD *)(a4 + 20);
    v18 = v8;
    v19 = *(float *)(a4 + 16);
    v11 = *(float *)(a4 + 36);
    v13 = v9;
    v12 = *(float *)(a4 + 40);
    sub_100456E0((const char *)a4, 0xCu, &v20);
    sub_10065B70(a1, (int)&v20, (int)&v11);
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (10045890) --------------------------------------------------------
char __cdecl sub_10045890(int a1, int a2, int a3, int *a4, _WORD *a5)
{
  char result; // al@4
  void *v6; // eax@7
  int v7; // edi@7
  float v8; // ST58_4@7
  double v9; // st7@7
  double v10; // st7@7
  double v11; // st7@7
  double v12; // st7@7
  double v13; // st7@7
  int v14; // edi@7
  unsigned int v15; // esi@7
  int v16; // ebx@13
  float v17; // ST58_4@14
  int v18; // ebx@14
  unsigned int v19; // esi@14
  float v20; // ST58_4@16
  float v21; // ST40_4@16
  float v22; // ST58_4@16
  float v23; // ST58_4@16
  float v24; // ST40_4@16
  float v25; // ST58_4@16
  float v26; // ST58_4@16
  float v27; // ST58_4@16
  float v28; // ST40_4@16
  float v29; // ST58_4@16
  float v30; // ST58_4@16
  float v31; // ST40_4@16
  float v32; // ST58_4@16
  float v33; // ST58_4@16
  float v34; // ST58_4@16
  float v35; // ST40_4@16
  float v36; // ST58_4@16
  float v37; // ST58_4@16
  float v38; // ST40_4@16
  float v39; // ST58_4@16
  float v40; // ST58_4@16
  float v41; // ST40_4@16
  float v42; // ST58_4@16
  float v43; // ST58_4@16
  float v44; // ST40_4@16
  float v45; // ST58_4@16
  float v46; // ST58_4@16
  float v47; // ST58_4@16
  float v48; // ST40_4@16
  float v49; // ST58_4@16
  float v50; // ST58_4@16
  float v51; // ST40_4@16
  float v52; // ST58_4@16
  float v53; // ST58_4@16
  float v54; // ST40_4@16
  float v55; // ST58_4@16
  float v56; // ST58_4@16
  float v57; // ST40_4@16
  float v58; // ST58_4@16
  unsigned int v59; // esi@16
  float v60; // ST5C_4@18
  float v61; // ST44_4@18
  float v62; // ST5C_4@18
  float v63; // ST5C_4@18
  float v64; // ST44_4@18
  float v65; // ST5C_4@18
  float v66; // ST5C_4@18
  float v67; // ST5C_4@18
  float v68; // ST44_4@18
  float v69; // ST5C_4@18
  float v70; // ST5C_4@18
  float v71; // ST44_4@18
  float v72; // ST5C_4@18
  float v73; // ST60_4@18
  float v74; // ST60_4@18
  float v75; // ST48_4@18
  float v76; // ST60_4@18
  float v77; // ST60_4@18
  float v78; // ST48_4@18
  float v79; // ST60_4@18
  float v80; // ST60_4@18
  float v81; // ST48_4@18
  float v82; // ST60_4@18
  float v83; // ST60_4@18
  float v84; // ST48_4@18
  float v85; // ST60_4@18
  float v86; // ST60_4@18
  float v87; // ST60_4@18
  float v88; // ST48_4@18
  float v89; // ST60_4@18
  float v90; // ST60_4@18
  float v91; // ST48_4@18
  float v92; // ST60_4@18
  float v93; // ST60_4@18
  float v94; // ST48_4@18
  float v95; // ST60_4@18
  float v96; // ST60_4@18
  float v97; // ST60_4@18
  double v98; // st7@18
  char *v99; // eax@19
  char v100; // cl@20
  float v101; // ST5C_4@22
  float v102; // ST60_4@22
  float v103; // ST58_4@22
  signed int v104; // ST58_4@22
  float v105; // ST58_4@22
  signed int v106; // eax@25
  float v107; // ST48_4@26
  float v108; // ST44_4@26
  float v109; // ST60_4@26
  float v110; // ST60_4@26
  float v111; // ST44_4@27
  float v112; // [sp+14h] [bp-84h]@18
  char v113; // [sp+23h] [bp-75h]@0
  float v114; // [sp+28h] [bp-70h]@14
  float v115; // [sp+2Ch] [bp-6Ch]@14
  int v116; // [sp+30h] [bp-68h]@7
  float v117; // [sp+34h] [bp-64h]@7
  int v118; // [sp+38h] [bp-60h]@7
  float v119; // [sp+3Ch] [bp-5Ch]@16
  float v120; // [sp+40h] [bp-58h]@7
  float v121; // [sp+44h] [bp-54h]@7
  float v122; // [sp+48h] [bp-50h]@7
  float v123; // [sp+4Ch] [bp-4Ch]@7
  float v124; // [sp+50h] [bp-48h]@7
  float v125; // [sp+54h] [bp-44h]@16
  float v126; // [sp+58h] [bp-40h]@7
  float v127; // [sp+5Ch] [bp-3Ch]@16
  float v128; // [sp+60h] [bp-38h]@7
  float v129; // [sp+64h] [bp-34h]@7
  float v130; // [sp+68h] [bp-30h]@7
  float v131; // [sp+6Ch] [bp-2Ch]@7
  float v132; // [sp+70h] [bp-28h]@7
  float v133; // [sp+74h] [bp-24h]@16
  float v134; // [sp+78h] [bp-20h]@7
  float v135; // [sp+7Ch] [bp-1Ch]@16
  float v136; // [sp+80h] [bp-18h]@7
  float v137; // [sp+84h] [bp-14h]@7
  float v138; // [sp+88h] [bp-10h]@7
  float v139; // [sp+8Ch] [bp-Ch]@16
  float v140; // [sp+90h] [bp-8h]@7
  float v141; // [sp+94h] [bp-4h]@16
  float vars0; // [sp+98h] [bp+0h]@18

  j_gdi_pvg_push_attrib(0x2000);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32833 )
    {
      if ( *(_BYTE *)(a2 + 20) && a4 )
      {
        v6 = (void *)sub_100027C0(a1, 96);
        *a4 = (int)v6;
        memset(v6, 0, 0x60u);
        v7 = *a4;
        v116 = *(int *)(a2 + 12);
        v117 = *(float *)(a2 + 8);
        sub_10095C00((int)&v116, (int)&v116);
        v8 = *(float *)(a2 + 16) * 0.5;
        sub_10095BA0(v8, (int)&v116, (int)&v116);
        sub_10095BE0((int)&v116, (int)&v134);
        v9 = *(float *)(a2 + 24) * 0.5;
        v136 = *(float *)(a2 + 8) * v9 + *(float *)&v116;
        v137 = v9 * *(float *)(a2 + 12) + v117;
        sub_10095BC0((int)&v134, (int)&v116, (int)&v140);
        sub_10095BC0((int)&v136, (int)&v116, (int)&v138);
        sub_10095BE0((int)&v136, (int)&v118);
        sub_10095BE0((int)&v118, (int)&v120);
        v10 = 1.0 - *(float *)(a2 + 24);
        v120 = *(float *)(a2 + 8) * v10 + v120;
        v121 = v10 * *(float *)(a2 + 12) + v121;
        sub_10095BE0((int)&v138, (int)&v124);
        sub_10095BE0((int)&v124, (int)&v122);
        v11 = 1.0 - *(float *)(a2 + 24);
        v122 = *(float *)(a2 + 8) * v11 + v122;
        v123 = v11 * *(float *)(a2 + 12) + v123;
        sub_10095BE0((int)&v120, (int)&v126);
        sub_10095BE0((int)&v126, (int)&v128);
        v12 = *(float *)(a2 + 24) * 0.5;
        v128 = *(float *)(a2 + 8) * v12 + v128;
        v129 = v12 * *(float *)(a2 + 12) + v129;
        sub_10095BE0((int)&v122, (int)&v132);
        sub_10095BE0((int)&v132, (int)&v130);
        v13 = *(float *)(a2 + 24) * 0.5;
        v14 = v7 + 64;
        v130 = *(float *)(a2 + 8) * v13 + v130;
        v15 = 0;
        v131 = v13 * *(float *)(a2 + 12) + v131;
        do
        {
          sub_10095BE0((int)&v134 + v15, v14 - 64);
          sub_10095BE0((int)&v118 + v15, v14 - 32);
          sub_10095BE0((int)&v126 + v15, v14);
          v15 += 8;
          v14 += 8;
        }
        while ( v15 < 0x20 );
        j_gdi_pvg_pop_attrib();
        result = 2;
      }
      else
      {
        j_gdi_pvg_pop_attrib();
        result = v113;
      }
      return result;
    }
    if ( *a5 != 32888 )
    {
      j_gdi_pvg_pop_attrib();
      return 1;
    }
  }
  if ( *(_BYTE *)(a2 + 20) && *(float *)(a2 + 16) >= 2.0 && a4 && (v16 = *a4) != 0 )
  {
    v114 = (double)*(_WORD *)a3;
    v115 = (double)*(_WORD *)(a3 + 2);
    v116 = *(int *)(a2 + 12);
    v117 = *(float *)(a2 + 8);
    sub_10095C00((int)&v116, (int)&v116);
    v17 = *(float *)(a2 + 16) * 0.5;
    sub_10095BA0(v17, (int)&v116, (int)&v116);
    v18 = v16 + 64;
    v19 = 0;
    do
    {
      sub_10095BE0(v18 - 64, (int)&v134 + v19);
      sub_10095BE0(v18 - 32, (int)&v118 + v19);
      sub_10095BE0(v18, (int)&v126 + v19);
      v19 += 8;
      v18 += 8;
    }
    while ( v19 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_1008BFB0(1.0, 1.0, 1.0, 0.0);
    v20 = v135 + v115;
    v21 = v20;
    v22 = v134 + v114;
    sub_1008C2F0(v22, v21);
    v23 = v141 + v115;
    v24 = v23;
    v25 = v140 + v114;
    sub_1008C2F0(v25, v24);
    v26 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_1008BFB0(1.0, 1.0, 1.0, v26);
    v27 = v139 + v115;
    v28 = v27;
    v29 = v138 + v114;
    sub_1008C2F0(v29, v28);
    v30 = v115 + v137;
    v31 = v30;
    v32 = v114 + v136;
    sub_1008C2F0(v32, v31);
    j_gdi_pvg_end();
    v33 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_1008BFB0(1.0, 1.0, 1.0, v33);
    j_gdi_pvg_begin(72);
    v34 = v119 + v115;
    v35 = v34;
    v36 = *(float *)&v118 + v114;
    sub_1008C2F0(v36, v35);
    v37 = v125 + v115;
    v38 = v37;
    v39 = v124 + v114;
    sub_1008C2F0(v39, v38);
    v40 = v115 + v123;
    v41 = v40;
    v42 = v114 + v122;
    sub_1008C2F0(v42, v41);
    v43 = v115 + v121;
    v44 = v43;
    v45 = v114 + v120;
    sub_1008C2F0(v45, v44);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(72);
    v46 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_1008BFB0(1.0, 1.0, 1.0, v46);
    v47 = v127 + v115;
    v48 = v47;
    v49 = v126 + v114;
    sub_1008C2F0(v49, v48);
    v50 = v133 + v115;
    v51 = v50;
    v52 = v132 + v114;
    sub_1008C2F0(v52, v51);
    sub_1008BFB0(1.0, 1.0, 1.0, 0.0);
    v53 = v115 + v131;
    v54 = v53;
    v55 = v114 + v130;
    sub_1008C2F0(v55, v54);
    v56 = v115 + v129;
    v57 = v56;
    v58 = v114 + v128;
    sub_1008C2F0(v58, v57);
    j_gdi_pvg_end();
    v59 = 0;
    do
    {
      sub_10095BC0((int)&v134 + v59, (int)&v116, (int)&v134 + v59);
      sub_10095BC0((int)&v118 + v59, (int)&v116, (int)&v118 + v59);
      sub_10095BC0((int)&v126 + v59, (int)&v116, (int)&v126 + v59);
      v59 += 8;
    }
    while ( v59 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_1008BFB0(0.0, 0.0, 0.0, 0.0);
    v60 = v136 + *(float *)&v116;
    v61 = v60;
    v62 = v135 + v115;
    sub_1008C2F0(v62, v61);
    v63 = vars0 + *(float *)&v116;
    v64 = v63;
    v65 = v141 + v115;
    sub_1008C2F0(v65, v64);
    v66 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_1008BFB0(0.0, 0.0, 0.0, v66);
    v67 = v140 + *(float *)&v116;
    v68 = v67;
    v69 = v139 + v115;
    sub_1008C2F0(v69, v68);
    v70 = *(float *)&v116 + v138;
    v71 = v70;
    v72 = v115 + v137;
    sub_1008C2F0(v72, v71);
    j_gdi_pvg_end();
    v73 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_1008BFB0(0.0, 0.0, 0.0, v73);
    j_gdi_pvg_begin(72);
    v74 = v121 + v117;
    v75 = v74;
    v76 = v120 + *(float *)&v116;
    sub_1008C2F0(v76, v75);
    v77 = v127 + v117;
    v78 = v77;
    v79 = v126 + *(float *)&v116;
    sub_1008C2F0(v79, v78);
    v80 = v117 + v125;
    v81 = v80;
    v82 = *(float *)&v116 + v124;
    sub_1008C2F0(v82, v81);
    v83 = v117 + v123;
    v84 = v83;
    v85 = *(float *)&v116 + v122;
    sub_1008C2F0(v85, v84);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(72);
    v86 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_1008BFB0(0.0, 0.0, 0.0, v86);
    v87 = v129 + v117;
    v88 = v87;
    v89 = v128 + *(float *)&v116;
    sub_1008C2F0(v89, v88);
    v90 = v135 + v117;
    v91 = v90;
    v92 = v134 + *(float *)&v116;
    sub_1008C2F0(v92, v91);
    sub_1008BFB0(0.0, 0.0, 0.0, 0.0);
    v93 = v117 + v133;
    v94 = v93;
    v95 = *(float *)&v116 + v132;
    sub_1008C2F0(v95, v94);
    v96 = v117 + v131;
    v112 = v96;
    v97 = *(float *)&v116 + v130;
    v98 = v97;
  }
  else
  {
    v99 = (char *)(a2 + 28);
    do
      v100 = *v99++;
    while ( v100 );
    if ( v99 != (char *)(a2 + 29) )
    {
      v101 = (double)*(_WORD *)a3;
      v102 = (double)*(_WORD *)(a3 + 2);
      v116 = *(int *)(a2 + 12);
      v117 = -*(float *)(a2 + 8);
      sub_10095C00((int)&v116, (int)&v116);
      v103 = *(float *)(a2 + 16) * 0.5;
      sub_10095BA0(v103, (int)&v116, (int)&v116);
      v118 = v116;
      v119 = v117;
      v120 = *(float *)&v116 + *(float *)(a2 + 8);
      v121 = v117 + *(float *)(a2 + 12);
      sub_10095BA0(-2.0, (int)&v116, (int)&v116);
      v104 = *(_BYTE *)(a2 + 7);
      v124 = *(float *)&v118 + *(float *)&v116;
      v125 = v119 + v117;
      v122 = *(float *)&v116 + v120;
      v123 = v117 + v121;
      v105 = (double)v104 / 255.0;
      sub_100741C0(v101, v102, *(_DWORD *)(a1 + 80), (int)&v118, a2 + 28, v105, 0);
      j_gdi_pvg_pop_attrib();
      return 2;
    }
    if ( *(_BYTE *)(a2 + 78) & 1 )
    {
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 4));
    }
    else
    {
      v106 = sub_10065D00(*(_DWORD *)(a2 + 4));
      j_gdi_pvg_color_u32(v106);
    }
    sub_1008C110(*(float *)(a2 + 16));
    j_gdi_pvg_begin(64);
    v107 = (double)*(_WORD *)(a3 + 2);
    v108 = (double)*(_WORD *)a3;
    sub_1008C2F0(v108, v107);
    v109 = *(float *)(a2 + 12) + (double)*(_WORD *)(a3 + 2);
    v112 = v109;
    v110 = *(float *)(a2 + 8) + (double)*(_WORD *)a3;
    v98 = v110;
  }
  v111 = v98;
  sub_1008C2F0(v111, v112);
  j_gdi_pvg_end();
  j_gdi_pvg_pop_attrib();
  return 2;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 1008C1A0: using guessed type int j_gdi_pvg_pop_attrib(void);
// 1008C1C0: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (10046480) --------------------------------------------------------
int __cdecl sub_10046480(float a1, float a2, int a3)
{
  int result; // eax@1
  double v4; // st7@1
  float v5; // [sp+4h] [bp+4h]@1
  int v6; // [sp+Ch] [bp+Ch]@1

  result = a3;
  v4 = a1;
  v5 = a1 - *(float *)a3;
  *(float *)&v6 = a2 - *(float *)(a3 + 4);
  *(float *)result = v4;
  *(float *)(result + 4) = a2;
  *(float *)(result + 176) = *(float *)(result + 176) + v5;
  *(float *)(result + 180) = *(float *)(result + 180) + *(float *)&v6;
  *(float *)(result + 228) = *(float *)(result + 228) + v5;
  *(float *)(result + 232) = *(float *)(result + 232) + *(float *)&v6;
  *(float *)(result + 28) = *(float *)(result + 28) + v5;
  *(float *)(result + 32) = *(float *)(result + 32) + *(float *)&v6;
  *(float *)(result + 280) = *(float *)(result + 280) + v5;
  *(float *)(result + 284) = *(float *)(result + 284) + *(float *)&v6;
  *(float *)(result + 76) = *(float *)(result + 76) + v5;
  *(float *)(result + 80) = *(float *)(result + 80) + *(float *)&v6;
  *(float *)(result + 332) = *(float *)(result + 332) + v5;
  *(float *)(result + 336) = *(float *)(result + 336) + *(float *)&v6;
  *(float *)(result + 124) = *(float *)(result + 124) + v5;
  *(float *)(result + 128) = *(float *)(result + 128) + *(float *)&v6;
  *(float *)(result + 384) = v5 + *(float *)(result + 384);
  *(float *)(result + 388) = *(float *)&v6 + *(float *)(result + 388);
  return result;
}

//----- (10046580) --------------------------------------------------------
signed int __cdecl sub_10046580(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 440);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 440);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (100465F0) --------------------------------------------------------
signed int __cdecl sub_100465F0(int a1, signed int a2, int a3)
{
  signed int result; // eax@1
  int *v4; // edx@2
  int v5; // ecx@2

  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a3 + 48);
    v5 = a1 + 8;
    do
    {
      if ( result >= 3 )
        break;
      *v4 = v5;
      ++result;
      v5 += 12;
      v4 += 12;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (10046630) --------------------------------------------------------
int __cdecl sub_10046630(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 52) = *(float *)a1;
  *(float *)(a2 + 56) = *(float *)(a1 + 4);
  *(float *)(a2 + 100) = *(float *)a1;
  *(float *)(a2 + 104) = *(float *)(a1 + 4);
  *(float *)(a2 + 148) = *(float *)a1;
  *(float *)(a2 + 152) = *(float *)(a1 + 4);
  return result;
}

//----- (10046660) --------------------------------------------------------
void __usercall sub_10046660(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  float **v4; // ebp@1
  int v5; // edi@1
  float *v6; // ecx@2
  char v7; // al@4
  unsigned __int8 v8; // [sp+23h] [bp-5h]@1
  char v9; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v8 = 0;
  v3 = 0;
  v4 = (float **)(a1 + 48);
  v5 = a1 + 528;
  do
  {
    v6 = *v4;
    if ( *v4 )
    {
      if ( 9.8999998e24 != *v6 )
      {
        v7 = sub_1006E1D0(*v6, v2 + 436, 10, v5);
        if ( (unsigned __int8)v9 < (unsigned __int8)v7 )
        {
          v9 = v7;
          v8 = v3;
        }
      }
    }
    ++v3;
    v5 += 28;
    v4 += 12;
  }
  while ( v3 < 3u );
  sub_1006E390(v9, (_DWORD *)(v2 + 188), (int *)(v2 + 184), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_1006E390(v9, (_DWORD *)(v2 + 240), (int *)(v2 + 236), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_1006BEC0(a2, v2 + 176);
  sub_1006BEC0(a2, v2 + 228);
}

//----- (10046750) --------------------------------------------------------
int __usercall sub_10046750@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // eax@1
  double v8; // st6@1
  int v9; // ebp@1
  int v10; // esi@1
  double v11; // st5@1
  char *v12; // eax@4
  char v13; // cl@5
  int v14; // eax@6
  signed int v15; // ecx@6
  double v16; // st6@6
  double v17; // st5@6
  double v18; // st4@6
  double v19; // st3@6
  double v20; // st7@6
  double v21; // rt1@7
  double v22; // st3@7
  double v23; // rtt@7
  double v24; // rt0@8
  double v25; // st3@8
  double v26; // st6@8
  double v27; // rt1@8
  double v28; // st3@8
  double v29; // st5@8
  double v30; // rt2@8
  double v31; // st3@8
  double v32; // st4@8
  double v33; // rtt@8
  double v34; // st3@8
  double v35; // st7@8
  double v36; // rt0@8
  double v37; // st3@8
  double v38; // st6@8
  float v40; // [sp+14h] [bp+14h]@1
  float v41; // [sp+18h] [bp+18h]@3

  v7 = a3;
  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = a6;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 528;
  *(float *)(a1 + 12) = a7;
  v10 = a1 + 32;
  LODWORD(v40) = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 172) = 1;
  *(float *)(a1 + 24) = v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 + 4) = 0;
    v41 = a4 + v8;
    *(float *)(v10 - 4) = v41;
    *(_DWORD *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 12) = -1;
    *(float *)v10 = a5;
    *(_BYTE *)(v10 + 42) = 0;
    *(float *)(v10 + 20) = *(float *)(v7 + 4);
    *(float *)(v10 + 24) = *(float *)(v7 + 8);
    *(_DWORD *)(v10 + 16) = 0;
    *(_BYTE *)(v10 + 41) = 0;
    *(_BYTE *)(v10 + 40) = 0;
    *(float *)(v10 + 28) = 1.0;
    *(float *)(v10 + 32) = 1.0;
    *(float *)(v10 + 36) = 15.0;
    sub_1006E420(v9);
    v10 += 48;
    v9 += 28;
    --LODWORD(v40);
    if ( v40 == 0.0 )
      break;
    v7 = a3;
  }
  v12 = (char *)a2;
  *(float *)(a1 + 176) = a4;
  *(float *)(a1 + 180) = a5;
  *(_WORD *)(a1 + 516) = 12;
  *(_DWORD *)(a1 + 520) = &unk_100B8DC0;
  *(_BYTE *)(a1 + 524) = 1;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = -1;
  do
  {
    v13 = *v12;
    v12[a1 - a2 + 192] = *v12;
    ++v12;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 236) = 0;
  *(float *)(a1 + 216) = 0.0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_BYTE *)(a1 + 244) = 0;
  *(float *)(a1 + 220) = 1.0;
  v14 = a1 + 284;
  v15 = 3;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = a4;
  v16 = a4;
  *(float *)(a1 + 232) = a5;
  v17 = a5;
  *(float *)(a1 + 268) = 0.0;
  v18 = 0.0;
  *(float *)(a1 + 272) = 1.0;
  v19 = 12.0;
  v20 = 1.0;
  *(float *)(a1 + 276) = 12.0;
  while ( 1 )
  {
    v24 = v19;
    v25 = v16;
    v26 = v24;
    *(_DWORD *)(v14 + 4) = 0;
    *(float *)(v14 - 4) = v25;
    *(_DWORD *)(v14 + 8) = -1;
    v27 = v25;
    v28 = v17;
    v29 = v27;
    *(_BYTE *)(v14 + 12) = 0;
    *(float *)v14 = v28;
    v14 += 52;
    --v15;
    v30 = v28;
    v31 = v18;
    v32 = v30;
    *(float *)(v14 - 16) = v31;
    v33 = v31;
    v34 = v20;
    v35 = v33;
    *(float *)(v14 - 12) = v34;
    v36 = v34;
    v37 = v26;
    v38 = v36;
    *(float *)(v14 - 8) = v37;
    if ( !v15 )
      break;
    v21 = v37;
    v22 = v35;
    v20 = v38;
    v23 = v22;
    v16 = v29;
    v17 = v32;
    v19 = v21;
    v18 = v23;
  }
  *(_WORD *)(a1 + 173) = 0;
  *(_BYTE *)(a1 + 175) = 0;
  return sub_10046580((_BYTE *)a3, a1);
}

//----- (10046920) --------------------------------------------------------
int __cdecl sub_10046920(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_10046750(a1, a2, a3, a4, a5, a6, a7);
}

//----- (10046960) --------------------------------------------------------
char __cdecl sub_10046960(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  double v8; // st6@1
  char result; // al@1
  double v10; // st5@1
  double v11; // rt1@1
  double v12; // st5@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1
  float v16; // [sp+28h] [bp+14h]@1

  sub_10046750(a1, a2, a3, a4, a5, a6, a7);
  v7 = a4;
  *(float *)(a1 + 28) = a4;
  v8 = a5;
  result = 0;
  *(_BYTE *)(a1 + 172) = 2;
  *(_BYTE *)(a1 + 296) = 0;
  v13 = a5 + a7;
  v10 = v13;
  *(float *)(a1 + 32) = v13;
  *(float *)(a1 + 60) = 0.0;
  *(float *)(a1 + 64) = 1.0;
  *(float *)(a1 + 68) = 15.0;
  v14 = v7 + a6;
  *(float *)(a1 + 76) = v14;
  v11 = v14;
  *(float *)(a1 + 80) = v10;
  *(float *)(a1 + 108) = 1.0;
  *(float *)(a1 + 112) = 1.0;
  *(float *)(a1 + 116) = 15.0;
  v15 = a6 * 0.5 + v7;
  *(float *)(a1 + 176) = v15;
  v16 = a5 - 3.0;
  *(float *)(a1 + 180) = v16;
  *(float *)(a1 + 216) = 0.5;
  *(float *)(a1 + 220) = 1.0;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = v15;
  *(float *)(a1 + 232) = v8;
  *(float *)(a1 + 268) = 0.5;
  *(float *)(a1 + 272) = 0.0;
  *(float *)(a1 + 276) = 12.0;
  *(float *)(a1 + 280) = v7;
  *(float *)(a1 + 284) = v16;
  *(float *)(a1 + 320) = 0.0;
  *(float *)(a1 + 324) = 1.0;
  *(_BYTE *)(a1 + 348) = 0;
  *(float *)(a1 + 328) = 12.0;
  *(float *)(a1 + 332) = v11;
  v12 = v16;
  *(float *)(a1 + 336) = *(float *)&v12;
  *(float *)(a1 + 372) = 1.0;
  *(float *)(a1 + 376) = 1.0;
  *(float *)(a1 + 380) = 12.0;
  return result;
}

//----- (10046AD0) --------------------------------------------------------
void __cdecl sub_10046AD0(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // ebx@1
  int v4; // edi@1
  float *v5; // ecx@3
  char v6; // ST40_1@9
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 288;
  v3 = (int *)(a2 + 536);
  v4 = a2 + 48;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 )
      {
        if ( *(_BYTE *)(v4 + 26)
          || 9.8999998e24 != *v5
          && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5) )
        {
          v6 = sub_1006E1D0(*v5, a2 + 436, 10, (int)(v3 - 2));
          sub_1006E390(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 173), *v3);
          sub_1006BEC0(a1, v2 - 8);
        }
      }
    }
    v4 += 48;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (10046BA0) --------------------------------------------------------
void __usercall sub_10046BA0(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST44_1@11

  v2 = 0;
  if ( *(_BYTE *)(a1 + 172) )
  {
    v3 = (int *)(a1 + 536);
    v4 = a1 + 48;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && *(_BYTE *)(a1 + 174) != 1 )
      {
        if ( !*(_BYTE *)(v4 + 26)
          && (9.8999998e24 == *v5
           || *(_BYTE *)(v4 + 24) && (*(float *)(v4 + 4) > (double)*v5 || *(float *)(v4 + 8) < (double)*v5)) )
        {
          sub_1006A400(v4 - 20);
        }
        else
        {
          v6 = sub_1006E1D0(*v5, a1 + 436, 10, (int)(v3 - 2));
          sub_1006E300(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 174), *v3);
          sub_10068AE0(a2, v4 - 20, *(_WORD *)(a1 + 516), *(_DWORD *)(a1 + 520), *(_BYTE *)(a1 + 524));
        }
      }
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 172) );
  }
}

//----- (10046CB0) --------------------------------------------------------
char __cdecl sub_10046CB0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
    case 0x8022:
    case 0x8078:
      sub_10046660(a4, a1);
      sub_10046AD0(a1, a4);
      sub_10046BA0(a4, a1);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (10046D70) --------------------------------------------------------
signed int __cdecl sub_10046D70(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@2
  float *v4; // edi@2
  int v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = a2 + 200;
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      *(_BYTE *)(v3 + 4) = a1[result + 92];
      *(float *)v3 = *v4;
      ++result;
      ++v4;
      v3 += 8;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = a2 + 8 * result + 200;
    v6 = 10 - result;
    do
    {
      *(float *)v5 = 9.8999998e24;
      *(_BYTE *)(v5 + 4) = 10;
      v5 += 8;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (10046DE0) --------------------------------------------------------
int __usercall sub_10046DE0@<eax>(int a1@<eax>)
{
  int result; // eax@2
  float v2; // ST18_4@3
  float v3; // ST0C_4@3
  float v4; // ST18_4@3

  if ( *(_BYTE *)(a1 + 49) )
  {
    result = sub_100690D0(*(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12), -1);
  }
  else
  {
    v2 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
    v3 = v2;
    v4 = *(float *)(a1 + 8) + *(float *)a1;
    result = sub_10067FF0(*(float *)a1, *(float *)(a1 + 4), v4, v3, -1, 1.0);
  }
  return result;
}

//----- (10046E60) --------------------------------------------------------
void __usercall sub_10046E60(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@3
  int v3; // ecx@3
  float v4; // [sp+1Ch] [bp-28h]@3
  float v5; // [sp+20h] [bp-24h]@3
  int v6; // [sp+24h] [bp-20h]@3
  int v7; // [sp+28h] [bp-1Ch]@3
  char v8; // [sp+2Ch] [bp-18h]@3
  float v9; // [sp+34h] [bp-10h]@3
  float v10; // [sp+38h] [bp-Ch]@3
  float v11; // [sp+3Ch] [bp-8h]@3

  if ( *(float *)(a2 + 40) < (double)*(float *)(a2 + 44) || *(float *)(a2 + 36) > (double)*(float *)(a2 + 44) )
  {
    sub_100659D0(
      *(float *)(a2 + 16),
      *(float *)(a2 + 20),
      *(float *)(a2 + 24),
      *(float *)(a2 + 28),
      0.0,
      0.0,
      *(_BYTE *)(a2 + 32));
  }
  else
  {
    v2 = *(_DWORD *)(a2 + 164);
    v3 = *(_DWORD *)(a2 + 168);
    v11 = *(float *)(a2 + 176);
    v9 = 0.5;
    v6 = v2;
    v10 = 0.5;
    v7 = v3;
    sub_100649E0((int)&v8, (_BYTE *)(a2 + 172), 7);
    v4 = *(float *)(a2 + 156);
    v5 = *(float *)(a2 + 160);
    sub_1006C070(a1, (int)&v4);
  }
}

//----- (10046F40) --------------------------------------------------------
void __usercall sub_10046F40(int a1@<eax>, int a2@<ecx>)
{
  sub_1006BEC0(a2, a1 + 52);
}

//----- (10046F50) --------------------------------------------------------
int __thiscall sub_10046F50(int this)
{
  int result; // eax@2

  if ( *(float *)(this + 200) <= (double)*(float *)(this + 44) )
  {
    if ( *(float *)(this + 208) <= (double)*(float *)(this + 44) )
    {
      if ( *(float *)(this + 216) <= (double)*(float *)(this + 44) )
      {
        if ( *(float *)(this + 224) <= (double)*(float *)(this + 44) )
          result = sub_100649E0(this + 172, (_BYTE *)(this + 196), 4);
        else
          result = sub_100649E0(this + 172, (_BYTE *)(this + 192), 4);
      }
      else
      {
        result = sub_100649E0(this + 172, (_BYTE *)(this + 188), 4);
      }
    }
    else
    {
      result = sub_100649E0(this + 172, (_BYTE *)(this + 184), 4);
    }
  }
  else
  {
    result = sub_100649E0(this + 172, (_BYTE *)(this + 180), 4);
  }
  return result;
}

//----- (10047020) --------------------------------------------------------
char __cdecl sub_10047020(int a1, int a2, int a3, int a4, _WORD *a5)
{
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    sub_10046F50(a4);
    if ( *(_BYTE *)(a4 + 48) )
      sub_10046DE0(a4);
    sub_10046F40(a4, a1);
    sub_10046E60(a1, a4);
  }
  return 1;
}

//----- (10047070) --------------------------------------------------------
int __cdecl sub_10047070(int a1, int a2, int a3, float a4, float a5, float a6, float a7, float a8)
{
  signed int v8; // ecx@1
  double v9; // st4@1
  int v10; // eax@1
  double v11; // st6@1
  double v12; // st5@1
  double v13; // st3@1
  double v14; // st2@1
  double v15; // rtt@2
  double v16; // st2@2
  double v17; // rtt@3
  double v18; // st2@3
  double v19; // st5@3
  double v20; // st6@3
  double v21; // st2@3
  double v22; // st3@3
  float v24; // [sp+20h] [bp+20h]@1

  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = a6;
  *(_BYTE *)(a1 + 32) = 0;
  v8 = 0;
  *(float *)(a1 + 12) = a7;
  *(float *)(a1 + 28) = a7;
  *(float *)(a1 + 16) = a4;
  *(float *)(a1 + 20) = a5;
  *(float *)(a1 + 24) = a6;
  *(float *)(a1 + 36) = *(float *)(a3 + 4);
  v9 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 49) = LOBYTE(a8);
  *(float *)(a1 + 40) = v9;
  *(_BYTE *)(a1 + 48) = 1;
  v10 = a1 + 60;
  *(float *)(a1 + 44) = 9.8999998e24;
  v24 = a4 + a6 * 0.5;
  v11 = 0.5;
  v12 = 0.0;
  v13 = 12.0;
  v14 = v24;
  while ( 1 )
  {
    v17 = v14;
    ++v8;
    *(float *)(v10 + 32) = v11;
    v18 = v12;
    v19 = v11;
    *(_DWORD *)(v10 + 4) = -1;
    *(float *)(v10 + 36) = v18;
    *(_DWORD *)v10 = 0;
    v20 = v18;
    *(_BYTE *)(v10 + 8) = 0;
    *(float *)(v10 - 8) = v17;
    v10 += 52;
    *(float *)(v10 - 56) = a5 - (double)v8 * 16.0;
    v21 = v13;
    v22 = v17;
    *(float *)(v10 - 12) = v21;
    if ( v8 >= 2 )
      break;
    v15 = v21;
    v16 = v20;
    v11 = v19;
    v12 = v16;
    v14 = v22;
    v13 = v15;
  }
  sub_100649E0(a1 + 68, (_BYTE *)a2, 21);
  *(float *)(a1 + 156) = v24;
  *(_DWORD *)(a1 + 164) = 0;
  *(_DWORD *)(a1 + 168) = -16711681;
  *(float *)(a1 + 160) = a7 * 0.5 + a5;
  *(float *)(a1 + 176) = 15.0;
  sub_10046D70((_BYTE *)a3, a1);
  sub_100649E0(a1 + 180, "UP", 4);
  sub_100649E0(a1 + 184, "///", 4);
  sub_100649E0(a1 + 188, "T/O", 4);
  sub_100649E0(a1 + 192, "///", 4);
  return sub_100649E0(a1 + 196, "DN", 4);
}

//----- (10047210) --------------------------------------------------------
char __cdecl sub_10047210(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@4
  float v7; // ST38_4@5
  float v8; // ST38_4@5
  float v9; // ST24_4@5
  float v10; // ST38_4@5
  float v11; // ST20_4@5
  float v12; // ST38_4@5
  float v13; // ST28_4@5
  float v14; // ST2C_4@5
  float v15; // ST1C_4@5
  float v16; // ST30_4@5
  float v17; // ST24_4@5
  float v18; // ST20_4@5
  float v19; // ST30_4@5
  float v20; // ST2C_4@5
  float v21; // ST38_4@5
  float v22; // ST28_4@5
  float v23; // ST34_4@5
  float v24; // ST38_4@6
  float v25; // ST30_4@6
  float v26; // ST34_4@6
  float v27; // ST38_4@6
  float v28; // ST38_4@6
  float v29; // ST34_4@6
  float v30; // ST38_4@6
  double v31; // st7@6
  float v32; // ST08_4@8
  float v33; // [sp+4h] [bp-30h]@6
  float v34; // [sp+10h] [bp-24h]@4
  float v35; // [sp+48h] [bp+14h]@4
  float v36; // [sp+48h] [bp+14h]@6

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  v6 = *(_DWORD *)(a1 + 56);
  v34 = (double)*(_WORD *)(v6 + 34);
  v35 = (double)*(_WORD *)(v6 + 32);
  if ( !(*(_BYTE *)(a2 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    sub_1008C2F0(0.0, 0.0);
    sub_1008C2F0(v35, 0.0);
    sub_1008C2F0(v35, v34);
    v33 = v34;
    v31 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
  sub_1008C2F0(0.0, 0.0);
  sub_1008C2F0(v35, 0.0);
  sub_1008C2F0(v35, v34);
  sub_1008C2F0(0.0, v34);
  j_gdi_pvg_color_u32(-16777216);
  sub_1008C2F0(0.0, 0.0);
  sub_1008C2F0(v35, 0.0);
  v7 = 0.0 + 3.0;
  sub_1008C2F0(v35, v7);
  sub_1008C2F0(0.0, v7);
  v8 = v34 - 3.0;
  sub_1008C2F0(0.0, v8);
  sub_1008C2F0(v35, v8);
  sub_1008C2F0(v35, v34);
  sub_1008C2F0(0.0, v34);
  j_gdi_pvg_end();
  sub_1008C110(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v9 = v34 - 3.5;
  v10 = 0.0 + 0.5;
  sub_1008C2F0(v10, v9);
  v11 = 0.0 + 3.5;
  sub_1008C2F0(v10, v11);
  v12 = v35 - 0.0;
  sub_1008C2F0(v12, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v13 = 0.0 + 1.5;
  sub_1008C2F0(v13, v9);
  v14 = v35 - 0.5;
  sub_1008C2F0(v14, v9);
  sub_1008C2F0(v14, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v15 = v34 - 4.5;
  sub_1008C2F0(v13, v15);
  v16 = 0.0 + 4.5;
  sub_1008C2F0(v13, v16);
  sub_1008C2F0(v14, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v17 = 0.0 + 2.5;
  sub_1008C2F0(v17, v15);
  v18 = v35 - 1.5;
  sub_1008C2F0(v18, v15);
  sub_1008C2F0(v18, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_1008C2F0(v17, v15);
  v19 = v34 - 9.5;
  v20 = 0.0 + 7.5;
  sub_1008C2F0(v20, v19);
  sub_1008C2F0(v18, v15);
  v21 = v35 - 6.5;
  sub_1008C2F0(v21, v19);
  v22 = 0.0 + 5.5;
  sub_1008C2F0(v18, v22);
  v23 = 0.0 + 10.5;
  sub_1008C2F0(v21, v23);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_1008C2F0(v17, v15);
  sub_1008C2F0(v20, v19);
  sub_1008C2F0(v17, v22);
  sub_1008C2F0(v20, v23);
  sub_1008C2F0(v18, v22);
  sub_1008C2F0(v21, v23);
  j_gdi_pvg_end();
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v24 = 0.0 + 14.0;
    v25 = 0.0 + 11.0;
    sub_1008C2F0(v25, v24);
    v26 = v35 - 11.0;
    sub_1008C2F0(v26, v24);
    v27 = v34 - 14.0;
    sub_1008C2F0(v26, v27);
    sub_1008C2F0(v25, v27);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    v28 = 0.0 + 15.0;
    v29 = 0.0 + 12.0;
    sub_1008C2F0(v29, v28);
    v36 = v35 - 12.0;
    sub_1008C2F0(v36, v28);
    v30 = v34 - 15.0;
    sub_1008C2F0(v36, v30);
    v33 = v30;
    v31 = v29;
LABEL_8:
    v32 = v31;
    sub_1008C2F0(v32, v33);
    j_gdi_pvg_end();
  }
  return 2;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10047850) --------------------------------------------------------
char __cdecl sub_10047850(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // eax@1
  int v4; // edi@2
  int v5; // ecx@2
  int v6; // edx@3
  signed int v7; // edi@5
  char *v8; // ebp@6
  char result; // al@13
  signed int v10; // edi@15
  char *v11; // ebp@16
  int v12; // eax@26
  float *v13; // edi@27
  int v14; // ebp@28
  char v15; // [sp+14h] [bp+4h]@1

  v2 = a1;
  v15 = sub_1004CCA0(a1, 0);
  v3 = 0;
  if ( *(_BYTE *)v2 )
  {
    v4 = a2 + 76;
    v5 = v2 + 44;
    do
    {
      v6 = *(_BYTE *)(v2 + v3++ + 35) != 2;
      v4 += 4;
      *(_DWORD *)(v4 - 4) = v5 & (v6 - 1);
      v5 += 4;
    }
    while ( v3 < *(_BYTE *)v2 );
  }
  if ( v15 == 3 )
  {
    *(_DWORD *)(a2 + 4 * *(_BYTE *)(v2 + 34) + 76) = v2 + 4 * *(_BYTE *)(v2 + 34) + 44;
    v7 = 0;
    if ( *(_BYTE *)v2 )
    {
      v8 = (char *)(a2 + 172);
      do
      {
        strncpy(v8, byte_100B8180, 0x15u);
        ++v7;
        v8 += 52;
      }
      while ( v7 < *(_BYTE *)v2 );
    }
    if ( *(_BYTE *)(a2 + 973) )
    {
      if ( *(_BYTE *)(a2 + 973) == 1 )
        strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "R", 0x15u);
      else
        strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "1st", 0x15u);
    }
    else
    {
      strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "Rich", 0x15u);
    }
    *(float *)(52 * *(_BYTE *)(v2 + 34) + a2 + 204) = 12.0;
    result = 3;
    *(_BYTE *)(a2 + 962) = *(_BYTE *)(v2 + 34);
  }
  else if ( v15 == 2 )
  {
    v10 = 0;
    if ( *(_BYTE *)v2 )
    {
      v11 = (char *)(a2 + 172);
      do
      {
        strncpy(v11, byte_100B8180, 0x15u);
        ++v10;
        v11 += 52;
      }
      while ( v10 < *(_BYTE *)v2 );
    }
    if ( *(_BYTE *)(a2 + 973) )
    {
      if ( *(_BYTE *)(a2 + 973) == 1 )
        strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "L", 0x15u);
      else
        strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "Last", 0x15u);
    }
    else
    {
      strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), "Lean", 0x15u);
    }
    result = 2;
    *(float *)(52 * *(_BYTE *)(v2 + 34) + a2 + 204) = 12.0;
    *(_BYTE *)(a2 + 962) = *(_BYTE *)(v2 + 34);
  }
  else if ( *(_BYTE *)v2 == 1 )
  {
    strncpy((char *)(52 * *(_BYTE *)(v2 + 34) + a2 + 172), byte_100B8180, 0x15u);
    result = v15;
    *(_BYTE *)(a2 + 962) = *(_BYTE *)(v2 + 34);
  }
  else
  {
    v12 = 0;
    if ( *(_BYTE *)v2 )
    {
      v13 = (float *)(a2 + 204);
      do
      {
        v14 = v12 + 1;
        _snprintf((char *)v13 - 32, 0x15u, "%d", v12 + 1);
        *v13 = 9.0;
        v12 = v14;
        v13 += 13;
      }
      while ( v14 < *(_BYTE *)v2 );
    }
    result = v15;
    *(_BYTE *)(a2 + 962) = *(_BYTE *)(v2 + 34);
  }
  return result;
}

//----- (10047AA0) --------------------------------------------------------
signed int __cdecl sub_10047AA0(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 592);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 592);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (10047B10) --------------------------------------------------------
void __cdecl sub_10047B10(int a1, signed int a2, char a3, int a4)
{
  signed int v4; // esi@1
  int *v5; // edi@2
  int v6; // eax@2
  int *v7; // ecx@2

  v4 = 0;
  if ( a2 > 0 )
  {
    v5 = (int *)(a4 + 688);
    v6 = a1 + 8;
    v7 = (int *)(a4 + 52);
    do
    {
      if ( v4 >= 6 )
        break;
      *(v7 - 6) = v6 - 4;
      *v7 = v6;
      if ( a3 )
        *v5 = v6;
      ++v4;
      ++v7;
      v6 += 12;
      v5 += 12;
    }
    while ( v4 < a2 );
  }
}

//----- (10047B60) --------------------------------------------------------
int __cdecl sub_10047B60(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 692) = *(float *)a1;
  *(float *)(a2 + 696) = *(float *)(a1 + 4);
  *(float *)(a2 + 740) = *(float *)a1;
  *(float *)(a2 + 744) = *(float *)(a1 + 4);
  *(float *)(a2 + 788) = *(float *)a1;
  *(float *)(a2 + 792) = *(float *)(a1 + 4);
  *(float *)(a2 + 836) = *(float *)a1;
  *(float *)(a2 + 840) = *(float *)(a1 + 4);
  *(float *)(a2 + 884) = *(float *)a1;
  *(float *)(a2 + 888) = *(float *)(a1 + 4);
  *(float *)(a2 + 932) = *(float *)a1;
  *(float *)(a2 + 936) = *(float *)(a1 + 4);
  return result;
}

//----- (10047BD0) --------------------------------------------------------
void __usercall sub_10047BD0(int a1@<esi>)
{
  char *v1; // edi@2
  signed int v2; // ebx@2
  double v3; // ST28_8@4
  double v4; // st7@5
  float v5; // ST0C_4@9
  float v6; // ST28_4@9
  float v7; // ST04_4@9
  float v8; // [sp+24h] [bp-14h]@4
  float v9; // [sp+28h] [bp-10h]@4
  float v10; // [sp+28h] [bp-10h]@7
  int v11; // [sp+30h] [bp-8h]@4
  char v12; // [sp+34h] [bp-4h]@4

  if ( *(_BYTE *)(a1 + 956) != 1 )
  {
    v1 = (char *)(a1 + 600);
    v2 = 9;
    do
    {
      if ( (unsigned __int8)*v1 > 0xAu )
      {
        sub_1006E2C0(*v1, &v12, &v11, *(_BYTE *)(a1 + 956));
        v3 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
        v8 = v3 - sub_10065120(*((float *)v1 - 3), a1 + 980, *(_BYTE *)(a1 + 1076));
        v9 = *(float *)(a1 + 4);
        if ( v8 >= (double)v9 )
          v4 = v8;
        else
          v4 = v9;
        v10 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
        if ( v10 <= v4 )
          v4 = v10;
        v5 = v4;
        v6 = *(float *)(a1 + 8) + *(float *)a1;
        v7 = v4;
        sub_100682A0(*(float *)a1, v7, v6, v5, v11, 1.0);
      }
      v1 += 8;
      --v2;
    }
    while ( v2 );
  }
}

//----- (10047CE0) --------------------------------------------------------
void __usercall sub_10047CE0(int a1@<esi>)
{
  int v1; // ebx@2
  int v2; // edi@2
  int v3; // ebp@2
  float *v4; // ecx@3
  float v5; // ST30_4@6
  float v6; // ST30_4@6
  float v7; // ST30_4@7
  double v8; // st7@7
  float v9; // ST30_4@9
  double v10; // st7@9
  float v11; // ST30_4@11
  char v12; // ST3C_1@11
  signed int v13; // edi@13
  float v14; // ST3C_4@14
  double v15; // st7@14
  float v16; // ST18_4@14
  float v17; // ST3C_4@14
  float v18; // ST10_4@14
  int v19; // edi@16
  float **v20; // ebx@16
  signed int v21; // ebp@16
  float *v22; // eax@17
  float *v23; // ecx@19
  double v24; // ST3C_8@21
  float v25; // ST3C_4@23
  int v26; // edi@28
  float **v27; // ebp@28
  signed int v28; // ebx@28
  float v29; // [sp+28h] [bp-18h]@5
  float v30; // [sp+28h] [bp-18h]@21
  signed int v31; // [sp+2Ch] [bp-14h]@2
  signed int v32; // [sp+2Ch] [bp-14h]@13
  float v33; // [sp+30h] [bp-10h]@7
  float v34; // [sp+34h] [bp-Ch]@21
  char v35; // [sp+3Ch] [bp-4h]@11

  if ( *(_BYTE *)(a1 + 957) != 1 )
  {
    v1 = a1 + 1080;
    v2 = a1 + 480;
    v3 = a1 + 28;
    v31 = 6;
    do
    {
      v4 = *(float **)v3;
      if ( *(_DWORD *)v3 && 9.8999998e24 != *v4 )
      {
        v29 = *v4;
        if ( *(float *)(a1 + 976) > 0.0 )
        {
          v5 = *v4 - *(float *)(a1 + 20);
          v6 = sub_10095970(v5, *(float *)(a1 + 976));
          v29 = *(float *)(a1 + 20) + v6;
        }
        v7 = sub_10065120(v29, a1 + 980, *(_BYTE *)(a1 + 1076));
        *(float *)v2 = v7;
        v33 = *(float *)(a1 + 12);
        v8 = v7;
        if ( v33 <= (double)v7 )
          v8 = v33;
        v9 = v8;
        v10 = v9;
        *(float *)v2 = v9;
        if ( v9 <= 0.0 )
          v10 = 0.0;
        v11 = v10;
        *(float *)v2 = v11;
        v12 = sub_1006E1D0(**(float **)(v3 + 24), a1 + 588, 10, v1);
        sub_1006E2C0(v12, &v35, (_DWORD *)(v2 + 4), *(_BYTE *)(a1 + 957));
        sub_100674D0(v2 - 12);
      }
      v3 += 4;
      v1 += 28;
      v2 += 20;
      --v31;
    }
    while ( v31 );
    v13 = 0;
    v32 = 0;
    if ( *(_BYTE *)(a1 + 100) )
    {
      do
      {
        v14 = *(float *)(a1 + 12) / (double)*(_BYTE *)(a1 + 100) * (double)v32 + *(float *)(a1 + 4);
        v15 = v14;
        v16 = v14;
        v17 = *(float *)(a1 + 8) + *(float *)a1;
        v18 = v15;
        sub_100682A0(*(float *)a1, v18, v17, v16, -14671840, 1.0);
        v32 = ++v13;
      }
      while ( v13 < *(_BYTE *)(a1 + 100) );
    }
  }
  if ( *(_BYTE *)(a1 + 959) != 1 )
  {
    v19 = a1 + 472;
    v20 = (float **)(a1 + 76);
    v21 = 6;
    do
    {
      v22 = *(v20 - 12);
      if ( v22 )
      {
        if ( 9.8999998e24 != *v22 )
        {
          v23 = *v20;
          if ( *v20 )
          {
            if ( 9.8999998e24 != *v23 )
            {
              v24 = *(float *)v19;
              v30 = v24 - sub_10065120(*v23, a1 + 980, *(_BYTE *)(a1 + 1076));
              v34 = *(float *)v19;
              if ( v30 > (double)v34 )
                v30 = v34;
              v25 = *(float *)v19 - *(float *)(a1 + 12);
              if ( v25 >= (double)v30 )
                v30 = *(float *)v19 - *(float *)(a1 + 12);
              sub_100689C0(*(float *)(v19 - 4), v30, *(float *)(v19 + 4), -16711681);
            }
          }
        }
      }
      ++v20;
      v19 += 20;
      --v21;
    }
    while ( v21 );
  }
  if ( *(_BYTE *)(a1 + 957) != 1 )
  {
    v26 = a1 + 472;
    v27 = (float **)(a1 + 28);
    v28 = 6;
    do
    {
      if ( *v27 )
      {
        if ( 9.8999998e24 == **v27 )
          sub_100659D0(
            *(float *)(v26 - 4),
            *(float *)v26,
            *(float *)(v26 + 4),
            *(float *)(a1 + 12),
            0.0,
            1.0,
            *(_BYTE *)(a1 + 16));
      }
      ++v27;
      v26 += 20;
      --v28;
    }
    while ( v28 );
  }
}

//----- (10048020) --------------------------------------------------------
void __cdecl sub_10048020(int a1, int a2)
{
  signed int v2; // ebx@2
  int v3; // eax@3
  const void *v4; // [sp+4h] [bp-40h]@2
  char v5; // [sp+Ch] [bp-38h]@3
  int v6; // [sp+14h] [bp-30h]@5
  int v7; // [sp+18h] [bp-2Ch]@5

  if ( *(_BYTE *)(a2 + 958) != 1 )
  {
    v2 = 0;
    v4 = (const void *)(a2 + 156);
    do
    {
      v3 = *(_BYTE *)(a2 + 962);
      qmemcpy(&v5, v4, 0x34u);
      if ( v3 == v2 )
      {
        if ( *(_DWORD *)(a2 + 4 * v3 + 28) )
        {
          v7 = -16777216;
          v6 = -16711681;
        }
      }
      sub_1006BEC0(a1, (int)&v5);
      v4 = (char *)v4 + 52;
      ++v2;
    }
    while ( v2 < 6 );
  }
}

//----- (100480C0) --------------------------------------------------------
void __usercall sub_100480C0(int a1@<esi>, int a2)
{
  unsigned __int8 v2; // al@1
  int v3; // ecx@2
  float *v4; // eax@2
  char v5; // ST38_1@8

  v2 = *(_BYTE *)(a1 + 962);
  if ( v2 < 6u )
  {
    v3 = 48 * v2 + a1;
    v4 = *(float **)(v3 + 688);
    if ( v4 )
    {
      if ( *(_BYTE *)(a1 + 960) != 1 )
      {
        if ( 9.8999998e24 != *v4 || *(_BYTE *)(v3 + 714) == 1 )
        {
          v5 = sub_1006E1D0(
                 **(float **)(a1 + 4 * *(_BYTE *)(a1 + 962) + 52),
                 a1 + 588,
                 10,
                 a1 + 28 * *(_BYTE *)(a1 + 962) + 1080);
          sub_1006E300(
            v5,
            (_DWORD *)(a1 + 48 * *(_BYTE *)(a1 + 962) + 680),
            (int *)(a1 + 48 * *(_BYTE *)(a1 + 962) + 676),
            *(_BYTE *)(a1 + 960),
            *(_DWORD *)(a1 + 28 * *(_BYTE *)(a1 + 962) + 1088));
          sub_10068AE0(
            a2,
            48 * *(_BYTE *)(a1 + 962) + a1 + 668,
            *(_WORD *)(a1 + 964),
            *(_DWORD *)(a1 + 968),
            *(_BYTE *)(a1 + 972));
        }
        else if ( *(_BYTE *)(a1 + 957) == 1 )
        {
          sub_1006A400(v3 + 668);
        }
      }
    }
  }
}

//----- (100481E0) --------------------------------------------------------
void __usercall sub_100481E0(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // cl@1
  float **v4; // eax@2
  char v5; // ST24_1@4
  char v6; // al@6
  float **v7; // ebp@6
  int v8; // edi@6
  signed int v9; // ebx@6
  char v10; // [sp+23h] [bp-5h]@0
  char v11; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 962);
  v11 = 0;
  if ( v3 < 6u && (v4 = (float **)(a1 + 4 * v3 + 28), *(_DWORD *)(v2 + 4 * v3 + 28)) && 9.8999998e24 != **v4 )
  {
    v5 = sub_1006E1D0(**(float **)(v2 + 4 * v3 + 52), v2 + 588, 10, v2 + 28 * v3 + 1080);
    sub_1006E390(
      v5,
      (_DWORD *)(v2 + 116),
      (int *)(v2 + 112),
      *(_BYTE *)(v2 + 961),
      *(_DWORD *)(v2 + 28 * *(_BYTE *)(v2 + 962) + 1088));
  }
  else
  {
    if ( v3 == -1 )
    {
      v6 = v10;
      v7 = (float **)(v2 + 52);
      v8 = v2 + 1080;
      v9 = 6;
      do
      {
        if ( *v7 )
          v6 = sub_1006E1D0(**v7, v2 + 588, 10, v8);
        if ( (unsigned __int8)v6 > (unsigned __int8)v11 )
          v11 = v6;
        ++v7;
        v8 += 28;
        --v9;
      }
      while ( v9 );
    }
    sub_1006E390(
      v11,
      (_DWORD *)(v2 + 116),
      (int *)(v2 + 112),
      *(_BYTE *)(v2 + 961),
      *(_DWORD *)(v2 + 28 * *(_BYTE *)(v2 + 962) + 1088));
  }
  sub_1006BEC0(a2, v2 + 104);
}

//----- (100482F0) --------------------------------------------------------
char __cdecl sub_100482F0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_10047BD0(a4);
      sub_10047CE0(a4);
      sub_100481E0(a4, a1);
      sub_10048020(a1, a4);
      sub_100480C0(a4, a1);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_100481E0(a4, a1);
      sub_100480C0(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (100483D0) --------------------------------------------------------
int __cdecl sub_100483D0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  int v8; // esi@1
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st4@1
  int v12; // eax@1
  double v13; // st4@1
  double v14; // st5@1
  int v15; // ecx@2
  int v16; // ebp@2
  int v17; // edi@2
  double v18; // st7@2
  double v19; // st6@2
  float v20; // ST28_4@4
  float v21; // ST2C_4@4
  double v22; // st7@4
  double v23; // rt0@4
  double v24; // st6@4
  double v25; // rt0@7
  double v26; // st5@7
  double v27; // st7@7
  float v28; // ST28_4@9
  double v29; // st6@7
  int v30; // ebp@7
  int v31; // ecx@7
  int v32; // edi@7
  double v33; // st6@9
  double v34; // st6@9
  int v35; // eax@10
  double v36; // st7@10
  signed int v37; // edi@10
  double v38; // st6@10
  double v39; // st5@10
  double v40; // rt2@11
  double v41; // st5@11
  double v42; // rtt@11
  double v43; // st4@12
  double v44; // rt0@12
  double v45; // st5@12
  double v46; // st7@12
  double v47; // rt1@12
  double v48; // st5@12
  double v49; // st6@12
  int result; // eax@14
  int v51; // [sp+0h] [bp-28h]@2
  int v52; // [sp+4h] [bp-24h]@2
  float v53; // [sp+Ch] [bp-1Ch]@7
  double v54; // [sp+10h] [bp-18h]@2
  double v55; // [sp+10h] [bp-18h]@7
  double v56; // [sp+18h] [bp-10h]@2
  int v57; // [sp+2Ch] [bp+4h]@1
  float v58; // [sp+38h] [bp+10h]@10
  float v59; // [sp+3Ch] [bp+14h]@7
  int v60; // [sp+44h] [bp+1Ch]@7

  v8 = a1;
  *(float *)a1 = a4;
  v9 = a5;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)(a1 + 4) = a5;
  v10 = a6;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 100) = 0;
  *(float *)(a1 + 24) = v11;
  *(float *)(a1 + 976) = 0.0;
  *(float *)(a1 + 980) = 0.0;
  *(float *)(a1 + 984) = 0.0;
  *(float *)(a1 + 988) = 1.0;
  *(float *)(a1 + 1000) = 1.0;
  *(float *)(a1 + 1012) = 1.0;
  *(float *)(a1 + 1024) = 1.0;
  *(float *)(a1 + 1036) = 1.0;
  *(float *)(a1 + 1048) = 1.0;
  *(float *)(a1 + 1060) = 1.0;
  *(float *)(a1 + 1072) = 1.0;
  *(float *)(a1 + 992) = 0.0;
  *(float *)(a1 + 996) = 0.0;
  *(float *)(a1 + 1004) = 0.0;
  *(float *)(a1 + 1008) = 0.0;
  *(float *)(a1 + 1016) = 0.0;
  *(float *)(a1 + 1020) = 0.0;
  *(float *)(a1 + 1028) = 0.0;
  *(float *)(a1 + 1032) = 0.0;
  *(float *)(a1 + 1040) = 0.0;
  *(float *)(a1 + 1044) = 0.0;
  *(float *)(a1 + 1052) = 0.0;
  *(float *)(a1 + 1056) = 0.0;
  *(float *)(a1 + 1064) = 0.0;
  *(float *)(a1 + 1068) = 0.0;
  *(_BYTE *)(a1 + 1076) = 2;
  *(float *)(a1 + 980) = *(float *)(a3 + 4);
  v12 = 0;
  *(float *)(a1 + 992) = *(float *)(a3 + 8);
  v57 = 0;
  *(float *)(v8 + 984) = 0.0;
  v13 = a7;
  v14 = 0.0;
  *(float *)(v8 + 996) = a7;
  if ( a8 <= 0 )
    goto LABEL_7;
  v52 = v8 + 1080;
  v15 = v8 + 52;
  v16 = v8 + 160;
  v17 = v8 + 476;
  v51 = v8 + 52;
  v54 = v10 / (double)a8;
  v18 = v54;
  v19 = 0.0;
  v56 = a7 + a5;
  while ( 1 )
  {
    *(_DWORD *)(v15 - 24) = 0;
    *(_DWORD *)v15 = 0;
    v22 = v18 * (double)v57;
    *(_DWORD *)(v17 + 8) = -1;
    v23 = v19;
    v57 = v12 + 1;
    *(float *)(v17 - 8) = v22 + a4 + 0.2000000029802322 * v54;
    v20 = v56;
    *(float *)(v17 - 4) = v20;
    v21 = v54 * 0.800000011920929;
    *(float *)v17 = v21;
    *(float *)(v17 + 4) = v19;
    *(_DWORD *)(v15 + 24) = 0;
    *(float *)(v16 - 4) = *(float *)v17 * 0.5 + *(float *)(v17 - 8);
    v24 = *(float *)(v17 - 4);
    *(_DWORD *)(v16 + 8) = -1;
    *(_DWORD *)(v16 + 4) = 0;
    *(float *)v16 = v24 + 4.0;
    *(float *)(v16 + 36) = 0.5;
    *(float *)(v16 + 40) = v23;
    *(float *)(v16 + 44) = 9.0;
    sprintf((char *)(v16 + 12), "%d", v12 + 1);
    sub_1006E420(v52);
    v12 = v57;
    v51 += 4;
    v52 += 28;
    v17 += 20;
    v16 += 52;
    if ( v57 >= a8 )
      break;
    v18 = v54;
    v15 = v51;
    v19 = 0.0;
  }
  if ( v57 < 6 )
  {
    v10 = a6;
    v9 = a5;
    v13 = a7;
    v14 = 0.0;
LABEL_7:
    v25 = v14;
    v26 = v9 + v13;
    v27 = v25;
    v56 = v26;
    v29 = v10 / (double)a8;
    v60 = v8 + 28 * v12 + 1080;
    v30 = 52 * v12 + v8 + 160;
    v31 = v8 + 4 * v12 + 52;
    v32 = v8 + 20 * v12 + 476;
    LODWORD(v59) = v8 + 4 * v12 + 52;
    v55 = v29;
    v53 = 0.8999999761581421 * v29;
    while ( 1 )
    {
      v33 = v29 * (double)v57;
      *(_DWORD *)(v31 - 24) = 0;
      *(_DWORD *)v31 = 0;
      *(_DWORD *)(v32 + 8) = -1;
      v57 = v12 + 1;
      *(float *)(v32 - 8) = v33 + a4;
      v28 = v26;
      *(float *)(v32 - 4) = v28;
      *(float *)v32 = v53;
      *(float *)(v32 + 4) = v27;
      *(_DWORD *)(v31 + 24) = 0;
      *(float *)(v30 - 4) = *(float *)v32 * 0.5 + *(float *)(v32 - 8);
      v34 = *(float *)(v32 - 4);
      *(_DWORD *)(v30 + 4) = 0;
      *(_DWORD *)(v30 + 8) = 0;
      *(float *)v30 = v34 + 4.0;
      *(float *)(v30 + 36) = 0.5;
      *(float *)(v30 + 40) = v27;
      *(float *)(v30 + 44) = 9.0;
      sprintf((char *)(v30 + 12), "%d", v12 + 1);
      sub_1006E420(v60);
      v12 = v57;
      LODWORD(v59) += 4;
      v60 += 28;
      v32 += 20;
      v30 += 52;
      if ( v57 >= 6 )
        break;
      v31 = LODWORD(v59);
      v29 = v55;
      v27 = 0.0;
    }
  }
  *(float *)(v8 + 104) = a4;
  *(_DWORD *)(v8 + 112) = 0;
  *(_DWORD *)(v8 + 116) = -1;
  *(float *)(v8 + 108) = v56 + 9.0 + 15.0 + 8.0;
  sub_100649E0(v8 + 120, (_BYTE *)a2, 21);
  *(float *)(v8 + 144) = 0.0;
  v35 = v8 + 672;
  v36 = 1.0;
  v37 = 6;
  *(float *)(v8 + 148) = 1.0;
  *(float *)(v8 + 152) = 12.0;
  v58 = a4 + a6;
  v38 = 15.0;
  v39 = v58;
  while ( 1 )
  {
    *(float *)(v35 - 4) = v39;
    v43 = *(float *)(v8 + 108);
    *(_BYTE *)(v35 + 40) = 0;
    *(float *)v35 = v43;
    *(_BYTE *)(v35 + 41) = 0;
    *(_DWORD *)(v35 + 4) = 0;
    *(_DWORD *)(v35 + 8) = -1;
    *(_DWORD *)(v35 + 12) = -1;
    *(_BYTE *)(v35 + 42) = 0;
    *(float *)(v35 + 20) = *(float *)(a3 + 4);
    v35 += 48;
    --v37;
    *(float *)(v35 - 24) = *(float *)(a3 + 8);
    *(_DWORD *)(v35 - 32) = 0;
    v44 = v39;
    v45 = v36;
    v46 = v44;
    *(float *)(v35 - 20) = v45;
    *(float *)(v35 - 16) = v45;
    v47 = v45;
    v48 = v38;
    v49 = v47;
    *(float *)(v35 - 12) = v48;
    if ( !v37 )
      break;
    v40 = v48;
    v41 = v49;
    v38 = v40;
    v42 = v41;
    v39 = v46;
    v36 = v42;
  }
  *(_BYTE *)(v8 + 962) = 0;
  *(_WORD *)(v8 + 964) = 12;
  *(_DWORD *)(v8 + 968) = &unk_100B8DC0;
  *(_BYTE *)(v8 + 972) = 1;
  *(_DWORD *)(v8 + 956) = 0;
  *(_WORD *)(v8 + 960) = 0;
  if ( a8 == 1 )
  {
    *(_BYTE *)(v8 + 172) = 0;
    *(_BYTE *)(v8 + 973) = 0;
    result = sub_10047AA0((_BYTE *)a3, v8);
  }
  else
  {
    *(_BYTE *)(v8 + 973) = 2;
    result = sub_10047AA0((_BYTE *)a3, v8);
  }
  return result;
}

//----- (10048850) --------------------------------------------------------
int __cdecl sub_10048850(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_100483D0(a1, a2, a3, a4, a5, a6, a7, 6);
}

//----- (10048890) --------------------------------------------------------
signed int __cdecl sub_10048890(int a1)
{
  unsigned __int8 v1; // cl@1
  signed int result; // eax@1

  v1 = *(_BYTE *)(a1 + 4036);
  result = -1;
  if ( v1 < 0x31u )
  {
    result = v1;
    *(_BYTE *)(a1 + 4036) = v1 + 1;
  }
  return result;
}

//----- (100488B0) --------------------------------------------------------
void __cdecl sub_100488B0(float a1, char *a2, float a3, float a4, int a5)
{
  double v5; // st7@1
  int v6; // esi@2
  int v7; // ST04_4@3
  double v8; // st7@3
  int v9; // ST10_4@4
  double v10; // st7@4
  double v11; // st7@4
  char v12; // [sp+3Bh] [bp-15h]@3
  float v13; // [sp+3Ch] [bp-14h]@1
  double v14; // [sp+40h] [bp-10h]@1
  double v15; // [sp+48h] [bp-8h]@1

  *(float *)&v14 = a1 * 0.5 + *(float *)(a5 + 24);
  v13 = *(float *)(a5 + 20);
  v15 = *(float *)&v14;
  v5 = v13;
  if ( v13 < (double)*(float *)&v14 )
  {
    v6 = a5 + 856;
    do
    {
      *(float *)&v7 = v5;
      v8 = sub_1006D0E0(v7, *(_WORD *)(a5 + 4312), *(_BYTE *)(a5 + 4320), &v12);
      sub_10064B00((char *)(v6 + 16), 7u, a2, v8 * a3);
      if ( *(_BYTE *)(a5 + 4208) == 1 )
      {
        *(float *)v6 = *(float *)(a5 + 4192) + 4.0;
        v9 = *(_BYTE *)(a5 + 4308);
        v14 = *(float *)(a5 + 4196);
        v10 = sub_10065120(v13, a5 + 4212, v9);
        *(float *)(v6 + 4) = v14 - v10;
        *(float *)(v6 + 28) = 0.5;
        v11 = 0.0;
      }
      else
      {
        *(float *)v6 = sub_10065120(v13, a5 + 4212, *(_BYTE *)(a5 + 4308)) + *(float *)a5;
        *(float *)(v6 + 4) = *(float *)(a5 + 12) + *(float *)(a5 + 4) + 3.0;
        *(float *)(v6 + 28) = 0.0;
        v11 = 0.5;
      }
      *(float *)(v6 + 24) = v11;
      *(_DWORD *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 12) = -1;
      *(float *)(v6 + 32) = a4;
      v6 += 64;
      v13 = v13 + a1;
      v5 = v13;
    }
    while ( v13 < v15 );
  }
}

//----- (10048A00) --------------------------------------------------------
int __cdecl sub_10048A00(float a1, float a2, int a3)
{
  int result; // eax@1
  double v4; // st7@1
  double v5; // st7@1
  double v6; // st6@1
  signed int v7; // edx@1
  int v8; // ecx@2
  double v9; // st5@3
  float v10; // [sp+4h] [bp+4h]@1
  int v11; // [sp+Ch] [bp+Ch]@1

  result = a3;
  v4 = a1;
  v10 = a1 - *(float *)a3;
  *(float *)&v11 = a2 - *(float *)(a3 + 4);
  *(float *)result = v4;
  *(float *)(result + 4) = a2;
  v5 = v10;
  *(float *)(result + 4192) = *(float *)(result + 4192) + v10;
  v6 = *(float *)&v11;
  *(float *)(result + 4196) = *(float *)&v11 + *(float *)(result + 4196);
  *(float *)(result + 168) = *(float *)(result + 168) + v10;
  *(float *)(result + 172) = *(float *)(result + 172) + *(float *)&v11;
  *(float *)(result + 188) = *(float *)(result + 188) + v10;
  *(float *)(result + 192) = *(float *)(result + 192) + *(float *)&v11;
  *(float *)(result + 208) = *(float *)(result + 208) + v10;
  *(float *)(result + 212) = *(float *)(result + 212) + *(float *)&v11;
  *(float *)(result + 228) = *(float *)(result + 228) + v10;
  *(float *)(result + 232) = *(float *)(result + 232) + *(float *)&v11;
  *(float *)(result + 248) = *(float *)(result + 248) + v10;
  *(float *)(result + 252) = *(float *)(result + 252) + *(float *)&v11;
  *(float *)(result + 268) = *(float *)(result + 268) + v10;
  *(float *)(result + 272) = *(float *)(result + 272) + *(float *)&v11;
  *(float *)(result + 288) = *(float *)(result + 288) + v10;
  *(float *)(result + 292) = *(float *)(result + 292) + *(float *)&v11;
  *(float *)(result + 308) = *(float *)(result + 308) + v10;
  *(float *)(result + 312) = *(float *)(result + 312) + *(float *)&v11;
  *(float *)(result + 328) = *(float *)(result + 328) + v10;
  *(float *)(result + 332) = *(float *)(result + 332) + *(float *)&v11;
  *(float *)(result + 348) = *(float *)(result + 348) + v10;
  *(float *)(result + 352) = *(float *)(result + 352) + *(float *)&v11;
  *(float *)(result + 452) = v10 + *(float *)(result + 452);
  *(float *)(result + 456) = *(float *)&v11 + *(float *)(result + 456);
  *(float *)(result + 468) = v10 + *(float *)(result + 468);
  *(float *)(result + 472) = *(float *)&v11 + *(float *)(result + 472);
  *(float *)(result + 516) = v10 + *(float *)(result + 516);
  *(float *)(result + 520) = *(float *)&v11 + *(float *)(result + 520);
  *(float *)(result + 532) = v10 + *(float *)(result + 532);
  *(float *)(result + 536) = *(float *)&v11 + *(float *)(result + 536);
  *(float *)(result + 580) = v10 + *(float *)(result + 580);
  *(float *)(result + 584) = *(float *)&v11 + *(float *)(result + 584);
  *(float *)(result + 596) = v10 + *(float *)(result + 596);
  *(float *)(result + 600) = *(float *)&v11 + *(float *)(result + 600);
  *(float *)(result + 644) = v10 + *(float *)(result + 644);
  *(float *)(result + 648) = *(float *)&v11 + *(float *)(result + 648);
  *(float *)(result + 660) = v10 + *(float *)(result + 660);
  *(float *)(result + 664) = *(float *)&v11 + *(float *)(result + 664);
  *(float *)(result + 708) = v10 + *(float *)(result + 708);
  *(float *)(result + 712) = *(float *)&v11 + *(float *)(result + 712);
  *(float *)(result + 724) = v10 + *(float *)(result + 724);
  *(float *)(result + 728) = *(float *)&v11 + *(float *)(result + 728);
  *(float *)(result + 772) = v10 + *(float *)(result + 772);
  *(float *)(result + 776) = *(float *)&v11 + *(float *)(result + 776);
  *(float *)(result + 788) = v10 + *(float *)(result + 788);
  *(float *)(result + 792) = *(float *)&v11 + *(float *)(result + 792);
  *(float *)(result + 64) = *(float *)(result + 64) + v10;
  *(float *)(result + 68) = *(float *)(result + 68) + *(float *)&v11;
  *(float *)(result + 116) = *(float *)(result + 116) + v10;
  v7 = 0;
  *(float *)(result + 120) = *(float *)(result + 120) + *(float *)&v11;
  if ( *(_BYTE *)(result + 4036) )
  {
    v8 = result + 860;
    do
    {
      ++v7;
      v9 = *(float *)(v8 - 4) + v5;
      v8 += 64;
      *(float *)(v8 - 68) = v9;
      *(float *)(v8 - 64) = *(float *)(v8 - 64) + v6;
      *(float *)(v8 - 88) = *(float *)(v8 - 88) + v5;
      *(float *)(v8 - 84) = v5 + *(float *)(v8 - 84);
      *(float *)(v8 - 80) = *(float *)(v8 - 80) + v6;
      *(float *)(v8 - 76) = *(float *)(v8 - 76) + v6;
    }
    while ( v7 < *(_BYTE *)(result + 4036) );
  }
  *(float *)(result + 4040) = *(float *)(result + 4040) + v5;
  *(float *)(result + 4044) = *(float *)(result + 4044) + v6;
  *(float *)(result + 4088) = *(float *)(result + 4088) + v5;
  *(float *)(result + 4092) = *(float *)(result + 4092) + v6;
  *(float *)(result + 4136) = v5 + *(float *)(result + 4136);
  *(float *)(result + 4140) = v6 + *(float *)(result + 4140);
  return result;
}

//----- (10048D80) --------------------------------------------------------
void __cdecl sub_10048D80(int a1, float a2, float a3, int a4)
{
  double v4; // st7@1
  int v5; // edi@1
  signed int v6; // esi@1
  int v7; // ebx@3
  int v8; // ebp@3
  double v9; // st6@5
  double v10; // st5@6
  float v11; // ST24_4@8
  int v12; // ebx@11
  int v13; // ebp@11
  double v14; // st6@13
  double v15; // st5@16
  float v16; // ST24_4@18
  double v17; // st6@21
  int v18; // eax@21
  int v19; // ecx@21
  int v20; // edx@21
  float v21; // [sp+1Ch] [bp-Ch]@1
  float *v22; // [sp+20h] [bp-8h]@3
  int v23; // [sp+20h] [bp-8h]@11
  int v24; // [sp+38h] [bp+10h]@6
  int v25; // [sp+38h] [bp+10h]@6
  int v26; // [sp+38h] [bp+10h]@6
  int v27; // [sp+38h] [bp+10h]@8
  int v28; // [sp+38h] [bp+10h]@16
  int v29; // [sp+38h] [bp+10h]@16
  int v30; // [sp+38h] [bp+10h]@16
  int v31; // [sp+38h] [bp+10h]@18

  v4 = 0.0;
  v21 = 0.0;
  v5 = a4;
  v6 = 0;
  if ( *(_BYTE *)(a4 + 4208) == 1 )
  {
    if ( *(_BYTE *)a1 )
    {
      v22 = (float *)(a4 + 376);
      v7 = a1 + 12;
      v8 = a4 + 168;
      while ( 1 )
      {
        v9 = a3;
        if ( v6 >= 10 )
          goto LABEL_23;
        *(float *)&v24 = *(float *)(v5 + 4200) * a2;
        *(float *)(v8 + 8) = *(float *)&v24;
        *(float *)&v25 = *(float *)(v5 + 4192) - *(float *)&v24 + *(float *)&v24 * v9;
        v10 = *(float *)&v25;
        v26 = 1;
        *(float *)v8 = v10;
        if ( v9 != v4 )
          v26 = 0;
        v11 = v10;
        *(float *)v8 = v11 - (double)v26;
        *(float *)(v8 + 4) = *(float *)(v5 + 4196) - v21;
        *(float *)&v27 = sub_10065120(*(float *)v7, v5 + 4212, *(_BYTE *)(v5 + 4308));
        ++v6;
        v7 += 4;
        v8 += 20;
        *(float *)(v8 - 8) = -(*(float *)&v27 - v21);
        *(_DWORD *)(v8 - 4) = *(_DWORD *)(v7 + 36);
        *(v22 - 1) = *(float *)(v7 - 4);
        *(_BYTE *)v22 = *(_BYTE *)(v6 + a1 + 91);
        v21 = *(float *)&v27;
        v22 += 2;
        if ( v6 >= *(_BYTE *)a1 )
          goto LABEL_19;
        v4 = 0.0;
      }
    }
LABEL_21:
    v17 = 9.8999998e24;
    v18 = v5 + 20 * v6 + 172;
    v19 = v5 + 8 * v6 + 372;
    v20 = 10 - v6;
    do
    {
      *(_DWORD *)(v18 + 12) = 0;
      *(float *)(v18 - 4) = v4;
      v18 += 20;
      *(float *)(v18 - 20) = v4;
      v19 += 8;
      --v20;
      *(float *)(v18 - 16) = v4;
      *(float *)(v18 - 12) = v4;
      *(_BYTE *)(v19 - 4) = 10;
      *(float *)(v19 - 8) = *(float *)&v17;
    }
    while ( v20 );
LABEL_23:
    *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
    return;
  }
  *(float *)(a4 + 168) = *(float *)(a4 + 4192);
  if ( !*(_BYTE *)a1 )
    goto LABEL_21;
  v23 = a4 + 376;
  v12 = a1 + 12;
  v13 = a4 + 148;
  while ( 1 )
  {
    v14 = a3;
    if ( v6 >= 10 )
    {
      *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
      return;
    }
    if ( v6 > 0 )
      *(float *)(v13 + 20) = *(float *)(v13 + 8) + *(float *)v13;
    *(float *)&v28 = *(float *)(v5 + 4204) * a2;
    *(float *)(v13 + 32) = *(float *)&v28;
    *(float *)&v29 = *(float *)(v5 + 4196) - *(float *)&v28 + *(float *)&v28 * v14;
    v15 = *(float *)&v29;
    v30 = 1;
    *(float *)(v13 + 24) = v15;
    if ( v14 != v4 )
      v30 = 0;
    v16 = v15;
    *(float *)(v13 + 24) = v16 - (double)v30;
    *(float *)&v31 = sub_10065120(*(float *)v12, v5 + 4212, *(_BYTE *)(v5 + 4308));
    v23 += 8;
    ++v6;
    *(float *)(v13 + 28) = *(float *)&v31 - v21;
    *(_DWORD *)(v13 + 36) = *(_DWORD *)(v12 + 40);
    *(float *)(v23 - 12) = *(float *)v12;
    *(_BYTE *)(v23 - 8) = *(_BYTE *)(v6 + a1 + 91);
    v21 = *(float *)&v31;
    v12 += 4;
    v13 += 20;
    if ( v6 >= *(_BYTE *)a1 )
      break;
    v4 = 0.0;
  }
LABEL_19:
  if ( v6 < 10 )
  {
    v4 = 0.0;
    goto LABEL_21;
  }
  *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
}

//----- (10049040) --------------------------------------------------------
void __cdecl sub_10049040(int a1, signed int a2, char a3, int a4)
{
  signed int v4; // esi@1
  int *v5; // edi@2
  int v6; // eax@2
  int *v7; // ecx@2

  v4 = 0;
  if ( a2 > 0 )
  {
    v5 = (int *)(a4 + 4060);
    v6 = a1 + 8;
    v7 = (int *)(a4 + 52);
    do
    {
      if ( v4 >= 3 )
        break;
      *(v7 - 6) = v6 - 4;
      *v7 = v6;
      if ( a3 )
        *v5 = v6;
      ++v4;
      ++v7;
      v6 += 12;
      v5 += 12;
    }
    while ( v4 < a2 );
  }
}

//----- (10049090) --------------------------------------------------------
int __cdecl sub_10049090(unsigned __int8 a1, int a2)
{
  int result; // eax@1
  signed int v3; // edi@1

  result = a2 + 464;
  v3 = 6;
  do
  {
    *(_BYTE *)(result + 50) = a1;
    if ( *(_BYTE *)(a2 + 4208) == 1 )
      *(float *)result = *(float *)(a2 + 4204) * flt_100D6778[a1];
    else
      *(float *)(result - 4) = *(float *)(a2 + 4200) * flt_100D6778[a1];
    result += 64;
    --v3;
  }
  while ( v3 );
  return result;
}
// 100D6778: using guessed type float flt_100D6778[];

//----- (100490F0) --------------------------------------------------------
int __cdecl sub_100490F0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 4064) = *(float *)a1;
  *(float *)(a2 + 4068) = *(float *)(a1 + 4);
  *(float *)(a2 + 4112) = *(float *)a1;
  *(float *)(a2 + 4116) = *(float *)(a1 + 4);
  *(float *)(a2 + 4160) = *(float *)a1;
  *(float *)(a2 + 4164) = *(float *)(a1 + 4);
  return result;
}

//----- (10049130) --------------------------------------------------------
char *__cdecl sub_10049130(int a1, float a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@2
  double v5; // ST20_8@2
  char *result; // eax@2
  double v7; // st7@2
  float v8; // [sp+2Ch] [bp+8h]@2
  float v9; // [sp+2Ch] [bp+8h]@3

  v3 = LOBYTE(a2);
  if ( *(_BYTE *)(a3 + 4208) == 1 )
  {
    *(float *)((LOBYTE(a2) << 6) + a3 + 836) = *(float *)(a3 + 4192);
    v4 = (LOBYTE(a2) << 6) + a3;
    v5 = *(float *)(a3 + 4196);
    *(float *)(v4 + 844) = v5 - sub_10065120(*(float *)a1, a3 + 4212, *(_BYTE *)(a3 + 4308));
    v8 = *(float *)(a3 + 4200) * *(float *)(a1 + 4);
    *(float *)(v4 + 840) = (double)sub_10095940(v8) + *(float *)(v4 + 836);
    *(float *)(v4 + 848) = *(float *)(v4 + 844);
    result = strncpy((char *)(v4 + 872), (const char *)(a1 + 8), 7u);
    *(float *)(v4 + 856) = *(float *)(a3 + 8) + *(float *)a3 + 4.0;
    *(float *)(v4 + 860) = *(float *)(v4 + 844);
    *(float *)(v4 + 884) = 0.5;
    v7 = 0.0;
  }
  else
  {
    v4 = (LOBYTE(a2) << 6) + a3;
    *(float *)(v4 + 836) = sub_10065120(*(float *)a1, a3 + 4212, *(_BYTE *)(a3 + 4308)) + *(float *)(a3 + 4192);
    *(float *)(v4 + 844) = *(float *)(a3 + 4196);
    *(float *)(v4 + 840) = *(float *)(v4 + 836);
    v9 = *(float *)(a3 + 4204) * *(float *)(a1 + 4);
    *(float *)(v4 + 848) = (double)sub_10095940(v9) + *(float *)(v4 + 844);
    result = strncpy((char *)(v4 + 872), (const char *)(a1 + 8), 7u);
    *(float *)(v4 + 856) = *(float *)(v4 + 836);
    *(float *)(v4 + 860) = *(float *)(a3 + 12) + *(float *)(a3 + 4) + 4.0;
    *(float *)(v4 + 884) = 0.0;
    v7 = 0.5;
  }
  *(float *)(v4 + 880) = v7;
  *(float *)(v4 + 852) = 1.0;
  *(_BYTE *)(((v3 + 14) << 6) + a3) = 0;
  *(float *)(v4 + 888) = 9.0;
  *(_DWORD *)(v4 + 864) = 0;
  *(_DWORD *)(v4 + 868) = -1;
  return result;
}

//----- (10049310) --------------------------------------------------------
void __cdecl sub_10049310(int a1, unsigned __int8 a2, char a3, int a4)
{
  double v4; // st7@1
  double v5; // st6@1
  char v6; // bl@1
  int v7; // esi@1
  bool v8; // zf@1
  int v9; // edi@4
  double v10; // ST20_8@4
  int v11; // ebp@4
  bool v12; // cf@4
  double v13; // st7@4
  int v14; // ebp@8
  int v15; // edi@8
  float v16; // ST20_4@8
  double v17; // st7@8
  double v18; // st7@8
  int v19; // eax@10
  int v20; // ecx@10
  unsigned __int8 v21; // [sp+34h] [bp+10h]@1

  v4 = 0.5;
  v5 = 0.0;
  v6 = a3;
  v7 = a4;
  v8 = *(_BYTE *)(a4 + 4208) == 1;
  v21 = 0;
  if ( v8 )
  {
    if ( a2 )
    {
      do
      {
        if ( (unsigned __int8)v6 >= 0x32u )
          break;
        v9 = ((unsigned __int8)v6 << 6) + v7;
        *(float *)(v9 + 836) = *(float *)(v7 + 4192);
        v10 = *(float *)(v7 + 4196);
        v11 = 16 * v21 + a1;
        *(float *)(v9 + 844) = v10 - sub_10065120(*(float *)v11, v7 + 4212, *(_BYTE *)(v7 + 4308));
        *(float *)&v10 = *(float *)(v11 + 4) * *(float *)(v7 + 4200);
        *(float *)(v9 + 840) = (double)sub_10095940(*(float *)&v10) + *(float *)(v9 + 836);
        *(float *)(v9 + 848) = *(float *)(v9 + 844);
        *(_DWORD *)(v9 + 892) = -1;
        *(_BYTE *)((((unsigned __int8)v6 + 14) << 6) + v7) = 0;
        *(float *)(v9 + 852) = 1.0;
        strncpy((char *)(v9 + 872), (const char *)(v11 + 8), 7u);
        ++v6;
        v12 = (unsigned __int8)(v21 + 1) < a2;
        v13 = *(float *)(v7 + 8) + *(float *)v7 + 4.0;
        *(_DWORD *)(v9 + 864) = 0;
        *(_DWORD *)(v9 + 868) = -1;
        ++v21;
        *(float *)(v9 + 856) = v13;
        *(float *)(v9 + 860) = *(float *)(v9 + 844);
        *(float *)(v9 + 888) = 9.0;
        v4 = 0.5;
        *(float *)(v9 + 884) = 0.5;
        v5 = 0.0;
        *(float *)(v9 + 880) = 0.0;
      }
      while ( v12 );
    }
  }
  else if ( a2 )
  {
    do
    {
      if ( (unsigned __int8)v6 >= 0x32u )
        break;
      v14 = 16 * v21 + a1;
      v15 = ((unsigned __int8)v6 << 6) + v7;
      *(float *)(v15 + 836) = sub_10065120(*(float *)v14, v7 + 4212, *(_BYTE *)(v7 + 4308)) + *(float *)(v7 + 4192);
      *(float *)(v15 + 844) = *(float *)(v7 + 4196);
      *(float *)(v15 + 840) = *(float *)(v15 + 836);
      v16 = *(float *)(v14 + 4) * *(float *)(v7 + 4204);
      v17 = (double)sub_10095940(v16) + *(float *)(v15 + 844);
      *(_BYTE *)((((unsigned __int8)v6 + 14) << 6) + v7) = 0;
      *(float *)(v15 + 848) = v17;
      *(float *)(v15 + 852) = 1.0;
      *(_DWORD *)(v15 + 892) = -1;
      strncpy((char *)(v15 + 872), (const char *)(v14 + 8), 7u);
      *(float *)(v15 + 856) = *(float *)(v15 + 836);
      ++v6;
      v12 = (unsigned __int8)(v21 + 1) < a2;
      v18 = *(float *)(v7 + 12) + *(float *)(v7 + 4);
      *(_DWORD *)(v15 + 864) = 0;
      *(_DWORD *)(v15 + 868) = -1;
      ++v21;
      *(float *)(v15 + 860) = v18 + 4.0;
      *(float *)(v15 + 888) = 9.0;
      *(float *)(v15 + 884) = 0.0;
      *(float *)(v15 + 880) = 0.5;
      v5 = 0.0;
      v4 = 0.5;
    }
    while ( v12 );
  }
  *(_BYTE *)(v7 + 4036) = v6;
  if ( (unsigned __int8)v6 < 0x32u )
  {
    v19 = ((unsigned __int8)v6 << 6) + v7 + 844;
    v20 = (unsigned __int8)(50 - v6);
    do
    {
      *(float *)(v19 - 8) = v5;
      *(float *)v19 = v5;
      *(_DWORD *)(v19 + 48) = 0;
      *(float *)(v19 - 4) = v5;
      *(_BYTE *)(v19 + 52) = 1;
      *(float *)(v19 + 4) = v5;
      *(_BYTE *)(v19 + 28) = 0;
      *(_DWORD *)(v19 + 20) = 0;
      *(float *)(v19 + 8) = 1.0;
      *(_DWORD *)(v19 + 24) = -1;
      v19 += 64;
      --v20;
      *(float *)(v19 - 52) = v5;
      *(float *)(v19 - 48) = v5;
      *(float *)(v19 - 24) = v4;
      *(float *)(v19 - 28) = v4;
      *(float *)(v19 - 20) = *(float *)&v5;
    }
    while ( v20 );
  }
}

//----- (10049630) --------------------------------------------------------
int __cdecl sub_10049630(float *a1)
{
  int result; // eax@1
  signed int v2; // ecx@1

  result = (int)(a1 + 26);
  v2 = 2;
  do
  {
    result += 52;
    --v2;
    *(float *)(result - 92) = *a1;
    *(float *)(result - 52) = 0.0;
  }
  while ( v2 );
  return result;
}

//----- (10049660) --------------------------------------------------------
int __usercall sub_10049660@<eax>(int a1@<esi>, float a2, float a3, float a4, char a5)
{
  double v5; // st7@1
  signed int v6; // ecx@2
  double v7; // st6@3
  char v8; // bl@4
  double v9; // st7@4
  float v10; // ST30_4@5
  double v11; // st6@5
  float v12; // ST28_4@8
  float v13; // ST00_4@8
  double v14; // st7@9
  char v15; // bl@12
  float v16; // ST28_4@18
  int result; // eax@19
  signed int v18; // [sp+24h] [bp-18h]@2
  float v19; // [sp+28h] [bp-14h]@2
  float v20; // [sp+2Ch] [bp-10h]@2
  double v21; // [sp+34h] [bp-8h]@4
  float v22; // [sp+44h] [bp+8h]@4
  float v23; // [sp+44h] [bp+8h]@12

  v5 = a3;
  if ( a3 == 0.0 )
  {
    v6 = 0;
    v18 = 0;
    v19 = 0.5 * a2 + *(float *)(a1 + 24);
    v20 = a2;
  }
  else
  {
    v19 = v5 * 0.5 + *(float *)(a1 + 24);
    v20 = a3;
    v7 = a2 / v5;
    v18 = (signed int)(v7 + 0.5);
    v6 = (signed int)(v7 + 0.5);
  }
  v22 = *(float *)(a1 + 20);
  v8 = 0;
  v21 = v19;
  v9 = v22;
  if ( v22 >= (double)v19 )
  {
    v14 = a4;
  }
  else
  {
    do
    {
      v10 = -a4;
      v11 = v10;
      if ( v6 && (unsigned __int8)v8 % v6 )
        v11 = v11 * 0.6000000238418579;
      v12 = v11;
      v13 = v9;
      sub_10065690(v13, v12, 1.0, a1 + 836, (unsigned __int8)v8, a1 + 4192);
      v6 = v18;
      ++v8;
      v22 = v22 + v20;
      v9 = v22;
    }
    while ( v22 < v21 );
    v14 = a4;
  }
  *(_BYTE *)(a1 + 4036) = v8;
  if ( a5 )
  {
    v15 = 0;
    v23 = *(float *)(a1 + 20);
    if ( *(_BYTE *)(a1 + 4036) )
    {
      while ( 1 )
      {
        if ( v6 )
        {
          if ( (unsigned __int8)v15 % v6 )
            v14 = v14 * 0.6000000238418579;
        }
        v16 = v14;
        sub_10065690(v23, v16, 1.0, a1 + 836, *(_BYTE *)(a1 + 4036) + (unsigned __int8)v15++, a1 + 4192);
        v23 = v23 + v20;
        if ( (unsigned __int8)v15 >= *(_BYTE *)(a1 + 4036) )
          break;
        v14 = a4;
        v6 = v18;
      }
      *(_BYTE *)(a1 + 4036) += v15;
      result = *(_BYTE *)(a1 + 4036);
    }
    else
    {
      *(_BYTE *)(a1 + 4036) = *(_BYTE *)(a1 + 4036);
      result = *(_BYTE *)(a1 + 4036);
    }
  }
  else
  {
    result = *(_BYTE *)(a1 + 4036);
  }
  return result;
}

//----- (10049840) --------------------------------------------------------
int __usercall sub_10049840@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4185) != 1 )
  {
    if ( *(_BYTE *)(result + 4208) == 1 )
      result = sub_1006BF60(result + 168, *(_BYTE *)(result + 368));
    else
      result = sub_1006AA90(result + 168, *(_BYTE *)(result + 368));
  }
  return result;
}

//----- (10049880) --------------------------------------------------------
void __usercall sub_10049880(int a1@<esi>, int a2)
{
  signed int v2; // ebp@2
  int v3; // ebx@2
  int v4; // edi@2
  float *v5; // ecx@3
  float v6; // ST2C_4@6
  double v7; // st7@6
  float v8; // ST34_4@15
  char v9; // ST38_1@17
  float v10; // [sp+4h] [bp-28h]@5
  int v11; // [sp+8h] [bp-24h]@5
  int v12; // [sp+Ch] [bp-20h]@5
  float v13; // [sp+1Ch] [bp-10h]@8
  float v14; // [sp+1Ch] [bp-10h]@11
  int v15; // [sp+20h] [bp-Ch]@2
  float v16; // [sp+24h] [bp-8h]@13

  if ( *(_BYTE *)(a1 + 4186) != 1 )
  {
    v2 = 5;
    v15 = a1 + 4464;
    v3 = a1 + 48;
    v4 = a1 + 792;
    do
    {
      v5 = *(float **)v3;
      if ( *(_DWORD *)v3 && 9.8999998e24 != *v5 )
      {
        v12 = *(_BYTE *)(a1 + 4308);
        v11 = a1 + 4212;
        v10 = *v5;
        if ( *(_BYTE *)(a1 + 4208) == 1 )
        {
          v6 = sub_10065120(v10, v11, v12);
          v7 = v6;
          if ( v6 < 0.0 )
            v7 = (float)0.0;
          v13 = *(float *)(a1 + 4204);
          if ( v13 <= v7 )
            v7 = v13;
          *(float *)(v4 - 16) = *(float *)(a1 + 4196) - v7;
          *(float *)v4 = *(float *)(a1 + 4196) - v7;
        }
        else
        {
          v14 = sub_10065120(v10, v11, v12);
          if ( v14 < 0.0 )
            v14 = 0.0;
          v16 = *(float *)(a1 + 4200);
          if ( v16 <= (double)v14 )
            v14 = v16;
          v8 = *(float *)(a1 + 4192) + v14;
          *(float *)(v4 - 20) = v8;
          *(float *)(v4 - 4) = v8;
        }
        if ( v2 < 3 )
        {
          v9 = sub_1006E1D0(**(float **)(v3 + 24), a1 + 372, 10, v15);
          sub_1006E2C0(v9, (_DWORD *)(v4 + 8), (_DWORD *)(v4 + 36), *(_BYTE *)(a1 + 4186));
        }
        sub_1006C090(a2, v4 - 20);
      }
      v15 -= 28;
      --v2;
      v3 -= 4;
      v4 -= 64;
    }
    while ( v2 >= 0 );
  }
}

//----- (10049A20) --------------------------------------------------------
int __usercall sub_10049A20@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4188) != 1 )
    result = sub_10069290(result + 4192);
  return result;
}

//----- (10049A40) --------------------------------------------------------
int __usercall sub_10049A40@<eax>(int result@<eax>, int a2@<edx>)
{
  if ( *(_BYTE *)(result + 4189) != 1 )
    result = sub_10069C80(a2, result + 836, *(_BYTE *)(result + 4036), 0);
  return result;
}

//----- (10049A70) --------------------------------------------------------
void __usercall sub_10049A70(int a1@<edi>, int a2)
{
  unsigned __int8 v2; // bl@1
  int v3; // ebp@1
  int v4; // esi@1
  char v5; // al@4
  _DWORD *v6; // esi@7
  signed int v7; // ebx@7
  unsigned __int8 v8; // [sp+1Fh] [bp-5h]@1
  char v9; // [sp+20h] [bp-4h]@1

  v9 = 0;
  v8 = 0;
  v2 = 0;
  v3 = a1 + 4324;
  v4 = a1 + 28;
  do
  {
    if ( *(_DWORD *)v4 )
    {
      if ( 9.8999998e24 != **(float **)v4 )
      {
        v5 = sub_1006E1D0(**(float **)(v4 + 24), a1 + 372, 10, v3);
        if ( (unsigned __int8)v9 < (unsigned __int8)v5 )
        {
          v9 = v5;
          v8 = v2;
        }
      }
    }
    ++v2;
    v4 += 4;
    v3 += 28;
  }
  while ( v2 < 3u );
  v6 = (_DWORD *)(a1 + 76);
  v7 = 2;
  do
  {
    sub_1006E390(v9, v6, v6 - 1, *(_BYTE *)(a1 + 4190), *(_DWORD *)(a1 + 28 * v8 + 4332));
    sub_1006BEC0(a2, (int)(v6 - 3));
    v6 += 13;
    --v7;
  }
  while ( v7 );
}

//----- (10049B40) --------------------------------------------------------
void __usercall sub_10049B40(int a1@<esi>, _BYTE *a2, int a3, float a4, float a5, float a6, float a7, char a8)
{
  int v8; // ebp@1
  _DWORD *v9; // edi@1
  double v10; // st7@1
  double v11; // st5@3
  double v12; // st6@3
  double v13; // st4@4
  double v14; // rt2@4
  double v15; // st3@4
  double v16; // st7@4
  double v17; // st3@5
  double v18; // rt1@5
  double v19; // st4@5
  int v20; // eax@6
  signed int v21; // ecx@6
  int v22; // edi@8
  signed int v23; // ebp@8
  signed int v24; // [sp+18h] [bp-4h]@1
  float v25; // [sp+38h] [bp+1Ch]@4
  float v26; // [sp+38h] [bp+1Ch]@4
  float v27; // [sp+38h] [bp+1Ch]@4
  float v28; // [sp+38h] [bp+1Ch]@4
  float v29; // [sp+38h] [bp+1Ch]@5
  float v30; // [sp+38h] [bp+1Ch]@5
  float v31; // [sp+38h] [bp+1Ch]@5
  float v32; // [sp+38h] [bp+1Ch]@9

  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)(a1 + 8) = a6;
  v8 = a1 + 4324;
  *(float *)(a1 + 12) = a7;
  v9 = (_DWORD *)(a1 + 28);
  v24 = 6;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v10 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 4184) = 0;
  *(float *)(a1 + 24) = v10;
  do
  {
    *v9 = 0;
    sub_1006E420(v8);
    ++v9;
    v8 += 28;
    --v24;
  }
  while ( v24 );
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 4060) = 0;
  v11 = a7;
  *(_DWORD *)(a1 + 4056) = -1;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 4108) = 0;
  *(_DWORD *)(a1 + 4104) = -1;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 4156) = 0;
  *(_DWORD *)(a1 + 4152) = -1;
  *(float *)(a1 + 4196) = a5 + a7;
  *(float *)(a1 + 4200) = a6;
  v12 = a6;
  *(float *)(a1 + 4204) = *(float *)&v11;
  *(float *)(a1 + 4212) = 0.0;
  *(float *)(a1 + 4216) = 0.0;
  *(float *)(a1 + 4220) = 1.0;
  *(float *)(a1 + 4232) = 1.0;
  *(float *)(a1 + 4244) = 1.0;
  *(float *)(a1 + 4256) = 1.0;
  *(float *)(a1 + 4268) = 1.0;
  *(float *)(a1 + 4280) = 1.0;
  *(float *)(a1 + 4292) = 1.0;
  *(float *)(a1 + 4304) = 1.0;
  *(float *)(a1 + 4224) = 0.0;
  *(float *)(a1 + 4228) = 0.0;
  *(float *)(a1 + 4236) = 0.0;
  *(float *)(a1 + 4240) = 0.0;
  *(float *)(a1 + 4248) = 0.0;
  *(float *)(a1 + 4252) = 0.0;
  *(float *)(a1 + 4260) = 0.0;
  *(float *)(a1 + 4264) = 0.0;
  *(float *)(a1 + 4272) = 0.0;
  *(float *)(a1 + 4276) = 0.0;
  *(float *)(a1 + 4284) = 0.0;
  *(float *)(a1 + 4288) = 0.0;
  *(float *)(a1 + 4296) = 0.0;
  *(float *)(a1 + 4300) = 0.0;
  *(_BYTE *)(a1 + 4308) = 2;
  *(float *)(a1 + 4212) = *(float *)(a3 + 4);
  *(float *)(a1 + 4224) = *(float *)(a3 + 8);
  if ( a8 )
  {
    *(_BYTE *)(a1 + 4208) = 1;
    *(_BYTE *)(a1 + 504) = 3;
    v25 = a4 + v12;
    *(float *)(a1 + 4192) = v25;
    v13 = v25;
    *(float *)(a1 + 4216) = 0.0;
    *(float *)(a1 + 4228) = a7;
    v26 = v12 * 0.8999999761581421;
    *(float *)(a1 + 460) = v26;
    v14 = v26;
    *(float *)(a1 + 464) = v11 * 0.1000000014901161;
    v27 = v13 - 1.0;
    v15 = v27;
    *(float *)(a1 + 452) = v27;
    v28 = *(float *)(a1 + 4196);
    *(float *)(a1 + 456) = v28;
    *(float *)(a1 + 468) = (double)(signed int)(v15 - v14 * 0.8500000238418579) + 0.5;
    *(float *)(a1 + 472) = v28;
    *(float *)(a1 + 492) = 0.0;
    *(float *)(a1 + 496) = 0.5;
    v16 = 0.0;
    *(float *)(a1 + 68) = a5 - 4.0;
    *(float *)(a1 + 120) = *(float *)(a1 + 68) - 16.0;
    *(float *)(a1 + 4040) = a4;
  }
  else
  {
    *(_BYTE *)(a1 + 4208) = 0;
    *(float *)(a1 + 4192) = a4;
    *(_BYTE *)(a1 + 504) = 1;
    v17 = 0.0;
    *(float *)(a1 + 4216) = *(float *)&v17;
    *(float *)(a1 + 4228) = a6;
    *(float *)(a1 + 460) = v12 * 0.1000000014901161;
    v29 = v11 * 0.8999999761581421;
    *(float *)(a1 + 464) = v29;
    v18 = v29;
    *(float *)(a1 + 452) = a4;
    v30 = *(float *)(a1 + 4196) - 1.0;
    *(float *)(a1 + 456) = v30;
    v19 = a4;
    *(float *)(a1 + 468) = *(float *)&v19;
    v31 = v30 - v18 * 0.8500000238418579;
    *(float *)(a1 + 472) = sub_10095970(v31, 1.0);
    *(float *)(a1 + 492) = 0.5;
    *(float *)(a1 + 496) = 0.0;
    *(float *)(a1 + 68) = a5 - 2.0;
    *(float *)(a1 + 120) = *(float *)(a1 + 68) - 12.0 - 2.0;
    *(float *)(a1 + 4040) = a4 + a6;
    v16 = 1.0;
  }
  *(float *)(a1 + 4076) = v16;
  *(float *)(a1 + 500) = 9.0;
  *(_DWORD *)(a1 + 508) = -1;
  *(_BYTE *)(a1 + 512) = 1;
  *(_BYTE *)(a1 + 513) = 0;
  *(_BYTE *)(a1 + 514) = 2;
  *(_DWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 480) = -16777216;
  strncpy((char *)(a1 + 484), byte_100B8180, 7u);
  *(_DWORD *)(a1 + 4048) = 0;
  *(_DWORD *)(a1 + 4052) = -1;
  *(float *)(a1 + 4044) = a5 - 3.0;
  v20 = a1 + 4085;
  v21 = 3;
  *(float *)(a1 + 4072) = 1.0;
  *(float *)(a1 + 4064) = *(float *)(a3 + 4);
  *(float *)(a1 + 4068) = *(float *)(a3 + 8);
  *(float *)(a1 + 4080) = 15.0;
  do
  {
    *(_BYTE *)(v20 - 1) = 0;
    *(_BYTE *)v20 = 0;
    *(_BYTE *)(v20 + 1) = 0;
    v20 += 48;
    --v21;
  }
  while ( v21 );
  *(_BYTE *)(a1 + 4184) = 1;
  *(_WORD *)(a1 + 4312) = 12;
  *(_DWORD *)(a1 + 4316) = &unk_100B8DC0;
  *(_BYTE *)(a1 + 4320) = 1;
  v22 = a1 + 104;
  v23 = 2;
  do
  {
    v32 = a6 * 0.5 + a4;
    *(float *)(v22 - 40) = v32;
    *(float *)v22 = 0.5;
    *(_DWORD *)(v22 - 32) = 0;
    *(float *)(v22 + 4) = 1.0;
    *(_DWORD *)(v22 - 28) = -1;
    *(float *)(v22 + 8) = 12.0;
    strncpy((char *)(v22 - 24), byte_100B8180, 1u);
    v22 += 52;
    --v23;
  }
  while ( v23 );
  sub_100649E0(a1 + 80, a2, 21);
  sub_10048D80(a3, 0.40000001, 0.0, a1);
  sub_10049310(0, 0, 0, a1);
  *(_DWORD *)(a1 + 4185) = 0;
  *(_WORD *)(a1 + 4189) = 0;
}

//----- (1004A000) --------------------------------------------------------
void __usercall sub_1004A000(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@2
  int v3; // ebx@2
  float **v4; // ebp@2
  double v5; // st7@9
  double v6; // st7@13
  float v7; // ST00_4@15
  int v8; // esi@19
  signed int v9; // edi@19
  float *v10; // ecx@20
  float v11; // [sp+4h] [bp-30h]@13
  float v12; // [sp+8h] [bp-2Ch]@13
  float v13; // [sp+Ch] [bp-28h]@13
  float v14; // [sp+10h] [bp-24h]@13
  float v15; // [sp+14h] [bp-20h]@13
  char v16; // [sp+18h] [bp-1Ch]@13
  float v17; // [sp+2Ch] [bp-8h]@1
  signed int v18; // [sp+30h] [bp-4h]@2

  v17 = 1.0;
  v1 = a1;
  if ( *(_BYTE *)(a1 + 4186) == 1 )
  {
    if ( *(_BYTE *)(a1 + 4187) != 1 )
    {
      v8 = a1 + 4060;
      v9 = 3;
      do
      {
        v10 = *(float **)v8;
        if ( *(_DWORD *)v8
          && !*(_BYTE *)(v8 + 26)
          && (9.8999998e24 == *v10
           || *(_BYTE *)(v8 + 24) && (*(float *)(v8 + 4) > (double)*v10 || *(float *)(v8 + 8) < (double)*v10)) )
        {
          sub_1006A400(v8 - 20);
        }
        v8 += 48;
        --v9;
      }
      while ( v9 );
    }
  }
  else
  {
    v2 = a1 + 504;
    v3 = a1 + 4040;
    v4 = (float **)(a1 + 28);
    v18 = 3;
    do
    {
      if ( *(_BYTE *)(v2 + 8)
        && (*v4 && 9.8999998e24 == **v4 || *(_DWORD *)(v3 + 20) && !(unsigned __int8)sub_10061A10(v3)) )
      {
        switch ( *(_BYTE *)v2 )
        {
          case 1:
          case 3:
            v5 = 1.0;
            goto LABEL_11;
          case 0:
          case 2:
            v5 = 0.0;
LABEL_11:
            v17 = v5;
            break;
          default:
            break;
        }
        if ( *(_BYTE *)(v1 + 4208) == 1 )
        {
          v16 = *(_BYTE *)(v1 + 16);
          v15 = 1.0;
          v14 = v17;
          v13 = *(float *)(v1 + 4204);
          v12 = *(float *)(v2 - 44);
          v11 = *(float *)(v1 + 4196);
          v6 = *(float *)(v2 - 52);
        }
        else
        {
          v16 = *(_BYTE *)(v1 + 16);
          v15 = v17;
          v14 = 0.0;
          v13 = *(float *)(v2 - 40);
          v12 = *(float *)(v1 + 4200);
          v11 = *(float *)(v2 - 48);
          v6 = *(float *)(v1 + 4192);
        }
        v7 = v6;
        sub_100659D0(v7, v11, v12, v13, v14, v15, v16);
      }
      ++v4;
      v3 += 48;
      v2 += 64;
      --v18;
    }
    while ( v18 );
  }
}

//----- (1004A1A0) --------------------------------------------------------
void __cdecl sub_1004A1A0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  sub_10049B40(a1, (_BYTE *)a2, a3, a4, a5, a6, a7, a8);
}

//----- (1004A1E0) --------------------------------------------------------
void __cdecl sub_1004A1E0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  int v8; // esi@1
  int v9; // edi@1
  double v10; // st5@2
  double v11; // st4@2
  double v12; // st7@2
  double v13; // st3@2
  double v14; // st2@2
  double v15; // st6@2
  double v16; // st7@2
  double v17; // st6@3
  double v18; // rt2@3
  double v19; // ST2C_8@3
  double v20; // st7@3
  double v21; // st7@4
  double v22; // st5@4
  double v23; // st4@4
  float v24; // [sp+30h] [bp+4h]@3
  float v25; // [sp+38h] [bp+Ch]@2
  float v26; // [sp+38h] [bp+Ch]@3
  float v27; // [sp+3Ch] [bp+10h]@4
  int v28; // [sp+4Ch] [bp+20h]@2
  int v29; // [sp+4Ch] [bp+20h]@2
  int v30; // [sp+4Ch] [bp+20h]@2
  int v31; // [sp+4Ch] [bp+20h]@2
  int v32; // [sp+4Ch] [bp+20h]@2
  float v33; // [sp+4Ch] [bp+20h]@2
  int v34; // [sp+4Ch] [bp+20h]@3
  int v35; // [sp+4Ch] [bp+20h]@3
  int v36; // [sp+4Ch] [bp+20h]@3
  int v37; // [sp+4Ch] [bp+20h]@3
  int v38; // [sp+4Ch] [bp+20h]@3
  int v39; // [sp+4Ch] [bp+20h]@3
  int v40; // [sp+4Ch] [bp+20h]@3

  v8 = a1;
  v9 = a3;
  sub_10049B40(a1, (_BYTE *)a2, a3, a4, a5, a6, a7, a8);
  if ( (_BYTE)a8 )
  {
    *(_BYTE *)(a1 + 504) = 3;
    *(float *)&v28 = a6 * 0.5 + a4;
    v10 = *(float *)&v28;
    *(float *)(a1 + 4192) = *(float *)&v28;
    *(float *)&v29 = *(float *)&v28 - 1.0;
    v11 = *(float *)&v29;
    *(float *)(a1 + 452) = *(float *)&v29;
    v30 = *(int *)(a1 + 4196);
    *(float *)(a1 + 456) = *(float *)&v30;
    v12 = *(float *)&v30;
    *(float *)&v31 = a6 * 0.449999988079071;
    v13 = *(float *)&v31;
    *(float *)(a1 + 460) = *(float *)&v31;
    v25 = a7 * 0.1000000014901161;
    *(float *)(a1 + 464) = v25;
    *(_BYTE *)(a1 + 568) = 2;
    *(float *)(a1 + 468) = (double)(signed int)(v11 - 0.8500000238418579 * *(float *)&v31) + 0.5;
    *(float *)(a1 + 472) = v12;
    *(float *)(a1 + 492) = 0.0;
    *(float *)(a1 + 496) = 0.5;
    *(float *)&v32 = v10 + 1.0;
    v14 = *(float *)&v32;
    *(float *)(a1 + 516) = *(float *)&v32;
    v33 = *(float *)(a1 + 4196);
    *(float *)(a1 + 520) = v33;
    *(float *)(a1 + 524) = v13;
    *(float *)(a1 + 528) = v25;
    *(float *)(a1 + 532) = (double)(signed int)(0.8500000238418579 * v13 + v14) + 0.5;
    *(float *)(a1 + 536) = v33;
    *(float *)(a1 + 556) = 1.0;
    *(float *)(a1 + 4072) = 1.0;
    v15 = 0.5;
    v16 = 0.0;
    *(float *)(a1 + 560) = *(float *)&v15;
  }
  else
  {
    *(_BYTE *)(a1 + 504) = 1;
    *(float *)&v34 = 0.5 * a7 + a5;
    v17 = *(float *)&v34;
    *(float *)(a1 + 4196) = *(float *)&v34;
    v35 = *(int *)(a1 + 4192);
    *(float *)(a1 + 452) = *(float *)&v35;
    v18 = *(float *)&v35;
    *(float *)&v36 = v17 - 1.0;
    *(float *)(a1 + 456) = *(float *)&v36;
    v26 = a6 * 0.1000000014901161;
    *(float *)(a1 + 460) = v26;
    v24 = a7 * 0.449999988079071;
    *(float *)(v8 + 464) = v24;
    *(float *)(v8 + 468) = v18;
    v19 = v24 * 0.8500000238418579;
    *(float *)&v37 = *(float *)&v36 - v19;
    *(float *)(v8 + 472) = sub_10095740(*(float *)&v37, 1.0);
    *(_BYTE *)(v8 + 568) = 0;
    *(float *)(v8 + 492) = 0.5;
    *(float *)(v8 + 496) = 0.0;
    v38 = *(int *)(v8 + 4192);
    v20 = *(float *)&v38;
    *(float *)(v8 + 516) = *(float *)&v38;
    *(float *)&v39 = *(float *)(v8 + 4196) + 1.0;
    *(float *)(v8 + 520) = *(float *)&v39;
    *(float *)(v8 + 524) = v26;
    *(float *)(v8 + 528) = v24;
    *(float *)(v8 + 532) = v20;
    *(float *)&v40 = *(float *)&v39 + v19;
    *(float *)(v8 + 536) = sub_100956A0(*(float *)&v40, 1.0);
    *(float *)(v8 + 556) = 0.5;
    v16 = 1.0;
    *(float *)(v8 + 560) = 1.0;
    *(float *)(v8 + 4072) = 0.0;
  }
  *(float *)(v8 + 4076) = v16;
  *(float *)(v8 + 4120) = v16;
  *(float *)(v8 + 4124) = v16;
  *(float *)(v8 + 500) = 9.0;
  *(_DWORD *)(v8 + 508) = -1;
  *(_BYTE *)(v8 + 514) = 2;
  *(_DWORD *)(v8 + 476) = 0;
  *(_DWORD *)(v8 + 480) = -16777216;
  strncpy((char *)(v8 + 484), "L", 7u);
  *(float *)(v8 + 564) = 9.0;
  *(_DWORD *)(v8 + 572) = -1;
  *(_BYTE *)(v8 + 576) = 1;
  *(_BYTE *)(v8 + 577) = 0;
  *(_BYTE *)(v8 + 578) = 2;
  *(_DWORD *)(v8 + 540) = 0;
  *(_DWORD *)(v8 + 544) = -16777216;
  strncpy((char *)(v8 + 548), "R", 7u);
  v21 = a4;
  *(float *)(v8 + 4040) = a4;
  *(_DWORD *)(v8 + 4048) = 0;
  *(_DWORD *)(v8 + 4052) = -1;
  v27 = a5 - 3.0;
  *(float *)(v8 + 4044) = v27;
  *(float *)(v8 + 4064) = *(float *)(v9 + 4);
  v22 = *(float *)(v9 + 8);
  *(_DWORD *)(v8 + 4096) = 0;
  *(float *)(v8 + 4068) = v22;
  *(_DWORD *)(v8 + 4100) = -1;
  *(float *)(v8 + 4080) = 15.0;
  *(float *)(v8 + 4088) = v21 + a6;
  *(float *)(v8 + 4092) = v27;
  *(float *)(v8 + 4112) = *(float *)(v9 + 4);
  v23 = *(float *)(v9 + 8);
  *(_BYTE *)(v8 + 4184) = 2;
  *(float *)(v8 + 4116) = v23;
  *(float *)(v8 + 4128) = 15.0;
  *(float *)(v8 + 64) = v21 + a6 * 0.5;
  *(float *)(v8 + 104) = 0.5;
  sub_10048D80(v9, 0.2, 0.5, v8);
}

//----- (1004A630) --------------------------------------------------------
int __cdecl sub_1004A630(float a1, float a2, float a3, int a4)
{
  return sub_10049660(a4, a1, a2, a3, 1);
}

//----- (1004A660) --------------------------------------------------------
int __cdecl sub_1004A660(float a1, float a2, float a3, int a4)
{
  return sub_10049660(a4, a1, a2, a3, 0);
}

//----- (1004A690) --------------------------------------------------------
unsigned __int8 __cdecl sub_1004A690(int a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 result; // al@1
  int v4; // esi@2

  result = sub_10066EE0(a1, 0, a2);
  if ( result < a2 )
  {
    v4 = result;
    sub_10049040(a1 + 12 * result, 1, 1, a3);
    result = sub_10064B00((char *)(a3 + 484), 2u, "%d", v4 + 1);
  }
  return result;
}

//----- (1004A6F0) --------------------------------------------------------
void __usercall sub_1004A6F0(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST48_1@11
  float **v7; // [sp+1Ch] [bp-8h]@2

  v2 = 0;
  if ( *(_BYTE *)(a1 + 4184) )
  {
    v3 = (int *)(a1 + 4332);
    v7 = (float **)(a1 + 52);
    v4 = a1 + 4060;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4
        && (*(_BYTE *)(v4 + 26)
         || 9.8999998e24 != *v5
         && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5))
        && *(_BYTE *)(a1 + 4187) != 1 )
      {
        v6 = sub_1006E1D0(**v7, a1 + 372, 10, (int)(v3 - 2));
        sub_1006E300(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 4187), *v3);
        sub_10068AE0(a2, v4 - 20, *(_WORD *)(a1 + 4312), *(_DWORD *)(a1 + 4316), *(_BYTE *)(a1 + 4320));
      }
      ++v7;
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 4184) );
  }
}

//----- (1004A800) --------------------------------------------------------
char __cdecl sub_1004A800(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_10049A20(a4);
      sub_10049840(a4);
      sub_10049A40(a4, a1);
      sub_10049880(a4, a1);
      sub_10049A70(a4, a1);
      sub_1004A6F0(a4, a1);
      sub_1004A000(a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10049880(a4, a1);
      sub_10049A70(a4, a1);
      sub_1004A6F0(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (1004A900) --------------------------------------------------------
char __cdecl sub_1004A900(int a1, _WORD *a2, char **a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  char result; // al@1
  char **v8; // ebp@1
  int v9; // esi@1
  int v10; // ebx@1
  bool v11; // al@7
  bool v12; // al@11
  int v13; // [sp+10h] [bp-4h]@5
  int v14; // [sp+18h] [bp+4h]@2

  v6 = a1;
  result = sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = *(_DWORD *)*a3 & 0xFF;
  v10 = 0;
  if ( v9 == 141 )
  {
    *(_BYTE *)(a1 + 3) = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      if ( *v8 )
      {
        result = sub_10063BC0(v6, a5, v10);
        if ( result )
        {
          sub_10063C40(*v8, &v13, 0);
          v11 = v10 == a6 && sub_10063BF0(v6, a2, *(_DWORD *)(v6 + 56));
          *(_BYTE *)(v6 + 3) = v11;
          v12 = v10 == a6 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
          *(_BYTE *)(v6 + 9) = v12;
          result = ((int (__cdecl *)(int, char *, int, _DWORD, _WORD *))dword_1031EB40[2 * v9])(
                     v6,
                     *v8,
                     v13,
                     *(_DWORD *)(v14 + a4),
                     a2);
        }
      }
      v14 = 4 * ++v10;
      v8 = &a3[v10];
      v9 = *(_DWORD *)a3[v10] & 0xFF;
    }
    while ( v9 != 141 );
    *(_BYTE *)(v6 + 3) = 0;
  }
  return result;
}
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (1004AA20) --------------------------------------------------------
bool __cdecl sub_1004AA20(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_10063C40(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_10063BC0(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_10063BF0(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_1031EB40[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_10063C40(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (1004AB20) --------------------------------------------------------
int __cdecl sub_1004AB20(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_101CAB28[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_101CAB28[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1004AB50) --------------------------------------------------------
char *__cdecl sub_1004AB50(unsigned int a1)
{
  return (char *)&unk_1031F1E0 + 20 * ((a1 >> 10) & 0xF);
}

//----- (1004AB70) --------------------------------------------------------
int __cdecl sub_1004AB70(unsigned int a1)
{
  char *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_1004AB50(a1);
  if ( v2 & 1 )
    result = *((_DWORD *)v1 + 2);
  else
    result = *((_DWORD *)v1 + 1);
  return result;
}

//----- (1004AB90) --------------------------------------------------------
signed int __cdecl sub_1004AB90(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (1004ABC0) --------------------------------------------------------
signed int __cdecl sub_1004ABC0(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004ABF0) --------------------------------------------------------
void *sub_1004ABF0()
{
  void *result; // eax@1

  result = (void *)dword_101E05A4;
  if ( !dword_101E05A4 )
    result = &unk_100D6D38;
  return result;
}
// 101E05A4: using guessed type int dword_101E05A4;

//----- (1004AC00) --------------------------------------------------------
int __usercall sub_1004AC00@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (1004AC30) --------------------------------------------------------
char __usercall sub_1004AC30@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_1008F880(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (1004AC80) --------------------------------------------------------
char __usercall sub_1004AC80@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_1008F880(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_100027C0(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_102BA90E || byte_1031EB20) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_1008F8E0(a3 + 392, v32, byte_100B8180, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_1008F8E0(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_102BA90E || byte_1031EB20 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_1008F8E0(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_1008F8E0(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_1008F8E0(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10002420(a3, (unsigned int)v30);
  return result;
}
// 102BA90E: using guessed type char byte_102BA90E;
// 1031EB20: using guessed type char byte_1031EB20;

//----- (1004B180) --------------------------------------------------------
__int16 __cdecl sub_1004B180(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  int v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_1004AB90(a2);
    v6 = *((_DWORD *)sub_1004AB50(a2) + 1);
    do
    {
      v7 = sub_1004AC00(v5);
      v9 = sub_1008F880(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = (_BYTE *)v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004B1E0) --------------------------------------------------------
int __cdecl sub_1004B1E0(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  _BYTE *v4; // eax@1

  v3 = *((_DWORD *)sub_1004AB50(a1) + 1);
  v4 = (_BYTE *)sub_1006C660(a2, a3);
  return sub_1008F880(v3, v4, 0);
}

//----- (1004B210) --------------------------------------------------------
int sub_1004B210()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_100D6D44;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_1031F1E0 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_1008F880(v4, &unk_100D6D90, 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_1004AC30(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_1004AC30(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"..\\lib\\adl\\cdp_fld_2d_utl.c" );
  return result;
}
// 1008BA0E: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (1004B2B0) --------------------------------------------------------
int __cdecl sub_1004B2B0(int a1, int a2, int a3, unsigned __int8 a4)
{
  _WORD *v4; // eax@1
  int v5; // esi@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  _WORD *v8; // edi@1
  int v9; // edx@1
  int result; // eax@3
  int v11; // [sp+10h] [bp-8h]@1
  __int16 v12; // [sp+14h] [bp-4h]@1
  __int16 v13; // [sp+1Ch] [bp+4h]@1
  __int16 v14; // [sp+1Eh] [bp+6h]@1

  v4 = sub_1004ABF0();
  v5 = a1;
  v6 = *(_WORD *)(a1 + 426);
  v7 = *(_WORD *)(a1 + 424);
  v8 = v4;
  LOWORD(v4) = *(_WORD *)(a1 + 396);
  *(_WORD *)(a1 + 396) = 2;
  v12 = (signed __int16)v4;
  v13 = v6;
  *(_WORD *)(v5 + 426) = v8[3];
  v14 = v7;
  v9 = *(_DWORD *)(v5 + 428);
  *(_WORD *)(v5 + 424) = v8[3];
  v11 = v9;
  if ( a4 >= 2u )
    sub_10051A40("..\\lib\\adl\\cdp_fld_2d_utl.c", 982, 1, 0);
  *(_WORD *)(v5 + 428) = word_101CAB28[*((_BYTE *)v8 + a4)];
  *(_WORD *)(v5 + 430) = word_101CAB28[*((_BYTE *)v8 + a4 + 2)];
  *(_WORD *)(v5 + 438) = *(_WORD *)a2 + v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_10090620(v5 + 392, *(_WORD *)a3 - v8[3], *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 438) = *(_WORD *)a3 - v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_10090620(v5 + 392, v8[3] + *(_WORD *)a2, *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 426) = v13;
  *(_WORD *)(v5 + 424) = v14;
  result = HIWORD(v11);
  *(_WORD *)(v5 + 396) = v12;
  *(_WORD *)(v5 + 428) = v11;
  *(_WORD *)(v5 + 430) = HIWORD(v11);
  return result;
}
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1004B430) --------------------------------------------------------
char __cdecl sub_1004B430(int a1, const char *a2, int *a3)
{
  return sub_1004AC80(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (1004B470) --------------------------------------------------------
int __cdecl sub_1004B470(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = *((_DWORD *)sub_1004AB50(a1) + 1);
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (1004B4D0) --------------------------------------------------------
char __cdecl sub_1004B4D0(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_100027C0(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_1004AC00(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_1004AC80(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_1004AC80(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_1004AC80(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10002420(v7, (unsigned int)v15);
}

//----- (1004B6E0) --------------------------------------------------------
int __cdecl sub_1004B6E0(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_1004B470(a3, 0);
  v5 = *((_DWORD *)sub_1004AB50(v4) + 1);
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (1004B7B0) --------------------------------------------------------
__int16 __cdecl sub_1004B7B0(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_1004B470(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = *((_DWORD *)sub_1004AB50(a2) + 1);
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (1004B840) --------------------------------------------------------
char __cdecl sub_1004B840(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  char *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_1004AB20(a6);
  v7 = sub_1004AB50(a6);
  v8 = *((_DWORD *)v7 + 1);
  v24 = *((_DWORD *)v7 + 1);
  v26 = sub_1004B470(a6, 0) & 0xFFFFFF00;
  v9 = sub_1004AB90(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = byte_100B8180;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_1004ABC0(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_1004AB20(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_1004B470(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_1008F880(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_1004AC80(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_1004AC80(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (1004BA60) --------------------------------------------------------
void __cdecl sub_1004BA60(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_100028A0(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_100028A0(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (1004BAA0) --------------------------------------------------------
unsigned int __usercall sub_1004BAA0@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_1031EFA8 )
  {
    dword_1031EFA8 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 1031EFA8: using guessed type int dword_1031EFA8;

//----- (1004BAE0) --------------------------------------------------------
int __usercall sub_1004BAE0@<eax>(int result@<eax>)
{
  if ( dword_1031EFA8 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_1031EFA8;
    *(_DWORD *)dword_1031EFA8 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_1031EFA8;
    dword_1031EFA8 = 0;
  }
  return result;
}
// 1031EFA8: using guessed type int dword_1031EFA8;

//----- (1004BB10) --------------------------------------------------------
void __cdecl sub_1004BB10(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_1004BAE0(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_100028E0(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_100028E0(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_100028E0(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_10051D80(v5) )
        {
          sub_1004BAA0(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_1004BA60(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_10051D80(v5) )
        {
          sub_1004BAE0(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_100028E0(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_100028E0(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_100016A0(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10001530(a1, v6);
    if ( !v6 || !v17 || !sub_100010B0(a1, v17) )
    {
      v18 = sub_10001180(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_100016A0(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_100010B0(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_100016A0(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_100016A0(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_100016A0(a1, (int)&i, 204);
  }
}

//----- (1004BEC0) --------------------------------------------------------
void __cdecl sub_1004BEC0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_1004BB10(a1, a2, a3, a4, 0);
}

//----- (1004BEE0) --------------------------------------------------------
char __thiscall sub_1004BEE0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1008CAC0(2023, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1004BF10) --------------------------------------------------------
char __thiscall sub_1004BF10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1008CAC0(2022, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1004BF40) --------------------------------------------------------
signed int sub_1004BF40()
{
  char v0; // bl@1
  double v1; // st7@2
  signed int result; // eax@4
  float v3; // [sp+8h] [bp-10h]@1
  float v4; // [sp+Ch] [bp-Ch]@1
  __int64 v5; // [sp+10h] [bp-8h]@4

  v0 = sub_10066410(&v4);
  v3 = sub_10066580();
  if ( v0 && (v1 = v3, v3 < 3785.411865234375) && v4 > 0.0001051503277267329 )
  {
    v5 = (signed __int64)(v1 / v4);
    result = v5;
  }
  else
  {
    result = 0x7FFFFFFF;
  }
  return result;
}

//----- (1004BFC0) --------------------------------------------------------
double sub_1004BFC0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1008CAC0(10009, &v2, 4, &v1);
  return v2;
}

//----- (1004BFF0) --------------------------------------------------------
double __fastcall sub_1004BFF0(float a1)
{
  signed int v1; // esi@1
  double result; // st7@4
  float v3; // [sp+0h] [bp-4h]@1

  v3 = a1;
  v1 = sub_1004BF40();
  if ( !sub_1006CA40(&v3)
    || v1 == 0x7FFFFFFF
    || (LODWORD(v3) & 0x7F800000) == 2139095040
    || (v3 = v3 * (double)(unsigned int)v1, result = v3, v3 > 37040000.0) )
  {
    result = (float)9.8999998e24;
  }
  return result;
}

//----- (1004C070) --------------------------------------------------------
double sub_1004C070()
{
  double result; // st7@1
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v2 = 9.8999998e24;
  sub_1008CAC0(6081, &v1, 4, &v2);
  result = v1;
  if ( v1 != 9.8999998e24 )
  {
    v1 = result / 3600.0;
    result = v1;
  }
  return result;
}

//----- (1004C0E0) --------------------------------------------------------
int sub_1004C0E0()
{
  char v1; // [sp+3h] [bp-5h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v2 = 0.0;
  v1 = 1;
  sub_1008CB30(10002, (int)&v2, 4);
  sub_1008CB30(10003, (int)&v2, 4);
  sub_1008CB30(10004, (int)&v2, 4);
  sub_1008CB30(10005, (int)&v2, 4);
  return sub_1008CB30(10006, (int)&v1, 1);
}

//----- (1004C150) --------------------------------------------------------
char __cdecl sub_1004C150(char a1)
{
  return sub_1008CBF0(2023, (int)&a1, 1);
}

//----- (1004C170) --------------------------------------------------------
char __cdecl sub_1004C170(char a1)
{
  return sub_1008CBF0(2022, (int)&a1, 1);
}

//----- (1004C190) --------------------------------------------------------
int __cdecl sub_1004C190(float a1)
{
  double v1; // st6@1
  int result; // eax@2

  v1 = *(float *)(dword_1031FB44 + 940) + *(float *)(dword_1031FB44 + 936) + *(float *)(dword_1031FB44 + 932);
  if ( v1 >= a1 )
  {
    if ( a1 >= 0.0 )
    {
      result = sub_1008CB30(10009, (int)&a1, 4);
    }
    else
    {
      a1 = 0.0;
      result = sub_1008CB30(10009, (int)&a1, 4);
    }
  }
  else
  {
    a1 = v1;
    result = sub_1008CB30(10009, (int)&a1, 4);
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1004C220) --------------------------------------------------------
int sub_1004C220()
{
  double v0; // st7@3
  int result; // eax@4
  char v2; // [sp+Bh] [bp-Dh]@1
  double v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+14h] [bp-4h]@1

  *(float *)&v3 = sub_10066580();
  *(float *)&v4 = 1.0;
  sub_1008D070(15, &v2);
  if ( v2 == 24 )
    *(float *)&v4 = 10.0;
  v3 = *(float *)&v3;
  v0 = sub_1006DAE0(v4, 0x1015u);
  *(float *)&v3 = v3 - v0;
  if ( *(float *)&v3 >= 0.0 )
  {
    result = sub_1004C190(*(float *)&v3);
  }
  else
  {
    *(float *)&v3 = 0.0;
    result = sub_1004C190(0.0);
  }
  return result;
}

//----- (1004C2B0) --------------------------------------------------------
int sub_1004C2B0()
{
  double v0; // st7@3
  double v1; // st7@3
  int result; // eax@4
  char v3; // [sp+Bh] [bp-9h]@1
  float v4; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v4 = sub_10066580();
  *(float *)&v5 = 1.0;
  sub_1008D070(15, &v3);
  if ( v3 == 24 )
    *(float *)&v5 = 10.0;
  v0 = sub_1006DAE0(v5, 0x1015u);
  v4 = v0 + v4;
  v1 = *(float *)(dword_1031FB44 + 940) + *(float *)(dword_1031FB44 + 936) + *(float *)(dword_1031FB44 + 932);
  if ( v4 <= v1 )
  {
    result = sub_1004C190(v4);
  }
  else
  {
    v4 = v1;
    result = sub_1004C190(v4);
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1004C380) --------------------------------------------------------
void __cdecl sub_1004C380(int a1, unsigned __int8 a2)
{
  int v2; // edi@1
  double v3; // st7@2
  float *v4; // esi@2

  v2 = a2;
  if ( (signed int)a2 > 0 )
  {
    v3 = 9.8999998e24;
    v4 = (float *)(a1 + 8);
    do
    {
      if ( v3 == *(v4 - 1) )
      {
        *v4 = v3;
      }
      else
      {
        *v4 = sub_100665E0(*(v4 - 1), *v4, 40, *(v4 - 2));
        v3 = 9.8999998e24;
      }
      v4 += 3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (1004C3E0) --------------------------------------------------------
double __cdecl sub_1004C3E0(unsigned __int16 a1)
{
  float v1; // ecx@0
  float v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  if ( !sub_10066790(a1, &v3) )
    v3 = 9.8999998e24;
  return v3;
}

//----- (1004C410) --------------------------------------------------------
void __cdecl sub_1004C410(float a1, int a2, int a3)
{
  float v3; // esi@1
  char v4; // dl@1
  char v5; // bl@1
  int v6; // eax@2
  char v7; // cl@3
  int v8; // edi@10
  char v9; // bl@12
  unsigned __int8 v10; // cl@14
  int v11; // eax@15
  char v12; // bl@25
  unsigned __int8 v13; // cl@27
  int v14; // eax@28
  int v15; // edx@30
  int v16; // ecx@30
  float v17; // ST1C_4@30
  float v18; // ST18_4@30
  int v19; // edx@31
  int v20; // ecx@31
  float v21; // ST1C_4@31
  float v22; // ST18_4@31
  int v23; // edx@37
  int v24; // ecx@37
  float v25; // ST1C_4@37
  float v26; // ST18_4@37
  int v27; // edx@39
  char v28; // bl@40
  unsigned __int8 v29; // cl@53
  int v30; // eax@54
  bool v31; // zf@57
  int v32; // edx@57
  int v33; // edi@57
  char v34; // bl@67
  char v35; // cl@69
  int v36; // eax@70
  int v37; // edi@72
  int v38; // [sp+0h] [bp-24h]@41
  int v39; // [sp+4h] [bp-20h]@41
  float v40; // [sp+8h] [bp-1Ch]@39
  float v41; // [sp+8h] [bp-1Ch]@57
  float v42; // [sp+Ch] [bp-18h]@39
  float v43; // [sp+Ch] [bp-18h]@57
  float v44; // [sp+10h] [bp-14h]@39
  float v45; // [sp+10h] [bp-14h]@57
  float v46; // [sp+14h] [bp-10h]@39
  float v47; // [sp+14h] [bp-10h]@57
  float v48; // [sp+28h] [bp+4h]@30
  float v49; // [sp+28h] [bp+4h]@31
  float v50; // [sp+28h] [bp+4h]@37

  v3 = a1;
  v4 = 0;
  v5 = 1;
  if ( a1 != 0.0 )
  {
    v6 = *(_DWORD *)(LODWORD(a1) + 4);
    if ( v6 )
    {
      v7 = *(_BYTE *)(LODWORD(a1) + 8);
      switch ( *(_BYTE *)(LODWORD(a1) + 8) )
      {
        case 0:
        case 1:
          sub_10062280(a1, a2, a3);
          return;
        case 2:
          sub_1004A1A0(
            v6,
            *(_DWORD *)(LODWORD(a1) + 12),
            164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912,
            *(float *)(LODWORD(a1) + 16),
            *(float *)(LODWORD(a1) + 20),
            *(float *)(LODWORD(a1) + 24),
            *(float *)(LODWORD(a1) + 28),
            0);
          *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 4312) = *(_WORD *)(LODWORD(a1) + 42);
          if ( *(_BYTE *)(LODWORD(a1) + 41) )
            sub_100490F0(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
          if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
            sub_10049040(a3 + 12 * *(_BYTE *)LODWORD(a1), 1, *(_BYTE *)(LODWORD(a1) + 41), *(_DWORD *)(LODWORD(a1) + 4));
          v8 = a2;
          if ( a2 && *(float *)(a2 + 4) > 0.0 )
          {
            v9 = sub_1004A660(*(float *)(a2 + 4), *(float *)(a2 + 8), *(float *)(a2 + 12), *(_DWORD *)(LODWORD(a1) + 4));
            if ( *(float *)(a2 + 16) > 0.0 )
              sub_100488B0(
                *(float *)(a2 + 16),
                *(char **)(a2 + 20),
                *(float *)(a2 + 24),
                *(float *)(a2 + 28),
                *(_DWORD *)(LODWORD(a1) + 4));
            v10 = *(_BYTE *)(a2 + 36);
            if ( v10 )
            {
              v11 = *(_DWORD *)(a2 + 32);
              if ( v11 )
              {
                sub_10049310(v11, v10, v9, *(_DWORD *)(LODWORD(a1) + 4));
                goto LABEL_17;
              }
            }
          }
          return;
        case 3:
          sub_1004A1E0(
            v6,
            *(_DWORD *)(LODWORD(a1) + 12),
            164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912,
            *(float *)(LODWORD(a1) + 16),
            *(float *)(LODWORD(a1) + 20),
            *(float *)(LODWORD(a1) + 24),
            *(float *)(LODWORD(a1) + 28),
            0);
          *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 4312) = *(_WORD *)(LODWORD(a1) + 42);
          if ( *(_BYTE *)(LODWORD(a1) + 41) )
            sub_100490F0(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
          if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
            sub_10049040(a3 + 12 * *(_BYTE *)LODWORD(a1), 2, *(_BYTE *)(LODWORD(a1) + 41), *(_DWORD *)(LODWORD(a1) + 4));
          if ( a2 && *(float *)(a2 + 4) > 0.0 )
          {
            v12 = sub_1004A630(
                    *(float *)(a2 + 4),
                    *(float *)(a2 + 8),
                    *(float *)(a2 + 12),
                    *(_DWORD *)(LODWORD(a1) + 4));
            if ( *(float *)(a2 + 16) > 0.0 )
              sub_100488B0(
                *(float *)(a2 + 16),
                *(char **)(a2 + 20),
                *(float *)(a2 + 24),
                *(float *)(a2 + 28),
                *(_DWORD *)(LODWORD(a1) + 4));
            v13 = *(_BYTE *)(a2 + 36);
            if ( v13 )
            {
              v14 = *(_DWORD *)(a2 + 32);
              if ( v14 )
              {
                sub_10049310(v14, v13, v12, *(_DWORD *)(LODWORD(a1) + 4));
                *(_BYTE *)(*(_DWORD *)(LODWORD(a1) + 4) + 4036) = v12 + *(_BYTE *)(a2 + 36);
              }
            }
          }
          return;
        case 0xB:
          v15 = 164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912;
          v16 = *(_DWORD *)(LODWORD(a1) + 12);
          v17 = *(float *)(LODWORD(a1) + 28);
          v5 = 2;
          v18 = *(float *)(LODWORD(a1) + 24);
          v48 = v17 * 0.5 + *(float *)(LODWORD(a1) + 20);
          sub_10046960(v6, v16, v15, *(float *)(LODWORD(v3) + 16), v48, v18, v17);
          goto LABEL_32;
        case 0xA:
          v19 = 164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912;
          v20 = *(_DWORD *)(LODWORD(a1) + 12);
          v21 = *(float *)(LODWORD(a1) + 28);
          v22 = *(float *)(LODWORD(a1) + 24);
          v49 = *(float *)(LODWORD(a1) + 20) + v21;
          sub_10046920(v6, v20, v19, *(float *)(LODWORD(v3) + 16), v49, v22, v21);
LABEL_32:
          *(_WORD *)(*(_DWORD *)(LODWORD(v3) + 4) + 516) = *(_WORD *)(LODWORD(v3) + 42);
          if ( *(_BYTE *)(LODWORD(v3) + 41) )
            sub_10046630(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(v3) + 2) + 20480, *(_DWORD *)(LODWORD(v3) + 4));
          if ( a3 && *(_BYTE *)LODWORD(v3) >= 0 )
            sub_100465F0(a3 + 12 * *(_BYTE *)LODWORD(v3), (unsigned __int8)v5, *(_DWORD *)(LODWORD(v3) + 4));
          return;
        case 0xC:
          v23 = 164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912;
          v24 = *(_DWORD *)(LODWORD(a1) + 12);
          v25 = *(float *)(LODWORD(a1) + 28);
          v26 = *(float *)(LODWORD(a1) + 24);
          v50 = *(float *)(LODWORD(a1) + 20) + v25;
          sub_10045660(v6, v24, v23, *(float *)(LODWORD(v3) + 16), v50, v26, v25);
          *(_WORD *)(*(_DWORD *)(LODWORD(v3) + 4) + 512) = *(_WORD *)(LODWORD(v3) + 42);
          if ( *(_BYTE *)(LODWORD(v3) + 41) )
            sub_10045050(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(v3) + 2) + 20480, *(_DWORD *)(LODWORD(v3) + 4));
          return;
        case 0xD:
        case 0xE:
        case 0xF:
          v27 = 164 * *(_BYTE *)(LODWORD(a1) + 2);
          v46 = *(float *)(LODWORD(a1) + 28);
          v44 = *(float *)(LODWORD(a1) + 24);
          v42 = *(float *)(LODWORD(a1) + 20);
          v40 = *(float *)(LODWORD(a1) + 16);
          if ( v7 == 15 )
          {
            v28 = 3;
            sub_10044F30(v6, *(_DWORD *)(LODWORD(a1) + 12), v27 + dword_1031FB44 + 3912, v40, v42, v44, v46);
          }
          else
          {
            v39 = v27 + dword_1031FB44 + 3912;
            v38 = *(_DWORD *)(LODWORD(a1) + 12);
            if ( v7 == 14 )
            {
              v28 = 2;
              sub_10044EC0(v6, v38, v39, v40, v42, v44, v46);
            }
            else
            {
              v28 = 1;
              sub_10044E50(v6, v38, v39, v40, v42, v44, v46);
            }
          }
          *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 11450) = *(_WORD *)(LODWORD(a1) + 42);
          if ( *(_BYTE *)(LODWORD(a1) + 41) )
            sub_100490F0(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
          if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
            sub_10042D60(
              a3 + 12 * *(_BYTE *)LODWORD(a1),
              (unsigned __int8)v28,
              *(_BYTE *)(LODWORD(a1) + 41),
              *(_DWORD *)(LODWORD(a1) + 4));
          v8 = a2;
          if ( a2 && *(float *)(a2 + 4) > 0.0 )
          {
            v9 = sub_10044300(*(float *)(a2 + 4), *(float *)(a2 + 8), *(float *)(a2 + 12), *(_DWORD *)(LODWORD(a1) + 4));
            if ( *(float *)(a2 + 16) > 0.0 )
              sub_10042C30(
                *(float *)(a2 + 16),
                *(char **)(a2 + 20),
                *(float *)(a2 + 24),
                *(float *)(a2 + 28),
                *(_DWORD *)(LODWORD(a1) + 4));
            v29 = *(_BYTE *)(a2 + 36);
            if ( v29 )
            {
              v30 = *(_DWORD *)(a2 + 32);
              if ( v30 )
              {
                sub_100445B0(v30, v29, v9, *(_DWORD *)(LODWORD(a1) + 4));
LABEL_17:
                *(_BYTE *)(*(_DWORD *)(LODWORD(a1) + 4) + 4036) = v9 + *(_BYTE *)(v8 + 36);
              }
            }
          }
          return;
        case 0x11:
          v4 = 1;
          goto LABEL_57;
        case 0x10:
LABEL_57:
          v47 = *(float *)(LODWORD(a1) + 28);
          v31 = v4 == 0;
          v32 = *(_BYTE *)(LODWORD(a1) + 2);
          v45 = *(float *)(LODWORD(a1) + 24);
          v33 = v6 + 16;
          v43 = *(float *)(LODWORD(a1) + 20);
          v41 = *(float *)(LODWORD(a1) + 16);
          if ( v31 )
            sub_10042820(v6, *(_DWORD *)(LODWORD(a1) + 12), 164 * v32 + dword_1031FB44 + 3912, v41, v43, v45, v47);
          else
            sub_100428D0(v6, *(_DWORD *)(LODWORD(a1) + 12), 164 * v32 + dword_1031FB44 + 3912, v41, v43, v45, v47);
          *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 5574) = *(_WORD *)(LODWORD(a1) + 42);
          if ( *(_BYTE *)(LODWORD(a1) + 41) )
            sub_10042990(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
          if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
            sub_10060F20(a3 + 12 * *(_BYTE *)LODWORD(a1), *(_BYTE *)(LODWORD(a1) + 41), v33);
          if ( a2 && *(float *)(a2 + 4) > 0.0 )
          {
            v34 = sub_10062160(*(float *)(a2 + 4), *(float *)(a2 + 8), *(float *)(a2 + 12), v33);
            LOBYTE(a1) = v34;
            if ( *(float *)(a2 + 16) > 0.0 )
              sub_10061F10(
                *(float *)(a2 + 16),
                *(char **)(a2 + 20),
                *(float *)(a2 + 24),
                *(float *)(a2 + 28),
                *(float *)(a2 + 12),
                v33);
            v35 = *(_BYTE *)(a2 + 36);
            if ( v35 )
            {
              v36 = *(_DWORD *)(a2 + 32);
              if ( v36 )
              {
                sub_100612A0(v36, v35, a1, v33);
                *(_BYTE *)(v33 + 5556) = v34 + *(_BYTE *)(a2 + 36);
              }
            }
          }
          break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          v37 = (unsigned __int8)(v7 - 3);
          sub_100483D0(
            v6,
            *(_DWORD *)(LODWORD(a1) + 12),
            164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912,
            *(float *)(LODWORD(a1) + 16),
            *(float *)(LODWORD(a1) + 20),
            *(float *)(LODWORD(a1) + 24),
            *(float *)(LODWORD(a1) + 28),
            v37);
          *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 964) = *(_WORD *)(LODWORD(a1) + 42);
          if ( *(_BYTE *)(LODWORD(a1) + 41) )
            sub_10047B60(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
          if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
            sub_10047B10(
              a3 + 12 * *(_BYTE *)LODWORD(a1),
              v37,
              *(_BYTE *)(LODWORD(a1) + 41),
              *(_DWORD *)(LODWORD(a1) + 4));
          break;
        default:
          return;
      }
    }
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1004CCA0) --------------------------------------------------------
char __cdecl sub_1004CCA0(int a1, char a2)
{
  signed int v2; // eax@2
  float *v3; // ecx@2
  char result; // al@4
  int v5; // esi@5
  signed int v6; // eax@5
  signed int v7; // ebx@10
  int v8; // esi@11
  float *v9; // edx@14
  double v10; // st7@15
  bool v11; // dl@15
  signed int v12; // eax@15
  char v13; // dl@18
  float *v14; // edx@28
  int v15; // esi@42
  signed int v16; // edx@42
  char v17; // al@44
  char v18; // al@55
  char v19; // bl@55
  signed int v20; // edx@61
  float **v21; // esi@62
  char v22; // [sp+5h] [bp-3h]@42
  bool v23; // [sp+6h] [bp-2h]@42
  char v24; // [sp+10h] [bp+8h]@5
  char v25; // [sp+10h] [bp+8h]@42

  if ( a2 )
  {
    sub_1008CA60(6247, (int)&flt_101CAB20, 4);
    sub_1008CA60(6248, (int)&flt_101CAB24, 4);
    *(_BYTE *)a1 = 6;
    *(_BYTE *)(a1 + 34) = 0;
    *(_BYTE *)(a1 + 32) = 6;
    *(_BYTE *)(a1 + 33) = 6;
    v2 = 0;
    v3 = (float *)(a1 + 68);
    do
    {
      *(v3 - 6) = 0.0;
      ++v2;
      *v3 = 0.0;
      *(_BYTE *)(a1 + v2 + 34) = 0;
      ++v3;
    }
    while ( v2 < 6 );
    return 0;
  }
  v5 = *(_BYTE *)a1;
  v6 = 0;
  v24 = 1;
  if ( v5 > 0 )
  {
    do
    {
      if ( !v24 || (v24 = 1, !*(_BYTE *)(v6 + a1 + 35)) )
        v24 = 0;
      ++v6;
    }
    while ( v6 < *(_BYTE *)a1 );
  }
  v7 = 0;
  if ( v5 > 0 )
  {
    v8 = a1 + 44;
    do
    {
      if ( v7 >= 6 )
        break;
      if ( *(_BYTE *)(a1 + v7 + 35) )
      {
        v9 = *(float **)(v8 - 40);
        if ( *v9 > flt_101CAB20 + *(float *)v8 )
        {
          v10 = *v9;
          v11 = 1;
          *(float *)v8 = v10;
          v12 = 0;
          *(float *)(v8 + 24) = **(float **)(a1 + 28);
          if ( !*(_BYTE *)a1 )
            goto LABEL_73;
          do
          {
            if ( v12 != v7 )
              v11 = v11 && ((v13 = *(_BYTE *)(a1 + v12 + 35)) == 0 || v13 == 1);
            ++v12;
          }
          while ( v12 < *(_BYTE *)a1 );
          if ( v11 )
          {
LABEL_73:
            *(_BYTE *)(a1 + v7 + 35) = 0;
            *(_BYTE *)(a1 + 32) = 6;
          }
        }
      }
      switch ( *(_BYTE *)(a1 + v7 + 35) )
      {
        case 1:
          if ( *(float *)(v8 + 24) > **(float **)(a1 + 28) + flt_101CAB24 )
          {
            *(_BYTE *)(a1 + v7 + 35) = 2;
            if ( *(_BYTE *)(a1 + 32) == 6 )
              *(_BYTE *)(a1 + 32) = v7;
            if ( v24 )
              *(_BYTE *)(a1 + 33) = v7;
          }
          break;
        case 2:
          if ( *(float *)(v8 + 24) + flt_101CAB24 < **(float **)(a1 + 28) )
            *(_BYTE *)(a1 + v7 + 35) = 3;
          break;
        case 3:
          if ( *(float *)(v8 + 24) - flt_101CAB24 > **(float **)(a1 + 28) )
            *(_BYTE *)(a1 + v7 + 35) = 2;
          break;
        default:
          v14 = *(float **)(v8 - 40);
          if ( *(float *)v8 >= (double)*v14 )
          {
            if ( *(float *)v8 - flt_101CAB20 > *v14 )
              *(_BYTE *)(a1 + v7 + 35) = 1;
          }
          else
          {
            *(float *)v8 = *v14;
            *(float *)(v8 + 24) = **(float **)(a1 + 28);
          }
          break;
      }
      ++v7;
      v8 += 4;
    }
    while ( v7 < *(_BYTE *)a1 );
  }
  v15 = *(_BYTE *)a1;
  v16 = 0;
  v23 = 1;
  v25 = 1;
  v22 = 1;
  if ( v15 > 0 )
  {
    do
    {
      v23 = v23 && ((v17 = *(_BYTE *)(v16 + a1 + 35)) == 0 || v17 == 1);
      if ( !v25 || (v25 = 1, !*(_BYTE *)(v16 + a1 + 35)) )
        v25 = 0;
      if ( !v22 || (v22 = 1, *(_BYTE *)(v16 + a1 + 35) != 2) )
        v22 = 0;
      ++v16;
    }
    while ( v16 < *(_BYTE *)a1 );
  }
  v18 = *(_BYTE *)(a1 + 32);
  v19 = 3;
  if ( v18 == 6 )
    v19 = 0;
  if ( v25 && v22 )
    v19 = 2;
  if ( !v23 )
  {
    if ( v19 == 2 )
    {
      result = 2;
      *(_BYTE *)(a1 + 34) = *(_BYTE *)(a1 + 33);
      return result;
    }
    *(_BYTE *)(a1 + 34) = v18;
    return v19;
  }
  v20 = 0;
  *(_BYTE *)(a1 + 34) = 0;
  if ( v15 <= 0 )
    return v19;
  v21 = (float **)(a1 + 4);
  do
  {
    if ( **(float **)(a1 + 4 * *(_BYTE *)(a1 + 34) + 4) < (double)**v21 )
      *(_BYTE *)(a1 + 34) = v20;
    ++v20;
    ++v21;
  }
  while ( v20 < *(_BYTE *)a1 );
  return v19;
}
// 101CAB20: using guessed type float flt_101CAB20;
// 101CAB24: using guessed type float flt_101CAB24;

//----- (1004CF90) --------------------------------------------------------
double __cdecl sub_1004CF90(float a1, int a2, int a3, int a4, float a5, float a6)
{
  float v6; // esi@1
  double result; // st7@2
  int v8; // eax@4
  int v9; // ecx@4
  double v10; // st6@5
  double v11; // st6@7
  double v12; // st7@7
  unsigned __int8 v13; // cl@9
  unsigned __int8 v14; // al@10
  int v15; // eax@14
  float v16; // ST20_4@14
  char v17; // dl@20
  char v18; // cl@20
  signed int v19; // eax@21
  float v20; // [sp+4h] [bp-4h]@9
  int v21; // [sp+4h] [bp-4h]@17
  float v22; // [sp+Ch] [bp+4h]@3
  float v23; // [sp+Ch] [bp+4h]@5
  float v24; // [sp+Ch] [bp+4h]@5
  float v25; // [sp+Ch] [bp+4h]@9

  v6 = a1;
  if ( a1 == 0.0 )
  {
    result = -1.0;
  }
  else
  {
    v22 = 0.0;
    if ( (_BYTE)a4 )
    {
      v8 = LODWORD(v6) + 32;
      v9 = (unsigned __int8)a4;
      do
      {
        v10 = *(float *)(v8 - 4);
        v8 += 44;
        --v9;
        v23 = v10 + v22;
        v24 = v23 + *(float *)(v8 - 44);
        v22 = v24 + *(float *)(v8 - 40);
      }
      while ( v9 );
    }
    if ( (unsigned __int8)a4 >= 2u )
    {
      v12 = a5;
      v11 = (a6 - a5 - v22) / (double)((unsigned __int8)a4 - 1);
    }
    else
    {
      v11 = 0.0;
      v12 = a5;
    }
    v25 = v11;
    v13 = 0;
    v20 = v12;
    result = v25;
    if ( (_BYTE)a4 )
    {
      do
      {
        v14 = 0;
        if ( *(_BYTE *)(LODWORD(v6) + 1) == v13 )
        {
LABEL_13:
          if ( v14 < (unsigned __int8)a4 )
          {
            v15 = 44 * v14;
            v16 = *(float *)(v15 + LODWORD(v6) + 32) + v20;
            *(float *)(v15 + LODWORD(v6) + 20) = v16;
            v20 = v16 + *(float *)(v15 + LODWORD(v6) + 28) + *(float *)(LODWORD(v6) + v15 + 36) + result;
          }
        }
        else
        {
          while ( v14 < (unsigned __int8)a4 )
          {
            if ( *(_BYTE *)(44 * ++v14 + LODWORD(v6) + 1) == v13 )
              goto LABEL_13;
          }
        }
        ++v13;
      }
      while ( v13 < (unsigned __int8)a4 );
      if ( (_BYTE)a4 )
      {
        v21 = (unsigned __int8)a4;
        do
        {
          if ( *(_BYTE *)(LODWORD(v6) + 40) )
          {
            if ( a2 )
            {
              v17 = *(_BYTE *)(LODWORD(v6) + 1);
              v18 = 0;
              if ( *(_BYTE *)a2 != v17 )
              {
                v19 = 0;
                do
                {
                  if ( v19 >= (unsigned __int8)a4 )
                    break;
                  v19 = ++v18;
                }
                while ( *(_BYTE *)(a2 + 40 * v18) != v17 );
              }
            }
            else
            {
              v18 = -1;
            }
            if ( v18 >= (signed int)(unsigned __int8)a4 || v18 < 0 )
              sub_1004C410(v6, 0, a3);
            else
              sub_1004C410(v6, a2 + 40 * v18, a3);
          }
          LODWORD(v6) += 44;
          --v21;
        }
        while ( v21 );
        result = v25;
      }
    }
  }
  return result;
}

//----- (1004D100) --------------------------------------------------------
char __cdecl sub_1004D100(unsigned int a1)
{
  char v1; // bl@1
  int v2; // eax@2
  char result; // al@2
  __int64 v4; // [sp-4h] [bp-28h]@0
  char v5; // [sp+8h] [bp-1Ch]@2
  unsigned int v6; // [sp+Ch] [bp-18h]@2

  v1 = byte_1031F2B0;
  LODWORD(v4) = a1;
  if ( sub_1004EB40(v4) )
  {
    result = v1;
  }
  else
  {
    v2 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v2, 28, &v5);
    result = (v6 >> 26) & 7;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2B0: using guessed type char byte_1031F2B0;

//----- (1004D150) --------------------------------------------------------
char __cdecl sub_1004D150(unsigned int a1)
{
  int v1; // eax@2
  char result; // al@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  char v4; // [sp+8h] [bp-1Ch]@2
  char v5; // [sp+20h] [bp-4h]@2

  LODWORD(v3) = a1;
  if ( sub_1004EB40(v3) )
  {
    result = 0;
  }
  else
  {
    v1 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v1, 28, &v4);
    result = v5;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004D1A0) --------------------------------------------------------
int __cdecl sub_1004D1A0(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_1031F9E2;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 1031F9E2: using guessed type __int16 word_1031F9E2;

//----- (1004D1E0) --------------------------------------------------------
signed int __usercall sub_1004D1E0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax@4

  if ( !a3 )
    return 1000;
  if ( a1 != 1000 )
  {
    v4 = 5 * a1;
    goto LABEL_7;
  }
  if ( a2 != 1000 )
  {
    v4 = 5 * a2 - 90;
LABEL_7:
    if ( abs(2 * v4 - a3) > 90 )
      a3 += 180;
  }
  return a3;
}

//----- (1004D220) --------------------------------------------------------
signed int __thiscall sub_1004D220(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1004D1A0(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1031F1D4)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_1031F9E2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1031F9E2;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1031F9E2;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E2: using guessed type __int16 word_1031F9E2;

//----- (1004D2D0) --------------------------------------------------------
signed int __usercall sub_1004D2D0@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_1004D1A0(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1031F1D4)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_1031F9E2;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E2: using guessed type __int16 word_1031F9E2;

//----- (1004D360) --------------------------------------------------------
signed int __thiscall sub_1004D360(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1004D1A0(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1031F1D4)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_1031F9E2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1031F9E2;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E2: using guessed type __int16 word_1031F9E2;

//----- (1004D400) --------------------------------------------------------
signed int __usercall sub_1004D400@<eax>(int a1@<esi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // edi@2
  unsigned __int16 v4; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 2 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_1004D1A0(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1031F1D4)(v2, 160, &v4);
    if ( *(_BYTE *)(a1 + 4) & 1 )
      v3 += v4;
    result = v3;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004D470) --------------------------------------------------------
char __usercall sub_1004D470@<al>(int a1@<eax>, char a2)
{
  int v2; // ecx@2
  char v3; // cl@2
  int v4; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@3
  int v7; // eax@5

  if ( a2 == 2 )
  {
    v2 = *(_DWORD *)(a1 + 12) >> 22;
    v4 = *(_DWORD *)(a1 + 4) >> 30;
    v3 = v2 & 3;
    LOBYTE(v4) = v4 & 3;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 12);
    v6 = v5 >> 23;
    v4 = v5 >> 22;
    v3 = v6 & 1;
    LOBYTE(v4) = v4 & 1;
  }
  if ( v3 == 1 )
  {
    LOBYTE(v4) = (_BYTE)v4 == 1;
    v7 = 2 * v4 + 1;
  }
  else if ( (_BYTE)v4 == 1 )
  {
    LOBYTE(v7) = 2;
  }
  else if ( v3 == 2 || (_BYTE)v4 == 2 )
  {
    LOBYTE(v7) = 5;
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  return v7;
}

//----- (1004D4C0) --------------------------------------------------------
int __usercall sub_1004D4C0@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_1004D1A0(a1);
  return result;
}

//----- (1004D4E0) --------------------------------------------------------
char __usercall sub_1004D4E0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_100D7ED0[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_100D7EC8[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_1031F1D4)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_1031F9E6;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_100D7EC8[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E6: using guessed type __int16 word_1031F9E6;

//----- (1004D5A0) --------------------------------------------------------
void *__usercall sub_1004D5A0@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_1031F344;
    *(_DWORD *)a2 = v2 + dword_1031F344;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_1031F1D4)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_1031F348;
  }
  else
  {
    result = memcpy(a2, &unk_100D7ED8, 6u);
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F344: using guessed type int dword_1031F344;
// 1031F348: using guessed type __int16 word_1031F348;

//----- (1004D600) --------------------------------------------------------
char __usercall sub_1004D600@<al>(unsigned int a1@<ecx>, int *a2@<esi>)
{
  unsigned __int8 v2; // dl@1
  int v3; // eax@3
  unsigned int v5; // [sp-2h] [bp-4h]@1
  int v6; // [sp-2h] [bp-4h]@9

  v5 = a1;
  (*(void (__cdecl **)(int, signed int, char *, unsigned int))dword_1031F1D4)(*a2, 1, (char *)&v5 + 2, a1);
  *a2 += (unsigned __int16)word_1031F9F2;
  v2 = BYTE2(v5);
  if ( BYTE2(v5) & 1 )
    *a2 += (unsigned __int16)word_1031F9F4;
  LOBYTE(v3) = (v2 >> 1) & 3;
  if ( (_BYTE)v3 )
  {
    *a2 += (unsigned __int16)word_1031F9F6;
    if ( (_BYTE)v3 == 3 )
    {
      v3 = *a2 + (unsigned __int16)word_1031F9F6;
      *a2 = v3;
    }
  }
  if ( v2 & 8 )
    *a2 += (unsigned __int16)word_1031F9F8;
  if ( v2 & 0x10 )
  {
    (*(void (__cdecl **)(int, signed int, char *, int))dword_1031F1D4)(*a2, 1, (char *)&v5 + 3, v6);
    v3 = BYTE3(v5) + (unsigned __int16)word_1031F9FA;
    *a2 += v3;
  }
  return v3;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9F2: using guessed type __int16 word_1031F9F2;
// 1031F9F4: using guessed type __int16 word_1031F9F4;
// 1031F9F6: using guessed type __int16 word_1031F9F6;
// 1031F9F8: using guessed type __int16 word_1031F9F8;
// 1031F9FA: using guessed type __int16 word_1031F9FA;

//----- (1004D6A0) --------------------------------------------------------
int __usercall sub_1004D6A0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>)
{
  int v2; // edi@1
  int *v3; // edx@1
  int v4; // esi@4
  int result; // eax@4
  char v6; // cl@4
  char v7; // [sp+Ch] [bp-34h]@3
  char v8; // [sp+30h] [bp-10h]@2
  int v9; // [sp+3Ch] [bp-4h]@1

  v2 = a1;
  *a2 = 0;
  v3 = &v9;
  do
  {
    if ( v3 > (int *)&v8 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v2, 48, &v7);
      v3 = (int *)&v7;
    }
    ++*a2;
    v2 += (unsigned __int16)word_1031F9E4;
    v4 = (unsigned __int16)word_1031F9E4;
    result = *(_WORD *)((char *)v3 + 5);
    v6 = *((_BYTE *)v3 + 2) >> 7;
    if ( result & 4 )
    {
      v2 += (unsigned __int16)word_1031F9E6;
      v4 = (unsigned __int16)word_1031F9E6 + (unsigned __int16)word_1031F9E4;
    }
    if ( result & 8 )
    {
      v2 += (unsigned __int16)word_1031F9E8;
      v4 += (unsigned __int16)word_1031F9E8;
    }
    if ( result & 0x10 )
    {
      result = (unsigned __int16)word_1031F9EA;
      v2 += (unsigned __int16)word_1031F9EA;
      v4 += (unsigned __int16)word_1031F9EA;
    }
    v3 = (int *)((char *)v3 + v4);
  }
  while ( v6 );
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E4: using guessed type __int16 word_1031F9E4;
// 1031F9E6: using guessed type __int16 word_1031F9E6;
// 1031F9E8: using guessed type __int16 word_1031F9E8;
// 1031F9EA: using guessed type __int16 word_1031F9EA;

//----- (1004D740) --------------------------------------------------------
__int16 __usercall sub_1004D740@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_1004F980(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1031F1D4)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1031F1D4)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_1031F9E4 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_1031F9E6;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E4: using guessed type __int16 word_1031F9E4;
// 1031F9E6: using guessed type __int16 word_1031F9E6;

//----- (1004D8B0) --------------------------------------------------------
char __cdecl sub_1004D8B0(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebp@1
  __int64 v4; // ST00_8@1
  char result; // al@1
  int v6; // eax@2
  unsigned int v7; // edi@2
  unsigned int v8; // ecx@2
  unsigned __int8 v9; // al@2
  char v10; // dl@2
  unsigned __int8 v11; // cl@3
  char v12; // dl@3
  char v13; // cl@3
  unsigned int v14; // ebp@4
  unsigned __int8 v15; // cl@4
  unsigned int v16; // eax@5
  char v17; // [sp+14h] [bp-20h]@2
  unsigned int v18; // [sp+18h] [bp-1Ch]@2
  int v19; // [sp+1Eh] [bp-16h]@2
  unsigned int v20; // [sp+24h] [bp-10h]@2
  unsigned int v21; // [sp+28h] [bp-Ch]@2
  __int16 v22; // [sp+2Dh] [bp-7h]@8
  unsigned __int8 v23; // [sp+2Fh] [bp-5h]@3
  unsigned __int8 v24; // [sp+30h] [bp-4h]@3
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1
  int v26; // [sp+3Ch] [bp+8h]@8

  v2 = a2;
  v3 = a2 + 32;
  memcpy((void *)(a2 + 32), "______", 7u);
  *(double *)a2 = 6.2831853071796;
  *(double *)(a2 + 8) = 6.2831853071796;
  *(float *)(a2 + 16) = 9.9999996e24;
  *(_BYTE *)(a2 + 62) = byte_1031F2B0;
  *(_BYTE *)(a2 + 58) = 0;
  *(_BYTE *)(a2 + 63) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 65) = 0;
  *(_BYTE *)(a2 + 66) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 28) = 0x3FFFF;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 67) = 2;
  *(_BYTE *)(a2 + 59) = 0;
  *(_BYTE *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 61) = 0;
  sub_100649E0(a2 + 39, word_100C2700, 9);
  sub_100649E0(a2 + 52, word_100C2700, 6);
  sub_100649E0(a2 + 48, word_100C2700, 4);
  LODWORD(v4) = a1;
  v25 = sub_10073D80();
  result = sub_1004EB40(v4);
  if ( !result )
  {
    sub_1004F840(a1, v3);
    sub_1004FA60(a1, v2);
    v6 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v6, 29, &v17);
    v7 = v18;
    v8 = v21 >> 13;
    v9 = (v18 >> 26) & 7;
    v10 = (v20 >> 23) & 1;
    *(float *)(v2 + 16) = (double)((v19 & 0x7FFF) - 5000) * 0.3048000037670135;
    *(_BYTE *)(v2 + 62) = v9;
    *(_BYTE *)(v2 + 58) = v10;
    *(_BYTE *)(v2 + 63) = v8 & 7;
    if ( v25 == 2 )
    {
      v11 = v24;
      *(_BYTE *)(v2 + 65) = v24 & 7;
      *(_BYTE *)(v2 + 66) = (v23 >> 4) & 7;
      *(_BYTE *)(v2 + 67) = (*(unsigned int *)((char *)&v19 + 2) >> 29) & 3;
      *(_BYTE *)(v2 + 59) = (v11 >> 3) & 1;
      v12 = v11 >> 4;
      v13 = v11 >> 5;
    }
    else
    {
      v14 = *(int *)((char *)&v19 + 2);
      *(_BYTE *)(v2 + 65) = (*(unsigned int *)((char *)&v19 + 2) >> 30) & 3;
      *(_BYTE *)(v2 + 66) = (v7 >> 30) & 3;
      *(_BYTE *)(v2 + 67) = (v14 >> 29) & 1;
      v15 = v23;
      *(_BYTE *)(v2 + 59) = (v23 >> 2) & 1;
      v12 = v15 >> 3;
      v13 = v15 >> 4;
    }
    *(_BYTE *)(v2 + 61) = v13 & 1;
    *(_BYTE *)(v2 + 60) = v12 & 1;
    sub_100649E0(v2 + 39, (_BYTE *)(dword_1031FB10 + 25 * (v9 + 64)), 9);
    sub_100649E0(v2 + 52, (_BYTE *)(dword_1031FB10 + 25 * (*(_BYTE *)(v2 + 66) + 128)), 6);
    sub_100649E0(v2 + 48, (_BYTE *)(dword_1031FB10 + 25 * (*(_BYTE *)(v2 + 65) + 192)), 4);
    v16 = (*(unsigned int *)((char *)&v19 + 2) >> 24) & 0x1F;
    *(_DWORD *)(v2 + 20) = v16;
    if ( v16 != 31 )
      *(_DWORD *)(v2 + 20) = 12 - v16;
    *(_DWORD *)(v2 + 24) = v21 & 0x1FFF;
    result = sub_1004D470((int)&v17, v25);
    *(_BYTE *)(v2 + 64) = result;
    if ( (unsigned __int16)word_1031F324 >= 0x1Cu )
    {
      result = v22;
      HIWORD(v26) = v23 & 3;
      LOWORD(v26) = v22;
      *(_DWORD *)(v2 + 28) = v26;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2B0: using guessed type char byte_1031F2B0;
// 1031F324: using guessed type __int16 word_1031F324;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004DB30) --------------------------------------------------------
void *__cdecl sub_1004DB30(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_1004EB40(v4) )
  {
    v2 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v2, 28, &v5);
  }
  return sub_1004D5A0((int)&v5, a2);
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004DB80) --------------------------------------------------------
signed int __cdecl sub_1004DB80(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_1004D220(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1031F9EC;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_1031F9EE;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9EC: using guessed type __int16 word_1031F9EC;
// 1031F9EE: using guessed type __int16 word_1031F9EE;

//----- (1004DC00) --------------------------------------------------------
signed int __usercall sub_1004DC00@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_1004D2D0(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1031FA04;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FA04: using guessed type __int16 word_1031FA04;

//----- (1004DC70) --------------------------------------------------------
signed int __cdecl sub_1004DC70(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_1004D360(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1031FA06;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FA06: using guessed type __int16 word_1031FA06;

//----- (1004DCE0) --------------------------------------------------------
signed int __usercall sub_1004DCE0@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  signed int result; // eax@1
  int v3; // esi@1
  unsigned __int8 v4; // bl@2
  unsigned int v5; // ecx@3
  int v6; // [sp+4h] [bp-8h]@3
  int v7; // [sp+8h] [bp-4h]@4

  result = sub_1004D400(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(v3, 4, &v6);
        if ( !(v6 & 0x8000) )
          break;
        v3 += (unsigned __int16)word_1031F9F0;
        ++v4;
        v7 = v3;
        if ( BYTE2(v6) & 0x80 )
        {
          sub_1004D600(v5, &v7);
          v3 = v7;
        }
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9F0: using guessed type __int16 word_1031F9F0;

//----- (1004DD60) --------------------------------------------------------
int __usercall sub_1004DD60@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_1004D4C0(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_1031F9E4;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_1031F9E6;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_1031F9E8;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_1031F9EA;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E4: using guessed type __int16 word_1031F9E4;
// 1031F9E6: using guessed type __int16 word_1031F9E6;
// 1031F9E8: using guessed type __int16 word_1031F9E8;
// 1031F9EA: using guessed type __int16 word_1031F9EA;

//----- (1004DDF0) --------------------------------------------------------
int __usercall sub_1004DDF0@<eax>(int a1@<eax>)
{
  signed int v1; // esi@1
  unsigned int v2; // ecx@2
  int result; // eax@6
  int v4; // [sp+8h] [bp-8h]@2
  int v5; // [sp+Ch] [bp-4h]@2

  v1 = sub_1004D400(a1);
  if ( v1 == 0xFFFFFF )
  {
LABEL_6:
    result = 0xFFFF;
  }
  else
  {
    while ( 1 )
    {
      (*(void (__cdecl **)(signed int, signed int, int *))dword_1031F1D4)(v1, 4, &v4);
      v1 += (unsigned __int16)word_1031F9F0;
      v5 = v1;
      if ( BYTE2(v4) & 0x40 )
        break;
      if ( SBYTE2(v4) < 0 )
      {
        sub_1004D600(v2, &v5);
        v1 = v5;
      }
      if ( !(v4 & 0x8000) )
        goto LABEL_6;
    }
    result = ((v4 & 0xFFF) % 5 != 0 ? 5 : 0) + 2 * (5 * (v4 & 0xFFF) + 54000);
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9F0: using guessed type __int16 word_1031F9F0;

//----- (1004DE90) --------------------------------------------------------
char __cdecl sub_1004DE90(int a1, _BYTE *a2)
{
  _BYTE *v2; // ebp@1
  int v3; // esi@1
  int *v4; // edi@1
  char result; // al@4
  char v6; // bl@4
  int v7; // ST1C_4@5
  char v8; // [sp+14h] [bp-20h]@3
  char v9; // [sp+2Ch] [bp-8h]@2
  int v10; // [sp+30h] [bp-4h]@1

  v2 = a2;
  v3 = a1;
  *a2 = 0;
  v4 = &v10;
  do
  {
    if ( v4 > (int *)&v9 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v3, 28, &v8);
      v4 = (int *)&v8;
    }
    ++*v2;
    result = *((_BYTE *)v4 + 2) >> 7;
    v3 += (unsigned __int16)word_1031F9F0;
    v6 = (*(_WORD *)v4 >> 15) & 1;
    v4 = (int *)((char *)v4 + (unsigned __int16)word_1031F9F0);
    a1 = v3;
    if ( result )
    {
      v7 = v3;
      result = sub_1004D600((unsigned __int16)word_1031F9F0, &a1);
      v3 = a1;
      v4 = (int *)((char *)v4 + a1 - v7);
    }
  }
  while ( v6 );
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9F0: using guessed type __int16 word_1031F9F0;

//----- (1004DF30) --------------------------------------------------------
void __usercall sub_1004DF30(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_1004D740(a3, (int)&v3, a2);
  *(double *)a1 = sub_10074380(v3, 24);
  *(double *)(a1 + 8) = sub_10074380(v4, 24);
}

//----- (1004DF70) --------------------------------------------------------
char __cdecl sub_1004DF70(unsigned int a1)
{
  int v1; // eax@1
  char result; // al@2
  char v3; // [sp+Bh] [bp-9h]@1
  char v4; // [sp+Ch] [bp-8h]@1

  v3 = 0;
  sub_1004DB30(a1, &v4);
  v1 = sub_1004D400((int)&v4);
  if ( v1 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_1004DE90(v1, &v3);
    result = v3;
  }
  return result;
}

//----- (1004DFC0) --------------------------------------------------------
char __cdecl sub_1004DFC0(unsigned int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  int v4; // ebp@1
  int v5; // ST0C_4@1
  signed int v6; // eax@1
  int v7; // edi@2
  signed __int16 v8; // ax@5
  int v9; // ecx@7
  unsigned int v10; // ecx@7
  unsigned __int8 v11; // dl@7
  char v12; // dl@7
  char v14; // [sp+10h] [bp-8h]@1

  v3 = a3;
  v4 = a3 + 8;
  v5 = a3 + 8;
  *(_DWORD *)a3 = 0xFFFF;
  *(_DWORD *)(v3 + 4) = 0;
  *(_BYTE *)(v3 + 22) = 0;
  *(_BYTE *)(v3 + 21) = 0;
  sub_100649E0(v5, "----------", 11);
  *(_BYTE *)(v3 + 19) = 0;
  *(_BYTE *)(v3 + 20) = 0;
  *(_BYTE *)(v3 + 23) = 0;
  *(_BYTE *)(v3 + 24) = 0;
  sub_1004DB30(a1, &v14);
  v6 = sub_1004DCE0((int)&v14, a2);
  if ( v6 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(signed int, signed int, unsigned int *))dword_1031F1D4)(v6, 4, &a3);
    v7 = (a3 >> 12) & 3;
    if ( (v7 || !((unsigned __int16)(a3 & 0xFFF) % 5)) && (_WORD)v7 != 2 )
      v8 = 0;
    else
      v8 = 5;
    v9 = 25 * ((BYTE2(a3) & 0x3F) + 256);
    *(_DWORD *)v3 = (unsigned __int16)v8 + 10 * ((a3 & 0xFFF) + 10800);
    sub_100649E0(v4, (_BYTE *)(dword_1031FB10 + v9), 11);
    LOBYTE(v6) = BYTE2(a3);
    v10 = a3;
    *(_DWORD *)(v3 + 4) = BYTE2(a3) & 0x3F;
    v11 = v6;
    *(_BYTE *)(v3 + 22) = ((unsigned __int8)v6 >> 6) & 1;
    LOBYTE(v6) = BYTE3(a3);
    *(_BYTE *)(v3 + 20) = v11 >> 7;
    *(_BYTE *)(v3 + 19) = (v10 >> 14) & 1;
    LOBYTE(v10) = v6 & 7;
    v12 = ((unsigned __int8)v6 >> 3) & 7;
    LOBYTE(v6) = ((unsigned __int8)v6 >> 6) & 1;
    *(_BYTE *)(v3 + 23) = v10;
    *(_BYTE *)(v3 + 24) = v12;
    *(_BYTE *)(v3 + 21) = v6;
  }
  return v6;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004E100) --------------------------------------------------------
char __cdecl sub_1004E100(unsigned int a1, char a2, int a3)
{
  unsigned int *v3; // ebx@1
  __int64 v4; // ST04_8@1
  int v5; // eax@1
  signed int v6; // edx@5
  unsigned __int8 v7; // al@5
  unsigned __int8 v8; // al@8
  unsigned __int16 v9; // si@8
  unsigned int v10; // edx@9
  bool v11; // zf@9
  char v12; // ah@10
  char v13; // cl@10
  char v14; // al@10
  unsigned int v15; // eax@11
  char v16; // dl@12
  double v17; // st6@12
  int v19; // [sp+Ch] [bp-44h]@2
  int v20; // [sp+10h] [bp-40h]@1
  unsigned int v21; // [sp+14h] [bp-3Ch]@1
  int v22; // [sp+18h] [bp-38h]@1
  int v23; // [sp+1Ch] [bp-34h]@12
  int v24; // [sp+20h] [bp-30h]@1
  char v25; // [sp+24h] [bp-2Ch]@3
  char v26; // [sp+2Ch] [bp-24h]@2
  int v27; // [sp+36h] [bp-1Ah]@2
  __int16 v28; // [sp+42h] [bp-Eh]@5

  *(float *)(a3 + 24) = 9.9999996e24;
  *(float *)(a3 + 28) = 9.9999996e24;
  *(_DWORD *)a3 = 1000;
  *(_BYTE *)(a3 + 10) = 95;
  *(_DWORD *)(a3 + 12) = 1000;
  *(_BYTE *)(a3 + 16) = 95;
  *(_DWORD *)(a3 + 20) = 1000;
  v3 = (unsigned int *)(a3 + 12);
  *(_BYTE *)(a3 + 32) = byte_1031FB0C;
  *(_DWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 44) = 0;
  *(_BYTE *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 33) = 4;
  *(_DWORD *)(a3 + 36) = 0xFFFF;
  *(_DWORD *)(a3 + 5) = 0;
  *(_BYTE *)(a3 + 9) = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  sub_100649E0(a3 + 64, word_100C2700, 11);
  v24 = a3 + 48;
  sub_100649E0(a3 + 48, word_100C2700, 16);
  LODWORD(v4) = a1;
  LOBYTE(v5) = sub_1004EB40(v4);
  if ( !(_BYTE)v5 )
  {
    v19 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v19, 29, &v26);
    if ( v27 & 0x8000 )
    {
      sub_1004D5A0((int)&v26, &v25);
      v5 = sub_1004DD60((int)&v25, a2);
      v19 = v5;
    }
    else
    {
      if ( !a2 )
      {
        v6 = (unsigned __int8)v28;
        v7 = HIBYTE(v28) & 0xF;
        *(_BYTE *)(a3 + 32) = HIBYTE(v28) & 0xF;
        v19 = v6;
        *(float *)(a3 + 24) = (double)v6 * 30.47999954223633;
        LOBYTE(v5) = sub_100649E0(a3 + 48, (_BYTE *)(dword_1031FB10 + 25 * (v7 + 384)), 16);
        return v5;
      }
      v5 = v19;
    }
    if ( v5 != 0xFFFFFF )
    {
      (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(v5, 12, &v20);
      v8 = sub_10073D80();
      v9 = *(_WORD *)((char *)&v21 + 1);
      if ( v8 == 2 )
      {
        v10 = ((unsigned int)BYTE3(v21) >> 1) & 3;
        v11 = (BYTE3(v21) & 1) == 0;
        *(_DWORD *)(a3 + 40) = BYTE1(v21) & 3;
        *(_DWORD *)(a3 + 44) = v10;
        if ( !v11 )
        {
          v12 = BYTE1(v22);
          v13 = BYTE3(v22);
          *(_BYTE *)(a3 + 5) = v22;
          v14 = BYTE2(v22);
          *(_BYTE *)(a3 + 4) = 1;
          *(_BYTE *)(a3 + 6) = v12;
          *(_BYTE *)(a3 + 7) = v14;
          *(_BYTE *)(a3 + 8) = v13;
          *(_BYTE *)(a3 + 9) = 0;
        }
      }
      else
      {
        v15 = ((unsigned int)*(unsigned __int16 *)((char *)&v21 + 1) >> 1) & 1;
        *(_DWORD *)(a3 + 40) = BYTE1(v21) & 1;
        *(_DWORD *)(a3 + 44) = v15;
      }
      v19 += (unsigned __int16)word_1031F9E4;
      v16 = BYTE2(v20);
      v23 = (unsigned __int16)v20;
      *(_BYTE *)(a3 + 33) = (BYTE2(v20) >> 4) & 7;
      v17 = (double)v23 * 0.3048000037670135;
      v23 = v9 >> 5;
      *(float *)(a3 + 24) = v17;
      *(_BYTE *)(a3 + 32) = v16 & 0xF;
      *(float *)(a3 + 28) = 0.3048000037670135 * (double)v23;
      if ( 0.0 == *(float *)(a3 + 28) )
        *(float *)(a3 + 28) = 9.9999996e24;
      v11 = *(_BYTE *)(a3 + 33) == 1;
      *(_DWORD *)(a3 + 20) = (unsigned int)*(unsigned __int16 *)((char *)&v20 + 3) >> 8;
      *(_DWORD *)(a3 + 36) = 0xFFFF;
      if ( v11 )
        *(_DWORD *)(a3 + 36) = sub_1004DDF0((int)&v25);
      sub_1004D4E0(a3 + 10, v3, (_BYTE *)(a3 + 16), (int)&v20, &v19, (int *)a3);
      *(_DWORD *)(a3 + 20) = sub_1004D1E0(*(_DWORD *)a3, *v3, *(_DWORD *)(a3 + 20));
      sub_100649E0(a3 + 64, (_BYTE *)(dword_1031FB10 + 25 * (*(_BYTE *)(a3 + 33) + 320)), 11);
      LOBYTE(v5) = sub_100649E0(v24, (_BYTE *)(dword_1031FB10 + 25 * (*(_BYTE *)(a3 + 32) + 384)), 16);
    }
  }
  return v5;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E4: using guessed type __int16 word_1031F9E4;
// 1031FB0C: using guessed type char byte_1031FB0C;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004E3E0) --------------------------------------------------------
char __cdecl sub_1004E3E0(unsigned int a1)
{
  __int64 v1; // ST00_8@1
  int v2; // esi@1
  char result; // al@3
  char v4; // [sp+Fh] [bp-9h]@1
  char v5; // [sp+10h] [bp-8h]@1

  v4 = 0;
  sub_1004DB30(a1, &v5);
  LODWORD(v1) = a1;
  v2 = sub_1004D4C0((int)&v5);
  if ( sub_1004EB40(v1) )
  {
    result = 0;
  }
  else if ( v2 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_1004D6A0(v2, &v4);
    result = v4;
  }
  return result;
}

//----- (1004E450) --------------------------------------------------------
int __cdecl sub_1004E450(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_1004DB30(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_1004DD60((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_1004DC00((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_1004DC70(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_1004DB80(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (1004E500) --------------------------------------------------------
int __cdecl sub_1004E500(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_1004E450(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v3, 12, &v13);
      v10 = (unsigned __int16)word_1031F9E4 + v3;
      sub_1004D4E0((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_100648D0(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v3, 9, &v13);
      sub_100743C0(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1031F1D4)(v3, 11, &v13);
      sub_100743C0(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1031F1D4)(v3, 15, &v13);
      sub_100743C0(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_10064B70(a2, 0);
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F9E4: using guessed type __int16 word_1031F9E4;

//----- (1004E690) --------------------------------------------------------
char __cdecl sub_1004E690(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_1004E450(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_1004EB10(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_1004DF30(a2, a1, v3);
  }
  return v2;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004E700) --------------------------------------------------------
__int16 __cdecl sub_1004E700(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_1004E450(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_1004D740(v2, a2, a1);
  return v2;
}

//----- (1004E740) --------------------------------------------------------
double __cdecl sub_1004E740(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_1004EB40(v3) == 3 )
  {
    v1 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_1004FA60(a1, (int)&v6);
    sub_10095920((int)&v6, (int)&v5);
    sub_10050CF0((int)&v5, &v4);
  }
  return v4;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004E7F0) --------------------------------------------------------
void __cdecl sub_1004E7F0(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // eax@2
  unsigned int v5; // ecx@4
  double v6; // st7@4
  unsigned int v7; // ecx@4
  unsigned __int8 v8; // al@4
  char v9; // cl@6
  unsigned __int8 v10; // al@9
  unsigned int v11; // eax@11
  unsigned int v12; // edi@14
  double v13; // st7@14
  int v14; // edx@14
  __int64 v15; // [sp-4h] [bp-34h]@0
  __int16 v16; // [sp+10h] [bp-20h]@2
  __int16 v17; // [sp+12h] [bp-1Eh]@14
  unsigned int v18; // [sp+14h] [bp-1Ch]@4
  unsigned int v19; // [sp+1Ah] [bp-16h]@2
  unsigned int v20; // [sp+1Eh] [bp-12h]@4
  unsigned int v21; // [sp+22h] [bp-Eh]@4
  unsigned __int8 v22; // [sp+26h] [bp-Ah]@4
  __int16 v23; // [sp+27h] [bp-9h]@13
  __int16 v24; // [sp+29h] [bp-7h]@12
  unsigned int v25; // [sp+2Bh] [bp-5h]@11
  int v26; // [sp+38h] [bp+8h]@5

  v2 = a2;
  v3 = a2 + 17;
  *(_DWORD *)v3 = *(_DWORD *)"______";
  *(_WORD *)(v3 + 4) = *(_WORD *)"__";
  *(double *)(a2 + 60) = 6.2831853071796;
  *(double *)(a2 + 68) = 6.2831853071796;
  LODWORD(v15) = a1;
  *(float *)(a2 + 32) = 6.2831855;
  *(_BYTE *)(v3 + 6) = a______[6];
  *(_DWORD *)(a2 + 40) = 0xFFFF;
  *(float *)(a2 + 36) = 9.9999996e24;
  *(_BYTE *)(a2 + 1) = 3;
  *(_BYTE *)a2 = 8;
  *(float *)(a2 + 28) = 9.8999998e24;
  *(_BYTE *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 5) = 0;
  *(double *)(a2 + 44) = 6.2831853071796;
  *(_BYTE *)(a2 + 3) = 0;
  *(double *)(a2 + 52) = 6.2831853071796;
  *(_DWORD *)(a2 + 24) = 0x3FFFF;
  *(_BYTE *)(a2 + 2) = 7;
  *(_WORD *)(a2 + 6) = 0;
  *(_WORD *)(a2 + 8) = 32;
  if ( sub_1004EB40(v15) == 3 )
  {
    sub_1004F840(a1, v3);
    sub_1004FA60(a1, a2 + 60);
    v4 = sub_1004EB10(a1);
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v4, 29, &v16);
    if ( v19 >> 24 != 255 )
      *(_DWORD *)(a2 + 40) = 50 * ((v19 >> 24) + 2160);
    v5 = v18;
    *(_BYTE *)(a2 + 1) = (v18 >> 27) & 3;
    *(_BYTE *)a2 = (v5 >> 29) & 7;
    *(_BYTE *)(a2 + 4) = (v20 >> 22) & 1;
    *(_BYTE *)(a2 + 5) = (v5 >> 26) & 1;
    strncpy((char *)(a2 + 8), (const char *)(dword_1031FB10 + 25 * ((v5 >> 29) + 768)), 8u);
    *(_BYTE *)(a2 + 16) = 0;
    v6 = sub_1004E740(a1);
    v7 = v21;
    *(float *)(a2 + 32) = v6;
    v8 = v22;
    *(float *)(a2 + 36) = (double)(signed int)((v7 & 0x7FFF) - 5000) * 0.3048000037670135;
    if ( (unsigned __int16)word_1031F3FC >= 0x17u )
    {
      HIWORD(v26) = v8 & 3;
      LOWORD(v26) = HIWORD(v21);
      *(_DWORD *)(v2 + 24) = v26;
    }
    v9 = (v7 >> 15) & 1;
    *(_BYTE *)(v2 + 3) = v9;
    if ( v9 )
    {
      *(_DWORD *)(v2 + 44) = *(_DWORD *)(v2 + 60);
      *(_DWORD *)(v2 + 48) = *(_DWORD *)(v2 + 64);
      *(_DWORD *)(v2 + 52) = *(_DWORD *)(v2 + 68);
      *(_DWORD *)(v2 + 56) = *(_DWORD *)(v2 + 72);
    }
    if ( (unsigned __int16)word_1031F3FC >= 0x1Du )
    {
      v10 = v8 >> 2;
      if ( v10 < 0x3Fu )
        *(float *)(v2 + 28) = (double)v10 * 0.1 * 1852.0;
      v11 = (v25 >> 3) & 0x3FF;
      *(_BYTE *)(v2 + 2) = v25 & 7;
      *(_WORD *)(v2 + 6) = v11;
      if ( v9 && (v24 || v23) )
      {
        v12 = (((v18 >> 8) & 0x1FF) + (v16 << 9)) << 7;
        v13 = sub_10074380((((unsigned int)(unsigned __int8)v18 + (v17 << 8)) << 7) - (v24 << 7), 24);
        v14 = v23;
        *(double *)(v2 + 44) = v13;
        *(double *)(v2 + 52) = sub_10074380(v12 - (v14 << 7), 24);
      }
    }
  }
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F3FC: using guessed type __int16 word_1031F3FC;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004EA60) --------------------------------------------------------
unsigned __int8 __cdecl sub_1004EA60(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_1031FB10 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004EA90) --------------------------------------------------------
int __cdecl sub_1004EA90(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_1031FB10 + 4 * a2 + 20812);
    v4 = byte_100D7F34[12 * a2];
    if ( sub_100746A0(v3, (unsigned __int8)byte_100D7F34[12 * a2]) )
      result = dword_1031F2C0[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_1031F2C4[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031F2C4: using guessed type __int16 word_1031F2C4[];
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004EB10) --------------------------------------------------------
int __cdecl sub_1004EB10(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_1004EA60(a1);
  return sub_1004EA90(a1, v1, 1);
}

//----- (1004EB40) --------------------------------------------------------
char __cdecl sub_1004EB40(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_1004EA60(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_100746E0(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (1004EBE0) --------------------------------------------------------
signed int __cdecl sub_1004EBE0(int a1)
{
  signed int v1; // ebp@2
  bool v2; // zf@2
  bool v3; // sf@2
  unsigned int *v4; // edi@3
  unsigned __int8 v5; // bl@6
  signed int i; // edi@12
  signed int result; // eax@18
  void *v8; // edi@19
  unsigned int v9; // ecx@19
  char v10; // [sp+7h] [bp-F1h]@6
  unsigned __int8 v11; // [sp+8h] [bp-F0h]@6
  __int16 v12; // [sp+Ch] [bp-ECh]@2
  int v13[31]; // [sp+10h] [bp-E8h]@3
  char v14; // [sp+8Ch] [bp-6Ch]@8
  char v15; // [sp+A1h] [bp-57h]@8
  char v16; // [sp+A8h] [bp-50h]@15
  char v17; // [sp+ADh] [bp-4Bh]@15

  if ( (unsigned __int8)sub_10072320() )
  {
    sub_1008C850(100, 60000);
    memcpy(&v12, (const void *)(dword_1031FB30 + 888), 0x80u);
    sub_1008C830(100);
    v1 = 0;
    v2 = v12 == 0;
    v3 = v12 < 0;
    *(_DWORD *)a1 = 0;
    if ( !v3 && !v2 )
    {
      v4 = (unsigned int *)v13;
      do
      {
        if ( v1 >= 25 || *(_DWORD *)a1 >= 25 )
          break;
        v5 = 0;
        v10 = sub_1004DF70(*v4);
        v11 = 0;
        if ( v10 )
        {
          do
          {
            if ( *(_DWORD *)a1 >= 25 )
              break;
            sub_1004DFC0(*v4, v11, (unsigned int)&v14);
            if ( v15 )
            {
              *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 32) = *v4;
              *(_BYTE *)((*(_DWORD *)a1)++ + a1 + 4) = v5;
            }
            v11 = ++v5;
          }
          while ( v5 < (unsigned __int8)v10 );
        }
        ++v1;
        ++v4;
      }
      while ( v1 < v12 );
    }
    sub_1008C850(100, 60000);
    memcpy(&v12, (const void *)(dword_1031FB30 + 632), 0x80u);
    sub_1008C830(100);
    for ( i = 0; i < v12; ++i )
    {
      if ( i >= 25 || *(_DWORD *)a1 >= 25 )
        break;
      sub_1004E7F0(v13[i], (int)&v16);
      if ( v17 )
      {
        *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 32) = v13[i];
        *(_BYTE *)((*(_DWORD *)a1)++ + a1 + 4) = 0;
      }
    }
    result = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 < 25 )
    {
      v8 = (void *)(a1 + 4 * result + 32);
      v9 = 25 - result;
      result = 0x3FFFF;
      memset32(v8, 0x3FFFF, v9);
    }
  }
  else
  {
    result = 0x3FFFF;
    *(_DWORD *)(a1 + 32) = 0x3FFFF;
    *(_DWORD *)(a1 + 36) = 0x3FFFF;
    *(_DWORD *)(a1 + 40) = 0x3FFFF;
    *(_DWORD *)(a1 + 44) = 0x3FFFF;
    *(_DWORD *)(a1 + 48) = 0x3FFFF;
    *(_DWORD *)(a1 + 52) = 0x3FFFF;
    *(_DWORD *)(a1 + 56) = 0x3FFFF;
    *(_DWORD *)(a1 + 60) = 0x3FFFF;
    *(_DWORD *)(a1 + 64) = 0x3FFFF;
    *(_DWORD *)(a1 + 68) = 0x3FFFF;
    *(_DWORD *)(a1 + 72) = 0x3FFFF;
    *(_DWORD *)(a1 + 76) = 0x3FFFF;
    *(_DWORD *)(a1 + 80) = 0x3FFFF;
    *(_DWORD *)(a1 + 84) = 0x3FFFF;
    *(_DWORD *)(a1 + 88) = 0x3FFFF;
    *(_DWORD *)(a1 + 92) = 0x3FFFF;
    *(_DWORD *)(a1 + 96) = 0x3FFFF;
    *(_DWORD *)(a1 + 100) = 0x3FFFF;
    *(_DWORD *)(a1 + 104) = 0x3FFFF;
    *(_DWORD *)(a1 + 108) = 0x3FFFF;
    *(_DWORD *)(a1 + 112) = 0x3FFFF;
    *(_DWORD *)(a1 + 116) = 0x3FFFF;
    *(_DWORD *)(a1 + 120) = 0x3FFFF;
    *(_DWORD *)(a1 + 124) = 0x3FFFF;
    *(_DWORD *)(a1 + 128) = 0x3FFFF;
  }
  return result;
}
// 1031FB30: using guessed type int dword_1031FB30;
// 1004EBE0: using guessed type int var_E8[31];

//----- (1004EDF0) --------------------------------------------------------
char __cdecl sub_1004EDF0(signed int a1, int a2, signed int a3)
{
  double v3; // st7@1
  int v4; // ebx@6
  signed int v5; // eax@6
  int v6; // ebp@6
  signed int i; // esi@7
  int v8; // ebx@9
  signed int v9; // edx@9
  signed int v10; // ecx@10
  int v11; // esi@11
  unsigned int v12; // edi@12
  unsigned int v13; // ebp@12
  __int16 v14; // dx@13
  __int16 v15; // dx@13
  float v17; // [sp+14h] [bp-34h]@1
  signed int v18; // [sp+14h] [bp-34h]@9
  int v19; // [sp+1Ch] [bp-2Ch]@8
  __int16 v20[2]; // [sp+20h] [bp-28h]@8
  float v21; // [sp+24h] [bp-24h]@1
  float v22; // [sp+28h] [bp-20h]@1
  int v23[7]; // [sp+2Ch] [bp-1Ch]@8
  char v24; // [sp+4Ch] [bp+4h]@10

  sub_1008C850(100, 60000);
  v21 = *(float *)(dword_1031FB30 + 1144);
  v22 = *(float *)(dword_1031FB30 + 1148);
  v17 = *(float *)(dword_1031FB30 + 4);
  sub_1008C830(100);
  v3 = v17;
  if ( (LODWORD(v17) & 0x7F800000) == 2139095040 || v3 > 1.0 )
  {
    v17 = 1.0;
  }
  else if ( v3 < 0.0000039196398 )
  {
    v17 = 0.0000039196398;
  }
  sub_10074850((int)&v21, (int)&unk_100D7F60);
  v4 = (unsigned __int16)(signed int)(v21 * 10430.37835047043);
  v5 = (signed int)(10430.37835047043 * v22);
  v6 = (unsigned __int16)v5;
  if ( a1 > 7 )
  {
    LOBYTE(v5) = sub_10051A40("..\\lib\\acl\\prx\\prx_intf_nrst_list.c", 855, 0, 0);
  }
  else
  {
    for ( i = 0; i < a1; ++i )
    {
      sub_1004F310(*(_WORD *)(a3 + 2 * i), v20, (__int16 *)&v19);
      v5 = sub_10050D10(v4, v6, v20[0], v19, v17);
      v23[i] = v5;
    }
    v8 = a2;
    v9 = a1;
    v18 = a1;
    do
    {
      v10 = 1;
      v24 = 0;
      if ( v9 > 1 )
      {
        v5 = a3;
        v11 = v8 - a3;
        do
        {
          v12 = v23[v10];
          v13 = *((_DWORD *)&v22 + v10);
          if ( v12 < v13 )
          {
            v14 = *(_WORD *)(v11 + v5);
            *(_WORD *)(v11 + v5) = *(_WORD *)(v8 + 2 * v10);
            *(_WORD *)(a2 + 2 * v10) = v14;
            v15 = *(_WORD *)v5;
            *(_WORD *)v5 = *(_WORD *)(v5 + 2);
            v8 = a2;
            *(_WORD *)(v5 + 2) = v15;
            v9 = v18;
            v24 = 1;
            *((_DWORD *)&v22 + v10) = v12;
            v23[v10] = v13;
          }
          ++v10;
          v5 += 2;
        }
        while ( v10 < v9 );
      }
      v18 = --v9;
    }
    while ( v24 );
  }
  return v5;
}
// 1031FB30: using guessed type int dword_1031FB30;
// 1004EDF0: using guessed type int var_1C[7];

//----- (1004EFB0) --------------------------------------------------------
char __cdecl sub_1004EFB0(_DWORD *a1)
{
  char *v1; // eax@2
  signed int v2; // edx@2
  signed int v3; // ecx@2
  bool v4; // zf@2
  bool v5; // sf@2
  __int16 v6; // bx@5
  int v7; // edx@6
  int v8; // ecx@7
  signed int v9; // ecx@10
  __int16 v11; // [sp+4h] [bp-24h]@2
  __int16 v12[7]; // [sp+8h] [bp-20h]@2
  char v13; // [sp+16h] [bp-12h]@2

  if ( (unsigned __int8)sub_10072320() )
  {
    sub_1008C850(100, 60000);
    memcpy(&v11, (const void *)(dword_1031FB30 + 16), 0x20u);
    sub_1008C830(100);
    LOBYTE(v1) = sub_1004EDF0(v11, (int)v12, (signed int)&v13);
    v2 = v11;
    v3 = 0;
    v4 = v11 == 0;
    v5 = v11 < 0;
    *a1 = 0;
    if ( !v5 && !v4 )
    {
      v1 = (char *)a1 + 14;
      do
      {
        if ( v3 >= 5 )
          break;
        v6 = v12[v3];
        ++*a1;
        *((_WORD *)v1 - 5) = v6;
        *(_WORD *)v1 = *(_WORD *)&v1[(char *)v12 - (char *)a1];
        ++v3;
        v1 += 2;
      }
      while ( v3 < v2 );
    }
    v7 = *a1;
    if ( *a1 < 5 )
    {
      v1 = (char *)a1 + 2 * v7 + 14;
      v8 = 5 - v7;
      do
      {
        *((_WORD *)v1 - 5) = -1;
        *(_WORD *)v1 = -1;
        v1 += 2;
        --v8;
      }
      while ( v8 );
    }
  }
  else
  {
    v1 = (char *)a1 + 14;
    v9 = 5;
    do
    {
      *((_WORD *)v1 - 5) = -1;
      *(_WORD *)v1 = -1;
      v1 += 2;
      --v9;
    }
    while ( v9 );
  }
  return (unsigned int)v1;
}
// 1031FB30: using guessed type int dword_1031FB30;
// 1004EFB0: using guessed type __int16 var_20[7];

//----- (1004F0C0) --------------------------------------------------------
signed int __usercall sub_1004F0C0@<eax>(signed int result@<eax>, char a2)
{
  char v2; // bl@1
  signed int v3; // esi@1
  int v4; // [sp+8h] [bp-4h]@2

  v2 = 0;
  v3 = result;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      (*(void (__cdecl **)(signed int, signed int, int *))dword_1031F1D4)(v3, 2, &v4);
      if ( !(v4 & 0x8000) )
        break;
      ++v2;
      v3 += (unsigned __int16)word_1031F480;
      if ( v4 & 0x4000 )
        v3 += (unsigned __int16)word_1031FA6A;
      if ( v2 >= a2 )
        return v3;
    }
    result = 0xFFFFFF;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F480: using guessed type __int16 word_1031F480;
// 1031FA6A: using guessed type __int16 word_1031FA6A;

//----- (1004F130) --------------------------------------------------------
int __fastcall sub_1004F130(unsigned __int16 a1)
{
  return dword_1031F458 + a1 * (unsigned __int16)word_1031F45C;
}
// 1031F458: using guessed type int dword_1031F458;
// 1031F45C: using guessed type __int16 word_1031F45C;

//----- (1004F150) --------------------------------------------------------
int __fastcall sub_1004F150(unsigned __int16 a1)
{
  return dword_1031F470 + a1 * (unsigned __int16)word_1031F474;
}
// 1031F470: using guessed type int dword_1031F470;
// 1031F474: using guessed type __int16 word_1031F474;

//----- (1004F170) --------------------------------------------------------
signed int __usercall sub_1004F170@<eax>(unsigned __int16 a1@<ax>)
{
  unsigned __int16 v1; // bx@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v5; // [sp+Ch] [bp-4h]@3

  v1 = a1;
  v2 = a1;
  v3 = 0xFFFFFF;
  if ( sub_100746A0(a1, 0x25u) )
  {
    v3 = dword_1031F47C;
    if ( v1 )
    {
      do
      {
        (*(void (__cdecl **)(signed int, signed int, int *))dword_1031F1D4)(v3, 2, &v5);
        v3 += (unsigned __int16)word_1031F480;
        if ( v5 & 0x4000 )
          v3 += (unsigned __int16)word_1031FA6A;
        --v2;
      }
      while ( v2 );
    }
  }
  return v3;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F47C: using guessed type int dword_1031F47C;
// 1031F480: using guessed type __int16 word_1031F480;
// 1031FA6A: using guessed type __int16 word_1031FA6A;

//----- (1004F1E0) --------------------------------------------------------
char __usercall sub_1004F1E0@<al>(int a1@<ecx>, int a2@<esi>, _BYTE *a3)
{
  char result; // al@1
  int v4; // eax@2
  int v5; // [sp+0h] [bp-30h]@2
  char v6; // [sp+4h] [bp-2Ch]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+2Ch] [bp-4h]@2

  (*(void (__cdecl **)(int, char *))(dword_1031F1C4 + 4))(a1, &v6);
  result = 0;
  if ( v7 != 0x7FFFF )
  {
    sub_10074460(v7 + dword_1031F2F0, v8, 30, &v5, a2);
    v4 = v5;
    *a3 = v5;
    *(_BYTE *)(v4 + a2) = 0;
    result = 1;
  }
  return result;
}
// 1031F1C4: using guessed type int dword_1031F1C4;
// 1031F2F0: using guessed type int dword_1031F2F0;

//----- (1004F240) --------------------------------------------------------
int __usercall sub_1004F240@<eax>(int a1@<eax>, _BYTE *a2@<edi>)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // [sp+4h] [bp-4h]@2

  v2 = a1;
  *a2 = 0;
  do
  {
    ++*a2;
    (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(v2, 2, &v4);
    result = (unsigned __int16)word_1031F480;
    v2 += (unsigned __int16)word_1031F480;
    if ( v4 & 0x4000 )
      v2 += (unsigned __int16)word_1031FA6A;
  }
  while ( v4 & 0x8000 );
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F480: using guessed type __int16 word_1031F480;
// 1031FA6A: using guessed type __int16 word_1031FA6A;

//----- (1004F2A0) --------------------------------------------------------
char __cdecl sub_1004F2A0(unsigned __int16 a1)
{
  int v1; // eax@2
  int v2; // eax@2
  char result; // al@3
  char v4; // [sp+Bh] [bp-9h]@1
  char v5; // [sp+Ch] [bp-8h]@2
  int v6; // [sp+10h] [bp-4h]@2

  v4 = 0;
  if ( sub_100746A0(a1, 0x24u)
    && (v1 = sub_1004F150(a1),
        (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v1, 6, &v5),
        v2 = sub_1004F170(v6 & 0x7FFF),
        v2 != 0xFFFFFF) )
  {
    sub_1004F240(v2, &v4);
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004F310) --------------------------------------------------------
char __cdecl sub_1004F310(unsigned __int16 a1, _WORD *a2, __int16 *a3)
{
  char result; // al@1
  int v4; // eax@2
  __int16 v5; // dx@2
  __int16 v6; // [sp+Ch] [bp-8h]@2
  __int16 v7; // [sp+Eh] [bp-6h]@2

  *a2 = 0x7FFF;
  *a3 = 0x7FFF;
  result = sub_100746A0(a1, 0x24u);
  if ( result )
  {
    v4 = sub_1004F150(a1);
    result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v4, 6, &v6);
    v5 = v6;
    *a2 = v7;
    *a3 = v5;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004F380) --------------------------------------------------------
char __cdecl sub_1004F380(unsigned __int16 a1, char a2, _DWORD *a3)
{
  unsigned __int16 v3; // bp@1
  _DWORD *v4; // esi@1
  unsigned int v5; // ST08_4@1
  signed int v6; // edi@1
  int v7; // eax@2
  signed int v8; // eax@2
  int v9; // eax@3
  int v10; // edi@4
  bool v11; // zf@4
  char v13; // [sp+10h] [bp-8h]@2
  int v14; // [sp+14h] [bp-4h]@2

  v3 = a1;
  v4 = a3;
  v5 = a1;
  *a3 = 0xFFFF;
  *((_BYTE *)v4 + 5) = 0;
  *((_BYTE *)v4 + 4) = 0;
  v6 = 0xFFFFFF;
  if ( sub_100746A0(v5, 0x24u) )
  {
    v7 = sub_1004F150(v3);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v7, 6, &v13);
    v8 = sub_1004F170(v14 & 0x7FFF);
    v6 = sub_1004F0C0(v8, a2);
  }
  LOBYTE(v9) = sub_10074710(v6, 0x25u);
  if ( (_BYTE)v9 )
  {
    (*(void (__cdecl **)(signed int, signed int, unsigned __int16 *))dword_1031F1D4)(v6, 2, &a1);
    v10 = (unsigned __int16)word_1031F480 + v6;
    v9 = 5 * (a1 & 0xFFF) + 54000;
    v11 = (a1 & 0x4000) == 0;
    *v4 = ((a1 & 0xFFF) % 5 != 0 ? 5 : 0) + 2 * v9;
    if ( v11 )
    {
      *((_BYTE *)v4 + 5) = 0;
      *((_BYTE *)v4 + 4) = 0;
    }
    else
    {
      (*(void (__cdecl **)(int, signed int, _DWORD **))dword_1031F1D4)(v10, 1, &a3);
      LOBYTE(v9) = ((unsigned __int8)a3 >> 1) & 3;
      *((_BYTE *)v4 + 5) = (unsigned __int8)a3 & 1;
      *((_BYTE *)v4 + 4) = v9;
    }
  }
  return v9;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F480: using guessed type __int16 word_1031F480;

//----- (1004F490) --------------------------------------------------------
char __cdecl sub_1004F490(unsigned __int16 a1, int a2, _BYTE *a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( !sub_100746A0(a1, 0x22u) || (v3 = sub_1004F130(a1), (result = sub_1004F1E0(v3, a2, a3)) == 0) )
  {
    *a3 = 0;
    result = 95;
    *(_DWORD *)a2 = 1600085855;
    *(_DWORD *)(a2 + 4) = 1600085855;
    *(_DWORD *)(a2 + 8) = 1600085855;
    *(_DWORD *)(a2 + 12) = 1600085855;
    *(_DWORD *)(a2 + 16) = 1600085855;
    *(_DWORD *)(a2 + 20) = 1600085855;
    *(_DWORD *)(a2 + 24) = 1600085855;
    *(_WORD *)(a2 + 28) = 24415;
    *(_BYTE *)(a2 + 30) = 0;
  }
  return result;
}

//----- (1004F4F0) --------------------------------------------------------
int __cdecl sub_1004F4F0(char a1, int a2, float a3, char a4, int a5)
{
  int v5; // edx@1
  int v6; // eax@1
  int result; // eax@1
  int v8; // [sp+0h] [bp-48h]@1
  int v9; // [sp+4h] [bp-44h]@1
  int v10; // [sp+8h] [bp-40h]@1
  __int16 *v11; // [sp+Ch] [bp-3Ch]@1
  int v12; // [sp+10h] [bp-38h]@1
  int *v13; // [sp+14h] [bp-34h]@1
  int v14; // [sp+18h] [bp-30h]@1
  int v15; // [sp+1Ch] [bp-2Ch]@1
  __int16 v16; // [sp+20h] [bp-28h]@1
  char v17; // [sp+24h] [bp-24h]@1
  int v18; // [sp+28h] [bp-20h]@1
  int v19; // [sp+2Ch] [bp-1Ch]@1
  float v20; // [sp+30h] [bp-18h]@1
  char v21; // [sp+34h] [bp-14h]@1

  v5 = *(_DWORD *)a2;
  v20 = a3;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v17 = a1;
  v6 = *(_DWORD *)(a2 + 4);
  v21 = a4;
  v18 = v5;
  v19 = v6;
  v16 = -32765;
  v15 = 4;
  v11 = &v16;
  v12 = 36;
  v13 = &v8;
  v14 = 400;
  v8 = a5;
  v9 = 104;
  result = sub_1008C8B0(43, (int)&v11);
  if ( result || v10 || v9 != 104 )
    *(_DWORD *)a5 = 0;
  return result;
}

//----- (1004F5C0) --------------------------------------------------------
char __cdecl sub_1004F5C0(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_1031F1D4)(
                          a2 + dword_100D7F38[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_100D7F98[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_100D7F99[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_100D7F9A[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_100D7F9B[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_100D7F9C[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100D7F38: using guessed type int dword_100D7F38[];
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (1004F640) --------------------------------------------------------
char __usercall sub_1004F640@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(
                          dword_1031F2C0[3 * (unsigned __int8)byte_100D7F30[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_1031FB10 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031FB10: using guessed type int dword_1031FB10;
// 1004F640: using guessed type char var_1EA[490];

//----- (1004F6E0) --------------------------------------------------------
char __usercall sub_1004F6E0@<al>(int a1@<ecx>, _BYTE *a2@<edi>, int a3@<esi>, char a4)
{
  unsigned int v4; // ecx@5
  int v5; // eax@8
  int v7; // [sp+8h] [bp-24h]@8
  char v8; // [sp+Ch] [bp-20h]@1
  unsigned int v9; // [sp+16h] [bp-16h]@5

  *a2 = 0;
  *(_DWORD *)a3 = 538976288;
  *(_DWORD *)(a3 + 4) = 538976288;
  *(_DWORD *)(a3 + 8) = 538976288;
  *(_DWORD *)(a3 + 12) = 538976288;
  *(_DWORD *)(a3 + 16) = 538976288;
  *(_DWORD *)(a3 + 20) = 538976288;
  *(_DWORD *)(a3 + 24) = 538976288;
  *(_WORD *)(a3 + 28) = 8224;
  *(_BYTE *)(a3 + 30) = 0;
  if ( !(unsigned __int8)(*(int (__cdecl **)(int, signed int, char *))dword_1031F1D4)(a1, 29, &v8) )
    return 0;
  if ( a4 && a4 != 2 )
  {
    if ( a4 != 3 )
      return 0;
    v4 = v9;
  }
  else
  {
    v4 = *(unsigned int *)((char *)&v9 + 2);
  }
  if ( (v4 & 0x7FFFF) != 0x7FFFF )
  {
    sub_10074460((v4 & 0x7FFFF) + dword_1031F2F0, (v4 >> 19) & 7, 30, &v7, a3);
    v5 = v7;
    *a2 = v7;
    *(_BYTE *)(v5 + a3) = 0;
    return 1;
  }
  return 0;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2F0: using guessed type int dword_1031F2F0;

//----- (1004F790) --------------------------------------------------------
int __fastcall sub_1004F790(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (1004F7C0) --------------------------------------------------------
char __cdecl sub_1004F7C0(unsigned int a1, int a2, _BYTE *a3)
{
  int v3; // eax@4
  char result; // al@4
  unsigned __int8 v5; // [sp+Ch] [bp-4h]@1

  v5 = sub_1004EA60(a1);
  if ( v5 >= 4u
    || a1 < 0x3E8
    || a1 >= *(_DWORD *)(dword_1031FB10 + 20828)
    || (v3 = sub_1004EA90(a1, v5, 1), (result = sub_1004F6E0(v3, a3, a2, v5)) == 0) )
  {
    *a3 = 0;
    result = 95;
    *(_DWORD *)a2 = 1600085855;
    *(_DWORD *)(a2 + 4) = 1600085855;
    *(_DWORD *)(a2 + 8) = 1600085855;
    *(_DWORD *)(a2 + 12) = 1600085855;
    *(_DWORD *)(a2 + 16) = 1600085855;
    *(_DWORD *)(a2 + 20) = 1600085855;
    *(_DWORD *)(a2 + 24) = 1600085855;
    *(_WORD *)(a2 + 28) = 24415;
    *(_BYTE *)(a2 + 30) = 0;
  }
  return result;
}
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004F840) --------------------------------------------------------
void __cdecl sub_1004F840(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1031FB10 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_10050D50(a1, a2);
      else
        sub_1004E500(a1, a2);
    }
    else
    {
      v2 = sub_1004EA60(a1);
      v3 = sub_1004EA90(a1, v2, 1);
      v4 = sub_1004F640(a1, v2);
      if ( sub_1004F5C0(v2, v3, v4, (int)&v5) )
      {
        sub_100743C0(&v6, 6, a2);
        sub_10064B70(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = *(_DWORD *)"______";
        *(_WORD *)(a2 + 4) = *(_WORD *)"__";
        *(_BYTE *)(a2 + 6) = a______[6];
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)"______";
    *(_WORD *)(a2 + 4) = *(_WORD *)"__";
    *(_BYTE *)(a2 + 6) = a______[6];
  }
}
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004F980) --------------------------------------------------------
char __cdecl sub_1004F980(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1031FB10 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_10050F30(a1, a2);
      else
        result = sub_1004E700(a1, a2);
    }
    else
    {
      v3 = sub_1004EA60(a1);
      v4 = sub_1004EA90(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v4, 7, &v5);
      result = sub_1004F790((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004FA30) --------------------------------------------------------
void __usercall sub_1004FA30(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_1004F790(a1, (int)&v2);
  *(double *)a2 = sub_10074380(v2, 24);
  *(double *)(a2 + 8) = sub_10074380(v3, 24);
}

//----- (1004FA60) --------------------------------------------------------
char __cdecl sub_1004FA60(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1031FB10 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_10050F30(a1, (int)&v7);
        if ( v6 )
        {
          sub_100748F0(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_1004E690(a1, a2);
      }
    }
    else
    {
      v3 = sub_1004EA60(a1);
      v4 = sub_1004EA90(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_1004FA30((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (1004FB80) --------------------------------------------------------
char __cdecl sub_1004FB80(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char result; // al@1

  result = 0;
  if ( a2 != 0x3FFFF && a1 != -1 && a1 >= a3 && a1 <= a4 )
    result = 1;
  return result;
}

//----- (1004FBB0) --------------------------------------------------------
char __usercall sub_1004FBB0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6)
{
  signed int v6; // esi@3
  int v7; // ebx@6
  int v8; // edi@6
  signed int v9; // esi@7
  __int64 v11; // [sp-Ch] [bp-14h]@6
  __int64 v12; // [sp-4h] [bp-Ch]@0

  *a5 = 0x3FFFF;
  *a6 = -1;
  if ( (_BYTE)a1 == -1 || a2 )
  {
    HIDWORD(v11) = a3;
    v7 = a2;
    v8 = (unsigned __int8)a1;
    if ( a2 >= (signed int)(unsigned __int8)a1 )
    {
      while ( 1 )
      {
        a1 = sub_10051020(a4, v7);
        v9 = a1;
        if ( a1 != 0x3FFFF )
        {
          LODWORD(v11) = a1;
          LOBYTE(a1) = sub_1004EB40(v11);
          if ( !(_BYTE)a1 )
            break;
        }
        if ( --v7 < v8 )
          return a1;
      }
      LOBYTE(a1) = (_BYTE)a5;
      *a6 = v7;
      *a5 = v9;
    }
  }
  else
  {
    a1 = sub_10051020(a4, 0);
    v6 = a1;
    if ( a1 != 0x3FFFF )
    {
      LODWORD(v12) = a1;
      LOBYTE(a1) = sub_1004EB40(v12);
      if ( !(_BYTE)a1 )
      {
        LOBYTE(a1) = (_BYTE)a6;
        *a6 = 0;
        *a5 = v6;
      }
    }
  }
  return a1;
}
// 1004FBB0: could not find valid save-restore pair for edi

//----- (1004FC50) --------------------------------------------------------
char __usercall sub_1004FC50@<al>(int a1@<ebx>, _BYTE *a2, int *a3)
{
  int v3; // ebp@1
  signed int v4; // esi@1
  int *v5; // esi@4
  _BYTE *v6; // edi@4
  signed int v7; // eax@4
  char v8; // bl@5
  unsigned __int8 v9; // dl@15
  char v10; // cl@20
  unsigned __int8 v11; // cl@26
  unsigned __int8 v13; // [sp-10h] [bp-38h]@23
  signed int *v14; // [sp-Ch] [bp-34h]@23
  __int64 v15; // [sp-8h] [bp-30h]@5
  _BYTE *v16; // [sp-8h] [bp-30h]@23
  char v17; // [sp+Ch] [bp-1Ch]@1
  char v18; // [sp+Dh] [bp-1Bh]@1
  char v19; // [sp+Eh] [bp-1Ah]@2
  char v20; // [sp+Fh] [bp-19h]@15
  int v21; // [sp+10h] [bp-18h]@1
  unsigned __int8 v22; // [sp+14h] [bp-14h]@1
  int v23; // [sp+18h] [bp-10h]@5
  unsigned __int8 v24; // [sp+1Ch] [bp-Ch]@1
  unsigned __int8 v25; // [sp+20h] [bp-8h]@1
  unsigned __int8 v26; // [sp+24h] [bp-4h]@1
  char v27; // [sp+2Ch] [bp+4h]@5
  unsigned __int8 v28; // [sp+30h] [bp+8h]@5
  char v29; // [sp+30h] [bp+8h]@15

  v18 = sub_10050FE0(0);
  v25 = sub_10051200(0);
  v26 = sub_10051280(0);
  v3 = sub_10050FA0(0);
  v24 = sub_10051240(0);
  v22 = sub_100512C0(0);
  v4 = sub_10051080(0);
  v21 = v4;
  v17 = sub_10051300(0);
  if ( v3 != 0x3FFFF || (v19 = 0, v4 != 0x3FFFF) )
    v19 = 1;
  v5 = a3;
  v6 = a2;
  *a3 = 0x3FFFF;
  *a2 = -1;
  LOBYTE(v7) = sub_10072360();
  if ( (_BYTE)v7 )
  {
    HIDWORD(v15) = a1;
    sub_10074930();
    v8 = *(_BYTE *)(dword_1031FB2C + 812);
    v27 = *(_BYTE *)(dword_1031FB2C + 816);
    v23 = *(_DWORD *)(dword_1031FB2C + 840);
    v28 = v8;
    if ( (unsigned __int8)v8 >= 0x66u && v8 != -1 )
    {
      v8 = -1;
      v28 = -1;
    }
    if ( ((unsigned __int8)v8 > (unsigned __int8)v18
       || *(_BYTE *)(dword_1031FB20 + 4) != v18
       || *(_DWORD *)(dword_1031FB20 + 264) != v3
       || *(_DWORD *)(dword_1031FB20 + 604) != v21)
      && *(_BYTE *)(dword_1031FB2C + 816) != 3 )
    {
      v8 = -1;
      v28 = -1;
    }
    LOBYTE(v7) = sub_10074920();
    if ( v8 != -1 )
    {
      v29 = sub_1004FB80(v28, v3, v25, v26);
      LOBYTE(v7) = sub_1004FB80(v9, v21, v24, v22);
      v20 = v7;
      if ( v27 == 3 )
      {
        LODWORD(v15) = v23;
        if ( !sub_1004EB40(v15) )
        {
          LOBYTE(v7) = v23;
          *v5 = v23;
          *v6 = v8;
          return v7;
        }
        LOBYTE(v7) = v20;
LABEL_29:
        if ( v29 == 1 )
        {
          LOBYTE(v7) = v17;
          if ( (unsigned __int8)v8 > (unsigned __int8)v17 )
          {
            v11 = v26;
LABEL_37:
            v16 = v6;
            v14 = v5;
            LOBYTE(v7) = v8;
            v13 = 0;
            goto LABEL_38;
          }
          *v5 = v3;
          *v6 = v17;
          goto LABEL_39;
        }
LABEL_33:
        if ( (_BYTE)v7 == 1 )
        {
          if ( v3 == 0x3FFFF )
          {
            v11 = v22;
            goto LABEL_37;
          }
          *v5 = v3;
          *v6 = v17;
        }
LABEL_39:
        if ( v27 != 3 && *v5 == 0x3FFFF && *v6 == -1 )
        {
          if ( v3 == 0x3FFFF )
          {
            LOBYTE(v7) = v21;
            if ( v21 != 0x3FFFF )
            {
              *v5 = v21;
              LOBYTE(v7) = v22;
              *v6 = v22;
            }
          }
          else
          {
            *v5 = v3;
            *v6 = v17;
          }
        }
        return v7;
      }
      if ( v27 != 2 && v27 != 1 )
        goto LABEL_29;
      v10 = v18;
      if ( !v18 || v29 )
        goto LABEL_29;
      if ( (_BYTE)v7 )
        goto LABEL_33;
      v16 = v6;
      v14 = v5;
      LOBYTE(v7) = v8;
      v13 = 0;
      if ( v19 == 1 )
      {
        if ( v21 == 0x3FFFF )
        {
          v11 = v25 - 1;
          goto LABEL_38;
        }
        v10 = v24;
      }
      v11 = v10 - 1;
LABEL_38:
      LOBYTE(v7) = sub_1004FBB0(v7, v11, (int)v6, v13, v14, v16);
      goto LABEL_39;
    }
  }
  return v7;
}
// 1004FC50: could not find valid save-restore pair for ebx
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1004FEA0) --------------------------------------------------------
signed int __cdecl sub_1004FEA0(unsigned __int8 a1)
{
  signed int v1; // esi@2
  int v2; // eax@3
  signed int result; // eax@5

  if ( (unsigned __int8)sub_10072320() )
  {
    v1 = 0x3FFFF;
    sub_1008C850(100, 60000);
    if ( a1 != 9 )
    {
      v2 = dword_1031FB30 + (a1 << 7);
      if ( *(_WORD *)(v2 + 248) )
        v1 = *(_DWORD *)(v2 + 252);
    }
    sub_1008C830(100);
    result = v1;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}
// 1031FB30: using guessed type int dword_1031FB30;

//----- (1004FF00) --------------------------------------------------------
int __cdecl sub_1004FF00(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_101CAB50[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_101CAB28[(unsigned __int8)byte_100D8558[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_101CAB50[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_101CAB28[(unsigned __int8)byte_100D8558[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 1008BA14: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 1008BA1A: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (1004FFD0) --------------------------------------------------------
int sub_1004FFD0()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_101CAB50, 127, 0x100u);
  v0 = 0;
  v1 = &unk_100D851D;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_101CAB28[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_101CAB50[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_100D8556 );
  return result;
}
// 1008D0D0: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 101CAB28: using guessed type __int16 word_101CAB28[];

//----- (10050030) --------------------------------------------------------
void sub_10050030()
{
  dword_1031F1C0 = -15;
}
// 1031F1C0: using guessed type int dword_1031F1C0;

//----- (10050040) --------------------------------------------------------
signed int sub_10050040()
{
  return sub_1008D490((int)&off_100D8588);
}
// 100D8588: using guessed type char *off_100D8588;

//----- (10050050) --------------------------------------------------------
void sub_10050050()
{
  dword_101CAC50 = -15;
}
// 101CAC50: using guessed type int dword_101CAC50;

//----- (10050060) --------------------------------------------------------
unsigned int __cdecl sub_10050060(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (100500D0) --------------------------------------------------------
int __cdecl sub_100500D0(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_1008F880(a2, &a1, a3);
  v15 = sub_1008F880(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_1008F880(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_1008F880(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_1008F880(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_1008F880(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_1008F880(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_1008F880(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        strcpy(v49 + 1, v49);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (10050660) --------------------------------------------------------
char *__cdecl sub_10050660(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_1031F2C0[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_1031F2C8];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_1031F2C4];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_1031F2C8];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_1031F1D4)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031F2C4: using guessed type __int16 word_1031F2C4[];
// 1031F2C8: using guessed type int dword_1031F2C8[];
// 10050660: using guessed type char var_20[28];

//----- (10050720) --------------------------------------------------------
signed int sub_10050720()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_1031F1D8 = 0;
  dword_1031F1DC = 0xFFFFFF;
  byte_1031F1C8 = 0;
  dword_1031F1CC = 0xFFFFFF;
  return result;
}
// 1031F1C8: using guessed type char byte_1031F1C8;
// 1031F1CC: using guessed type int dword_1031F1CC;
// 1031F1D8: using guessed type char byte_1031F1D8;
// 1031F1DC: using guessed type int dword_1031F1DC;

//----- (10050740) --------------------------------------------------------
int sub_10050740()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_1031F1D4 + 16))();
  byte_1031F1D0 = (_BYTE)result == 0;
  return result;
}
// 1031F1D0: using guessed type char byte_1031F1D0;
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (100507A0) --------------------------------------------------------
int sub_100507A0()
{
  int result; // eax@1

  *(_DWORD *)(dword_1031FB10 + 20812) = 1000;
  *(_DWORD *)(dword_1031FB10 + 20816) = dword_1031F328 + *(_DWORD *)(dword_1031FB10 + 20812);
  *(_DWORD *)(dword_1031FB10 + 20820) = dword_1031F388 + *(_DWORD *)(dword_1031FB10 + 20816);
  *(_DWORD *)(dword_1031FB10 + 20824) = dword_1031F3B8 + *(_DWORD *)(dword_1031FB10 + 20820);
  result = dword_1031FB10;
  *(_DWORD *)(dword_1031FB10 + 20828) = dword_1031F400 + *(_DWORD *)(dword_1031FB10 + 20824);
  return result;
}
// 1031F328: using guessed type int dword_1031F328;
// 1031F388: using guessed type int dword_1031F388;
// 1031F3B8: using guessed type int dword_1031F3B8;
// 1031F400: using guessed type int dword_1031F400;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (10050810) --------------------------------------------------------
char *sub_10050810()
{
  sub_10050660(0x40u);
  sub_10050660(0x39u);
  sub_10050660(0x33u);
  sub_10050660(0x31u);
  sub_10050660(0x32u);
  sub_10050660(0x4Eu);
  sub_10050660(0x4Fu);
  sub_10050660(0x3Du);
  sub_10050660(0x3Eu);
  sub_10050660(0x45u);
  return sub_10050660(0x38u);
}
// 1031FB10: using guessed type int dword_1031FB10;

//----- (100508E0) --------------------------------------------------------
int __cdecl sub_100508E0(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_101CAC58, a1, 0x1Cu);
  dword_1031F1D4 = (int)dword_101CAC58;
  dword_1031FB10 = (int)&unk_101CAC78;
  memset(&unk_101CAC78, 0, 0x516Cu);
  dword_101CAC58[5](dword_1031FB10 + 20832, dword_1031FB10 + 20833, dword_1031FB10 + 20836);
  (*(void (__cdecl **)(int))(dword_1031F1D4 + 24))(dword_1031FB10 + 20840);
  sub_10074010();
  sub_10073AE0();
  sub_10073E50();
  sub_10073BB0();
  sub_10050810();
  sub_10050720();
  sub_10051690();
  sub_10050990();
  sub_10050740();
  sub_100507A0();
  *(_DWORD *)(dword_1031FB10 + 20800) = 0;
  *(_DWORD *)(dword_1031FB10 + 20804) = dword_1031F4A8;
  result = dword_1031FB10;
  *(_DWORD *)(dword_1031FB10 + 20808) = dword_1031F4B4 + *(_DWORD *)(dword_1031FB10 + 20804);
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F4A8: using guessed type int dword_1031F4A8;
// 1031F4B4: using guessed type int dword_1031F4B4;
// 1031FB10: using guessed type int dword_1031FB10;

//----- (10050990) --------------------------------------------------------
int sub_10050990()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_100746A0(0x4Du, 1u) )
  {
    result = dword_1031F65C;
    dword_101CFDF0 = dword_1031F65C;
    if ( dword_1031F65C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1031F1D4)(dword_1031F65C, 8, &v1);
      word_101CFDE8 = v1;
      result = v3 & 0x1FF;
      dword_101CFDF0 += (unsigned __int16)word_1031F660;
      word_101CFDEC = v2 & 0x1FF;
      word_101CFDE4 = v3 & 0x1FF;
    }
  }
  else
  {
    word_101CFDE8 = 6;
    word_101CFDEC = 6;
    result = dword_1031F4DC;
    word_101CFDE4 = 60;
    dword_101CFDF0 = dword_1031F4DC;
  }
  return result;
}
// 101CFDE4: using guessed type __int16 word_101CFDE4;
// 101CFDE8: using guessed type __int16 word_101CFDE8;
// 101CFDEC: using guessed type __int16 word_101CFDEC;
// 101CFDF0: using guessed type int dword_101CFDF0;
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F4DC: using guessed type int dword_1031F4DC;
// 1031F65C: using guessed type int dword_1031F65C;
// 1031F660: using guessed type __int16 word_1031F660;

//----- (10050A30) --------------------------------------------------------
char __cdecl sub_10050A30(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10074850(v1, 0);
  if ( dword_101CFDF0 && v4 && sub_100746A0(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_101CFDE8;
    v12 = v9 / word_101CFDEC;
    v13 = (signed __int16)(v7 / word_101CFDE8);
    v14 = v7 / word_101CFDE8 + 1;
    v23 = v24 / (double)word_101CFDE8 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_101CFDEC - (double)v12;
    v16 = (v12 + 1) % word_101CFDE4;
    (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(
      dword_101CFDF0 + (unsigned __int16)word_1031F4E0 * (v12 + v11 * word_101CFDE4),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(
      dword_101CFDF0 + (unsigned __int16)word_1031F4E0 * (v16 + v13 * word_101CFDE4),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_1031F1D4)(
      dword_101CFDF0 + (unsigned __int16)word_1031F4E0 * (v15 + v14 * word_101CFDE4),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_1031F1D4)(
      dword_101CFDF0 + (unsigned __int16)word_1031F4E0 * (v16 + v14 * word_101CFDE4),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 101CFDE4: using guessed type __int16 word_101CFDE4;
// 101CFDE8: using guessed type __int16 word_101CFDE8;
// 101CFDEC: using guessed type __int16 word_101CFDEC;
// 101CFDF0: using guessed type int dword_101CFDF0;
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F4E0: using guessed type __int16 word_1031F4E0;

//----- (10050CF0) --------------------------------------------------------
char __cdecl sub_10050CF0(int a1, float *a2)
{
  return sub_10050A30(a2);
}

//----- (10050D10) --------------------------------------------------------
int __cdecl sub_10050D10(int a1, int a2, __int16 a3, int a4, float a5)
{
  double v5; // st7@1

  v5 = (double)(signed __int16)(a4 - a2) * a5;
  return (a3 - (signed __int16)a1) * (a3 - (signed __int16)a1) + (signed int)v5 * (signed int)v5;
}

//----- (10050D50) --------------------------------------------------------
void __cdecl sub_10050D50(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = *(_DWORD *)"______";
      *(_WORD *)(a2 + 4) = *(_WORD *)"__";
      *(_BYTE *)(a2 + 6) = a______[6];
    }
    else
    {
      sub_10064B00(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_10064B00(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (10050F30) --------------------------------------------------------
char __cdecl sub_10050F30(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (10050FA0) --------------------------------------------------------
signed int __cdecl sub_10050FA0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_1008C850(54, 60000);
  v2 = sub_10051340(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_1008C830(54);
  return v1;
}

//----- (10050FE0) --------------------------------------------------------
char __cdecl sub_10050FE0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = 0;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_1008C830(54);
  return v1;
}

//----- (10051020) --------------------------------------------------------
signed int __cdecl sub_10051020(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_1008C850(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_10051340(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_10074360(84 * a2 + v3 + 148);
  sub_1008C830(54);
  return v2;
}

//----- (10051080) --------------------------------------------------------
signed int __cdecl sub_10051080(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_10051340(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_1008C830(54);
  return v1;
}

//----- (100510C0) --------------------------------------------------------
char __cdecl sub_100510C0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10051100) --------------------------------------------------------
char __cdecl sub_10051100(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10051140) --------------------------------------------------------
char __cdecl sub_10051140(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 1) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10051180) --------------------------------------------------------
char __cdecl sub_10051180(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 4) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (100511C0) --------------------------------------------------------
char __cdecl sub_100511C0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10051200) --------------------------------------------------------
char __cdecl sub_10051200(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = -1;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = sub_100510C0(v2);
  sub_1008C830(54);
  return v1;
}

//----- (10051240) --------------------------------------------------------
char __cdecl sub_10051240(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = -1;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = sub_10051100(v2);
  sub_1008C830(54);
  return v1;
}

//----- (10051280) --------------------------------------------------------
char __cdecl sub_10051280(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = -1;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = sub_10051140(v2);
  sub_1008C830(54);
  return v1;
}

//----- (100512C0) --------------------------------------------------------
char __cdecl sub_100512C0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = -1;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = sub_10051180(v2);
  sub_1008C830(54);
  return v1;
}

//----- (10051300) --------------------------------------------------------
char __cdecl sub_10051300(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1008C850(54, 60000);
  v1 = -1;
  v2 = sub_10051340(a1);
  if ( v2 )
    v1 = sub_100511C0(v2);
  sub_1008C830(54);
  return v1;
}

//----- (10051340) --------------------------------------------------------
int __cdecl sub_10051340(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_10050040()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_1031F1C0 + 2004), result = v1 + dword_1031F1C0 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 1031F1C0: using guessed type int dword_1031F1C0;

//----- (10051380) --------------------------------------------------------
int __cdecl sub_10051380(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_100746E0(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (100513B0) --------------------------------------------------------
int sub_100513B0()
{
  return (*(int (**)(void))(dword_1031F1D4 + 8))();
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (100513C0) --------------------------------------------------------
int __fastcall sub_100513C0(unsigned __int8 a1)
{
  return dword_1031F4C4 + a1 * (unsigned __int16)word_1031F4C8;
}
// 1031F4C4: using guessed type int dword_1031F4C4;
// 1031F4C8: using guessed type __int16 word_1031F4C8;

//----- (100513E0) --------------------------------------------------------
int __fastcall sub_100513E0(unsigned __int8 a1)
{
  return dword_1031F4D0 + a1 * (unsigned __int16)word_1031F4D4;
}
// 1031F4D0: using guessed type int dword_1031F4D0;
// 1031F4D4: using guessed type __int16 word_1031F4D4;

//----- (10051400) --------------------------------------------------------
void *__cdecl sub_10051400(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_10051380(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_100513C0(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v3, 22, &v7);
      result = (void *)sub_10073C10(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (100514D0) --------------------------------------------------------
int __cdecl sub_100514D0(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_100513C0(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v2, 22, &v22);
    sub_10073C10((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_100513E0(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_1031F1D4)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10073C10((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_1031F1D4 + 12))(a1);
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (10051690) --------------------------------------------------------
char sub_10051690()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_100513B0();
  sub_10051380(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10051400(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_100746E0(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10051400(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_100514D0((int)&v8);
  }
  return v0;
}

//----- (10051800) --------------------------------------------------------
char *__cdecl sub_10051800(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1008C710();
  *(_DWORD *)(a5 + 596) = sub_1008C780();
  sub_1008C7A0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_100649E0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10051BD0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10051930) --------------------------------------------------------
char sub_10051930()
{
  char result; // al@1

  result = 0;
  byte_101D53E8 = 0;
  byte_101D53E9 = 0;
  return result;
}
// 101D53E8: using guessed type char byte_101D53E8;
// 101D53E9: using guessed type char byte_101D53E9;

//----- (10051940) --------------------------------------------------------
char __cdecl sub_10051940(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10051800(-5, a1, a2, a4, a5);
  else
    sub_10051800(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_10064B30((const char *)(a5 + 485), " DBGA", 100);
  sub_1008C7A0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_101D53E8 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_101D53E9 )
LABEL_15:
      result = sub_1008C7E0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1008D0F0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 101D53E8: using guessed type char byte_101D53E8;
// 101D53E9: using guessed type char byte_101D53E9;

//----- (10051A40) --------------------------------------------------------
char __cdecl sub_10051A40(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10051940(a1, a2, a3, a4, (int)&v5);
}

//----- (10051AB0) --------------------------------------------------------
int sub_10051AB0()
{
  int result; // eax@1

  sub_1008CB00(6361, (int)&unk_101D53EC, 4);
  result = sub_1008CB00(6362, (int)&unk_101D53F0, 4);
  dword_101D53F4 = 1379255385;
  return result;
}
// 101D53F4: using guessed type int dword_101D53F4;

//----- (10051AE0) --------------------------------------------------------
char __cdecl sub_10051AE0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100733E0(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10051B40) --------------------------------------------------------
char __cdecl sub_10051B40(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100733E0(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10051BA0) --------------------------------------------------------
char __cdecl sub_10051BA0(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10051AE0(&a1);
  if ( v2 )
    *v1 = sub_10051C00() + *(float *)&a1;
  return v2;
}
// 10051C00: using guessed type double sub_10051C00(void);

//----- (10051BD0) --------------------------------------------------------
char __cdecl sub_10051BD0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_100520D0(13, (char *)&v3 + 3);
  sub_100520D0(12, a1);
  return BYTE3(v3);
}

//----- (10051C00) --------------------------------------------------------
void sub_10051C00()
{
  float v0; // ST00_4@1

  v0 = sub_100731F0();
  sub_1008E960(v0);
}
// 100731F0: using guessed type double sub_100731F0(void);

//----- (10051C20) --------------------------------------------------------
char __thiscall sub_10051C20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_1008CC30(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051C50) --------------------------------------------------------
char __thiscall sub_10051C50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_1008CC30(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051C80) --------------------------------------------------------
char __fastcall sub_10051C80(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1008D070(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_100DE775[2 * sub_1006E440((int *)((char *)&v2 + 2), 1u, (int)&unk_100DE774, 2, 5, -1)];
  if ( sub_1008CA60(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1008CBF0(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10051CF0) --------------------------------------------------------
char __thiscall sub_10051CF0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1008CC30(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051D20) --------------------------------------------------------
char __fastcall sub_10051D20(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1008D070(3, (_BYTE *)&v2 + 2);
  if ( sub_1008CA60(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1008CBF0(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10051D70) --------------------------------------------------------
char sub_10051D70()
{
  return 18;
}

//----- (10051D80) --------------------------------------------------------
BOOL __thiscall sub_10051D80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1008D070(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (10051DA0) --------------------------------------------------------
int __thiscall sub_10051DA0(void *this)
{
  int result; // eax@1
  signed int v2; // esi@1
  int v3; // [sp-Ch] [bp-14h]@3
  char *v4; // [sp-8h] [bp-10h]@3
  char v5; // [sp+7h] [bp-1h]@1

  v5 = 8;
  result = sub_1006F3C0(this);
  v2 = 0;
  if ( !(result & 0xF) )
  {
    switch ( result )
    {
      case 64:
        v4 = &v5;
        v3 = 9956;
        goto LABEL_7;
      case 128:
        v4 = &v5;
        v3 = 9957;
        goto LABEL_7;
      case 16:
        v4 = &v5;
        v3 = 9958;
        goto LABEL_7;
      case 32:
        v4 = &v5;
        v3 = 9959;
LABEL_7:
        sub_1008CA60(v3, (int)v4, 1);
        break;
      default:
        break;
    }
    switch ( v5 )
    {
      case 0:
      case 1:
        result = 1;
        break;
      case 2:
      case 3:
        result = 4;
        break;
      case 4:
      case 5:
        result = 8;
        break;
      case 6:
      case 7:
        v2 = 2;
        goto LABEL_13;
      default:
LABEL_13:
        result = v2;
        break;
    }
  }
  return result;
}

//----- (10051EF0) --------------------------------------------------------
char __thiscall sub_10051EF0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_1008CC30(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051F20) --------------------------------------------------------
char __thiscall sub_10051F20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_1008CC30(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051F50) --------------------------------------------------------
char __fastcall sub_10051F50(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1008D070(5, (_BYTE *)&v2 + 2);
  if ( sub_1008CA60(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1008CBF0(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10051FA0) --------------------------------------------------------
char __thiscall sub_10051FA0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1008CC30(3011, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10051FD0) --------------------------------------------------------
char __thiscall sub_10051FD0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1008CC30(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10052000) --------------------------------------------------------
int sub_10052000()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_1008CC30(3012, &v2, 4, &v1);
  return v2;
}

//----- (10052030) --------------------------------------------------------
char __thiscall sub_10052030(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_1008CC30(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10052060) --------------------------------------------------------
char __fastcall sub_10052060(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1008D070(42, (_BYTE *)&v2 + 2);
  if ( sub_1008CA60(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1008CBF0(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (100520B0) --------------------------------------------------------
char __cdecl sub_100520B0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960AE: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 100960B4: using guessed type int SYS_enter_krnl(void);

//----- (100520D0) --------------------------------------------------------
int __cdecl sub_100520D0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10051A40("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10051A40("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100960BA: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10052130) --------------------------------------------------------
char __thiscall sub_10052130(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(10, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10052150) --------------------------------------------------------
char __thiscall sub_10052150(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(11, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10052170) --------------------------------------------------------
char __thiscall sub_10052170(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10052190) --------------------------------------------------------
int __thiscall sub_10052190(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_100520D0(15, (char *)&v2);
  return (int)v2;
}

//----- (100521B0) --------------------------------------------------------
int __thiscall sub_100521B0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_100520D0(16, (char *)&v2);
  return (int)v2;
}

//----- (100521D0) --------------------------------------------------------
char __thiscall sub_100521D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100521F0) --------------------------------------------------------
int __thiscall sub_100521F0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_100520D0(29, (char *)&v2);
  return (int)v2;
}

//----- (10052210) --------------------------------------------------------
char __thiscall sub_10052210(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10052230) --------------------------------------------------------
char __thiscall sub_10052230(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100520D0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10052250) --------------------------------------------------------
char sub_10052250()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_100520D0(48, &v1);
  return v1;
}

//----- (10052270) --------------------------------------------------------
BOOL sub_10052270()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  sub_100520D0(49, &v1);
  return v1 == 0;
}

//----- (10052290) --------------------------------------------------------
int __cdecl sub_10052290(char a1)
{
  return sub_100520D0(59, &a1);
}

//----- (100522A0) --------------------------------------------------------
int __cdecl sub_100522A0(char a1)
{
  return sub_100520D0(60, &a1);
}

//----- (100522B0) --------------------------------------------------------
int __cdecl sub_100522B0(char a1)
{
  return sub_100520D0(56, &a1);
}

//----- (100522C0) --------------------------------------------------------
int __cdecl sub_100522C0(char a1)
{
  return sub_100520D0(76, &a1);
}

//----- (100522D0) --------------------------------------------------------
int __cdecl sub_100522D0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10052310) --------------------------------------------------------
void *__usercall sub_10052310@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1008CA60(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1008CBB0(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10052360) --------------------------------------------------------
signed int sub_10052360()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1031FB44 = 0;
  v4 = 0;
  sub_1008D070(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1008CB30(3201, (int)&v4, 1);
    sub_1008D0A0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1008CB30(3201, (int)&v4, 1);
    sub_1008D0A0(94, (int)&v4);
  }
  sub_10052310(1u, 6011, &unk_101D53F8);
  sub_10052310(0x16u, 6194, &unk_101D53F9);
  sub_10052310(1u, 6012, &unk_101D540F);
  sub_10052310(1u, 6013, &unk_101D5410);
  sub_10052310(1u, 6014, &unk_101D5411);
  sub_10052310(1u, 6015, &unk_101D5412);
  sub_10052310(4u, 6078, &unk_101D5414);
  sub_10052310(4u, 6104, &unk_101D5418);
  sub_10052310(0x20u, 6016, &unk_101D541C);
  sub_10052310(0x20u, 6017, &unk_101D543C);
  sub_10052310(0x20u, 6018, &unk_101D545C);
  sub_10052310(0x20u, 6019, &unk_101D547C);
  sub_10052310(0x20u, 6020, &unk_101D549C);
  sub_10052310(0x20u, 6021, &unk_101D54BC);
  sub_10052310(0x20u, 6022, &unk_101D54DC);
  sub_10052310(0x20u, 6023, &unk_101D54FC);
  sub_10052310(0x20u, 6024, &unk_101D551C);
  sub_10052310(0x20u, 6025, &unk_101D553C);
  sub_10052310(0x20u, 6026, &unk_101D555C);
  sub_10052310(0x20u, 6027, &unk_101D557C);
  sub_10052310(0x20u, 6028, &unk_101D559C);
  sub_10052310(0x20u, 6029, &unk_101D55BC);
  sub_10052310(0x20u, 6030, &unk_101D55DC);
  sub_10052310(0x20u, 6031, &unk_101D55FC);
  sub_10052310(0x20u, 6032, &unk_101D561C);
  sub_10052310(0x20u, 6033, &unk_101D563C);
  sub_10052310(0x20u, 6034, &unk_101D565C);
  sub_10052310(0x20u, 6035, &unk_101D567C);
  sub_10052310(0x20u, 6036, &unk_101D569C);
  sub_10052310(0x20u, 6037, &unk_101D56BC);
  sub_10052310(0x20u, 6038, &unk_101D56DC);
  sub_10052310(0x20u, 6039, &unk_101D56FC);
  sub_10052310(0x20u, 6040, &unk_101D571C);
  sub_10052310(0x20u, 6041, &unk_101D573C);
  sub_10052310(0x20u, 6042, &unk_101D575C);
  sub_10052310(0x20u, 6043, &unk_101D577C);
  sub_10052310(4u, 6044, &unk_101D579C);
  sub_10052310(4u, 6045, &unk_101D57A0);
  sub_10052310(4u, 6046, &unk_101D57A4);
  sub_10052310(4u, 6357, &unk_101D57A8);
  sub_10052310(4u, 6358, &unk_101D57AC);
  sub_10052310(4u, 6359, &unk_101D57B0);
  sub_10052310(0x20u, 6047, &unk_101D57B4);
  sub_10052310(0x20u, 6048, &unk_101D57D4);
  sub_10052310(0x20u, 6049, &unk_101D57F4);
  sub_10052310(0x20u, 6050, &unk_101D5814);
  sub_10052310(0x20u, 6051, &unk_101D5834);
  sub_10052310(0x20u, 6052, &unk_101D5854);
  sub_10052310(0x20u, 6053, &unk_101D5874);
  sub_10052310(0x20u, 6054, &unk_101D5894);
  sub_10052310(1u, 6511, &unk_101D58B4);
  sub_10052310(1u, 6522, &unk_101D58B5);
  sub_10052310(1u, 6057, &unk_101D58B6);
  sub_10052310(0x20u, 6075, &unk_101D5908);
  sub_10052310(0x20u, 6076, &unk_101D5928);
  sub_10052310(1u, 6077, &unk_101D5948);
  sub_10052310(4u, 6079, &unk_101D594C);
  sub_10052310(4u, 6080, &unk_101D5950);
  sub_10052310(0x20u, 6082, &unk_101D5954);
  sub_10052310(0x20u, 6083, &unk_101D5974);
  sub_10052310(0x20u, 6084, &unk_101D5994);
  sub_10052310(0x20u, 6085, &unk_101D59B4);
  sub_10052310(0x20u, 6086, &unk_101D59D4);
  sub_10052310(0x20u, 6087, &unk_101D59F4);
  sub_10052310(0x20u, 6088, &unk_101D5A14);
  sub_10052310(0x20u, 6089, &unk_101D5A34);
  sub_10052310(0x20u, 6123, &unk_101D5A54);
  sub_10052310(0x48u, 6906, &unk_101D5A74);
  sub_10052310(0x48u, 6907, &unk_101D5ABC);
  sub_10052310(0x48u, 6908, &unk_101D5B04);
  sub_10052310(0x48u, 6909, &unk_101D5B4C);
  sub_10052310(0x48u, 6910, &unk_101D5B94);
  sub_10052310(0x48u, 6911, &unk_101D5BDC);
  sub_10052310(0x48u, 6912, &unk_101D5C24);
  sub_10052310(0x48u, 6913, &unk_101D5C6C);
  sub_10052310(0x48u, 6914, &unk_101D5CB4);
  sub_10052310(0x48u, 6915, &unk_101D5CFC);
  sub_10052310(0x48u, 6916, &unk_101D5D44);
  sub_10052310(0x48u, 6917, &unk_101D5D8C);
  sub_10052310(0x48u, 6918, &unk_101D5DD4);
  sub_10052310(0x48u, 6919, &unk_101D5E1C);
  sub_10052310(0x48u, 6920, &unk_101D5E64);
  sub_10052310(0x48u, 6921, &unk_101D5EAC);
  sub_10052310(0x48u, 6922, &unk_101D5EF4);
  sub_10052310(0x48u, 6923, &unk_101D5F3C);
  sub_10052310(0x48u, 6924, &unk_101D5F84);
  sub_10052310(0x48u, 6925, &unk_101D5FCC);
  sub_10052310(0x48u, 6926, &unk_101D6014);
  sub_10052310(0x48u, 6927, &unk_101D605C);
  sub_10052310(0x48u, 6928, &unk_101D60A4);
  sub_10052310(0x48u, 6929, &unk_101D60EC);
  sub_10052310(0x48u, 6930, &unk_101D6134);
  sub_10052310(0x48u, 6931, &unk_101D617C);
  sub_10052310(0x48u, 6932, &unk_101D61C4);
  sub_10052310(0x48u, 6933, &unk_101D620C);
  sub_10052310(0x48u, 6934, &unk_101D6254);
  sub_10052310(0x48u, 6935, &unk_101D629C);
  sub_10052310(0x18u, 6163, &unk_101D62E4);
  sub_10052310(0x20u, 6164, &unk_101D62FC);
  sub_10052310(0x20u, 6165, &unk_101D631C);
  sub_10052310(2u, 6166, &unk_101D633C);
  sub_10052310(0xA4u, 40100, &unk_101D6340);
  sub_10052310(0xA4u, 40101, &unk_101D63E4);
  sub_10052310(0xA4u, 40102, &unk_101D6488);
  sub_10052310(0xA4u, 40103, &unk_101D652C);
  sub_10052310(0xA4u, 40104, &unk_101D65D0);
  sub_10052310(0xA4u, 40105, &unk_101D6674);
  sub_10052310(0xA4u, 40106, &unk_101D6718);
  sub_10052310(0xA4u, 40107, &unk_101D67BC);
  sub_10052310(0xA4u, 40108, &unk_101D6860);
  sub_10052310(0xA4u, 40109, &unk_101D6904);
  sub_10052310(0xA4u, 40110, &unk_101D69A8);
  sub_10052310(0xA4u, 40111, &unk_101D6A4C);
  sub_10052310(0xA4u, 40112, &unk_101D6AF0);
  sub_10052310(0xA4u, 40113, &unk_101D6B94);
  sub_10052310(0xA4u, 40114, &unk_101D6C38);
  sub_10052310(0xA4u, 40115, &unk_101D6CDC);
  sub_10052310(0xA4u, 40116, &unk_101D6D80);
  sub_10052310(0xA4u, 40117, &unk_101D6E24);
  sub_10052310(0xA4u, 40118, &unk_101D6EC8);
  sub_10052310(0xA4u, 40119, &unk_101D6F6C);
  sub_10052310(0xA4u, 40120, &unk_101D7010);
  sub_10052310(0xA4u, 40121, &unk_101D70B4);
  sub_10052310(0xA4u, 40122, &unk_101D7158);
  sub_10052310(0xA4u, 40123, &unk_101D71FC);
  sub_10052310(0xA4u, 40124, &unk_101D72A0);
  sub_10052310(0xA4u, 40125, &unk_101D7344);
  sub_10052310(0xA4u, 40126, &unk_101D73E8);
  sub_10052310(0xA4u, 40127, &unk_101D748C);
  sub_10052310(0xA4u, 40128, &unk_101D7530);
  sub_10052310(0xA4u, 40129, &unk_101D75D4);
  sub_10052310(0xA4u, 40130, &unk_101D7678);
  sub_10052310(0xA4u, 40131, &unk_101D771C);
  sub_10052310(0xA4u, 40132, &unk_101D77C0);
  sub_10052310(0xA4u, 40133, &unk_101D7864);
  sub_10052310(0xA4u, 40134, &unk_101D7908);
  sub_10052310(0xA4u, 40135, &unk_101D79AC);
  sub_10052310(0xA4u, 40136, &unk_101D7A50);
  sub_10052310(0xA4u, 40137, &unk_101D7AF4);
  sub_10052310(0xA4u, 40138, &unk_101D7B98);
  sub_10052310(0xA4u, 40139, &unk_101D7C3C);
  sub_10052310(0xA4u, 40140, &unk_101D7CE0);
  sub_10052310(0xA4u, 40141, &unk_101D7D84);
  sub_10052310(0xA4u, 40142, &unk_101D7E28);
  sub_10052310(0xA4u, 40143, &unk_101D7ECC);
  sub_10052310(0xA4u, 40144, &unk_101D7F70);
  sub_10052310(0xA4u, 40145, &unk_101D8014);
  sub_10052310(0xA4u, 40146, &unk_101D80B8);
  sub_10052310(0xA4u, 40147, &unk_101D815C);
  sub_10052310(0xA4u, 40148, &unk_101D8200);
  sub_10052310(0xA4u, 40149, &unk_101D82A4);
  sub_10052310(0xA4u, 40150, &unk_101D8348);
  sub_10052310(0xA4u, 40151, &unk_101D83EC);
  sub_10052310(0xA4u, 40152, &unk_101D8490);
  sub_10052310(0xA4u, 40153, &unk_101D8534);
  sub_10052310(0xA4u, 40154, &unk_101D85D8);
  sub_10052310(0xA4u, 40155, &unk_101D867C);
  sub_10052310(0xA4u, 40156, &unk_101D8720);
  sub_10052310(0xA4u, 40157, &unk_101D87C4);
  sub_10052310(0xA4u, 40158, &unk_101D8868);
  sub_10052310(0xA4u, 40159, &unk_101D890C);
  sub_10052310(0xA4u, 40160, &unk_101D89B0);
  sub_10052310(0xA4u, 40161, &unk_101D8A54);
  sub_10052310(0xA4u, 40162, &unk_101D8AF8);
  sub_10052310(0xA4u, 40163, &unk_101D8B9C);
  sub_10052310(0xA4u, 40164, &unk_101D8C40);
  sub_10052310(0xA4u, 40165, &unk_101D8CE4);
  sub_10052310(0xA4u, 40166, &unk_101D8D88);
  sub_10052310(0xA4u, 40167, &unk_101D8E2C);
  sub_10052310(0xA4u, 40168, &unk_101D8ED0);
  sub_10052310(0xA4u, 40169, &unk_101D8F74);
  sub_10052310(0xA4u, 40170, &unk_101D9018);
  sub_10052310(0xA4u, 40171, &unk_101D90BC);
  sub_10052310(0xA4u, 40172, &unk_101D9160);
  sub_10052310(0xA4u, 40173, &unk_101D9204);
  sub_10052310(0xA4u, 40174, &unk_101D92A8);
  sub_10052310(0xA4u, 40175, &unk_101D934C);
  sub_10052310(0xA4u, 40176, &unk_101D93F0);
  sub_10052310(0xA4u, 40177, &unk_101D9494);
  sub_10052310(0xA4u, 40178, &unk_101D9538);
  sub_10052310(0xA4u, 40179, &unk_101D95DC);
  sub_10052310(0xA4u, 40180, &unk_101D9680);
  sub_10052310(0xA4u, 40181, &unk_101D9724);
  sub_10052310(0xA4u, 40182, &unk_101D97C8);
  sub_10052310(0xA4u, 40183, &unk_101D986C);
  sub_10052310(0xA4u, 40184, &unk_101D9910);
  sub_10052310(0xA4u, 40185, &unk_101D99B4);
  sub_10052310(0xA4u, 40186, &unk_101D9A58);
  sub_10052310(0xA4u, 40187, &unk_101D9AFC);
  sub_10052310(0xA4u, 40188, &unk_101D9BA0);
  sub_10052310(0xA4u, 40189, &unk_101D9C44);
  sub_10052310(0xA4u, 40190, &unk_101D9CE8);
  sub_10052310(0xA4u, 40191, &unk_101D9D8C);
  sub_10052310(0xA4u, 40192, &unk_101D9E30);
  sub_10052310(0xA4u, 40193, &unk_101D9ED4);
  sub_10052310(0xA4u, 40194, &unk_101D9F78);
  sub_10052310(0xA4u, 40195, &unk_101DA01C);
  sub_10052310(0xA4u, 40196, &unk_101DA0C0);
  sub_10052310(0xA4u, 40197, &unk_101DA164);
  sub_10052310(0xA4u, 40198, &unk_101DA208);
  sub_10052310(0xA4u, 40199, &unk_101DA2AC);
  sub_10052310(0x20u, 6190, &unk_101DA350);
  sub_10052310(0x20u, 6191, &unk_101DA370);
  sub_10052310(0x20u, 6192, &unk_101DA390);
  sub_10052310(0x20u, 6199, &unk_101DA3B0);
  sub_10052310(0x28u, 6207, &unk_101DA3D0);
  sub_10052310(4u, 6231, &unk_101DAEE8);
  sub_10052310(4u, 6232, &unk_101DAEEC);
  sub_10052310(4u, 6233, &unk_101DAEF0);
  sub_10052310(4u, 6234, &unk_101DAEF4);
  sub_10052310(0x1Cu, 40000, &unk_101DA3F8);
  sub_10052310(0x1Cu, 40001, &unk_101DA414);
  sub_10052310(0x1Cu, 40002, &unk_101DA430);
  sub_10052310(0x1Cu, 40003, &unk_101DA44C);
  sub_10052310(0x1Cu, 40004, &unk_101DA468);
  sub_10052310(0x1Cu, 40005, &unk_101DA484);
  sub_10052310(0x1Cu, 40006, &unk_101DA4A0);
  sub_10052310(0x1Cu, 40007, &unk_101DA4BC);
  sub_10052310(0x1Cu, 40008, &unk_101DA4D8);
  sub_10052310(0x1Cu, 40009, &unk_101DA4F4);
  sub_10052310(0x1Cu, 40010, &unk_101DA510);
  sub_10052310(0x1Cu, 40011, &unk_101DA52C);
  sub_10052310(0x1Cu, 40012, &unk_101DA548);
  sub_10052310(0x1Cu, 40013, &unk_101DA564);
  sub_10052310(0x1Cu, 40014, &unk_101DA580);
  sub_10052310(0x1Cu, 40015, &unk_101DA59C);
  sub_10052310(0x1Cu, 40016, &unk_101DA5B8);
  sub_10052310(0x1Cu, 40017, &unk_101DA5D4);
  sub_10052310(0x1Cu, 40018, &unk_101DA5F0);
  sub_10052310(0x1Cu, 40019, &unk_101DA60C);
  sub_10052310(0x1Cu, 40020, &unk_101DA628);
  sub_10052310(0x1Cu, 40021, &unk_101DA644);
  sub_10052310(0x1Cu, 40022, &unk_101DA660);
  sub_10052310(0x1Cu, 40023, &unk_101DA67C);
  sub_10052310(0x1Cu, 40024, &unk_101DA698);
  sub_10052310(0x1Cu, 40025, &unk_101DA6B4);
  sub_10052310(0x1Cu, 40026, &unk_101DA6D0);
  sub_10052310(0x1Cu, 40027, &unk_101DA6EC);
  sub_10052310(0x1Cu, 40028, &unk_101DA708);
  sub_10052310(0x1Cu, 40029, &unk_101DA724);
  sub_10052310(0x1Cu, 40030, &unk_101DA740);
  sub_10052310(0x1Cu, 40031, &unk_101DA75C);
  sub_10052310(0x1Cu, 40032, &unk_101DA778);
  sub_10052310(0x1Cu, 40033, &unk_101DA794);
  sub_10052310(0x1Cu, 40034, &unk_101DA7B0);
  sub_10052310(0x1Cu, 40035, &unk_101DA7CC);
  sub_10052310(0x1Cu, 40036, &unk_101DA7E8);
  sub_10052310(0x1Cu, 40037, &unk_101DA804);
  sub_10052310(0x1Cu, 40038, &unk_101DA820);
  sub_10052310(0x1Cu, 40039, &unk_101DA83C);
  sub_10052310(0x1Cu, 40040, &unk_101DA858);
  sub_10052310(0x1Cu, 40041, &unk_101DA874);
  sub_10052310(0x1Cu, 40042, &unk_101DA890);
  sub_10052310(0x1Cu, 40043, &unk_101DA8AC);
  sub_10052310(0x1Cu, 40044, &unk_101DA8C8);
  sub_10052310(0x1Cu, 40045, &unk_101DA8E4);
  sub_10052310(0x1Cu, 40046, &unk_101DA900);
  sub_10052310(0x1Cu, 40047, &unk_101DA91C);
  sub_10052310(0x1Cu, 40048, &unk_101DA938);
  sub_10052310(0x1Cu, 40049, &unk_101DA954);
  sub_10052310(0x1Cu, 40050, &unk_101DA970);
  sub_10052310(0x1Cu, 40051, &unk_101DA98C);
  sub_10052310(0x1Cu, 40052, &unk_101DA9A8);
  sub_10052310(0x1Cu, 40053, &unk_101DA9C4);
  sub_10052310(0x1Cu, 40054, &unk_101DA9E0);
  sub_10052310(0x1Cu, 40055, &unk_101DA9FC);
  sub_10052310(0x1Cu, 40056, &unk_101DAA18);
  sub_10052310(0x1Cu, 40057, &unk_101DAA34);
  sub_10052310(0x1Cu, 40058, &unk_101DAA50);
  sub_10052310(0x1Cu, 40059, &unk_101DAA6C);
  sub_10052310(0x1Cu, 40060, &unk_101DAA88);
  sub_10052310(0x1Cu, 40061, &unk_101DAAA4);
  sub_10052310(0x1Cu, 40062, &unk_101DAAC0);
  sub_10052310(0x1Cu, 40063, &unk_101DAADC);
  sub_10052310(0x1Cu, 40064, &unk_101DAAF8);
  sub_10052310(0x1Cu, 40065, &unk_101DAB14);
  sub_10052310(0x1Cu, 40066, &unk_101DAB30);
  sub_10052310(0x1Cu, 40067, &unk_101DAB4C);
  sub_10052310(0x1Cu, 40068, &unk_101DAB68);
  sub_10052310(0x1Cu, 40069, &unk_101DAB84);
  sub_10052310(0x1Cu, 40070, &unk_101DABA0);
  sub_10052310(0x1Cu, 40071, &unk_101DABBC);
  sub_10052310(0x1Cu, 40072, &unk_101DABD8);
  sub_10052310(0x1Cu, 40073, &unk_101DABF4);
  sub_10052310(0x1Cu, 40074, &unk_101DAC10);
  sub_10052310(0x1Cu, 40075, &unk_101DAC2C);
  sub_10052310(0x1Cu, 40076, &unk_101DAC48);
  sub_10052310(0x1Cu, 40077, &unk_101DAC64);
  sub_10052310(0x1Cu, 40078, &unk_101DAC80);
  sub_10052310(0x1Cu, 40079, &unk_101DAC9C);
  sub_10052310(0x1Cu, 40080, &unk_101DACB8);
  sub_10052310(0x1Cu, 40081, &unk_101DACD4);
  sub_10052310(0x1Cu, 40082, &unk_101DACF0);
  sub_10052310(0x1Cu, 40083, &unk_101DAD0C);
  sub_10052310(0x1Cu, 40084, &unk_101DAD28);
  sub_10052310(0x1Cu, 40085, &unk_101DAD44);
  sub_10052310(0x1Cu, 40086, &unk_101DAD60);
  sub_10052310(0x1Cu, 40087, &unk_101DAD7C);
  sub_10052310(0x1Cu, 40088, &unk_101DAD98);
  sub_10052310(0x1Cu, 40089, &unk_101DADB4);
  sub_10052310(0x1Cu, 40090, &unk_101DADD0);
  sub_10052310(0x1Cu, 40091, &unk_101DADEC);
  sub_10052310(0x1Cu, 40092, &unk_101DAE08);
  sub_10052310(0x1Cu, 40093, &unk_101DAE24);
  sub_10052310(0x1Cu, 40094, &unk_101DAE40);
  sub_10052310(0x1Cu, 40095, &unk_101DAE5C);
  sub_10052310(0x1Cu, 40096, &unk_101DAE78);
  sub_10052310(0x1Cu, 40097, &unk_101DAE94);
  sub_10052310(0x1Cu, 40098, &unk_101DAEB0);
  sub_10052310(0x1Cu, 40099, &unk_101DAECC);
  sub_10052310(4u, 6238, &unk_101DAEF8);
  sub_10052310(4u, 6239, &unk_101DAEFC);
  sub_10052310(4u, 6240, &unk_101DAF00);
  sub_10052310(4u, 6242, &unk_101DAF04);
  sub_10052310(4u, 6244, &unk_101DAF08);
  sub_10052310(4u, 6245, &unk_101DAF0C);
  sub_10052310(4u, 6246, &unk_101DAF10);
  sub_10052310(4u, 6251, &unk_101DAF14);
  sub_10052310(4u, 6252, &unk_101DAF18);
  sub_10052310(4u, 6253, &unk_101DAF1C);
  sub_10052310(4u, 6254, &unk_101DAF20);
  sub_10052310(1u, 6255, &unk_101DAF24);
  sub_10052310(4u, 6256, &unk_101DAF28);
  sub_10052310(4u, 6257, &unk_101DAF2C);
  sub_10052310(0xE2u, 6286, &unk_101DAF30);
  v0 = 18000;
  v1 = &unk_101DB014;
  v2 = 16;
  do
  {
    sub_10052310(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10052310(4u, 6262, &unk_101DC1D4);
  sub_10052310(0x28u, 6263, &unk_101DC1D8);
  sub_10052310(0x28u, 6264, &unk_101DC200);
  sub_10052310(0x40u, 6268, &unk_101DC228);
  sub_10052310(4u, 6272, &unk_101DC2E8);
  sub_10052310(4u, 6273, &unk_101DC2EC);
  sub_10052310(1u, 6274, &unk_101DC2F0);
  sub_10052310(2u, 6275, &unk_101DC2F2);
  sub_10052310(1u, 6276, &unk_101DC2F4);
  sub_10052310(1u, 6277, &unk_101DC2F5);
  sub_10052310(1u, 6278, &unk_101DC2F6);
  sub_10052310(0x40u, 6279, &unk_101DC2F8);
  sub_10052310(0x28u, 6753, &unk_101DD1AD);
  sub_10052310(0x30u, 6754, &unk_101DD1D8);
  sub_10052310(0x28u, 6958, &unk_101DD208);
  sub_10052310(0x80u, 6802, &unk_101DC268);
  sub_10052310(1u, 6760, &unk_101DD230);
  sub_10052310(0x10u, 6312, &unk_101DC67C);
  sub_10052310(0x10u, 6313, &unk_101DC68C);
  sub_10052310(0x10u, 6314, &unk_101DC69C);
  sub_10052310(1u, 6307, &unk_101DC6AC);
  sub_10052310(1u, 6308, &unk_101DC6AD);
  sub_10052310(1u, 6309, &unk_101DC6AE);
  sub_10052310(4u, 6285, &unk_101DC6B0);
  sub_10052310(0xA8u, 6318, &unk_101DC6B4);
  sub_10052310(4u, 6319, &unk_101DC75C);
  sub_10052310(1u, 6350, &unk_101DC760);
  sub_10052310(0x50u, 6351, &unk_101DC764);
  sub_10052310(4u, 6352, &unk_101DC7B4);
  sub_10052310(4u, 6353, &unk_101DC7B8);
  sub_10052310(0x54u, 6448, &unk_101DCA04);
  sub_10052310(0x54u, 6449, &unk_101DCA58);
  sub_10052310(8u, 6287, &unk_101DC35C);
  sub_10052310(8u, 6288, &unk_101DC364);
  sub_10052310(8u, 6289, &unk_101DC36C);
  sub_10052310(8u, 6290, &unk_101DC374);
  sub_10052310(8u, 6291, &unk_101DC37C);
  sub_10052310(8u, 6292, &unk_101DC384);
  sub_10052310(8u, 6293, &unk_101DC38C);
  sub_10052310(8u, 6294, &unk_101DC394);
  sub_10052310(8u, 6295, &unk_101DC39C);
  sub_10052310(8u, 6296, &unk_101DC3A4);
  sub_10052310(8u, 6297, &unk_101DC3AC);
  sub_10052310(8u, 6298, &unk_101DC3B4);
  sub_10052310(8u, 6299, &unk_101DC3BC);
  sub_10052310(8u, 6300, &unk_101DC3C4);
  sub_10052310(8u, 6301, &unk_101DC3CC);
  sub_10052310(8u, 6302, &unk_101DC3D4);
  sub_10052310(8u, 6303, &unk_101DC3DC);
  sub_10052310(8u, 6304, &unk_101DC3E4);
  sub_10052310(8u, 6305, &unk_101DC3EC);
  sub_10052310(8u, 6306, &unk_101DC3F4);
  sub_10052310(8u, 6409, &unk_101DC3FC);
  sub_10052310(8u, 6410, &unk_101DC404);
  sub_10052310(8u, 6411, &unk_101DC40C);
  sub_10052310(8u, 6412, &unk_101DC414);
  sub_10052310(8u, 6413, &unk_101DC41C);
  sub_10052310(8u, 6414, &unk_101DC424);
  sub_10052310(8u, 6415, &unk_101DC42C);
  sub_10052310(8u, 6416, &unk_101DC434);
  sub_10052310(8u, 6417, &unk_101DC43C);
  sub_10052310(8u, 6418, &unk_101DC444);
  sub_10052310(8u, 6419, &unk_101DC44C);
  sub_10052310(8u, 6420, &unk_101DC454);
  sub_10052310(8u, 6421, &unk_101DC45C);
  sub_10052310(8u, 6422, &unk_101DC464);
  sub_10052310(8u, 6423, &unk_101DC46C);
  sub_10052310(8u, 6424, &unk_101DC474);
  sub_10052310(8u, 6425, &unk_101DC47C);
  sub_10052310(8u, 6426, &unk_101DC484);
  sub_10052310(8u, 6427, &unk_101DC48C);
  sub_10052310(8u, 6428, &unk_101DC494);
  sub_10052310(4u, 6429, &unk_101DC99C);
  sub_10052310(8u, 6430, &unk_101DC9A0);
  sub_10052310(8u, 6431, &unk_101DC9A8);
  sub_10052310(8u, 6432, &unk_101DC9B0);
  sub_10052310(8u, 6433, &unk_101DC9B8);
  sub_10052310(8u, 6434, &unk_101DC9C0);
  sub_10052310(8u, 6435, &unk_101DC9C8);
  sub_10052310(8u, 6436, &unk_101DC9D0);
  sub_10052310(8u, 6437, &unk_101DC9D8);
  sub_10052310(8u, 6438, &unk_101DC9E0);
  sub_10052310(8u, 6439, &unk_101DC9E8);
  sub_10052310(8u, 6440, &unk_101DC9F0);
  sub_10052310(0xAu, 6519, &unk_101DCE5C);
  sub_10052310(4u, 6442, &unk_101DC9F8);
  sub_10052310(4u, 6443, &unk_101DC9FC);
  sub_10052310(0xF0u, 6367, &unk_101DC7BC);
  sub_10052310(0xF0u, 6368, &unk_101DC8AC);
  sub_10052310(1u, 6446, &unk_101DCA00);
  sub_10052310(6u, 6452, &unk_101DCAAC);
  sub_10052310(4u, 6457, &unk_101DCAB4);
  sub_10052310(4u, 6458, &unk_101DCAB8);
  sub_10052310(4u, 6459, &unk_101DCABC);
  sub_10052310(4u, 6460, &unk_101DCAC0);
  sub_10052310(0x208u, 6515, &unk_101DCAC4);
  sub_10052310(0x160u, 6516, &unk_101DCCCC);
  sub_10052310(0x18u, 6517, &unk_101DCE2C);
  sub_10052310(0x18u, 6518, &unk_101DCE44);
  sub_10052310(1u, 6520, &unk_101DCE66);
  sub_10052310(0x10u, 6521, &unk_101DCE68);
  sub_10052310(4u, 6523, &unk_101DCE78);
  sub_10052310(4u, 6524, &unk_101DCE7C);
  sub_10052310(4u, 6525, &unk_101DCE80);
  sub_10052310(1u, 6526, &unk_101DCE84);
  sub_10052310(1u, 6527, &unk_101DCE85);
  sub_10052310(0x50u, 6528, &unk_101DCE88);
  sub_10052310(4u, 6529, &unk_101DCED8);
  sub_10052310(1u, 6530, &unk_101DCEDC);
  sub_10052310(1u, 6531, &unk_101DCEDD);
  sub_10052310(1u, 6532, &unk_101DCEDE);
  sub_10052310(0x14u, 6533, &unk_101DCEDF);
  sub_10052310(0xAu, 6883, &unk_101DD5F8);
  sub_10052310(0xAu, 6884, &unk_101DD602);
  sub_10052310(0xAu, 6885, &unk_101DD60C);
  sub_10052310(1u, 6664, &unk_101DCEF3);
  sub_10052310(1u, 6666, &unk_101DCEF4);
  sub_10052310(1u, 6667, &unk_101DCEF5);
  sub_10052310(1u, 6668, &unk_101DCEF6);
  sub_10052310(0xA0u, 6669, &unk_101DCEF8);
  sub_10052310(2u, 6670, &unk_101DCFE8);
  sub_10052310(4u, 6671, &unk_101DCFEC);
  sub_10052310(4u, 6672, &unk_101DCFF0);
  sub_10052310(4u, 6673, &unk_101DCFF4);
  sub_10052310(4u, 6674, &unk_101DCFF8);
  sub_10052310(4u, 6675, &unk_101DCFFC);
  sub_10052310(4u, 6676, &unk_101DD004);
  sub_10052310(4u, 6677, &unk_101DD00C);
  sub_10052310(4u, 6678, &unk_101DD010);
  sub_10052310(1u, 6679, &unk_101DD014);
  sub_10052310(0x140u, 6680, &unk_101DD018);
  sub_10052310(4u, 6882, &unk_101DD5F4);
  sub_10052310(0xCu, 6652, &unk_101DD158);
  sub_10052310(0x48u, 6653, &unk_101DD164);
  sub_10052310(1u, 6688, &unk_101DD1AC);
  sub_10052310(4u, 6771, &unk_101DD234);
  sub_10052310(4u, 6772, &unk_101DD238);
  sub_10052310(8u, 6787, &unk_101DD23C);
  sub_10052310(1u, 6832, &unk_101DD26C);
  sub_10052310(1u, 6833, &unk_101DD26D);
  sub_10052310(1u, 6834, &unk_101DD26E);
  sub_10052310(4u, 6835, &unk_101DD270);
  sub_10052310(4u, 6836, &unk_101DD274);
  sub_10052310(4u, 6837, &unk_101DD278);
  sub_10052310(4u, 6838, &unk_101DD27C);
  sub_10052310(1u, 6839, &unk_101DD280);
  sub_10052310(0x50u, 6840, &unk_101DCF98);
  sub_10052310(4u, 6841, &unk_101DD284);
  sub_10052310(4u, 6842, &unk_101DD288);
  sub_10052310(4u, 6843, &unk_101DD28C);
  sub_10052310(1u, 6844, &unk_101DD290);
  sub_10052310(0x360u, 6845, &unk_101DD294);
  sub_10052310(4u, 6846, &unk_101DD000);
  sub_10052310(4u, 6847, &unk_101DD008);
  result = 1;
  dword_1031FB44 = (int)&unk_101D53F8;
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10054160) --------------------------------------------------------
char __cdecl sub_10054160(int a1, int a2, int a3, int a4, _WORD *a5)
{
  bool v5; // zf@3
  signed int v6; // edx@6
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  void *v9; // ecx@8
  signed int v10; // ecx@18
  signed int v11; // edx@18
  double v12; // st7@18
  double v13; // st6@18
  double v14; // st5@18
  float v15; // ST10_4@18
  float v16; // ST08_4@18
  float v17; // ST04_4@18
  int v19; // [sp+1Ch] [bp-40h]@8
  unsigned int v20; // [sp+20h] [bp-3Ch]@6
  float v21; // [sp+24h] [bp-38h]@18
  float v22; // [sp+28h] [bp-34h]@6
  float v23; // [sp+2Ch] [bp-30h]@6
  int v24; // [sp+30h] [bp-2Ch]@3
  float v25; // [sp+34h] [bp-28h]@3
  int v26; // [sp+38h] [bp-24h]@3
  int v27; // [sp+3Ch] [bp-20h]@6
  float v28; // [sp+40h] [bp-1Ch]@6
  float v29; // [sp+44h] [bp-18h]@6
  float v30; // [sp+48h] [bp-14h]@17
  char v31; // [sp+4Ch] [bp-10h]@10

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v5 = *(_BYTE *)(a4 + 8) == 0;
    v25 = 15.0;
    v26 = -16777216;
    v24 = 4;
    if ( !v5 )
      v26 = *(_DWORD *)(a4 + 12);
    if ( *(_BYTE *)a4 )
    {
      v6 = *(_WORD *)(a3 + 2);
      v28 = *(float *)(a2 + 16);
      v27 = -1;
      v7 = *(_WORD *)a3;
      v29 = *(float *)(a2 + 20);
      v20 = v7;
      v8 = *(_DWORD *)(a4 + 4);
      v22 = (double)(signed int)v20;
      v20 = v8;
      v23 = (double)v6;
      if ( sub_10051FD0((void *)a4) == 1 )
        sub_1006E640((int *)&v20, v20);
      sub_10073910((int)&v19, v20);
      if ( sub_10051FA0(v9) == 1 )
      {
        if ( (_WORD)v19 )
        {
          if ( (signed __int16)v19 >= 12 )
          {
            if ( (_WORD)v19 == 12 )
              sprintf(&v31, "%02d:%02d:%02d%c", 12, BYTE2(v19), BYTE3(v19), 149);
            else
              sprintf(&v31, "%d:%02d:%02d%c", (signed __int16)v19 % 12, BYTE2(v19), BYTE3(v19), 149);
          }
          else
          {
            sprintf(&v31, "%d:%02d:%02d%c", (signed __int16)v19, BYTE2(v19), BYTE3(v19), 148);
          }
        }
        else
        {
          sprintf(&v31, "%02d:%02d:%02d%c", 12, BYTE2(v19), BYTE3(v19), 148);
        }
      }
      else
      {
        sprintf(&v31, "%02d:%02d:%02d", (signed __int16)v19, BYTE2(v19), BYTE3(v19));
      }
      v30 = 0.0;
      sub_10065670((int)&v31, (int)&v22);
    }
    else
    {
      v10 = *(_WORD *)(a2 + 4);
      v28 = 0.5;
      v11 = *(_WORD *)(a2 + 6);
      v29 = 0.5;
      v19 = v10;
      v20 = v11;
      v12 = (double)v10;
      v13 = *(float *)(a2 + 8);
      v27 = -256;
      v22 = v13 * 0.5 + v12;
      v14 = (double)v11;
      v23 = 0.5 * *(float *)(a2 + 12) + v14;
      v21 = v14 + *(float *)(a2 + 12);
      v15 = v21;
      v21 = v12 + *(float *)(a2 + 8);
      v16 = v14;
      v17 = v12;
      sub_10065780(v17, v16, v21, v15, 0);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (100543D0) --------------------------------------------------------
char __cdecl sub_100543D0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char *v5; // eax@1

  v5 = sub_1006ED10(*a4);
  return sub_10054440(a1, a2, a3, (int)v5, a5);
}

//----- (100543F0) --------------------------------------------------------
int __usercall sub_100543F0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (10054440) --------------------------------------------------------
char __cdecl sub_10054440(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_100543F0((int)&v8, a3, a2);
      sub_10065630(a1, a4, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_100543F0((int)&v8, a3, a2);
  sub_10065B70(a1, a4, v7);
  return 2;
}

//----- (100544C0) --------------------------------------------------------
__int16 __cdecl sub_100544C0(char a1)
{
  return word_100E3832[2 * sub_1006E440(&a1, 1u, (int)&unk_100E3830, 4, 5, 0)];
}
// 100E3832: using guessed type __int16 word_100E3832[];

//----- (100544F0) --------------------------------------------------------
_BYTE *__usercall sub_100544F0@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@1
  signed int v3; // ecx@1
  signed int v4; // eax@1
  double v5; // st7@1
  double v6; // st7@1
  signed int v7; // ST14_4@1
  signed int v8; // ST18_4@1
  float v9; // ST1C_4@1
  float v10; // ST0C_4@1
  float v11; // ST1C_4@1
  float v12; // ST04_4@1
  float v13; // ST00_4@1
  __int16 v14; // ax@1
  char *v15; // eax@1
  float v17; // [sp+20h] [bp-24h]@1
  float v18; // [sp+24h] [bp-20h]@1
  int v19; // [sp+28h] [bp-1Ch]@1
  float v20; // [sp+2Ch] [bp-18h]@1
  int v21; // [sp+30h] [bp-14h]@1
  int v22; // [sp+34h] [bp-10h]@1
  float v23; // [sp+38h] [bp-Ch]@1
  float v24; // [sp+3Ch] [bp-8h]@1
  float v25; // [sp+40h] [bp-4h]@1

  v21 = -16777216;
  v2 = sub_10065750(0);
  v20 = 15.0;
  v3 = *(_WORD *)(a2 + 6);
  v22 = v2;
  v4 = *(_WORD *)(a2 + 4);
  v23 = 0.5;
  v24 = 0.5;
  v5 = *(float *)(a2 + 8);
  v19 = 4;
  v17 = v5 * 0.5 + (double)v4;
  v6 = 0.5 * *(float *)(a2 + 12);
  *(_BYTE *)a1 = 0;
  v7 = *(_WORD *)(a2 + 6);
  v8 = *(_WORD *)(a2 + 4);
  v18 = v6 + (double)v3;
  v25 = 0.0;
  v9 = *(float *)(a2 + 12) + (double)v7;
  v10 = v9;
  v11 = (double)v8 + *(float *)(a2 + 8);
  v12 = (double)v7;
  v13 = (double)v8;
  sub_10065780(v13, v12, v11, v10, 0);
  v14 = sub_100544C0(*(_BYTE *)(a1 + 1));
  v15 = sub_1006ED10(v14);
  return sub_10065BE0((int)v15, (int)&v17, 1);
}

//----- (100545E0) --------------------------------------------------------
char __cdecl sub_100545E0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@1
  bool v6; // zf@3
  signed int v7; // edx@4
  signed int v8; // eax@4
  signed int v9; // ST24_4@4
  int v10; // eax@4
  double v11; // st7@7
  void *v12; // ebp@7
  char *v14; // [sp-Ch] [bp-5Ch]@13
  char *v15; // [sp-4h] [bp-54h]@13
  float v16; // [sp+18h] [bp-38h]@10
  float v17; // [sp+18h] [bp-38h]@12
  float v18; // [sp+20h] [bp-30h]@4
  float v19; // [sp+24h] [bp-2Ch]@4
  int v20; // [sp+28h] [bp-28h]@3
  float v21; // [sp+2Ch] [bp-24h]@3
  int v22; // [sp+30h] [bp-20h]@3
  int v23; // [sp+34h] [bp-1Ch]@4
  float v24; // [sp+38h] [bp-18h]@4
  float v25; // [sp+3Ch] [bp-14h]@4
  float v26; // [sp+40h] [bp-10h]@3
  char v27; // [sp+44h] [bp-Ch]@13

  v5 = *a5 - 32802;
  if ( *a5 == 32802 || (v5 = *a5 - 32888, *a5 == 32888) )
  {
    v6 = *(_BYTE *)a4 == 0;
    v21 = 15.0;
    v22 = -16777216;
    v26 = 0.0;
    v20 = 4;
    if ( v6 )
      goto LABEL_21;
    v7 = *(_WORD *)a3;
    v8 = *(_WORD *)(a3 + 2);
    v24 = *(float *)(a2 + 16);
    v25 = *(float *)(a2 + 20);
    v23 = -1;
    v9 = v8;
    v10 = *(_BYTE *)(a2 + 24) - 1;
    v18 = (double)v7;
    v19 = (double)v9;
    if ( v10 && (v10 == 1 || sub_10051F50(v5) == 4) )
    {
      v11 = *(float *)(a4 + 4);
      v12 = &unk_100E386C;
    }
    else
    {
      v11 = *(float *)(a4 + 4) * 1.799999952316284;
      v12 = &unk_100E3868;
      if ( *(_BYTE *)(a4 + 1) != 3 )
        v11 = v11 + 32.0;
    }
    v16 = v11;
    if ( v16 > 999.0 || v16 < -999.0 )
    {
LABEL_21:
      sub_100544F0(a4, a2);
    }
    else
    {
      v17 = sub_10095970(v16, 1.0);
      if ( *(_BYTE *)(a4 + 1) == 3 )
      {
        v15 = "%+.0f%s";
        v14 = &v27;
      }
      else
      {
        v15 = "%.0f%s";
        v14 = &v27;
      }
      sub_10064B00(v14, 6u, v15, v17, v12);
      sub_10065670((int)&v27, (int)&v18);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (10054760) --------------------------------------------------------
int __usercall sub_10054760@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned __int16 v3; // si@1
  unsigned __int16 v4; // di@1
  signed int v5; // ebp@2
  signed int v6; // ebx@2
  float v7; // ST58_4@2
  __int16 v8; // ax@2
  bool v9; // dl@2
  float v10; // ST50_4@2
  double v11; // st6@2
  double v12; // st4@7
  double v13; // st5@9
  double v14; // st4@10
  double v15; // st6@10
  float v16; // ST60_4@10
  float v17; // ST60_4@14
  float v18; // ST4C_4@16
  float v19; // ST50_4@16
  float v20; // ST48_4@16
  float v21; // ST50_4@16
  float v22; // ST60_4@16
  float v23; // ST60_4@16
  float v24; // [sp+24h] [bp-44h]@2
  float v25; // [sp+28h] [bp-40h]@2
  float v26; // [sp+2Ch] [bp-3Ch]@2
  float v27; // [sp+2Ch] [bp-3Ch]@9
  float v28; // [sp+30h] [bp-38h]@6
  float v29; // [sp+30h] [bp-38h]@13
  float v30; // [sp+34h] [bp-34h]@2
  float v31; // [sp+38h] [bp-30h]@2
  float v32; // [sp+3Ch] [bp-2Ch]@2
  float v33; // [sp+40h] [bp-28h]@2
  signed int v34; // [sp+44h] [bp-24h]@2
  char v35; // [sp+4Ch] [bp-1Ch]@16
  float v36; // [sp+50h] [bp-18h]@16
  float v37; // [sp+54h] [bp-14h]@16
  float v38; // [sp+58h] [bp-10h]@16
  float v39; // [sp+5Ch] [bp-Ch]@16
  float v40; // [sp+60h] [bp-8h]@16
  float v41; // [sp+64h] [bp-4h]@16

  v3 = *(_WORD *)a2;
  v4 = *(_WORD *)(a2 + 2);
  if ( *(_WORD *)a2 > v4 )
  {
    v5 = -8355712;
    v6 = -8355712;
    v24 = (double)*(_WORD *)result;
    v25 = *(float *)(a3 + 4) + v24;
    v32 = (double)*(_WORD *)(result + 2);
    v7 = *(float *)(a3 + 8) + v32;
    v8 = *(_WORD *)(a2 + 4);
    v33 = v7 - 7.0;
    v34 = *(_WORD *)(a2 + 4);
    v9 = v34 == (signed __int16)(v3 - v4 + 1) - 1;
    v10 = v32 + 7.0;
    v31 = v10 + 3.0;
    v30 = v33 - 3.0;
    v11 = v31;
    v26 = v30 - v31;
    if ( !v8 )
      v5 = -12566464;
    if ( v9 )
      v6 = -12566464;
    v28 = (double)v4 / (double)v3 * v26;
    if ( v28 > 3.0 )
      v12 = v28;
    else
      v12 = (float)3.0;
    v13 = v12;
    v27 = (v26 - v12) * (double)v34 / (double)((signed __int16)(v3 - v4 + 1) - 1) + v11;
    if ( v8 == 0 )
    {
      v15 = 1.0;
    }
    else
    {
      v14 = v11 + 1.0;
      v15 = 1.0;
      v16 = v14;
      if ( v16 >= (double)v27 )
        v27 = v14;
    }
    v29 = v13 + v27;
    if ( !v9 )
    {
      v17 = v30 - v15;
      if ( v17 <= (double)v29 )
        v29 = v30 - v15;
    }
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(v5);
    v36 = v24;
    v37 = v32;
    v35 = 0;
    v38 = v25 - v24;
    v39 = 7.0;
    v40 = 0.0;
    v41 = 0.0;
    sub_10064CF0(5u, (int)&v35);
    j_gdi_pvg_color_u32(v6);
    v37 = v33;
    v35 = 2;
    sub_10064CF0(5u, (int)&v35);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    sub_1008C2F0(v24, v31);
    sub_1008C2F0(v25, v31);
    sub_1008C2F0(v25, v30);
    sub_1008C2F0(v24, v30);
    j_gdi_pvg_end();
    sub_10064BF0(9, v24, v31, v25, v30, -8355712);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-8355712);
    sub_1008C2F0(v24, v27);
    sub_1008C2F0(v25, v27);
    sub_1008C2F0(v25, v29);
    sub_1008C2F0(v24, v29);
    j_gdi_pvg_end();
    sub_1008C110(1.0);
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    sub_1008C2F0(v24, v29);
    sub_1008C2F0(v24, v27);
    sub_1008C2F0(v25, v27);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-14671840);
    v18 = v27 + 1.0;
    sub_1008C2F0(v25, v18);
    sub_1008C2F0(v25, v29);
    v19 = v24 + 1.0;
    sub_1008C2F0(v19, v29);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-1);
    v20 = v29 - 1.0;
    sub_1008C2F0(v19, v20);
    sub_1008C2F0(v19, v18);
    v21 = v25 - 1.0;
    sub_1008C2F0(v21, v18);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    v22 = v27 + 2.0;
    sub_1008C2F0(v21, v22);
    sub_1008C2F0(v21, v20);
    v23 = v24 + 2.0;
    sub_1008C2F0(v23, v20);
    j_gdi_pvg_end();
    result = j_gdi_pvg_disable(35);
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10054C30) --------------------------------------------------------
char __cdecl sub_10054C30(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == -32648 )
  {
    sub_10054760(a3, a4, a2);
    result = 2;
  }
  return result;
}

//----- (10054C60) --------------------------------------------------------
char __cdecl sub_10054C60(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@3
  signed int v6; // ecx@4
  signed int v7; // edx@4
  signed int v8; // eax@4
  float v9; // ST1C_4@5
  float v10; // ST20_4@5
  double v11; // st7@5
  float v12; // ST0C_4@7
  float v13; // [sp+4h] [bp-24h]@5
  float v14; // [sp+Ch] [bp-1Ch]@4
  float v15; // [sp+10h] [bp-18h]@4
  float v16; // [sp+14h] [bp-14h]@4
  float v17; // [sp+18h] [bp-10h]@4
  float v18; // [sp+1Ch] [bp-Ch]@4
  float v19; // [sp+20h] [bp-8h]@4
  float v20; // [sp+24h] [bp-4h]@4
  float v21; // [sp+3Ch] [bp+14h]@4

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v7 = *(_WORD *)a3;
    v14 = *(float *)(a2 + 20) + (double)v6;
    v16 = (double)v7;
    v21 = *(float *)(a2 + 16) + (double)v7;
    v15 = (double)v6;
    v20 = v14 - *(float *)(a2 + 24);
    v18 = *(float *)(a2 + 24) + v16;
    v19 = v21 - *(float *)(a2 + 24);
    v17 = *(float *)(a2 + 24) + v15;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v8 = sub_10065D00(*(_DWORD *)(a2 + 8));
    j_gdi_pvg_color_u32(v8);
    if ( 1.0 == *(float *)(a2 + 24) )
    {
      j_gdi_pvg_begin(66);
      v9 = v15 + 0.5;
      v10 = v16 + 0.5;
      sub_1008C2F0(v10, v9);
      sub_1008C2F0(v21, v9);
      sub_1008C2F0(v21, v14);
      v13 = v14;
      v11 = v10;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_1008C2F0(v16, v15);
      sub_1008C2F0(v18, v17);
      sub_1008C2F0(v21, v15);
      sub_1008C2F0(v19, v17);
      sub_1008C2F0(v21, v14);
      sub_1008C2F0(v19, v20);
      sub_1008C2F0(v16, v14);
      sub_1008C2F0(v18, v20);
      sub_1008C2F0(v16, v15);
      v13 = v17;
      v11 = v18;
    }
    v12 = v11;
    sub_1008C2F0(v12, v13);
    j_gdi_pvg_end();
    if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 12));
      sub_1008C2F0(v18, v17);
      sub_1008C2F0(v19, v17);
      sub_1008C2F0(v19, v20);
      sub_1008C2F0(v18, v20);
      j_gdi_pvg_end();
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10054EE0) --------------------------------------------------------
BOOL __usercall sub_10054EE0@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi@1

  v2 = a1 + 24 * *(_DWORD *)(a2 + 32) + 28;
  return strncmp((const char *)a2, (const char *)(a2 + 8), 8u) || *(_DWORD *)(v2 + 12) != *(_DWORD *)(a2 + 16);
}

//----- (10054F20) --------------------------------------------------------
int __usercall sub_10054F20@<eax>(int result@<eax>)
{
  float *v1; // ecx@1

  v1 = (float *)(dword_1031FB44 + 9008);
  *(float *)(result + 49844) = *(float *)(dword_1031FB44 + 9008);
  *(float *)(result + 49880) = *v1;
  *(float *)(result + 49916) = *(float *)(dword_1031FB44 + 9012);
  *(float *)(result + 49952) = *(float *)(dword_1031FB44 + 9016);
  *(float *)(result + 49988) = *(float *)(dword_1031FB44 + 9020);
  *(float *)(result + 50024) = *(float *)(dword_1031FB44 + 9024);
  *(float *)(result + 50060) = *(float *)(dword_1031FB44 + 9028);
  *(float *)(result + 50096) = *(float *)(dword_1031FB44 + 9032);
  *(float *)(result + 50132) = *(float *)(dword_1031FB44 + 9036);
  *(float *)(result + 50168) = *(float *)(dword_1031FB44 + 9040);
  *(float *)(result + 50204) = *(float *)(dword_1031FB44 + 9044);
  *(float *)(result + 50240) = *(float *)(dword_1031FB44 + 9172);
  *(float *)(result + 50276) = *(float *)(dword_1031FB44 + 9176);
  *(float *)(result + 50312) = *(float *)(dword_1031FB44 + 9180);
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10055020) --------------------------------------------------------
int __usercall sub_10055020@<eax>(int result@<eax>)
{
  float *v1; // ecx@1

  v1 = (float *)(dword_1031FB44 + 7204);
  *(float *)(result + 49844) = *(float *)(dword_1031FB44 + 7204);
  *(float *)(result + 49880) = *v1;
  *(float *)(result + 49916) = *(float *)(dword_1031FB44 + 7208);
  *(float *)(result + 49952) = *(float *)(dword_1031FB44 + 7212);
  *(float *)(result + 49988) = *(float *)(dword_1031FB44 + 7216);
  *(float *)(result + 50024) = *(float *)(dword_1031FB44 + 7220);
  *(float *)(result + 50060) = *(float *)(dword_1031FB44 + 7224);
  *(float *)(result + 50096) = *(float *)(dword_1031FB44 + 7228);
  *(float *)(result + 50132) = *(float *)(dword_1031FB44 + 7232);
  *(float *)(result + 50168) = *(float *)(dword_1031FB44 + 7236);
  *(float *)(result + 50204) = *(float *)(dword_1031FB44 + 7240);
  *(float *)(result + 50240) = *(float *)(dword_1031FB44 + 7368);
  *(float *)(result + 50276) = *(float *)(dword_1031FB44 + 7372);
  *(float *)(result + 50312) = *(float *)(dword_1031FB44 + 7376);
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10055120) --------------------------------------------------------
#error "10055120: function frame is wrong (funcsize=0)"

//----- (10055E70) --------------------------------------------------------
int __usercall sub_10055E70@<eax>(int a1@<ebx>, int a2@<edi>, int *a3)
{
  double v3; // st7@1
  int v4; // esi@1
  int v5; // ST24_4@1
  double v6; // ST5C_8@1
  float v7; // ST2C_4@1
  double v8; // ST64_8@1
  float v9; // ST28_4@1
  float v10; // ST44_4@1
  double v11; // st7@1
  float v12; // ST3C_4@1
  float v13; // ST54_4@1
  float v14; // ST50_4@1
  double v15; // st7@1
  float v16; // ST54_4@1
  double v17; // st7@1
  double v18; // st6@1
  double v19; // st7@1
  double v20; // st6@1
  float v21; // ST5C_4@4
  float v22; // ST44_4@1
  float v23; // ST44_4@1
  float v24; // ST3C_4@1
  int v25; // esi@1
  int v26; // ST24_4@3
  float v27; // ST54_4@3
  float v28; // ST54_4@3
  int v29; // esi@4
  float v30; // ST54_4@4
  float v31; // ST54_4@4
  float v32; // ST54_4@4
  float v33; // ST04_4@4
  float v34; // ST54_4@4
  int v35; // esi@4
  float v36; // ST54_4@4
  float v37; // ST54_4@4
  int v38; // ST24_4@6
  float v39; // ST5C_4@6
  float v40; // ST5C_4@6
  int v41; // esi@7
  float v42; // ST5C_4@7
  float v43; // ST5C_4@7
  float v44; // ST04_4@7
  float v45; // ST5C_4@7
  float v46; // ST5C_4@7
  float v47; // ST5C_4@7
  float v48; // ST5C_4@7
  float v49; // ST5C_4@7
  float v50; // ST5C_4@7
  float v51; // ST5C_4@7
  float v52; // ST5C_4@7
  float v53; // ST5C_4@7
  float v54; // ST04_4@7
  float v55; // ST5C_4@7
  float v56; // ST5C_4@7
  float v57; // ST04_4@7
  float v58; // ST5C_4@7
  int v59; // esi@7
  long double v60; // st7@7
  float v61; // ST5C_4@9
  float v62; // ST5C_4@9
  float v63; // ST04_4@9
  float v64; // ST5C_4@9
  float v65; // ST5C_4@9
  float v66; // ST5C_4@10
  float v67; // ST5C_4@10
  float v68; // ST04_4@10
  float v69; // ST5C_4@10
  float v70; // ST5C_4@10
  int v71; // esi@10
  long double v72; // st7@10
  float v73; // ST5C_4@12
  float v74; // ST5C_4@12
  float v75; // ST04_4@12
  float v76; // ST5C_4@12
  float v77; // ST5C_4@12
  float v78; // ST5C_4@13
  float v79; // ST04_4@13
  float v80; // ST5C_4@13
  int result; // eax@13
  int v82; // esi@13
  int v83; // [sp+24h] [bp-50h]@2
  int v84; // [sp+24h] [bp-50h]@5
  float v85; // [sp+28h] [bp-4Ch]@1
  float v86; // [sp+28h] [bp-4Ch]@4
  float v87; // [sp+2Ch] [bp-48h]@1
  float v88; // [sp+2Ch] [bp-48h]@4
  float v89; // [sp+34h] [bp-40h]@1
  float v90; // [sp+38h] [bp-3Ch]@1
  int v91; // [sp+3Ch] [bp-38h]@8
  int v92; // [sp+3Ch] [bp-38h]@11
  long double v93; // [sp+44h] [bp-30h]@1
  double v94; // [sp+44h] [bp-30h]@4
  double v95; // [sp+44h] [bp-30h]@7
  long double v96; // [sp+44h] [bp-30h]@10
  float v97; // [sp+50h] [bp-24h]@1
  double v98; // [sp+54h] [bp-20h]@4
  double v99; // [sp+64h] [bp-10h]@4
  double v100; // [sp+6Ch] [bp-8h]@4

  v3 = *(float *)(a2 + 51652) - 1.0;
  v4 = *a3;
  *(_DWORD *)(a2 + 49188) = 68;
  *(float *)&v5 = v3;
  *(_DWORD *)(a2 + 49192) = v4;
  v6 = *(float *)(a2 + 20) - *(float *)(a2 + 8);
  v7 = v6;
  v8 = *(float *)(a2 + 24) - *(float *)(a2 + 12);
  v9 = v8;
  v90 = *(float *)(a2 + 12);
  v89 = v90 - *(float *)(a2 + 4) + *(float *)(a2 + 16);
  v10 = sqrt(v9 * v9 + v7 * v7);
  v11 = v90 * v90;
  v12 = (v11 - v89 * v89 + v10 * v10) / (v10 + v10);
  v13 = sqrt(v11 - v12 * v12);
  v14 = v12 * v7 / v10 + *(float *)(a2 + 8);
  v87 = v14 - v8 * v13 / v10;
  v15 = v13;
  v16 = v12 * v9 / v10 + v90;
  v85 = v16 + v15 * v6 / v10;
  v17 = v85 - v90;
  v18 = v87 - *(float *)(a2 + 8);
  sub_1009814A(v17);
  v97 = v17 * 180.0 / 3.1415926535898 - 90.0;
  v19 = v85 - *(float *)(a2 + 24);
  v20 = v87 - *(float *)(a2 + 20);
  sub_1009814A(v19);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 8), 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(v87, v85, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 41.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v22 = *(float *)&v5 + 1.0;
  sub_1008CCA0(v22, 31.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(v22, 31.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v23 = *(float *)&v5 + 3.0;
  sub_1008CCA0(v23, 24.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(v23, 24.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v24 = *(float *)&v5 + 4.0;
  sub_1008CCA0(v24, 14.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(v24, 14.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_1008CCA0(v24, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4);
  v25 = v4 + 1;
  v93 = (v97 + 90.0) * 0.01745329251994333;
  if ( v93 < 4.7123889803847 )
  {
    v83 = a1 + 24 * v25;
    do
    {
      sub_1008CCA0(v87, v85, 0.0, 0.0, 0.0, -14671840, v83);
      v26 = v83 + 24;
      sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, v26);
      v26 += 24;
      v27 = cos(v93);
      v87 = v27 * v90 + *(float *)(a2 + 8);
      v28 = sin(v93);
      v85 = v28 * v90 + *(float *)(a2 + 12);
      sub_1008CCA0(v87, v85, 0.0, 0.0, 0.0, -14671840, v26);
      v83 = v26 + 24;
      v25 += 3;
      v93 = v93 + 0.08726646259971667;
    }
    while ( v93 < 4.7123889803847 );
  }
  sub_1008CCA0(v87, v85, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v25);
  v29 = v25 + 1;
  sub_1008CCA0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v29++);
  v30 = sin(4.7123889803847);
  v99 = v30 * v90;
  v31 = cos(4.7123889803847);
  v100 = v31 * v90;
  v32 = *(float *)(a2 + 12) + v99;
  v33 = v32;
  v34 = v100 + *(float *)(a2 + 8);
  sub_1008CCA0(v34, v33, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v29);
  v94 = 1.5707963267949;
  v35 = v29 + 1;
  v36 = cos(1.5707963267949);
  v88 = v36 * v89 + *(float *)(a2 + 20);
  v37 = sin(1.5707963267949);
  v86 = v37 * v89 + *(float *)(a2 + 24);
  v21 = v19 * 180.0 / 3.1415926535898 - 90.0;
  v98 = (v21 + 90.0) * 0.01745329251994333;
  if ( v98 > 1.5707963267949 )
  {
    v84 = a1 + 24 * v35;
    do
    {
      sub_1008CCA0(v88, v86, 0.0, 0.0, 0.0, -14671840, v84);
      v38 = v84 + 24;
      sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, v38);
      v38 += 24;
      v39 = cos(v94);
      v88 = v39 * v89 + *(float *)(a2 + 20);
      v40 = sin(v94);
      v86 = v40 * v89 + *(float *)(a2 + 24);
      sub_1008CCA0(v88, v86, 0.0, 0.0, 0.0, -14671840, v38);
      v84 = v38 + 24;
      v35 += 3;
      v94 = v94 + 0.08726646259971667;
    }
    while ( v94 < v98 );
  }
  sub_1008CCA0(v88, v86, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v35);
  v41 = v35 + 1;
  sub_1008CCA0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v42 = sin(v98);
  v43 = v42 * v89 + *(float *)(a2 + 24);
  v44 = v43;
  v45 = cos(v98);
  v46 = v45 * v89 + *(float *)(a2 + 20);
  sub_1008CCA0(v46, v44, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  *(_DWORD *)(a2 + 49196) = v41 - *(_DWORD *)(a2 + 49192);
  *(_DWORD *)(a2 + 49200) = 67;
  *(_DWORD *)(a2 + 49204) = v41;
  v47 = *(float *)(a2 + 8) - 1.5;
  sub_1008CCA0(v47, -0.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v48 = *(float *)(a2 + 51652) + 4.0 - 1.5;
  sub_1008CCA0(v48, -0.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v49 = *(float *)(a2 + 51652) + 4.0 - 1.5;
  sub_1008CCA0(v49, 13.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v50 = *(float *)(a2 + 51652) + 3.0 - 1.5;
  sub_1008CCA0(v50, 23.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v51 = *(float *)(a2 + 51652) + 1.0 - 1.5;
  sub_1008CCA0(v51, 30.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v52 = *(float *)(a2 + 51652) - 1.5;
  sub_1008CCA0(v52, 40.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v53 = *(float *)(a2 + 51656) - 0.5;
  v54 = v53;
  v55 = *(float *)(a2 + 51652) - 1.5;
  sub_1008CCA0(v55, v54, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v56 = *(float *)(a2 + 51656) - 0.5;
  v57 = v56;
  v58 = *(float *)(a2 + 20) - 1.5;
  sub_1008CCA0(v58, v57, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41);
  v59 = v41 + 1;
  v95 = 1.658062789394617;
  v60 = 1.658062789394617;
  if ( v98 > 1.658062789394617 )
  {
    v91 = a1 + 24 * v59;
    do
    {
      v61 = sin(v60);
      v62 = v61 * v89 + *(float *)(a2 + 24);
      v63 = v62;
      v64 = cos(v95);
      v65 = v64 * v89 + *(float *)(a2 + 20);
      sub_1008CCA0(v65, v63, 0.0, 0.0, 0.0, -14671840, v91);
      v91 += 24;
      v60 = v95 + 0.08726646259971667;
      ++v59;
      v95 = v60;
    }
    while ( v98 > v60 );
  }
  v66 = sin(v98);
  v67 = v66 * v89 + *(float *)(a2 + 24);
  v68 = v67;
  v69 = cos(v98);
  v70 = v69 * v89 + *(float *)(a2 + 20);
  sub_1008CCA0(v70, v68, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v59);
  v71 = v59 + 1;
  v72 = (v97 + 5.0 + 90.0) * 0.01745329251994333;
  v96 = v72;
  if ( v72 < 4.7123889803847 )
  {
    v92 = a1 + 24 * v71;
    do
    {
      v73 = sin(v72);
      v74 = v73 * v90 + *(float *)(a2 + 12);
      v75 = v74;
      v76 = cos(v96);
      v77 = v76 * v90 + *(float *)(a2 + 8);
      sub_1008CCA0(v77, v75, 0.0, 0.0, 0.0, -14671840, v92);
      v92 += 24;
      v72 = v96 + 0.08726646259971667;
      ++v71;
      v96 = v72;
    }
    while ( v72 < 4.7123889803847 );
  }
  v78 = *(float *)(a2 + 12) + v99;
  v79 = v78;
  v80 = *(float *)(a2 + 8) + v100;
  result = sub_1008CCA0(v80, v79, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v71);
  v82 = v71 + 1;
  *(_DWORD *)(a2 + 49208) = v82 - *(_DWORD *)(a2 + 49204);
  *a3 = v82;
  return result;
}
// 1009814A: using guessed type double __usercall sub_1009814A@<st0>(double@<st0>);

//----- (10056FD0) --------------------------------------------------------
int __usercall sub_10056FD0@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, _DWORD *a8)
{
  _DWORD *v8; // ebp@1
  int v9; // esi@1
  int v10; // eax@1
  float v11; // ST2C_4@1
  float v12; // ST24_4@1
  float v13; // ST28_4@1
  float v14; // ST38_4@1
  double v15; // ST48_8@1
  float v16; // ST34_4@1
  float v17; // ST38_4@1
  double v18; // ST58_8@1
  float v19; // ST30_4@1
  float v20; // ST3C_4@1
  double v21; // ST50_8@1
  float v22; // ST38_4@1
  float v23; // ST3C_4@1
  double v24; // ST3C_8@1
  float v25; // ST30_4@1
  int result; // eax@1
  float v27; // [sp+6Ch] [bp+Ch]@1
  float v28; // [sp+6Ch] [bp+Ch]@1
  float v29; // [sp+74h] [bp+14h]@1
  float v30; // [sp+74h] [bp+14h]@1
  float v31; // [sp+78h] [bp+18h]@1

  v8 = a8;
  v9 = *a8;
  v10 = a2 + 24 * *a8;
  v31 = a3 + a7;
  v11 = a4 + a7;
  v12 = a5 - a7;
  v13 = a6 - a7;
  sub_1008CCA0(v31, a4, 0.0, 0.0, 0.0, a1, v10);
  sub_1008CCA0(v12, a4, 0.0, 0.0, 0.0, a1, a2 + 24 * ++v9);
  ++v9;
  v14 = sin(1.0472);
  v15 = v14 * a7;
  v16 = v11 - v15;
  v17 = cos(1.0472);
  v18 = v17 * a7;
  v19 = v18 + v12;
  sub_1008CCA0(v19, v16, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v20 = sin(0.5236);
  v21 = v20 * a7;
  v22 = v11 - v21;
  v23 = cos(0.5236);
  v24 = v23 * a7;
  v29 = v24 + v12;
  sub_1008CCA0(v29, v22, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(a5, v11, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(a5, v13, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v27 = v13 + v15;
  sub_1008CCA0(v19, v27, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v25 = v13 + v21;
  sub_1008CCA0(v29, v25, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(v12, a6, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(v31, a6, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v30 = v31 - v18;
  sub_1008CCA0(v30, v27, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v28 = v31 - v24;
  sub_1008CCA0(v28, v25, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(a3, v13, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(a3, v11, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(v30, v16, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_1008CCA0(v28, v22, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  result = sub_1008CCA0(v31, a4, 0.0, 0.0, 0.0, a1, a2 + 24 * v9);
  *v8 = v9 + 1;
  return result;
}

//----- (10057450) --------------------------------------------------------
int __usercall sub_10057450@<eax>(int a1@<ebx>, int a2, float a3, float a4, float a5, float a6, float a7, int *a8, int a9)
{
  int v9; // esi@1
  double v10; // st7@2
  int v11; // edi@2
  long double v12; // ST34_8@3
  float v13; // ST24_4@3
  float v14; // ST28_4@3
  float v15; // ST04_4@3
  int v16; // edi@3
  float v17; // ST04_4@3
  long double v18; // ST34_8@4
  float v19; // ST24_4@4
  float v20; // ST28_4@4
  float v21; // ST04_4@4
  int v22; // esi@4
  float v23; // ST04_4@4
  int result; // eax@4
  float v25; // [sp+2Ch] [bp-18h]@1
  float v26; // [sp+30h] [bp-14h]@1

  v9 = *a8;
  v26 = a5 - 5.0;
  *(_DWORD *)a2 = 69;
  *(_DWORD *)(a2 + 4) = v9;
  v25 = a6;
  if ( a7 > (double)a6 )
  {
    v10 = a6;
    v11 = a9 + 24 * v9;
    do
    {
      v12 = (v10 + 90.0) * 0.01745329251994333;
      v13 = sin(v12);
      v14 = cos(v12);
      *(float *)&v12 = v13 * a5 + a4;
      v15 = *(float *)&v12;
      *(float *)&v12 = a5 * v14 + a3;
      sub_1008CCA0(*(float *)&v12, v15, 0.0, 0.0, 0.0, a1, v11);
      v16 = v11 + 24;
      *(float *)&v12 = v13 * v26 + a4;
      v17 = *(float *)&v12;
      *(float *)&v12 = v26 * v14 + a3;
      sub_1008CCA0(*(float *)&v12, v17, 0.0, 0.0, 0.0, a1, v16);
      v9 += 2;
      v11 = v16 + 24;
      v25 = v25 + 5.0;
      v10 = v25;
    }
    while ( v25 < (double)a7 );
  }
  v18 = (a7 + 90.0) * 0.01745329251994333;
  v19 = sin(v18);
  v20 = cos(v18);
  *(float *)&v18 = v19 * a5 + a4;
  v21 = *(float *)&v18;
  *(float *)&v18 = a5 * v20 + a3;
  sub_1008CCA0(*(float *)&v18, v21, 0.0, 0.0, 0.0, a1, a9 + 24 * v9);
  v22 = v9 + 1;
  *(float *)&v18 = v19 * v26 + a4;
  v23 = *(float *)&v18;
  *(float *)&v18 = v26 * v20 + a3;
  sub_1008CCA0(*(float *)&v18, v23, 0.0, 0.0, 0.0, a1, a9 + 24 * v22);
  result = a2;
  *(_DWORD *)(a2 + 8) = ++v22 - *(_DWORD *)(a2 + 4);
  *a8 = v22;
  return result;
}

//----- (10057680) --------------------------------------------------------
int __usercall sub_10057680@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, int a7)
{
  _DWORD *v7; // ebp@1
  int v8; // esi@1
  double v9; // ST24_8@1
  int v10; // ST18_4@1
  double v11; // ST2C_8@1
  int v12; // ecx@1
  int result; // eax@1
  float v14; // [sp+38h] [bp+4h]@1
  float v15; // [sp+3Ch] [bp+8h]@1
  float v16; // [sp+44h] [bp+10h]@1
  int v17; // [sp+48h] [bp+14h]@1

  v7 = (_DWORD *)a7;
  v8 = *(_DWORD *)a7;
  v9 = a6 * 0.5;
  v10 = a2 + 24 * *(_DWORD *)a7;
  *(float *)&v17 = a4 - v9;
  *(_DWORD *)a1 = 64;
  *(_DWORD *)(a1 + 4) = v8;
  v11 = 0.5 * a5;
  v16 = a3 - v11;
  sub_1008CCA0(v16, *(float *)&v17, 0.0, 0.0, 0.0, -65536, v10);
  ++v8;
  v15 = a4 + v9;
  v14 = a3 + v11;
  sub_1008CCA0(v14, v15, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  sub_1008CCA0(v16, v15, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  sub_1008CCA0(v14, *(float *)&v17, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  v12 = v8 - *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 12) = 68;
  *(_DWORD *)(a1 + 8) = v12;
  *(_DWORD *)(a1 + 16) = v8;
  sub_1008CCA0(v16, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_1008CCA0(v16, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_1008CCA0(v14, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_1008CCA0(v14, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_1008CCA0(v16, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  result = sub_1008CCA0(v14, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  *(_DWORD *)(a1 + 20) = v8 - *(_DWORD *)(a1 + 16);
  *v7 = v8;
  return result;
}

//----- (10057920) --------------------------------------------------------
unsigned __int8 __usercall sub_10057920@<al>(int a1@<ebx>, _DWORD *a2@<edi>, int a3, int a4, int a5, float a6, float a7, float a8, float a9)
{
  double v9; // st7@1
  int v10; // esi@1
  double v11; // st6@1
  double v12; // st5@1
  double v13; // st6@1
  char *v14; // esi@1
  double v15; // st6@1
  unsigned __int8 v16; // al@2
  bool v17; // zf@2
  char *v18; // ecx@2
  double v19; // st4@3
  unsigned __int8 result; // al@5
  int v21; // esi@8
  float v22; // ST08_4@8
  char *v23; // eax@8
  float v24; // [sp+24h] [bp-4h]@1
  int v25; // [sp+2Ch] [bp+4h]@2
  int v26; // [sp+2Ch] [bp+4h]@8
  int v27; // [sp+2Ch] [bp+4h]@8
  float v28; // [sp+38h] [bp+10h]@5
  float v29; // [sp+3Ch] [bp+14h]@1
  float v30; // [sp+40h] [bp+18h]@5
  float v31; // [sp+44h] [bp+1Ch]@1

  v24 = *(float *)a5;
  v9 = v24;
  v10 = *(_DWORD *)(a5 + 8);
  v11 = v24 * a9;
  v12 = a7;
  v29 = (double)(signed int)(a7 - *(float *)(v10 + 8200) * v24 + v11);
  v13 = v11 + v12 + *(float *)(v10 + 8204) * v24;
  v14 = (char *)a3;
  v31 = (double)(signed int)v13;
  v15 = 0.0;
  if ( a8 != 0.0 )
  {
    v16 = *(_BYTE *)a3;
    v17 = *(_BYTE *)a3 == 0;
    *(float *)&v25 = 0.0;
    v18 = v14;
    if ( !v17 )
    {
      do
      {
        ++v18;
        v19 = *(float *)(32 * v16 + *(_DWORD *)(a5 + 8) + 16);
        v16 = *v18;
        *(float *)&v25 = v19 * v9 + *(float *)&v25;
      }
      while ( *v18 );
    }
    a6 = a6 - a8 * *(float *)&v25;
  }
  v30 = *(float *)&v14;
  result = *v14;
  v28 = (double)(signed int)a6 + 0.5;
  if ( *v14 )
  {
    while ( 1 )
    {
      v21 = *(_DWORD *)(a5 + 8) + 32 * result;
      *(float *)&v26 = v9 * *(float *)(v21 + 16);
      v22 = v15;
      sub_1008CCA0(v28, v31, v22, *(float *)v21, *(float *)(v21 + 12), a4, a1 + 24 * *a2);
      sub_1008CCA0(v28, v29, 0.0, *(float *)v21, *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 1));
      *(float *)&v27 = *(float *)&v26 + v28;
      sub_1008CCA0(*(float *)&v27, v31, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 12), a4, a1 + 24 * (*a2 + 2));
      sub_1008CCA0(*(float *)&v27, v31, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 12), a4, a1 + 24 * (*a2 + 3));
      sub_1008CCA0(v28, v29, 0.0, *(float *)v21, *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 4));
      sub_1008CCA0(*(float *)&v27, v29, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 5));
      v28 = *(float *)&v27;
      *a2 += 6;
      v23 = (char *)(LODWORD(v30) + 1);
      v30 = *(float *)&v23;
      result = *v23;
      if ( !result )
        break;
      v9 = v24;
      v15 = 0.0;
    }
  }
  return result;
}

//----- (10057BC0) --------------------------------------------------------
bool __usercall sub_10057BC0@<al>(int a1@<esi>)
{
  bool v1; // bl@1
  double v2; // st7@2
  float v4; // [sp+4h] [bp-10h]@1
  float v5; // [sp+8h] [bp-Ch]@1
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@4

  v5 = 9.8999998e24;
  v4 = 9.8999998e24;
  v1 = 0;
  if ( sub_10051B40(&v6) )
  {
    v2 = -40.0;
    if ( v6 > -40.0 )
      v2 = v6;
    v5 = v2;
    v5 = sqrt((v5 + 273.0) / 288.0);
    v7 = *(float *)(a1 + 51836);
    if ( v7 != 9.8999998e24 )
    {
      v4 = v7 / v5;
      v1 = *(float *)(dword_1031FB44 + 7404) < (double)v4 && *(float *)(dword_1031FB44 + 7396) > (double)v6;
    }
  }
  sub_1008CB30(9010, (int)&v4, 4);
  *(float *)(a1 + 51716) = v5;
  return v1;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10057CB0) --------------------------------------------------------
double __usercall sub_10057CB0@<st0>(int a1@<eax>, float a2@<ecx>)
{
  bool v2; // zf@1
  float v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  v2 = *(_BYTE *)(a1 + 51615) == 0;
  v4 = *(float *)(dword_1031FB44 + 7368);
  if ( !v2 )
    v4 = *(float *)(a1 + 51716) * *(float *)(dword_1031FB44 + 7400);
  sub_1008CB30(41110, (int)&v4, 4);
  return v4;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10057D00) --------------------------------------------------------
int __usercall sub_10057D00@<eax>(int a1@<edx>, float *a2@<ecx>, int a3@<ebx>, float a4, int a5)
{
  double v5; // st7@1
  float *v6; // ebp@1
  float *v7; // esi@1
  int v8; // edi@1
  double v9; // st7@2
  float *v10; // ecx@5
  double v11; // st5@6
  float v13; // [sp+4h] [bp+4h]@10

  v5 = a4;
  v6 = &a2[9 * a3 - 9];
  v7 = a2;
  v8 = 1;
  if ( a2[a1 + 4] < (double)a4 )
  {
    if ( v6[a1 + 4] > v5 )
    {
      v10 = a2 + 9;
      if ( v10[a1 + 4] < v5 )
      {
        do
        {
          v11 = v10[a1 + 13];
          v7 = v10;
          v10 += 9;
          ++v8;
        }
        while ( v11 < v5 );
      }
      if ( !a5 )
        return v8;
      v9 = (v5 - v7[a1 + 4]) / (v10[a1 + 4] - v7[a1 + 4]) * (*v10 - *v7) + *v7;
    }
    else
    {
      v8 = a3 - 1;
      v9 = *v6;
    }
  }
  else
  {
    v8 = 0;
    v9 = *a2;
  }
  if ( a5 )
  {
    v13 = v9;
    *(float *)a5 = v13;
    return v8;
  }
  return v8;
}

//----- (10057DB0) --------------------------------------------------------
char __usercall sub_10057DB0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  char result; // al@1
  bool v4; // zf@1
  bool v5; // sf@1
  signed int v6; // ecx@2
  int v7; // [sp+4h] [bp-4h]@2

  v2 = *(_DWORD *)(a1 + 16);
  result = **(_WORD **)(a2 + 52) == -32747;
  v4 = *(_DWORD *)(v2 + 51596) == 0;
  v5 = *(_DWORD *)(v2 + 51596) < 0;
  *(_BYTE *)(v2 + 51601) = result;
  if ( !v5 && !v4 )
  {
    *(_DWORD *)(v2 + 51448) = -256;
    v6 = *(_DWORD *)(v2 + 51596) - sub_1008C780();
    v7 = v6;
    if ( v6 < 0 )
    {
      sub_10064B00((char *)(v2 + 51432), 8u, "00:00");
      *(_BYTE *)(v2 + 51600) = 1;
      *(_DWORD *)(v2 + 51448) = -65536;
      v7 = -1;
      result = sub_1008CB30(9212, (int)&v7, 4);
      *(_BYTE *)(v2 + 49825) = 1;
    }
    else
    {
      sub_10064B00((char *)(v2 + 51432), 8u, "%02d:%02d", v6 / 60000, v6 / 1000 % 60);
      if ( v7 < 30000 )
        *(_BYTE *)(v2 + 51600) = 1;
      result = sub_1008CB30(9212, (int)&v7, 4);
      *(_BYTE *)(v2 + 49825) = 1;
    }
  }
  return result;
}

//----- (10057EB0) --------------------------------------------------------
signed int __usercall sub_10057EB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>)
{
  int v3; // esi@1
  unsigned __int16 v4; // cx@1
  double v5; // st7@2
  double v6; // st7@2
  double v7; // st6@2
  bool v8; // c0@4
  double v9; // st7@4
  char v10; // al@7
  double v11; // st7@7
  bool v12; // c3@7
  bool v13; // al@11
  bool v14; // zf@13
  signed int result; // eax@15
  float v16; // [sp+14h] [bp-10h]@1
  float v17; // [sp+18h] [bp-Ch]@2
  float v18; // [sp+1Ch] [bp-8h]@1
  float v19; // [sp+20h] [bp-4h]@1

  *(float *)(a3 + 56 * a2 + 51720) = 9.8999998e24;
  v3 = a3 + 56 * a2 + 51720;
  *(_BYTE *)(a3 + 56 * a2 + 51742) = 0;
  v4 = *(_WORD *)(a3 + 56 * a2 + 51740);
  v19 = *(float *)(dword_1031FB44 + 28 * a1 + 20484);
  v18 = *(float *)(dword_1031FB44 + 28 * a1 + 20480);
  if ( sub_10066790(v4, &v16) )
  {
    v5 = v16;
    *(float *)(v3 + 12) = v16;
    v17 = v5 * *(float *)(v3 + 16);
    v6 = v17;
    *(float *)v3 = v17;
    v7 = v18;
    if ( v18 <= v6 )
    {
      v8 = v19 < v6;
      v9 = v19;
      if ( v8 )
      {
        *(float *)v3 = v19;
        *(float *)(v3 + 12) = v9;
      }
    }
    else
    {
      *(float *)v3 = v18;
      *(float *)(v3 + 12) = v7;
    }
  }
  else
  {
    *(float *)(v3 + 12) = 9.8999998e24;
  }
  *(_BYTE *)(v3 + 22) = sub_1006F520(v3 + 24);
  v10 = sub_1006F520(v3 + 40);
  v11 = 9.8999998e24;
  v12 = 9.8999998e24 == *(float *)v3;
  *(_BYTE *)(v3 + 23) = v10;
  if ( !v12 )
    v11 = sub_100665E0(*(float *)v3, *(float *)(v3 + 4), 0, *(float *)(v3 + 8));
  *(float *)(v3 + 4) = v11;
  v13 = *(_BYTE *)(a3 + 51607) || *(_BYTE *)(v3 + 22);
  v14 = *(_BYTE *)(a3 + 51608) == 0;
  *(_BYTE *)(a3 + 51607) = v13;
  if ( v14 || *(_BYTE *)(v3 + 23) )
  {
    result = 0;
    *(_BYTE *)(a3 + 51608) = 0;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a3 + 51608) = 1;
  }
  return result;
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10058000) --------------------------------------------------------
unsigned int __usercall sub_10058000@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>)
{
  unsigned int result; // eax@1
  _DWORD *v4; // ecx@1

  result = a2 + 24 * *(_DWORD *)(a1 + 4) + 28;
  v4 = (_DWORD *)(a2 + 24 * *(_DWORD *)(a1 + 4) + 40);
  if ( *v4 != a3 )
  {
    result = 0;
    if ( *(_DWORD *)(a1 + 8) )
    {
      do
      {
        *v4 = a3;
        ++result;
        v4 += 6;
      }
      while ( result < *(_DWORD *)(a1 + 8) );
    }
    *(_BYTE *)(a2 + 49824) = 1;
  }
  return result;
}

//----- (10058040) --------------------------------------------------------
void __usercall sub_10058040(void *a1@<ecx>, int a2@<esi>)
{
  void *v2; // ecx@1
  float v3; // ST00_4@8
  double v4; // st7@8
  int v5; // [sp+10h] [bp-8h]@8
  int v6; // [sp+14h] [bp-4h]@8

  *(_BYTE *)(a2 + 51604) = 0;
  if ( !(sub_1006F3C0(a1) & 0xC) || sub_10052230(v2) == 1 )
    *(_BYTE *)(a2 + 51572) = 0;
  if ( *(_BYTE *)(a2 + 51572)
    && 9.8999998e24 != *(float *)(a2 + 51584)
    && 9.8999998e24 != *(float *)(a2 + 51576)
    && 9.8999998e24 != *(float *)(a2 + 51580) )
  {
    v3 = *(float *)(a2 + 51584);
    *(_BYTE *)(a2 + 51604) = 1;
    sub_10057D00(1, (float *)(a2 + 49828), 14, v3, (int)&v6);
    sub_10057D00(2, (float *)(a2 + 49828), 14, *(float *)(a2 + 51576), (int)&v5);
    v4 = *(float *)&v6;
    if ( *(float *)&v5 >= (double)*(float *)&v6 )
      v4 = *(float *)&v5;
    *(float *)&v6 = v4;
    sub_10057D00(0, (float *)(a2 + 49828), 14, *(float *)(a2 + 51580), (int)&v5);
    if ( *(float *)&v5 >= (double)*(float *)&v6 )
      *(float *)(a2 + 51592) = *(float *)&v5;
    else
      *(float *)(a2 + 51592) = *(float *)&v6;
  }
}

//----- (10058170) --------------------------------------------------------
unsigned int __usercall sub_10058170@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // edi@1
  int v3; // eax@1

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 16);
  if ( v3 == -256 )
  {
    *(_DWORD *)(a2 + 20) = -16777216;
    *(_DWORD *)(a2 + 24) = -256;
  }
  else if ( v3 == -65536 )
  {
    *(_DWORD *)(a2 + 20) = -1;
    *(_DWORD *)(a2 + 24) = -65536;
  }
  else
  {
    *(_DWORD *)(a2 + 20) = v3;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(v2 + 51488);
  }
  sub_10058000(a2 + 28, v2, *(_DWORD *)(a2 + 20));
  return sub_10058000(a2 + 40, v2, *(_DWORD *)(a2 + 24));
}

//----- (100581D0) --------------------------------------------------------
int *__cdecl sub_100581D0(int a1, int *a2)
{
  int v2; // ebp@1
  int v3; // ebx@1
  int v4; // edi@3
  float v5; // ST38_4@4
  float v6; // ST1C_4@4
  float v7; // ST38_4@4
  int v8; // edi@7
  float v9; // ST38_4@8
  float v10; // ST1C_4@8
  float v11; // ST38_4@8
  int v12; // edi@11
  float v13; // ST38_4@12
  float v14; // ST1C_4@12
  float v15; // ST38_4@12
  int v16; // edi@15
  float v17; // ST38_4@16
  int v18; // edi@19
  float v19; // ST38_4@20
  int *result; // eax@21

  v2 = a1;
  v3 = a1 + 28;
  if ( a2 )
    *(_DWORD *)(a1 + 51256) = *a2;
  v4 = *(_DWORD *)(v2 + 51256);
  a1 = *(_DWORD *)(v2 + 51256);
  if ( (unsigned __int8)sub_10054EE0(v2, v2 + 51224) )
  {
    v5 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
    v6 = v5;
    v7 = *(float *)(v2 + 51652) - 8.5;
    sub_10057920(v3, &a1, v2 + 51224, *(_DWORD *)(v2 + 51244), v2 + 51640, v7, v6, 1.0, 0.5);
    v4 = a1;
    *(_DWORD *)(v2 + 51260) = a1 - *(_DWORD *)(v2 + 51256);
    sub_100649E0(v2 + 51232, (_BYTE *)(v2 + 51224), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51308) = v4;
  v8 = *(_DWORD *)(v2 + 51308);
  a1 = *(_DWORD *)(v2 + 51308);
  if ( (unsigned __int8)sub_10054EE0(v2, v2 + 51276) )
  {
    v9 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2));
    v10 = v9;
    v11 = *(float *)(v2 + 51652) - 8.5;
    sub_10057920(v3, &a1, v2 + 51276, *(_DWORD *)(v2 + 51296), v2 + 51640, v11, v10, 1.0, 0.5);
    v8 = a1;
    *(_DWORD *)(v2 + 51312) = a1 - *(_DWORD *)(v2 + 51308);
    sub_100649E0(v2 + 51284, (_BYTE *)(v2 + 51276), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51360) = v8;
  v12 = *(_DWORD *)(v2 + 51360);
  a1 = *(_DWORD *)(v2 + 51360);
  if ( (unsigned __int8)sub_10054EE0(v2, v2 + 51328) )
  {
    v13 = *(float *)(v2 + 51668)
        + 6.0
        + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                                * ((signed int)(*(float *)(v2 + 51664)
                                                                                              + 4.0)
                                                                                 / 2))
                                                                       * 0.5
                                                                       + 2.0)
                                                  + 0.5
                                                  + *(float *)(v2 + 51664) * 1.5)
                             + 0.5
                             + *(float *)(v2 + 51664)
                             - 1.0)
        + 0.5
        + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2));
    v14 = v13;
    v15 = *(float *)(v2 + 51652) - 8.5;
    sub_10057920(v3, &a1, v2 + 51328, *(_DWORD *)(v2 + 51348), v2 + 51640, v15, v14, 1.0, 0.5);
    v12 = a1;
    *(_DWORD *)(v2 + 51364) = a1 - *(_DWORD *)(v2 + 51360);
    sub_100649E0(v2 + 51336, (_BYTE *)(v2 + 51328), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51412) = v12;
  v16 = *(_DWORD *)(v2 + 51412);
  a1 = *(_DWORD *)(v2 + 51412);
  if ( (unsigned __int8)sub_10054EE0(v2, v2 + 51380) )
  {
    v17 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
    sub_10057920(v3, &a1, v2 + 51380, *(_DWORD *)(v2 + 51400), v2 + 51640, v17, *(float *)(v2 + 24), 0.5, 0.5);
    v16 = a1;
    *(_DWORD *)(v2 + 51416) = a1 - *(_DWORD *)(v2 + 51412);
    sub_100649E0(v2 + 51388, (_BYTE *)(v2 + 51380), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51464) = v16;
  v18 = *(_DWORD *)(v2 + 51464);
  a1 = *(_DWORD *)(v2 + 51464);
  if ( (unsigned __int8)sub_10054EE0(v2, v2 + 51432) )
  {
    v19 = *(float *)(v2 + 8) - *(float *)(v2 + 4) * 0.4000000059604645;
    sub_10057920(v3, &a1, v2 + 51432, *(_DWORD *)(v2 + 51448), v2 + 51640, v19, *(float *)(v2 + 12), 0.5, 0.5);
    v18 = a1;
    *(_DWORD *)(v2 + 51468) = a1 - *(_DWORD *)(v2 + 51464);
    sub_100649E0(v2 + 51440, (_BYTE *)(v2 + 51432), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  result = a2;
  if ( a2 )
    *a2 = v18;
  return result;
}

//----- (10058770) --------------------------------------------------------
int __usercall sub_10058770@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, float *a4@<edi>, int a5, int a6, _DWORD *a7)
{
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // esi@1
  int v11; // eax@1

  v7 = a3;
  v8 = sub_10057D00(a2, a4, a3, *(float *)(a5 + 4), a1);
  v10 = v8;
  v11 = (int)&a4[9 * v8];
  if ( *(_BYTE *)(v11 + 32) & 1 )
    *a7 = -65536;
  else
    *a7 = *(_DWORD *)(v11 + 8);
  sub_10057D00(v9, a4, v7, *(float *)a5, a6);
  return v10;
}

//----- (100587D0) --------------------------------------------------------
char __usercall sub_100587D0@<al>(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  double v3; // st7@1
  double v4; // st7@2
  double v5; // st7@5
  double v6; // st7@10
  double v7; // st6@10
  double v8; // st4@10
  double v9; // st6@10
  double v10; // st4@10
  double v11; // st6@10
  double v12; // st5@10
  double v13; // st5@10
  double v14; // st7@10
  float v15; // ST44_4@10
  int v16; // eax@10
  double v17; // st7@10
  float v18; // ST44_4@10
  int v19; // eax@10
  double v20; // st7@10
  float v21; // ST44_4@10
  int v22; // eax@10
  int v23; // esi@10
  double v24; // st7@10
  double v25; // st7@12
  int v26; // edi@12
  double v27; // st5@13
  double v28; // st4@13
  float v29; // ST3C_4@13
  float v30; // ST38_4@13
  float v31; // ST34_4@13
  int v32; // ST44_4@14
  double v33; // st6@14
  int v34; // edi@14
  float v35; // ST30_4@14
  int v36; // ST44_4@14
  float v37; // ST30_4@14
  int v38; // ST44_4@14
  float v39; // ST30_4@14
  int v40; // ST44_4@14
  float v41; // ST30_4@14
  int v42; // ST44_4@14
  float v43; // ST30_4@14
  double v44; // st5@14
  float v45; // ST3C_4@14
  float v46; // ST38_4@14
  double v47; // st5@14
  float v48; // ST3C_4@14
  float v49; // ST38_4@14
  double v50; // st5@14
  float v51; // ST3C_4@14
  float v52; // ST38_4@14
  double v53; // st7@14
  float v54; // ST3C_4@14
  int v55; // edx@14
  float v56; // ST3C_4@14
  int v57; // eax@14
  float *v58; // edi@14
  float v59; // ST3C_4@16
  bool v60; // zf@17
  int v61; // eax@18
  float v62; // ST3C_4@18
  int v63; // eax@18
  float v64; // ST3C_4@18
  int v65; // eax@18
  float v66; // ST3C_4@18
  int v67; // eax@18
  float v68; // ST3C_4@18
  int v69; // eax@18
  int v70; // edi@18
  int v71; // ecx@18
  double v72; // st7@18
  int v73; // ST44_4@18
  int v74; // ST44_4@18
  int v75; // ST44_4@18
  int v76; // ST44_4@18
  int v77; // edi@18
  int v78; // edx@18
  double v79; // st7@18
  int v80; // ST44_4@18
  int v81; // ST44_4@18
  int v82; // ST44_4@18
  int v83; // ST44_4@18
  int v84; // edi@18
  int v85; // ST44_4@18
  double v86; // st6@18
  int v87; // ST44_4@18
  int v88; // ST44_4@18
  int v89; // ST44_4@18
  int v90; // ST44_4@18
  int v91; // ST44_4@18
  float v92; // ST3C_4@18
  int v93; // edi@18
  int v94; // ST44_4@18
  int v95; // ST44_4@18
  int v96; // ST44_4@18
  int v97; // ST44_4@18
  int v98; // ST44_4@18
  int v99; // ST44_4@18
  int v100; // ST44_4@18
  int v101; // ST44_4@18
  int v102; // ST44_4@18
  int v103; // ST44_4@18
  int v104; // ST44_4@18
  int v105; // ST44_4@18
  int v106; // ST44_4@18
  int v107; // ST44_4@18
  int v108; // ST44_4@18
  int v109; // ST44_4@18
  int v110; // ST44_4@18
  int v111; // ST44_4@18
  int v112; // ST44_4@18
  int v113; // ST44_4@18
  int v114; // ST44_4@18
  int v115; // ST44_4@18
  int v116; // ST44_4@18
  int v117; // ST44_4@18
  int v118; // ST44_4@18
  int v119; // ST44_4@18
  int v120; // ST44_4@18
  int v121; // ST44_4@18
  int v122; // ST44_4@18
  int v123; // ST44_4@18
  int v124; // ST44_4@18
  int v125; // ST44_4@18
  int v126; // ST44_4@18
  int v127; // ST44_4@18
  int v128; // ST44_4@18
  int v129; // ST44_4@18
  int v130; // ST44_4@18
  float v131; // ST30_4@18
  int v132; // ST44_4@18
  int v133; // edi@18
  float v134; // ST30_4@18
  int v135; // ST44_4@19
  int v136; // ST44_4@19
  float v137; // ST30_4@19
  bool v138; // sf@19
  unsigned __int8 v139; // of@19
  int v140; // ST44_4@20
  int v141; // edi@20
  int v142; // ST44_4@20
  int v143; // ST44_4@20
  int v144; // ST44_4@20
  int v145; // ST44_4@20
  int v146; // ST44_4@20
  float v147; // ST30_4@20
  int v148; // ST44_4@20
  int v149; // edi@20
  float v150; // ST30_4@20
  int v151; // ST44_4@21
  int v152; // ST44_4@21
  float v153; // ST30_4@21
  int v154; // ST44_4@22
  int v155; // edi@22
  float v156; // ST30_4@22
  int v157; // ST44_4@22
  int v158; // edi@22
  float v159; // ST30_4@22
  int v160; // ST44_4@23
  float v161; // ST30_4@23
  int v162; // ST44_4@23
  float v163; // ST30_4@23
  int v164; // ST44_4@24
  int v165; // edi@24
  int v166; // ST44_4@24
  int v167; // ST44_4@24
  int v168; // ST44_4@24
  double v169; // st7@24
  float v170; // ST3C_4@24
  float v171; // ST3C_4@24
  float v172; // ST3C_4@24
  int v173; // edi@24
  int v174; // ST44_4@24
  int v175; // ST44_4@24
  int v176; // ST44_4@24
  int v177; // ST44_4@24
  int v178; // ST44_4@24
  int v179; // ST44_4@24
  int v180; // ST44_4@24
  int v181; // ST44_4@24
  int v182; // ST44_4@24
  int v183; // ST44_4@24
  int v184; // ST44_4@24
  int v185; // ST44_4@24
  double v186; // st7@24
  int v187; // ST44_4@24
  int v188; // ST44_4@24
  int v189; // ST44_4@24
  int v190; // ST44_4@24
  int v191; // ST44_4@24
  int v192; // ST44_4@24
  int v193; // ST44_4@24
  int v194; // ST44_4@24
  int v195; // ST44_4@24
  double v196; // st7@24
  float v197; // ST30_4@24
  double v198; // st7@24
  float v199; // ST2C_4@24
  int v200; // ST44_4@24
  int v201; // ST44_4@24
  int v202; // ST44_4@24
  int v203; // ST44_4@24
  int v204; // ST44_4@24
  int v205; // ST44_4@24
  double v206; // st7@24
  int v207; // ST44_4@24
  int v208; // ST44_4@24
  int v209; // ST44_4@24
  int v210; // ST44_4@24
  int v211; // ST44_4@24
  int v212; // ST44_4@24
  int v213; // ST44_4@24
  int v214; // ST44_4@24
  int v215; // ST44_4@24
  double v216; // st7@24
  float v217; // ST30_4@24
  double v218; // st7@24
  float v219; // ST2C_4@24
  int v220; // ST44_4@24
  int v221; // ST44_4@24
  int v222; // ST44_4@24
  int v223; // ST44_4@24
  int v224; // ST44_4@24
  int v225; // ST44_4@24
  int v226; // eax@24
  int v227; // edi@24
  double v228; // st6@24
  int v229; // ST44_4@24
  int v230; // ST40_4@24
  float v231; // ST30_4@24
  int v232; // ST44_4@24
  int v233; // ST40_4@24
  float v234; // ST30_4@24
  int v235; // ecx@24
  int v236; // ST44_4@24
  int v237; // ST44_4@24
  int v238; // ST40_4@24
  int v239; // ST44_4@24
  int v240; // ST40_4@24
  int v241; // ST44_4@24
  int v242; // ST40_4@24
  float v243; // ST30_4@24
  int v244; // ST44_4@24
  int v245; // ST40_4@24
  float v246; // ST30_4@24
  int v247; // ST44_4@24
  int v248; // ST40_4@24
  float v249; // ST30_4@24
  int v250; // eax@24
  int v251; // ST40_4@24
  float v252; // ST30_4@24
  int v253; // ST44_4@24
  int v254; // ST40_4@24
  float v255; // ST30_4@24
  int v256; // ST44_4@24
  int v257; // ST40_4@24
  float v258; // ST30_4@24
  int v259; // ecx@24
  int v260; // ST44_4@24
  int v261; // ST44_4@24
  int v262; // ST40_4@24
  int v263; // ST44_4@24
  int v264; // ST40_4@24
  float v265; // ST30_4@24
  int v266; // ST44_4@24
  int v267; // ST40_4@24
  int v268; // ST44_4@24
  int v269; // ST40_4@24
  int v270; // ST44_4@24
  int v271; // ST40_4@24
  int v272; // ST44_4@24
  int v273; // ST44_4@24
  int v274; // ST40_4@24
  int v275; // ST44_4@24
  int v276; // ST40_4@24
  float v277; // ST30_4@24
  int v278; // ST44_4@24
  int v279; // ST40_4@24
  int v280; // ST44_4@24
  int v281; // ST40_4@24
  int v282; // ST44_4@24
  int v283; // ST40_4@24
  float v284; // ST30_4@24
  int v285; // ST44_4@24
  int v286; // ST40_4@24
  float v287; // ST30_4@24
  int v288; // ST44_4@24
  int v289; // ST40_4@24
  int v290; // ST44_4@24
  int v291; // ST40_4@24
  float v292; // ST30_4@24
  int v293; // ST44_4@24
  int v294; // ST40_4@24
  int v295; // ST44_4@24
  int v296; // ST40_4@24
  int v297; // ST44_4@24
  int v298; // ST40_4@24
  float v299; // ST30_4@24
  int v300; // ST44_4@24
  int v301; // ST40_4@24
  float v302; // ST30_4@24
  int v303; // ST44_4@24
  int v304; // ST40_4@24
  float v305; // ST30_4@24
  int v306; // ST44_4@24
  int v307; // ST40_4@24
  float v308; // ST30_4@24
  int v309; // ST44_4@24
  int v310; // ST40_4@24
  float v311; // ST30_4@24
  int v312; // ST44_4@24
  int v313; // ST40_4@24
  float v314; // ST30_4@24
  int v315; // ST44_4@24
  int v316; // ST40_4@24
  float v317; // ST30_4@24
  int v318; // eax@24
  int v319; // ST40_4@24
  int v320; // ST44_4@24
  int v321; // ST40_4@24
  int v322; // ST44_4@24
  int v323; // ST40_4@24
  float v324; // ST30_4@24
  int v325; // ST44_4@24
  int v326; // ST40_4@24
  int v327; // ST44_4@24
  int v328; // ST40_4@24
  int v329; // ST44_4@24
  int v330; // ST40_4@24
  int v331; // ST44_4@24
  int v332; // ST40_4@24
  double v333; // st7@24
  int v334; // ST44_4@24
  float v335; // ST30_4@24
  int v336; // ST44_4@24
  float v337; // ST30_4@24
  int v338; // ST44_4@24
  float v339; // ST30_4@24
  int v340; // ST44_4@24
  float v341; // ST30_4@24
  int v342; // ST44_4@24
  float v343; // ST30_4@24
  int v344; // ST44_4@24
  float v345; // ST30_4@24
  int v347; // [sp+30h] [bp-24h]@10
  float v348; // [sp+34h] [bp-20h]@14
  int v349; // [sp+38h] [bp-1Ch]@18
  int v350; // [sp+3Ch] [bp-18h]@18
  float v351; // [sp+40h] [bp-14h]@18
  long double v352; // [sp+44h] [bp-10h]@16
  float v353; // [sp+4Ch] [bp-8h]@16
  int v354; // [sp+50h] [bp-4h]@10
  float v355; // [sp+58h] [bp+4h]@13
  float v356; // [sp+58h] [bp+4h]@13
  float v357; // [sp+58h] [bp+4h]@13
  float v358; // [sp+58h] [bp+4h]@13
  float v359; // [sp+58h] [bp+4h]@14
  float v360; // [sp+58h] [bp+4h]@14
  float v361; // [sp+58h] [bp+4h]@14
  float v362; // [sp+58h] [bp+4h]@14
  float v363; // [sp+58h] [bp+4h]@14
  float v364; // [sp+58h] [bp+4h]@14
  float v365; // [sp+58h] [bp+4h]@14
  float v366; // [sp+58h] [bp+4h]@14
  float v367; // [sp+58h] [bp+4h]@14
  float v368; // [sp+58h] [bp+4h]@14
  float v369; // [sp+58h] [bp+4h]@14
  float v370; // [sp+58h] [bp+4h]@14
  float v371; // [sp+58h] [bp+4h]@14
  float v372; // [sp+58h] [bp+4h]@14
  float v373; // [sp+58h] [bp+4h]@14
  float v374; // [sp+58h] [bp+4h]@14
  float v375; // [sp+58h] [bp+4h]@14
  float v376; // [sp+58h] [bp+4h]@14
  float v377; // [sp+58h] [bp+4h]@14
  float v378; // [sp+58h] [bp+4h]@14
  int v379; // [sp+58h] [bp+4h]@14
  float v380; // [sp+58h] [bp+4h]@18
  float v381; // [sp+58h] [bp+4h]@18
  float v382; // [sp+58h] [bp+4h]@18
  float v383; // [sp+58h] [bp+4h]@18
  float v384; // [sp+58h] [bp+4h]@18
  float v385; // [sp+58h] [bp+4h]@18
  float v386; // [sp+58h] [bp+4h]@18
  float v387; // [sp+58h] [bp+4h]@18
  float v388; // [sp+58h] [bp+4h]@18
  float v389; // [sp+58h] [bp+4h]@18
  float v390; // [sp+58h] [bp+4h]@18
  float v391; // [sp+58h] [bp+4h]@18
  float v392; // [sp+58h] [bp+4h]@18
  float v393; // [sp+58h] [bp+4h]@18
  float v394; // [sp+58h] [bp+4h]@18
  float v395; // [sp+58h] [bp+4h]@18
  float v396; // [sp+58h] [bp+4h]@18
  float v397; // [sp+58h] [bp+4h]@18
  float v398; // [sp+58h] [bp+4h]@18
  float v399; // [sp+58h] [bp+4h]@18
  float v400; // [sp+58h] [bp+4h]@18
  float v401; // [sp+58h] [bp+4h]@18
  float v402; // [sp+58h] [bp+4h]@18
  float v403; // [sp+58h] [bp+4h]@18
  float v404; // [sp+58h] [bp+4h]@18
  float v405; // [sp+58h] [bp+4h]@18
  float v406; // [sp+58h] [bp+4h]@18
  float v407; // [sp+58h] [bp+4h]@18
  float v408; // [sp+58h] [bp+4h]@18
  float v409; // [sp+58h] [bp+4h]@18
  float v410; // [sp+58h] [bp+4h]@18
  float v411; // [sp+58h] [bp+4h]@18
  float v412; // [sp+58h] [bp+4h]@18
  float v413; // [sp+58h] [bp+4h]@18
  float v414; // [sp+58h] [bp+4h]@18
  float v415; // [sp+58h] [bp+4h]@18
  float v416; // [sp+58h] [bp+4h]@18
  float v417; // [sp+58h] [bp+4h]@18
  float v418; // [sp+58h] [bp+4h]@18
  float v419; // [sp+58h] [bp+4h]@18
  float v420; // [sp+58h] [bp+4h]@18
  float v421; // [sp+58h] [bp+4h]@18
  float v422; // [sp+58h] [bp+4h]@18
  float v423; // [sp+58h] [bp+4h]@18
  float v424; // [sp+58h] [bp+4h]@18
  float v425; // [sp+58h] [bp+4h]@18
  float v426; // [sp+58h] [bp+4h]@18
  float v427; // [sp+58h] [bp+4h]@18
  signed int v428; // [sp+58h] [bp+4h]@18
  float v429; // [sp+58h] [bp+4h]@20
  float v430; // [sp+58h] [bp+4h]@20
  float v431; // [sp+58h] [bp+4h]@20
  float v432; // [sp+58h] [bp+4h]@20
  float v433; // [sp+58h] [bp+4h]@20
  float v434; // [sp+58h] [bp+4h]@20
  float v435; // [sp+58h] [bp+4h]@20
  signed int v436; // [sp+58h] [bp+4h]@20
  float v437; // [sp+58h] [bp+4h]@22
  float v438; // [sp+58h] [bp+4h]@22
  float v439; // [sp+58h] [bp+4h]@22
  float v440; // [sp+58h] [bp+4h]@22
  signed int v441; // [sp+58h] [bp+4h]@22
  float v442; // [sp+58h] [bp+4h]@24
  float v443; // [sp+58h] [bp+4h]@24
  float v444; // [sp+58h] [bp+4h]@24
  float v445; // [sp+58h] [bp+4h]@24
  float v446; // [sp+58h] [bp+4h]@24
  float v447; // [sp+58h] [bp+4h]@24
  float v448; // [sp+58h] [bp+4h]@24
  float v449; // [sp+58h] [bp+4h]@24
  float v450; // [sp+58h] [bp+4h]@24
  float v451; // [sp+58h] [bp+4h]@24
  float v452; // [sp+58h] [bp+4h]@24
  float v453; // [sp+58h] [bp+4h]@24
  float v454; // [sp+58h] [bp+4h]@24
  float v455; // [sp+58h] [bp+4h]@24
  float v456; // [sp+58h] [bp+4h]@24
  float v457; // [sp+58h] [bp+4h]@24
  float v458; // [sp+58h] [bp+4h]@24
  float v459; // [sp+58h] [bp+4h]@24
  float v460; // [sp+58h] [bp+4h]@24
  float v461; // [sp+58h] [bp+4h]@24
  float v462; // [sp+58h] [bp+4h]@24
  float v463; // [sp+58h] [bp+4h]@24
  float v464; // [sp+58h] [bp+4h]@24
  float v465; // [sp+58h] [bp+4h]@24
  float v466; // [sp+58h] [bp+4h]@24
  float v467; // [sp+58h] [bp+4h]@24

  v2 = sub_100027C0(a1, 52008);
  v3 = *(float *)(a2 + 8);
  *(_DWORD *)(a2 + 16) = v2;
  *(float *)(v2 + 51656) = v3;
  *(float *)(v2 + 51652) = *(float *)(a2 + 12);
  if ( *(_BYTE *)(a2 + 3) )
  {
    *(float *)(v2 + 51660) = 9.0;
    *(float *)(v2 + 51664) = 15.0;
    *(float *)(v2 + 51668) = 23.0;
    *(float *)(v2 + 51672) = 5.0;
    *(float *)(v2 + 51676) = 6.0;
    *(float *)(v2 + 51680) = 7.0;
    *(float *)(v2 + 51684) = 7.0;
    *(float *)(v2 + 51688) = 11.0;
    *(float *)(v2 + 51692) = 11.0;
    *(float *)(v2 + 51696) = 9.0;
    *(float *)(v2 + 51700) = 10.0;
    v4 = 17.0;
  }
  else
  {
    *(float *)(v2 + 51660) = 7.0;
    *(float *)(v2 + 51664) = 12.0;
    *(float *)(v2 + 51668) = 15.0;
    *(float *)(v2 + 51672) = 4.0;
    *(float *)(v2 + 51676) = 5.0;
    *(float *)(v2 + 51680) = 5.0;
    *(float *)(v2 + 51684) = 6.0;
    *(float *)(v2 + 51688) = 7.0;
    *(float *)(v2 + 51692) = 7.0;
    *(float *)(v2 + 51696) = 8.0;
    *(float *)(v2 + 51700) = 9.0;
    v4 = 10.0;
  }
  *(float *)(v2 + 51704) = v4;
  if ( *(_BYTE *)(a2 + 4) )
  {
    *(float *)(v2 + 51708) = 0.75;
    v5 = 3.0;
  }
  else
  {
    *(float *)(v2 + 51708) = 0.30000001;
    v5 = 1.2;
  }
  *(float *)(v2 + 51712) = v5;
  if ( *(_BYTE *)(a2 + 1) )
    *(_DWORD *)(v2 + 51488) = -16777216;
  else
    *(_DWORD *)(v2 + 51488) = -14671840;
  sub_100649E0(v2 + 51224, "199.9", 8);
  *(_BYTE *)(v2 + 51232) = 0;
  *(_DWORD *)(v2 + 51240) = -16728064;
  *(_DWORD *)(v2 + 51244) = -16728064;
  *(_DWORD *)(v2 + 51248) = -16777216;
  *(_DWORD *)(v2 + 51252) = 68;
  sub_100649E0(v2 + 51276, "1999", 8);
  *(_BYTE *)(v2 + 51284) = 0;
  *(_DWORD *)(v2 + 51292) = -16728064;
  *(_DWORD *)(v2 + 51296) = -16728064;
  *(_DWORD *)(v2 + 51300) = -16777216;
  *(_DWORD *)(v2 + 51304) = 68;
  sub_100649E0(v2 + 51328, "199.9", 8);
  *(_BYTE *)(v2 + 51336) = 0;
  *(_DWORD *)(v2 + 51344) = -16728064;
  *(_DWORD *)(v2 + 51348) = -16728064;
  *(_DWORD *)(v2 + 51352) = -16777216;
  *(_DWORD *)(v2 + 51356) = 68;
  sub_100649E0(v2 + 51380, "199", 8);
  *(_DWORD *)(v2 + 51396) = -16728064;
  *(_DWORD *)(v2 + 51400) = -16728064;
  *(_BYTE *)(v2 + 51388) = 0;
  *(_DWORD *)(v2 + 51404) = -16777216;
  *(_DWORD *)(v2 + 51408) = 68;
  sub_100649E0(v2 + 51432, "XX:XX", 8);
  *(_BYTE *)(v2 + 51440) = 0;
  *(_DWORD *)(v2 + 51456) = -16777216;
  *(_DWORD *)(v2 + 51460) = 68;
  *(_DWORD *)(v2 + 51448) = -256;
  *(_DWORD *)(v2 + 51452) = -256;
  *(_BYTE *)a2 = 0;
  *(_BYTE *)v2 = 0;
  *(_DWORD *)(v2 + 52000) = 0;
  *(_DWORD *)(v2 + 52004) = 0;
  *(_BYTE *)(v2 + 51484) = 0;
  *(_DWORD *)(v2 + 51596) = 0;
  *(_BYTE *)(v2 + 51601) = 0;
  *(_BYTE *)(v2 + 51600) = 0;
  *(_BYTE *)(v2 + 49825) = 1;
  *(_BYTE *)(v2 + 49824) = 0;
  *(_BYTE *)(v2 + 51611) = 0;
  *(_BYTE *)(v2 + 51612) = 0;
  *(float *)(v2 + 51720) = 9.8999998e24;
  *(float *)(v2 + 51724) = 9.8999998e24;
  *(float *)(v2 + 51776) = 9.8999998e24;
  *(float *)(v2 + 51780) = 9.8999998e24;
  *(float *)(v2 + 51832) = 9.8999998e24;
  *(float *)(v2 + 51836) = 9.8999998e24;
  *(float *)(v2 + 51888) = 9.8999998e24;
  *(float *)(v2 + 51892) = 9.8999998e24;
  *(float *)(v2 + 51944) = 9.8999998e24;
  *(float *)(v2 + 51948) = 9.8999998e24;
  *(_WORD *)(v2 + 51740) = 373;
  *(float *)(v2 + 51728) = 0.1;
  *(float *)(v2 + 51736) = 100.0;
  sub_100649E0(v2 + 51744, "_trq_prim", 16);
  sub_100649E0(v2 + 51760, "_trq_bkup", 16);
  *(float *)(v2 + 51784) = 1.0;
  *(float *)(v2 + 51792) = 1.0;
  *(_WORD *)(v2 + 51796) = 372;
  sub_100649E0(v2 + 51800, "_mgt_prim", 16);
  sub_100649E0(v2 + 51816, "_mgt_bkup", 16);
  *(float *)(v2 + 51840) = 0.1;
  *(float *)(v2 + 51848) = 100.0;
  *(_WORD *)(v2 + 51852) = 370;
  sub_100649E0(v2 + 51856, "_ng_prim", 16);
  sub_100649E0(v2 + 51872, "_ng_bkup", 16);
  *(float *)(v2 + 51896) = 0.1;
  *(float *)(v2 + 51904) = 100.0;
  *(_WORD *)(v2 + 51908) = 371;
  sub_100649E0(v2 + 51912, "_np_prim", 16);
  sub_100649E0(v2 + 51928, "_np_bkup", 16);
  *(float *)(v2 + 51952) = 1.0;
  *(float *)(v2 + 51960) = 100.0;
  *(_WORD *)(v2 + 51964) = 374;
  sub_100649E0(v2 + 51968, "_nr_prim", 16);
  sub_100649E0(v2 + 51984, "_nr_bkup", 16);
  v6 = *(float *)(v2 + 51668) + 6.0;
  v354 = (signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                       * ((signed int)(*(float *)(v2 + 51664) + 4.0)
                                                                        / 2))
                                                              * 0.5
                                                              + 2.0)
                                         + 0.5
                                         + *(float *)(v2 + 51664) * 1.5)
                    + 0.5
                    + *(float *)(v2 + 51664)
                    - 1.0);
  v7 = (double)v354 + 0.5;
  v354 = 2 * ((signed int)(2.0 * v6 + *(float *)(v2 + 51668) + 10.0) / 2);
  *(_BYTE *)(v2 + 51602) = 0;
  v8 = (double)v354;
  *(_BYTE *)(v2 + 51610) = 0;
  *(_BYTE *)(v2 + 51603) = 0;
  *(_BYTE *)(v2 + 51604) = 0;
  *(_BYTE *)(v2 + 51605) = 0;
  *(_BYTE *)(v2 + 51606) = 0;
  *(_BYTE *)(v2 + 51607) = 0;
  v9 = v7 + v8 * 0.5;
  *(_BYTE *)(v2 + 51608) = 0;
  *(_BYTE *)(v2 + 51609) = 0;
  *(_BYTE *)(v2 + 51613) = 0;
  *(_BYTE *)(v2 + 51614) = 0;
  *(_BYTE *)(v2 + 51615) = 0;
  *(float *)&v354 = v9 - v6;
  v10 = *(float *)&v354;
  *(float *)(v2 + 51504) = *(float *)&v354;
  *(float *)(v2 + 51508) = v9;
  *(float *)(v2 + 51512) = v6 + v9;
  *(float *)(v2 + 51516) = v10;
  *(float *)(v2 + 51548) = 9.8999998e24;
  *(float *)(v2 + 51552) = 9.8999998e24;
  *(float *)(v2 + 51564) = 9.8999998e24;
  *(float *)(v2 + 51568) = 9.8999998e24;
  *(float *)(v2 + 51716) = 9.8999998e24;
  *(float *)&v354 = *(float *)(v2 + 51652) * 0.4199999868869781;
  v11 = *(float *)&v354;
  *(float *)(v2 + 4) = *(float *)&v354;
  *(float *)&v354 = (double)(signed int)(v11 + 5.0) + 0.5;
  v12 = *(float *)&v354;
  *(float *)(v2 + 8) = *(float *)&v354;
  *(float *)(v2 + 12) = v12;
  *(float *)&v354 = *(float *)(v2 + 51652) * 0.3600000143051147;
  v13 = *(float *)&v354;
  *(float *)(v2 + 16) = *(float *)&v354;
  v354 = (signed int)(*(float *)(v2 + 51652) - 22.0);
  *(float *)(v2 + 20) = (double)v354 + 0.5;
  v354 = (signed int)(*(float *)(v2 + 51656) - v13 - 5.0);
  *(float *)(v2 + 24) = (double)v354 + 0.5;
  *(float *)(v2 + 51520) = 0.0;
  *(float *)(v2 + 51528) = 0.0;
  *(float *)(v2 + 51524) = 0.0;
  *(float *)(v2 + 51532) = 0.0;
  *(float *)(v2 + 51540) = 0.0;
  *(float *)(v2 + 51536) = 0.0;
  v354 = *(int *)(v2 + 51660);
  v14 = *(float *)&v354;
  *(float *)(v2 + 51616) = *(float *)&v354;
  v15 = v14;
  v16 = sub_10065060(v15);
  *(_DWORD *)(v2 + 51620) = v16;
  *(_DWORD *)(v2 + 51624) = sub_1008D620(v16 & 0x3FFFFFFF);
  v354 = *(int *)(v2 + 51664);
  v17 = *(float *)&v354;
  *(float *)(v2 + 51628) = *(float *)&v354;
  v18 = v17;
  v19 = sub_10065060(v18);
  *(_DWORD *)(v2 + 51632) = v19;
  *(_DWORD *)(v2 + 51636) = sub_1008D620(v19 & 0x3FFFFFFF);
  v354 = *(int *)(v2 + 51668);
  v20 = *(float *)&v354;
  *(float *)(v2 + 51640) = *(float *)&v354;
  v21 = v20;
  v22 = sub_10065060(v21);
  *(_DWORD *)(v2 + 51644) = v22;
  *(_DWORD *)(v2 + 51648) = sub_1008D620(v22 & 0x3FFFFFFF);
  qmemcpy((void *)(v2 + 50332), &unk_100E4968, 0x18Cu);
  *(float *)(v2 + 50348) = *(float *)(dword_1031FB44 + 8188);
  *(float *)(v2 + 50384) = *(float *)(dword_1031FB44 + 0x2000);
  *(float *)(v2 + 50420) = *(float *)(dword_1031FB44 + 8196);
  *(float *)(v2 + 50456) = *(float *)(dword_1031FB44 + 8200);
  *(float *)(v2 + 50492) = *(float *)(dword_1031FB44 + 8204);
  *(float *)(v2 + 50528) = *(float *)(dword_1031FB44 + 8208);
  *(float *)(v2 + 50564) = *(float *)(dword_1031FB44 + 8212);
  *(float *)(v2 + 50600) = *(float *)(dword_1031FB44 + 8216);
  *(float *)(v2 + 50636) = *(float *)(dword_1031FB44 + 8220);
  *(float *)(v2 + 50672) = *(float *)(dword_1031FB44 + 8224);
  *(float *)(v2 + 50708) = *(float *)(dword_1031FB44 + 8352);
  qmemcpy((void *)(v2 + 50728), &unk_100E4AF8, 0x18Cu);
  *(float *)(v2 + 50744) = *(float *)(dword_1031FB44 + 8516);
  *(float *)(v2 + 50780) = *(float *)(dword_1031FB44 + 8520);
  *(float *)(v2 + 50816) = *(float *)(dword_1031FB44 + 8524);
  *(float *)(v2 + 50852) = *(float *)(dword_1031FB44 + 8528);
  *(float *)(v2 + 50888) = *(float *)(dword_1031FB44 + 8532);
  *(float *)(v2 + 50924) = *(float *)(dword_1031FB44 + 8536);
  *(float *)(v2 + 50960) = *(float *)(dword_1031FB44 + 8540);
  *(float *)(v2 + 50996) = *(float *)(dword_1031FB44 + 8544);
  *(float *)(v2 + 51032) = *(float *)(dword_1031FB44 + 8548);
  *(float *)(v2 + 51068) = *(float *)(dword_1031FB44 + 8552);
  *(float *)(v2 + 51104) = *(float *)(dword_1031FB44 + 8680);
  *(_DWORD *)(v2 + 51124) = v2 + 50332;
  qmemcpy((void *)(v2 + 49828), &unk_100E4C88, 0x1F8u);
  sub_10055020(v2);
  *(float *)(v2 + 49848) = *(float *)(dword_1031FB44 + 7532);
  *(float *)(v2 + 49884) = *(float *)(dword_1031FB44 + 7532);
  *(float *)(v2 + 49920) = *(float *)(dword_1031FB44 + 7536);
  *(float *)(v2 + 49956) = *(float *)(dword_1031FB44 + 7540);
  *(float *)(v2 + 49992) = *(float *)(dword_1031FB44 + 7544);
  v23 = v2 + 12320;
  *(float *)(v2 + 50028) = *(float *)(dword_1031FB44 + 7548);
  v24 = *(float *)(dword_1031FB44 + 7552);
  *(float *)&v347 = 0.0;
  *(float *)(v2 + 50064) = v24;
  *(float *)(v2 + 50100) = *(float *)(dword_1031FB44 + 7556);
  *(float *)(v2 + 50136) = *(float *)(dword_1031FB44 + 7560);
  *(float *)(v2 + 50172) = *(float *)(dword_1031FB44 + 7564);
  *(float *)(v2 + 50208) = *(float *)(dword_1031FB44 + 7568);
  *(float *)(v2 + 50244) = *(float *)(dword_1031FB44 + 7696);
  *(float *)(v2 + 50280) = *(float *)(dword_1031FB44 + 7700);
  *(float *)(v2 + 50316) = *(float *)(dword_1031FB44 + 7704);
  *(float *)(v2 + 51556) = *(float *)(dword_1031FB44 + 7728);
  *(float *)(v2 + 51560) = *(float *)(dword_1031FB44 + 7732);
  *(float *)(v2 + 49852) = *(float *)(dword_1031FB44 + 7860);
  *(float *)(v2 + 49888) = *(float *)(dword_1031FB44 + 7860);
  *(float *)(v2 + 49924) = *(float *)(dword_1031FB44 + 7864);
  *(float *)(v2 + 49960) = *(float *)(dword_1031FB44 + 7868);
  *(float *)(v2 + 49996) = *(float *)(dword_1031FB44 + 7872);
  *(float *)(v2 + 50032) = *(float *)(dword_1031FB44 + 7876);
  *(float *)(v2 + 50068) = *(float *)(dword_1031FB44 + 7880);
  *(float *)(v2 + 50104) = *(float *)(dword_1031FB44 + 7884);
  *(float *)(v2 + 50140) = *(float *)(dword_1031FB44 + 7888);
  *(float *)(v2 + 50176) = *(float *)(dword_1031FB44 + 7892);
  *(float *)(v2 + 50212) = *(float *)(dword_1031FB44 + 7896);
  *(float *)(v2 + 50248) = *(float *)(dword_1031FB44 + 8024);
  *(float *)(v2 + 50284) = *(float *)(dword_1031FB44 + 8028);
  *(float *)(v2 + 50320) = *(float *)(dword_1031FB44 + 8032);
  *(_DWORD *)(v2 + 49184) = 0;
  if ( *(_BYTE *)(a2 + 1) )
    sub_10055E70(v2 + 12320, v2, &v347);
  sub_10055120(
    v2 + 49828,
    v2 + 49212,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    0,
    13,
    &v347,
    v2 + 12320,
    0);
  sub_10057450(
    -8355712,
    v2 + 49464,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    180.0,
    216.0,
    &v347,
    v2 + 12320);
  sub_10057450(
    -65536,
    v2 + 49476,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    180.0,
    216.0,
    &v347,
    v2 + 12320);
  sub_10057450(-256, v2 + 49488, 0.0, 0.0, *(float *)(v2 + 4), 180.0, 198.0, &v347, v2 + 12320);
  sub_10055120(
    v2 + 50332,
    v2 + 49260,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0,
    10,
    &v347,
    v2 + 12320,
    0);
  sub_10055120(
    v2 + 50728,
    v2 + 49284,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0,
    10,
    &v347,
    v2 + 12320,
    0);
  sub_10057450(
    -8355712,
    v2 + 49500,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    115.0,
    125.0,
    &v347,
    v2 + 12320);
  sub_10057450(
    -65536,
    v2 + 49512,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    115.0,
    125.0,
    &v347,
    v2 + 12320);
  sub_10057450(
    -65536,
    v2 + 49524,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    95.0,
    115.0,
    &v347,
    v2 + 12320);
  sub_10057450(
    -8355712,
    v2 + 49536,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0.0,
    30.0,
    &v347,
    v2 + 12320);
  sub_10057450(
    -256,
    v2 + 49548,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0.0,
    30.0,
    &v347,
    v2 + 12320);
  v25 = 4.5;
  v26 = v347;
  *(_DWORD *)(v2 + 49320) = 67;
  *(_DWORD *)(v2 + 49324) = v26;
  if ( *(_BYTE *)(a2 + 1) == 1 )
  {
    v27 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                                * ((signed int)(*(float *)(v2 + 51664)
                                                                                              + 4.0)
                                                                                 / 2))
                                                                       * 0.5
                                                                       + 2.0)
                                                  + 0.5
                                                  + *(float *)(v2 + 51664) * 1.5)
                             + 0.5
                             + *(float *)(v2 + 51664)
                             - 1.0)
        + 0.5;
    v28 = *(float *)(v2 + 51652) - 4.5;
    v355 = (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) + v27;
    v29 = v355;
    v356 = v28;
    v30 = v356;
    v357 = v27;
    v31 = v357;
    v358 = v28 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
    sub_10056FD0(-4144960, v2 + 12320, v358, v31, v30, v29, 5.0, &v347);
    v25 = 4.5;
    v26 = v347;
  }
  *(_DWORD *)(v2 + 49328) = v26 - *(_DWORD *)(v2 + 49324);
  *(_DWORD *)(v2 + 49308) = 67;
  *(_DWORD *)(v2 + 49312) = v26;
  v32 = v23 + 24 * v26;
  v33 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
  v34 = v26 + 1;
  v348 = *(float *)(v2 + 51652) - v25 - v33;
  v359 = *(float *)(v2 + 24);
  *(float *)&v354 = v359 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2));
  v35 = *(float *)&v354;
  *(float *)&v354 = v348 - v33;
  sub_1008CCA0(*(float *)&v354, v35, 0.0, 0.0, 0.0, -4144960, v32);
  v36 = v23 + 24 * v34++;
  *(float *)&v354 = v359 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5;
  v37 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v37, 0.0, 0.0, 0.0, -4144960, v36);
  v38 = v23 + 24 * v34++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v359;
  v39 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v39, 0.0, 0.0, 0.0, -4144960, v38);
  v40 = v23 + 24 * v34++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v359;
  v41 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_1008CCA0(*(float *)&v354, v41, 0.0, 0.0, 0.0, -4144960, v40);
  v42 = v23 + 24 * v34++;
  v347 = v34;
  v360 = v359 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5;
  v43 = v360;
  v361 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_1008CCA0(v361, v43, 0.0, 0.0, 0.0, -4144960, v42);
  *(_DWORD *)(v2 + 49316) = v34 - *(_DWORD *)(v2 + 49312);
  v362 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v44 = v362;
  v363 = v362 - 9.0;
  v45 = v363;
  v364 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  v46 = v364;
  v365 = 0.5 - (double)(signed int)(v44 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_10057680(v2 + 49728, v2 + 12320, v365, v46, v45, *(float *)(v2 + 51668), (int)&v347);
  v366 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v47 = v366;
  v367 = v366 - 9.0;
  v48 = v367;
  v368 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  v49 = v368;
  v369 = 0.5 - (double)(signed int)(v47 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_10057680(v2 + 49752, v2 + 12320, v369, v49, v48, *(float *)(v2 + 51668), (int)&v347);
  v370 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v50 = v370;
  v371 = v370 - 9.0;
  v51 = v371;
  v372 = *(float *)(v2 + 51668)
       + 6.0
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  v52 = v372;
  v373 = 0.5 - (double)(signed int)(v50 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_10057680(v2 + 49776, v2 + 12320, v373, v52, v51, *(float *)(v2 + 51668), (int)&v347);
  v374 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  v53 = v374;
  v375 = v374 - 9.0;
  v54 = v375;
  v376 = *(float *)(v2 + 51652) - 4.5 - v53 * 0.5;
  sub_10057680(v2 + 49800, v2 + 12320, v376, *(float *)(v2 + 24), v54, *(float *)(v2 + 51668), (int)&v347);
  v55 = v347;
  *(_DWORD *)(v2 + 49356) = 68;
  *(_DWORD *)(v2 + 49360) = v55;
  v377 = *(float *)(v2 + 24) - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 - 4.0;
  v56 = v377;
  v378 = *(float *)(v2 + 51652) - 4.5 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_10057920(v2 + 12320, &v347, (int)"NR", -1, v2 + 51628, v378, v56, 0.5, 0.0);
  v57 = v347;
  v58 = (float *)(v2 + 49856);
  *(_DWORD *)(v2 + 49364) = v347 - *(_DWORD *)(v2 + 49360);
  *(_DWORD *)(v2 + 49332) = 68;
  *(_DWORD *)(v2 + 49336) = v57;
  v379 = v2 + 49856;
  v354 = 14;
  do
  {
    if ( *(_BYTE *)v58 )
    {
      v348 = *(float *)(v2 + 4) - *(float *)(v2 + 51668) * 1.5;
      v352 = (*(v58 - 7) + 90.0) * 0.01745329251994333;
      v353 = sin(v352);
      v353 = v353 * v348 + *(float *)(v2 + 12);
      v59 = v353;
      v353 = cos(v352);
      v353 = v353 * v348 + *(float *)(v2 + 8);
      sub_10057920(v2 + 12320, &v347, (int)v58, -4144960, v2 + 51628, v353, v59, 0.5, 0.5);
      v58 = (float *)v379;
    }
    v58 += 9;
    v60 = v354-- == 1;
    v379 = (int)v58;
  }
  while ( !v60 );
  v61 = v347;
  *(_DWORD *)(v2 + 49340) = v347 - *(_DWORD *)(v2 + 49336);
  *(_DWORD *)(v2 + 49680) = 68;
  *(_DWORD *)(v2 + 49684) = v61;
  v380 = 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0)
       + *(float *)(v2 + 51680)
       + 2.0;
  v62 = v380;
  v381 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 12320, &v347, (int)&unk_100C3160, -256, v2 + 51616, v381, v62, 0.0, 0.0);
  v63 = v347;
  *(_DWORD *)(v2 + 49688) = v347 - *(_DWORD *)(v2 + 49684);
  *(_DWORD *)(v2 + 49692) = 68;
  *(_DWORD *)(v2 + 49696) = v63;
  v382 = 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + *(float *)(v2 + 51680)
       + 2.0;
  v64 = v382;
  v383 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 12320, &v347, (int)&unk_100C3160, -256, v2 + 51616, v383, v64, 0.0, 0.0);
  v65 = v347;
  *(_DWORD *)(v2 + 49700) = v347 - *(_DWORD *)(v2 + 49696);
  *(_DWORD *)(v2 + 49704) = 68;
  *(_DWORD *)(v2 + 49708) = v65;
  v384 = *(float *)(v2 + 51668)
       + 6.0
       + 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + *(float *)(v2 + 51680)
       + 2.0;
  v66 = v384;
  v385 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 12320, &v347, (int)&unk_100C3160, -256, v2 + 51616, v385, v66, 0.0, 0.0);
  v67 = v347;
  *(_DWORD *)(v2 + 49712) = v347 - *(_DWORD *)(v2 + 49708);
  *(_DWORD *)(v2 + 49716) = 68;
  *(_DWORD *)(v2 + 49720) = v67;
  v386 = *(float *)(v2 + 24) - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 - 4.0 + 1.0;
  v68 = v386;
  v387 = *(float *)(v2 + 51652)
       - 4.5
       - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2))
       + *(float *)(v2 + 51700);
  sub_10057920(v2 + 12320, &v347, (int)&unk_100C3160, -256, v2 + 51616, v387, v68, 0.0, 0.0);
  v69 = v347;
  *(_DWORD *)(v2 + 49724) = v347 - *(_DWORD *)(v2 + 49720);
  *(_DWORD *)(v2 + 49368) = 68;
  *(_DWORD *)(v2 + 49372) = v69;
  v348 = 0.5
       - (double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) * 0.5 + 4.5)
       + *(float *)(v2 + 51652);
  v388 = (double)(signed int)((double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2)) * 0.5
                                                 + 2.0)
                            + 0.5
                            + *(float *)(v2 + 51664) * 1.5)
       + 0.5;
  sub_10057920(v2 + 12320, &v347, (int)"ALTN", -256, v2 + 51628, v348, v388, 0.5, 0.5);
  v70 = v347;
  v71 = 3 * v347;
  *(_DWORD *)(v2 + 49376) = v347 - *(_DWORD *)(v2 + 49372);
  *(_DWORD *)(v2 + 49380) = 67;
  *(_DWORD *)(v2 + 49384) = v70;
  v351 = v388 - *(float *)(v2 + 51684) - 2.0;
  ++v70;
  *(float *)&v352 = v388 + *(float *)(v2 + 51680) + 2.0;
  v72 = 2.0 * *(float *)(v2 + 51700) + 1.0;
  v389 = v348 - v72;
  v348 = v72 + v348;
  sub_1008CCA0(v389, v351, 0.0, 0.0, 0.0, -256, v23 + 8 * v71);
  v73 = v23 + 24 * v70++;
  sub_1008CCA0(v389, *(float *)&v352, 0.0, 0.0, 0.0, -256, v73);
  v74 = v23 + 24 * v70++;
  sub_1008CCA0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -256, v74);
  v75 = v23 + 24 * v70++;
  sub_1008CCA0(v348, v351, 0.0, 0.0, 0.0, -256, v75);
  v76 = v23 + 24 * v70++;
  v347 = v70;
  sub_1008CCA0(v389, v351, 0.0, 0.0, 0.0, -256, v76);
  *(_DWORD *)(v2 + 49388) = v70 - *(_DWORD *)(v2 + 49384);
  *(_DWORD *)(v2 + 49392) = 68;
  *(_DWORD *)(v2 + 49396) = v70;
  v348 = 0.5
       - (double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) * 0.5 + 4.5)
       + *(float *)(v2 + 51652);
  v390 = (double)(signed int)((double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2)) * 0.5
                                                 + 2.0)
                            + 0.5
                            + *(float *)(v2 + 51664) * 1.5)
       + 0.5;
  sub_10057920(v2 + 12320, &v347, (int)"ALTN", -1, v2 + 51628, v348, v390, 0.5, 0.5);
  v77 = v347;
  v78 = 3 * v347;
  *(_DWORD *)(v2 + 49400) = v347 - *(_DWORD *)(v2 + 49396);
  *(_DWORD *)(v2 + 49404) = 67;
  *(_DWORD *)(v2 + 49408) = v77;
  v351 = v390 - *(float *)(v2 + 51684) - 2.0;
  ++v77;
  *(float *)&v352 = v390 + *(float *)(v2 + 51680) + 2.0;
  v79 = 2.0 * *(float *)(v2 + 51700) + 1.0;
  v391 = v348 - v79;
  v348 = v79 + v348;
  sub_1008CCA0(v391, v351, 0.0, 0.0, 0.0, -1, v23 + 8 * v78);
  v80 = v23 + 24 * v77++;
  sub_1008CCA0(v391, *(float *)&v352, 0.0, 0.0, 0.0, -1, v80);
  v81 = v23 + 24 * v77++;
  sub_1008CCA0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -1, v81);
  v82 = v23 + 24 * v77++;
  sub_1008CCA0(v348, v351, 0.0, 0.0, 0.0, -1, v82);
  v83 = v23 + 24 * v77++;
  v347 = v77;
  sub_1008CCA0(v391, v351, 0.0, 0.0, 0.0, -1, v83);
  *(_DWORD *)(v2 + 49412) = v77 - *(_DWORD *)(v2 + 49408);
  *(_DWORD *)(v2 + 49416) = 68;
  *(_DWORD *)(v2 + 49420) = v77;
  v392 = (double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2));
  v348 = *(float *)(v2 + 51652) - 2.0 - (double)(2 * ((signed int)(4.0 * v392) / 2)) * 0.5 - 7.0;
  v393 = (double)(signed int)(v392 * 0.5 + 2.0) + 0.5;
  sub_10057920(v2 + 12320, &v347, (int)"CYC CTR", -16777216, v2 + 51628, v348, v393, 0.5, 0.5);
  v84 = v347;
  *(_DWORD *)(v2 + 49424) = v347 - *(_DWORD *)(v2 + 49420);
  *(_DWORD *)(v2 + 49428) = 68;
  *(_DWORD *)(v2 + 49432) = v84;
  v85 = v23 + 24 * v84;
  v351 = v393 - *(float *)(v2 + 51684) - 1.0;
  ++v84;
  *(float *)&v352 = v393 + *(float *)(v2 + 51680) + 2.0;
  v86 = *(float *)(v2 + 51700) * 3.5;
  v394 = v348 - (v86 + 0.0);
  v348 = v86 + 1.0 + v348;
  sub_1008CCA0(v394, v351, 0.0, 0.0, 0.0, -256, v85);
  v87 = v23 + 24 * v84++;
  sub_1008CCA0(v394, *(float *)&v352, 0.0, 0.0, 0.0, -256, v87);
  v88 = v23 + 24 * v84++;
  sub_1008CCA0(v348, v351, 0.0, 0.0, 0.0, -256, v88);
  v89 = v23 + 24 * v84++;
  sub_1008CCA0(v348, v351, 0.0, 0.0, 0.0, -256, v89);
  v90 = v23 + 24 * v84++;
  sub_1008CCA0(v394, *(float *)&v352, 0.0, 0.0, 0.0, -256, v90);
  v91 = v23 + 24 * v84++;
  v347 = v84;
  sub_1008CCA0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -256, v91);
  *(_DWORD *)(v2 + 49436) = v84 - *(_DWORD *)(v2 + 49432);
  *(_DWORD *)(v2 + 49452) = 68;
  *(_DWORD *)(v2 + 49456) = v84;
  v395 = *(float *)(v2 + 12) - (*(float *)(v2 + 51668) * 0.5 + 3.0);
  v92 = v395;
  v396 = *(float *)(v2 + 8) - *(float *)(v2 + 4) * 0.4000000059604645;
  sub_10057920(v2 + 12320, &v347, (int)"5 MIN", -256, v2 + 51628, v396, v92, 0.5, 0.0);
  v93 = v347;
  v94 = v23 + 24 * v347;
  *(_DWORD *)(v2 + 49460) = v347 - *(_DWORD *)(v2 + 49456);
  *(_DWORD *)(v2 + 49560) = 68;
  *(_DWORD *)(v2 + 49564) = v93++;
  sub_1008CCA0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -65536, v94);
  v95 = v23 + 24 * v93++;
  v397 = *(float *)(v2 + 4) + 10.0;
  sub_1008CCA0(-8.0, v397, 0.0, 0.0, 0.0, -65536, v95);
  v96 = v23 + 24 * v93++;
  v398 = *(float *)(v2 + 4) + 10.0;
  sub_1008CCA0(8.0, v398, 0.0, 0.0, 0.0, -65536, v96);
  *(_DWORD *)(v2 + 49568) = v93 - *(_DWORD *)(v2 + 49564);
  v97 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49572) = 67;
  *(_DWORD *)(v2 + 49576) = v93++;
  sub_1008CCA0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16777216, v97);
  v98 = v23 + 24 * v93++;
  v399 = *(float *)(v2 + 4) + 10.0;
  sub_1008CCA0(-8.0, v399, 0.0, 0.0, 0.0, -16777216, v98);
  v99 = v23 + 24 * v93++;
  v400 = *(float *)(v2 + 4) + 10.0;
  sub_1008CCA0(8.0, v400, 0.0, 0.0, 0.0, -16777216, v99);
  v100 = v23 + 24 * v93++;
  sub_1008CCA0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16777216, v100);
  v101 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49580) = v93 - *(_DWORD *)(v2 + 49576);
  *(_DWORD *)(v2 + 49584) = 69;
  *(_DWORD *)(v2 + 49588) = v93++;
  sub_1008CCA0(-2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -65281, v101);
  v102 = v23 + 24 * v93++;
  sub_1008CCA0(2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -65281, v102);
  v103 = v23 + 24 * v93++;
  v401 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_1008CCA0(-2.0, v401, 0.0, 0.0, 0.0, -65281, v103);
  v104 = v23 + 24 * v93++;
  v402 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_1008CCA0(2.0, v402, 0.0, 0.0, 0.0, -65281, v104);
  v105 = v23 + 24 * v93++;
  v403 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_1008CCA0(-5.5430002, v403, 0.0, 0.0, 0.0, -65281, v105);
  v106 = v23 + 24 * v93++;
  v404 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_1008CCA0(5.5430002, v404, 0.0, 0.0, 0.0, -65281, v106);
  v107 = v23 + 24 * v93++;
  v405 = *(float *)(v2 + 16) + 14.0;
  sub_1008CCA0(-6.0, v405, 0.0, 0.0, 0.0, -65281, v107);
  v108 = v23 + 24 * v93++;
  v406 = *(float *)(v2 + 16) + 14.0;
  sub_1008CCA0(6.0, v406, 0.0, 0.0, 0.0, -65281, v108);
  v109 = v23 + 24 * v93++;
  v407 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_1008CCA0(-5.5430002, v407, 0.0, 0.0, 0.0, -65281, v109);
  v110 = v23 + 24 * v93++;
  v408 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_1008CCA0(5.5430002, v408, 0.0, 0.0, 0.0, -65281, v110);
  v111 = v23 + 24 * v93++;
  v409 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_1008CCA0(-2.296, v409, 0.0, 0.0, 0.0, -65281, v111);
  v112 = v23 + 24 * v93++;
  v410 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_1008CCA0(2.296, v410, 0.0, 0.0, 0.0, -65281, v112);
  v113 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49592) = v93 - *(_DWORD *)(v2 + 49588);
  *(_DWORD *)(v2 + 49596) = 67;
  *(_DWORD *)(v2 + 49600) = v93++;
  sub_1008CCA0(-2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -16777216, v113);
  v114 = v23 + 24 * v93++;
  v411 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_1008CCA0(-2.0, v411, 0.0, 0.0, 0.0, -16777216, v114);
  v115 = v23 + 24 * v93++;
  v412 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_1008CCA0(-5.5430002, v412, 0.0, 0.0, 0.0, -16777216, v115);
  v116 = v23 + 24 * v93++;
  v413 = *(float *)(v2 + 16) + 14.0;
  sub_1008CCA0(-6.0, v413, 0.0, 0.0, 0.0, -16777216, v116);
  v117 = v23 + 24 * v93++;
  v414 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_1008CCA0(-5.5430002, v414, 0.0, 0.0, 0.0, -16777216, v117);
  v118 = v23 + 24 * v93++;
  v415 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_1008CCA0(-2.296, v415, 0.0, 0.0, 0.0, -16777216, v118);
  v119 = v23 + 24 * v93++;
  v416 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_1008CCA0(2.296, v416, 0.0, 0.0, 0.0, -16777216, v119);
  v120 = v23 + 24 * v93++;
  v417 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_1008CCA0(5.5430002, v417, 0.0, 0.0, 0.0, -16777216, v120);
  v121 = v23 + 24 * v93++;
  v418 = *(float *)(v2 + 16) + 14.0;
  sub_1008CCA0(6.0, v418, 0.0, 0.0, 0.0, -16777216, v121);
  v122 = v23 + 24 * v93++;
  v419 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_1008CCA0(5.5430002, v419, 0.0, 0.0, 0.0, -16777216, v122);
  v123 = v23 + 24 * v93++;
  v420 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_1008CCA0(2.0, v420, 0.0, 0.0, 0.0, -16777216, v123);
  v124 = v23 + 24 * v93++;
  sub_1008CCA0(2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -16777216, v124);
  *(_DWORD *)(v2 + 49604) = v93 - *(_DWORD *)(v2 + 49600);
  v125 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49620) = 69;
  *(_DWORD *)(v2 + 49624) = v93++;
  sub_1008CCA0(-3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -1, v125);
  v126 = v23 + 24 * v93++;
  sub_1008CCA0(3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -1, v126);
  v127 = v23 + 24 * v93++;
  v421 = *(float *)(v2 + 4) + 9.0;
  sub_1008CCA0(-3.0, v421, 0.0, 0.0, 0.0, -1, v127);
  v128 = v23 + 24 * v93++;
  v422 = *(float *)(v2 + 4) + 9.0;
  sub_1008CCA0(3.0, v422, 0.0, 0.0, 0.0, -1, v128);
  v129 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49628) = v93 - *(_DWORD *)(v2 + 49624);
  *(_DWORD *)(v2 + 49608) = 69;
  *(_DWORD *)(v2 + 49612) = v93++;
  v423 = *(float *)(v2 + 4) + 16.0;
  sub_1008CCA0(0.0, v423, 0.0, 0.0, 0.0, -1, v129);
  sub_100959E0(0.0, (int)&v349, (int)&v350);
  v130 = v23 + 24 * v93++;
  v424 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v131 = v424;
  v425 = 8.0 * *(float *)&v350;
  sub_1008CCA0(v425, v131, 0.0, 0.0, 0.0, -1, v130);
  sub_100959E0(0.62831855, (int)&v349, (int)&v350);
  v132 = v23 + 24 * v93;
  v133 = v93 + 1;
  v426 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v134 = v426;
  v427 = 8.0 * *(float *)&v350;
  sub_1008CCA0(v427, v134, 0.0, 0.0, 0.0, -1, v132);
  v428 = 2;
  v354 = v23 + 24 * v133;
  do
  {
    v353 = (double)v428 * 6.283185482025146 / 10.0;
    sub_100959E0(v353, (int)&v349, (int)&v350);
    v135 = v354;
    v354 += 24;
    v353 = *(float *)(v2 + 4) + 16.0;
    sub_1008CCA0(0.0, v353, 0.0, 0.0, 0.0, -1, v135);
    v136 = v354;
    v133 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
    v137 = v353;
    v353 = 8.0 * *(float *)&v350;
    sub_1008CCA0(v353, v137, 0.0, 0.0, 0.0, -1, v136);
    v139 = __OFSUB__(v428 + 1, 10);
    v60 = v428 == 9;
    v138 = v428++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  v140 = v23 + 24 * v133;
  *(_DWORD *)(v2 + 49616) = v133 - *(_DWORD *)(v2 + 49612);
  *(_DWORD *)(v2 + 49644) = 69;
  *(_DWORD *)(v2 + 49648) = v133;
  v141 = v133 + 1;
  sub_1008CCA0(-3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16711681, v140);
  v142 = v23 + 24 * v141++;
  sub_1008CCA0(3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16711681, v142);
  v143 = v23 + 24 * v141++;
  v429 = *(float *)(v2 + 4) + 9.0;
  sub_1008CCA0(-3.0, v429, 0.0, 0.0, 0.0, -16711681, v143);
  v144 = v23 + 24 * v141++;
  v430 = *(float *)(v2 + 4) + 9.0;
  sub_1008CCA0(3.0, v430, 0.0, 0.0, 0.0, -16711681, v144);
  *(_DWORD *)(v2 + 49652) = v141 - *(_DWORD *)(v2 + 49648);
  *(_DWORD *)(v2 + 49632) = 69;
  *(_DWORD *)(v2 + 49636) = v141;
  v145 = v23 + 24 * v141++;
  v431 = *(float *)(v2 + 4) + 16.0;
  sub_1008CCA0(0.0, v431, 0.0, 0.0, 0.0, -16711681, v145);
  sub_100959E0(0.0, (int)&v349, (int)&v350);
  v146 = v23 + 24 * v141++;
  v432 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v147 = v432;
  v433 = 8.0 * *(float *)&v350;
  sub_1008CCA0(v433, v147, 0.0, 0.0, 0.0, -16711681, v146);
  sub_100959E0(0.62831855, (int)&v349, (int)&v350);
  v148 = v23 + 24 * v141;
  v149 = v141 + 1;
  v434 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v150 = v434;
  v435 = 8.0 * *(float *)&v350;
  sub_1008CCA0(v435, v150, 0.0, 0.0, 0.0, -16711681, v148);
  v436 = 2;
  v354 = v23 + 24 * v149;
  do
  {
    v353 = (double)v436 * 6.283185482025146 / 10.0;
    sub_100959E0(v353, (int)&v349, (int)&v350);
    v151 = v354;
    v354 += 24;
    v353 = *(float *)(v2 + 4) + 16.0;
    sub_1008CCA0(0.0, v353, 0.0, 0.0, 0.0, -16711681, v151);
    v152 = v354;
    v149 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
    v153 = v353;
    v353 = 8.0 * *(float *)&v350;
    sub_1008CCA0(v353, v153, 0.0, 0.0, 0.0, -16711681, v152);
    v139 = __OFSUB__(v436 + 1, 10);
    v60 = v436 == 9;
    v138 = v436++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  *(_DWORD *)(v2 + 49640) = v149 - *(_DWORD *)(v2 + 49636);
  *(_DWORD *)(v2 + 49656) = 69;
  *(_DWORD *)(v2 + 49660) = v149;
  sub_100959E0(0.0, (int)&v349, (int)&v350);
  v154 = v23 + 24 * v149;
  v155 = v149 + 1;
  v437 = *(float *)&v349 * 2.0 + *(float *)(v2 + 4) + 16.0;
  v156 = v437;
  v438 = 2.0 * *(float *)&v350;
  sub_1008CCA0(v438, v156, 0.0, 0.0, 0.0, -16777216, v154);
  v157 = v23 + 24 * v155;
  v158 = v155 + 1;
  v439 = *(float *)&v349 * 6.0 + *(float *)(v2 + 4) + 16.0;
  v159 = v439;
  v440 = 6.0 * *(float *)&v350;
  sub_1008CCA0(v440, v159, 0.0, 0.0, 0.0, -16777216, v157);
  v441 = 1;
  v354 = v23 + 24 * v158;
  do
  {
    v353 = (double)v441 * 6.283185482025146 / 10.0;
    sub_100959E0(v353, (int)&v349, (int)&v350);
    v160 = v354;
    v354 += 24;
    v353 = *(float *)&v349 * 6.0 + *(float *)(v2 + 4) + 16.0;
    v161 = v353;
    v353 = 6.0 * *(float *)&v350;
    sub_1008CCA0(v353, v161, 0.0, 0.0, 0.0, -16777216, v160);
    v162 = v354;
    v158 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 2.0 + *(float *)(v2 + 4) + 16.0;
    v163 = v353;
    v353 = 2.0 * *(float *)&v350;
    sub_1008CCA0(v353, v163, 0.0, 0.0, 0.0, -16777216, v162);
    v139 = __OFSUB__(v441 + 1, 10);
    v60 = v441 == 9;
    v138 = v441++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  v164 = v23 + 24 * v158;
  *(_DWORD *)(v2 + 49664) = v158 - *(_DWORD *)(v2 + 49660);
  *(_DWORD *)(v2 + 49668) = 69;
  *(_DWORD *)(v2 + 49672) = v158;
  v165 = v158 + 1;
  v442 = *(float *)(v2 + 4) + 16.0 - 5.0;
  sub_1008CCA0(-1.2, v442, 0.0, 0.0, 0.0, -16777216, v164);
  v166 = v23 + 24 * v165++;
  v443 = *(float *)(v2 + 4) + 16.0 - 5.0;
  sub_1008CCA0(1.2, v443, 0.0, 0.0, 0.0, -16777216, v166);
  v167 = v23 + 24 * v165++;
  v444 = *(float *)(v2 + 4) + 16.0 + 5.0;
  sub_1008CCA0(-1.2, v444, 0.0, 0.0, 0.0, -16777216, v167);
  v168 = v23 + 24 * v165++;
  v445 = *(float *)(v2 + 4) + 16.0 + 5.0;
  sub_1008CCA0(1.2, v445, 0.0, 0.0, 0.0, -16777216, v168);
  *(_DWORD *)(v2 + 49676) = v165 - *(_DWORD *)(v2 + 49672);
  *(_DWORD *)(v2 + 49184) = v165;
  sub_1008CD40(&unk_101DEDC8, 0, v2 + 12320, (_DWORD *)(24 * v165), 0x9000u);
  *(_DWORD *)(v2 + 12316) = 0;
  *(_DWORD *)(v2 + 49440) = 67;
  *(_DWORD *)(v2 + 49444) = 0;
  v169 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v446 = v169 - *(float *)(v2 + 51700) * 3.0 - (*(float *)(v2 + 51696) + 1.0) - 3.0;
  v348 = v169;
  v351 = -*(float *)(v2 + 51684) - 4.0;
  *(float *)&v352 = *(float *)(v2 + 51680) + 4.0;
  sub_1008CCA0(v348, v351, 0.0, 0.0, 0.0, -16728064, v2 + 28);
  sub_1008CCA0(v446, v351, 0.0, 0.0, 0.0, -16728064, v2 + 52);
  sub_1008CCA0(v446, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v2 + 76);
  sub_1008CCA0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v2 + 100);
  *(float *)&v354 = *(float *)&v352 + 1.0;
  sub_1008CCA0(v348, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 124);
  v447 = v446 - 1.0;
  sub_1008CCA0(v447, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 148);
  *(float *)&v354 = v351 - 1.0;
  sub_1008CCA0(v447, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 172);
  v347 = 8;
  sub_1008CCA0(v348, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 196);
  *(_DWORD *)(v2 + 49448) = 8 - *(_DWORD *)(v2 + 49444);
  *(_DWORD *)(v2 + 49344) = 68;
  *(_DWORD *)(v2 + 49348) = 8;
  v448 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  v170 = v448;
  v449 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 28, &v347, (int)&unk_100E4F94, -1, v2 + 51628, v449, v170, 1.0, 0.5);
  v450 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5;
  v171 = v450;
  v451 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 28, &v347, dword_1031FB44 + 7664, -1, v2 + 51628, v451, v171, 1.0, 0.5);
  v452 = *(float *)(v2 + 51668)
       + 6.0
       + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5;
  v172 = v452;
  v453 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_10057920(v2 + 28, &v347, (int)&unk_100E4F90, -1, v2 + 51628, v453, v172, 1.0, 0.5);
  *(_DWORD *)(v2 + 49352) = v347 - *(_DWORD *)(v2 + 49348);
  sub_10055120(&unk_100E4E80, v2 + 49236, 0.0, 0.0, *(float *)(v2 + 4), 0, 2, &v347, v2 + 28, 1);
  v173 = v347;
  v348 = *(float *)(v2 + 4) - 5.0;
  v174 = v2 + 28 + 24 * v347;
  *(float *)(v2 + 51128) = 9.8999998e24;
  *(_DWORD *)(v2 + 51136) = 68;
  *(_DWORD *)(v2 + 51140) = v173++;
  sub_1008CCA0(0.0, 0.0, 0.0, 0.0, 0.0, -16728064, v174);
  v175 = v2 + 28 + 24 * v173;
  v454 = 0.8500000238418579 * v348;
  ++v173;
  *(float *)&v354 = -v348 * 0.07000000029802322;
  sub_1008CCA0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16728064, v175);
  v176 = v2 + 28 + 24 * v173;
  v353 = v348 * 0.07000000029802322;
  ++v173;
  sub_1008CCA0(v353, v454, 0.0, 0.0, 0.0, -16728064, v176);
  v177 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16728064, v177);
  v178 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v178);
  v179 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v353, v454, 0.0, 0.0, 0.0, -16728064, v179);
  v180 = v2 + 28 + 24 * v173;
  *(_DWORD *)(v2 + 51144) = v173 - *(_DWORD *)(v2 + 51140);
  *(_DWORD *)(v2 + 51148) = 67;
  *(_DWORD *)(v2 + 51152) = v173++;
  sub_1008CCA0(0.0, 0.0, 0.0, 0.0, 0.0, -16777216, v180);
  v181 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16777216, v181);
  v182 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v182);
  v183 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v353, v454, 0.0, 0.0, 0.0, -16777216, v183);
  v184 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, 0.0, 0.0, 0.0, 0.0, -16777216, v184);
  *(_DWORD *)(v2 + 51156) = v173 - *(_DWORD *)(v2 + 51152);
  v185 = v2 + 28 + 24 * v173;
  v348 = *(float *)(v2 + 16) * 0.75;
  *(float *)&v352 = *(float *)(v2 + 16) * 0.25;
  *(float *)(v2 + 51160) = 9.8999998e24;
  *(_DWORD *)(v2 + 51168) = 68;
  v186 = v348;
  *(_DWORD *)(v2 + 51172) = v173++;
  v353 = v186 * -0.02999999932944775;
  sub_1008CCA0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v185);
  v187 = v2 + 28 + 24 * v173;
  v455 = 0.8500000238418579 * v348;
  ++v173;
  *(float *)&v347 = v348 * -0.07999999821186066;
  sub_1008CCA0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v187);
  v188 = v2 + 28 + 24 * v173;
  v351 = v348 * 0.02999999932944775;
  ++v173;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v188);
  v189 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v189);
  v190 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v190);
  v191 = v2 + 28 + 24 * v173;
  *(float *)&v354 = v348 * 0.07999999821186066;
  ++v173;
  sub_1008CCA0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16728064, v191);
  v192 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v192);
  v193 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v193);
  v194 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16728064, v194);
  v195 = v2 + 28 + 24 * v173;
  v196 = *(float *)&v352;
  *(_DWORD *)(v2 + 51176) = v173 - *(_DWORD *)(v2 + 51172);
  v197 = v196;
  *(_DWORD *)(v2 + 51180) = 67;
  v198 = v353;
  *(_DWORD *)(v2 + 51184) = v173;
  v199 = v198;
  ++v173;
  sub_1008CCA0(v199, v197, 0.0, 0.0, 0.0, -16777216, v195);
  v200 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16777216, v200);
  v201 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v201);
  v202 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16777216, v202);
  v203 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v203);
  v204 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v204);
  *(_DWORD *)(v2 + 51188) = v173 - *(_DWORD *)(v2 + 51184);
  v205 = v2 + 28 + 24 * v173;
  v348 = *(float *)(v2 + 16) - 5.0;
  *(float *)(v2 + 51192) = 9.8999998e24;
  *(_DWORD *)(v2 + 51200) = 68;
  v206 = v348;
  *(_DWORD *)(v2 + 51204) = v173++;
  v353 = v206 * -0.02999999932944775;
  sub_1008CCA0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v205);
  v207 = v2 + 28 + 24 * v173;
  v456 = v348 * 0.8500000238418579;
  ++v173;
  sub_1008CCA0(v353, v456, 0.0, 0.0, 0.0, -16728064, v207);
  v208 = v2 + 28 + 24 * v173;
  v351 = v348 * 0.02999999932944775;
  ++v173;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v208);
  v209 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v209);
  v210 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v353, v456, 0.0, 0.0, 0.0, -16728064, v210);
  v211 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, v456, 0.0, 0.0, 0.0, -16728064, v211);
  v212 = v2 + 28 + 24 * v173;
  *(float *)&v347 = v348 * -0.07999999821186066;
  ++v173;
  sub_1008CCA0(*(float *)&v347, v456, 0.0, 0.0, 0.0, -16728064, v212);
  v213 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v213);
  v214 = v2 + 28 + 24 * v173;
  *(float *)&v354 = v348 * 0.07999999821186066;
  ++v173;
  sub_1008CCA0(*(float *)&v354, v456, 0.0, 0.0, 0.0, -16728064, v214);
  v215 = v2 + 28 + 24 * v173;
  v216 = *(float *)&v352;
  *(_DWORD *)(v2 + 51208) = v173 - *(_DWORD *)(v2 + 51204);
  v217 = v216;
  *(_DWORD *)(v2 + 51212) = 67;
  v218 = v353;
  *(_DWORD *)(v2 + 51216) = v173;
  v219 = v218;
  ++v173;
  sub_1008CCA0(v219, v217, 0.0, 0.0, 0.0, -16777216, v215);
  v220 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v353, v456, 0.0, 0.0, 0.0, -16777216, v220);
  v221 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v347, v456, 0.0, 0.0, 0.0, -16777216, v221);
  v222 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v222);
  v223 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(*(float *)&v354, v456, 0.0, 0.0, 0.0, -16777216, v223);
  v224 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, v456, 0.0, 0.0, 0.0, -16777216, v224);
  v225 = v2 + 28 + 24 * v173++;
  sub_1008CCA0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v225);
  v226 = 3 * v173++;
  v347 = v173;
  sub_1008CCA0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v2 + 28 + 8 * v226);
  *(_DWORD *)(v2 + 51220) = v173 - *(_DWORD *)(v2 + 51216);
  sub_100581D0(v2, &v347);
  v227 = v347;
  *(_DWORD *)(v2 + 51264) = 68;
  *(_DWORD *)(v2 + 51268) = v227;
  v457 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v228 = v457;
  v348 = *(float *)(v2 + 51652) - 4.5 - v457;
  v229 = v2 + 28 + 24 * v227;
  v230 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v458 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  *(float *)&v354 = v458 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + 2.0;
  v231 = *(float *)&v354;
  *(float *)&v354 = v228 + v348;
  sub_1008CCA0(*(float *)&v354, v231, 0.0, 0.0, 0.0, v230, v229);
  v232 = v2 + 28 + 24 * v227;
  v233 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  v234 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v234, 0.0, 0.0, 0.0, v233, v232);
  v235 = *(_DWORD *)(v2 + 51488);
  *(float *)&v352 = v348 + 1.0;
  v236 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v235, v236);
  v237 = v2 + 28 + 24 * v227;
  v238 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v238, v237);
  v239 = v2 + 28 + 24 * v227;
  v240 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v240, v239);
  v241 = v2 + 28 + 24 * v227;
  v242 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v243 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v243, 0.0, 0.0, 0.0, v242, v241);
  v244 = v2 + 28 + 24 * v227;
  v245 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v246 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v246, 0.0, 0.0, 0.0, v245, v244);
  v247 = v2 + 28 + 24 * v227;
  v248 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v249 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v249, 0.0, 0.0, 0.0, v248, v247);
  v250 = v2 + 28 + 24 * v227++;
  v251 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v252 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v252, 0.0, 0.0, 0.0, v251, v250);
  v253 = v2 + 28 + 24 * v227;
  v254 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v255 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v255, 0.0, 0.0, 0.0, v254, v253);
  v256 = v2 + 28 + 24 * v227;
  v257 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v258 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v258, 0.0, 0.0, 0.0, v257, v256);
  v259 = *(_DWORD *)(v2 + 51488);
  v351 = v348 + 3.0;
  v260 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v259, v260);
  v261 = v2 + 28 + 24 * v227;
  v262 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v262, v261);
  v263 = v2 + 28 + 24 * v227;
  v264 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v265 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v265, 0.0, 0.0, 0.0, v264, v263);
  v266 = v2 + 28 + 24 * v227;
  v267 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v267, v266);
  v268 = v2 + 28 + 24 * v227;
  v269 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v269, v268);
  v270 = v2 + 28 + 24 * v227;
  v271 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v271, v270);
  v272 = v2 + 28 + 24 * v227++;
  v459 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_1008CCA0(*(float *)&v352, v459, 0.0, 0.0, 0.0, *(_DWORD *)(v2 + 51488), v272);
  *(_DWORD *)(v2 + 51272) = v227 - *(_DWORD *)(v2 + 51268);
  *(_DWORD *)(v2 + 51316) = 68;
  *(_DWORD *)(v2 + 51320) = v227;
  v348 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v273 = v2 + 28 + 24 * v227;
  v274 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v460 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  *(float *)&v352 = v348 + 1.0;
  *(float *)&v354 = 1.0 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + v460;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v274, v273);
  v275 = v2 + 28 + 24 * v227;
  v276 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v460 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v277 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v277, 0.0, 0.0, 0.0, v276, v275);
  v278 = v2 + 28 + 24 * v227;
  v279 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v460;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v279, v278);
  v280 = v2 + 28 + 24 * v227++;
  v281 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v460;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v281, v280);
  v282 = v2 + 28 + 24 * v227;
  v283 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v460 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v284 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v284, 0.0, 0.0, 0.0, v283, v282);
  v285 = v2 + 28 + 24 * v227;
  v286 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v461 = (double)v354 * 0.5 + v460;
  v287 = v461;
  v462 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(v462, v287, 0.0, 0.0, 0.0, v286, v285);
  *(_DWORD *)(v2 + 51324) = v227 - *(_DWORD *)(v2 + 51320);
  *(_DWORD *)(v2 + 51368) = 68;
  *(_DWORD *)(v2 + 51372) = v227;
  v348 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v288 = v2 + 28 + 24 * v227;
  v289 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v463 = *(float *)(v2 + 51668)
       + 6.0
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  *(float *)&v352 = v348 + 1.0;
  *(float *)&v354 = 1.0 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + v463;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v289, v288);
  v290 = v2 + 28 + 24 * v227;
  v291 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v463 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v292 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v292, 0.0, 0.0, 0.0, v291, v290);
  v293 = v2 + 28 + 24 * v227;
  v294 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v294, v293);
  v295 = v2 + 28 + 24 * v227;
  v296 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_1008CCA0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v296, v295);
  v297 = v2 + 28 + 24 * v227;
  v298 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v463 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v299 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v299, 0.0, 0.0, 0.0, v298, v297);
  v300 = v2 + 28 + 24 * v227;
  v301 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v302 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v302, 0.0, 0.0, 0.0, v301, v300);
  v303 = v2 + 28 + 24 * v227;
  v304 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v305 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v305, 0.0, 0.0, 0.0, v304, v303);
  v306 = v2 + 28 + 24 * v227;
  v307 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v308 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v308, 0.0, 0.0, 0.0, v307, v306);
  v309 = v2 + 28 + 24 * v227;
  v310 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v311 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v311, 0.0, 0.0, 0.0, v310, v309);
  v312 = v2 + 28 + 24 * v227;
  v313 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v314 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v314, 0.0, 0.0, 0.0, v313, v312);
  v315 = v2 + 28 + 24 * v227;
  v316 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v317 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v317, 0.0, 0.0, 0.0, v316, v315);
  v318 = v2 + 28 + 24 * v227++;
  v351 = v348 + 3.0;
  v319 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v319, v318);
  v320 = v2 + 28 + 24 * v227;
  v321 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v321, v320);
  v322 = v2 + 28 + 24 * v227;
  v323 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v324 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_1008CCA0(*(float *)&v354, v324, 0.0, 0.0, 0.0, v323, v322);
  v325 = v2 + 28 + 24 * v227;
  v326 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v326, v325);
  v327 = v2 + 28 + 24 * v227;
  v328 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v328, v327);
  v329 = v2 + 28 + 24 * v227;
  v330 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_1008CCA0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v330, v329);
  v331 = v2 + 28 + 24 * v227;
  v332 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v464 = (double)v354 * 0.5 + v463 - 1.0;
  sub_1008CCA0(*(float *)&v352, v464, 0.0, 0.0, 0.0, v332, v331);
  *(_DWORD *)(v2 + 51376) = v227 - *(_DWORD *)(v2 + 51372);
  *(_DWORD *)(v2 + 51420) = 68;
  *(_DWORD *)(v2 + 51424) = v227;
  v333 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
  v334 = v2 + 28 + 24 * v227++;
  v348 = *(float *)(v2 + 51652) - 4.5 - v333;
  v465 = *(float *)(v2 + 24);
  *(float *)&v354 = v465 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + 1.0;
  v335 = *(float *)&v354;
  *(float *)&v354 = v348 - v333 + 1.0;
  sub_1008CCA0(*(float *)&v354, v335, 0.0, 0.0, 0.0, -16777216, v334);
  v336 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v465 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v337 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v337, 0.0, 0.0, 0.0, -16777216, v336);
  v338 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v465;
  v339 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + 1.0;
  sub_1008CCA0(*(float *)&v354, v339, 0.0, 0.0, 0.0, -16777216, v338);
  v340 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v465;
  v341 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + 1.0;
  sub_1008CCA0(*(float *)&v354, v341, 0.0, 0.0, 0.0, -16777216, v340);
  v342 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v465 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v343 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_1008CCA0(*(float *)&v354, v343, 0.0, 0.0, 0.0, -16777216, v342);
  v344 = v2 + 28 + 24 * v227++;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v466 = (double)v354 * 0.5 + v465;
  v345 = v466;
  v467 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_1008CCA0(v467, v345, 0.0, 0.0, 0.0, -16777216, v344);
  *(_DWORD *)(v2 + 51428) = v227 - *(_DWORD *)(v2 + 51424);
  *(_DWORD *)(v2 + 12316) = v227;
  sub_1008CD40(&unk_101DEDD4, 0, v2 + 28, (_DWORD *)(24 * v227), 0x3000u);
  *(float *)(v2 + 51128) = 0.0;
  *(float *)(v2 + 51160) = 0.0;
  *(float *)(v2 + 51192) = 0.0;
  return 2;
}
// 10055120: using guessed type int __cdecl sub_10055120(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1031FB44: using guessed type int dword_1031FB44;

//----- (1005EE70) --------------------------------------------------------
unsigned int __cdecl sub_1005EE70(int a1)
{
  int v1; // ebp@1
  char v2; // al@1
  bool v3; // zf@1
  int v4; // eax@1
  bool v5; // al@3
  void *v6; // ecx@7
  int *v7; // esi@18
  float *v8; // ebx@18
  int v9; // edx@20
  double v10; // st7@20
  _DWORD *v11; // ebx@25
  float *v12; // esi@25
  char v13; // dl@25
  double v14; // st7@28
  double v15; // st7@28
  float v16; // ecx@35
  int *v17; // esi@38
  float *v18; // ebx@38
  char v19; // dl@38
  int v20; // eax@41
  double v21; // st7@41
  int v22; // eax@49
  _BYTE *v23; // ebx@49
  int v24; // ecx@50
  unsigned __int8 v25; // al@51
  int v26; // esi@58
  double v27; // st7@61
  bool v28; // c3@63
  int *v29; // esi@64
  int v30; // edi@64
  char v31; // dl@64
  int v32; // esi@75
  bool v33; // al@77
  bool v34; // al@81
  double v35; // ST0C_8@83
  char *v36; // ebx@83
  int v37; // edx@87
  unsigned int result; // eax@88
  float v39; // [sp+18h] [bp-10h]@17
  int v40; // [sp+1Ch] [bp-Ch]@11
  float v41; // [sp+20h] [bp-8h]@20
  float v42; // [sp+24h] [bp-4h]@20

  v1 = a1;
  *(_BYTE *)(a1 + 51608) = 1;
  *(_BYTE *)(v1 + 51607) = 0;
  *(_BYTE *)(v1 + 51610) = sub_1006F520((int)"_start_mode");
  v2 = sub_1006F520((int)"_autorotation");
  *(_BYTE *)(v1 + 51602) = v2;
  v3 = v2 == 0;
  v4 = v1 + 50728;
  if ( v3 )
    v4 = v1 + 50332;
  *(_DWORD *)(v1 + 51124) = v4;
  *(_BYTE *)(v1 + 51609) = sub_1006F520((int)"_cyc_ctr");
  *(_BYTE *)(v1 + 51603) = sub_1006F520((int)"_quiet_mode");
  *(_BYTE *)(v1 + 51605) = sub_1006F520((int)"_engine_out");
  *(_BYTE *)(v1 + 51606) = sub_1006F520((int)"_manual_mode");
  *(_BYTE *)(v1 + 51613) = sub_1006F520((int)"_nr_inhibit");
  sub_10057EB0(24, 0, v1);
  sub_10057EB0(22, 1, v1);
  sub_10057EB0(20, 2, v1);
  v5 = sub_10057BC0(v1);
  if ( v5 != *(_BYTE *)(v1 + 51615) )
  {
    *(_BYTE *)(v1 + 51615) = v5;
    if ( v5 )
      sub_10054F20(v1);
    else
      sub_10055020(v1);
  }
  sub_1008CA60(41114, v1 + 51572, 20);
  sub_10058040(v6, v1);
  sub_10057EB0(26, 3, v1);
  sub_10057EB0(26, 4, v1);
  if ( !sub_1006F520((int)"_to_timer") || *(_BYTE *)(v1 + 51610) && *(_BYTE *)(v1 + 51484) == 1 )
  {
    if ( *(_DWORD *)(v1 + 51596) )
    {
      v40 = 0;
      sub_1008CB30(9212, (int)&v40, 4);
    }
    *(_DWORD *)(v1 + 51596) = 0;
    *(_BYTE *)(v1 + 51600) = 0;
  }
  else if ( !*(_DWORD *)(v1 + 51596) )
  {
    sub_1008CA60(9212, (int)&v40, 4);
    if ( !v40 )
    {
      v40 = 300000;
      sub_1008CB30(9212, (int)&v40, 4);
    }
    *(_DWORD *)(v1 + 51596) = v40 + sub_1008C780();
    sub_10064B00((char *)(v1 + 51432), 8u, "05:00");
  }
  v39 = -1.0;
  *(float *)(v1 + 51544) = 1000.0;
  if ( 9.8999998e24 == *(float *)(v1 + 51720) )
  {
    sub_10064B00((char *)(v1 + 51224), 8u, "     ");
    sub_10058000(v1 + 51264, v1, -16777216);
    *(float *)(v1 + 51520) = -1000.0;
  }
  else
  {
    v7 = (int *)(v1 + 51240);
    v8 = (float *)(v1 + 51532);
    sub_10058770(v1 + 51532, 2, 14, (float *)(v1 + 49828), v1 + 51720, v1 + 51520, (_DWORD *)(v1 + 51240));
    if ( *(_BYTE *)(v1 + 51605) )
      *v7 = -8355712;
    v9 = *v7;
    v39 = *(float *)(v1 + 51520);
    LOBYTE(a1) = 0;
    v10 = *v8;
    *(_DWORD *)(v1 + 51132) = v9;
    v42 = v10;
    v41 = *(float *)(v1 + 50260) - *(float *)(v1 + 51520);
    if ( *(float *)(v1 + 50260) - *v8 < 0.0 )
      *v7 = -65536;
    *(float *)(v1 + 51544) = v41;
    sub_10064B00((char *)(v1 + 51224), 8u, "%5.1f", *(float *)(v1 + 51724));
    *(_DWORD *)(v1 + 51492) = *v7;
    sub_10058170(v1, v1 + 51224);
  }
  if ( 9.8999998e24 == *(float *)(v1 + 51776) )
  {
    sub_10064B00((char *)(v1 + 51276), 8u, "    ");
    sub_10058000(v1 + 51316, v1, -16777216);
    *(float *)(v1 + 51524) = -1000.0;
  }
  else
  {
    v11 = (_DWORD *)(v1 + 51292);
    v12 = (float *)(v1 + 51524);
    sub_10058770(v1 + 51536, 1, 14, (float *)(v1 + 49828), v1 + 51776, v1 + 51524, (_DWORD *)(v1 + 51292));
    if ( *(_BYTE *)(v1 + 51605) )
      *v11 = -8355712;
    if ( v39 < (double)*v12 )
    {
      v14 = *v12;
      LOBYTE(a1) = v13;
      v39 = v14;
      v15 = *(float *)(v1 + 51536);
      *(_DWORD *)(v1 + 51132) = *v11;
      v42 = v15;
    }
    v41 = *(float *)(v1 + 51560);
    if ( sub_1006F520((int)"_mgt_lo_trans") )
      v41 = *(float *)(v1 + 51556);
    sub_10057D00(1, (float *)(v1 + 49828), 14, v41, v1 + 51568);
    v41 = *(float *)(v1 + 50260) - *v12;
    if ( *(float *)(v1 + 50260) - *(float *)(v1 + 51536) < 0.0 )
      *(_DWORD *)(v1 + 51292) = -65536;
    if ( *(float *)(v1 + 51544) > (double)v41 )
      *(float *)(v1 + 51544) = v41;
    sub_10064B00((char *)(v1 + 51276), 8u, "%4.0f", *(float *)(v1 + 51780));
    *(_DWORD *)(v1 + 51496) = *(_DWORD *)(v1 + 51292);
    sub_10058170(v1, v1 + 51276);
  }
  if ( 9.8999998e24 == *(float *)(v1 + 51832) )
  {
    sub_10064B00((char *)(v1 + 51328), 8u, "     ");
    sub_10058000(v1 + 51368, v1, -16777216);
    *(float *)(v1 + 51528) = -1000.0;
  }
  else
  {
    *(float *)(v1 + 50240) = sub_10057CB0(v1, v16);
    v17 = (int *)(v1 + 51344);
    v18 = (float *)(v1 + 51528);
    sub_10058770(v1 + 51540, 0, 14, (float *)(v1 + 49828), v1 + 51832, v1 + 51528, (_DWORD *)(v1 + 51344));
    if ( *(_BYTE *)(v1 + 51605) != v19 )
      *v17 = -8355712;
    if ( v39 < (double)*v18 )
    {
      v20 = *v17;
      v39 = *v18;
      LOBYTE(a1) = 2;
      v21 = *(float *)(v1 + 51540);
      *(_DWORD *)(v1 + 51132) = v20;
      v42 = v21;
    }
    v41 = *(float *)(v1 + 50224) - *v18;
    if ( *(float *)(v1 + 50224) - *(float *)(v1 + 51540) < 0.0 )
      *v17 = -65536;
    if ( *(float *)(v1 + 51544) > (double)v41 )
      *(float *)(v1 + 51544) = v41;
    sub_10064B00((char *)(v1 + 51328), 8u, "%5.1f", *(float *)(v1 + 51836));
    *(_DWORD *)(v1 + 51500) = *v17;
    sub_10058170(v1, v1 + 51328);
  }
  if ( v39 <= -1.0 )
  {
    *(_DWORD *)(v1 + 51132) = -16777216;
    v27 = 9.8999998e24;
    *(float *)(v1 + 51128) = 9.8999998e24;
  }
  else
  {
    v22 = *(_BYTE *)(v1 + 51484);
    *(float *)(v1 + 51128) = v39;
    v23 = (_BYTE *)(v1 + 51484);
    if ( v39 - *(float *)(v1 + 4 * v22 + 51520) > 3.0 )
    {
      v24 = (unsigned __int8)a1;
      *v23 = a1;
      *(float *)(v1 + 51516) = *(float *)(v1 + 4 * v24 + 51504);
      sub_1008CB30(9213, v1 + 51484, 1);
    }
    sub_1008CA60(9213, (int)&a1, 1);
    v25 = a1;
    if ( *v23 != (_BYTE)a1 )
    {
      *v23 = a1;
      *(float *)(v1 + 51516) = *(float *)(v1 + 4 * v25 + 51504);
    }
    if ( *(float *)(v1 + 51548) < (double)v42 )
      *(_DWORD *)(v1 + 51132) = -65536;
    if ( *(_DWORD *)(v1 + 51132) == -16728064 && *(_BYTE *)(v1 + 51606) )
      *(_DWORD *)(v1 + 51132) = -16711681;
    sub_10058000(v1 + 51136, v1, *(_DWORD *)(v1 + 51132));
    v26 = *(_DWORD *)(v1 + 4 * *v23 + 51492);
    if ( v26 == -16728064 && *(_BYTE *)(v1 + 51606) )
      v26 = -16711681;
    sub_10058000(v1 + 49440, v1, v26);
    *(float *)(v1 + 51552) = *(float *)(v1 + 51544) + v39;
    v27 = 9.8999998e24;
  }
  v28 = v27 == *(float *)(v1 + 51888);
  *(_BYTE *)(v1 + 51611) = 0;
  *(_BYTE *)(v1 + 51612) = 0;
  *(_BYTE *)(v1 + 51614) = 0;
  if ( v28 )
  {
    *(float *)(v1 + 51160) = v27;
  }
  else
  {
    v29 = (int *)(v1 + 51164);
    v30 = sub_10058770(0, 0, 11, *(float **)(v1 + 51124), v1 + 51888, v1 + 51160, (_DWORD *)(v1 + 51164));
    if ( *(_BYTE *)(v1 + 51605) != v31 )
      *v29 = -8355712;
    v3 = *v29 == -65536;
    *(_BYTE *)(v1 + 51611) = *(float *)(*(_DWORD *)(v1 + 51124) + 72) > (double)*(float *)(v1 + 51160);
    *(_BYTE *)(v1 + 51612) = v3;
    if ( sub_1006F520((int)"_np_excess") )
      *v29 = -65536;
    if ( v30 >= 8 )
    {
      *v29 = -65536;
      *(_BYTE *)(v1 + 51614) = 1;
    }
    sub_10058000(v1 + 51168, v1, *v29);
    v27 = 9.8999998e24;
  }
  if ( *(_BYTE *)(v1 + 51613) )
    *(float *)(v1 + 51944) = 0.0;
  if ( v27 == *(float *)(v1 + 51944) )
  {
    v36 = (char *)(v1 + 51380);
    sub_10064B00((char *)(v1 + 51380), 8u, "   ");
    *(float *)(v1 + 51192) = 9.8999998e24;
    sub_10058000(v1 + 51420, v1, -16777216);
  }
  else
  {
    sub_10058770(0, 0, 11, *(float **)(v1 + 51124), v1 + 51944, v1 + 51192, (_DWORD *)(v1 + 51396));
    v32 = *(_DWORD *)(v1 + 51396);
    *(_DWORD *)(v1 + 51196) = v32;
    sub_10058000(v1 + 51200, v1, v32);
    v33 = *(_BYTE *)(v1 + 51611) || *(float *)(*(_DWORD *)(v1 + 51124) + 72) > (double)*(float *)(v1 + 51192);
    v3 = *(_BYTE *)(v1 + 51612) == 0;
    *(_BYTE *)(v1 + 51611) = v33;
    v34 = !v3 || *(_DWORD *)(v1 + 51196) == -65536;
    v35 = *(float *)(v1 + 51948);
    v36 = (char *)(v1 + 51380);
    *(_BYTE *)(v1 + 51612) = v34;
    sub_10064B00((char *)(v1 + 51380), 8u, "%3.0f", v35);
    sub_10058170(v1, v1 + 51380);
  }
  if ( *(_BYTE *)(v1 + 51613) )
  {
    sub_10064B00(v36, 8u, "   ");
    sub_10058000(v1 + 51420, v1, -16777216);
  }
  v37 = v1 + 49344;
  if ( *(_BYTE *)(v1 + 51605) )
    result = sub_10058000(v37, v1, -8355712);
  else
    result = sub_10058000(v37, v1, -1);
  return result;
}

//----- (1005F7C0) --------------------------------------------------------
char __usercall sub_1005F7C0@<al>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1
  double v6; // st6@6
  bool v7; // cf@18
  bool v8; // zf@18
  float v9; // ST3C_4@24
  float v10; // ST38_4@24
  int v11; // eax@27
  int v12; // ecx@27
  int v13; // edx@27
  int v14; // eax@34
  int v15; // ecx@34
  int v16; // edx@34
  int v17; // eax@44
  int v18; // ecx@44
  int v19; // edx@44
  int v20; // ecx@48
  int v21; // edx@48
  int v22; // eax@48
  int v23; // edx@55
  int v24; // eax@55
  int v25; // ecx@55
  int v26; // edx@58
  int v27; // eax@58
  int v28; // ecx@58
  _DWORD *v29; // eax@66
  int v30; // ecx@75
  int v31; // edx@75
  int v32; // eax@75
  int v33; // ecx@87
  int v34; // eax@88
  int v35; // edi@92
  int v36; // ebp@92
  float v38; // [sp+1Ch] [bp-4h]@5
  float v39; // [sp+1Ch] [bp-4h]@14
  float v40; // [sp+24h] [bp+4h]@3
  float v41; // [sp+24h] [bp+4h]@12
  float v42; // [sp+24h] [bp+4h]@38
  float v43; // [sp+24h] [bp+4h]@85

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 16);
  v4 = sub_1008C780();
  v5 = v4;
  if ( 9.8999998e24 != *(float *)(v3 + 51552) )
  {
    if ( 9.8999998e24 == *(float *)(v3 + 51548) )
    {
      v6 = *(float *)(v3 + 51552);
    }
    else
    {
      v40 = (*(float *)(v3 + 51552) - *(float *)(v3 + 51548)) * *(float *)(v3 + 51708);
      if ( *(float *)(v3 + 51712) < (double)v40 )
        v40 = *(float *)(v3 + 51712);
      v38 = -*(float *)(v3 + 51712);
      if ( v38 <= (double)v40 )
        v6 = *(float *)(v3 + 51548) + v40;
      else
        v6 = *(float *)(v3 + 51548) + v38;
    }
    *(float *)(v3 + 51548) = v6;
  }
  if ( 9.8999998e24 != *(float *)(v3 + 51568) )
  {
    if ( 9.8999998e24 == *(float *)(v3 + 51564) )
    {
      *(float *)(v3 + 51564) = *(float *)(v3 + 51568);
    }
    else
    {
      v41 = (*(float *)(v3 + 51568) - *(float *)(v3 + 51564)) * *(float *)(v3 + 51708);
      if ( *(float *)(v3 + 51712) < (double)v41 )
        v41 = *(float *)(v3 + 51712);
      v39 = -*(float *)(v3 + 51712);
      if ( v39 <= (double)v41 )
        *(float *)(v3 + 51564) = v41 + *(float *)(v3 + 51564);
      else
        *(float *)(v3 + 51564) = v39 + *(float *)(v3 + 51564);
    }
  }
  v7 = v4 < *(_DWORD *)(v3 + 52000);
  v8 = v4 == *(_DWORD *)(v3 + 52000);
  *(_BYTE *)(v3 + 49824) = 0;
  if ( !v7 && !v8 )
  {
    *(_DWORD *)(v3 + 52000) = v4 + 75;
    sub_1005EE70(v3);
  }
  if ( v5 > *(_DWORD *)(v3 + 52004) )
  {
    *(_DWORD *)(v3 + 52004) = v5 + 175;
    sub_100581D0(v3, 0);
  }
  v8 = *(_BYTE *)(v3 + 49824) == 0;
  *(_BYTE *)(v3 + 49825) = 0;
  if ( !v8 )
    sub_1008CD40(&unk_101DEDD4, 0, v3 + 28, (_DWORD *)(24 * *(_DWORD *)(v3 + 12316)), 0x3000u);
  *(_BYTE *)v2 = *(_BYTE *)v3;
  j_gdi_pvg_push_matrix();
  v9 = (double)*(_WORD *)(a1 + 2);
  v10 = (double)*(_WORD *)a1;
  sub_1008C2B0(v10, v9, 0.0);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(38);
  sub_1008CCE0((int)&unk_101DEDC8);
  if ( *(_BYTE *)(v2 + 1) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49188), *(_DWORD *)(v3 + 49192), *(_DWORD *)(v3 + 49196));
  sub_1008C110(1.0);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49200), *(_DWORD *)(v3 + 49204), *(_DWORD *)(v3 + 49208));
  if ( *(_BYTE *)(v3 + 51607) )
  {
    v11 = *(_DWORD *)(v3 + 49388);
    v12 = *(_DWORD *)(v3 + 49384);
    v13 = *(_DWORD *)(v3 + 49380);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 51608) )
      goto LABEL_31;
    v11 = *(_DWORD *)(v3 + 49412);
    v12 = *(_DWORD *)(v3 + 49408);
    v13 = *(_DWORD *)(v3 + 49404);
  }
  j_gdi_pvg_draw_arrays(v13, v12, v11);
LABEL_31:
  if ( *(_BYTE *)(v3 + 51609) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49428), *(_DWORD *)(v3 + 49432), *(_DWORD *)(v3 + 49436));
  sub_1008C110(1.0);
  if ( *(_DWORD *)(v3 + 51132) == -65536 )
  {
    v14 = *(_DWORD *)(v3 + 49484);
    v15 = *(_DWORD *)(v3 + 49480);
    v16 = *(_DWORD *)(v3 + 49476);
  }
  else
  {
    v14 = *(_DWORD *)(v3 + 49472);
    v15 = *(_DWORD *)(v3 + 49468);
    v16 = *(_DWORD *)(v3 + 49464);
  }
  j_gdi_pvg_draw_arrays(v16, v15, v14);
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C2B0(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    if ( 9.8999998e24 != *(float *)(v3 + 51548) )
    {
      j_gdi_pvg_push_matrix();
      v42 = *(float *)(v3 + 51548) - 198.0;
      sub_1008C1F0(v42, 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49488), *(_DWORD *)(v3 + 49492), *(_DWORD *)(v3 + 49496));
      j_gdi_pvg_pop_matrix();
    }
    if ( *(_BYTE *)(v3 + 51610) && 9.8999998e24 != *(float *)(v3 + 51564) )
    {
      sub_1008C1F0(*(float *)(v3 + 51564), 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49560), *(_DWORD *)(v3 + 49564), *(_DWORD *)(v3 + 49568));
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49572), *(_DWORD *)(v3 + 49576), *(_DWORD *)(v3 + 49580));
    }
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49212), *(_DWORD *)(v3 + 49216), *(_DWORD *)(v3 + 49220));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49224), *(_DWORD *)(v3 + 49228), *(_DWORD *)(v3 + 49232));
  if ( *(_BYTE *)(v3 + 51612) )
  {
    v17 = *(_DWORD *)(v3 + 49520);
    v18 = *(_DWORD *)(v3 + 49516);
    v19 = *(_DWORD *)(v3 + 49512);
  }
  else
  {
    v17 = *(_DWORD *)(v3 + 49508);
    v18 = *(_DWORD *)(v3 + 49504);
    v19 = *(_DWORD *)(v3 + 49500);
  }
  j_gdi_pvg_draw_arrays(v19, v18, v17);
  if ( *(_DWORD *)(v3 + 51124) == v3 + 50332 )
  {
    if ( *(_BYTE *)(v3 + 51611) )
    {
      v20 = *(_DWORD *)(v3 + 49556);
      v21 = *(_DWORD *)(v3 + 49552);
      v22 = *(_DWORD *)(v3 + 49548);
    }
    else
    {
      v20 = *(_DWORD *)(v3 + 49544);
      v21 = *(_DWORD *)(v3 + 49540);
      v22 = *(_DWORD *)(v3 + 49536);
    }
    j_gdi_pvg_draw_arrays(v22, v21, v20);
  }
  if ( *(_BYTE *)(v3 + 51603) )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C2B0(*(float *)(v3 + 20), *(float *)(v3 + 24), 0.0);
    sub_1008C1F0(*(float *)(*(_DWORD *)(v3 + 51124) + 180), 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49584), *(_DWORD *)(v3 + 49588), *(_DWORD *)(v3 + 49592));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49596), *(_DWORD *)(v3 + 49600), *(_DWORD *)(v3 + 49604));
    j_gdi_pvg_pop_matrix();
  }
  if ( *(_BYTE *)(v3 + 51604) )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C2B0(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    sub_1008C1F0(*(float *)(v3 + 51592), 0.0, 0.0, 1.0);
    if ( *(_BYTE *)(v3 + 51589) )
    {
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49632), *(_DWORD *)(v3 + 49636), *(_DWORD *)(v3 + 49640));
      v23 = *(_DWORD *)(v3 + 49652);
      v24 = *(_DWORD *)(v3 + 49648);
      v25 = *(_DWORD *)(v3 + 49644);
    }
    else
    {
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49608), *(_DWORD *)(v3 + 49612), *(_DWORD *)(v3 + 49616));
      v23 = *(_DWORD *)(v3 + 49628);
      v24 = *(_DWORD *)(v3 + 49624);
      v25 = *(_DWORD *)(v3 + 49620);
    }
    j_gdi_pvg_draw_arrays(v25, v24, v23);
    if ( *(_BYTE *)(v3 + 51588) )
    {
      v26 = *(_DWORD *)(v3 + 49676);
      v27 = *(_DWORD *)(v3 + 49672);
      v28 = *(_DWORD *)(v3 + 49668);
    }
    else
    {
      v26 = *(_DWORD *)(v3 + 49664);
      v27 = *(_DWORD *)(v3 + 49660);
      v28 = *(_DWORD *)(v3 + 49656);
    }
    j_gdi_pvg_draw_arrays(v28, v27, v26);
    j_gdi_pvg_pop_matrix();
  }
  if ( *(_BYTE *)(v3 + 51602) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49284), *(_DWORD *)(v3 + 49288), *(_DWORD *)(v3 + 49292));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49296), *(_DWORD *)(v3 + 49300), *(_DWORD *)(v3 + 49304));
  }
  else
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49260), *(_DWORD *)(v3 + 49264), *(_DWORD *)(v3 + 49268));
    if ( *(_BYTE *)(v3 + 51614) )
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49524), *(_DWORD *)(v3 + 49528), *(_DWORD *)(v3 + 49532));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49272), *(_DWORD *)(v3 + 49276), *(_DWORD *)(v3 + 49280));
  }
  j_gdi_pvg_enable(34);
  v29 = (_DWORD *)sub_1008CC80(0x33u);
  j_gdi_pvg_bind_texture(34, *v29);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51624) + 8212));
  if ( *(_BYTE *)(v3 + 51742) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49680), *(_DWORD *)(v3 + 49684), *(_DWORD *)(v3 + 49688));
  if ( *(_BYTE *)(v3 + 51798) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49692), *(_DWORD *)(v3 + 49696), *(_DWORD *)(v3 + 49700));
  if ( *(_BYTE *)(v3 + 51854) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49704), *(_DWORD *)(v3 + 49708), *(_DWORD *)(v3 + 49712));
  if ( *(_BYTE *)(v3 + 51966) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49716), *(_DWORD *)(v3 + 49720), *(_DWORD *)(v3 + 49724));
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49356), *(_DWORD *)(v3 + 49360), *(_DWORD *)(v3 + 49364));
  if ( *(_BYTE *)(v3 + 51607) )
  {
    v30 = *(_DWORD *)(v3 + 49376);
    v31 = *(_DWORD *)(v3 + 49372);
    v32 = *(_DWORD *)(v3 + 49368);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 51608) )
      goto LABEL_79;
    v30 = *(_DWORD *)(v3 + 49400);
    v31 = *(_DWORD *)(v3 + 49396);
    v32 = *(_DWORD *)(v3 + 49392);
  }
  j_gdi_pvg_draw_arrays(v32, v31, v30);
LABEL_79:
  if ( *(_BYTE *)(v3 + 51609) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49416), *(_DWORD *)(v3 + 49420), *(_DWORD *)(v3 + 49424));
  if ( *(_DWORD *)(v3 + 51596) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49452), *(_DWORD *)(v3 + 49456), *(_DWORD *)(v3 + 49460));
  j_gdi_pvg_disable(34);
  sub_1008CDE0();
  sub_1008C110(1.0);
  sub_1008CCE0((int)&unk_101DEDD4);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51264), *(_DWORD *)(v3 + 51268), *(_DWORD *)(v3 + 51272));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51316), *(_DWORD *)(v3 + 51320), *(_DWORD *)(v3 + 51324));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51368), *(_DWORD *)(v3 + 51372), *(_DWORD *)(v3 + 51376));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51420), *(_DWORD *)(v3 + 51424), *(_DWORD *)(v3 + 51428));
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C2B0(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    if ( 9.8999998e24 != *(float *)(v3 + 51548) )
    {
      j_gdi_pvg_push_matrix();
      v43 = *(float *)(v3 + 51548) - 198.0;
      sub_1008C1F0(v43, 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49236), *(_DWORD *)(v3 + 49240), *(_DWORD *)(v3 + 49244));
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49248), *(_DWORD *)(v3 + 49252), *(_DWORD *)(v3 + 49256));
      j_gdi_pvg_pop_matrix();
    }
    sub_1008C1F0(*(float *)(v3 + 51128), 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51136), *(_DWORD *)(v3 + 51140), *(_DWORD *)(v3 + 51144));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51148), *(_DWORD *)(v3 + 51152), *(_DWORD *)(v3 + 51156));
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_push_matrix();
  sub_1008C2B0(*(float *)(v3 + 20), *(float *)(v3 + 24), 0.0);
  v33 = *(_DWORD *)(v3 + 51196);
  if ( (v33 != -16728064 || (v34 = *(_DWORD *)(v3 + 51164), v34 != -256) && v34 != -65536)
    && (v33 != -256 || *(_DWORD *)(v3 + 51164) != -65536) )
  {
    v35 = v3 + 51160;
    v36 = v3 + 51192;
  }
  else
  {
    v35 = v3 + 51192;
    v36 = v3 + 51160;
  }
  if ( 9.8999998e24 != *(float *)v35 )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C1F0(*(float *)v35, 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v35 + 8), *(_DWORD *)(v35 + 12), *(_DWORD *)(v35 + 16));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v35 + 20), *(_DWORD *)(v35 + 24), *(_DWORD *)(v35 + 28));
    j_gdi_pvg_pop_matrix();
  }
  if ( 9.8999998e24 != *(float *)v36 )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C1F0(*(float *)v36, 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v36 + 8), *(_DWORD *)(v36 + 12), *(_DWORD *)(v36 + 16));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v36 + 20), *(_DWORD *)(v36 + 24), *(_DWORD *)(v36 + 28));
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_enable(34);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49344), *(_DWORD *)(v3 + 49348), *(_DWORD *)(v3 + 49352));
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51648) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51252), *(_DWORD *)(v3 + 51256), *(_DWORD *)(v3 + 51260));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51304), *(_DWORD *)(v3 + 51308), *(_DWORD *)(v3 + 51312));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51356), *(_DWORD *)(v3 + 51360), *(_DWORD *)(v3 + 51364));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51408), *(_DWORD *)(v3 + 51412), *(_DWORD *)(v3 + 51416));
  if ( *(_DWORD *)(v3 + 51596) && (!*(_BYTE *)(v3 + 51600) || *(_BYTE *)(v3 + 51601)) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51460), *(_DWORD *)(v3 + 51464), *(_DWORD *)(v3 + 51468));
  j_gdi_pvg_disable(34);
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_1008C2B0(0.0, *(float *)(v3 + 51516), 0.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49440), *(_DWORD *)(v3 + 49444), *(_DWORD *)(v3 + 49448));
    j_gdi_pvg_pop_matrix();
  }
  sub_1008CDE0();
  sub_1008CCE0((int)&unk_101DEDC8);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49308), *(_DWORD *)(v3 + 49312), *(_DWORD *)(v3 + 49316));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49320), *(_DWORD *)(v3 + 49324), *(_DWORD *)(v3 + 49328));
  sub_1008C110(3.0);
  if ( 9.8999998e24 == *(float *)(v3 + 51720) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49740), *(_DWORD *)(v3 + 49744), *(_DWORD *)(v3 + 49748));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49728), *(_DWORD *)(v3 + 49732), *(_DWORD *)(v3 + 49736));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51776) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49764), *(_DWORD *)(v3 + 49768), *(_DWORD *)(v3 + 49772));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49752), *(_DWORD *)(v3 + 49756), *(_DWORD *)(v3 + 49760));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51832) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49788), *(_DWORD *)(v3 + 49792), *(_DWORD *)(v3 + 49796));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49776), *(_DWORD *)(v3 + 49780), *(_DWORD *)(v3 + 49784));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51944) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49812), *(_DWORD *)(v3 + 49816), *(_DWORD *)(v3 + 49820));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49800), *(_DWORD *)(v3 + 49804), *(_DWORD *)(v3 + 49808));
  }
  sub_1008C110(1.0);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_enable(34);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49332), *(_DWORD *)(v3 + 49336), *(_DWORD *)(v3 + 49340));
  sub_1008CDE0();
  j_gdi_pvg_disable(34);
  j_gdi_pvg_disable(38);
  j_gdi_pvg_disable(35);
  j_gdi_pvg_pop_matrix();
  return 2;
}
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C050: using guessed type int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 1008C1B0: using guessed type int j_gdi_pvg_pop_matrix(void);
// 1008C1D0: using guessed type int j_gdi_pvg_push_matrix(void);

//----- (10060680) --------------------------------------------------------
char __cdecl sub_10060680(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // bl@1
  char result; // al@2

  v5 = 1;
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
      sub_10057DB0(a4, a1);
      result = 1;
      break;
    case 0x8041:
      result = sub_100587D0(a1, a4);
      break;
    case 0x8022:
    case 0x8078:
      v5 = sub_1005F7C0(a3, a4);
      goto LABEL_5;
    default:
LABEL_5:
      result = v5;
      break;
  }
  return result;
}

//----- (10060760) --------------------------------------------------------
int __cdecl sub_10060760(unsigned __int16 a1)
{
  return dword_100E5750[a1];
}
// 100E5750: using guessed type int dword_100E5750[];

//----- (10060770) --------------------------------------------------------
char __cdecl sub_10060770(int a1, int a2, int a3, int a4, __int16 *a5)
{
  __int16 v5; // ax@1
  unsigned __int16 v6; // dx@4
  double v7; // st7@4
  int v8; // ST04_4@4
  double v9; // st7@4
  int v10; // eax@4
  char *v11; // edi@5
  const char *v12; // esi@6
  bool v13; // zf@97
  const char *v14; // ebx@98
  __int16 v15; // cx@98
  __int16 v16; // dx@98
  char v18; // [sp+1Eh] [bp-11Ah]@1
  char v19; // [sp+1Fh] [bp-119h]@1
  __int16 v20; // [sp+20h] [bp-118h]@98
  __int16 v21; // [sp+22h] [bp-116h]@98
  __int16 *v22; // [sp+24h] [bp-114h]@1
  int v23; // [sp+28h] [bp-110h]@1
  int v24; // [sp+2Ch] [bp-10Ch]@1
  int v25; // [sp+30h] [bp-108h]@98
  float v26; // [sp+34h] [bp-104h]@4
  char v27; // [sp+38h] [bp-100h]@4
  char *v28; // [sp+54h] [bp-E4h]@1
  int v29; // [sp+58h] [bp-E0h]@98
  int v30; // [sp+5Ch] [bp-DCh]@98
  char v31; // [sp+60h] [bp-D8h]@1
  char v32; // [sp+6Bh] [bp-CDh]@99

  v23 = a1;
  v22 = a5;
  v5 = *a5;
  v24 = a3;
  v19 = 1;
  v18 = 31;
  v28 = &v31;
  if ( v5 == -32648 || v5 == -32734 || v5 == -32704 )
  {
    v6 = *(_WORD *)a4;
    v7 = *(float *)(a4 + 4);
    qmemcpy(&v27, (const void *)(a4 + 8), 0x1Cu);
    *(float *)&v8 = v7;
    v9 = sub_1006D0E0(v8, v6, *(_BYTE *)(a4 + 40), &v18);
    v10 = *(_WORD *)a4;
    v26 = v9;
    switch ( v10 )
    {
      case 0:
        v11 = &v31;
        if ( v18 == 21 )
          v12 = "\a_.__";
        else
          v12 = "\a_.__";
        goto LABEL_97;
      case 42:
      case 46:
        v12 = (const char *)&unk_100E59C0;
        goto LABEL_96;
      case 1:
      case 45:
        v12 = (const char *)&unk_100E5A90;
        goto LABEL_96;
      case 4:
        v12 = (const char *)&unk_100E5B60;
        goto LABEL_96;
      case 5:
        v12 = (const char *)&unk_100E5C30;
        goto LABEL_96;
      case 6:
      case 10:
      case 37:
        v12 = (const char *)&unk_100E5D00;
        goto LABEL_96;
      case 11:
        v12 = (const char *)&unk_100E5DD0;
        goto LABEL_96;
      case 7:
      case 12:
      case 36:
        v12 = (const char *)&unk_100E5EA0;
        goto LABEL_96;
      case 13:
        v12 = (const char *)&unk_100E5F70;
        goto LABEL_96;
      case 8:
        v12 = (const char *)&unk_100E6040;
        goto LABEL_96;
      case 9:
        v12 = (const char *)&unk_100E6110;
        goto LABEL_96;
      case 14:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100E5D00;
        else
          v12 = (const char *)&unk_100E62B0;
        goto LABEL_97;
      case 15:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100E5EA0;
        else
          v12 = (const char *)&unk_100E6380;
        goto LABEL_97;
      case 16:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100E61E0;
        else
          v12 = (const char *)&unk_100E6450;
        goto LABEL_97;
      case 17:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100E6520;
        else
          v12 = (const char *)&unk_100E6790;
        goto LABEL_97;
      case 19:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100E65F0;
        else
          v12 = (const char *)&unk_100E6860;
        goto LABEL_97;
      case 18:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100E66C0;
        else
          v12 = (const char *)&unk_100E6930;
        goto LABEL_97;
      case 20:
        v12 = (const char *)&unk_100E6A00;
        goto LABEL_96;
      case 21:
        v12 = (const char *)&unk_100E6AD0;
        goto LABEL_96;
      case 22:
        v12 = (const char *)&unk_100E6BA0;
        goto LABEL_96;
      case 23:
        v12 = (const char *)&unk_100E6C70;
        goto LABEL_96;
      case 24:
        v12 = (const char *)&unk_100E6D40;
        goto LABEL_96;
      case 25:
        v12 = (const char *)&unk_100E6E10;
        goto LABEL_96;
      case 43:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100E72F0;
            break;
          case 21:
            v12 = (const char *)&unk_100E7490;
            break;
          case 30:
            v12 = (const char *)&unk_100E6FB0;
            break;
          default:
            v12 = (const char *)&unk_100E7630;
            break;
        }
        goto LABEL_97;
      case 26:
      case 38:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100E7080;
            break;
          case 21:
            v12 = (const char *)&unk_100E73C0;
            break;
          case 30:
            v12 = (const char *)&unk_100E6EE0;
            break;
          default:
            v12 = (const char *)&unk_100E7560;
            break;
        }
        goto LABEL_97;
      case 48:
        v12 = (const char *)&unk_100E7150;
        goto LABEL_96;
      case 49:
        v12 = (const char *)&unk_100E7220;
        goto LABEL_96;
      case 27:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100E7700;
        else
          v12 = (const char *)&unk_100E78A0;
        goto LABEL_97;
      case 29:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100E77D0;
        else
          v12 = (const char *)&unk_100E7970;
        goto LABEL_97;
      case 30:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100E7A40;
            break;
          case 0x10:
            v12 = (const char *)&unk_100E7BE0;
            break;
          case 0x18:
            v12 = (const char *)&unk_100E7F20;
            break;
          default:
            v12 = (const char *)&unk_100E80C0;
            break;
          case 0x13:
            goto LABEL_95;
        }
        goto LABEL_96;
      case 31:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100E7B10;
            break;
          case 0x10:
            v12 = (const char *)&unk_100E7CB0;
            break;
          case 0x13:
            v12 = (const char *)&unk_100E7E50;
            break;
          case 0x18:
            v12 = (const char *)&unk_100E7FF0;
            break;
          default:
            v12 = (const char *)&unk_100E8190;
            break;
        }
        goto LABEL_96;
      case 32:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100E8260;
            break;
          case 0x11:
            v12 = (const char *)&unk_100E8400;
            break;
          case 0x14:
            v12 = (const char *)&unk_100E85A0;
            break;
          case 0x19:
            v12 = (const char *)&unk_100E8740;
            break;
          default:
            v12 = (const char *)&unk_100E88E0;
            break;
        }
        goto LABEL_96;
      case 33:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100E8330;
            break;
          case 0x11:
            v12 = (const char *)&unk_100E84D0;
            break;
          case 0x14:
            v12 = (const char *)&unk_100E8670;
            break;
          case 0x19:
            v12 = (const char *)&unk_100E8810;
            break;
          default:
            v12 = (const char *)&unk_100E89B0;
            break;
        }
        goto LABEL_96;
      case 35:
        v12 = (const char *)&unk_100E8A80;
        goto LABEL_96;
      case 34:
        v12 = (const char *)&unk_100E8B50;
        goto LABEL_96;
      case 39:
        v12 = (const char *)&unk_100E8C20;
        goto LABEL_96;
      case 40:
        v12 = (const char *)&unk_100E8CF0;
        goto LABEL_96;
      case 41:
        v12 = (const char *)&unk_100E8DC0;
        goto LABEL_96;
      case 44:
        v12 = (const char *)&unk_100E8E90;
        goto LABEL_96;
      case 47:
        v12 = (const char *)&unk_100E8F60;
        goto LABEL_96;
      case 50:
        v12 = (const char *)&unk_100E7F20;
        if ( v18 == 19 )
LABEL_95:
          v12 = (const char *)&unk_100E7D80;
LABEL_96:
        v11 = &v31;
LABEL_97:
        v13 = v28 == 0;
        qmemcpy(v11, v12, 0xCCu);
        if ( !v13 )
        {
          v14 = *(const char **)(a4 + 36);
          v30 = *(_DWORD *)(a4 + 60);
          v15 = *(_WORD *)v24;
          v29 = a4 + 41;
          v16 = *(_WORD *)(v24 + 2);
          v25 = 27;
          v20 = v15;
          v21 = v16;
          if ( v14 )
            strcpy(&v32, v14);
          v19 = sub_10076690(v23, (int)&v25, (int)&v20, (int)&v26, v22);
        }
        break;
      default:
        return v19;
    }
  }
  return v19;
}

//----- (10060DD0) --------------------------------------------------------
char __cdecl sub_10060DD0(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_1031EB40[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (10060E40) --------------------------------------------------------
void __cdecl sub_10060E40(_BYTE *a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@2
  int v4; // ebp@2
  int v5; // esi@2
  int v6; // eax@7
  int v7; // ecx@7

  v2 = 0;
  if ( *a1 )
  {
    v3 = a2;
    v4 = (int)(a1 + 12);
    v5 = a2 + 232;
    while ( v2 < 10 )
    {
      *(float *)(v5 - 4) = sub_10065120(*(float *)v4, v3 + 308, *(_BYTE *)(v3 + 404));
      *(_DWORD *)v5 = *(_DWORD *)(v4 + 40);
      *(_BYTE *)(v5 + 1736) = a1[v2 + 92];
      *(float *)(v5 + 1732) = *(float *)v4;
      ++v2;
      v4 += 4;
      v5 += 8;
      if ( v2 >= *a1 )
      {
        if ( v2 < 10 )
          goto LABEL_7;
        v3 = a2;
        break;
      }
      v3 = a2;
    }
    sub_1006A190(v3 + 204);
  }
  else
  {
LABEL_7:
    v6 = a2 + 8 * v2 + 232;
    v7 = 10 - v2;
    do
    {
      *(float *)(v6 - 4) = 9.8999998e24;
      *(_DWORD *)v6 = 0;
      *(float *)(v6 + 1732) = 9.8999998e24;
      *(_BYTE *)(v6 + 1736) = 10;
      v6 += 8;
      --v7;
    }
    while ( v7 );
    sub_1006A190(a2 + 204);
  }
}

//----- (10060F20) --------------------------------------------------------
int __cdecl sub_10060F20(int a1, char a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(_DWORD *)(a3 + 44) = a1 + 4;
  *(_DWORD *)(a3 + 48) = a1 + 8;
  if ( a2 )
    *(_DWORD *)(a3 + 2320) = a1 + 8;
  return result;
}

//----- (10060F50) --------------------------------------------------------
int __cdecl sub_10060F50(float a1, float a2, float a3, float a4, int a5)
{
  int result; // eax@1

  result = a5;
  *(float *)(a5 + 24) = a1;
  *(float *)(a5 + 28) = a2;
  *(float *)(a5 + 32) = a3;
  *(float *)(a5 + 36) = a4;
  return result;
}

//----- (10060F80) --------------------------------------------------------
int __cdecl sub_10060F80(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 2324) = *(float *)a1;
  *(float *)(a2 + 2328) = *(float *)(a1 + 4);
  return result;
}

//----- (10060FA0) --------------------------------------------------------
int __cdecl sub_10060FA0(float a1, char *a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // st7@1
  float v9; // ST34_4@1
  long double v10; // ST2C_8@1
  int v11; // ebx@1
  double v12; // st7@1
  int v13; // eax@3
  int result; // eax@3
  double v15; // st7@3
  double v16; // st3@3
  double v17; // st7@4
  double v18; // st4@6
  double v19; // st7@6
  int v20; // [sp+1Ch] [bp-18h]@1
  float v21; // [sp+24h] [bp-10h]@1
  float v22; // [sp+28h] [bp-Ch]@1
  float v23; // [sp+2Ch] [bp-8h]@1
  float v24; // [sp+30h] [bp-4h]@1
  float v25; // [sp+40h] [bp+Ch]@3
  float v26; // [sp+44h] [bp+10h]@6

  v7 = a7;
  v8 = *(float *)(a7 + 8) * 0.5;
  v22 = v8;
  v23 = v8 + *(float *)a7;
  v24 = 0.5 * *(float *)(a7 + 12) + *(float *)(a7 + 4);
  v9 = sub_10065120(a1, a7 + 308, *(_BYTE *)(a7 + 404)) + *(float *)(v7 + 220);
  v10 = v9 * 0.01745329251994333;
  v21 = cos(v10);
  *(float *)&v20 = sin(v10);
  v11 = (a6 << 6) + v7;
  v12 = sub_1006D0E0(SLODWORD(a1), *(_WORD *)(v7 + 5558), *(_BYTE *)(v7 + 5564), (char *)&a7);
  _snprintf((char *)(v11 + 2392), 7u, a2, v12 * a3);
  if ( !strncmp((const char *)(v11 + 2392), "-0", 7u) )
    sub_100649E0(v11 + 2392, &word_100D1710, 7);
  v13 = sub_10065060(a4);
  v25 = sub_1008D010(v13, v11 + 2392, a4);
  a7 = v20;
  result = 0x7FFFFFFF;
  v15 = a5 * (1.100000023841858 * v22) + v22;
  v16 = a4 * 0.5;
  if ( a5 >= 0.0 )
  {
    a7 &= 0x7FFFFFFFu;
    v17 = 0.5 * v25 * COERCE_FLOAT(LODWORD(v21) & 0x7FFFFFFF) + v16 * *(float *)&a7 + v15;
  }
  else
  {
    a7 &= 0x7FFFFFFFu;
    v17 = v15 - v16 * *(float *)&a7 - 0.5 * v25 * COERCE_FLOAT(LODWORD(v21) & 0x7FFFFFFF);
  }
  v18 = v17;
  v19 = a4;
  v26 = v18;
  *(_DWORD *)(v11 + 2384) = 0;
  *(_DWORD *)(v11 + 2388) = -1;
  *(float *)(v11 + 2376) = v21 * v26 + v23;
  *(float *)(v11 + 2380) = *(float *)&v20 * v26 + v24;
  *(float *)(v11 + 2404) = 0.5;
  *(float *)(v11 + 2400) = 0.5;
  *(float *)(v11 + 2408) = *(float *)&v19;
  return result;
}
// 100D1710: using guessed type __int16 word_100D1710;

//----- (10061190) --------------------------------------------------------
int __cdecl sub_10061190(float a1, float a2, float a3, int a4, int a5)
{
  int v5; // esi@1
  double v6; // st7@1
  float v7; // ST10_4@1
  float v8; // ST1C_4@1
  long double v9; // ST14_8@1
  int result; // eax@1
  double v11; // st5@1
  float v12; // [sp+2Ch] [bp+Ch]@1
  int v13; // [sp+34h] [bp+14h]@1
  int v14; // [sp+34h] [bp+14h]@1
  int v15; // [sp+34h] [bp+14h]@1

  v5 = a5;
  v6 = *(float *)(a5 + 8) * 0.5;
  v12 = v6 - a3;
  v7 = v6 + *(float *)a5;
  v8 = 0.5 * *(float *)(a5 + 12) + *(float *)(a5 + 4);
  *(float *)&v13 = sub_10065120(a1, a5 + 308, *(_BYTE *)(a5 + 404)) + *(float *)(a5 + 220);
  v9 = *(float *)&v13 * 0.01745329251994333;
  *(float *)&v14 = cos(v9);
  *(float *)&v9 = sin(v9);
  result = (a4 << 6) + v5;
  *(_BYTE *)(result + 2416) = 0;
  *(_DWORD *)(result + 2412) = -1;
  *(float *)(result + 2356) = *(float *)&v14 * v12 + v7;
  *(float *)(result + 2364) = *(float *)&v9 * v12 + v8;
  v11 = v12 + v12 * a2;
  *(float *)(result + 2360) = v7 + *(float *)&v14 * v11;
  *(float *)&v15 = v8 + *(float *)&v9 * v11;
  *(float *)(((a4 + 37) << 6) + v5) = *(float *)&v15;
  return result;
}

//----- (100612A0) --------------------------------------------------------
int __cdecl sub_100612A0(int a1, char a2, float a3, int a4)
{
  int result; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@1
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st7@1
  int v10; // edi@2
  long double v11; // ST24_8@4
  double v12; // st5@4
  int v13; // eax@4
  double v14; // st4@4
  char *v15; // edx@4
  char v16; // cl@5
  double v17; // st7@6
  double v18; // st6@8
  double v19; // st5@8
  int v20; // ecx@8
  double v21; // rt1@9
  double v22; // rt2@10
  double v23; // st5@10
  double v24; // st6@10
  float v25; // [sp+1Ch] [bp-14h]@1
  float v26; // [sp+20h] [bp-10h]@1
  float v27; // [sp+2Ch] [bp-4h]@1
  float v28; // [sp+3Ch] [bp+Ch]@4
  float v29; // [sp+3Ch] [bp+Ch]@4
  float v30; // [sp+3Ch] [bp+Ch]@4
  int v31; // [sp+40h] [bp+10h]@1

  result = (unsigned __int8)a2;
  v5 = LOBYTE(a3);
  v6 = a4;
  v7 = *(float *)(a4 + 8);
  v31 = 0;
  v8 = v7 * 0.5;
  v25 = v8;
  v26 = v8 + *(float *)v6;
  v27 = 0.5 * *(float *)(v6 + 12) + *(float *)(v6 + 4);
  v9 = 0.5;
  if ( (signed int)(unsigned __int8)a2 > 0 )
  {
    v10 = a1 + 8;
    do
    {
      if ( v5 >= 0x32u )
        break;
      v28 = sub_10065120(*(float *)(v10 - 8), v6 + 308, *(_BYTE *)(v6 + 404)) + *(float *)(v6 + 220);
      v11 = v28 * 0.01745329251994333;
      v29 = cos(v11);
      *(float *)&v11 = sin(v11);
      v12 = v25;
      v13 = (v5 << 6) + v6;
      *(float *)(v13 + 2356) = v29 * v25 + v26;
      *(float *)(v13 + 2364) = *(float *)&v11 * v25 + v27;
      *(float *)(v13 + 2360) = v26 + v29 * (*(float *)(v10 - 4) * v12 + v12);
      v14 = *(float *)(v10 - 4);
      *(_DWORD *)(v13 + 2412) = -1;
      *(_BYTE *)(v13 + 2416) = 0;
      v30 = v27 + *(float *)&v11 * (v12 + v14 * v12);
      *(float *)(((v5 + 37) << 6) + v6) = v30;
      v15 = (char *)v10;
      *(float *)(v13 + 2372) = 2.0;
      do
      {
        v16 = *v15;
        *(&v15[(v5 << 6) - v10 + 2392] + v6) = *v15;
        ++v15;
      }
      while ( v16 );
      *(float *)(v13 + 2376) = *(float *)(v13 + 2356);
      v17 = *(float *)(v13 + 2364);
      *(_DWORD *)(v13 + 2384) = 0;
      *(_DWORD *)(v13 + 2388) = -1;
      v10 += 16;
      ++v5;
      *(float *)(v13 + 2380) = v17 + 8.0;
      v9 = 0.5;
      *(float *)(v13 + 2404) = 0.5;
      *(float *)(v13 + 2400) = 0.5;
      *(float *)(v13 + 2408) = 9.0;
      result = v31++ + 1;
    }
    while ( v31 < (unsigned __int8)a2 );
  }
  *(_BYTE *)(v6 + 5556) = v5;
  if ( v5 < 0x32u )
  {
    v18 = 0.0;
    v19 = 1.0;
    result = (v5 << 6) + v6 + 2364;
    v20 = (unsigned __int8)(50 - v5);
    while ( 1 )
    {
      v22 = v19;
      v23 = v18;
      *(_DWORD *)(result + 48) = 0;
      *(float *)(result - 8) = v18;
      *(_BYTE *)(result + 52) = 1;
      *(float *)result = v18;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result - 4) = v18;
      *(_DWORD *)(result + 20) = 0;
      *(float *)(result + 4) = v18;
      *(_DWORD *)(result + 24) = -1;
      result += 64;
      --v20;
      *(float *)(result - 56) = v22;
      v24 = v22;
      *(float *)(result - 52) = v23;
      *(float *)(result - 48) = v23;
      *(float *)(result - 24) = v9;
      *(float *)(result - 28) = v9;
      *(float *)(result - 20) = *(float *)&v23;
      if ( !v20 )
        break;
      v21 = v23;
      v19 = v24;
      v18 = v21;
    }
  }
  return result;
}

//----- (100614E0) --------------------------------------------------------
int __usercall sub_100614E0@<eax>(int result@<eax>)
{
  int v1; // esi@1
  double v2; // st7@6
  float v3; // ST20_4@6
  float v4; // ST08_4@6
  float v5; // ST20_4@6
  float v6; // ST04_4@6
  float v7; // ST20_4@6

  v1 = result;
  if ( *(_BYTE *)(result + 2348) != 1 )
    result = sub_10067030(result + 204);
  if ( *(_BYTE *)(v1 + 2351) != 1 )
  {
    if ( *(float *)(v1 + 1952) != *(float *)(v1 + 220) || *(float *)(v1 + 1956) != *(float *)(v1 + 224) )
    {
      *(float *)(v1 + 1952) = *(float *)(v1 + 220);
      *(float *)(v1 + 1956) = *(float *)(v1 + 224);
      v2 = *(float *)(v1 + 212) * 0.5;
      *(_DWORD *)(v1 + 1948) = 49;
      v3 = v2;
      v4 = v3;
      v5 = *(float *)(v1 + 208) + v2;
      v6 = v5;
      v7 = v2 + *(float *)(v1 + 204);
      sub_1006BF80(v7, v6, v4, *(float *)(v1 + 220), *(float *)(v1 + 224), v1 + 1556, v1 + 1948);
    }
    result = sub_10068A50(v1 + 1556, *(_DWORD *)(v1 + 1948), -1, 1.5);
  }
  return result;
}

//----- (100615F0) --------------------------------------------------------
void __usercall sub_100615F0(int a1@<esi>)
{
  float *v1; // ecx@2
  float v2; // ST24_4@4
  double v3; // st7@5
  float v4; // ST24_4@7
  double v5; // st7@7
  double v6; // st6@7
  float v7; // ST28_4@10
  double v8; // st7@10
  float v9; // ST24_4@12
  float *v10; // edx@14
  float v11; // ST24_4@14
  char v12; // ST28_1@14
  int v13; // eax@15
  float v14; // [sp+14h] [bp-Ch]@4
  float v15; // [sp+14h] [bp-Ch]@10
  float v16; // [sp+18h] [bp-8h]@5
  float v17; // [sp+18h] [bp-8h]@8
  char v18; // [sp+1Ch] [bp-4h]@14

  if ( *(_BYTE *)(a1 + 2349) != 1 )
  {
    v1 = *(float **)(a1 + 44);
    if ( v1 )
    {
      if ( 9.8999998e24 != *v1 )
      {
        v2 = sub_10065120(*v1, a1 + 308, *(_BYTE *)(a1 + 404));
        v14 = v2 + *(float *)(a1 + 220);
        *(float *)(a1 + 2060) = v14;
        if ( *(float *)(a1 + 220) >= (double)*(float *)(a1 + 224) )
        {
          v7 = v14;
          v15 = *(float *)(a1 + 224);
          v8 = v7;
          if ( v15 >= (double)v7 )
            v8 = v15;
          v9 = v8;
          v5 = v9;
          *(float *)(a1 + 2060) = v9;
          v6 = *(float *)(a1 + 220);
        }
        else
        {
          v16 = *(float *)(a1 + 220);
          v3 = v14;
          if ( v16 >= (double)v14 )
            v3 = v16;
          v4 = v3;
          v5 = v4;
          *(float *)(a1 + 2060) = v4;
          v6 = *(float *)(a1 + 224);
        }
        v17 = v6;
        if ( v17 <= v5 )
          v5 = v17;
        v10 = *(float **)(a1 + 48);
        v11 = v5;
        *(float *)(a1 + 2060) = v11;
        v12 = sub_1006E1D0(*v10, a1 + 1964, 10, a1 + 5568);
        sub_1006E2C0(v12, &v18, (_DWORD *)(a1 + 2068), *(_BYTE *)(a1 + 2349));
        sub_1006AAB0(a1 + 2044);
        if ( *(_BYTE *)(a1 + 2072) != 1 )
        {
          v13 = *(_DWORD *)(a1 + 2076);
          if ( v13 == 54 || v13 == 55 || v13 == 70 || v13 == 68 || v13 == 69 || v13 == 71 )
            sub_10067EE0(*(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12), 59);
        }
      }
    }
  }
}

//----- (100617A0) --------------------------------------------------------
void __usercall sub_100617A0(int a1@<esi>)
{
  int v1; // edi@3
  int v2; // ebp@3
  float *v3; // ecx@4
  float v4; // ST18_4@6
  float *v5; // eax@6
  char v6; // al@8
  double v7; // st7@14
  float v8; // ST18_4@16
  double v9; // st7@16
  double v10; // st6@16
  float v11; // ST18_4@23
  float v12; // [sp+18h] [bp-Ch]@6
  float v13; // [sp+18h] [bp-Ch]@19
  signed int v14; // [sp+1Ch] [bp-8h]@2
  float v15; // [sp+20h] [bp-4h]@14
  float v16; // [sp+20h] [bp-4h]@17
  float v17; // [sp+20h] [bp-4h]@19

  if ( *(_BYTE *)(a1 + 2354) != 1 )
  {
    v14 = 0;
    if ( *(_BYTE *)(a1 + 2296) )
    {
      v1 = a1 + 2096;
      v2 = a1 + 52;
      do
      {
        v3 = *(float **)v2;
        if ( *(_DWORD *)v2 && 9.8999998e24 != *v3 )
        {
          v4 = sub_10065120(*v3, a1 + 308, *(_BYTE *)(a1 + 404));
          *(float *)v1 = *(float *)(a1 + 220) + v4;
          v5 = *(float **)(v2 + 24);
          v12 = 0.0;
          if ( v5 )
            v12 = sub_10065120(*v5, a1 + 308, *(_BYTE *)(a1 + 404));
          v6 = *(_BYTE *)(v1 + 12);
          if ( v6 != 9 && v6 != 4 && v6 != 14 && v6 != 5 )
            *(float *)(v1 + 4) = *(float *)(a1 + 220) + v12;
          if ( *(float *)(a1 + 220) >= (double)*(float *)(a1 + 224) )
          {
            v17 = *(float *)v1;
            v13 = *(float *)(a1 + 224);
            if ( v13 >= (double)v17 )
            {
              v9 = v13;
              *(float *)v1 = v13;
              v10 = *(float *)(a1 + 220);
            }
            else
            {
              v9 = v17;
              *(float *)v1 = v17;
              v10 = *(float *)(a1 + 220);
            }
          }
          else
          {
            v15 = *(float *)(a1 + 220);
            v7 = *(float *)v1;
            if ( v15 >= v7 )
              v7 = v15;
            v8 = v7;
            v9 = v8;
            *(float *)v1 = v8;
            v10 = *(float *)(a1 + 224);
          }
          v16 = v10;
          if ( v16 <= v9 )
            v9 = v16;
          v11 = v9;
          *(float *)v1 = v11;
          sub_1006AAB0(v1 - 16);
        }
        v2 += 4;
        v1 += 36;
        ++v14;
      }
      while ( v14 < *(_BYTE *)(a1 + 2296) );
    }
  }
}

//----- (10061950) --------------------------------------------------------
int __usercall sub_10061950@<eax>(int result@<eax>, int a2@<edx>)
{
  if ( *(_BYTE *)(result + 2352) != 1 )
    result = sub_10069C80(a2, result + 2356, *(_BYTE *)(result + 5556), 1);
  return result;
}

//----- (10061980) --------------------------------------------------------
void __usercall sub_10061980(int a1@<edi>, int a2)
{
  float *v2; // eax@1
  _DWORD *v3; // esi@4
  signed int v4; // ebx@4
  char v5; // [sp+10h] [bp-4h]@1

  v2 = *(float **)(a1 + 44);
  v5 = 0;
  if ( v2 && 9.8999998e24 != *v2 )
    v5 = sub_1006E1D0(**(float **)(a1 + 48), a1 + 1964, 10, a1 + 5568);
  v3 = (_DWORD *)(a1 + 112);
  v4 = 2;
  do
  {
    sub_1006E390(v5, v3, v3 - 1, *(_BYTE *)(a1 + 2353), *(_DWORD *)(a1 + 5576));
    sub_1006BEC0(a2, (int)(v3 - 3));
    v3 += 13;
    --v4;
  }
  while ( v4 );
}

//----- (10061A10) --------------------------------------------------------
int __thiscall sub_10061A10(int this)
{
  float *v1; // edx@2
  int result; // eax@6

  result = 1;
  if ( !*(_BYTE *)(this + 46) )
  {
    v1 = *(float **)(this + 20);
    if ( 9.8999998e24 == *v1
      || *(_BYTE *)(this + 44) && (*(float *)(this + 24) > (double)*v1 || *(float *)(this + 28) < (double)*v1) )
    {
      result = 0;
    }
  }
  return result;
}

//----- (10061A60) --------------------------------------------------------
void __usercall sub_10061A60(int a1@<esi>)
{
  float *v1; // eax@2
  int v2; // ecx@9

  if ( *(_BYTE *)(a1 + 2349) == 1 )
  {
    if ( *(_BYTE *)(a1 + 2350) != 1 && *(_DWORD *)(a1 + 2320) && !(unsigned __int8)sub_10061A10(a1 + 2300) )
      sub_1006A400(v2);
  }
  else
  {
    v1 = *(float **)(a1 + 44);
    if ( v1 && 9.8999998e24 == *v1 || *(_DWORD *)(a1 + 2320) && !(unsigned __int8)sub_10061A10(a1 + 2300) )
      sub_100659D0(
        *(float *)(a1 + 24),
        *(float *)(a1 + 28),
        *(float *)(a1 + 32),
        *(float *)(a1 + 36),
        0.0,
        0.0,
        *(_BYTE *)(a1 + 40));
  }
}

//----- (10061B00) --------------------------------------------------------
int __cdecl sub_10061B00(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // esi@1
  signed int v8; // edx@1
  double v9; // st3@1
  int v10; // eax@1
  double v11; // st7@1
  double v12; // st4@1
  double v13; // st3@1
  double v14; // rtt@2
  double v15; // st3@2
  double v16; // rt1@2
  double v17; // st2@3
  double v18; // rt2@3
  double v19; // st3@3
  double v20; // st7@3
  double v21; // rt0@3
  double v22; // st3@3
  double v23; // st4@3
  char *v24; // edi@4
  char v25; // al@5
  double v26; // st5@6
  double v27; // st5@6
  double v28; // st5@6

  v7 = a1;
  *(float *)a1 = a4;
  v8 = 2;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  *(float *)(a1 + 16) = *(float *)(a3 + 4);
  v9 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 40) = 0;
  *(float *)(a1 + 20) = v9;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(float *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 1960) = 0;
  *(float *)(a1 + 28) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  *(float *)(a1 + 204) = a4;
  *(float *)(a1 + 208) = a5;
  *(float *)(a1 + 212) = a6;
  *(float *)(a1 + 216) = a7;
  *(float *)(a1 + 220) = 150.0;
  *(float *)(a1 + 224) = 375.0;
  *(float *)(a1 + 1952) = 0.0;
  *(float *)(a1 + 1956) = 0.0;
  *(float *)(a1 + 308) = 0.0;
  *(float *)(a1 + 312) = 0.0;
  *(float *)(a1 + 316) = 1.0;
  *(float *)(a1 + 328) = 1.0;
  *(float *)(a1 + 340) = 1.0;
  *(float *)(a1 + 352) = 1.0;
  *(float *)(a1 + 364) = 1.0;
  *(float *)(a1 + 376) = 1.0;
  *(float *)(a1 + 388) = 1.0;
  *(float *)(a1 + 400) = 1.0;
  *(float *)(a1 + 320) = 0.0;
  *(float *)(a1 + 324) = 0.0;
  *(float *)(a1 + 332) = 0.0;
  *(float *)(a1 + 336) = 0.0;
  *(float *)(a1 + 344) = 0.0;
  *(float *)(a1 + 348) = 0.0;
  *(float *)(a1 + 356) = 0.0;
  *(float *)(a1 + 360) = 0.0;
  *(float *)(a1 + 368) = 0.0;
  *(float *)(a1 + 372) = 0.0;
  *(float *)(a1 + 380) = 0.0;
  *(float *)(a1 + 384) = 0.0;
  *(float *)(a1 + 392) = 0.0;
  *(float *)(a1 + 396) = 0.0;
  *(_BYTE *)(a1 + 404) = 2;
  *(float *)(a1 + 308) = *(float *)(a3 + 4);
  *(float *)(a1 + 320) = *(float *)(a3 + 8);
  *(float *)(a1 + 312) = 0.0;
  *(float *)(a1 + 324) = 225.0;
  *(_DWORD *)(a1 + 2068) = -1;
  *(_BYTE *)(a1 + 2072) = 0;
  *(_DWORD *)(a1 + 2076) = 54;
  v10 = a1 + 104;
  *(float *)(a1 + 2044) = a4 + a6 * 0.5;
  v11 = 1.0;
  *(float *)(a1 + 2048) = a5 + 0.5 * a7;
  *(float *)(v7 + 2052) = *(float *)(v7 + 8) * 0.4777779877185822;
  *(float *)(v7 + 2056) = *(float *)(v7 + 12) * 0.1194444969296455;
  *(float *)(a1 + 2060) = 150.0;
  *(float *)(v7 + 2064) = *(float *)(v7 + 220);
  v12 = 0.5;
  v13 = 12.0;
  while ( 1 )
  {
    v10 += 52;
    --v8;
    *(float *)(v10 - 56) = *(float *)(a1 + 2044);
    v17 = *(float *)(a1 + 2048);
    *(_DWORD *)(v10 - 48) = 0;
    *(_DWORD *)(v10 - 44) = -1;
    *(_BYTE *)(v10 - 40) = 0;
    *(float *)(v10 - 52) = v17 + 35.0;
    v18 = v13;
    *(float *)(v10 - 16) = v12;
    v19 = v11;
    v20 = v12;
    *(float *)(v10 - 12) = v19;
    v21 = v19;
    v22 = v18;
    v23 = v21;
    *(float *)(v10 - 8) = v18;
    if ( !v8 )
      break;
    v14 = v22;
    v15 = v20;
    v11 = v23;
    v16 = v15;
    v13 = v14;
    v12 = v16;
  }
  v24 = (char *)a2;
  do
  {
    v25 = *v24;
    v24[a1 - a2 + 116] = *v24;
    ++v24;
  }
  while ( v25 );
  v26 = *(float *)(a1 + 2044);
  *(_DWORD *)(a1 + 2320) = 0;
  *(float *)(a1 + 2300) = v26;
  *(_DWORD *)(a1 + 2308) = 0;
  v27 = *(float *)(a1 + 104);
  *(_DWORD *)(a1 + 2312) = -1;
  *(_DWORD *)(a1 + 2316) = -1;
  *(float *)(a1 + 2304) = v27 + 3.0;
  *(float *)(a1 + 2324) = *(float *)(a3 + 4);
  v28 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 2344) = 0;
  *(float *)(a1 + 2328) = v28;
  *(_BYTE *)(a1 + 2345) = 0;
  *(_BYTE *)(a1 + 2346) = 0;
  *(float *)(a1 + 2332) = v20;
  *(_WORD *)(a1 + 5558) = 12;
  *(_DWORD *)(a1 + 5560) = &unk_100B8DC0;
  *(float *)(a1 + 2336) = 0.0;
  *(_BYTE *)(a1 + 5564) = 1;
  *(float *)(a1 + 2340) = 23.0;
  *(_DWORD *)(a1 + 2348) = 0;
  *(_WORD *)(a1 + 2352) = 0;
  *(_BYTE *)(a1 + 2354) = 0;
  *(_BYTE *)(a1 + 2296) = 0;
  sub_10060E40((_BYTE *)a3, a1);
  sub_100612A0(0, 0, 0.0, a1);
  return sub_1006E420(a1 + 5568);
}

//----- (10061E10) --------------------------------------------------------
int __cdecl sub_10061E10(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // esi@1

  v7 = a1;
  sub_10061B00(a1, a2, a3, a4, a5, a6, a7);
  *(float *)(a1 + 220) = 170.0;
  *(_BYTE *)(a1 + 1960) = 0;
  *(float *)(a1 + 224) = 350.0;
  *(float *)(a1 + 1952) = 0.0;
  *(float *)(a1 + 1956) = 0.0;
  *(float *)(a1 + 324) = 180.0;
  *(float *)(v7 + 100) = *(float *)v7;
  *(float *)(v7 + 104) = *(float *)(v7 + 12) * 0.75 + *(float *)(v7 + 4);
  *(float *)(a1 + 140) = 0.0;
  *(float *)(a1 + 144) = 1.0;
  *(float *)(v7 + 152) = *(float *)v7;
  *(float *)(v7 + 156) = 0.75 * *(float *)(v7 + 12) + *(float *)(v7 + 4);
  *(float *)(a1 + 192) = 0.0;
  *(float *)(a1 + 196) = 1.0;
  *(float *)(v7 + 2300) = *(float *)(v7 + 8) + *(float *)v7;
  *(float *)(v7 + 2304) = *(float *)(v7 + 104) + 1.0;
  *(float *)(a1 + 2332) = 1.0;
  *(float *)(a1 + 2336) = 1.0;
  sub_10060E40((_BYTE *)a3, a1);
  return sub_100612A0(0, 0, 0.0, a1);
}

//----- (10061F10) --------------------------------------------------------
void __cdecl sub_10061F10(float a1, char *a2, float a3, float a4, float a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  float v8; // ST28_4@1
  double v9; // st7@1
  bool v10; // c0@1
  double v11; // st7@1
  float v12; // ST00_4@2
  double v13; // [sp+28h] [bp-8h]@1
  int v14; // [sp+48h] [bp+18h]@1

  v6 = a6;
  v7 = 0;
  v8 = a1 * 0.5 + *(float *)(a6 + 20);
  v14 = *(int *)(a6 + 16);
  v9 = v8;
  v13 = v9;
  v10 = *(float *)&v14 < v9;
  v11 = *(float *)&v14;
  if ( v10 )
  {
    do
    {
      v12 = v11;
      sub_10060FA0(v12, a2, a3, a4, a5, v7++, v6);
      *(float *)&v14 = *(float *)&v14 + a1;
      v11 = *(float *)&v14;
    }
    while ( *(float *)&v14 < v13 );
  }
}

//----- (10061FA0) --------------------------------------------------------
int __cdecl sub_10061FA0(float a1, float a2, int a3, int a4)
{
  return sub_10061190(a1, a2, 0.0, a3, a4);
}

//----- (10061FD0) --------------------------------------------------------
void __usercall sub_10061FD0(int a1@<esi>, int a2)
{
  char v2; // ST3C_1@4

  if ( *(_BYTE *)(a1 + 2350) != 1 && *(_DWORD *)(a1 + 2320) )
  {
    if ( (unsigned __int8)sub_10061A10(a1 + 2300) )
    {
      v2 = sub_1006E1D0(**(float **)(a1 + 48), a1 + 1964, 10, a1 + 5568);
      sub_1006E300(v2, (_DWORD *)(a1 + 2312), (int *)(a1 + 2308), *(_BYTE *)(a1 + 2350), *(_DWORD *)(a1 + 5576));
      sub_10068AE0(a2, a1 + 2300, *(_WORD *)(a1 + 5558), *(_DWORD *)(a1 + 5560), *(_BYTE *)(a1 + 5564));
    }
  }
}

//----- (10062070) --------------------------------------------------------
char __cdecl sub_10062070(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_100614E0(a4);
      sub_10061950(a4, a1);
      sub_100617A0(a4);
      sub_100615F0(a4);
      sub_10061FD0(a4, a1);
      sub_10061A60(a4);
      sub_10061980(a4, a1);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10061980(a4, a1);
      sub_10061FD0(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10062160) --------------------------------------------------------
int __cdecl sub_10062160(float a1, float a2, float a3, int a4)
{
  int v4; // esi@1
  double v5; // st7@1
  signed int v6; // edi@2
  char v7; // bl@4
  double i; // st7@4
  int v9; // ecx@6
  float v10; // ST00_4@9
  float v12; // [sp+1Ch] [bp-Ch]@2
  double v13; // [sp+20h] [bp-8h]@4
  float v14; // [sp+30h] [bp+8h]@2
  float v15; // [sp+30h] [bp+8h]@7
  int v16; // [sp+38h] [bp+10h]@4

  v4 = a4;
  v5 = a2;
  if ( a2 == 0.0 )
  {
    v6 = 0;
    v14 = 0.5 * a1 + *(float *)(a4 + 20);
    v12 = a1;
  }
  else
  {
    v14 = v5 * 0.5 + *(float *)(a4 + 20);
    v12 = v5;
    v6 = (signed int)(a1 / v5 + 0.5);
  }
  v7 = 0;
  v16 = *(int *)(a4 + 16);
  v13 = v14;
  for ( i = *(float *)&v16; *(float *)&v16 < v13; i = *(float *)&v16 )
  {
    if ( v6 && (v9 = (unsigned __int8)v7, (unsigned __int8)v7 % v6) )
    {
      v15 = a3 * 0.6000000238418579;
      *(float *)(((unsigned __int8)v7 << 6) + v4 + 2372) = 1.5;
    }
    else
    {
      v9 = (unsigned __int8)v7;
      v15 = a3;
      *(float *)(((unsigned __int8)v7 << 6) + v4 + 2372) = 2.0;
    }
    v10 = i;
    sub_10061FA0(v10, v15, v9, v4);
    ++v7;
    *(float *)&v16 = *(float *)&v16 + v12;
  }
  *(_BYTE *)(v4 + 5556) = v7;
  return (unsigned __int8)v7;
}

//----- (10062280) --------------------------------------------------------
void __cdecl sub_10062280(float a1, int a2, int a3)
{
  float v3; // esi@1
  char v4; // bl@12
  char v5; // cl@14
  int v6; // eax@15
  float v7; // [sp+10h] [bp-14h]@2
  float v8; // [sp+14h] [bp-10h]@2
  float v9; // [sp+18h] [bp-Ch]@2
  float v10; // [sp+1Ch] [bp-8h]@2

  v3 = a1;
  if ( a1 != 0.0 )
  {
    v10 = *(float *)(LODWORD(a1) + 28);
    v9 = *(float *)(LODWORD(a1) + 24);
    v8 = *(float *)(LODWORD(a1) + 20);
    v7 = *(float *)(LODWORD(a1) + 16);
    if ( *(_BYTE *)(LODWORD(a1) + 8) == 1 )
      sub_10061E10(
        *(_DWORD *)(LODWORD(a1) + 4),
        *(_DWORD *)(LODWORD(a1) + 12),
        164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912,
        v7,
        v8,
        v9,
        v10);
    else
      sub_10061B00(
        *(_DWORD *)(LODWORD(a1) + 4),
        *(_DWORD *)(LODWORD(a1) + 12),
        164 * *(_BYTE *)(LODWORD(a1) + 2) + dword_1031FB44 + 3912,
        v7,
        v8,
        v9,
        v10);
    *(_WORD *)(*(_DWORD *)(LODWORD(a1) + 4) + 5558) = *(_WORD *)(LODWORD(a1) + 42);
    if ( *(_BYTE *)(LODWORD(a1) + 41) )
      sub_10060F80(dword_1031FB44 + 28 * *(_BYTE *)(LODWORD(a1) + 2) + 20480, *(_DWORD *)(LODWORD(a1) + 4));
    if ( a3 && *(_BYTE *)LODWORD(a1) >= 0 )
      sub_10060F20(a3 + 12 * *(_BYTE *)LODWORD(a1), *(_BYTE *)(LODWORD(a1) + 41), *(_DWORD *)(LODWORD(a1) + 4));
    if ( a2 && *(float *)(a2 + 4) > 0.0 )
    {
      v4 = sub_10062160(*(float *)(a2 + 4), *(float *)(a2 + 8), *(float *)(a2 + 12), *(_DWORD *)(LODWORD(a1) + 4));
      LOBYTE(a1) = v4;
      if ( *(float *)(a2 + 16) > 0.0 )
        sub_10061F10(
          *(float *)(a2 + 16),
          *(char **)(a2 + 20),
          *(float *)(a2 + 24),
          *(float *)(a2 + 28),
          *(float *)(a2 + 12),
          *(_DWORD *)(LODWORD(v3) + 4));
      v5 = *(_BYTE *)(a2 + 36);
      if ( v5 )
      {
        v6 = *(_DWORD *)(a2 + 32);
        if ( v6 )
        {
          sub_100612A0(v6, v5, a1, *(_DWORD *)(LODWORD(v3) + 4));
          *(_BYTE *)(*(_DWORD *)(LODWORD(v3) + 4) + 5556) = v4 + *(_BYTE *)(a2 + 36);
        }
      }
    }
  }
}
// 1031FB44: using guessed type int dword_1031FB44;

//----- (10062420) --------------------------------------------------------
unsigned __int8 __cdecl sub_10062420(char a1, int a2)
{
  unsigned __int8 result; // al@1
  int v3; // esi@3
  unsigned __int8 v4; // bl@4
  char *v5; // eax@6
  char v6; // cl@7
  char v7; // cl@8
  int v8; // eax@8
  bool v9; // zf@8
  unsigned __int8 v10; // [sp+Ah] [bp-AAh]@1
  unsigned __int8 v11; // [sp+Bh] [bp-A9h]@3
  _BYTE *v12; // [sp+Ch] [bp-A8h]@1
  __int16 v13; // [sp+10h] [bp-A4h]@4
  char v14; // [sp+12h] [bp-A2h]@6
  char v15; // [sp+96h] [bp-1Eh]@8
  char v16; // [sp+ADh] [bp-7h]@8

  result = 0;
  v10 = 0;
  v12 = &unk_100EA1D4;
  if ( !(a1 & 8) )
    v12 = &unk_100EA1C0;
  v3 = (int)v12;
  v11 = 0;
  if ( *v12 != 5 )
  {
    do
    {
      v4 = 0;
      if ( sub_1006F4F0(0, *(_BYTE *)v3, *(_BYTE *)(v3 + 1), (int)&v13) )
      {
        do
        {
          if ( v10 >= 0x96u )
            break;
          v5 = &v14;
          do
          {
            v6 = *v5;
            *(&v5[38 * v10 - (_DWORD)&v14 + 2] + a2) = *v5;
            ++v5;
          }
          while ( v6 );
          v7 = v16;
          v8 = 38 * v10 + a2;
          *(_WORD *)v8 = v13;
          *(_BYTE *)(v8 + 35) = v7;
          *(_BYTE *)(v8 + 34) = *(_BYTE *)(v3 + 1);
          v9 = (v15 & 0x40) == 64;
          *(_BYTE *)(v8 + 33) = *(_BYTE *)v3;
          ++v10;
          *(_BYTE *)(v8 + 36) = v9;
          ++v4;
        }
        while ( sub_1006F4F0(v4, *(_BYTE *)v3, *(_BYTE *)(v3 + 1), (int)&v13) );
      }
      v3 = (int)&v12[2 * ++v11];
    }
    while ( v12[2 * v11] != 5 );
    result = v10;
  }
  return result;
}

//----- (10062560) --------------------------------------------------------
char __usercall sub_10062560@<al>(int a1@<eax>)
{
  char result; // al@1

  *(_BYTE *)(a1 + 8) = 0;
  result = 40;
  byte_101DEDE1 = 40;
  byte_101DEDE0 = 40;
  return result;
}
// 101DEDE0: using guessed type char byte_101DEDE0;
// 101DEDE1: using guessed type char byte_101DEDE1;

//----- (10062580) --------------------------------------------------------
char sub_10062580()
{
  char v0; // bl@1
  __int16 v1; // bp@1
  __int16 v2; // di@1
  unsigned int v3; // eax@4
  _DWORD *v4; // ecx@4
  char *v5; // edx@4
  int v6; // esi@8
  int v7; // eax@9
  _BYTE *v8; // ecx@9
  _BYTE *v9; // edx@9
  int v10; // eax@11
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  _BYTE *v13; // ecx@13
  _BYTE *v14; // edx@13
  signed int v15; // eax@15
  unsigned int v16; // eax@24
  _DWORD *v17; // ecx@24
  char *v18; // edx@24
  int v19; // esi@28
  int v20; // eax@29
  _BYTE *v21; // ecx@29
  _BYTE *v22; // edx@29
  int v23; // eax@31
  _BYTE *v24; // ecx@31
  _BYTE *v25; // edx@31
  _BYTE *v26; // ecx@33
  _BYTE *v27; // edx@33
  signed int v28; // eax@35
  char v30; // [sp+14h] [bp-144h]@1
  char v31; // [sp+B4h] [bp-A4h]@1

  memset(&v30, 0, 0xA0u);
  memset(&v31, 0, 0xA0u);
  v0 = 0;
  v1 = sub_1006F4C0(1, 0, 1);
  v2 = sub_1006F4C0(2, 0, 1);
  sub_1006F4F0(0, 1, 0, (int)&v31);
  sub_1006F4F0(0, 2, 0, (int)&v30);
  if ( (unsigned __int16)v2 > (unsigned __int16)word_101DEE90 )
  {
LABEL_19:
    v0 = 1;
    goto LABEL_21;
  }
  if ( v2 && v2 == word_101DEE90 )
  {
    v3 = 160;
    v4 = &unk_101DEE98;
    v5 = &v30;
    do
    {
      if ( *(_DWORD *)v5 != *v4 )
        goto LABEL_8;
      v3 -= 4;
      ++v4;
      v5 += 4;
    }
    while ( v3 >= 4 );
    if ( v3 )
    {
LABEL_8:
      v6 = (unsigned __int8)*v5 - *(_BYTE *)v4;
      if ( (unsigned __int8)*v5 != *(_BYTE *)v4
        || (v7 = v3 - 1, v8 = (char *)v4 + 1, v9 = v5 + 1, v7)
        && ((v6 = *v9 - *v8, *v9 != *v8)
         || (v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, v10)
         && ((v6 = *v12 - *v11, *v12 != *v11)
          || (v13 = v11 + 1, v14 = v12 + 1, v10 != 1) && (v6 = *v14 - *v13, *v14 != *v13))) )
      {
        v15 = 1;
        if ( v6 <= 0 )
          v15 = -1;
LABEL_18:
        if ( v15 )
          goto LABEL_19;
        v0 = 0;
        goto LABEL_21;
      }
    }
    v15 = 0;
    goto LABEL_18;
  }
LABEL_21:
  word_101DEE90 = v2;
  qmemcpy(&unk_101DEE98, &v30, 0xA0u);
  if ( (unsigned __int16)v1 > (unsigned __int16)word_101DEE8C )
  {
LABEL_39:
    v0 = 2;
    goto LABEL_40;
  }
  if ( v1 && v1 == word_101DEE8C )
  {
    v16 = 160;
    v17 = &unk_101DEDE8;
    v18 = &v31;
    do
    {
      if ( *(_DWORD *)v18 != *v17 )
        goto LABEL_28;
      v16 -= 4;
      ++v17;
      v18 += 4;
    }
    while ( v16 >= 4 );
    if ( v16 )
    {
LABEL_28:
      v19 = (unsigned __int8)*v18 - *(_BYTE *)v17;
      if ( (unsigned __int8)*v18 != *(_BYTE *)v17
        || (v20 = v16 - 1, v21 = (char *)v17 + 1, v22 = v18 + 1, v20)
        && ((v19 = *v22 - *v21, *v22 != *v21)
         || (v23 = v20 - 1, v24 = v21 + 1, v25 = v22 + 1, v23)
         && ((v19 = *v25 - *v24, *v25 != *v24)
          || (v26 = v24 + 1, v27 = v25 + 1, v23 != 1) && (v19 = *v27 - *v26, *v27 != *v26))) )
      {
        v28 = 1;
        if ( v19 <= 0 )
          v28 = -1;
LABEL_38:
        if ( v28 )
          goto LABEL_39;
        goto LABEL_40;
      }
    }
    v28 = 0;
    goto LABEL_38;
  }
LABEL_40:
  qmemcpy(&unk_101DEDE8, &v31, 0xA0u);
  word_101DEE8C = v1;
  return v0;
}
// 101DEE8C: using guessed type __int16 word_101DEE8C;
// 101DEE90: using guessed type __int16 word_101DEE90;

//----- (100627C0) --------------------------------------------------------
char __usercall sub_100627C0@<al>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, int a5)
{
  _WORD *v5; // ebp@1
  int v6; // esi@1
  float *v7; // edx@1
  unsigned __int8 v8; // al@1
  void *v9; // ecx@1
  signed int v10; // ST74_4@1
  bool v11; // cf@1
  char result; // al@2
  void *v13; // ecx@14
  __int16 v14; // si@20
  __int16 v15; // si@20
  __int16 v16; // bx@20
  __int16 v17; // bx@20
  char v18; // ST74_1@20
  unsigned __int8 v19; // al@24
  unsigned int v20; // ecx@26
  unsigned int v21; // eax@32
  int v22; // eax@41
  __int16 v23; // ax@43
  __int16 v24; // ax@48
  unsigned __int8 v25; // cl@50
  unsigned int v26; // edx@50
  int v27; // ebx@54
  __int16 v28; // dx@54
  unsigned int v29; // esi@54
  int v30; // eax@54
  int v31; // ecx@54
  int v32; // ecx@54
  int v33; // esi@62
  unsigned __int8 v34; // cl@64
  int v35; // ebx@66
  char v36; // al@66
  double v37; // st7@67
  double v38; // st7@73
  unsigned int v39; // eax@76
  double v40; // st7@82
  float v41; // ST68_4@86
  float v42; // ST58_4@86
  float v43; // ST58_4@86
  float v44; // ST68_4@86
  float v45; // ST58_4@86
  float v46; // ST58_4@86
  signed int v47; // eax@86
  float v48; // ST68_4@86
  float v49; // ST58_4@86
  float v50; // ST58_4@86
  float v51; // ST68_4@86
  float v52; // ST58_4@86
  float v53; // ST58_4@86
  float v54; // ST68_4@86
  float v55; // ST58_4@86
  float v56; // ST58_4@86
  float v57; // ST68_4@86
  float v58; // ST58_4@86
  float v59; // ST58_4@86
  double v60; // st7@90
  double v61; // st7@91
  double v62; // ST84_8@96
  float v63; // ST44_4@96
  char *v64; // ST38_4@96
  int v65; // eax@96
  float v66; // ST58_4@96
  char *v67; // ST38_4@96
  int v68; // eax@96
  signed int v69; // ST68_4@98
  float v70; // ST74_4@98
  float v71; // ST34_4@98
  int v72; // esi@99
  __int16 v73; // ax@101
  unsigned __int16 v74; // cx@104
  unsigned __int8 v75; // al@104
  int v76; // ecx@111
  void *v77; // edi@112
  char v78; // cl@113
  int v79; // ebp@113
  char v80; // bl@113
  int v81; // eax@114
  int v82; // esi@128
  double v83; // ST84_8@128
  float v84; // ST8C_4@128
  float v85; // ST58_4@128
  float v86; // ST44_4@128
  int v87; // ebx@128
  float v88; // ST8C_4@128
  float v89; // ST8C_4@128
  int v90; // eax@129
  unsigned __int8 v91; // bl@133
  float v92; // ST60_4@137
  signed int v93; // eax@137
  _WORD *v94; // esi@137
  float v95; // ST84_4@137
  float v96; // ST84_4@137
  unsigned __int8 v97; // al@138
  signed int v98; // ST84_4@155
  double v99; // st7@155
  bool v100; // zf@155
  __int16 v101; // ax@157
  unsigned __int16 v102; // cx@157
  __int16 v103; // si@157
  float v104; // ST6C_4@161
  float v105; // ST38_4@161
  float v106; // ST34_4@161
  float v107; // ST6C_4@164
  float v108; // ST40_4@164
  float v109; // ST6C_4@164
  float v110; // ST3C_4@164
  float v111; // ST6C_4@164
  float v112; // ST34_4@164
  float v113; // ST60_4@166
  signed int v114; // eax@166
  float v115; // ST58_4@166
  float v116; // ST6C_4@166
  float v117; // ST6C_4@166
  char *v118; // eax@167
  float *v119; // eax@169
  int v120; // ST44_4@169
  bool v121; // al@172
  bool v122; // bl@176
  int v123; // esi@179
  char v124; // di@180
  float v125; // [sp+8h] [bp-B4h]@128
  float v126; // [sp+10h] [bp-ACh]@128
  float v127; // [sp+10h] [bp-ACh]@166
  float v128; // [sp+24h] [bp-98h]@159
  unsigned __int8 v129; // [sp+29h] [bp-93h]@1
  unsigned __int8 v130; // [sp+2Ah] [bp-92h]@20
  char v131; // [sp+2Ah] [bp-92h]@59
  unsigned __int8 v132; // [sp+2Ah] [bp-92h]@111
  unsigned __int8 v133; // [sp+2Bh] [bp-91h]@24
  unsigned __int8 v134; // [sp+2Ch] [bp-90h]@20
  float v135; // [sp+2Ch] [bp-90h]@69
  float v136; // [sp+2Ch] [bp-90h]@111
  float v137; // [sp+2Ch] [bp-90h]@166
  unsigned __int8 v138; // [sp+31h] [bp-8Bh]@111
  bool v139; // [sp+32h] [bp-8Ah]@24
  unsigned __int8 v140; // [sp+33h] [bp-89h]@1
  __int16 v141; // [sp+34h] [bp-88h]@20
  int v142; // [sp+38h] [bp-84h]@1
  unsigned __int8 v143; // [sp+3Ch] [bp-80h]@24
  char v144; // [sp+3Eh] [bp-7Eh]@22
  bool v145; // [sp+3Fh] [bp-7Dh]@18
  int v146; // [sp+40h] [bp-7Ch]@54
  char v147; // [sp+40h] [bp-7Ch]@174
  float v148; // [sp+44h] [bp-78h]@78
  char v149; // [sp+4Ah] [bp-72h]@1
  char v150; // [sp+4Bh] [bp-71h]@1
  __int16 v151; // [sp+4Ch] [bp-70h]@20
  int v152; // [sp+4Ch] [bp-70h]@112
  float v153; // [sp+58h] [bp-64h]@159
  float v154; // [sp+5Ch] [bp-60h]@76
  float v155; // [sp+64h] [bp-58h]@1
  unsigned int v156; // [sp+68h] [bp-54h]@1
  int v157; // [sp+6Ch] [bp-50h]@1
  int v158; // [sp+70h] [bp-4Ch]@54
  unsigned __int16 v159; // [sp+74h] [bp-48h]@157
  __int16 v160; // [sp+76h] [bp-46h]@157
  __int16 v161; // [sp+78h] [bp-44h]@157
  _WORD *v162; // [sp+7Ch] [bp-40h]@1
  int v163; // [sp+80h] [bp-3Ch]@1
  float v164; // [sp+84h] [bp-38h]@1
  int v165; // [sp+88h] [bp-34h]@52
  float v166; // [sp+8Ch] [bp-30h]@1
  int v167; // [sp+90h] [bp-2Ch]@155
  float v168; // [sp+94h] [bp-28h]@155
  float v169; // [sp+98h] [bp-24h]@155
  __int16 v170; // [sp+9Ch] [bp-20h]@155
  __int16 v171; // [sp+9Eh] [bp-1Eh]@155
  float *v172; // [sp+A0h] [bp-1Ch]@1
  char v173; // [sp+A4h] [bp-18h]@167

  v166 = 0.0;
  v5 = a4;
  v157 = a3;
  v6 = a1;
  v7 = *(float **)(a5 + 12);
  v163 = v6;
  v162 = a4;
  v142 = a2;
  v150 = 5;
  v149 = 5;
  v172 = v7;
  v140 = 0;
  sub_1008D070(39, &v156);
  memset(word_101DEF48, 0, 0x1644u);
  v8 = sub_10062420(v156, (int)word_101DEF48);
  v10 = *a4;
  v129 = v8;
  v11 = (unsigned __int8)(byte_101DEF3C + 1) < 0xAu;
  v155 = *(float *)(a5 + 4) + 3.0 + 1.0;
  ++byte_101DEF3C;
  v164 = (double)v10 + 0.5;
  if ( !v11
    || (result = unk_101DEF3D, unk_101DEF3D != byte_102BA90E)
    || (LOWORD(v9) = word_101DEF40, word_101DEF40 != *(_WORD *)a5)
    || !byte_101DEF3E && (result = j_gdi_pvg_cmd_list_execute(0)) == 0 )
  {
    byte_101DEF3E = 1;
    unk_101DEF3D = byte_102BA90E;
    byte_101DEF3C = 0;
    word_101DEF40 = *(_WORD *)a5;
    if ( v156 & 1 && sub_1006F3C0(v9) & 3 && !(*(_BYTE *)(v6 + 22) & 0x18) && !sub_1006F3E0(2) )
    {
      if ( *(_BYTE *)(a5 + 8) )
      {
        sub_10032270(v6, byte_101DEDE1, 1);
        result = sub_10032270(v6, byte_101DEDE0, 1);
      }
      else
      {
        sub_100522A0(0);
        sub_10052290(0);
        sub_10065E00(0);
        result = sub_10065DC0(0);
      }
      return result;
    }
    v145 = v156 & 0x400
        && (sub_1006F3C0(v9) & 0xC && sub_1006F3E0(1) || *(_BYTE *)(v6 + 22) & 0x1E || !(sub_1006F3C0(v13) & 0xC));
    v14 = sub_1006F4C0(5, 1, 1);
    v15 = v14 - sub_1006F4C0(3, 1, 1);
    v16 = sub_1006F4C0(5, 0, 1);
    v141 = v16 - sub_1006F4C0(3, 0, 1);
    v151 = sub_1006F4C0(0, 1, 1);
    v17 = sub_1006F4C0(0, 0, 1);
    v130 = v17 + v151;
    v18 = sub_1006F4C0(1, 1, 1);
    v134 = v18 + sub_1006F4C0(1, 0, 1);
    if ( !(~(unsigned __int8)(v156 >> 3) & 1) || !v15 || (v144 = 1, !v141) )
      v144 = 0;
    v139 = (v156 & 0x10000) == 0x10000;
    v133 = 0;
    v19 = (signed int)(*(float *)(v157 + 8) / v155);
    v143 = (signed int)(*(float *)(v157 + 8) / v155);
    if ( ~(unsigned __int8)(v156 >> 3) & 1 )
    {
      if ( v17 )
      {
        v20 = (unsigned __int16)v17;
      }
      else
      {
        if ( v141 )
          goto LABEL_35;
        v20 = (unsigned __int16)v151;
      }
      if ( v19 < v20 )
        LOBYTE(v20) = (signed int)(*(float *)(v157 + 8) / v155);
      v133 = v20;
    }
    else
    {
      v21 = (unsigned __int16)v151 + (unsigned __int16)v17;
      if ( v143 < v21 )
        LOBYTE(v21) = (signed int)(*(float *)(v157 + 8) / v155);
      v133 = v21;
      v19 = (signed int)(*(float *)(v157 + 8) / v155);
    }
LABEL_35:
    if ( v156 & 4 )
    {
      if ( (v156 & 0x8000) == 0x8000 )
      {
        v140 = v129 - v130;
      }
      else if ( v129 <= v19 )
      {
        v140 = 0;
      }
      else
      {
        v140 = v129 - v19;
      }
    }
    v22 = (unsigned __int8)sub_10062580() - 1;
    if ( v22 )
    {
      if ( v22 == 1 )
        v23 = 0;
      else
        v23 = *(_WORD *)a5;
    }
    else
    {
      v23 = v134;
    }
    if ( (unsigned __int16)v23 < *(_WORD *)a5 )
      *(_WORD *)a5 = v23;
    LOBYTE(v24) = v140;
    if ( *(_WORD *)a5 < (unsigned int)v140 )
      v24 = *(_WORD *)a5;
    v25 = v17 + v151;
    v24 = (unsigned __int8)v24;
    v26 = (unsigned __int8)(v129 - v24);
    *(_WORD *)a5 = (unsigned __int8)v24;
    if ( v26 > v130 )
      v25 = v129 - v24;
    v165 = v143;
    if ( v25 >= (unsigned int)v143 )
      v25 = v143;
    v27 = (unsigned __int16)v24;
    v28 = v24;
    v29 = v25;
    v30 = v129 - v25 - (unsigned __int16)v24;
    v31 = v30 < 0;
    LOBYTE(v31) = v30 <= 0;
    v146 = v27;
    v32 = v30 & (v31 - 1);
    v158 = (unsigned __int8)v32;
    if ( v140 && (v28 || (_BYTE)v32) && !v139 )
      v166 = 5.0;
    v131 = sub_10052270();
    if ( v131 )
    {
      v34 = v143;
    }
    else
    {
      if ( !v129 )
      {
        if ( *(_BYTE *)(a5 + 8) )
        {
          v33 = v163;
          sub_10032270(v163, byte_101DEDE1, 1);
          result = sub_10032270(v33, byte_101DEDE0, 1);
          *(_WORD *)a5 = 0;
          word_101DEF38 = -1;
        }
        else
        {
          sub_100522A0(0);
          sub_10052290(0);
          sub_10065E00(0);
          result = sub_10065DC0(0);
          *(_WORD *)a5 = 0;
          word_101DEF38 = -1;
        }
        return result;
      }
      v34 = 0;
    }
    v35 = v157;
    v36 = *(_BYTE *)(v157 + 12);
    if ( v36 )
      v37 = 2.0;
    else
      v37 = 8.0;
    v135 = v37;
    if ( v144 )
      v135 = v135 + 8.0;
    if ( v139 || v145 )
    {
      v38 = v155;
      v135 = v135 + v155;
    }
    else
    {
      v38 = v155;
    }
    if ( *(_BYTE *)(v157 + 13) )
    {
      v39 = v34;
      v154 = (double)a4[1];
      if ( v29 > v34 )
        v39 = v29;
      v148 = v154 - (v38 * (double)v39 + v135);
    }
    else
    {
      v148 = (double)a4[1];
      if ( v36 )
      {
        if ( v29 <= v34 )
          v29 = v34;
        v40 = v38 * (double)v29;
      }
      else
      {
        v40 = v38 * (double)v165;
      }
      v154 = v40 + v148 + v135;
    }
    byte_101DEF3E = 0;
    j_gdi_pvg_cmd_list_start(0, 2);
    if ( *(_BYTE *)(v35 + 12) )
    {
      v164 = (double)*a4 + 1.5;
      sub_1008C110(1.0);
      j_gdi_pvg_begin(66);
      j_gdi_pvg_color_u32(-16777216);
      v41 = v148 - 0.5;
      v42 = (double)*a4 - 0.5;
      sub_1008C2F0(v42, v41);
      v43 = (double)*a4 + *(float *)(v35 + 4) + 0.5;
      sub_1008C2F0(v43, v41);
      v44 = v154 + 0.5;
      v45 = (double)*a4 + *(float *)(v35 + 4) + 0.5;
      sub_1008C2F0(v45, v44);
      v46 = (double)*a4 - 0.5;
      sub_1008C2F0(v46, v44);
      j_gdi_pvg_end();
      j_gdi_pvg_begin(66);
      v47 = sub_10065D00(-1);
      j_gdi_pvg_color_u32(v47);
      v48 = v148 + 0.5;
      v49 = (double)*a4 + 0.5;
      sub_1008C2F0(v49, v48);
      v50 = (double)*a4 + *(float *)(v35 + 4) - 0.5;
      sub_1008C2F0(v50, v48);
      v51 = v154 - 0.5;
      v52 = (double)*a4 + *(float *)(v35 + 4) - 0.5;
      sub_1008C2F0(v52, v51);
      v53 = (double)*a4 + 0.5;
      sub_1008C2F0(v53, v51);
      j_gdi_pvg_end();
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(-16777216);
      v54 = v148 + 1.0;
      v55 = (double)*a4 + 1.0;
      sub_1008C2F0(v55, v54);
      v56 = (double)*a4 + *(float *)(v35 + 4) - 1.0;
      sub_1008C2F0(v56, v54);
      v57 = v154 - 1.0;
      v58 = (double)*a4 + *(float *)(v35 + 4) - 1.0;
      sub_1008C2F0(v58, v57);
      v59 = (double)*a4 + 1.0;
      sub_1008C2F0(v59, v57);
      j_gdi_pvg_end();
    }
    if ( v145 == 1 && !v139 || !v131 )
    {
      v60 = v148;
      if ( *(_BYTE *)(v35 + 12) )
        v61 = v60 + 1.0 + 3.0;
      else
        v61 = v60 + 6.0;
      v148 = v61;
    }
    if ( v145 == 1 && !v139 )
    {
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_color_u32(-1);
      v62 = *(float *)(v35 + 4) * 0.5 + (double)*a4;
      v63 = *(float *)(a5 + 4);
      v64 = sub_1006ED10(0x4E4u);
      v65 = sub_10065060(*(float *)(a5 + 4));
      v66 = v62 - sub_1008D010(v65, (int)v64, v63) * 0.5;
      v67 = sub_1006ED10(0x4E4u);
      v68 = sub_10065060(*(float *)(a5 + 4));
      sub_1008CE70(v68, (int)v67, v66, v148, v63);
      j_gdi_pvg_disable(35);
      v148 = v148 + v155;
    }
    if ( v131 )
    {
      v69 = *a4;
      v70 = *(float *)(v35 + 4) + (double)v69;
      v71 = (double)v69;
      sub_10065780(v71, v148, v70, v154, 0);
      if ( *(_BYTE *)(a5 + 8) )
      {
        v72 = v163;
        sub_10032270(v163, byte_101DEDE1, 1);
        sub_10032270(v72, byte_101DEDE0, 1);
        *(_WORD *)a5 = 0;
      }
      else
      {
        sub_100522A0(0);
        sub_10052290(0);
        sub_10065E00(0);
        sub_10065DC0(0);
        *(_WORD *)a5 = 0;
      }
      return j_gdi_pvg_cmd_list_stop(0);
    }
    v73 = *(_WORD *)a5;
    if ( *(_WORD *)a5 && v73 == word_101DEE88 && word_101DEF48[19 * (unsigned __int16)(v73 + v133)] != word_101DEF38 )
    {
      v74 = v129;
      v75 = 0;
      if ( v129 )
      {
        while ( word_101DEF48[19 * v75] != word_101DEF38 )
        {
          if ( ++v75 >= v129 )
            goto LABEL_109;
        }
        v74 = v75;
      }
LABEL_109:
      if ( v74 < v129 )
        *(_WORD *)a5 = v74 - v133;
    }
    v76 = v133;
    v136 = v148;
    word_101DEE88 = *(_WORD *)a5;
    word_101DEF38 = word_101DEF48[19 * (v133 + (unsigned __int16)word_101DEE88)];
    v132 = 0;
    v138 = 0;
    if ( v129 )
    {
      v152 = -v133;
      v77 = &unk_101DEF69;
      do
      {
        v78 = *((_BYTE *)v77 + 1);
        v79 = (int)v77 - 31;
        v80 = 0;
        if ( v78 || (v81 = v156 & 0x60, v81 != 96) && v81 != 32 && (v81 != 64 || *(_BYTE *)v77) )
        {
          if ( *(_BYTE *)(v79 + 34) || (v156 & 0x60) == 64 && !v78 && *(_BYTE *)v77 == 1 )
            v80 = 2;
        }
        else
        {
          v80 = byte_102BA90E + 1;
        }
        if ( (!*(_BYTE *)v77 && v138 < v133 || v152 >= *(_WORD *)a5) && v132 < v143 )
        {
          j_gdi_pvg_enable(35);
          j_gdi_pvg_blend_func(4, 5);
          j_gdi_pvg_begin(72);
          v82 = (unsigned __int8)v80;
          j_gdi_pvg_color_u32(dword_100EA184[*(_BYTE *)v77 + (unsigned __int8)v80 + 2 * *(_BYTE *)v77]);
          v83 = v136 - 2.5;
          v84 = v83;
          v85 = v164 - 0.5;
          sub_1008C2F0(v85, v84);
          v86 = v84;
          v87 = v157;
          v88 = (double)*v162 + *(float *)(v157 + 4) - v166 - 1.0;
          sub_1008C2F0(v88, v86);
          v89 = v155 + v83;
          *(float *)&v83 = (double)*v162 + *(float *)(v87 + 4) - v166 - 1.0;
          sub_1008C2F0(*(float *)&v83, v89);
          sub_1008C2F0(v85, v89);
          j_gdi_pvg_end();
          j_gdi_pvg_color_u32(*(&dword_100EA148 + *(_BYTE *)v77 + v82 + 2 * *(_BYTE *)v77));
          v126 = *(float *)(a5 + 4);
          v125 = v164;
          v90 = v156 & 0x20000 ? sub_100650F0(v126) : sub_10065060(v126);
          sub_1008CE70(v90, (int)v77 - 31, v125, v136, v126);
          j_gdi_pvg_disable(35);
          ++v132;
          v136 = v136 + v155;
          if ( !*(_BYTE *)(v79 + 33) )
            sub_10074A80(*(_WORD *)((char *)v77 - 33));
        }
        v91 = v138;
        if ( v144 && v138 < 0x95u && !*(_BYTE *)(v79 + 32) && *(_BYTE *)(v79 + 70) )
        {
          v92 = v136 + 1.0;
          j_gdi_pvg_begin(64);
          v93 = sub_10065D00(-1);
          j_gdi_pvg_color_u32(v93);
          v94 = v162;
          v95 = (double)*v162 + 4.0;
          sub_1008C2F0(v95, v92);
          v96 = *(float *)(v157 + 4) + (double)*v94 - 4.0;
          sub_1008C2F0(v96, v92);
          j_gdi_pvg_end();
          v136 = v92 + 7.0;
        }
        v97 = *(_BYTE *)v77;
        if ( *(_BYTE *)v77 < (unsigned __int8)v149 && *(_WORD *)a5 > v152 && (!v97 && v138 >= v133 || v97 == 1) )
          v149 = *(_BYTE *)v77;
        if ( v97 < (unsigned __int8)v150 && v152 + v133 >= v165 + *(_WORD *)a5 && (!v97 || v97 == 1) )
          v150 = *(_BYTE *)v77;
        ++v152;
        v77 = (char *)v77 + 38;
        ++v138;
      }
      while ( (unsigned __int8)(v91 + 1) < v129 );
      v5 = v162;
      v76 = v133;
      v35 = v157;
    }
    if ( v156 & 4 && v129 > v143 && v133 < v143 )
    {
      if ( !v139 )
      {
        v168 = 5.0;
        v167 = 35;
        v169 = (double)(v165 - v76) * v155;
        v98 = *v5;
        v99 = *(float *)(v157 + 4);
        v171 = (signed int)(v155 * (double)v133 + v148 - 3.0);
        v100 = *(_BYTE *)(v157 + 12) == 0;
        v170 = (signed int)(v99 - 5.0 + (double)v98);
        if ( !v100 )
          --v170;
        v101 = v132 - v133;
        v102 = v129 - v133;
        v103 = *(_WORD *)a5;
        v160 = v132 - v133;
        v159 = v129 - v133;
        v161 = v103;
        if ( v144 )
        {
          ++v101;
          ++v102;
          v160 = v101;
          v159 = v102;
        }
        v153 = (v169 - 20.0) * (double)(unsigned __int16)v101 / (double)v102;
        v128 = (v169 - v153 - 20.0) * (double)v103 / (double)(v102 - (unsigned __int16)v101)
             + (double)((signed __int16)(signed int)(v155 * (double)v133 + v148 - 3.0) + 10);
        sub_10063CF0(v163, v142, (char *)&v167, (int)&v159);
        if ( v161 > 0 && (unsigned __int8)v149 <= 1u )
        {
          v104 = (double)v170 + 5.0;
          v105 = (double)(v171 + 10);
          v106 = (double)v170;
          sub_10064BF0(9, v106, v105, v104, v128, *(&dword_100EA148 + 3 * (unsigned __int8)v149));
        }
        if ( v161 < (signed int)v159 && (unsigned __int8)v150 <= 1u )
        {
          v107 = (double)v171 + v169 - 10.0;
          v108 = v107;
          v109 = (double)v170 + 5.0;
          v110 = v109;
          v111 = v128 + v153;
          v112 = (double)v170;
          sub_10064BF0(9, v112, v111, v110, v108, *(&dword_100EA148 + 3 * (unsigned __int8)v150));
        }
        goto LABEL_170;
      }
    }
    else if ( !v139 )
    {
      goto LABEL_170;
    }
    v113 = v154 - v155 - 1.0;
    j_gdi_pvg_begin(64);
    v114 = sub_10065D00(-1);
    j_gdi_pvg_color_u32(v114);
    v115 = v113 + 0.5;
    v116 = (double)*v5 + 4.0;
    sub_1008C2F0(v116, v115);
    v117 = (double)*v5 + *(float *)(v35 + 4) - 4.0;
    sub_1008C2F0(v117, v115);
    j_gdi_pvg_end();
    LODWORD(v127) = (unsigned __int16)v158;
    v137 = v113 + 3.0;
    if ( v145 )
    {
      v118 = sub_1006ED10(0x4E4u);
      sub_10064B00(&v173, 0x14u, "%s  %2d  %2d", v118, v146, v127);
    }
    else
    {
      sub_10064B00(&v173, 0x14u, "%2d  %2d", v146, (unsigned __int16)v158);
    }
    v119 = v172;
    v120 = (int)v172;
    *v172 = *(float *)(v35 + 4) * 0.5 + (double)*v5;
    v119[1] = v137;
    sub_10065670((int)&v173, v120);
LABEL_170:
    v121 = v140 && *(_WORD *)a5;
    v147 = v121;
    v122 = v140 && *(_WORD *)a5 < (unsigned __int16)v140;
    v100 = *(_BYTE *)(a5 + 8) == 0;
    LOBYTE(v158) = v122;
    if ( v100 )
    {
      sub_100522A0(v121);
      v124 = v158;
      sub_10052290(v158);
      sub_10065E00(v147);
      sub_10065DC0(v124);
    }
    else
    {
      v123 = v163;
      sub_10032270(v163, byte_101DEDE1, v121 == 0);
      sub_10032270(v123, byte_101DEDE0, v122 == 0);
    }
    return j_gdi_pvg_cmd_list_stop(0);
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008BF80: using guessed type int __cdecl j_gdi_pvg_cmd_list_execute(_DWORD);
// 1008BF90: using guessed type int __cdecl j_gdi_pvg_cmd_list_start(_DWORD, _DWORD);
// 1008BFA0: using guessed type int __cdecl j_gdi_pvg_cmd_list_stop(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100EA184: using guessed type int dword_100EA184[];
// 101DEDE0: using guessed type char byte_101DEDE0;
// 101DEDE1: using guessed type char byte_101DEDE1;
// 101DEE88: using guessed type __int16 word_101DEE88;
// 101DEF38: using guessed type __int16 word_101DEF38;
// 101DEF3C: using guessed type char byte_101DEF3C;
// 101DEF3E: using guessed type char byte_101DEF3E;
// 101DEF40: using guessed type __int16 word_101DEF40;
// 101DEF48: using guessed type __int16 word_101DEF48[];
// 102BA90E: using guessed type char byte_102BA90E;

//----- (10063AB0) --------------------------------------------------------
char __cdecl sub_10063AB0(int a1, int a2, _WORD *a3, int a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@6
  int v7; // esi@6

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_9;
  if ( *a5 == 32833 )
  {
    *(_DWORD *)&byte_101DEF3C = 0;
    word_101DEF40 = 0;
    _mkgmtime_0(0);
    sub_10062560(a4);
    v6 = sub_100027C0(a1, 36);
    v7 = v6;
    *(_DWORD *)(a4 + 12) = v6;
    *(_DWORD *)v6 = 0;
    *(_DWORD *)(v6 + 4) = 0;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)(v6 + 20) = -4144960;
    *(_DWORD *)(v6 + 8) = sub_10065060(*(float *)(a4 + 4));
    *(float *)(v7 + 24) = 0.5;
    result = 2;
    *(float *)(v7 + 28) = 0.0;
    *(float *)(v7 + 32) = 0.0;
    *(float *)(v7 + 12) = *(float *)(a4 + 4);
    return result;
  }
  if ( *a5 == 32888 )
  {
LABEL_9:
    sub_100627C0(a1, (int)a5, a2, a3, a4);
    result = 2;
  }
  return result;
}
// 101DEF3C: using guessed type char byte_101DEF3C;
// 101DEF40: using guessed type __int16 word_101DEF40;

//----- (10063B70) --------------------------------------------------------
_DWORD *__cdecl sub_10063B70(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10063B80) --------------------------------------------------------
int __cdecl sub_10063B80(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (10063BB0) --------------------------------------------------------
_DWORD *__cdecl sub_10063BB0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (10063BC0) --------------------------------------------------------
char __cdecl sub_10063BC0(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (10063BF0) --------------------------------------------------------
char __cdecl sub_10063BF0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (10063C20) --------------------------------------------------------
__int16 __cdecl sub_10063C20(unsigned int a1)
{
  return word_100EAD14[(a1 >> 17) & 0xF];
}
// 100EAD14: using guessed type __int16 word_100EAD14[];

//----- (10063C40) --------------------------------------------------------
bool __cdecl sub_10063C40(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_1031EB44[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (10063C90) --------------------------------------------------------
char __cdecl sub_10063C90(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_10063C40(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_10063C40(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (10063CF0) --------------------------------------------------------
int __cdecl sub_10063CF0(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_10063C40(a3, &v8, 0);
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_1031EB40[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (10063D60) --------------------------------------------------------
char __cdecl sub_10063D60(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10051A40("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_10063BF0(a1, v7, (int)v3);
    sub_10063C40(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012F0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_1031EB40[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (10063E10) --------------------------------------------------------
int __cdecl sub_10063E10(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_1006E440(&a1, 4u, (int)&unk_100EB358, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10051A40(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_100EB35C + 2 * v2);
}
// 100EB35C: using guessed type void *off_100EB35C;

//----- (10063E90) --------------------------------------------------------
char __cdecl sub_10063E90(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10063ED0) --------------------------------------------------------
char __cdecl sub_10063ED0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10051A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10063F40) --------------------------------------------------------
signed int __cdecl sub_10063F40(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10051A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10063FC0) --------------------------------------------------------
char __cdecl sub_10063FC0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10051A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10064030) --------------------------------------------------------
char __cdecl sub_10064030(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10051A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100640E0) --------------------------------------------------------
char __cdecl sub_100640E0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10051A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100641E0) --------------------------------------------------------
char __thiscall sub_100641E0(void *this)
{
  int v1; // eax@1

  v1 = sub_1006F3C0(this);
  return sub_100640E0(v1);
}

//----- (100641F0) --------------------------------------------------------
int __cdecl sub_100641F0(int *a1)
{
  int result; // eax@1

  result = sub_10076960((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_1008C780();
    result = sub_100721B0();
  }
  return result;
}

//----- (10064220) --------------------------------------------------------
char __usercall sub_10064220@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_1008C850(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_10077A20("%i %i\r\n", 13, v2);
    sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_1008C830(*(_DWORD *)(a1 + 4));
    v6 = sub_10077A20("%i %i\r\n", 14, v5);
    sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100EBDAC, (int)v6);
    result = 1;
  }
  else
  {
    sub_10051A40(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (100642C0) --------------------------------------------------------
int __cdecl sub_100642C0(const char *a1)
{
  int result; // eax@1

  result = sub_100704D0();
  if ( a1 )
    result = sub_10076990(dword_101E058C[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 101E058C: using guessed type int dword_101E058C[];

//----- (10064300) --------------------------------------------------------
char __cdecl sub_10064300(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_100768E0((char *)a1 + 4);
  v1 = sub_1007D340();
  sub_10072290((int)v1, 0, 0);
  dword_101E058C[sub_100704D0()] = (int)a1;
  v2 = sub_1007D300((int)sub_100642C0);
  return sub_100769B0(v2);
}
// 101E058C: using guessed type int dword_101E058C[];

//----- (10064350) --------------------------------------------------------
signed int __cdecl sub_10064350(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_1008C780();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_1008C900(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_1008C780() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_1008C990(&v23);
          }
          while ( sub_1008C780() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_1008C760(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_1008C7A0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_10077A20("The %s task is loaded.", &v24);
            sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_10077A20("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_10077A20("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_10077A20(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_1008C6F0(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_10077A20("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_10077A20("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10076FC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10076FC0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_1008C7E0(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1007D300((int)sub_100642C0);
        sub_10077090((int)v15);
        v16 = sub_1007E6E0((int)sub_100642C0);
        sub_10077090((int)v16);
        v17 = sub_1007E6E0((int)sub_100642C0);
        sub_100769B0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1007D300((int)sub_100642C0);
        sub_10077090((int)v18);
        v19 = sub_1007E6E0((int)sub_100642C0);
        sub_10077090((int)v19);
        v20 = sub_1007D300((int)sub_100642C0);
        sub_100769B0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10064220(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (100646F0) --------------------------------------------------------
char **sub_100646F0()
{
  return off_100EBD98;
}
// 100EBD98: using guessed type char *off_100EBD98[3];

//----- (10064710) --------------------------------------------------------
int __cdecl sub_10064710(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101E05A0 = a1;
  return result;
}
// 101E05A0: using guessed type int dword_101E05A0;

//----- (10064720) --------------------------------------------------------
int __cdecl sub_10064720(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101E05A4 = a1;
  return result;
}
// 101E05A4: using guessed type int dword_101E05A4;

//----- (10064730) --------------------------------------------------------
char __cdecl sub_10064730(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_100ECF98[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 100ECF98: using guessed type __int16 word_100ECF98[];

//----- (10064760) --------------------------------------------------------
bool __cdecl sub_10064760(float a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // esi@3
  int v6; // ecx@8
  unsigned int v7; // eax@9
  float v8; // ST14_4@10
  float v9; // ST14_4@10
  float v10; // ST14_4@10
  float v11; // ST14_4@10
  float v12; // ST14_4@10
  float v13; // ST14_4@10
  float v14; // ST14_4@10
  int v15; // eax@12
  float v16; // ST14_4@14
  signed int v17; // ebx@14
  bool result; // al@19
  int v19; // [sp+8h] [bp-8h]@5

  if ( a4 && (v4 = a3, a3 <= 9) && (v5 = a2, a2 > 0) && a3 <= a2 - 2 )
  {
    v19 = 0;
    if ( a1 < 0.0 )
    {
      v4 = a3 - 1;
      a1 = fabs(a1);
      *(_BYTE *)a4 = 45;
      v19 = 1;
      if ( a3 == 1 )
        v4 = -1;
    }
    v6 = 0;
    if ( v4 >= 8 )
    {
      v7 = ((unsigned int)(v4 - 8) >> 3) + 1;
      v6 = 8 * v7;
      do
      {
        --v7;
        v8 = a1 * 10.0;
        v9 = v8 * 10.0;
        v10 = v9 * 10.0;
        v11 = v10 * 10.0;
        v12 = v11 * 10.0;
        v13 = v12 * 10.0;
        v14 = v13 * 10.0;
        a1 = v14 * 10.0;
      }
      while ( v7 );
    }
    if ( v6 < v4 )
    {
      v15 = v4 - v6;
      do
      {
        --v15;
        a1 = a1 * 10.0;
      }
      while ( v15 );
    }
    v16 = a1 + 0.5;
    v17 = (signed int)v16;
    if ( a2 > v19 )
    {
      do
      {
        if ( --v5 == a2 - v4 - 1 )
        {
          *(_BYTE *)(v5 + a4) = 46;
        }
        else
        {
          *(_BYTE *)(v5 + a4) = v17 % 10 + 48;
          v17 /= 10;
        }
      }
      while ( v5 > v19 );
    }
    result = v17 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100648D0) --------------------------------------------------------
bool __cdecl sub_100648D0(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10064940) --------------------------------------------------------
void __cdecl sub_10064940(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (10064990) --------------------------------------------------------
void __cdecl sub_10064990(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (100649E0) --------------------------------------------------------
int __cdecl sub_100649E0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10064A30) --------------------------------------------------------
int __cdecl sub_10064A30(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10064A60) --------------------------------------------------------
int __cdecl sub_10064A60(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10064AC0) --------------------------------------------------------
int __cdecl sub_10064AC0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10064B00) --------------------------------------------------------
int sub_10064B00(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10064AC0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (10064B30) --------------------------------------------------------
int __cdecl sub_10064B30(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_100649E0((int)&a1[v3], a2, a3 - v3);
}

//----- (10064B70) --------------------------------------------------------
int __cdecl sub_10064B70(int a1, int a2)
{
  return sub_10064A60(a1, "_ ", a2);
}

//----- (10064B90) --------------------------------------------------------
signed int __cdecl sub_10064B90(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_100C7134;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 100C7134: using guessed type int (__cdecl *off_100C7134)(int);

//----- (10064BC0) --------------------------------------------------------
char *__cdecl sub_10064BC0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = byte_100B8180;
  else
    result = (char *)&unk_100C7139 + 56 * a1;
  return result;
}

//----- (10064BF0) --------------------------------------------------------
int __cdecl sub_10064BF0(int a1, float a2, float a3, float a4, float a5, int a6)
{
  float v6; // ST1C_4@1
  float v7; // ST18_4@1
  _DWORD *v8; // eax@1

  v6 = (a4 - a2) * 0.0625;
  v7 = 0.0625 * (a5 - a3);
  j_gdi_pvg_enable(34);
  j_gdi_pvg_color_u32(a6);
  v8 = (_DWORD *)sub_1008CC80(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 0.0);
  sub_1008C2F0(a2, a5);
  sub_1008C220(0.0, v7);
  sub_1008C2F0(a2, a3);
  sub_1008C220(v6, v7);
  sub_1008C2F0(a4, a3);
  sub_1008C220(v6, 0.0);
  sub_1008C2F0(a4, a5);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10064CF0) --------------------------------------------------------
int __cdecl sub_10064CF0(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char *v4; // edi@1
  float v5; // ST28_4@1
  float v6; // ST2C_4@1
  float v7; // ST30_4@1
  _DWORD *v8; // eax@1
  float v10; // [sp+28h] [bp+8h]@1

  v2 = sub_1008CC80(a1);
  v3 = a2;
  v2 += 4;
  v4 = (char *)&unk_100EDCD0 + 8 * *(_BYTE *)a2;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 20) * *(float *)(a2 + 12);
  v10 = *(float *)(a2 + 8) - *(float *)(a2 + 24) * *(float *)(a2 + 16);
  v6 = *(float *)(v3 + 12) + v5;
  v7 = *(float *)(v3 + 16) + v10;
  j_gdi_pvg_enable(34);
  sub_1008C280(84, 82, 79.0);
  v8 = (_DWORD *)sub_1008CC80(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_1008C220(*(float *)(v2 + 8 * (unsigned __int8)*v4), *(float *)(v2 + 8 * (unsigned __int8)v4[4] + 4));
  sub_1008C2F0(v5, v10);
  sub_1008C220(*(float *)(v2 + 8 * (unsigned __int8)v4[1]), *(float *)(v2 + 8 * (unsigned __int8)v4[5] + 4));
  sub_1008C2F0(v6, v10);
  sub_1008C220(*(float *)(v2 + 8 * (unsigned __int8)v4[2]), *(float *)(v2 + 8 * (unsigned __int8)v4[6] + 4));
  sub_1008C2F0(v6, v7);
  sub_1008C220(*(float *)(v2 + 8 * (unsigned __int8)v4[3]), *(float *)(v2 + 8 * (unsigned __int8)v4[7] + 4));
  sub_1008C2F0(v5, v7);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10064E50) --------------------------------------------------------
int __cdecl sub_10064E50(int a1, int a2)
{
  int v2; // eax@1
  float v3; // ST18_4@1
  float v4; // ST1C_4@1
  float v5; // ST20_4@1
  float v7; // [sp+1Ch] [bp+8h]@1

  v2 = a2;
  v3 = *(float *)(a2 + 4) - *(float *)(a2 + 20) * *(float *)(a2 + 12);
  v7 = *(float *)(a2 + 8) - *(float *)(a2 + 24) * *(float *)(a2 + 16);
  v4 = v3 + *(float *)(v2 + 12);
  v5 = v7 + *(float *)(v2 + 16);
  j_gdi_pvg_enable(34);
  sub_1008C280(84, 82, 79.0);
  j_gdi_pvg_bind_texture(34, a1);
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 1.0);
  sub_1008C2F0(v3, v7);
  sub_1008C220(1.0, 1.0);
  sub_1008C2F0(v4, v7);
  sub_1008C220(1.0, 0.0);
  sub_1008C2F0(v4, v5);
  sub_1008C220(0.0, 0.0);
  sub_1008C2F0(v3, v5);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10064F60) --------------------------------------------------------
void __cdecl sub_10064F60(float a1, char *a2, float a3, float a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // st7@1
  double v9; // st7@6

  v7 = (a7 << 6) + a6;
  v8 = sub_1006D0E0(SLODWORD(a1), a5, 1, (char *)&a7);
  sub_10064B00((char *)(v7 + 36), 7u, a2, v8 * a3);
  *(float *)(v7 + 20) = *(float *)v7;
  *(float *)(v7 + 24) = *(float *)(v7 + 8);
  if ( *(float *)(v7 + 4) <= (double)*(float *)v7 )
  {
    if ( *(float *)(v7 + 4) >= (double)*(float *)v7 )
    {
      if ( *(float *)(v7 + 12) <= (double)*(float *)(v7 + 8) )
      {
        *(float *)(v7 + 48) = 0.0;
        *(float *)(v7 + 44) = 0.5;
        v9 = *(float *)(v7 + 24) + 4.0;
      }
      else
      {
        *(float *)(v7 + 48) = 1.0;
        *(float *)(v7 + 44) = 0.5;
        v9 = *(float *)(v7 + 24) - 4.0;
      }
      *(float *)(v7 + 24) = v9;
    }
    else
    {
      *(float *)(v7 + 48) = 0.5;
      *(float *)(v7 + 44) = 0.0;
      *(float *)(v7 + 20) = *(float *)(v7 + 20) + 4.0;
    }
  }
  else
  {
    *(float *)(v7 + 48) = 0.5;
    *(float *)(v7 + 44) = 1.0;
    *(float *)(v7 + 20) = *(float *)(v7 + 20) - 4.0;
  }
  *(_DWORD *)(v7 + 28) = 0;
  *(float *)(v7 + 52) = a4;
  *(_DWORD *)(v7 + 32) = -1;
}

//----- (10065060) --------------------------------------------------------
int __cdecl sub_10065060(float a1)
{
  double v1; // st7@1
  signed int v2; // ecx@1
  int result; // eax@13

  v1 = a1;
  v2 = 6;
  if ( a1 > 0.0 )
    v2 = 0;
  if ( v1 > 8.0 )
    v2 = 1;
  if ( v1 > 10.0 )
    v2 = 2;
  if ( v1 > 12.5 )
    v2 = 3;
  if ( v1 > 14.0 )
    v2 = 4;
  if ( v1 > 16.0 )
    v2 = 6;
  result = 7;
  if ( v1 <= 20.0 )
    result = v2;
  return result;
}

//----- (100650F0) --------------------------------------------------------
int __cdecl sub_100650F0(float a1)
{
  signed int v1; // ecx@1
  int result; // eax@3

  v1 = 9;
  if ( a1 > 0.0 )
    v1 = 8;
  result = 9;
  if ( a1 <= 14.0 )
    result = v1;
  return result;
}

//----- (10065120) --------------------------------------------------------
double __cdecl sub_10065120(float a1, int a2, int a3)
{
  int v3; // edx@1
  double v4; // st7@1
  int v5; // edi@1
  int v6; // ecx@1
  char v7; // bl@2
  double v8; // st6@4
  double result; // st7@5
  signed int v10; // esi@8
  float *v11; // ecx@9
  int v12; // eax@15
  int v13; // ebx@16
  long double v14; // ST14_8@18
  float v15; // [sp+8h] [bp-10h]@2
  float v16; // [sp+10h] [bp-8h]@2
  float v17; // [sp+1Ch] [bp+4h]@15
  float v18; // [sp+1Ch] [bp+4h]@15
  int v19; // [sp+20h] [bp+8h]@2
  int v20; // [sp+24h] [bp+Ch]@2

  v3 = a3;
  v4 = 0.0;
  v5 = a2;
  v6 = a2 + 12 * a3;
  if ( *(float *)(a2 + 12 * a3 - 12) <= (double)*(float *)a2 )
  {
    v15 = *(float *)a2;
    v7 = 1;
    v16 = *(float *)(a2 + 4);
    v20 = *(int *)(v6 - 12);
    v19 = *(int *)(v6 - 8);
  }
  else
  {
    v20 = *(int *)a2;
    v7 = 0;
    v19 = *(int *)(a2 + 4);
    v15 = *(float *)(v6 - 12);
    v16 = *(float *)(v6 - 8);
  }
  v8 = a1;
  if ( *(float *)&v20 <= (double)a1 )
  {
    if ( v15 > v8 )
    {
      v10 = 1;
      if ( v3 > 1 )
      {
        v11 = (float *)(v5 + 12);
        while ( (*v11 <= v8 || v7) && (*v11 >= v8 || !v7) )
        {
          ++v10;
          v11 += 3;
          if ( v10 >= v3 )
            goto LABEL_15;
        }
        v13 = v5 + 12 * v10;
        if ( 1.0 == *(float *)(v13 + 8) )
        {
          v4 = (a1 - *(float *)(v13 - 12)) / (*(float *)v13 - *(float *)(v13 - 12));
        }
        else
        {
          v14 = pow(*(float *)(v13 - 12), *(float *)(v13 + 8));
          v4 = (pow(a1, *(float *)(v13 + 8)) - v14) / (pow(*(float *)v13, *(float *)(v13 + 8)) - v14);
        }
      }
LABEL_15:
      v12 = v5 + 12 * v10;
      v17 = v4 * (*(float *)(v5 + 12 * v10 + 4) - *(float *)(v12 - 8));
      v18 = v17 + *(float *)(v12 - 8);
      result = v18;
    }
    else
    {
      result = v16;
    }
  }
  else
  {
    result = *(float *)&v19;
  }
  return result;
}

//----- (10065280) --------------------------------------------------------
int __cdecl sub_10065280(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_10063C40(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_10063BC0(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_10063BF0(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_1031EB40[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_10063C40(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 1008C0E0: using guessed type int j_gdi_pvg_flush(void);
// 1031EB40: using guessed type int dword_1031EB40[];

//----- (100653C0) --------------------------------------------------------
int __cdecl sub_100653C0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_10065280(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (10065400) --------------------------------------------------------
void __usercall sub_10065400(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_1008D010(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( LOBYTE(a4) )
  {
    v11 = sub_10095740(v11, 1.0) + 0.5;
    v12 = sub_10095970(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (10065550) --------------------------------------------------------
void *sub_10065550()
{
  void *result; // eax@1

  result = (void *)dword_101E05A0;
  if ( !dword_101E05A0 )
    result = &unk_100EDCB0;
  return result;
}
// 101E05A0: using guessed type int dword_101E05A0;

//----- (10065560) --------------------------------------------------------
int __usercall sub_10065560@<eax>(int a1@<edi>, int a2@<esi>, char a3)
{
  float v3; // ST18_4@1
  float v5; // [sp+Ch] [bp-8h]@1
  float v6; // [sp+10h] [bp-4h]@1

  v3 = sub_1008D010(*(_DWORD *)(a2 + 8) & 0x3FFFFFFF, a1, *(float *)(a2 + 12));
  v6 = *(float *)a2 - *(float *)(a2 + 24) * v3;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 28) * *(float *)(a2 + 12);
  if ( a3 )
  {
    v6 = sub_10095740(v6, 1.0) + 0.5;
    v5 = sub_10095970(v5, 1.0);
  }
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 20));
  sub_1008CE70(*(_DWORD *)(a2 + 8), a1, v6, v5, *(float *)(a2 + 12));
  return j_gdi_pvg_disable(35);
}
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10065630) --------------------------------------------------------
void __cdecl sub_10065630(int a1, int a2, int a3)
{
  sub_10065400(a2, a1, a3, COERCE_FLOAT(1));
}

//----- (10065650) --------------------------------------------------------
int __cdecl sub_10065650(int a1, int a2)
{
  return sub_10065560(a1, a2, 0);
}

//----- (10065670) --------------------------------------------------------
int __cdecl sub_10065670(int a1, int a2)
{
  return sub_10065560(a1, a2, 1);
}

//----- (10065690) --------------------------------------------------------
void __cdecl sub_10065690(float a1, float a2, float a3, int a4, int a5, int a6)
{
  int v6; // esi@2
  double v7; // ST14_8@2
  double v8; // st7@2

  if ( *(_BYTE *)(a6 + 16) == 1 )
  {
    *(float *)((a5 << 6) + a4) = *(float *)a6;
    v6 = (a5 << 6) + a4;
    v7 = *(float *)(a6 + 4);
    *(float *)(v6 + 8) = v7 - sub_10065120(a1, a6 + 20, *(_BYTE *)(a6 + 116));
    *(float *)(v6 + 4) = *(float *)(a6 + 8) * a2 + *(float *)v6;
    v8 = *(float *)(v6 + 8);
  }
  else
  {
    v6 = (a5 << 6) + a4;
    *(float *)v6 = sub_10065120(a1, a6 + 20, *(_BYTE *)(a6 + 116)) + *(float *)a6;
    *(float *)(v6 + 8) = *(float *)(a6 + 4);
    *(float *)(v6 + 4) = *(float *)v6;
    v8 = *(float *)(v6 + 8) - *(float *)(a6 + 12) * a2;
  }
  *(float *)(v6 + 12) = v8;
  *(float *)(v6 + 16) = a3;
  *(_DWORD *)(v6 + 56) = -1;
  *(_BYTE *)(v6 + 60) = 0;
}

//----- (10065750) --------------------------------------------------------
int __cdecl sub_10065750(unsigned __int8 a1)
{
  if ( a1 >= 2u )
    sub_10051A40("..\\lib\\adl\\cdp_fld_3d_utl.c", 1492, 1, 0);
  return *((_DWORD *)sub_10065550() + a1 + 4);
}

//----- (10065780) --------------------------------------------------------
void __cdecl sub_10065780(float a1, float a2, float a3, float a4, char a5)
{
  void *v5; // ebp@3
  void *v6; // ecx@5
  void *v7; // ecx@5
  float v8; // ST28_4@5
  float v9; // ST2C_4@5
  double v10; // st7@5
  float v11; // ST28_4@7
  float v12; // ST2C_4@7
  float v13; // ST28_4@7
  float v14; // [sp+1Ch] [bp-44h]@5
  char v15; // [sp+20h] [bp-40h]@5
  float v16; // [sp+30h] [bp-30h]@5
  float v17; // [sp+34h] [bp-2Ch]@5
  float v18; // [sp+38h] [bp-28h]@5

  if ( a3 != a1 && a4 != a2 )
  {
    v5 = sub_10065550();
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(38);
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    if ( (unsigned __int8)a5 >= 2u )
      sub_10051A40("..\\lib\\adl\\cdp_fld_3d_utl.c", 1596, 1, 0);
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5));
    j_gdi_pvg_begin(72);
    sub_1008C2F0(a1, a2);
    sub_1008C2F0(a3, a2);
    sub_1008C2F0(a3, a4);
    sub_1008C2F0(a1, a4);
    j_gdi_pvg_end();
    j_gdi_pvg_read_matrix(&v15, 4, 4, 0);
    v8 = (double)((unsigned int)sub_100521B0(v6) >> 1);
    v9 = (double)((unsigned int)sub_10052190(v7) >> 1);
    v14 = sqrt(v9 * (v9 * v16 * v16) + v8 * (v8 * v17 * v17) + v18 * v18 * 0.5);
    v10 = 0.0;
    if ( v14 != 0.0 )
      v10 = *((float *)v5 + 7) * 0.5 / v14;
    v11 = v10;
    sub_1008C110(*((float *)v5 + 7));
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5 + 2));
    j_gdi_pvg_begin(64);
    v12 = v11 + a2;
    sub_1008C2F0(a1, v12);
    v13 = a4 - v11;
    sub_1008C2F0(a3, v13);
    sub_1008C2F0(a3, v12);
    sub_1008C2F0(a1, v13);
    j_gdi_pvg_end();
    sub_1008C110(1.0);
    j_gdi_pvg_pop_attrib();
  }
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 1008C1A0: using guessed type int j_gdi_pvg_pop_attrib(void);
// 1008C1C0: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);
// 1008C1E0: using guessed type int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100659D0) --------------------------------------------------------
void __cdecl sub_100659D0(float a1, float a2, float a3, float a4, float a5, float a6, char a7)
{
  double v7; // st6@1
  double v8; // st4@1
  float v9; // ST0C_4@1
  float v10; // ST08_4@1
  float v11; // ST04_4@1
  float v12; // [sp+24h] [bp+10h]@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1

  v7 = a4 * a6;
  v8 = a3 * a5;
  v12 = a4 + a2 - v7;
  v9 = v12;
  v13 = a3 + a1 - v8;
  v10 = v13;
  v14 = a2 - v7;
  v11 = v14;
  v15 = a1 - v8;
  sub_10065780(v15, v11, v10, v9, a7);
}

//----- (10065A50) --------------------------------------------------------
int __usercall sub_10065A50@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1

  v4 = a4;
  v5 = a2;
  sub_10065400(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_1008C2F0(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_1008C2F0(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_1008C2F0(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_1008C2F0(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end();
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_1008CE70(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10065B30) --------------------------------------------------------
int __cdecl sub_10065B30(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 0;
  return sub_10065A50(v3, a3, a2, a1);
}

//----- (10065B50) --------------------------------------------------------
int __cdecl sub_10065B50(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 1;
  return sub_10065A50(v3, a3, a2, a1);
}

//----- (10065B70) --------------------------------------------------------
int __cdecl sub_10065B70(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_102BA90E || byte_1031EB20) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_10065B50(a1, a2, (int)&v5);
}
// 102BA90E: using guessed type char byte_102BA90E;
// 1031EB20: using guessed type char byte_1031EB20;

//----- (10065BE0) --------------------------------------------------------
_BYTE *__cdecl sub_10065BE0(int a1, int a2, char a3)
{
  _BYTE *result; // eax@2
  char v4; // cl@2

  if ( !a3 || (result = sub_10065550(), result[24] == v4) )
    result = (_BYTE *)sub_10065650(a1, a2);
  return result;
}

//----- (10065C10) --------------------------------------------------------
int __cdecl sub_10065C10(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_100EF808, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100EF80C[2 * v1];
  }
  else
  {
    sub_10051A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100EF80C: using guessed type int dword_100EF80C[];

//----- (10065C60) --------------------------------------------------------
char __cdecl sub_10065C60(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1006E440(&a1, 1u, (int)&unk_100EF468, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10051A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100EF46C[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100EF46C: using guessed type int dword_100EF46C[];

//----- (10065CD0) --------------------------------------------------------
char __cdecl sub_10065CD0(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_1008D070(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10065D00) --------------------------------------------------------
signed int __cdecl sub_10065D00(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_1008D070(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (10065D40) --------------------------------------------------------
bool __cdecl sub_10065D40(char a1, _BYTE *a2)
{
  int v2; // eax@3
  float v4; // [sp+0h] [bp-144h]@3
  char v5; // [sp+140h] [bp-4h]@7

  if ( a1 == 1 )
  {
    v2 = sub_1008CA60(6266, (int)&v4, 324);
  }
  else if ( a1 == 2 )
  {
    v2 = sub_1008CA60(6267, (int)&v4, 324);
  }
  else
  {
    v2 = sub_1008CA60(6265, (int)&v4, 324);
  }
  *a2 = 0;
  if ( !v2 && (!v5 || v5 == 1 && 0.0 == v4) )
    *a2 = 1;
  return v2 == 0;
}

//----- (10065DC0) --------------------------------------------------------
int __cdecl sub_10065DC0(char a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int result; // eax@3

  v2 = sub_10051DA0(v1) - 1;
  if ( v2 && v2 != 3 )
    result = sub_1008CB30(41029, (int)&a1, 1);
  else
    result = sub_1008CB30(41028, (int)&a1, 1);
  return result;
}

//----- (10065E00) --------------------------------------------------------
int __cdecl sub_10065E00(char a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int result; // eax@3

  v2 = sub_10051DA0(v1) - 1;
  if ( v2 && v2 != 3 )
    result = sub_1008CB30(41027, (int)&a1, 1);
  else
    result = sub_1008CB30(41026, (int)&a1, 1);
  return result;
}

//----- (10065E40) --------------------------------------------------------
double sub_10065E40()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1008CAC0(10002, &v2, 4, &v1);
  return v2;
}

//----- (10065E70) --------------------------------------------------------
void __usercall sub_10065E70(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (10065FE0) --------------------------------------------------------
char __usercall sub_10065FE0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_1008CAC0(6117, v12, 16, &v8) )
    sub_10051A40("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_100727A0(1, 0x50u, &v5);
  if ( sub_1008CB00(6354, (int)&v7, 4) )
    sub_10051A40("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_1006C420(a2) || v5) && sub_10066790(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10065FE0: using guessed type float var_10[4];

//----- (100660D0) --------------------------------------------------------
char __usercall sub_100660D0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_1006C420(*v5) )
        {
          ++v8;
          if ( sub_10066930((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_1008CA60(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_1008CA60(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_1008CA60(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10051A40("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_1006C420(*v12) )
        {
          ++v8;
          if ( sub_10066790(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10065E70(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (100663B0) --------------------------------------------------------
char __cdecl sub_100663B0(float *a1)
{
  return sub_10066790(4u, a1);
}

//----- (100663C0) --------------------------------------------------------
void __cdecl sub_100663C0(int a1)
{
  JUMPOUT(&loc_10065FD0);
}

//----- (100663D0) --------------------------------------------------------
char __cdecl sub_100663D0(float *a1)
{
  return sub_10065FE0(a1, 0x14u, 0);
}

//----- (100663F0) --------------------------------------------------------
char __cdecl sub_100663F0(float *a1)
{
  return sub_10065FE0(a1, 0x2Du, 1u);
}

//----- (10066410) --------------------------------------------------------
char __cdecl sub_10066410(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_100663D0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100663F0(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (100664A0) --------------------------------------------------------
char __cdecl sub_100664A0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1008CA60(6265, (int)&v2, 324) )
  {
    sub_10051A40("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100660D0(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 100F0F20: using guessed type wchar_t a__[6];

//----- (10066510) --------------------------------------------------------
char __cdecl sub_10066510(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1008CA60(6267, (int)&v2, 324) )
  {
    sub_10051A40("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100660D0(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 100F0F48: using guessed type wchar_t aAbcde[6];

//----- (10066580) --------------------------------------------------------
double sub_10066580()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_1008CAC0(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10065E40();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (100665E0) --------------------------------------------------------
double __cdecl sub_100665E0(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_10095740(a1, a4);
  *(float *)&v16 = sub_100956A0(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (100666C0) --------------------------------------------------------
int __cdecl sub_100666C0(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1

  v2 = *(_DWORD *)(a1 + 4);
  result = v2 + (((a2 - v2) * (unsigned __int64)*(_DWORD *)a1 + 0x80000000) >> 32);
  *(_DWORD *)(a1 + 4) = result;
  if ( v2 == result && v2 != a2 )
  {
    if ( v2 <= a2 )
      *(_DWORD *)(a1 + 4) = ++result;
    else
      *(_DWORD *)(a1 + 4) = --result;
  }
  return result;
}

//----- (10066720) --------------------------------------------------------
int __cdecl sub_10066720(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (10066730) --------------------------------------------------------
int __cdecl sub_10066730(int a1, int a2, float a3, float a4)
{
  *(_DWORD *)a1 = (signed __int64)((1.0 - exp(-a4 / a3)) * 4294967296.0);
  return sub_10066720(a1, a2);
}

//----- (10066790) --------------------------------------------------------
char __cdecl sub_10066790(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10080E20(a1, v4, &v6) == 1 )
  {
    v2 = sub_10072410(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_100730B0(v4[0], v6, &v5) && !sub_10080A20((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100668B0) --------------------------------------------------------
void sub_100668B0()
{
  dword_101E05B0 = -15;
}
// 101E05B0: using guessed type int dword_101E05B0;

//----- (100668C0) --------------------------------------------------------
double __cdecl sub_100668C0(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10066920) --------------------------------------------------------
signed int sub_10066920()
{
  return sub_1008D490((int)&off_100F1798);
}
// 100F1798: using guessed type char *off_100F1798;

//----- (10066930) --------------------------------------------------------
char __usercall sub_10066930@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_1008CA60(6091, (int)&v23, 16) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_1008CA60(6115, (int)&v25, 16) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_1008CA60(6090, (int)&v31, 40) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_1008CA60(6114, (int)&v27, 40) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_1008CA60(6092, (int)&v29, 40) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_1008CA60(6116, (int)&v33, 40) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_1008CAC0(6355, &v22, 4, &v19) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_1008D070(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_1008CAC0(6356, &v21, 4, &v19) )
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_1008D070(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_1008CA60(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_1008CA60(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_1008CA60(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_1008CA60(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_10066790(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_100668C0(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 10066930: using guessed type int var_AC[3];
// 10066930: using guessed type int var_BC[3];
// 10066930: using guessed type float var_22C[76];
// 10066930: using guessed type float var_27C[19];

//----- (10066E70) --------------------------------------------------------
char __cdecl sub_10066E70(unsigned __int8 a1, _DWORD *a2)
{
  char result; // al@3

  if ( a1 >= 4u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 795, 0, 0);
    return 0;
  }
  if ( (unsigned __int8)sub_10066920() != 1 )
    return 0;
  if ( *(_DWORD *)(dword_101E05B0 + 4 * a1 + 696) + 4000 <= (unsigned int)sub_1008C780() )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(dword_101E05B0 + 4 * a1 + 228);
    result = 1;
  }
  return result;
}
// 101E05B0: using guessed type int dword_101E05B0;

//----- (10066EE0) --------------------------------------------------------
char __cdecl sub_10066EE0(int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // eax@1
  int v5; // ecx@1
  float *v6; // edx@3
  char result; // al@7
  char v8; // [sp+7h] [bp-5h]@1
  float v9; // [sp+8h] [bp-4h]@1
  char v10; // [sp+14h] [bp+8h]@2

  v9 = -9.8999998e24;
  v3 = a2;
  v4 = a2;
  v5 = a2 + a3;
  v8 = 0;
  if ( a2 >= v5 )
  {
    result = 0;
  }
  else
  {
    v10 = 0;
    do
    {
      v6 = (float *)(a1 + 12 * v4 + 8);
      if ( 9.8999998e24 != *v6 && v9 + 0.05000000074505806 < *v6 )
      {
        v9 = *v6;
        v8 = v10;
      }
      ++v10;
      v4 = ++v3;
    }
    while ( v3 < v5 );
    result = v8;
  }
  return result;
}

//----- (10066F80) --------------------------------------------------------
bool __cdecl sub_10066F80(unsigned __int16 a1, _BYTE *a2, unsigned __int8 a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10080E80(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10072410(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_100730B0(v5[0], v6, a2) && !sub_100809D0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10067000) --------------------------------------------------------
bool __cdecl sub_10067000(unsigned __int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  bool v3; // ST0C_1@1

  v3 = sub_10076320(v2) != 0;
  return sub_10066F80(a1, a2, v3);
}

//----- (10067030) --------------------------------------------------------
int __cdecl sub_10067030(int a1)
{
  int v1; // ST0C_4@2
  int v2; // ST0C_4@3
  float *v3; // ebp@5
  float *v4; // ebx@5
  float *v5; // edi@5
  int v6; // esi@5
  double v7; // st7@6
  int v8; // esi@6
  float v9; // ST04_4@6
  float *v10; // edi@6
  float *v11; // ebx@6
  float *v12; // ebp@6
  _DWORD *v14; // [sp+18h] [bp-8h]@5
  int v15; // [sp+1Ch] [bp-4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  if ( *(_BYTE *)(a1 + 1756) )
  {
    v1 = *(_DWORD *)sub_1008CC80(0x34u);
    j_gdi_pvg_bind_texture(34, v1);
  }
  else
  {
    v2 = *(_DWORD *)sub_1008CC80(0x33u);
    j_gdi_pvg_bind_texture(34, v2);
  }
  sub_1008C280(84, 82, 79.0);
  j_gdi_pvg_begin(68);
  v15 = 0;
  if ( *(_DWORD *)(a1 + 1348) > 0 )
  {
    v3 = (float *)(a1 + 204);
    v4 = (float *)(a1 + 208);
    v5 = (float *)(a1 + 732);
    v6 = a1 + 736;
    v14 = (_DWORD *)(a1 + 1260);
    do
    {
      j_gdi_pvg_color_u32(*v14);
      sub_1008C220(*v5, *(float *)v6);
      sub_1008C2F0(*v3, *v4);
      v7 = *(float *)(v6 + 8);
      v8 = v6 + 8;
      v9 = v7;
      v10 = v5 + 2;
      v11 = v4 + 2;
      v12 = v3 + 2;
      sub_1008C220(*v10, v9);
      sub_1008C2F0(*v12, *v11);
      v10 += 2;
      v11 += 2;
      v12 += 2;
      sub_1008C220(*v10, *(float *)(v8 + 8));
      sub_1008C2F0(*v12, *v11);
      ++v14;
      v6 = v8 + 16;
      v5 = v10 + 2;
      v4 = v11 + 2;
      v3 = v12 + 2;
      ++v15;
    }
    while ( v15 < *(_DWORD *)(a1 + 1348) );
  }
  j_gdi_pvg_end();
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100671C0) --------------------------------------------------------
int __cdecl sub_100671C0(int a1)
{
  int v1; // esi@1
  float v2; // ST48_4@1
  float v3; // ST4C_4@1
  float v4; // ST4C_4@1
  float v5; // ST24_4@1
  double v6; // st6@1
  float v7; // ST20_4@1
  float v8; // ST30_4@1
  float v9; // ST28_4@1
  float v10; // ST3C_4@1
  float v11; // ST38_4@1
  float v12; // ST1C_4@1
  float v13; // ST34_4@1
  float v14; // ST2C_4@1
  float v15; // ST40_4@1
  float v16; // ST44_4@1
  float v17; // ST48_4@1
  float v18; // ST4C_4@1
  float v19; // ST50_4@1
  float v20; // ST14_4@1
  float v21; // ST50_4@1
  float v22; // ST50_4@1
  float v23; // ST14_4@1
  float v24; // ST50_4@1
  float v25; // ST20_4@1
  float v26; // ST24_4@1
  float v27; // ST2C_4@1
  float v28; // ST34_4@1
  float v29; // ST50_4@1
  float v30; // ST14_4@1
  float v31; // ST50_4@1
  float v32; // ST14_4@1
  float v34; // [sp+48h] [bp+4h]@1
  float v35; // [sp+48h] [bp+4h]@1
  float v36; // [sp+48h] [bp+4h]@1
  float v37; // [sp+48h] [bp+4h]@1
  float v38; // [sp+48h] [bp+4h]@1
  float v39; // [sp+48h] [bp+4h]@1

  v1 = a1;
  v2 = *(float *)(a1 + 20) / *(float *)(a1 + 8);
  v34 = *(float *)(a1 + 24) * 0.01745329238474369;
  v3 = cos(v34);
  v4 = v3 * *(float *)(v1 + 8);
  v35 = sin(v34);
  v36 = v35 * *(float *)(v1 + 8);
  v5 = *(float *)(v1 + 12) * v4 + *(float *)v1;
  v6 = v36;
  v7 = *(float *)(v1 + 12) * v36 + *(float *)(v1 + 4);
  v8 = v4 * *(float *)(v1 + 16) + *(float *)v1;
  v9 = v36 * *(float *)(v1 + 16) + *(float *)(v1 + 4);
  v10 = *(float *)v1 + v4;
  v11 = *(float *)(v1 + 4) + v36;
  v12 = v36 * 0.1500000059604645 * v2;
  v37 = -(0.1500000059604645 * v4 * v2);
  v13 = v6 * 0.5 * v2;
  v14 = -(v2 * (0.5 * v4));
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 28));
  j_gdi_pvg_begin(71);
  sub_1008C2F0(v10, v11);
  v15 = v14 + v9;
  v16 = v13 + v8;
  sub_1008C2F0(v16, v15);
  v17 = v37 + v7;
  v18 = v12 + v5;
  sub_1008C2F0(v18, v17);
  v19 = *(float *)(v1 + 4) + v37;
  v20 = v19;
  v21 = *(float *)v1 + v12;
  sub_1008C2F0(v21, v20);
  v22 = *(float *)(v1 + 4) - v37;
  v23 = v22;
  v24 = *(float *)v1 - v12;
  sub_1008C2F0(v24, v23);
  v25 = v7 - v37;
  v26 = v5 - v12;
  sub_1008C2F0(v26, v25);
  v27 = v9 - v14;
  v28 = v8 - v13;
  sub_1008C2F0(v28, v27);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_color_u32(-16777216);
  j_gdi_pvg_begin(66);
  sub_1008C2F0(v10, v11);
  sub_1008C2F0(v16, v15);
  sub_1008C2F0(v18, v17);
  v29 = *(float *)(v1 + 4) + v37;
  v30 = v29;
  v31 = *(float *)v1 + v12;
  sub_1008C2F0(v31, v30);
  v38 = *(float *)(v1 + 4) - v37;
  v32 = v38;
  v39 = *(float *)v1 - v12;
  sub_1008C2F0(v39, v32);
  sub_1008C2F0(v26, v25);
  sub_1008C2F0(v28, v27);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100674D0) --------------------------------------------------------
int __cdecl sub_100674D0(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  unsigned int v3; // edi@1
  float v4; // ST10_4@1
  float v5; // ST10_4@1
  float v6; // ST10_4@1
  unsigned int v8; // [sp+14h] [bp+4h]@1
  float v9; // [sp+14h] [bp+4h]@1
  float v10; // [sp+14h] [bp+4h]@1
  float v11; // [sp+14h] [bp+4h]@1
  float v12; // [sp+14h] [bp+4h]@1
  float v13; // [sp+14h] [bp+4h]@1
  float v14; // [sp+14h] [bp+4h]@1
  float v15; // [sp+14h] [bp+4h]@1
  float v16; // [sp+14h] [bp+4h]@1
  float v17; // [sp+14h] [bp+4h]@1
  float v18; // [sp+14h] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v8 = *(_DWORD *)(a1 + 16);
  v2 = v8;
  BYTE1(v8) >>= 1;
  LOBYTE(v8) = (unsigned __int8)v8 >> 1;
  BYTE2(v8) = (unsigned __int8)(v2 >> 16) >> 1;
  j_gdi_pvg_begin(73);
  v3 = v8;
  j_gdi_pvg_color_u32(v8);
  sub_1008C2F0(*(float *)v1, *(float *)(v1 + 4));
  v9 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_1008C2F0(*(float *)v1, v9);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v10 = *(float *)(v1 + 8) * 0.25 + *(float *)v1;
  sub_1008C2F0(v10, *(float *)(v1 + 4));
  v11 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v4 = v11;
  v12 = *(float *)(v1 + 8) * 0.25 + *(float *)v1;
  sub_1008C2F0(v12, v4);
  v13 = *(float *)(v1 + 8) * 0.75 + *(float *)v1;
  sub_1008C2F0(v13, *(float *)(v1 + 4));
  v14 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v5 = v14;
  v15 = *(float *)(v1 + 8) * 0.75 + *(float *)v1;
  sub_1008C2F0(v15, v5);
  j_gdi_pvg_color_u32(v3);
  v16 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v16, *(float *)(v1 + 4));
  v17 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v6 = v17;
  v18 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v18, v6);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10067650) --------------------------------------------------------
int __cdecl sub_10067650(float a1, float a2, float a3, float a4, char a5, int a6)
{
  double v6; // st7@4
  char v8; // [sp+0h] [bp-1Ch]@4
  float v9; // [sp+4h] [bp-18h]@1
  float v10; // [sp+8h] [bp-14h]@1
  float v11; // [sp+Ch] [bp-10h]@1
  float v12; // [sp+10h] [bp-Ch]@1
  float v13; // [sp+14h] [bp-8h]@4
  float v14; // [sp+18h] [bp-4h]@8

  v12 = a4;
  v11 = a3;
  v9 = a1;
  v10 = a2;
  if ( a5 )
  {
    if ( a5 == 2 )
    {
      v8 = 3;
      v13 = 1.0;
      v6 = 0.5;
    }
    else if ( a5 == 3 )
    {
      v8 = 1;
      v13 = 0.0;
      v6 = 0.5;
    }
    else
    {
      v8 = 2;
      v13 = 0.5;
      v6 = 0.0;
    }
  }
  else
  {
    v8 = 0;
    v13 = 0.5;
    v6 = 1.0;
  }
  v14 = v6;
  j_gdi_pvg_color_u32(a6);
  j_gdi_pvg_enable(35);
  sub_10064CF0(4u, (int)&v8);
  return j_gdi_pvg_disable(35);
}
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10067700) --------------------------------------------------------
int __cdecl sub_10067700(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  double v3; // st7@2
  int v4; // edi@4
  float v5; // ST18_4@4
  float v6; // ST18_4@4
  float v7; // ST18_4@4
  float v8; // ST0C_4@4
  float v9; // ST18_4@4
  float v10; // ST18_4@4
  float v11; // ST18_4@4
  float v12; // ST0C_4@4
  float v13; // ST18_4@4
  float v14; // ST18_4@4
  float v15; // ST0C_4@4
  float v16; // ST18_4@4
  float v17; // ST18_4@4
  float v18; // ST18_4@4
  float v19; // ST0C_4@4
  float v20; // ST18_4@4
  float v21; // ST18_4@4
  float v22; // ST0C_4@4
  float v23; // ST18_4@4
  float v24; // ST18_4@4
  float v25; // ST0C_4@4
  float v26; // ST18_4@4
  float v27; // ST18_4@4
  float v28; // ST0C_4@4
  float v29; // ST18_4@4
  float v30; // ST18_4@4
  float v31; // ST0C_4@4
  float v32; // ST18_4@4
  float v33; // ST18_4@4
  float v34; // ST0C_4@4
  float v35; // ST18_4@4
  float v36; // ST18_4@4
  float v37; // ST0C_4@4
  float v38; // ST18_4@4
  int v40; // [sp+10h] [bp-4h]@1
  float v41; // [sp+18h] [bp+4h]@4
  float v42; // [sp+18h] [bp+4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 16);
  v40 = *(_DWORD *)(a1 + 16);
  BYTE1(v40) >>= 1;
  LOBYTE(v40) = (unsigned __int8)v2 >> 1;
  BYTE2(v40) = (unsigned __int8)(v2 >> 16) >> 1;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) > (double)*(float *)(a1 + 12) )
    v3 = 0.0;
  else
    v3 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) - *(float *)(a1 + 12);
  v41 = v3;
  j_gdi_pvg_begin(73);
  v4 = v40;
  j_gdi_pvg_color_u32(v40);
  sub_1008C2F0(*(float *)v1, *(float *)(v1 + 4));
  v5 = *(float *)(v1 + 4) + v41;
  sub_1008C2F0(*(float *)v1, v5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v6 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v6, *(float *)(v1 + 4));
  v7 = *(float *)(v1 + 4) + v41;
  v8 = v7;
  v9 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v9, v8);
  j_gdi_pvg_color_u32(v4);
  v10 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v10, *(float *)(v1 + 4));
  v11 = *(float *)(v1 + 4) + v41;
  v12 = v11;
  v13 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v13, v12);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  v14 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v15 = v14;
  v16 = *(float *)v1 - *(float *)(v1 + 8);
  sub_1008C2F0(v16, v15);
  v17 = *(float *)(v1 + 4) + v41;
  sub_1008C2F0(*(float *)v1, v17);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v18 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v19 = v18;
  v20 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v20, v19);
  v21 = *(float *)(v1 + 4) + v41;
  v22 = v21;
  v23 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v23, v22);
  j_gdi_pvg_color_u32(v4);
  v24 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v25 = v24;
  v26 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v26, v25);
  v27 = *(float *)(v1 + 4) + v41;
  v28 = v27;
  v29 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v29, v28);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_1008C110(2.0);
  v30 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v31 = v30;
  v32 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v32, v31);
  v33 = *(float *)(v1 + 4) + v41;
  v34 = v33;
  v35 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v35, v34);
  sub_1008C110(1.0);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_1008C110(2.0);
  v36 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v37 = v36;
  v38 = *(float *)v1 - *(float *)(v1 + 8);
  sub_1008C2F0(v38, v37);
  v42 = *(float *)(v1 + 4) + v41;
  sub_1008C2F0(*(float *)v1, v42);
  sub_1008C110(1.0);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10067A90) --------------------------------------------------------
int __cdecl sub_10067A90(float a1, float a2, float a3, float a4, int a5, int a6)
{
  int v6; // esi@1
  unsigned int v7; // eax@1
  double v8; // ST18_8@1
  double v9; // ST20_8@1
  float v11; // [sp+28h] [bp+Ch]@1
  float v12; // [sp+2Ch] [bp+10h]@1
  int v13; // [sp+30h] [bp+14h]@1

  v6 = a5;
  v7 = (unsigned int)a5 >> 16;
  BYTE1(a5) >>= 1;
  LOBYTE(a5) = (unsigned __int8)a5 >> 1;
  BYTE2(a5) = (unsigned __int8)v7 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(v6);
  j_gdi_pvg_begin(71);
  sub_1008C2F0(a1, a2);
  j_gdi_pvg_color_u32(a5);
  v8 = a3 * 0.5;
  *(float *)&v13 = a1 - v8;
  sub_1008C2F0(*(float *)&v13, a2);
  v9 = a4 * 0.5;
  v11 = a2 - v9;
  sub_1008C2F0(a1, v11);
  v12 = a1 + v8;
  sub_1008C2F0(v12, a2);
  *(float *)&v8 = a2 + v9;
  sub_1008C2F0(a1, *(float *)&v8);
  sub_1008C2F0(*(float *)&v13, a2);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  sub_1008C110(1.0);
  j_gdi_pvg_color_u32(a6);
  j_gdi_pvg_begin(66);
  sub_1008C2F0(*(float *)&v13, a2);
  sub_1008C2F0(a1, v11);
  sub_1008C2F0(v12, a2);
  sub_1008C2F0(a1, *(float *)&v8);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10067C30) --------------------------------------------------------
int __cdecl sub_10067C30(float a1, float a2, float a3, float a4, float a5, float a6, int a7)
{
  double v7; // st7@1
  double v8; // st6@1
  float v9; // ST20_4@3
  double v10; // st7@3
  float v11; // ST20_4@3
  signed int v12; // edi@3
  signed int v13; // esi@5
  int i; // ebx@5
  signed int j; // esi@10
  float v16; // ST1C_4@11
  float v17; // ST0C_4@11
  float v18; // ST1C_4@11
  float v19; // ST1C_4@11
  float v20; // ST0C_4@11
  float v21; // ST1C_4@11
  signed int k; // esi@13
  float v23; // ST1C_4@14
  float v24; // ST0C_4@14
  float v25; // ST1C_4@14
  int l; // esi@15
  float v27; // ST1C_4@16
  float v28; // ST0C_4@16
  float v29; // ST1C_4@16
  float v31; // [sp+14h] [bp-1A0h]@3
  int v32; // [sp+1Ch] [bp-198h]@8
  int v33; // [sp+20h] [bp-194h]@8
  float v34[49]; // [sp+24h] [bp-190h]@11
  float v35; // [sp+E8h] [bp-CCh]@8
  float v36[50]; // [sp+ECh] [bp-C8h]@11

  sub_1008C110(1.0);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  v7 = a5;
  v8 = a6;
  if ( a6 > (double)a5 )
  {
    v8 = a5;
    v7 = a6;
  }
  v9 = v8;
  v31 = v7;
  v10 = v9;
  v11 = (v31 - v9) * 0.1333333402872086;
  v12 = (signed int)(COERCE_FLOAT(LODWORD(v11) & 0x7FFFFFFF) + 1.990000009536743);
  if ( v12 >= 50 )
    v12 = 50;
  v13 = 0;
  for ( i = (unsigned __int64)(v10 * 11930464.71111111);
        v13 < v12;
        *((float *)&v33 + v13) = 4.656612873077393e-10 * (double)v33 )
  {
    if ( v13 == v12 - 1 )
      i = (unsigned __int64)(v31 * 11930464.71111111);
    sub_10095EC0(i, &v33, &v32);
    ++v13;
    i += 89478485;
    *(&v35 + v13) = (double)v32 * 4.656612873077393e-10;
  }
  j_gdi_pvg_color_u32(a7);
  if ( a3 - a4 > 1.5 )
  {
    j_gdi_pvg_begin(73);
    for ( j = 0; j < v12; ++j )
    {
      v16 = v34[j] * a3 + a2;
      v17 = v16;
      v18 = a3 * v36[j] + a1;
      sub_1008C2F0(v18, v17);
      v19 = v34[j] * a4 + a2;
      v20 = v19;
      v21 = a4 * v36[j] + a1;
      sub_1008C2F0(v21, v20);
    }
    j_gdi_pvg_end();
  }
  j_gdi_pvg_begin(66);
  for ( k = 0; k < v12; ++k )
  {
    v23 = v34[k] * a4 + a2;
    v24 = v23;
    v25 = a4 * v36[k] + a1;
    sub_1008C2F0(v25, v24);
  }
  for ( l = v12 - 1; l >= 0; --l )
  {
    v27 = v34[l] * a3 + a2;
    v28 = v27;
    v29 = a3 * v36[l] + a1;
    sub_1008C2F0(v29, v28);
  }
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10067C30: using guessed type float var_190[49];
// 10067C30: using guessed type float var_C8[50];

//----- (10067EE0) --------------------------------------------------------
int __cdecl sub_10067EE0(float a1, float a2, float a3, float a4, int a5)
{
  _DWORD *v5; // eax@1
  float v7; // [sp+Ch] [bp+4h]@1
  float v8; // [sp+18h] [bp+10h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  v5 = (_DWORD *)sub_1008CC80(a5);
  j_gdi_pvg_bind_texture(34, *v5);
  sub_1008C280(84, 82, 79.0);
  j_gdi_pvg_color_u32(-1);
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 0.0);
  v8 = a2 + a4;
  sub_1008C2F0(a1, v8);
  sub_1008C220(0.0, 1.0);
  sub_1008C2F0(a1, a2);
  sub_1008C220(1.0, 1.0);
  v7 = a1 + a3;
  sub_1008C2F0(v7, a2);
  sub_1008C220(1.0, 0.0);
  sub_1008C2F0(v7, v8);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10067FF0) --------------------------------------------------------
int __cdecl sub_10067FF0(float a1, float a2, float a3, float a4, int a5, float a6)
{
  float v7; // [sp+Ch] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a5);
  sub_1008C110(a6);
  j_gdi_pvg_begin(66);
  v7 = a1 - 0.5;
  sub_1008C2F0(v7, a2);
  sub_1008C2F0(a3, a2);
  sub_1008C2F0(a3, a4);
  sub_1008C2F0(v7, a4);
  j_gdi_pvg_end();
  sub_1008C110(1.0);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100680A0) --------------------------------------------------------
int __cdecl sub_100680A0(int a1)
{
  _DWORD *v1; // eax@1
  int v2; // esi@1
  float v3; // ST18_4@1
  _DWORD *v4; // eax@1
  float v5; // ST18_4@1
  float v7; // [sp+10h] [bp+4h]@1
  float v8; // [sp+10h] [bp+4h]@1
  float v9; // [sp+10h] [bp+4h]@1
  float v10; // [sp+10h] [bp+4h]@1
  float v11; // [sp+10h] [bp+4h]@1
  float v12; // [sp+10h] [bp+4h]@1
  float v13; // [sp+10h] [bp+4h]@1
  float v14; // [sp+10h] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  v1 = (_DWORD *)sub_1008CC80(0x3Fu);
  j_gdi_pvg_bind_texture(34, *v1);
  sub_1008C280(84, 82, 79.0);
  j_gdi_pvg_color_u32(-1);
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 0.0);
  v2 = a1;
  v7 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
  sub_1008C2F0(*(float *)v2, v7);
  sub_1008C220(0.0, 1.0);
  sub_1008C2F0(*(float *)v2, *(float *)(v2 + 4));
  sub_1008C220(1.0, 1.0);
  v8 = *(float *)(v2 + 8) + *(float *)v2;
  sub_1008C2F0(v8, *(float *)(v2 + 4));
  sub_1008C220(1.0, 0.0);
  v9 = *(float *)(v2 + 12) + *(float *)(v2 + 4);
  v3 = v9;
  v10 = *(float *)(v2 + 8) + *(float *)v2;
  sub_1008C2F0(v10, v3);
  j_gdi_pvg_end();
  v4 = (_DWORD *)sub_1008CC80(0x40u);
  j_gdi_pvg_bind_texture(34, *v4);
  j_gdi_pvg_color_u32(*(_DWORD *)(v2 + 16));
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 0.0);
  v11 = *(float *)(v2 + 12) + *(float *)(v2 + 4);
  sub_1008C2F0(*(float *)v2, v11);
  sub_1008C220(0.0, 1.0);
  sub_1008C2F0(*(float *)v2, *(float *)(v2 + 4));
  sub_1008C220(1.0, 1.0);
  v12 = *(float *)(v2 + 8) + *(float *)v2;
  sub_1008C2F0(v12, *(float *)(v2 + 4));
  sub_1008C220(1.0, 0.0);
  v13 = *(float *)(v2 + 12) + *(float *)(v2 + 4);
  v5 = v13;
  v14 = *(float *)(v2 + 8) + *(float *)v2;
  sub_1008C2F0(v14, v5);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100682A0) --------------------------------------------------------
int __cdecl sub_100682A0(float a1, float a2, float a3, float a4, int a5, float a6)
{
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a5);
  sub_1008C110(a6);
  j_gdi_pvg_begin(64);
  sub_1008C2F0(a1, a2);
  sub_1008C2F0(a3, a4);
  j_gdi_pvg_end();
  sub_1008C110(1.0);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10068320) --------------------------------------------------------
int __cdecl sub_10068320(float a1, float a2, float a3, float a4, int a5, float a6, int a7)
{
  _DWORD *v7; // eax@1
  float v8; // ST2C_4@1
  int v9; // ecx@1
  double v10; // st7@1
  double v11; // st4@3
  double v12; // st3@3
  float v13; // ST30_4@5
  float v14; // ST38_4@5
  float v15; // ST28_4@5
  float v16; // ST38_4@5
  float v17; // ST28_4@5
  float v18; // ST28_4@5
  float v19; // ST28_4@5
  float v21; // [sp+8h] [bp-10h]@3
  double v22; // [sp+Ch] [bp-Ch]@1
  float v23; // [sp+Ch] [bp-Ch]@3
  float v24; // [sp+20h] [bp+8h]@5
  float v25; // [sp+20h] [bp+8h]@5
  float v26; // [sp+20h] [bp+8h]@5
  float v27; // [sp+20h] [bp+8h]@5
  float v28; // [sp+20h] [bp+8h]@5
  float v29; // [sp+20h] [bp+8h]@5
  float v30; // [sp+30h] [bp+18h]@3

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  v7 = (_DWORD *)sub_1008CC80(a7);
  j_gdi_pvg_bind_texture(34, *v7);
  sub_1008C280(84, 82, 79.0);
  j_gdi_pvg_color_u32(a5);
  v22 = a3 - a1;
  v8 = sqrt(v22 * v22 + (a4 - a2) * (a4 - a2));
  v9 = 3 * sub_1006E440(&a7, 4u, (int)&unk_100F2430, 12, 6, 0);
  v10 = v8;
  if ( v8 <= 0.1000000014901161 )
    v10 = (float)0.1;
  v11 = a6;
  v12 = 0.5 * a6;
  v21 = (a2 - a4) * v12 / v10;
  v30 = v12 * v22 / v10;
  v23 = v11 * flt_100F2434[v9];
  if ( v23 <= 0.1000000014901161 )
    v23 = 0.1;
  v13 = v10 * flt_100F2438[v9] / v23;
  j_gdi_pvg_begin(72);
  sub_1008C220(0.0, 0.0);
  v14 = v30 + a2;
  v15 = v14;
  v16 = v21 + a1;
  sub_1008C2F0(v16, v15);
  sub_1008C220(0.0, 1.0);
  v24 = a2 - v30;
  v17 = v24;
  v25 = a1 - v21;
  sub_1008C2F0(v25, v17);
  sub_1008C220(v13, 1.0);
  v26 = a4 - v30;
  v18 = v26;
  v27 = a3 - v21;
  sub_1008C2F0(v27, v18);
  sub_1008C220(v13, 0.0);
  v28 = v30 + a4;
  v19 = v28;
  v29 = v21 + a3;
  sub_1008C2F0(v29, v19);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100F2434: using guessed type float flt_100F2434[];
// 100F2438: using guessed type float flt_100F2438[];

//----- (10068550) --------------------------------------------------------
int __cdecl sub_10068550(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  unsigned int v8; // eax@1
  double v9; // ST28_8@5
  int v10; // edi@5
  double v11; // ST30_8@5
  float v12; // ST20_4@5
  double v13; // ST18_8@5
  float v14; // ST14_4@5
  double v15; // st7@5
  double v16; // ST30_8@7
  int v17; // edi@7
  double v18; // ST20_8@7
  float v19; // ST28_4@7
  float v20; // ST18_4@7
  double v21; // ST30_8@7
  float v22; // ST14_4@7
  float v23; // ST04_4@8
  float v25; // [sp+4h] [bp-30h]@5
  float v26; // [sp+14h] [bp-20h]@1
  float v27; // [sp+48h] [bp+14h]@5
  float v28; // [sp+48h] [bp+14h]@7
  int v29; // [sp+4Ch] [bp+18h]@5
  int v30; // [sp+4Ch] [bp+18h]@7

  v7 = a6;
  v26 = 1.0;
  v8 = (unsigned int)a6 >> 16;
  BYTE1(a6) >>= 1;
  LOBYTE(a6) = (unsigned __int8)a6 >> 1;
  BYTE2(a6) = (unsigned __int8)v8 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v26 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v26 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(71);
    j_gdi_pvg_color_u32(v7);
    v16 = v26 * a4;
    v28 = a2 - v16;
    sub_1008C2F0(a1, v28);
    v17 = a6;
    j_gdi_pvg_color_u32(a6);
    v18 = a3 * 0.5;
    v19 = a1 - v18;
    sub_1008C2F0(v19, v28);
    v20 = a2 - v16 * 0.699999988079071;
    v21 = a3 * 0.1000000014901161;
    *(float *)&v30 = a1 - v21;
    sub_1008C2F0(*(float *)&v30, v20);
    sub_1008C2F0(*(float *)&v30, a2);
    j_gdi_pvg_color_u32(v7);
    sub_1008C2F0(a1, a2);
    j_gdi_pvg_color_u32(v17);
    v22 = a1 + v21;
    sub_1008C2F0(v22, a2);
    sub_1008C2F0(v22, v20);
    *(float *)&v18 = a1 + v18;
    sub_1008C2F0(*(float *)&v18, v28);
    j_gdi_pvg_end();
    j_gdi_pvg_enable(38);
    sub_1008C110(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_1008C2F0(a1, a2);
    sub_1008C2F0(*(float *)&v30, a2);
    sub_1008C2F0(*(float *)&v30, v20);
    sub_1008C2F0(v19, v28);
    sub_1008C2F0(*(float *)&v18, v28);
    sub_1008C2F0(v22, v20);
    v25 = a2;
    v15 = v22;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(71);
  j_gdi_pvg_color_u32(v7);
  v9 = v26 * a3;
  v27 = a1 - v9;
  sub_1008C2F0(v27, a2);
  v10 = a6;
  j_gdi_pvg_color_u32(a6);
  v11 = a4 * 0.5;
  v12 = a2 - v11;
  sub_1008C2F0(v27, v12);
  v13 = a4 * 0.1000000014901161;
  *(float *)&v29 = a2 - v13;
  v14 = a1 - v9 * 0.699999988079071;
  sub_1008C2F0(v14, *(float *)&v29);
  sub_1008C2F0(a1, *(float *)&v29);
  j_gdi_pvg_color_u32(v7);
  sub_1008C2F0(a1, a2);
  j_gdi_pvg_color_u32(v10);
  *(float *)&v13 = a2 + v13;
  sub_1008C2F0(a1, *(float *)&v13);
  sub_1008C2F0(v14, *(float *)&v13);
  *(float *)&v9 = a2 + v11;
  sub_1008C2F0(v27, *(float *)&v9);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  sub_1008C110(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_1008C2F0(a1, a2);
  sub_1008C2F0(a1, *(float *)&v29);
  sub_1008C2F0(v14, *(float *)&v29);
  sub_1008C2F0(v27, v12);
  sub_1008C2F0(v27, *(float *)&v9);
  sub_1008C2F0(v14, *(float *)&v13);
  v25 = *(float *)&v13;
  v15 = a1;
LABEL_8:
  v23 = v15;
  sub_1008C2F0(v23, v25);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100689C0) --------------------------------------------------------
int __cdecl sub_100689C0(float a1, float a2, float a3, int a4)
{
  float v5; // [sp+Ch] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a4);
  sub_1008C110(3.0);
  j_gdi_pvg_begin(64);
  sub_1008C2F0(a1, a2);
  v5 = a1 + a3;
  sub_1008C2F0(v5, a2);
  j_gdi_pvg_end();
  sub_1008C110(1.0);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10068A50) --------------------------------------------------------
int __cdecl sub_10068A50(int a1, int a2, int a3, float a4)
{
  int i; // esi@1

  j_gdi_pvg_color_u32(a3);
  sub_1008C110(a4);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(67);
  for ( i = 0; i < a2; ++i )
    sub_1008C2F0(*(float *)(a1 + 8 * i), *(float *)(a1 + 8 * i + 4));
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  j_gdi_pvg_disable(35);
  return sub_1008C110(1.0);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10068AE0) --------------------------------------------------------
char __cdecl sub_10068AE0(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // edx@1
  double v6; // st7@1
  int v7; // eax@1
  float v8; // ST10_4@1
  int v9; // eax@1
  const char *v10; // edi@1
  double v11; // st7@2
  char v12; // al@2
  int v13; // edx@3
  char *v14; // ecx@3
  double v15; // st7@11
  float *v16; // ecx@13
  int v17; // eax@16
  double v18; // st6@17
  bool v19; // zf@17
  char v21; // [sp+1Fh] [bp-65h]@1
  __int16 v22; // [sp+20h] [bp-64h]@17
  __int16 v23; // [sp+22h] [bp-62h]@17
  float v24; // [sp+24h] [bp-60h]@11
  float v25; // [sp+28h] [bp-5Ch]@13
  int v26; // [sp+2Ch] [bp-58h]@1
  float v27; // [sp+30h] [bp-54h]@15
  int v28; // [sp+34h] [bp-50h]@1
  int v29; // [sp+38h] [bp-4Ch]@1
  float v30; // [sp+3Ch] [bp-48h]@1
  float v31; // [sp+40h] [bp-44h]@1
  int v32; // [sp+44h] [bp-40h]@1
  float v33; // [sp+48h] [bp-3Ch]@1
  float v34; // [sp+4Ch] [bp-38h]@1
  int v35; // [sp+50h] [bp-34h]@1
  int v36; // [sp+54h] [bp-30h]@1
  int v37; // [sp+68h] [bp-1Ch]@1
  char v38; // [sp+6Ch] [bp-18h]@2

  v5 = *(_DWORD *)(a2 + 12);
  v30 = *(float *)(a2 + 40);
  v35 = a4;
  v31 = 0.0;
  v6 = *(float *)(a2 + 40);
  LOBYTE(v36) = a5;
  v7 = *(_DWORD *)(a2 + 8);
  v8 = v6;
  v21 = 31;
  LOWORD(v26) = a3;
  v37 = 0;
  v28 = v5;
  v29 = v7;
  v9 = sub_10065060(v8);
  v33 = *(float *)(a2 + 32);
  v34 = *(float *)(a2 + 36);
  v32 = v9;
  v10 = (const char *)sub_10060760(a3);
  if ( v10 )
  {
    v11 = sub_1006D0E0(COERCE_INT(*(float *)(a2 + 28)), v26, v36, &v21);
    sprintf(&v38, v10, LODWORD(v11), (_DWORD)(*(unsigned __int64 *)&v11 >> 32));
    v12 = v38;
    if ( v38 )
    {
      v13 = v37;
      v14 = &v38;
      do
      {
        if ( (unsigned __int8)v12 >= 0x30u && (unsigned __int8)v12 <= 0x39u )
          ++v13;
        v12 = (v14++)[1];
      }
      while ( v12 );
      v37 = v13;
    }
  }
  else
  {
    v37 = 0;
  }
  if ( *(float *)(a2 + 28) >= (double)*(float *)(a2 + 24) )
  {
    v24 = *(float *)(a2 + 24);
    v15 = *(float *)(a2 + 28);
  }
  else
  {
    v24 = *(float *)(a2 + 28);
    v15 = *(float *)(a2 + 24);
  }
  v16 = *(float **)(a2 + 20);
  v25 = v15;
  if ( v24 > (double)*v16 || v25 < (double)*v16 )
  {
    v17 = *(_DWORD *)(a2 + 16);
    v27 = 9.8999998e24;
    v29 = 0;
    v28 = v17;
  }
  else
  {
    v27 = *v16;
  }
  v18 = *(float *)(a2 + 4);
  v22 = (signed int)*(float *)a2;
  v19 = *(_BYTE *)(a2 + 46) == 0;
  v23 = (signed int)v18;
  if ( !v19 && 9.8999998e24 == v27 )
    v23 += (signed int)(*(float *)(a2 + 40) * -0.5);
  return sub_10060770(a1, 0, (int)&v22, (int)&v26, (__int16 *)&unk_100EB2AC);
}

//----- (10068CB0) --------------------------------------------------------
int __cdecl sub_10068CB0(float a1, float a2, float a3, int a4)
{
  int v4; // ST34_4@1
  int v5; // eax@1
  int v6; // ST08_4@1
  float v7; // ST0C_4@1
  float v8; // ST38_4@1
  float v9; // ST54_4@1
  float v10; // ST40_4@1
  float v11; // ST10_4@1
  float v12; // ST3C_4@1
  float v13; // ST44_4@1
  float v14; // ST1C_4@1
  float v15; // ST20_4@1
  float v16; // ST24_4@1
  float v17; // ST28_4@1
  float v18; // ST2C_4@1
  float v19; // ST30_4@1
  float v20; // ST48_4@1
  float v21; // ST14_4@1
  float v22; // ST50_4@1
  float v23; // ST4C_4@1
  float v24; // ST18_4@1
  float v25; // ST54_4@1
  float v26; // ST54_4@1
  float v28; // [sp+58h] [bp+4h]@1
  float v29; // [sp+60h] [bp+Ch]@1
  float v30; // [sp+60h] [bp+Ch]@1
  float v31; // [sp+60h] [bp+Ch]@1
  int v32; // [sp+64h] [bp+10h]@1

  v4 = a4;
  BYTE3(v4) = BYTE3(a4) >> 1;
  v5 = 3 * LOBYTE(a3);
  v6 = a4;
  v28 = flt_100F2480[v5] + a1;
  v32 = SLODWORD(flt_100F2478[v5]);
  v29 = flt_100F247C[v5];
  j_gdi_pvg_color_u32(v6);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_begin(63);
  v7 = v29 * 0.5 + a2;
  v8 = 0.5 * *(float *)&v32 + v28;
  sub_1008C2F0(v8, v7);
  v9 = *(float *)&v32 * 1.5 + v28;
  sub_1008C2F0(v9, v7);
  v10 = *(float *)&v32 * 2.5 + v28;
  sub_1008C2F0(v10, v7);
  v11 = v29 * 1.5 + a2;
  v12 = *(float *)&v32 * 3.5 + v28;
  sub_1008C2F0(v12, v11);
  v13 = *(float *)&v32 * 4.5 + v28;
  sub_1008C2F0(v13, v11);
  v14 = v29 * 2.5 + a2;
  v15 = *(float *)&v32 * 5.5 + v28;
  sub_1008C2F0(v15, v14);
  v16 = v29 * 3.5 + a2;
  v17 = *(float *)&v32 * 6.5 + v28;
  sub_1008C2F0(v17, v16);
  v18 = v29 * 4.5 + a2;
  v19 = *(float *)&v32 * 7.5 + v28;
  sub_1008C2F0(v19, v18);
  v20 = v29 * 5.5 + a2;
  v21 = *(float *)&v32 * 8.5 + v28;
  sub_1008C2F0(v21, v20);
  v22 = v29 * 6.5 + a2;
  sub_1008C2F0(v21, v22);
  v23 = v29 * 7.5 + a2;
  v24 = *(float *)&v32 * 9.5 + v28;
  sub_1008C2F0(v24, v23);
  v25 = v29 * 8.5 + a2;
  sub_1008C2F0(v24, v25);
  v26 = v29 * 9.5 + a2;
  sub_1008C2F0(v24, v26);
  j_gdi_pvg_color_u32(v4);
  v30 = v29 * -0.5 + a2;
  sub_1008C2F0(v8, v30);
  sub_1008C2F0(v12, v7);
  sub_1008C2F0(v10, v11);
  sub_1008C2F0(v15, v11);
  sub_1008C2F0(v13, v14);
  sub_1008C2F0(v17, v14);
  sub_1008C2F0(v15, v16);
  sub_1008C2F0(v19, v16);
  sub_1008C2F0(v17, v18);
  sub_1008C2F0(v21, v18);
  sub_1008C2F0(v19, v20);
  sub_1008C2F0(v21, v23);
  sub_1008C2F0(v24, v22);
  v31 = *(float *)&v32 * 10.5 + v28;
  sub_1008C2F0(v31, v26);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100F2478: using guessed type float flt_100F2478[];
// 100F247C: using guessed type float flt_100F247C[];
// 100F2480: using guessed type float flt_100F2480[];

//----- (100690D0) --------------------------------------------------------
int __cdecl sub_100690D0(float a1, float a2, float a3, float a4, int a5)
{
  float v5; // ST14_4@1
  double v6; // ST28_8@1
  float v7; // ST18_4@1
  double v8; // ST20_8@1
  float v9; // ST1C_4@1
  float v11; // [sp+38h] [bp+8h]@1
  float v12; // [sp+3Ch] [bp+Ch]@1
  float v13; // [sp+40h] [bp+10h]@1
  float v14; // [sp+40h] [bp+10h]@1
  float v15; // [sp+40h] [bp+10h]@1

  j_gdi_pvg_color_u32(a5);
  sub_1008C110(1.0);
  j_gdi_pvg_begin(64);
  v5 = a2 + 10.0;
  sub_1008C2F0(a1, v5);
  v6 = a2 + a4;
  v13 = v6 - 10.0;
  sub_1008C2F0(a1, v13);
  v7 = a1 + 10.0;
  sub_1008C2F0(v7, a2);
  v8 = a1 + a3;
  v9 = v8 - 10.0;
  sub_1008C2F0(v9, a2);
  v12 = v8 + 0.5;
  sub_1008C2F0(v12, v5);
  sub_1008C2F0(v12, v13);
  v14 = v6 + 0.5;
  sub_1008C2F0(v7, v14);
  sub_1008C2F0(v9, v14);
  j_gdi_pvg_end();
  sub_10068CB0(a1, a2, 0.0, a5);
  v15 = v8;
  sub_10068CB0(v15, a2, COERCE_FLOAT(1), a5);
  v11 = v6;
  sub_10068CB0(v15, v11, COERCE_FLOAT(2), a5);
  return sub_10068CB0(a1, v11, COERCE_FLOAT(3), a5);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10069290) --------------------------------------------------------
int __cdecl sub_10069290(int a1)
{
  int v1; // esi@1
  double v2; // st7@2
  float v3; // ST08_4@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+4h] [bp-8h]@2
  float v7; // [sp+10h] [bp+4h]@2
  float v8; // [sp+10h] [bp+4h]@2
  float v9; // [sp+10h] [bp+4h]@3

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(-1);
  sub_1008C110(1.0);
  j_gdi_pvg_begin(64);
  v1 = a1;
  v5 = *(float *)(a1 + 4);
  if ( *(_BYTE *)(a1 + 16) == 1 )
  {
    sub_1008C2F0(*(float *)a1, v5);
    v9 = *(float *)(a1 + 4) - *(float *)(a1 + 12);
    v6 = v9;
    v2 = *(float *)v1;
  }
  else
  {
    v7 = *(float *)a1 - 1.0;
    sub_1008C2F0(v7, v5);
    v6 = *(float *)(v1 + 4);
    v8 = *(float *)(v1 + 8) + *(float *)v1;
    v2 = v8;
  }
  v3 = v2;
  sub_1008C2F0(v3, v6);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10069340) --------------------------------------------------------
int __cdecl sub_10069340(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // esi@1
  float v6; // ST10_4@1
  float v7; // ST10_4@1
  float v9; // [sp+10h] [bp+4h]@1
  float v10; // [sp+10h] [bp+4h]@1
  float v11; // [sp+10h] [bp+4h]@1
  float v12; // [sp+10h] [bp+4h]@1
  float v13; // [sp+10h] [bp+4h]@1
  float v14; // [sp+10h] [bp+4h]@1

  v5 = a1;
  sub_10068AE0(a1, a2, a3, a4, a5);
  sub_1008C110(1.5);
  j_gdi_pvg_begin(66);
  j_gdi_pvg_color_u32(-16711681);
  v9 = *(float *)(a1 + 296) - 1.0;
  v6 = v9;
  v10 = *(float *)(v5 + 292) - 1.0;
  sub_1008C2F0(v10, v6);
  v11 = *(float *)(v5 + 296) - 1.0;
  sub_1008C2F0(*(float *)(v5 + 300), v11);
  v12 = *(float *)(v5 + 304) + 1.0;
  sub_1008C2F0(*(float *)(v5 + 300), v12);
  v13 = *(float *)(v5 + 304) + 1.0;
  v7 = v13;
  v14 = *(float *)(v5 + 292) - 1.0;
  sub_1008C2F0(v14, v7);
  j_gdi_pvg_end();
  return sub_1008C110(1.0);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10069450) --------------------------------------------------------
int __cdecl sub_10069450(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  unsigned int v8; // eax@1
  int v9; // edi@5
  double v10; // ST2C_8@5
  double v11; // ST1C_8@5
  float v12; // ST18_4@5
  double v13; // ST24_8@5
  float v14; // ST14_4@5
  float v15; // ST14_4@5
  float v16; // ST14_4@5
  double v17; // st7@5
  int v18; // edi@7
  double v19; // ST1C_8@7
  float v20; // ST18_4@7
  double v21; // ST24_8@7
  float v22; // ST14_4@7
  double v23; // ST2C_8@7
  float v24; // ST14_4@7
  float v25; // ST04_4@8
  float v27; // [sp+4h] [bp-2Ch]@5
  float v28; // [sp+14h] [bp-1Ch]@1
  float v29; // [sp+44h] [bp+14h]@5
  float v30; // [sp+44h] [bp+14h]@7
  int v31; // [sp+48h] [bp+18h]@5
  int v32; // [sp+48h] [bp+18h]@7

  v7 = a6;
  v28 = 1.0;
  v8 = (unsigned int)a6 >> 16;
  BYTE1(a6) >>= 1;
  LOBYTE(a6) = (unsigned __int8)a6 >> 1;
  BYTE2(a6) = (unsigned __int8)v8 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v28 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v28 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(73);
    v18 = a6;
    j_gdi_pvg_color_u32(a6);
    v19 = v28 * a4;
    v20 = a2 - v19 * 0.4000000059604645;
    v21 = a3 * 0.5;
    *(float *)&v32 = a1 - v21;
    sub_1008C2F0(*(float *)&v32, v20);
    v30 = a2 - v19;
    sub_1008C2F0(*(float *)&v32, v30);
    j_gdi_pvg_color_u32(v7);
    v22 = a2 - v19 * 0.2000000029802322;
    v23 = a3 * 0.25;
    *(float *)&v19 = a1 - v23;
    sub_1008C2F0(*(float *)&v19, v22);
    sub_1008C2F0(*(float *)&v19, v30);
    sub_1008C2F0(a1, a2);
    sub_1008C2F0(a1, v30);
    *(float *)&v19 = a1 + v23;
    sub_1008C2F0(*(float *)&v19, v22);
    sub_1008C2F0(*(float *)&v19, v30);
    j_gdi_pvg_color_u32(v18);
    v24 = a1 + v21;
    sub_1008C2F0(v24, v20);
    sub_1008C2F0(v24, v30);
    j_gdi_pvg_end();
    j_gdi_pvg_enable(38);
    sub_1008C110(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_1008C2F0(a1, a2);
    sub_1008C2F0(*(float *)&v32, v20);
    sub_1008C2F0(*(float *)&v32, v30);
    sub_1008C2F0(v24, v30);
    v27 = v20;
    v17 = v24;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(73);
  v9 = a6;
  j_gdi_pvg_color_u32(a6);
  v10 = a4 * 0.5;
  *(float *)&v31 = v10 + a2;
  v11 = v28 * a3;
  v12 = v11 * 0.4000000059604645 + a1;
  sub_1008C2F0(v12, *(float *)&v31);
  v29 = a1 + v11;
  sub_1008C2F0(v29, *(float *)&v31);
  j_gdi_pvg_color_u32(v7);
  v13 = a4 * 0.25;
  v14 = v13 + a2;
  *(float *)&v11 = v11 * 0.2000000029802322 + a1;
  sub_1008C2F0(*(float *)&v11, v14);
  sub_1008C2F0(v29, v14);
  sub_1008C2F0(a1, a2);
  sub_1008C2F0(v29, a2);
  v15 = a2 - v13;
  sub_1008C2F0(*(float *)&v11, v15);
  sub_1008C2F0(v29, v15);
  j_gdi_pvg_color_u32(v9);
  v16 = a2 - v10;
  sub_1008C2F0(v12, v16);
  sub_1008C2F0(v29, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  sub_1008C110(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_1008C2F0(a1, a2);
  sub_1008C2F0(v12, *(float *)&v31);
  sub_1008C2F0(v29, *(float *)&v31);
  sub_1008C2F0(v29, v16);
  v27 = v16;
  v17 = v12;
LABEL_8:
  v25 = v17;
  sub_1008C2F0(v25, v27);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (100698D0) --------------------------------------------------------
int __cdecl sub_100698D0(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  double v3; // st7@2
  int v4; // edi@4
  float v5; // ST18_4@4
  float v6; // ST18_4@4
  float v7; // ST18_4@4
  float v8; // ST0C_4@4
  float v9; // ST18_4@4
  float v10; // ST18_4@4
  float v11; // ST18_4@4
  float v12; // ST0C_4@4
  float v13; // ST18_4@4
  float v14; // ST18_4@4
  float v15; // ST18_4@4
  float v16; // ST18_4@4
  float v17; // ST0C_4@4
  float v18; // ST18_4@4
  float v19; // ST18_4@4
  float v20; // ST0C_4@4
  float v21; // ST18_4@4
  float v22; // ST18_4@4
  float v23; // ST0C_4@4
  float v24; // ST18_4@4
  float v25; // ST18_4@4
  float v26; // ST0C_4@4
  float v27; // ST18_4@4
  float v28; // ST18_4@4
  float v29; // ST0C_4@4
  float v30; // ST18_4@4
  float v31; // ST0C_4@4
  int v33; // [sp+10h] [bp-4h]@1
  float v34; // [sp+18h] [bp+4h]@4
  float v35; // [sp+18h] [bp+4h]@4
  float v36; // [sp+18h] [bp+4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 16);
  v33 = *(_DWORD *)(a1 + 16);
  BYTE1(v33) >>= 1;
  LOBYTE(v33) = (unsigned __int8)v2 >> 1;
  BYTE2(v33) = (unsigned __int8)(v2 >> 16) >> 1;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) > (double)*(float *)(a1 + 12) )
    v3 = 0.0;
  else
    v3 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) - *(float *)(a1 + 12);
  v34 = v3;
  j_gdi_pvg_begin(73);
  v4 = v33;
  j_gdi_pvg_color_u32(v33);
  sub_1008C2F0(*(float *)v1, *(float *)(v1 + 4));
  v5 = *(float *)(v1 + 4) + v34;
  sub_1008C2F0(*(float *)v1, v5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v6 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v6, *(float *)(v1 + 4));
  v7 = *(float *)(v1 + 4) + v34;
  v8 = v7;
  v9 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v9, v8);
  j_gdi_pvg_color_u32(v4);
  v10 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v10, *(float *)(v1 + 4));
  v11 = *(float *)(v1 + 4) + v34;
  v12 = v11;
  v13 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v13, v12);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  v14 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_1008C2F0(*(float *)v1, v14);
  v15 = *(float *)(v1 + 4) + v34;
  sub_1008C2F0(*(float *)v1, v15);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v16 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v17 = v16;
  v18 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v18, v17);
  v19 = *(float *)(v1 + 4) + v34;
  v20 = v19;
  v21 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_1008C2F0(v21, v20);
  j_gdi_pvg_color_u32(v4);
  v22 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v23 = v22;
  v24 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v24, v23);
  v25 = *(float *)(v1 + 4) + v34;
  v26 = v25;
  v27 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v27, v26);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_1008C110(2.0);
  v28 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v29 = v28;
  v30 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v30, v29);
  v35 = *(float *)(v1 + 4) + v34;
  v31 = v35;
  v36 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v36, v31);
  sub_1008C110(1.0);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10069BD0) --------------------------------------------------------
int __cdecl sub_10069BD0(int a1)
{
  int v1; // esi@1
  float v2; // ST10_4@1
  float v4; // [sp+10h] [bp+4h]@1
  float v5; // [sp+10h] [bp+4h]@1
  float v6; // [sp+10h] [bp+4h]@1
  float v7; // [sp+10h] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_begin(73);
  v1 = a1;
  j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 16));
  sub_1008C2F0(*(float *)v1, *(float *)(v1 + 4));
  v4 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_1008C2F0(*(float *)v1, v4);
  v5 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v5, *(float *)(v1 + 4));
  v6 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v2 = v6;
  v7 = *(float *)(v1 + 8) + *(float *)v1;
  sub_1008C2F0(v7, v2);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10069C80) --------------------------------------------------------
int __cdecl sub_10069C80(int a1, int a2, unsigned __int8 a3, char a4)
{
  int v4; // ebp@3
  int v5; // edi@3
  int v6; // esi@3
  int v7; // ebp@4
  int result; // eax@13
  int v9; // esi@16
  int v10; // ebp@16
  int v11; // eax@18
  int v12; // ecx@18
  int v13; // edx@18
  float v14; // [sp+18h] [bp-28h]@3
  float v15; // [sp+1Ch] [bp-24h]@18
  float v16; // [sp+20h] [bp-20h]@18
  int v17; // [sp+24h] [bp-1Ch]@18
  float v18; // [sp+28h] [bp-18h]@18
  int v19; // [sp+2Ch] [bp-14h]@18
  int v20; // [sp+30h] [bp-10h]@18
  float v21; // [sp+34h] [bp-Ch]@18
  float v22; // [sp+38h] [bp-8h]@18
  float v23; // [sp+3Ch] [bp-4h]@20

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( a4 )
    j_gdi_pvg_enable(38);
  v4 = a2;
  v14 = *(float *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 56);
  v6 = a2 + 56;
  sub_1008C110(v14);
  j_gdi_pvg_begin(64);
  j_gdi_pvg_color_u32(v5);
  if ( a3 )
  {
    v7 = a3;
    do
    {
      if ( *(_BYTE *)(v6 + 4) != 1 )
      {
        if ( *(_DWORD *)v6 != v5 )
        {
          v5 = *(_DWORD *)v6;
          j_gdi_pvg_color_u32(*(_DWORD *)v6);
        }
        if ( v14 != *(float *)(v6 - 40) )
        {
          j_gdi_pvg_end();
          v14 = *(float *)(v6 - 40);
          sub_1008C110(v14);
          j_gdi_pvg_begin(64);
        }
        sub_1008C2F0(*(float *)(v6 - 56), *(float *)(v6 - 48));
        sub_1008C2F0(*(float *)(v6 - 52), *(float *)(v6 - 44));
      }
      v6 += 64;
      --v7;
    }
    while ( v7 );
    v4 = a2;
  }
  j_gdi_pvg_end();
  sub_1008C110(1.0);
  result = j_gdi_pvg_disable(35);
  if ( a4 )
    result = j_gdi_pvg_disable(38);
  if ( a3 )
  {
    v9 = v4 + 48;
    v10 = a3;
    do
    {
      if ( *(_BYTE *)(v9 - 12) )
      {
        v21 = *(float *)(v9 - 4);
        v22 = *(float *)v9;
        v15 = *(float *)(v9 - 28);
        v16 = *(float *)(v9 - 24);
        v11 = sub_10065060(*(float *)(v9 + 4));
        v12 = *(_DWORD *)(v9 - 20);
        v13 = *(_DWORD *)(v9 - 16);
        v18 = *(float *)(v9 + 4);
        v17 = v11;
        v19 = v12;
        v20 = v13;
        if ( v12 )
        {
          v23 = sub_1008D010(v11, v9 - 12, v18);
          result = sub_10065B50(a1, v9 - 12, (int)&v15);
        }
        else
        {
          result = sub_10065670(v9 - 12, (int)&v15);
        }
      }
      v9 += 64;
      --v10;
    }
    while ( v10 );
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10069E40) --------------------------------------------------------
int __cdecl sub_10069E40(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // ST1C_8@5
  float v9; // ST18_4@5
  double v10; // st7@5
  double v11; // ST1C_8@7
  float v12; // ST18_4@7
  float v13; // ST04_4@8
  float v15; // [sp+4h] [bp-1Ch]@5
  int v16; // [sp+10h] [bp-10h]@1
  float v17; // [sp+14h] [bp-Ch]@1
  float v18; // [sp+34h] [bp+14h]@5
  float v19; // [sp+34h] [bp+14h]@7
  int v20; // [sp+38h] [bp+18h]@5
  int v21; // [sp+38h] [bp+18h]@7

  v7 = a6;
  v17 = 1.0;
  v16 = a6;
  BYTE2(v16) = (signed int)((double)(unsigned __int8)((unsigned int)a6 >> 16) * 0.8999999761581421);
  BYTE1(v16) = (signed int)((double)BYTE1(v16) * 0.8999999761581421);
  LOBYTE(v16) = (signed int)(0.8999999761581421 * (double)(unsigned __int8)a6);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v17 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v17 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(71);
    j_gdi_pvg_color_u32(a6);
    sub_1008C2F0(a1, a2);
    j_gdi_pvg_color_u32(v16);
    v19 = a2 - v17 * a4;
    v11 = a3 * 0.5;
    *(float *)&v21 = v11 + a1;
    sub_1008C2F0(*(float *)&v21, v19);
    j_gdi_pvg_color_u32(v7);
    sub_1008C2F0(a1, v19);
    j_gdi_pvg_color_u32(v16);
    v12 = a1 - v11;
    sub_1008C2F0(v12, v19);
    j_gdi_pvg_end();
    j_gdi_pvg_enable(38);
    sub_1008C110(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_1008C2F0(a1, a2);
    sub_1008C2F0(*(float *)&v21, v19);
    v15 = v19;
    v10 = v12;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(71);
  j_gdi_pvg_color_u32(a6);
  sub_1008C2F0(a1, a2);
  j_gdi_pvg_color_u32(v16);
  v8 = a4 * 0.5;
  *(float *)&v20 = a2 - v8;
  v18 = v17 * a3 + a1;
  sub_1008C2F0(v18, *(float *)&v20);
  j_gdi_pvg_color_u32(v7);
  sub_1008C2F0(v18, a2);
  j_gdi_pvg_color_u32(v16);
  v9 = a2 + v8;
  sub_1008C2F0(v18, v9);
  j_gdi_pvg_end();
  j_gdi_pvg_enable(38);
  sub_1008C110(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_1008C2F0(a1, a2);
  sub_1008C2F0(v18, *(float *)&v20);
  v15 = v9;
  v10 = v18;
LABEL_8:
  v13 = v10;
  sub_1008C2F0(v13, v15);
  j_gdi_pvg_end();
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (1006A190) --------------------------------------------------------
void __cdecl sub_1006A190(int a1)
{
  int v1; // ebp@1
  double v2; // st7@1
  signed int v3; // edx@1
  int v4; // ecx@1
  double v5; // st5@1
  int v6; // ebx@1
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st5@1
  double v10; // st4@4
  double v11; // st6@7
  int v12; // edi@7
  int v13; // esi@7
  int v14; // esi@9
  int v15; // edi@9
  float v16; // ST10_4@9
  float v17; // ST20_4@9
  float v18; // ST20_4@9
  int v19; // ebx@9
  int v20; // esi@9
  int v21; // edi@9
  double v22; // st7@9
  double v23; // st7@11
  float v24; // ST10_4@14
  float v25; // ST20_4@14
  int v26; // esi@14
  int v27; // edi@14
  float v28; // ST20_4@14
  float v29; // [sp+Ch] [bp-20h]@1
  float v30; // [sp+14h] [bp-18h]@6
  float v31; // [sp+1Ch] [bp-10h]@1
  float v32; // [sp+20h] [bp-Ch]@1
  int v33; // [sp+24h] [bp-8h]@1
  signed int v34; // [sp+28h] [bp-4h]@1
  float v35; // [sp+30h] [bp+4h]@4

  v1 = a1;
  v2 = *(float *)(a1 + 8);
  v3 = 0;
  v4 = a1 + 24;
  v5 = *(float *)a1;
  v6 = 0;
  *(_DWORD *)(a1 + 1348) = 0;
  v34 = 0;
  v33 = a1 + 24;
  v31 = v2 * 0.5 + v5;
  v32 = 0.5 * *(float *)(v1 + 12) + *(float *)(v1 + 4);
  v29 = *(float *)(a1 + 8);
  v7 = v32;
  v8 = 0.0;
  v9 = 0.5;
  do
  {
    if ( 9.8999998e24 == *(float *)v4 )
      break;
    if ( v3 <= 0 )
    {
      v35 = *(float *)v4;
      v10 = *(float *)(v1 + 16);
    }
    else
    {
      v35 = *(float *)v4 - *(float *)(v4 - 8);
      v10 = *(float *)(v1 + 16) + *(float *)(v4 - 8);
    }
    v30 = v10;
    if ( v35 != v8 )
    {
      v11 = v35;
      v12 = v1 + 4 * v6 + 732;
      v13 = v1 + 4 * v6 + 204;
      while ( 1 )
      {
        v14 = v13 + 4;
        *(float *)(v14 - 4) = v31;
        v15 = v12 + 4;
        *(float *)(v15 - 4) = v9;
        v14 += 4;
        *(float *)(v14 - 4) = v7;
        v15 += 4;
        *(float *)(v15 - 4) = v9;
        *(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 1348) + 1260) = *(_DWORD *)(v4 + 4);
        v16 = (v11 + v30) * 0.01745329251994333;
        v17 = cos(v16);
        v14 += 4;
        v15 += 4;
        *(float *)(v14 - 4) = v17 * v29 + v31;
        *(float *)(v15 - 4) = v17 + 0.5;
        v18 = sin(v16);
        v19 = v6 + 4;
        v20 = v14 + 4;
        v21 = v15 + 4;
        *(float *)(v20 - 4) = v18 * v29 + v32;
        *(float *)(v21 - 4) = v18 + 0.5;
        v22 = v35;
        if ( COERCE_FLOAT(LODWORD(v35) & 0x7FFFFFFF) <= 30.0 )
          v23 = 0.0;
        else
          v23 = v22 <= 0.0 ? v22 + 30.0 : v22 - 30.0;
        v35 = v23;
        v24 = (v30 + v35) * 0.01745329251994333;
        v25 = cos(v24);
        v26 = v20 + 4;
        v27 = v21 + 4;
        *(float *)(v26 - 4) = v25 * v29 + v31;
        *(float *)(v27 - 4) = v25 + 0.5;
        v28 = sin(v24);
        v4 = v33;
        v6 = v19 + 2;
        v13 = v26 + 4;
        v12 = v27 + 4;
        *(float *)(v13 - 4) = v28 * v29 + v32;
        v7 = v32;
        *(float *)(v12 - 4) = v28 + 0.5;
        ++*(_DWORD *)(v1 + 1348);
        v8 = 0.0;
        if ( v35 == 0.0 )
          break;
        v11 = v35;
        v9 = 0.5;
      }
      v3 = v34;
      v9 = 0.5;
    }
    ++v3;
    v4 += 8;
    v34 = v3;
    v33 = v4;
  }
  while ( v3 < 10 );
}

//----- (1006A400) --------------------------------------------------------
void __cdecl sub_1006A400(int a1)
{
  sub_100659D0(
    *(float *)a1,
    *(float *)(a1 + 4),
    25.0,
    *(float *)(a1 + 40),
    *(float *)(a1 + 32),
    *(float *)(a1 + 36),
    *(_BYTE *)(a1 + 45));
}

//----- (1006A440) --------------------------------------------------------
int __usercall sub_1006A440@<eax>(char a1@<al>, int a2@<ecx>, char a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // esi@3
  unsigned int v6; // eax@4
  unsigned int v7; // edi@4
  float v8; // ST08_4@4
  float v9; // ST08_4@4
  float v10; // ST08_4@4
  int v12; // esi@7
  unsigned int v13; // eax@8
  unsigned int v14; // edi@8
  float v15; // ST08_4@8
  float v16; // ST08_4@8
  float v17; // ST08_4@8
  unsigned int v18; // [sp+18h] [bp+4h]@4
  float v19; // [sp+18h] [bp+4h]@4
  float v20; // [sp+18h] [bp+4h]@4
  float v21; // [sp+18h] [bp+4h]@4
  float v22; // [sp+18h] [bp+4h]@4
  float v23; // [sp+18h] [bp+4h]@4
  float v24; // [sp+18h] [bp+4h]@4
  float v25; // [sp+18h] [bp+4h]@4
  float v26; // [sp+18h] [bp+4h]@4
  float v27; // [sp+18h] [bp+4h]@4
  float v28; // [sp+18h] [bp+4h]@4
  unsigned int v29; // [sp+18h] [bp+4h]@8
  float v30; // [sp+18h] [bp+4h]@8
  float v31; // [sp+18h] [bp+4h]@8
  float v32; // [sp+18h] [bp+4h]@8
  float v33; // [sp+18h] [bp+4h]@8
  float v34; // [sp+18h] [bp+4h]@8
  float v35; // [sp+18h] [bp+4h]@8
  float v36; // [sp+18h] [bp+4h]@8
  float v37; // [sp+18h] [bp+4h]@8
  float v38; // [sp+18h] [bp+4h]@8
  float v39; // [sp+18h] [bp+4h]@8

  LOBYTE(v3) = a1;
  v4 = a2;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !a3 )
  {
    if ( (_BYTE)v3 )
    {
      v12 = v4 + 4;
      v3 = (unsigned __int8)v3;
      do
      {
        v29 = *(_DWORD *)(v12 + 12);
        v13 = v29;
        BYTE1(v29) >>= 1;
        LOBYTE(v29) = (unsigned __int8)v29 >> 1;
        BYTE2(v29) = (unsigned __int8)(v13 >> 16) >> 1;
        j_gdi_pvg_begin(73);
        v14 = v29;
        j_gdi_pvg_color_u32(v29);
        sub_1008C2F0(*(float *)(v12 - 4), *(float *)v12);
        v30 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_1008C2F0(v30, *(float *)v12);
        j_gdi_pvg_color_u32(*(_DWORD *)(v12 + 12));
        v31 = *(float *)(v12 + 8) * 0.25 + *(float *)v12;
        sub_1008C2F0(*(float *)(v12 - 4), v31);
        v32 = *(float *)(v12 + 8) * 0.25 + *(float *)v12;
        v15 = v32;
        v33 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_1008C2F0(v33, v15);
        v34 = *(float *)(v12 + 8) * 0.75 + *(float *)v12;
        sub_1008C2F0(*(float *)(v12 - 4), v34);
        v35 = *(float *)(v12 + 8) * 0.75 + *(float *)v12;
        v16 = v35;
        v36 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_1008C2F0(v36, v16);
        j_gdi_pvg_color_u32(v14);
        v37 = *(float *)(v12 + 8) + *(float *)v12;
        sub_1008C2F0(*(float *)(v12 - 4), v37);
        v38 = *(float *)(v12 + 8) + *(float *)v12;
        v17 = v38;
        v39 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_1008C2F0(v39, v17);
        j_gdi_pvg_end();
        v12 += 20;
        --v3;
      }
      while ( v3 );
    }
    return j_gdi_pvg_disable(35);
  }
  if ( !(_BYTE)v3 )
    return j_gdi_pvg_disable(35);
  v5 = v4 + 4;
  v3 = (unsigned __int8)v3;
  do
  {
    v18 = *(_DWORD *)(v5 + 12);
    v6 = v18;
    BYTE1(v18) >>= 1;
    LOBYTE(v18) = (unsigned __int8)v18 >> 1;
    BYTE2(v18) = (unsigned __int8)(v6 >> 16) >> 1;
    j_gdi_pvg_begin(73);
    v7 = v18;
    j_gdi_pvg_color_u32(v18);
    sub_1008C2F0(*(float *)(v5 - 4), *(float *)v5);
    v19 = *(float *)(v5 + 8) + *(float *)v5;
    sub_1008C2F0(*(float *)(v5 - 4), v19);
    j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 12));
    v20 = *(float *)(v5 + 4) * 0.25 + *(float *)(v5 - 4);
    sub_1008C2F0(v20, *(float *)v5);
    v21 = *(float *)(v5 + 8) + *(float *)v5;
    v8 = v21;
    v22 = *(float *)(v5 + 4) * 0.25 + *(float *)(v5 - 4);
    sub_1008C2F0(v22, v8);
    v23 = *(float *)(v5 + 4) * 0.75 + *(float *)(v5 - 4);
    sub_1008C2F0(v23, *(float *)v5);
    v24 = *(float *)(v5 + 8) + *(float *)v5;
    v9 = v24;
    v25 = *(float *)(v5 + 4) * 0.75 + *(float *)(v5 - 4);
    sub_1008C2F0(v25, v9);
    j_gdi_pvg_color_u32(v7);
    v26 = *(float *)(v5 + 4) + *(float *)(v5 - 4);
    sub_1008C2F0(v26, *(float *)v5);
    v27 = *(float *)(v5 + 8) + *(float *)v5;
    v10 = v27;
    v28 = *(float *)(v5 + 4) + *(float *)(v5 - 4);
    sub_1008C2F0(v28, v10);
    j_gdi_pvg_end();
    v5 += 20;
    --v3;
  }
  while ( v3 );
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (1006A770) --------------------------------------------------------
void __usercall sub_1006A770(int a1@<ebx>, int a2@<esi>, char a3)
{
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  float v6; // [sp+8h] [bp-24h]@2
  float v7; // [sp+Ch] [bp-20h]@2
  int v8; // [sp+10h] [bp-1Ch]@2
  float v9; // [sp+14h] [bp-18h]@2
  int v10; // [sp+18h] [bp-14h]@2
  int v11; // [sp+1Ch] [bp-10h]@2
  float v12; // [sp+20h] [bp-Ch]@2
  float v13; // [sp+24h] [bp-8h]@2
  float v14; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a2 + 16) )
  {
    v12 = *(float *)(a2 + 40);
    v13 = *(float *)(a2 + 44);
    v6 = *(float *)a2;
    v7 = *(float *)(a2 + 4);
    v3 = sub_10065060(*(float *)(a2 + 48));
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    v9 = *(float *)(a2 + 48);
    v8 = v3;
    v10 = v4;
    v11 = v5;
    v14 = sub_1008D010(v3, a2 + 16, v9);
    if ( a3 )
      sub_10065B50(a1, a2 + 16, (int)&v6);
    else
      sub_10065B30(a1, a2 + 16, (int)&v6);
  }
}

//----- (1006A810) --------------------------------------------------------
int __usercall sub_1006A810@<eax>(int a1@<esi>, float a2, float a3, float a4, float a5, float a6)
{
  double v6; // st7@2
  float v7; // ST10_4@4
  float v9; // [sp+10h] [bp-28h]@2
  float v10; // [sp+14h] [bp-24h]@2
  float v11; // [sp+18h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@1
  float v13; // [sp+20h] [bp-18h]@1
  int v14; // [sp+24h] [bp-14h]@1
  int v15; // [sp+28h] [bp-10h]@1
  float v16; // [sp+2Ch] [bp-Ch]@2
  float v17; // [sp+30h] [bp-8h]@1
  float v18; // [sp+34h] [bp-4h]@1
  float v19; // [sp+4Ch] [bp+14h]@2
  float v20; // [sp+4Ch] [bp+14h]@2
  float v21; // [sp+4Ch] [bp+14h]@3
  float v22; // [sp+4Ch] [bp+14h]@3

  v17 = 0.5;
  v11 = a3;
  v13 = 12.0;
  v12 = sub_10065060(12.0);
  v14 = 0;
  v15 = -1;
  v18 = sub_1008D010(v12, a1, 12.0);
  sub_100690D0(a2, a3, a4, a5, -1);
  j_gdi_pvg_color_u32(-16777216);
  if ( LOBYTE(a6) )
  {
    v10 = a4 * 0.5 + a2;
    v16 = 0.5;
    j_gdi_pvg_begin(64);
    v19 = v10 - v18 * 0.5 - 3.0;
    sub_1008C2F0(v19, a3);
    v9 = a3;
    v20 = v18 * 0.5 + v10 + 3.0;
    v6 = v20;
  }
  else
  {
    v10 = a2 + 10.0 + 10.0;
    v16 = 0.0;
    j_gdi_pvg_begin(64);
    v21 = v10 - 3.0;
    sub_1008C2F0(v21, a3);
    v9 = a3;
    v22 = v10 + v18 + 3.0;
    v6 = v22;
  }
  v7 = v6;
  sub_1008C2F0(v7, v9);
  j_gdi_pvg_end();
  return sub_10065670(a1, (int)&v10);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (1006A990) --------------------------------------------------------
void __usercall sub_1006A990(int *a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8)
{
  double v8; // st7@1
  double v9; // st6@1
  double v10; // st7@2
  int v11; // esi@4
  long double v12; // st7@5
  float v13; // ST04_4@7
  float v14; // ST04_4@7
  int v15; // esi@8
  float v16; // [sp+10h] [bp+4h]@8
  float v17; // [sp+1Ch] [bp+10h]@2
  float v18; // [sp+1Ch] [bp+10h]@8
  float v19; // [sp+20h] [bp+14h]@4

  v8 = a6;
  v9 = a7;
  if ( a7 <= (double)a6 )
  {
    v17 = v9 * 0.01745329251994333;
    v10 = v8 * 0.01745329251994333;
  }
  else
  {
    v17 = v8 * 0.01745329251994333;
    v10 = 0.01745329251994333 * v9;
  }
  v19 = v10;
  v11 = 0;
  if ( v19 > (double)v17 )
  {
    v12 = v17;
    do
    {
      if ( v11 >= *a1 - 1 )
        break;
      v13 = cos(v12);
      *(float *)(a2 + 8 * v11) = v13 * a5 + a3;
      v14 = sin(v17);
      *(float *)(a2 + 8 * ++v11 - 4) = v14 * a5 + a4;
      v17 = v17 + a8;
      v12 = v17;
    }
    while ( v17 < (double)v19 );
  }
  v18 = cos(v19);
  *(float *)(a2 + 8 * v11) = v18 * a5 + a3;
  v16 = sin(v19);
  v15 = v11 + 1;
  *(float *)(a2 + 8 * v15 - 4) = v16 * a5 + a4;
  *a1 = v15;
}

//----- (1006AA90) --------------------------------------------------------
int __cdecl sub_1006AA90(int a1, char a2)
{
  return sub_1006A440(a2, a1, 0);
}

//----- (1006AAB0) --------------------------------------------------------
int __cdecl sub_1006AAB0(int a1)
{
  float v1; // ST34_4@1
  float v2; // ST38_4@1
  float v3; // ST2C_4@1
  float v4; // ST2C_4@1
  float v5; // ST34_4@1
  float v6; // ST2C_4@1
  float v7; // ST6C_4@1
  float v8; // ST34_4@1
  float v9; // ST30_4@1
  float v10; // ST38_4@1
  double v11; // ST54_8@1
  float v12; // ST38_4@1
  double v13; // st7@1
  float v14; // ST30_4@1
  float v15; // ST38_4@1
  double v16; // ST54_8@1
  float v17; // ST3C_4@1
  double v18; // st7@1
  float v19; // ST34_4@3
  char v20; // bl@1
  _DWORD *v21; // eax@3
  double v22; // st7@3
  float v23; // ST14_4@4
  double v24; // st7@4
  float v25; // ST2C_4@5
  double v27; // st7@6
  float v28; // ST64_4@6
  double v29; // st7@6
  float v30; // ST30_4@6
  double v31; // ST5C_8@6
  float v32; // ST0C_4@6
  float v33; // ST2C_4@6
  float v34; // ST2C_4@6
  float v35; // ST08_4@6
  float v36; // ST2C_4@6
  float v37; // ST2C_4@6
  double v38; // st7@7
  float v39; // ST2C_4@7
  double v40; // st7@7
  float v41; // ST34_4@7
  float v42; // ST38_4@7
  float v43; // ST2C_4@7
  float v44; // ST2C_4@7
  float v45; // ST6C_4@7
  float v46; // ST6C_4@7
  float v47; // ST0C_4@7
  float v48; // ST2C_4@7
  float v49; // ST2C_4@7
  float v50; // ST08_4@7
  float v51; // ST2C_4@7
  float v52; // ST2C_4@7
  double v53; // st7@8
  float v54; // ST2C_4@8
  double v55; // st7@8
  double v56; // ST6C_8@8
  float v57; // ST30_4@8
  double v58; // ST5C_8@8
  float v59; // ST2C_4@8
  float v60; // ST54_4@8
  float v61; // ST2C_4@8
  float v62; // ST34_4@8
  double v63; // ST64_8@8
  float v64; // ST30_4@8
  double v65; // ST5C_8@8
  float v66; // ST2C_4@8
  float v67; // ST44_4@8
  float v68; // ST2C_4@8
  float v69; // ST40_4@8
  float v70; // ST30_4@8
  float v71; // ST2C_4@8
  float v72; // ST4C_4@8
  float v73; // ST2C_4@8
  float v74; // ST48_4@8
  float v75; // ST30_4@9
  float v76; // ST2C_4@9
  float v77; // ST2C_4@9
  double v78; // st7@9
  double v79; // ST5C_8@9
  float v80; // ST2C_4@9
  double v81; // ST64_8@9
  float v82; // ST30_4@9
  float v83; // ST6C_4@9
  float v84; // ST6C_4@9
  float v85; // ST30_4@9
  float v86; // ST2C_4@9
  float v87; // ST2C_4@9
  double v88; // st7@14
  float v89; // ST2C_4@16
  float v90; // ST30_4@16
  float v91; // ST3C_4@16
  double v92; // ST5C_8@16
  float v93; // ST64_4@16
  float v94; // ST30_4@16
  float v95; // ST3C_4@16
  float v96; // ST64_4@16
  _DWORD *v97; // eax@20
  double v98; // st7@21
  float v99; // ST2C_4@21
  int v100; // edi@21
  float v101; // ST2C_4@21
  double v102; // st6@21
  double v103; // st7@21
  float v104; // ST6C_4@23
  _DWORD *v105; // eax@21
  int v106; // edi@22
  float v107; // ST3C_4@23
  float v108; // ST54_4@23
  float v109; // ST64_4@23
  float v110; // ST34_4@23
  double v111; // st6@23
  float v112; // ST44_4@23
  float v113; // ST40_4@23
  float v114; // ST30_4@25
  float v115; // ST2C_4@25
  float v116; // ST54_4@25
  float v117; // ST2C_4@25
  float v118; // ST34_4@25
  long double v119; // ST5C_8@25
  float v120; // ST2C_4@25
  double v121; // ST6C_8@25
  float v122; // ST44_4@25
  float v123; // ST2C_4@25
  double v124; // ST5C_8@25
  float v125; // ST40_4@25
  float v126; // ST30_4@25
  float v127; // ST2C_4@25
  float v128; // ST4C_4@25
  float v129; // ST2C_4@25
  float v130; // ST48_4@25
  float v131; // ST38_4@25
  float v132; // ST3C_4@25
  _DWORD *v133; // eax@25
  float v134; // ST34_4@26
  float v135; // ST30_4@26
  float v136; // ST2C_4@26
  double v137; // st7@26
  double v138; // ST54_8@26
  float v139; // ST2C_4@26
  double v140; // st7@26
  float v141; // ST30_4@26
  float v142; // ST2C_4@26
  double v143; // st7@26
  float v144; // ST2C_4@26
  double v145; // ST5C_8@26
  _DWORD *v146; // eax@26
  float v147; // ST2C_4@26
  float v148; // ST2C_4@26
  float v149; // ST34_4@27
  float v150; // ST30_4@27
  float v151; // ST2C_4@27
  double v152; // st7@27
  double v153; // ST54_8@27
  float v154; // ST2C_4@27
  double v155; // st7@27
  float v156; // ST30_4@27
  float v157; // ST2C_4@27
  double v158; // st7@27
  float v159; // ST2C_4@27
  double v160; // ST5C_8@27
  _DWORD *v161; // eax@27
  float v162; // ST2C_4@27
  float v163; // ST2C_4@27
  float v164; // ST30_4@28
  float v165; // ST3C_4@28
  float v166; // ST6C_4@28
  float v167; // ST64_4@28
  double v168; // st7@28
  float v169; // ST2C_4@28
  double v170; // st6@28
  float v171; // ST64_4@28
  float v172; // ST50_4@28
  float v173; // ST34_4@28
  float v174; // ST30_4@28
  float v175; // ST38_4@28
  double v176; // st7@28
  double v177; // ST54_8@28
  float v178; // ST4C_4@28
  float v179; // ST38_4@28
  double v180; // st7@28
  float v181; // ST48_4@28
  float v182; // ST44_4@28
  float v183; // ST40_4@28
  float v184; // ST30_4@28
  _DWORD *v185; // eax@28
  float v186; // ST38_4@28
  double v187; // ST5C_8@28
  float v188; // ST38_4@28
  double v189; // ST54_8@28
  float v190; // ST50_4@28
  float v191; // ST64_4@28
  float v192; // ST2C_4@28
  float v193; // ST2C_4@28
  float v194; // ST14_4@29
  float v195; // [sp+18h] [bp-73Ch]@3
  float v196; // [sp+18h] [bp-73Ch]@4
  float v197; // [sp+2Ch] [bp-728h]@1
  float v198; // [sp+2Ch] [bp-728h]@21
  float v199; // [sp+30h] [bp-724h]@21
  float v200; // [sp+34h] [bp-720h]@9
  float v201; // [sp+34h] [bp-720h]@16
  float v202; // [sp+38h] [bp-71Ch]@1
  float v203; // [sp+38h] [bp-71Ch]@16
  float v204; // [sp+3Ch] [bp-718h]@1
  float v205; // [sp+3Ch] [bp-718h]@16
  float v206; // [sp+40h] [bp-714h]@1
  float v207; // [sp+40h] [bp-714h]@9
  float v208; // [sp+40h] [bp-714h]@16
  float v209; // [sp+44h] [bp-710h]@1
  float v210; // [sp+44h] [bp-710h]@9
  float v211; // [sp+44h] [bp-710h]@16
  float v212; // [sp+48h] [bp-70Ch]@1
  float v213; // [sp+48h] [bp-70Ch]@9
  float v214; // [sp+48h] [bp-70Ch]@16
  float v215; // [sp+4Ch] [bp-708h]@1
  float v216; // [sp+4Ch] [bp-708h]@9
  float v217; // [sp+4Ch] [bp-708h]@16
  float v218; // [sp+50h] [bp-704h]@1
  float v219; // [sp+50h] [bp-704h]@21
  float v220; // [sp+54h] [bp-700h]@1
  float v221; // [sp+54h] [bp-700h]@9
  float v222; // [sp+54h] [bp-700h]@16
  float v223; // [sp+64h] [bp-6F0h]@1
  float v224; // [sp+6Ch] [bp-6E8h]@1
  float v225; // [sp+74h] [bp-6E0h]@6
  float v226; // [sp+78h] [bp-6DCh]@6
  float v227; // [sp+7Ch] [bp-6D8h]@6
  float v228; // [sp+80h] [bp-6D4h]@6
  float v229; // [sp+84h] [bp-6D0h]@6
  float v230; // [sp+88h] [bp-6CCh]@6
  float v231; // [sp+8Ch] [bp-6C8h]@6
  int v232; // [sp+90h] [bp-6C4h]@6
  float v233; // [sp+94h] [bp-6C0h]@6
  char v234; // [sp+750h] [bp-4h]@6

  v1 = *(float *)(a1 + 8);
  v2 = *(float *)(a1 + 16) * 0.01745329251994333;
  v3 = cos(v2);
  v223 = v3 * v1 + *(float *)a1;
  v4 = sin(v2);
  v218 = v4 * v1 + *(float *)(a1 + 4);
  v5 = v1 * 0.800000011920929 * 0.949999988079071;
  v6 = cos(v2);
  v197 = v6 * v5 + *(float *)a1;
  v7 = sin(v2);
  v224 = v7 * v5 + *(float *)(a1 + 4);
  v8 = *(float *)(a1 + 12) * 0.5;
  v9 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
  v10 = cos(v9);
  v11 = v10 * v8;
  v215 = v11 + *(float *)a1;
  v12 = sin(v9);
  v13 = v12 * v8;
  v212 = *(float *)(a1 + 4) + v13;
  v209 = v223 + v11;
  v206 = v13 + v218;
  v14 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
  v15 = cos(v14);
  v16 = v15 * v8;
  v202 = v16 + *(float *)a1;
  v17 = sin(v14);
  v18 = v17 * v8;
  v204 = *(float *)(a1 + 4) + v18;
  v220 = v223 + v16;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v20 = *(_BYTE *)(a1 + 28);
  switch ( v20 )
  {
    case 1:
      *(_DWORD *)(a1 + 32) = 65;
      goto LABEL_3;
    case 0:
LABEL_3:
      j_gdi_pvg_enable(34);
      v21 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v21);
      sub_1008C280(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      v19 = v18 + v218;
      v195 = v19;
      v22 = v220;
      goto LABEL_4;
    case 3:
      v25 = *(float *)(a1 + 8) - 5.0;
      sub_10067C30(
        *(float *)a1,
        *(float *)(a1 + 4),
        v25,
        0.0,
        *(float *)(a1 + 20),
        *(float *)(a1 + 16),
        *(_DWORD *)(a1 + 24));
      return j_gdi_pvg_disable(35);
    case 2:
      v27 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v232 = *(_DWORD *)(a1 + 24);
      v231 = v27;
      v234 = 0;
      v233 = 9.8999998e24;
      v230 = *(float *)(a1 + 16);
      v229 = *(float *)(a1 + 20);
      v28 = (*(float *)(a1 + 8) + *(float *)(a1 + 8)) * 0.800000011920929;
      v228 = v28;
      v227 = v28;
      v29 = 0.800000011920929 * *(float *)(a1 + 8);
      v225 = *(float *)a1 - v29;
      v226 = *(float *)(a1 + 4) - v29;
      sub_1006A190((int)&v225);
      sub_10067030((int)&v225);
      v30 = *(float *)(a1 + 16) * 0.01745329251994333;
      v31 = *(float *)(a1 + 8) - 5.0;
      v32 = v197;
      v33 = sin(v30);
      v34 = v33 * v31 + *(float *)(a1 + 4);
      v35 = v34;
      v36 = cos(v30);
      v37 = v36 * v31 + *(float *)a1;
      sub_100682A0(v37, v35, v32, v224, *(_DWORD *)(a1 + 24), 3.0);
      return j_gdi_pvg_disable(35);
    case 0xF:
      v38 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v232 = *(_DWORD *)(a1 + 24);
      v231 = v38;
      v234 = 1;
      v233 = 9.8999998e24;
      v230 = *(float *)(a1 + 16);
      v229 = *(float *)(a1 + 20);
      v39 = (*(float *)(a1 + 8) + *(float *)(a1 + 8)) * *(float *)(a1 + 12);
      v228 = v39;
      v227 = v39;
      v40 = *(float *)(a1 + 12) * *(float *)(a1 + 8);
      v225 = *(float *)a1 - v40;
      v226 = *(float *)(a1 + 4) - v40;
      sub_1006A190((int)&v225);
      sub_10067030((int)&v225);
      v41 = *(float *)(a1 + 12) * *(float *)(a1 + 8) * 0.949999988079071;
      v42 = *(float *)(a1 + 16) * 0.01745329251994333;
      v43 = cos(v42);
      v44 = v43 * v41 + *(float *)a1;
      v45 = sin(v42);
      v46 = v45 * v41 + *(float *)(a1 + 4);
      v47 = v44;
      v48 = sin(v42);
      v49 = v48 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v50 = v49;
      v51 = cos(v42);
      v52 = v51 * *(float *)(a1 + 8) + *(float *)a1;
      sub_100682A0(v52, v50, v47, v46, *(_DWORD *)(a1 + 24), 3.0);
      return j_gdi_pvg_disable(35);
    case 6:
      v53 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v232 = *(_DWORD *)(a1 + 24);
      v231 = v53;
      v234 = 0;
      v233 = 9.8999998e24;
      v230 = *(float *)(a1 + 16);
      v229 = *(float *)(a1 + 20);
      v54 = *(float *)(a1 + 8) * 1.799999952316284;
      v228 = v54;
      v227 = v54;
      v55 = *(float *)(a1 + 8) * 0.8999999761581421;
      v225 = *(float *)a1 - v55;
      v226 = *(float *)(a1 + 4) - v55;
      sub_1006A190((int)&v225);
      sub_10067030((int)&v225);
      v56 = (*(float *)(a1 + 16) + *(float *)(a1 + 20)) * 0.5;
      v57 = v56 * 0.01745329251994333;
      v58 = *(float *)(a1 + 8) * 0.8799999952316284;
      v59 = cos(v57);
      v60 = v59 * v58 + *(float *)a1;
      v61 = sin(v57);
      v62 = v61 * v58 + *(float *)(a1 + 4);
      v63 = (*(float *)(a1 + 16) - *(float *)(a1 + 20)) * 0.25;
      v64 = (v56 - v63) * 0.01745329251994333;
      v65 = *(float *)(a1 + 8) * 0.75;
      v66 = cos(v64);
      v67 = v66 * v65 + *(float *)a1;
      v68 = sin(v64);
      v69 = v68 * v65 + *(float *)(a1 + 4);
      v70 = (v63 + v56) * 0.01745329251994333;
      v71 = cos(v70);
      v72 = v71 * v65 + *(float *)a1;
      v73 = sin(v70);
      v74 = v73 * v65 + *(float *)(a1 + 4);
      j_gdi_pvg_begin(69);
      j_gdi_pvg_color_u32(-14671840);
      sub_1008C2F0(v60, v62);
      sub_1008C2F0(v67, v69);
      sub_1008C2F0(v72, v74);
      j_gdi_pvg_end();
      return j_gdi_pvg_disable(35);
    case 8:
    case 0xD:
      v75 = *(float *)(a1 + 16) * 0.01745329251994333;
      v76 = cos(v75);
      v221 = v76 * *(float *)(a1 + 8) + *(float *)a1;
      v77 = sin(v75);
      v200 = v77 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v78 = *(float *)(a1 + 12);
      v79 = *(float *)(a1 + 8) - v78;
      v80 = atan(v78 / (v79 + v79));
      v81 = *(float *)(a1 + 16) * 0.01745329238474369;
      v82 = v81 + v80;
      v83 = cos(v82);
      v210 = v83 * v79 + *(float *)a1;
      v84 = sin(v82);
      v207 = v84 * v79 + *(float *)(a1 + 4);
      v85 = v81 - v80;
      v86 = cos(v85);
      v216 = v86 * v79 + *(float *)a1;
      v87 = sin(v85);
      v213 = v87 * v79 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(35);
      j_gdi_pvg_enable(38);
      if ( *(_BYTE *)(a1 + 28) == 13 )
      {
        sub_1008C110(2.5);
        j_gdi_pvg_begin(66);
        j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
        sub_1008C2F0(v221, v200);
        sub_1008C2F0(v210, v207);
        sub_1008C2F0(v216, v213);
        j_gdi_pvg_end();
        sub_1008C110(1.0);
      }
      else
      {
        j_gdi_pvg_begin(68);
        j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
        sub_1008C2F0(v221, v200);
        sub_1008C2F0(v210, v207);
        sub_1008C2F0(v216, v213);
        j_gdi_pvg_end();
        j_gdi_pvg_begin(66);
        j_gdi_pvg_color_u32(-16777216);
        sub_1008C2F0(v221, v200);
        sub_1008C2F0(v210, v207);
        sub_1008C2F0(v216, v213);
        j_gdi_pvg_end();
      }
      j_gdi_pvg_disable(38);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 4:
    case 5:
    case 0xE:
      if ( 0.0 == *(float *)(a1 + 20) )
        v88 = 5.0;
      else
        v88 = *(float *)(a1 + 20);
      v89 = v88;
      v90 = (*(float *)(a1 + 16) - v89) * 0.01745329251994333;
      v91 = cos(v90);
      v92 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
      v222 = v92 * v91 + *(float *)a1;
      v93 = sin(v90);
      v201 = v92 * v93 + *(float *)(a1 + 4);
      v211 = v91 * *(float *)(a1 + 8) + *(float *)a1;
      v208 = v93 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v94 = (*(float *)(a1 + 16) + v89) * 0.01745329251994333;
      v95 = cos(v94);
      v217 = v95 * *(float *)(a1 + 8) + *(float *)a1;
      v96 = sin(v94);
      *(_DWORD *)(a1 + 32) = 5;
      v214 = v96 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v203 = v95 * v92 + *(float *)a1;
      v205 = v96 * v92 + *(float *)(a1 + 4);
      if ( v20 == 5 )
      {
        *(_DWORD *)(a1 + 32) = 56;
      }
      else if ( v20 == 14 )
      {
        *(_DWORD *)(a1 + 32) = 112;
      }
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v97 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v97);
      sub_1008C280(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      sub_1008C2F0(v222, v201);
      sub_1008C220(0.0, 1.0);
      sub_1008C2F0(v211, v208);
      sub_1008C220(1.0, 1.0);
      sub_1008C2F0(v217, v214);
      sub_1008C220(1.0, 0.0);
      sub_1008C2F0(v203, v205);
      j_gdi_pvg_end();
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 7:
      v98 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v99 = v98;
      v100 = (signed int)COERCE_FLOAT(LODWORD(v99) & 0x7FFFFFFF) / 5 + 1;
      *(_DWORD *)(a1 + 32) = 66;
      v101 = (double)v100;
      v102 = v98 / v101;
      v103 = v101;
      v198 = v102 * 0.01745329238474369;
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v105 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v105);
      sub_1008C280(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(73);
      v199 = *(float *)(a1 + 20) * 0.01745329238474369;
      v219 = 0.0;
      if ( v100 >= 0 )
      {
        v106 = v100 + 1;
        do
        {
          v107 = cos(v199);
          v108 = v107 * *(float *)(a1 + 8) + *(float *)a1;
          v109 = sin(v199);
          v110 = v109 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
          v111 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
          v112 = v107 * v111 + *(float *)a1;
          v113 = v109 * v111 + *(float *)(a1 + 4);
          sub_1008C220(v219, 0.0);
          sub_1008C2F0(v108, v110);
          sub_1008C220(v219, 1.0);
          sub_1008C2F0(v112, v113);
          --v106;
          v199 = v198 + v199;
          v104 = 1.0 / v103;
          v219 = v219 + v104;
        }
        while ( v106 );
      }
      j_gdi_pvg_end();
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 9:
      v114 = (*(float *)(a1 + 16) - *(float *)(a1 + 20)) * 0.01745329251994333;
      v115 = cos(v114);
      v116 = v115 * *(float *)(a1 + 8) + *(float *)a1;
      v117 = sin(v114);
      v118 = v117 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v119 = *(float *)(a1 + 16) * 0.01745329251994333;
      v120 = cos(v119);
      v121 = v120 * *(float *)(a1 + 12);
      v122 = v121 + v116;
      v123 = sin(v119);
      v124 = v123 * *(float *)(a1 + 12);
      v125 = v124 + v118;
      v126 = (*(float *)(a1 + 16) + *(float *)(a1 + 20)) * 0.01745329251994333;
      v127 = cos(v126);
      v128 = v127 * *(float *)(a1 + 8) + *(float *)a1;
      v129 = sin(v126);
      v130 = v129 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v131 = v128 + v121;
      v132 = v130 + v124;
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v133 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v133);
      sub_1008C280(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      sub_1008C2F0(v116, v118);
      sub_1008C220(0.0, 1.0);
      sub_1008C2F0(v122, v125);
      sub_1008C220(1.0, 1.0);
      sub_1008C2F0(v131, v132);
      sub_1008C220(1.0, 0.0);
      sub_1008C2F0(v128, v130);
      j_gdi_pvg_end();
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 0xA:
      v134 = *(float *)(a1 + 12);
      v135 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v136 = cos(v135);
      v137 = v136 * v134;
      v138 = v137;
      v215 = v137 + *(float *)a1;
      v139 = sin(v135);
      v140 = v139 * v134;
      v212 = *(float *)(a1 + 4) + v140;
      v209 = v223 + v138;
      v206 = v140 + v218;
      v141 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      v142 = cos(v141);
      v143 = v142 * v134;
      v202 = v143 + *(float *)a1;
      v144 = sin(v141);
      *(_DWORD *)(a1 + 32) = 68;
      v145 = v144 * v134;
      v204 = v145 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(34);
      v146 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v146);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      v147 = v218 + v145;
      v195 = v147;
      v148 = v223 + v143;
      v22 = v148;
      goto LABEL_4;
    case 0xB:
      v149 = *(float *)(a1 + 12);
      v150 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v151 = cos(v150);
      v152 = v151 * v149;
      v153 = v152;
      v215 = v152 + *(float *)a1;
      v154 = sin(v150);
      v155 = v154 * v149;
      v212 = *(float *)(a1 + 4) + v155;
      v209 = v223 + v153;
      v206 = v155 + v218;
      v156 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      v157 = cos(v156);
      v158 = v157 * v149;
      v202 = v158 + *(float *)a1;
      v159 = sin(v156);
      *(_DWORD *)(a1 + 32) = 69;
      v160 = v159 * v149;
      v204 = v160 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(34);
      v161 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v161);
      sub_1008C280(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      v162 = v218 + v160;
      v195 = v162;
      v163 = v223 + v158;
      v22 = v163;
LABEL_4:
      v23 = v22;
      sub_1008C2F0(v23, v195);
      sub_1008C220(0.0, 1.0);
      sub_1008C2F0(v209, v206);
      sub_1008C220(1.0, 1.0);
      sub_1008C2F0(v215, v212);
      sub_1008C220(1.0, 0.0);
      v196 = v204;
      v24 = v202;
      goto LABEL_29;
    case 0xC:
      v164 = *(float *)(a1 + 16) * 0.01745329251994333;
      v165 = cos(v164);
      v166 = v165 * *(float *)(a1 + 8) + *(float *)a1;
      v167 = sin(v164);
      v168 = v167;
      v169 = v167 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v170 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
      v171 = v165 * v170 + *(float *)a1;
      v172 = v168 * v170 + *(float *)(a1 + 4);
      v173 = *(float *)(a1 + 12) * 0.015625 * 16.0;
      v174 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v175 = cos(v174);
      v176 = v175 * v173;
      v177 = v176;
      v178 = v176 + v166;
      v179 = sin(v174);
      v180 = v179 * v173;
      *(_DWORD *)(a1 + 32) = 68;
      v181 = v169 + v180;
      v182 = v171 + v177;
      v183 = v180 + v172;
      v184 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      j_gdi_pvg_enable(34);
      v185 = (_DWORD *)sub_1008CC80(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v185);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_1008C220(0.0, 0.0);
      v186 = sin(v184);
      v187 = v186 * v173;
      v188 = cos(v184);
      v189 = v188 * v173;
      v190 = v172 + v187;
      v191 = v189 + v171;
      sub_1008C2F0(v191, v190);
      sub_1008C220(0.0, 1.0);
      sub_1008C2F0(v182, v183);
      sub_1008C220(1.0, 1.0);
      sub_1008C2F0(v178, v181);
      sub_1008C220(1.0, 0.0);
      v192 = v169 + v187;
      v196 = v192;
      v193 = v166 + v189;
      v24 = v193;
LABEL_29:
      v194 = v24;
      sub_1008C2F0(v194, v196);
      j_gdi_pvg_end();
      j_gdi_pvg_disable(34);
      break;
    default:
      return j_gdi_pvg_disable(35);
  }
  return j_gdi_pvg_disable(35);
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008BF60: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 1008C020: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 1008C030: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (1006BEC0) --------------------------------------------------------
void __cdecl sub_1006BEC0(int a1, int a2)
{
  sub_1006A770(a1, a2, 1);
}

//----- (1006BEE0) --------------------------------------------------------
int __cdecl sub_1006BEE0(int a1, float a2, float a3, float a4, float a5)
{
  return sub_1006A810(a1, a2, a3, a4, a5, 0.0);
}

//----- (1006BF20) --------------------------------------------------------
int __cdecl sub_1006BF20(int a1, float a2, float a3, float a4, float a5)
{
  return sub_1006A810(a1, a2, a3, a4, a5, COERCE_FLOAT(1));
}

//----- (1006BF60) --------------------------------------------------------
int __cdecl sub_1006BF60(int a1, char a2)
{
  return sub_1006A440(a2, a1, 1);
}

//----- (1006BF80) --------------------------------------------------------
void __cdecl sub_1006BF80(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  sub_1006A990((int *)a7, a6, a1, a2, a3, a4, a5, 0.1308997);
}

//----- (1006BFD0) --------------------------------------------------------
void __usercall sub_1006BFD0(int a1@<edx>, int a2@<ecx>, char a3)
{
  int v3; // esi@1
  int v4; // eax@1
  double v5; // st7@1
  int v6; // ebx@1
  float v7; // [sp+8h] [bp-38h]@1
  float v8; // [sp+Ch] [bp-34h]@1
  int v9; // [sp+10h] [bp-30h]@1
  int v10; // [sp+14h] [bp-2Ch]@1
  char v11; // [sp+18h] [bp-28h]@1
  float v12; // [sp+30h] [bp-10h]@1
  float v13; // [sp+34h] [bp-Ch]@1
  float v14; // [sp+38h] [bp-8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 8);
  v7 = *(float *)a1;
  v5 = *(float *)(a1 + 4);
  v9 = v4;
  v8 = v5;
  v6 = a2;
  v10 = *(_DWORD *)(a1 + 12);
  strncpy(&v11, (const char *)(a1 + 16), 7u);
  v12 = *(float *)(v3 + 24);
  v13 = *(float *)(v3 + 28);
  v14 = *(float *)(v3 + 32);
  sub_1006A770(v6, (int)&v7, a3);
}

//----- (1006C050) --------------------------------------------------------
void __cdecl sub_1006C050(int a1, int a2)
{
  sub_1006BFD0(a2, a1, 0);
}

//----- (1006C070) --------------------------------------------------------
void __cdecl sub_1006C070(int a1, int a2)
{
  sub_1006BFD0(a2, a1, 1);
}

//----- (1006C090) --------------------------------------------------------
void __cdecl sub_1006C090(int a1, int a2)
{
  switch ( *(_BYTE *)(a2 + 62) )
  {
    case 1:
      sub_10067A90(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1006C050(a1, a2 + 16);
      break;
    case 2:
      sub_10069450(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1006C050(a1, a2 + 16);
      break;
    case 3:
      sub_10068550(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1006C050(a1, a2 + 16);
      break;
    default:
      sub_10069E40(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1006C050(a1, a2 + 16);
      break;
  }
}

//----- (1006C1B0) --------------------------------------------------------
char __thiscall sub_1006C1B0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_101E05B8 = sub_10052210(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101E05C0, 0, 0x1540u);
  memset(&unk_101E1B00, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_101E05C0;
  do
  {
    sub_10081090(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_101E1B00 );
  v3 = 0;
  v4 = &unk_101E1B00;
  do
  {
    result = sub_10081110(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_101E34B0 );
  return result;
}
// 101E05B8: using guessed type int dword_101E05B8;
// 101E34B0: using guessed type int dword_101E34B0;

//----- (1006C240) --------------------------------------------------------
char __cdecl sub_1006C240(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101E05B8 != 1379255385;
  v7 = 0;
  v8 = dword_101E05B8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1008CA00(86, 10);
      memset((char *)&unk_101E05C0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10081090(a1, (int)&unk_101E05C0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_101E0898[v6] == a2 || byte_101E0899[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1008C9D0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E05B8: using guessed type int dword_101E05B8;

//----- (1006C300) --------------------------------------------------------
char __cdecl sub_1006C300(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101E05B8 != 1379255385;
  v7 = 0;
  v8 = dword_101E05B8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1008CA00(86, 10);
      memset((char *)&unk_101E05C0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10081090(a1, (int)&unk_101E05C0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_101E08B8[v6] == a2 || byte_101E08B9[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1008C9D0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E05B8: using guessed type int dword_101E05B8;

//----- (1006C3C0) --------------------------------------------------------
char __cdecl sub_1006C3C0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1006C240(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1006C3F0) --------------------------------------------------------
char __cdecl sub_1006C3F0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1006C300(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1006C420) --------------------------------------------------------
char __cdecl sub_1006C420(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10080E20(a1, &v5, &v4) && sub_100727A0(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_1008CB00(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 1006C420: using guessed type char var_408[1028];

//----- (1006C4C0) --------------------------------------------------------
char __cdecl sub_1006C4C0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10081530(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10081330(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_100813B0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10081430(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_100814B0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1006C5D0) --------------------------------------------------------
int __cdecl sub_1006C5D0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_100F32B8, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100F32BC[2 * v1];
  }
  return result;
}
// 100F32BC: using guessed type int dword_100F32BC[];

//----- (1006C620) --------------------------------------------------------
bool __cdecl sub_1006C620(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (1006C650) --------------------------------------------------------
int __cdecl sub_1006C650(unsigned __int8 a1)
{
  return (int)*(&off_100F3A70 + 2 * a1);
}
// 100F3A70: using guessed type void *off_100F3A70;

//----- (1006C660) --------------------------------------------------------
int __cdecl sub_1006C660(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_1006CCC0(a1, a2);
  return sub_1006C650(v2);
}

//----- (1006C690) --------------------------------------------------------
char *__cdecl sub_1006C690(unsigned int a1, float *a2)
{
  return off_100F3A74[2 * (unsigned __int8)sub_1006CCC0(a1, a2)];
}
// 100F3A74: using guessed type char *off_100F3A74[7];

//----- (1006C6B0) --------------------------------------------------------
int __cdecl sub_1006C6B0(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1006C700) --------------------------------------------------------
void sub_1006C700()
{
  dword_1031FB40 = -15;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006C710) --------------------------------------------------------
signed int sub_1006C710()
{
  return sub_1008D490((int)&off_100F3C80);
}
// 100F3C80: using guessed type char *off_100F3C80;

//----- (1006C720) --------------------------------------------------------
char __usercall sub_1006C720@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_1031FB40;
  v3 = *(_WORD *)(dword_1031FB40 + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_1031FB40 + 1296) )
    {
      v4 = sub_100815D0(*(_DWORD *)(dword_1031FB40 + 1292));
      v2 = dword_1031FB40;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006C790) --------------------------------------------------------
signed int sub_1006C790()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_1006C710() )
    v0 = *(_BYTE *)(dword_1031FB40 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006C7C0) --------------------------------------------------------
bool __cdecl sub_1006C7C0(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_1008CA60(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_1006C710() )
  {
    sub_1008C850(101, 10000);
    v3 = 0.0;
    v4 = dword_1031FB40;
    v2 = *(_WORD *)(dword_1031FB40 + 1456) > 1u;
    if ( *(_BYTE *)(dword_1031FB40 + 1296) )
    {
      v14 = sub_100815D0(*(_DWORD *)(dword_1031FB40 + 1292));
      v4 = dword_1031FB40;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_1006C6B0(6.2831853071796, -6.2831853071796);
      sub_1006C6B0(6.2831853071796, -6.2831853071796);
      sub_10095C80(v14, dword_1031FB40 + 1512, (int)&v17);
      v4 = dword_1031FB40;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_10095C50((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_1031FB40;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_1031FB40 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_1008C830(101);
    sub_10074750(a2);
  }
  return v2;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006C9E0) --------------------------------------------------------
char __cdecl sub_1006C9E0(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1006C710() )
  {
    sub_1008C850(101, 60000);
    v1 = sub_1006C720(a1);
    if ( v1 )
      *a1 = *(float *)(dword_1031FB40 + 1440) + *a1;
    sub_1008C830(101);
  }
  return v1;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006CA40) --------------------------------------------------------
bool __cdecl sub_1006CA40(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_1006C710() )
  {
    sub_1008C850(101, 60000);
    v2 = dword_1031FB40;
    if ( *(_BYTE *)(dword_1031FB40 + 1451) )
    {
      *a1 = *(float *)(dword_1031FB40 + 1480);
      v2 = dword_1031FB40;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_1008C830(101);
  }
  return v1;
}
// 1031FB40: using guessed type int dword_1031FB40;

//----- (1006CAA0) --------------------------------------------------------
char __cdecl sub_1006CAA0(unsigned __int16 a1, int a2, char a3)
{
  int v3; // ecx@0
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v3;
  result = 31;
  BYTE3(v5) = 31;
  switch ( a1 )
  {
    case 0x1Au:
      if ( a3 )
      {
        sub_1008D070(44, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10051C20((void *)a1);
      }
      break;
    case 0u:
    case 0x26u:
    case 0x2Bu:
      if ( a3 )
      {
        sub_1008D070(77, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10051C50((void *)a1);
      }
      break;
    case 0x30u:
    case 0x31u:
      result = 18;
      break;
    case 8u:
    case 9u:
      result = 32;
      break;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( a3 )
      {
        sub_1008D070(17, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = 33;
      }
      break;
    case 4u:
    case 5u:
      result = sub_10051D70();
      break;
    case 0x11u:
    case 0x12u:
    case 0x13u:
      if ( a3 )
      {
        sub_1008D070(14, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10051F50(a1);
      }
      break;
    case 0x14u:
    case 0x15u:
      result = 39;
      break;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( a3 )
      {
        sub_1008D070(45, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10052030((void *)a1);
      }
      break;
    case 0x1Eu:
    case 0x1Fu:
      if ( a3 )
      {
        sub_1008D070(15, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10051D20(a1);
      }
      break;
    case 0x20u:
    case 0x21u:
      if ( a3 )
      {
        sub_1008D070(16, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10051C80(a1);
      }
      break;
    case 0x22u:
    case 0x23u:
      sub_1008D070(67, (_BYTE *)&v5 + 3);
      result = BYTE3(v5);
      break;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      result = 0;
      break;
    case 6u:
    case 7u:
      result = 34;
      break;
    case 0x24u:
    case 0x25u:
      result = 41;
      break;
    case 0x29u:
      result = 23;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 0x2Du:
    case 0x2Eu:
      result = 5;
      break;
    case 0x2Fu:
      result = 51;
      break;
    case 0x32u:
      if ( a3 )
      {
        sub_1008D070(136, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10052060(a1);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (1006CCA0) --------------------------------------------------------
char __cdecl sub_1006CCA0(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1006CCC0) --------------------------------------------------------
char __cdecl sub_1006CCC0(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_1008D070(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051C20((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_1008D070(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051C50((void *)31);
      }
      break;
    case 3:
      result = sub_10051C50((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_10051C50((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_10051EF0((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_1008D070(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_10051D70();
      break;
    case 15:
      if ( v4 )
      {
        sub_1008D070(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051F20((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_1008D070(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051F50(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_1008D070(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_10052030((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_1008D070(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051D20(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_1006CCC0(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_1006CCC0(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_1006CCC0(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_1006CCC0(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_1006CCC0(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_1006CCC0(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_1008D070(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_10051C80(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_1008DED0();
      result = sub_1006CCA0(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_10052060(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_10052060(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (1006D0E0) --------------------------------------------------------
double __cdecl sub_1006D0E0(int a1, unsigned __int16 a2, char a3, char *a4)
{
  unsigned __int16 v4; // si@1
  char v5; // al@1
  double v6; // st7@3
  double result; // st7@16
  int v8; // eax@22
  int v9; // eax@23
  int v10; // eax@29
  int v11; // eax@30
  int v12; // eax@39
  int v13; // eax@40
  int v14; // eax@46
  int v15; // eax@47
  float v16; // [sp+4h] [bp-4h]@1

  v16 = 1.0;
  v4 = a2;
  v5 = sub_1006CAA0(a2, 0, a3);
  *a4 = v5;
  switch ( v4 )
  {
    case 0u:
    case 0x1Au:
    case 0x26u:
    case 0x2Bu:
    case 0x30u:
    case 0x31u:
      switch ( v5 )
      {
        case 0x12:
          v6 = 39.370079;
          goto LABEL_64;
        case 0xC:
          v6 = 3.2808399;
          goto LABEL_64;
        case 0x1E:
          v6 = 0.00053995679;
          goto LABEL_64;
        case 0x15:
          goto LABEL_63;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 8u:
    case 9u:
      v6 = 100.0;
      goto LABEL_64;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( v5 == 40 )
        v6 = 0.0000099999997;
      else
        v6 = 0.0001450377;
      goto LABEL_64;
    case 4u:
    case 5u:
      v6 = 0.00029530001;
      goto LABEL_64;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( v5 == 28 )
        v6 = 60.0;
      else
        v6 = 196.85039;
      goto LABEL_64;
    case 0x11u:
    case 0x12u:
      if ( v5 != 10 || *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      sub_10081620((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x13u:
      if ( v5 != 10 )
        goto LABEL_65;
      v6 = 1.8;
      goto LABEL_64;
    case 0x1Eu:
    case 0x1Fu:
      switch ( v5 )
      {
        case 0xD:
          v6 = 0.26417205;
          goto LABEL_64;
        case 0x10:
          v6 = 0.21997361;
          goto LABEL_64;
        case 0x13:
          v8 = (unsigned __int8)sub_10051CF0((void *)v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                v6 = 0.77890778;
              else
                v6 = 0.84999973;
            }
            else
            {
              v6 = 0.80407244;
            }
          }
          else
          {
            v6 = 0.71895844;
          }
          goto LABEL_64;
        case 0x18:
          v10 = (unsigned __int8)sub_10051CF0((void *)v4);
          if ( (_BYTE)v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
                v6 = 1.7171981;
              else
                v6 = 1.8756201;
            }
            else
            {
              v6 = 1.7726756;
            }
          }
          else
          {
            v6 = 1.5850322;
          }
          goto LABEL_64;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 0x20u:
    case 0x21u:
      switch ( v5 )
      {
        case 0xE:
          v6 = 951.01935;
          break;
        case 0x11:
          v6 = 791.90497;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10051CF0((void *)v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
                v6 = 2804.0679;
              else
                v6 = 3059.999;
            }
            else
            {
              v6 = 2894.6609;
            }
          }
          else
          {
            v6 = 2588.2505;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10051CF0((void *)v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
                v6 = 6181.9131;
              else
                v6 = 6752.2324;
            }
            else
            {
              v6 = 6381.6323;
            }
          }
          else
          {
            v6 = 5706.1162;
          }
          break;
        default:
          v6 = 3600.0;
          break;
      }
      goto LABEL_64;
    case 0x22u:
    case 0x23u:
      if ( v5 == 45 )
        v6 = 0.0020439588;
      else
        v6 = 0.0023521457;
      goto LABEL_64;
    case 0x28u:
      v6 = 0.73756248;
      goto LABEL_64;
    case 0x29u:
      v6 = 1.9438444;
      goto LABEL_64;
    case 0x2Du:
    case 0x2Eu:
      v6 = 57.29578;
      goto LABEL_64;
    case 0x2Fu:
      v6 = 61.023743;
      goto LABEL_64;
    case 0x32u:
      if ( v5 == 19 )
LABEL_63:
        v6 = 0.001;
      else
        v6 = 0.0022046;
LABEL_64:
      v16 = v6;
LABEL_65:
      if ( *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      *(float *)&a1 = *(float *)&a1 * v16;
      result = *(float *)&a1;
      break;
    default:
LABEL_67:
      result = *(float *)&a1;
      break;
  }
  return result;
}

//----- (1006D4B0) --------------------------------------------------------
double __cdecl sub_1006D4B0(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_1006CCC0(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_10081620((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_1006DAE0(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (1006DAE0) --------------------------------------------------------
double __cdecl sub_1006DAE0(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_1006CCC0(a2, 0);
  if ( v3 == 4 )
    sub_10051A40("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 27:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 10:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 11:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 13:
    case 14:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 12:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 15:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 20:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 16:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_10081640((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 17:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 21:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 36:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_1006D4B0(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 22:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_10051CF0(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 32:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 37:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (1006E1D0) --------------------------------------------------------
char __cdecl sub_1006E1D0(float a1, int a2, char a3, int a4)
{
  char v4; // bl@1
  int v5; // ebp@1
  double v6; // st6@1
  unsigned __int8 v7; // dl@4
  int v8; // ecx@5
  int v9; // ecx@17
  bool v10; // zf@17
  int v11; // ebp@19
  char v13; // [sp+13h] [bp-1h]@1

  v4 = *(_BYTE *)(a2 + 4);
  v13 = 0;
  v5 = sub_1008C780();
  v6 = a1;
  if ( a1 == 9.8999998e24 )
  {
    v4 = 10;
    v13 = 10;
  }
  else if ( *(_BYTE *)(a4 + 24) )
  {
    v4 = *(_BYTE *)a4;
    v13 = *(_BYTE *)(a4 + 12);
  }
  else
  {
    v7 = 1;
    if ( (unsigned __int8)a3 > 1u )
    {
      v8 = a2;
      do
      {
        if ( 9.8999998e24 != *(float *)(v8 + 8)
          && (*(float *)v8 < (double)*(float *)(v8 + 8) && *(float *)v8 < v6
           || *(float *)v8 > (double)*(float *)(v8 + 8) && *(float *)v8 > v6) )
        {
          v4 = *(_BYTE *)(v8 + 12);
          v13 = v7;
        }
        ++v7;
        v8 += 8;
      }
      while ( v7 < (unsigned __int8)a3 );
    }
  }
  if ( v4 != *(_BYTE *)a4 )
  {
    *(_DWORD *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 4) = v5;
  }
  v9 = v5 - *(_DWORD *)(a4 + 4);
  v10 = v13 == *(_BYTE *)(a4 + 12);
  *(_BYTE *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v9;
  if ( !v10 )
  {
    *(_DWORD *)(a4 + 20) = 0;
    *(_DWORD *)(a4 + 16) = v5;
  }
  v11 = v5 - *(_DWORD *)(a4 + 16);
  *(_BYTE *)(a4 + 12) = v13;
  *(_DWORD *)(a4 + 20) = v11;
  return v4;
}

//----- (1006E2C0) --------------------------------------------------------
void __cdecl sub_1006E2C0(char a1, _DWORD *a2, _DWORD *a3, char a4)
{
  int v4; // eax@2

  if ( !a4 )
  {
    v4 = 8 * sub_1006E440(&a1, 1u, (int)&unk_100F4920, 32, 20, 0);
    *a2 = dword_100F4934[v4];
    *a3 = dword_100F4938[v4];
  }
}
// 100F4934: using guessed type int dword_100F4934[];
// 100F4938: using guessed type int dword_100F4938[];

//----- (1006E300) --------------------------------------------------------
char __cdecl sub_1006E300(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_1006E440(&a1, 1u, (int)&unk_100F4920, 32, 20, 0);
    v7 = *(int *)((char *)&dword_100F493C + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_102BA90E )
    {
      *a2 = *(int *)((char *)&dword_100F492C + v5);
      v5 = *(int *)((char *)&dword_100F4930 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_100F4930 + v5);
      v8 = *(int *)((char *)&dword_100F492C + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 100F492C: using guessed type int dword_100F492C;
// 100F4930: using guessed type int dword_100F4930;
// 100F493C: using guessed type int dword_100F493C;
// 102BA90E: using guessed type char byte_102BA90E;

//----- (1006E390) --------------------------------------------------------
char __cdecl sub_1006E390(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_1006E440(&a1, 1u, (int)&unk_100F4920, 32, 20, 0);
    v7 = *(int *)((char *)&dword_100F493C + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_102BA90E )
    {
      *a2 = *(int *)((char *)&dword_100F4924 + v5);
      v5 = *(int *)((char *)&dword_100F4928 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_100F4928 + v5);
      v8 = *(int *)((char *)&dword_100F4924 + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 100F4924: using guessed type int dword_100F4924;
// 100F4928: using guessed type int dword_100F4928;
// 100F493C: using guessed type int dword_100F493C;
// 102BA90E: using guessed type char byte_102BA90E;

//----- (1006E420) --------------------------------------------------------
int __cdecl sub_1006E420(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 12) = 10;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)a1 = 10;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (1006E440) --------------------------------------------------------
int __cdecl sub_1006E440(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1006E5D0) --------------------------------------------------------
int __cdecl sub_1006E5D0(unsigned __int8 a1)
{
  int result; // eax@2
  int v2[12]; // [sp+4h] [bp-60h]@4
  int v3[12]; // [sp+34h] [bp-30h]@6

  if ( a1 < 3u )
  {
    if ( a1 )
      v2[4 * a1] = 0x7FFFFFFF;
    else
      v2[0] = 0;
    sub_1008CAC0(2026, v3, 48, v2);
    result = v3[4 * a1];
  }
  else
  {
    result = 0x7FFFFFFF;
  }
  return result;
}
// 1006E5D0: using guessed type int var_60[12];
// 1006E5D0: using guessed type int var_30[12];

//----- (1006E630) --------------------------------------------------------
bool __thiscall sub_1006E630(void *this)
{
  return sub_100521D0(this) == 0;
}

//----- (1006E640) --------------------------------------------------------
int __cdecl sub_1006E640(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_1031F2AC)();
  *a1 = result;
  return result;
}
// 1031F2AC: using guessed type int dword_1031F2AC;

//----- (1006E660) --------------------------------------------------------
unsigned int __cdecl sub_1006E660(signed int *a1, int a2)
{
  signed int v2; // ecx@1
  unsigned int result; // eax@3

  v2 = a2 + (*(int (**)(void))dword_1031F2AC)();
  if ( v2 < 0 )
  {
    v2 += 86400 - 86400 * (v2 / 86400);
LABEL_3:
    result = (unsigned int)a1;
    *a1 = v2;
    return result;
  }
  if ( (unsigned int)v2 <= 0x15180 )
    goto LABEL_3;
  result = 86400
         * (((signed int)(((unsigned __int64)(1037155065i64 * v2) >> 32) - v2) >> 16)
          + ((unsigned int)(((unsigned __int64)(1037155065i64 * v2) >> 32) - v2) >> 31));
  *a1 = result + v2;
  return result;
}
// 1031F2AC: using guessed type int dword_1031F2AC;

//----- (1006E6D0) --------------------------------------------------------
char __cdecl sub_1006E6D0(int a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@1

  v1 = a1;
  result = 0;
  if ( (unsigned __int8)a1 < 0x34u )
  {
    if ( (unsigned __int8)sub_1006EBA0(&a1) )
      result = *(_BYTE *)(a1 + 20 * v1 + 592);
    else
      result = 0;
  }
  return result;
}

//----- (1006E710) --------------------------------------------------------
int __cdecl sub_1006E710(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 >= 0x34u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\wx\\iop_wx_intf.c", 632, 1, 0);
    result = 138;
  }
  else
  {
    result = dword_100F53CC[4 * a1];
  }
  return result;
}
// 100F53CC: using guessed type int dword_100F53CC[];

//----- (1006E750) --------------------------------------------------------
char __cdecl sub_1006E750(int a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@1

  v1 = a1;
  result = 0;
  if ( (unsigned __int8)a1 < 0x34u )
  {
    if ( (unsigned __int8)sub_1006EBA0(&a1) )
      result = *(_BYTE *)(a1 + 20 * (v1 + 30));
    else
      result = 0;
  }
  return result;
}

//----- (1006E790) --------------------------------------------------------
char __usercall sub_1006E790@<al>(char result@<al>, char *a2@<esi>)
{
  if ( *a2 == -1 )
  {
    result = sub_1006E6D0(result);
    *a2 = result;
  }
  return result;
}

//----- (1006E7B0) --------------------------------------------------------
int __usercall sub_1006E7B0@<eax>(unsigned __int8 a1@<al>, int a2@<ecx>, _DWORD *a3@<esi>, int a4)
{
  int v4; // eax@1
  int result; // eax@3

  v4 = 5 * a1;
  if ( *(_BYTE *)(a2 + 4 * v4 + 600) && *(_BYTE *)(132 * (a4 + *(_DWORD *)(a2 + 4 * v4 + 604)) + a2 + 1640) )
  {
    *a3 = a2 + *(_DWORD *)(132 * (a4 + *(_DWORD *)(a2 + 4 * v4 + 604)) + a2 + 1644);
    result = *a3 != 0;
  }
  else
  {
    *a3 = 0;
    result = *a3 != 0;
  }
  return result;
}

//----- (1006E800) --------------------------------------------------------
int __usercall sub_1006E800@<eax>(unsigned __int8 a1@<al>, int a2@<ecx>, int a3, unsigned __int8 a4)
{
  int v4; // edx@1
  bool v5; // zf@1
  int v6; // ecx@1
  int result; // eax@2

  v4 = 132 * (a3 + *(_DWORD *)(a2 + 20 * a1 + 604));
  v5 = *(_BYTE *)(v4 + a2 + 1649) == 0;
  v6 = v4 + a2 + 1632;
  if ( v5 )
    result = 0;
  else
    result = *(_DWORD *)(v6 + 6 * (a4 + 5));
  return result;
}

//----- (1006E840) --------------------------------------------------------
BOOL __usercall sub_1006E840@<eax>(unsigned __int8 a1@<al>, unsigned __int8 a2@<cl>)
{
  return a1 < (unsigned __int8)byte_100F53C1[16 * a2] || a1 == -1;
}

//----- (1006E860) --------------------------------------------------------
bool __usercall sub_1006E860@<al>(unsigned __int8 a1@<al>, int a2@<ecx>, int a3)
{
  int v3; // eax@1
  bool v4; // zf@1
  int v5; // eax@1

  v3 = 5 * a1;
  v4 = *(_BYTE *)(a2 + 4 * v3 + 600) == 0;
  v5 = a2 + 4 * v3 + 592;
  return !v4 && *(_BYTE *)(132 * (a3 + *(_DWORD *)(v5 + 12)) + a2 + 1640);
}

//----- (1006E8A0) --------------------------------------------------------
char __cdecl sub_1006E8A0(int a1, _DWORD *a2, unsigned __int8 a3)
{
  char v3; // bl@1
  char result; // al@4

  v3 = a1;
  if ( (unsigned __int8)a1 < 0x34u && (unsigned __int8)sub_1006E840(a3, a1) && (unsigned __int8)sub_1006EBA0(&a1) )
  {
    sub_1006E790(v3, (char *)&a3);
    result = sub_1006E7B0(v3, a1, a2, a3);
  }
  else
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}

//----- (1006E910) --------------------------------------------------------
int __cdecl sub_1006E910(int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  char v3; // bl@1
  int result; // eax@5

  v3 = a1;
  if ( (unsigned __int8)a1 < 0x34u
    && a2 < 0x10u
    && (unsigned __int8)sub_1006E840(a3, a1)
    && (unsigned __int8)sub_1006EBA0(&a1) )
  {
    sub_1006E790(v3, (char *)&a3);
    result = sub_1006E800(v3, a1, a3, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006E980) --------------------------------------------------------
bool __cdecl sub_1006E980(int a1, unsigned __int8 a2)
{
  char v2; // bl@1
  bool result; // al@4

  v2 = a1;
  if ( (unsigned __int8)a1 < 0x34u && (unsigned __int8)sub_1006E840(a2, a1) && (unsigned __int8)sub_1006EBA0(&a1) )
  {
    sub_1006E790(v2, (char *)&a2);
    result = sub_1006E860(v2, a1, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006E9E0) --------------------------------------------------------
char __cdecl sub_1006E9E0(int a1)
{
  int v1; // eax@2
  int v2; // eax@3

  if ( (unsigned __int8)a1 < 0x1Cu )
  {
    v1 = (unsigned __int8)sub_10081660();
    if ( !(_BYTE)v1 )
      return sub_1006E750(a1);
    v2 = v1 - 1;
    if ( !v2 )
      return byte_100F5DEC[(unsigned __int8)a1];
    if ( v2 == 1 )
      return byte_100F5DD0[(unsigned __int8)a1];
  }
  return 0;
}

//----- (1006EA30) --------------------------------------------------------
char __cdecl sub_1006EA30(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_1008CA80(6470, (int)&a1, 1);
      result = a1 && sub_10081690(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_1006C3F0(14);
    }
    else
    {
      sub_10051A40("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = (sub_100521F0(v1) & 0x800) == 2048;
  }
  return result;
}

//----- (1006EAB0) --------------------------------------------------------
BOOL sub_1006EAB0()
{
  return sub_1006EA30(0) || sub_1006EA30(1) || sub_1006EA30(2);
}

//----- (1006EAF0) --------------------------------------------------------
char __cdecl sub_1006EAF0(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@10
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@4

  v1 = 0;
  LOBYTE(v3) = 0;
  if ( (unsigned __int8)sub_1006EAB0() )
  {
    if ( sub_1008CA60(dword_100F5DC0[a1], (int)&v3, 1) || !sub_1006EA30(v3) )
    {
      LOBYTE(v3) = 0;
      LOBYTE(v4) = 0;
      while ( !sub_1006EA30(v4) )
      {
        LOBYTE(v4) = ++v1;
        if ( v1 > 3u )
          goto LABEL_9;
      }
      LOBYTE(v3) = v1;
LABEL_9:
      sub_1008CB30(dword_100F5DC0[a1], (int)&v3, 1);
    }
    result = v3;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 100F5DC0: using guessed type int dword_100F5DC0[];

//----- (1006EB90) --------------------------------------------------------
void sub_1006EB90()
{
  dword_101E34B0 = -15;
}
// 101E34B0: using guessed type int dword_101E34B0;

//----- (1006EBA0) --------------------------------------------------------
signed int __cdecl sub_1006EBA0(_DWORD *a1)
{
  signed int result; // eax@1

  result = sub_1008D490((int)&off_100F61C4);
  *a1 = dword_101E34B0;
  return result;
}
// 100F61C4: using guessed type char *off_100F61C4;
// 101E34B0: using guessed type int dword_101E34B0;

//----- (1006EBC0) --------------------------------------------------------
char __cdecl sub_1006EBC0(char a1)
{
  char result; // al@1

  result = a1;
  switch ( a1 )
  {
    case 0x16:
      result = 0;
      break;
    case 0x17:
      result = 1;
      break;
    case 0x18:
      result = 9;
      break;
    case 0x19:
      result = 8;
      break;
    case 0x1A:
      result = 10;
      break;
    case 0x1B:
      result = 14;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1006EC00) --------------------------------------------------------
bool __cdecl sub_1006EC00(unsigned __int8 a1, char a2)
{
  bool v2; // dl@1
  char v3; // bl@1
  bool result; // al@6
  int v5; // [sp+4h] [bp-4h]@2

  v3 = sub_1006EBC0(a2);
  if ( (unsigned __int8)v3 >= 0x34u )
    result = v2;
  else
    result = (unsigned __int8)sub_1006EBA0(&v5)
          && a1 < 4u
          && *(_BYTE *)(v5 + 4 * (5 * (unsigned __int8)v3 + 150))
          && *(_BYTE *)((unsigned __int8)v3 + 109 * a1 + v5);
  return result;
}

//----- (1006EC70) --------------------------------------------------------
char __cdecl sub_1006EC70(float a1)
{
  double v1; // st7@1
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2

  v3 = sub_100958E0(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  return byte_100F61F0[-(signed int)((v1 + 0.3926990926265717) / -0.7853981852531433)];
}

//----- (1006ECC0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1006ECC0(unsigned __int8 a1, _BYTE *a2)
{
  unsigned __int8 result; // al@1
  _BYTE *v3; // edx@2
  unsigned __int8 *v4; // ecx@2

  result = a1;
  if ( a1 < 8u )
  {
    v3 = a2;
    v4 = (unsigned __int8 *)*(&off_100F61FC + a1);
    do
    {
      result = *v4;
      *v3++ = *v4++;
    }
    while ( result );
  }
  return result;
}
// 100F61FC: using guessed type void *off_100F61FC;

//----- (1006ECF0) --------------------------------------------------------
int __cdecl sub_1006ECF0(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (1006ED10) --------------------------------------------------------
char *__cdecl sub_1006ED10(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_100F6230;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_1031FB3C[(unsigned __int16)sub_1006ECF0(a1)];
  return result;
}
// 1008BA20: using guessed type int TXT_get_static_string(void);

//----- (1006ED50) --------------------------------------------------------
void *__usercall sub_1006ED50@<eax>(int a1@<eax>, unsigned __int16 a2@<di>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-8h]@0
  int v5; // [sp+4h] [bp-4h]@0

  result = (void *)sub_1008CA60(a1, v4, v5);
  if ( result )
    result = memset(a3, 204, a2);
  return result;
}

//----- (1006ED80) --------------------------------------------------------
void *sub_1006ED80()
{
  void *result; // eax@1

  dword_1031FB38 = 0;
  sub_1006ED50(40200, 0x6D8u, &unk_101E34B8);
  sub_1006ED50(40201, 0x6D8u, &unk_101E3B90);
  sub_1006ED50(40202, 0x6D8u, &unk_101E4268);
  sub_1006ED50(40203, 0x6D8u, &unk_101E4940);
  sub_1006ED50(40204, 0x6D8u, &unk_101E5018);
  sub_1006ED50(40205, 0x6D8u, &unk_101E56F0);
  sub_1006ED50(40206, 0x6D8u, &unk_101E5DC8);
  sub_1006ED50(40207, 0x6D8u, &unk_101E64A0);
  sub_1006ED50(40208, 0x6D8u, &unk_101E6B78);
  sub_1006ED50(40209, 0x6D8u, &unk_101E7250);
  sub_1006ED50(40210, 0x6D8u, &unk_101E7928);
  sub_1006ED50(40211, 0x6D8u, &unk_101E8000);
  sub_1006ED50(40212, 0x6D8u, &unk_101E86D8);
  sub_1006ED50(40213, 0x6D8u, &unk_101E8DB0);
  sub_1006ED50(40214, 0x6D8u, &unk_101E9488);
  sub_1006ED50(40215, 0x6D8u, &unk_101E9B60);
  sub_1006ED50(40216, 0x6D8u, &unk_101EA238);
  sub_1006ED50(40217, 0x6D8u, &unk_101EA910);
  sub_1006ED50(40218, 0x6D8u, &unk_101EAFE8);
  sub_1006ED50(40219, 0x6D8u, &unk_101EB6C0);
  sub_1006ED50(40220, 0x6D8u, &unk_101EBD98);
  sub_1006ED50(40221, 0x6D8u, &unk_101EC470);
  sub_1006ED50(40222, 0x6D8u, &unk_101ECB48);
  sub_1006ED50(40223, 0x6D8u, &unk_101ED220);
  sub_1006ED50(40224, 0x6D8u, &unk_101ED8F8);
  sub_1006ED50(40225, 0x6D8u, &unk_101EDFD0);
  sub_1006ED50(40226, 0x6D8u, &unk_101EE6A8);
  sub_1006ED50(40227, 0x6D8u, &unk_101EED80);
  sub_1006ED50(40228, 0x6D8u, &unk_101EF458);
  sub_1006ED50(40229, 0x6D8u, &unk_101EFB30);
  sub_1006ED50(40230, 0x6D8u, &unk_101F0208);
  sub_1006ED50(40231, 0x6D8u, &unk_101F08E0);
  sub_1006ED50(40232, 0x6D8u, &unk_101F0FB8);
  sub_1006ED50(40233, 0x6D8u, &unk_101F1690);
  sub_1006ED50(40234, 0x6D8u, &unk_101F1D68);
  sub_1006ED50(40235, 0x6D8u, &unk_101F2440);
  sub_1006ED50(40236, 0x6D8u, &unk_101F2B18);
  sub_1006ED50(40237, 0x6D8u, &unk_101F31F0);
  sub_1006ED50(40238, 0x6D8u, &unk_101F38C8);
  sub_1006ED50(40239, 0x6D8u, &unk_101F3FA0);
  sub_1006ED50(40240, 0x6D8u, &unk_101F4678);
  sub_1006ED50(40241, 0x6D8u, &unk_101F4D50);
  sub_1006ED50(40242, 0x6D8u, &unk_101F5428);
  sub_1006ED50(40243, 0x6D8u, &unk_101F5B00);
  sub_1006ED50(40244, 0x6D8u, &unk_101F61D8);
  sub_1006ED50(40245, 0x6D8u, &unk_101F68B0);
  sub_1006ED50(40246, 0x6D8u, &unk_101F6F88);
  sub_1006ED50(40247, 0x6D8u, &unk_101F7660);
  sub_1006ED50(40248, 0x6D8u, &unk_101F7D38);
  sub_1006ED50(40249, 0x6D8u, &unk_101F8410);
  sub_1006ED50(40250, 0x6D8u, &unk_101F8AE8);
  sub_1006ED50(40251, 0x6D8u, &unk_101F91C0);
  sub_1006ED50(40252, 0x6D8u, &unk_101F9898);
  sub_1006ED50(40253, 0x6D8u, &unk_101F9F70);
  sub_1006ED50(40254, 0x6D8u, &unk_101FA648);
  sub_1006ED50(40255, 0x6D8u, &unk_101FAD20);
  sub_1006ED50(40256, 0x6D8u, &unk_101FB3F8);
  sub_1006ED50(40257, 0x6D8u, &unk_101FBAD0);
  sub_1006ED50(40258, 0x6D8u, &unk_101FC1A8);
  sub_1006ED50(40259, 0x6D8u, &unk_101FC880);
  sub_1006ED50(40260, 0x6D8u, &unk_101FCF58);
  sub_1006ED50(40261, 0x6D8u, &unk_101FD630);
  sub_1006ED50(40262, 0x6D8u, &unk_101FDD08);
  sub_1006ED50(40263, 0x6D8u, &unk_101FE3E0);
  sub_1006ED50(40264, 0x6D8u, &unk_101FEAB8);
  sub_1006ED50(40265, 0x6D8u, &unk_101FF190);
  sub_1006ED50(40266, 0x6D8u, &unk_101FF868);
  sub_1006ED50(40267, 0x6D8u, &unk_101FFF40);
  sub_1006ED50(40268, 0x6D8u, &unk_10200618);
  sub_1006ED50(40269, 0x6D8u, &unk_10200CF0);
  sub_1006ED50(40270, 0x6D8u, &unk_102013C8);
  sub_1006ED50(40271, 0x6D8u, &unk_10201AA0);
  sub_1006ED50(40272, 0x6D8u, &unk_10202178);
  sub_1006ED50(40273, 0x6D8u, &unk_10202850);
  sub_1006ED50(40274, 0x6D8u, &unk_10202F28);
  sub_1006ED50(40275, 0x6D8u, &unk_10203600);
  sub_1006ED50(40276, 0x6D8u, &unk_10203CD8);
  sub_1006ED50(40277, 0x6D8u, &unk_102043B0);
  sub_1006ED50(40278, 0x6D8u, &unk_10204A88);
  sub_1006ED50(40279, 0x6D8u, &unk_10205160);
  sub_1006ED50(40280, 0x6D8u, &unk_10205838);
  sub_1006ED50(40281, 0x6D8u, &unk_10205F10);
  sub_1006ED50(40282, 0x6D8u, &unk_102065E8);
  sub_1006ED50(40283, 0x6D8u, &unk_10206CC0);
  sub_1006ED50(40284, 0x6D8u, &unk_10207398);
  sub_1006ED50(40285, 0x6D8u, &unk_10207A70);
  sub_1006ED50(40286, 0x6D8u, &unk_10208148);
  sub_1006ED50(40287, 0x6D8u, &unk_10208820);
  sub_1006ED50(40288, 0x6D8u, &unk_10208EF8);
  sub_1006ED50(40289, 0x6D8u, &unk_102095D0);
  sub_1006ED50(40290, 0x6D8u, &unk_10209CA8);
  sub_1006ED50(40291, 0x6D8u, &unk_1020A380);
  sub_1006ED50(40292, 0x6D8u, &unk_1020AA58);
  sub_1006ED50(40293, 0x6D8u, &unk_1020B130);
  sub_1006ED50(40294, 0x6D8u, &unk_1020B808);
  sub_1006ED50(40295, 0x6D8u, &unk_1020BEE0);
  sub_1006ED50(40296, 0x6D8u, &unk_1020C5B8);
  sub_1006ED50(40297, 0x6D8u, &unk_1020CC90);
  sub_1006ED50(40298, 0x6D8u, &unk_1020D368);
  sub_1006ED50(40299, 0x6D8u, &unk_1020DA40);
  result = sub_1006ED50(40300, 0x1774u, &unk_1020E118);
  dword_1031FB38 = (int)&unk_101E34B8;
  return result;
}
// 1031FB38: using guessed type int dword_1031FB38;

//----- (1006F390) --------------------------------------------------------
char __thiscall sub_1006F390(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_100520D0(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 100960A2: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (1006F3C0) --------------------------------------------------------
int __thiscall sub_1006F3C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_100520D0(46, (char *)&v2);
  return (int)v2;
}

//----- (1006F3E0) --------------------------------------------------------
bool __cdecl sub_1006F3E0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_100763E0(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_1006F3C0(v1) & 3 || sub_10052230(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_10052230(v1) != 1;
      break;
    default:
      result = sub_10052230(v1) == 1;
      break;
  }
  return result;
}

//----- (1006F450) --------------------------------------------------------
BOOL __fastcall sub_1006F450(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10065C60(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (1006F480) --------------------------------------------------------
bool __thiscall sub_1006F480(void *this)
{
  int v1; // ecx@1
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  BYTE2(v3) = 0;
  sub_1008CAC0(6791, (char *)&v3 + 3, 1, (char *)&v3 + 2);
  return BYTE3(v3) && (unsigned __int8)sub_1006F450(v1);
}

//----- (1006F4C0) --------------------------------------------------------
__int16 __cdecl sub_1006F4C0(int a1, int a2, int a3)
{
  __int16 v3; // si@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_cnt(a1, a2, a3, 0);
  SYS_exit_krnl();
  return v3;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100960C0: using guessed type int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006F4F0) --------------------------------------------------------
char __cdecl sub_1006F4F0(int a1, int a2, int a3, int a4)
{
  char v4; // bl@1

  SYS_enter_krnl();
  v4 = SYS_pvg_alrt_get_dsply_alrt(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100960C6: using guessed type int __cdecl SYS_pvg_alrt_get_dsply_alrt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006F520) --------------------------------------------------------
char __cdecl sub_1006F520(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100960CC: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (1006F590) --------------------------------------------------------
char __thiscall sub_1006F590(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_1020FF50 = sub_10052210(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1020FF58, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_1020FF58;
  do
  {
    result = sub_10081090(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 1020FF50: using guessed type int dword_1020FF50;

//----- (1006F600) --------------------------------------------------------
char __usercall sub_1006F600@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10073080(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10073080(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1006F640) --------------------------------------------------------
void *__usercall sub_1006F640@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_1020FF50 == 1379255385 )
    goto LABEL_4;
  v4 = sub_1008CA00(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_1020FF58 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10081090(a1, (int)&unk_1020FF58 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_1020FF58 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_1020FF50 != 1379255385 )
    result = (void *)sub_1008C9D0(v4, 86);
  return result;
}
// 1020FF50: using guessed type int dword_1020FF50;

//----- (1006F6E0) --------------------------------------------------------
char __cdecl sub_1006F6E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1006F600(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1006F720) --------------------------------------------------------
bool __cdecl sub_1006F720(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1006F640(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1006F780) --------------------------------------------------------
char __cdecl sub_1006F780(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1006F600(a2, 1, a3, a1);
  return result;
}

//----- (1006F7C0) --------------------------------------------------------
char __cdecl sub_1006F7C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1006F640(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1006F7F0) --------------------------------------------------------
char __cdecl sub_1006F7F0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1006F600(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1006F830) --------------------------------------------------------
char __cdecl sub_1006F830(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1006F640(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1006F870) --------------------------------------------------------
char __cdecl sub_1006F870(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1006F600(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1006F8B0) --------------------------------------------------------
bool __cdecl sub_1006F8B0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1006F640(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1006F900) --------------------------------------------------------
char __cdecl sub_1006F900(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1006F600(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1006F940) --------------------------------------------------------
bool __cdecl sub_1006F940(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1006F640(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1006F980) --------------------------------------------------------
char __cdecl sub_1006F980(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1006F600(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1006F9C0) --------------------------------------------------------
bool __cdecl sub_1006F9C0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1006F640(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1006FA00) --------------------------------------------------------
char __cdecl sub_1006FA00(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1006F600(1229, 1, a2, a1);
  return result;
}

//----- (1006FA30) --------------------------------------------------------
char __cdecl sub_1006FA30(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1006F640(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1006FA60) --------------------------------------------------------
char __cdecl sub_1006FA60(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1006F600(1212, 16, a2, a1);
  return result;
}

//----- (1006FA90) --------------------------------------------------------
char __cdecl sub_1006FA90(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1006F640(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006FAC0) --------------------------------------------------------
char __cdecl sub_1006FAC0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1006F600(2400, 65, a2, a1);
  return result;
}

//----- (1006FAF0) --------------------------------------------------------
char __cdecl sub_1006FAF0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1006F640(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006FB20) --------------------------------------------------------
char __cdecl sub_1006FB20(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1006F600(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1006FB60) --------------------------------------------------------
char __cdecl sub_1006FB60(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10051A40("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1006F640(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1006FBB0) --------------------------------------------------------
char __cdecl sub_1006FBB0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1006F600(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1006FBF0) --------------------------------------------------------
char __cdecl sub_1006FBF0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1006F640(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1006FC20) --------------------------------------------------------
char __cdecl sub_1006FC20(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1006F600(22, 1, a2, a1);
  return result;
}

//----- (1006FC50) --------------------------------------------------------
char __cdecl sub_1006FC50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1006F600(832, 4, a2, a1);
  return result;
}

//----- (1006FC80) --------------------------------------------------------
char __cdecl sub_1006FC80(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1006F640(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1006FCB0) --------------------------------------------------------
char __cdecl sub_1006FCB0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10076080(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1006FB60(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1006FB20(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1006FBF0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1006FBB0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1006F720(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F6E0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1006F940(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F900(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1006F9C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F980(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1006F7C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F780(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1006F830(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F7F0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1006FC20(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1006FA90(v6, a5);
        else
          result = sub_1006FA60(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1006F8B0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1006F870(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1006FAF0(v6, a5);
        else
          result = sub_1006FAC0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1006FA30(v6, a5);
        else
          result = sub_1006FA00(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1006FC80(v6, a5);
        else
          result = sub_1006FC50(v6, a5);
        break;
      default:
        sub_10051A40("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1008D100: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10070050) --------------------------------------------------------
bool __cdecl sub_10070050(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10211498 != 1379255385 )
    {
      sub_10081070(a1, (int)&byte_102114A0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_102114A5[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_102114A4[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10211498: using guessed type int dword_10211498;

//----- (100700C0) --------------------------------------------------------
bool __cdecl sub_100700C0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10211498 != 1379255385 )
      sub_10081070(a1, (int)&byte_102114A0[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_102114B4[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10211498: using guessed type int dword_10211498;
// 102114B4: using guessed type int dword_102114B4[];

//----- (10070120) --------------------------------------------------------
bool __cdecl sub_10070120(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10211498 != 1379255385 )
    {
      sub_10081070(a1, (int)&byte_102114A0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_102114AC[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10211498: using guessed type int dword_10211498;
// 102114AC: using guessed type int dword_102114AC[];

//----- (10070190) --------------------------------------------------------
char __cdecl sub_10070190(char a1, _BYTE *a2)
{
  if ( dword_10211498 != 1379255385 )
    sub_10081070(a1, (int)&byte_102114A0[24 * (unsigned __int8)a1]);
  *a2 = byte_102114A0[24 * (unsigned __int8)a1];
  return 1;
}
// 10211498: using guessed type int dword_10211498;

//----- (100701D0) --------------------------------------------------------
char __thiscall sub_100701D0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10211498 = sub_10052210(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_102114A0, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_102114A0;
  do
  {
    result = sub_10081070(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10211498: using guessed type int dword_10211498;

//----- (10070240) --------------------------------------------------------
char __cdecl sub_10070240(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10063F40(a1);
  v3 = sub_1008D880(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10070270) --------------------------------------------------------
char __cdecl sub_10070270(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10063F40(a1);
  v3 = sub_1008D8F0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100702A0) --------------------------------------------------------
char __cdecl sub_100702A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10064030(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10070120(v7, *a4, (int)a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10070050(v7, *a4, (int)a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100700C0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10070190(v7, a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10070270(v7, (int)a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10070240(v7, (int)a5);
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10070480) --------------------------------------------------------
char *__cdecl sub_10070480(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = byte_100B8180;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (100704D0) --------------------------------------------------------
int sub_100704D0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1008C710();
  result = 0;
  while ( 1 )
  {
    v3 = dword_102114FC[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_102114FC[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 102114FC: using guessed type int dword_102114FC[];

//----- (10070510) --------------------------------------------------------
int __cdecl sub_10070510(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10070580) --------------------------------------------------------
signed int __cdecl sub_10070580(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10070620) --------------------------------------------------------
int __usercall sub_10070620@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10070580(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10070650) --------------------------------------------------------
signed int __usercall sub_10070650@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10070580((_BYTE *)a3, (int)(&off_100F79B8)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100F79BC[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10098802(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10098802(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10098802(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100F79B8: using guessed type char *off_100F79B8;

//----- (10070820) --------------------------------------------------------
char *__usercall sub_10070820@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_100C2700, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10070880) --------------------------------------------------------
int __usercall sub_10070880@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10070580((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10070910) --------------------------------------------------------
int __usercall sub_10070910@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10070620(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10070960) --------------------------------------------------------
char **__usercall sub_10070960@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10070480(v6);
      if ( !sub_10070580((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (100709C0) --------------------------------------------------------
const char *__usercall sub_100709C0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (100709E0) --------------------------------------------------------
int __usercall sub_100709E0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_102114E8[sub_100704D0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (10070A20) --------------------------------------------------------
int __usercall sub_10070A20@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10070650(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10070AB0) --------------------------------------------------------
int __usercall sub_10070AB0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10070C00) --------------------------------------------------------
int __usercall sub_10070C00@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10076F40(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_100714E0(v3, v6, 0);
        v7 = -*v3;
        sub_10076F40(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10076F40(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100F7670);
      sub_10081840(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100F7670);
      sub_10076F40(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10070CA0) --------------------------------------------------------
int __usercall sub_10070CA0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10070CE0) --------------------------------------------------------
char *__cdecl sub_10070CE0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10070820(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10070820(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10070820(result, v5, (int)&v20);
      v10 = byte_100B8180;
    }
    LOBYTE(v9) = 0;
    sub_10070820(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10070820(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10070820(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10070820(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10076ED0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10070CE0: using guessed type int var_61C[6];

//----- (10070E90) --------------------------------------------------------
int __usercall sub_10070E90@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10070480((char **)a1);
  result = sub_10076F60(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100F7670);
  return result;
}

//----- (10070EC0) --------------------------------------------------------
int __usercall sub_10070EC0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100F7670);
  v2 = (unsigned int)sub_10070480((char **)a1);
  return sub_10076F40(10, v2);
}

//----- (10070EF0) --------------------------------------------------------
void __cdecl sub_10070EF0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10070480(v5);
            v7 = sub_10070480((char **)v3);
            if ( !sub_10070510(v7, (int)v6) )
            {
              v8 = sub_10070480((char **)v3);
              sub_10077000(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10070480((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10070480((char **)v3);
        sub_10077000(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_100709C0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_10077A20("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10070480((char **)v3);
            sub_10077040(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10070510(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_100709C0(v18);
                  v25 = sub_10077A20("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10070480((char **)v3);
                  sub_10077040(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10070480((char **)v3);
                  sub_10077040(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10070480((char **)v3);
              sub_10077040(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10070480((char **)v3);
              sub_10077040(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10070480((char **)v3);
              sub_10077040(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10070EF0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10070480((char **)v3);
            sub_10077040(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10070480((char **)v3);
            sub_10077040(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10070480((char **)v3);
          sub_10077040(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10070480((char **)v3);
        sub_10077040(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10070480(a2);
      sub_10077000(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10071360) --------------------------------------------------------
int sub_10071360()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_102114E8[sub_100704D0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10070EF0(i, 0, &v2);
  }
  return v2;
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (100713B0) --------------------------------------------------------
void *sub_100713B0()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_102114E8[0] = 0;
  dword_102114EC = 0;
  dword_102114F0 = 0;
  dword_102114F4 = 0;
  dword_102114F8 = 0;
  result = &unk_10211510;
  dword_102114FC[0] = -1;
  dword_10211500 = -1;
  dword_10211504 = -1;
  dword_10211508 = -1;
  dword_1021150C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10070CA0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 102114E8: using guessed type int dword_102114E8[];
// 102114EC: using guessed type int dword_102114EC;
// 102114F0: using guessed type int dword_102114F0;
// 102114F4: using guessed type int dword_102114F4;
// 102114F8: using guessed type int dword_102114F8;
// 102114FC: using guessed type int dword_102114FC[];
// 10211500: using guessed type int dword_10211500;
// 10211504: using guessed type int dword_10211504;
// 10211508: using guessed type int dword_10211508;
// 1021150C: using guessed type int dword_1021150C;

//----- (10071410) --------------------------------------------------------
char *sub_10071410()
{
  return (char *)&unk_10211510 + 56 * sub_100704D0();
}

//----- (10071430) --------------------------------------------------------
char sub_10071430()
{
  return sub_10071410()[33];
}

//----- (10071440) --------------------------------------------------------
char __cdecl sub_10071440(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10071410();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10076AC0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10071480) --------------------------------------------------------
int *__usercall sub_10071480@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10071410() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10070580((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (100714D0) --------------------------------------------------------
char **sub_100714D0()
{
  return &off_100F7A20;
}
// 100F7A20: using guessed type char *off_100F7A20;

//----- (100714E0) --------------------------------------------------------
int __cdecl sub_100714E0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1007BC90();
  v3 = sub_10071410();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10071360();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10070E90(a2);
    if ( a3 )
    {
      v7 = sub_10070C00(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10070C00(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10070EC0(a2);
        return v7;
      }
    }
    sub_10070EC0(a2);
    result = v7;
  }
  return result;
}

//----- (10071590) --------------------------------------------------------
int __cdecl sub_10071590(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10070820(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10070820(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10070820(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10076ED0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10070820(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10070820(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10070820(v14, "group-begin", (int)&v29);
          sub_10076ED0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10070480(v15);
          sub_10071590(v16[2], v16[3], v16[4], v17, a4);
          sub_10070480(v16);
          v18 = sub_10070CE0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10070820(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10070820(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10070820(v20, "group-end", (int)&v29);
          result = sub_10076ED0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10070820(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10070820(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10070820(v21, a4, (int)&v28);
          v23 = byte_100B8180;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10070820(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10070820(v24, *(const char **)v5, (int)&v30);
        result = sub_10076ED0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10071590: using guessed type int var_414[4];

//----- (100717A0) --------------------------------------------------------
char *__usercall sub_100717A0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10070820(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10070820(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10076ED0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10071590(a3, (int)a4, a5, a2, 0);
    result = sub_10070CE0(a3, a4, a5, 0);
  }
  return result;
}
// 100717A0: using guessed type int var_20C[2];

//----- (10071860) --------------------------------------------------------
char *__cdecl sub_10071860(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_102114E8[sub_100704D0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10070480((char **)v2);
    sub_100717A0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10071410() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_100717A0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (10071900) --------------------------------------------------------
int *__cdecl sub_10071900(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_102114E8[sub_100704D0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10070480(v2);
      if ( !sub_10070580(a1, (int)v4) )
      {
        v5 = sub_10070480(v3);
        sub_100717A0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10071410();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10070580(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_100717A0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (100719C0) --------------------------------------------------------
int __usercall sub_100719C0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_100709E0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_100714E0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_100709E0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_100714E0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10070E90(v5);
        sub_10070C00(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10070EC0(v8);
          v10 = sub_100709E0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10071B20) --------------------------------------------------------
signed int __usercall sub_10071B20@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_102114E8[sub_100704D0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_100714E0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (10071B90) --------------------------------------------------------
int __cdecl sub_10071B90(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10071410();
  switch ( a1 )
  {
    case 9:
      sub_10076F40(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10070580((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10070580(v6, (int)"-q") )
            {
              sub_10071900(v6);
              v9 = sub_10071360();
              sub_10076F40(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10071860(0);
              v8 = sub_10071360();
              sub_10076F40(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10071860(1);
            v7 = sub_10071360();
            sub_10076F40(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10076FC0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10076F40(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10071860(0);
        v4 = sub_10071360();
        sub_10076F40(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10076F40(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_102114E8[sub_100704D0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10071B90 )
              v12(2, (int)&unk_100F7670);
          }
        }
      }
      sub_1007BC90();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10076F40(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_102114E8[sub_100704D0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10076FC0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_100719C0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10076FC0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10071B20((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10076FC0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10071B90 )
          v15(3, (int)&unk_100F7670);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10071B90: using guessed type int __cdecl sub_10071B90(int, int);
// 102114E8: using guessed type int dword_102114E8[];

//----- (10071E70) --------------------------------------------------------
char **sub_10071E70()
{
  return off_100F7814;
}
// 100F7814: using guessed type char *off_100F7814[3];

//----- (10071E80) --------------------------------------------------------
int __usercall sub_10071E80@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10070910(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10070A20(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10071E70();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10071F70) --------------------------------------------------------
int __cdecl sub_10071F70(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10071410();
  *a1 = 0;
  v4 = sub_10077A20("Processing command '%s'", v2);
  sub_10076FC0(3, (int)&unk_100F81C0, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10070AB0(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_100719C0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10071B20((int)v3);
    v11 = 0;
    v6 = sub_100704D0();
    v7 = sub_10070960((int (**)(void))dword_102114E8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10070880((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10070880((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100714E0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100714E0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10071E80(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10071480(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10071E80(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10071E70();
        result = sub_10071E80(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 102114E8: using guessed type int dword_102114E8[];
// 10071F70: using guessed type char var_2D4[720];

//----- (100721B0) --------------------------------------------------------
int sub_100721B0()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10071F70(&v4);
  if ( !sub_10071410()[32] )
    sub_10076F40(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_10077A20("%s %i, %s", "Command status:", v0, &v4);
    sub_10076FC0(3, (int)&unk_100F81C0, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_10077A20("%s %i", "Command status:", v0);
    sub_10076FC0(3, (int)&unk_100F81C0, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10072290) --------------------------------------------------------
int __cdecl sub_10072290(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_102114E8[sub_100704D0()] = a1;
  sub_10071410()[32] = a3;
  sub_1007BC90();
  sub_10081A50(a2);
  v3 = sub_100714D0();
  sub_100769B0(v3);
  return sub_100721B0();
}
// 102114E8: using guessed type int dword_102114E8[];

//----- (100722E0) --------------------------------------------------------
_DWORD *sub_100722E0()
{
  sub_10001580();
  return sub_10081DE0();
}

//----- (100722F0) --------------------------------------------------------
#error "100722FF: call analysis failed (funcsize=5)"

//----- (10072310) --------------------------------------------------------
void sub_10072310()
{
  dword_1031FB30 = -15;
}
// 1031FB30: using guessed type int dword_1031FB30;

//----- (10072320) --------------------------------------------------------
signed int sub_10072320()
{
  return sub_1008D490((int)&off_100F8858);
}
// 100F8858: using guessed type char *off_100F8858;

//----- (10072330) --------------------------------------------------------
int sub_10072330()
{
  int result; // eax@1

  result = 0;
  dword_10211628 = -15;
  dword_1031FB2C = 0;
  dword_1031FB20 = 0;
  dword_1031FB24 = 0;
  dword_1031FB28 = 0;
  return result;
}
// 10211628: using guessed type int dword_10211628;
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB24: using guessed type int dword_1031FB24;
// 1031FB28: using guessed type int dword_1031FB28;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (10072360) --------------------------------------------------------
char sub_10072360()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1008D490((int)&off_100F8884);
  if ( v0 )
  {
    dword_1031FB2C = dword_10211628;
    v1 = *(_BYTE *)(dword_10211628 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1031FB2C + 36) < (unsigned int)sub_1008C780() )
      v0 = 0;
    dword_1031FB28 = dword_10211628 + 56116;
    result = v0;
    dword_1031FB20 = dword_10211628 + 1516;
    dword_1031FB24 = dword_10211628 + 20484;
  }
  else
  {
    dword_1031FB2C = 0;
    dword_1031FB20 = 0;
    dword_1031FB24 = 0;
    dword_1031FB28 = 0;
    result = 0;
  }
  return result;
}
// 100F8884: using guessed type char *off_100F8884;
// 10211628: using guessed type int dword_10211628;
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB24: using guessed type int dword_1031FB24;
// 1031FB28: using guessed type int dword_1031FB28;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (10072400) --------------------------------------------------------
void sub_10072400()
{
  dword_1021162C = -15;
}
// 1021162C: using guessed type int dword_1021162C;

//----- (10072410) --------------------------------------------------------
int __cdecl sub_10072410(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100F977C[a1];
  return result;
}
// 100F977C: using guessed type __int16 word_100F977C[];

//----- (10072430) --------------------------------------------------------
signed int sub_10072430()
{
  signed int result; // eax@1

  result = -15;
  dword_1021164C = -15;
  dword_10211658 = -15;
  dword_10211634 = -15;
  dword_1021165C = -15;
  dword_10211648 = -15;
  dword_10211638 = -15;
  dword_10211630 = -15;
  dword_10211644 = -15;
  dword_10211654 = -15;
  dword_10211650 = -15;
  dword_10211640 = -15;
  dword_1021163C = -15;
  return result;
}
// 10211630: using guessed type int dword_10211630;
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 1021163C: using guessed type int dword_1021163C;
// 10211640: using guessed type int dword_10211640;
// 10211644: using guessed type int dword_10211644;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211650: using guessed type int dword_10211650;
// 10211654: using guessed type int dword_10211654;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (10072480) --------------------------------------------------------
signed int __usercall sub_10072480@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1008D490((int)&off_100F979C);
      break;
    case 0:
      result = sub_1008D490((int)&off_100F97B0);
      break;
    case 1:
      result = sub_1008D490((int)&off_100F97C4);
      break;
    case 2:
      result = sub_1008D490((int)&off_100F97EC);
      break;
    case 3:
      result = sub_1008D490((int)&off_100F97D8);
      break;
    case 5:
      result = sub_1008D490((int)&off_100F9800);
      break;
    default:
      result = sub_1008D490(a2);
      break;
  }
  return result;
}
// 100F979C: using guessed type char *off_100F979C;
// 100F97B0: using guessed type char *off_100F97B0;
// 100F97C4: using guessed type char *off_100F97C4;
// 100F97D8: using guessed type char *off_100F97D8;
// 100F97EC: using guessed type char *off_100F97EC;
// 100F9800: using guessed type char *off_100F9800;

//----- (10072520) --------------------------------------------------------
int __usercall sub_10072520@<eax>(char a1@<al>)
{
  return sub_1008C830(dword_100F92CC[a1]);
}
// 100F92CC: using guessed type int dword_100F92CC[];

//----- (10072540) --------------------------------------------------------
int __usercall sub_10072540@<eax>(char a1@<al>)
{
  return sub_1008C850(dword_100F92CC[a1], 10);
}
// 100F92CC: using guessed type int dword_100F92CC[];

//----- (10072560) --------------------------------------------------------
signed __int16 __usercall sub_10072560@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10072480(a1, a1) )
        {
          sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1021164C + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10072480(a1, a1) )
      {
        result = *(_WORD *)(dword_10211658 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_100520B0(15000) )
        goto LABEL_6;
      sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10072480(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_10211634 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10072480(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1021165C + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10072480(a1, a1) )
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_10211648 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10072480(a1, a1) )
        {
          result = *(_WORD *)(dword_10211638 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (100727A0) --------------------------------------------------------
char __cdecl sub_100727A0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_10072560(a1, a2);
  if ( v3 != -1 && !sub_10072540(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1021164C);
        sub_10072520(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10211658);
        sub_10072520(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_10211634;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1021165C);
        sub_10072520(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10211648);
        sub_10072520(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_10211638;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_10072520(a1);
        return 1;
      default:
LABEL_17:
        sub_10072520(a1);
        break;
    }
  }
  return 0;
}
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (10072900) --------------------------------------------------------
char __cdecl sub_10072900(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10072560(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10072480(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1021164C + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10072480(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10211658 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10072480(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10211634 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10072480(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1021165C + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10072480(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10211648 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10072480(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10211638 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (10072A80) --------------------------------------------------------
char __cdecl sub_10072A80(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10072560(a1, a2);
  if ( v3 != -1 && !sub_10072540(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1021164C + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10211658 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10211634 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1021165C + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10211648 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10072480(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10211638 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10072520(a1);
        return 1;
      default:
LABEL_17:
        sub_10072520(a1);
        break;
    }
  }
  return 0;
}
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (10072BE0) --------------------------------------------------------
char __cdecl sub_10072BE0(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10072480(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10072560(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10072900(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_1008C780();
      v13 = 0;
      LOBYTE(v7) = sub_10074950(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10072D20) --------------------------------------------------------
char __cdecl sub_10072D20(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10072560(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10074950(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10072E00) --------------------------------------------------------
char __cdecl sub_10072E00(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_1008C780();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10072560(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1021164C + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1021164C + 210116;
          v12 = dword_1021164C + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_10211658 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_10211658 + 257156;
          v12 = dword_10211658 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_10211634 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_10211634 + 321708;
          v12 = dword_10211634 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1021165C + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1021165C + 326220;
          v12 = dword_1021165C + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_10211648 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_10211648 + 18832;
          v12 = dword_10211648 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10072480(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_10211638 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_10211638 + 1596;
          v12 = dword_10211638 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10072540(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10072520(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10211630: using guessed type int dword_10211630;
// 10211634: using guessed type int dword_10211634;
// 10211638: using guessed type int dword_10211638;
// 10211644: using guessed type int dword_10211644;
// 10211648: using guessed type int dword_10211648;
// 1021164C: using guessed type int dword_1021164C;
// 10211654: using guessed type int dword_10211654;
// 10211658: using guessed type int dword_10211658;
// 1021165C: using guessed type int dword_1021165C;

//----- (10073080) --------------------------------------------------------
char __cdecl sub_10073080(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10072E00(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (100730B0) --------------------------------------------------------
char __cdecl sub_100730B0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10072E00(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (100730E0) --------------------------------------------------------
char __cdecl sub_100730E0(char a1, int a2, void *a3, int a4)
{
  return sub_10072E00(a1, a2, 0, 0, a3, a4);
}

//----- (10073110) --------------------------------------------------------
char __thiscall sub_10073110(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1008CB00(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (10073130) --------------------------------------------------------
char sub_10073130()
{
  char result; // al@1

  byte_10211660 = 2;
  result = sub_1006C3F0(4);
  if ( result )
  {
    byte_10211660 = 0;
  }
  else
  {
    result = sub_1006C3F0(7);
    if ( result )
      byte_10211660 = 1;
  }
  return result;
}
// 10211660: using guessed type char byte_10211660;

//----- (10073170) --------------------------------------------------------
double __cdecl sub_10073170(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10076320(v1);
  if ( sub_10073110(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1008CB00(2015, (int)&v5, 12);
      return v6;
    }
    sub_1008CB00(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1008CB00(2015, (int)&v5, 12);
      return v6;
    }
    sub_1008CB00(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (100731F0) --------------------------------------------------------
void sub_100731F0()
{
  sub_10073170(0);
}

//----- (10073200) --------------------------------------------------------
void sub_10073200()
{
  dword_1031FB18 = -15;
}
// 1031FB18: using guessed type int dword_1031FB18;

//----- (10073210) --------------------------------------------------------
char __cdecl sub_10073210(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10076320(v1);
  v3 = sub_10076440(v2);
  if ( sub_1008CA60(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 10073210: using guessed type char var_48[68];

//----- (10073270) --------------------------------------------------------
signed int sub_10073270()
{
  return sub_1008D490((int)&off_100FA770);
}
// 100FA770: using guessed type char *off_100FA770;

//----- (10073280) --------------------------------------------------------
char __usercall sub_10073280@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10073270()
    || sub_1008C850(33, 10) )
  {
    sub_10051A40("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_1008C780()
                         - *(_DWORD *)(dword_1031FB18 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_1031FB18 + 37) )
  {
    memcpy_0(
      a3,
      (const void *)(dword_1031FB18 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_1031FB18 + 2 * v3 + 62));
    sub_1008C830(33);
    result = 1;
  }
  else
  {
    sub_1008C830(33);
    result = 0;
  }
  return result;
}
// 1031FB18: using guessed type int dword_1031FB18;

//----- (10073360) --------------------------------------------------------
char __cdecl sub_10073360(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10073280(a1, a2, a3);
    }
    else
    {
      v4 = sub_10081EA0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10072410(*(_BYTE *)v5)) )
      {
        result = sub_100730B0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10081EA0: using guessed type _DWORD __cdecl sub_10081EA0(char);

//----- (100733E0) --------------------------------------------------------
char __cdecl sub_100733E0(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_10073210(a1);
  return sub_10073360(a1, v2, a2);
}

//----- (10073400) --------------------------------------------------------
int __cdecl sub_10073400(int a1, int a2)
{
  byte_1031FB3C[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10073410) --------------------------------------------------------
BOOL __cdecl sub_10073410(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_1008C780();
  for ( i = sub_1008D560(6, 0, 1, (int)&v4); i == 12; i = sub_1008D560(6, 0, 1, (int)&v4) )
  {
    if ( sub_1008C780() - v1 >= a1 )
      break;
    sub_1008C900(100);
  }
  return i == 12;
}

//----- (10073480) --------------------------------------------------------
char __thiscall sub_10073480(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1008D070(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100734A0) --------------------------------------------------------
void __cdecl sub_100734A0(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_1008D070(120, a1);
  sub_1008D070(124, a2);
  sub_1008D070(121, a3);
}

//----- (100734D0) --------------------------------------------------------
int __cdecl sub_100734D0(int a1)
{
  return sub_1008CA60(3025, a1, 84);
}

//----- (100734F0) --------------------------------------------------------
signed int sub_100734F0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1008D5A0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10073520) --------------------------------------------------------
void __cdecl sub_10073520(_BYTE *a1)
{
  sub_1008D070(129, a1);
}

//----- (10073540) --------------------------------------------------------
char __cdecl sub_10073540(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1008D560(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10073580) --------------------------------------------------------
int __cdecl sub_10073580(int a1)
{
  return sub_1008CB30(3025, a1, 84);
}

//----- (100735A0) --------------------------------------------------------
char __fastcall sub_100735A0(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_1031FB14 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10073540(147, 0xCu, &v38);
  sub_10073540(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1008CAC0(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_1006F390(a1);
  if ( !result || result == 3 )
    result = sub_100522B0(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_1008CB30(2000, (int)&v20, 29);
  }
  return result;
}
// 1031FB14: using guessed type char byte_1031FB14;

//----- (100737C0) --------------------------------------------------------
char sub_100737C0()
{
  int *v0; // ecx@1

  sub_10073410(0x9C40u);
  sub_100508E0(&off_100FACC8);
  return sub_100735A0(v0);
}
// 100FACC8: using guessed type int (__cdecl *off_100FACC8)(int, size_t, void *);

//----- (100737E0) --------------------------------------------------------
signed int sub_100737E0()
{
  return 1000;
}

//----- (10073810) --------------------------------------------------------
int sub_10073810()
{
  return sub_1007E750((int)off_100FB210);
}
// 100FB210: using guessed type int (*off_100FB210[4])();

//----- (10073820) --------------------------------------------------------
int __cdecl sub_10073820(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *((_WORD *)&off_100FB21C + *(_BYTE *)a1 + 1) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - *((_BYTE *)&off_100FB21C + 2 * *(_BYTE *)a1 + 2);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 100FB21C: using guessed type int (*)();

//----- (10073910) --------------------------------------------------------
__int16 __cdecl sub_10073910(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10073960) --------------------------------------------------------
int __cdecl sub_10073960(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10073990) --------------------------------------------------------
__int16 __cdecl sub_10073990(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10073910((int)&v5, *a1);
  sub_10073820((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10073A10) --------------------------------------------------------
int __cdecl sub_10073A10(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_1031FB14 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_1031F1D4)(146, 1, a1);
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FB14: using guessed type char byte_1031FB14;

//----- (10073A40) --------------------------------------------------------
char __cdecl sub_10073A40(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1031FB14 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(dword_1031F5E4, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F5E4: using guessed type int dword_1031F5E4;
// 1031FB14: using guessed type char byte_1031FB14;

//----- (10073A90) --------------------------------------------------------
char __cdecl sub_10073A90(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1031FB14 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1031F1D4)(dword_1031F5E4, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F5E4: using guessed type int dword_1031F5E4;
// 1031FB14: using guessed type char byte_1031FB14;

//----- (10073AE0) --------------------------------------------------------
int sub_10073AE0()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_1031F2C0, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_1031F1C4)(512, &v6);
  v1 = 0;
  do
  {
    word_1031F2C4[v1 / 2] = 0;
    dword_1031F2C8[v1 / 4] = 0;
    dword_1031F2C0[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_1031F2CC = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_1031F2D0 = v7;
    dword_1031F2D4 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_1031F2D8;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_1031F1C4)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_1031F2D0;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 1031F1C4: using guessed type int dword_1031F1C4;
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031F2C4: using guessed type __int16 word_1031F2C4[];
// 1031F2C8: using guessed type int dword_1031F2C8[];
// 1031F2CC: using guessed type int dword_1031F2CC;
// 1031F2D0: using guessed type int dword_1031F2D0;
// 1031F2D4: using guessed type int dword_1031F2D4;
// 1031F2D8: using guessed type int dword_1031F2D8;

//----- (10073BB0) --------------------------------------------------------
__int16 sub_10073BB0()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_1031F2DC;
  v1 = dword_1031F2E0;
  v2 = 1;
  v3 = dword_1031F2D8;
  if ( (unsigned int)dword_1031F2E0 >= 1 )
  {
    v4 = (unsigned __int16)word_1031F2DC;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(v3, 2, &v5);
      result = v5;
      word_1031F9E0[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2D8: using guessed type int dword_1031F2D8;
// 1031F2DC: using guessed type __int16 word_1031F2DC;
// 1031F2E0: using guessed type int dword_1031F2E0;
// 1031F9E0: using guessed type __int16 word_1031F9E0[];

//----- (10073C10) --------------------------------------------------------
int __usercall sub_10073C10@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10073C90) --------------------------------------------------------
signed int __cdecl sub_10073C90(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_1031FB14 )
  {
    LOBYTE(dword_10211664) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_10211664 )
  {
    *(_DWORD *)a1 = dword_10211664;
    *(_DWORD *)(a1 + 4) = dword_10211668;
    *(_DWORD *)(a1 + 8) = dword_1021166C;
    result = dword_10211670;
    *(_DWORD *)(a1 + 12) = dword_10211670;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(147, 12, &v2);
    sub_10073C10((int)&v3, &v3, 16, a1);
    dword_10211664 = *(_DWORD *)a1;
    dword_10211668 = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_1021166C = *(_DWORD *)(a1 + 8);
    dword_10211670 = *(_DWORD *)(a1 + 12);
    byte_10211674 = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 10211664: using guessed type int dword_10211664;
// 10211668: using guessed type int dword_10211668;
// 1021166C: using guessed type int dword_1021166C;
// 10211670: using guessed type int dword_10211670;
// 10211674: using guessed type char byte_10211674;
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031FB14: using guessed type char byte_1031FB14;

//----- (10073D80) --------------------------------------------------------
unsigned __int8 sub_10073D80()
{
  unsigned __int8 result; // al@1
  unsigned int v1; // edx@2
  char *v2; // ecx@2
  char *v3; // esi@2
  int v4; // edi@6
  int v5; // edx@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // esi@7
  int v8; // edx@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // esi@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // esi@11
  signed int v13; // ecx@13
  char v14; // [sp+0h] [bp-18h]@1

  sub_10073C90((int)&v14);
  result = 0;
  do
  {
    v1 = 10;
    v2 = &a006D0170[11 * result];
    v3 = &v14;
    do
    {
      if ( *(_DWORD *)v3 != *(_DWORD *)v2 )
        goto LABEL_6;
      v1 -= 4;
      v2 += 4;
      v3 += 4;
    }
    while ( v1 >= 4 );
    if ( !v1 )
    {
LABEL_15:
      v13 = 0;
      goto LABEL_16;
    }
LABEL_6:
    v4 = (unsigned __int8)*v3 - (unsigned __int8)*v2;
    if ( (unsigned __int8)*v3 == (unsigned __int8)*v2 )
    {
      v5 = v1 - 1;
      v6 = v2 + 1;
      v7 = v3 + 1;
      if ( !v5 )
        goto LABEL_15;
      v4 = *v7 - *v6;
      if ( *v7 == *v6 )
      {
        v8 = v5 - 1;
        v9 = v6 + 1;
        v10 = v7 + 1;
        if ( !v8 )
          goto LABEL_15;
        v4 = *v10 - *v9;
        if ( *v10 == *v9 )
        {
          v11 = v9 + 1;
          v12 = v10 + 1;
          if ( v8 == 1 )
            goto LABEL_15;
          v4 = *v12 - *v11;
          if ( *v12 == *v11 )
            goto LABEL_15;
        }
      }
    }
    v13 = 1;
    if ( v4 <= 0 )
      v13 = -1;
LABEL_16:
    if ( !v13 )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}

//----- (10073E50) --------------------------------------------------------
char sub_10073E50()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_1031FB14 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(147, 12, &v17);
  byte_1031FB14 = 1;
  dword_10211664 = 0;
  dword_10211668 = 0;
  dword_1021166C = 0;
  dword_10211670 = 0;
  byte_10211674 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  sub_10073C10((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  }
  byte_1031FB14 = 0;
  sub_10073A10(&v16);
  if ( v16 != 101 )
  {
    byte_1031FB14 = 2;
    return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  }
  if ( byte_1031FB14 )
    return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  sub_10073A90(&unk_1031F9C8, &byte_1031FB0D);
  byte_1031FB0C = byte_1031FB0D - 1;
  if ( byte_1031FB14 )
    return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  result = sub_10073A40(&unk_1031F9C9, &byte_1031F9CA);
  byte_1031F2B0 = 0;
  if ( byte_1031FB14 )
    return (unsigned int)memset(dword_1031F2C0, 0, 0x708u);
  return result;
}
// 10211664: using guessed type int dword_10211664;
// 10211668: using guessed type int dword_10211668;
// 1021166C: using guessed type int dword_1021166C;
// 10211670: using guessed type int dword_10211670;
// 10211674: using guessed type char byte_10211674;
// 1031F1D4: using guessed type int dword_1031F1D4;
// 1031F2B0: using guessed type char byte_1031F2B0;
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031F9CA: using guessed type char byte_1031F9CA;
// 1031FB0C: using guessed type char byte_1031FB0C;
// 1031FB0D: using guessed type char byte_1031FB0D;
// 1031FB14: using guessed type char byte_1031FB14;

//----- (10074010) --------------------------------------------------------
int (__cdecl *(*sub_10074010())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_1031F1C4 = (int)off_10122980;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_1031F1D4)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10073C10((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100FB288)[8 * v1];
      v3 = strlen((&off_100FB288)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100FB28C)[v1];
        dword_1031F1C4 = (int)(&off_100FB28C)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100FB288: using guessed type char *off_100FB288;
// 100FB28C: using guessed type int (__cdecl *(*off_100FB28C)[2])(int, int);
// 10122980: using guessed type int (__cdecl *off_10122980[2])(int, int);
// 1031F1C4: using guessed type int dword_1031F1C4;
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (10074140) --------------------------------------------------------
int __usercall sub_10074140@<eax>(const char *a1@<eax>, int a2@<ecx>)
{
  int v2; // ebp@1
  int v3; // esi@1
  const char *v4; // edi@2
  int result; // eax@5
  const char *v6; // [sp+8h] [bp-4h]@2

  v2 = *(_WORD *)(a2 + 4);
  v3 = 0;
  if ( v2 <= 0 )
  {
    result = 0;
  }
  else
  {
    v6 = *(const char **)a2;
    v4 = *(const char **)a2;
    while ( strcmp(v4, a1) )
    {
      ++v3;
      v4 += 56;
      if ( v3 >= v2 )
        return 0;
    }
    result = (int)&v6[56 * v3];
  }
  return result;
}

//----- (100741C0) --------------------------------------------------------
int __cdecl sub_100741C0(float a1, float a2, int a3, int a4, int a5, float a6, char a7)
{
  int result; // eax@1
  int v8; // edi@1
  float v9; // ST20_4@2
  float v10; // ST24_4@2
  float v11; // ST10_4@2
  float v12; // ST24_4@2
  float v13; // ST24_4@2
  float v14; // ST10_4@2
  float v15; // ST24_4@2
  float v16; // ST20_4@2
  float v17; // ST24_4@2
  float v18; // ST10_4@2
  float v19; // ST24_4@2
  float v20; // ST24_4@2
  float v21; // ST10_4@2
  float v22; // ST24_4@2

  result = sub_10074140((const char *)a5, a3);
  v8 = result;
  if ( result )
  {
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_bind_texture(34, *(_DWORD *)(a3 + 8));
    sub_1008BFB0(1.0, 1.0, 1.0, a6);
    j_gdi_pvg_begin(72);
    v9 = (double)(a7 != 0);
    sub_1008C220(v9, *(float *)(v8 + 52));
    v10 = *(float *)(a4 + 4) + a2;
    v11 = v10;
    v12 = *(float *)a4 + a1;
    sub_1008C2F0(v12, v11);
    sub_1008C220(v9, *(float *)(v8 + 52));
    v13 = *(float *)(a4 + 28) + a2;
    v14 = v13;
    v15 = *(float *)(a4 + 24) + a1;
    sub_1008C2F0(v15, v14);
    v16 = (double)(a7 == 0);
    sub_1008C220(v16, *(float *)(v8 + 52));
    v17 = *(float *)(a4 + 20) + a2;
    v18 = v17;
    v19 = *(float *)(a4 + 16) + a1;
    sub_1008C2F0(v19, v18);
    sub_1008C220(v16, *(float *)(v8 + 52));
    v20 = *(float *)(a4 + 12) + a2;
    v21 = v20;
    v22 = *(float *)(a4 + 8) + a1;
    sub_1008C2F0(v22, v21);
    j_gdi_pvg_end();
    result = j_gdi_pvg_pop_attrib();
  }
  return result;
}
// 1008BEE0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 1008BF00: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 1008C0B0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 1008C1A0: using guessed type int j_gdi_pvg_pop_attrib(void);
// 1008C1C0: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (10074360) --------------------------------------------------------
signed int __cdecl sub_10074360(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (10074380) --------------------------------------------------------
double __cdecl sub_10074380(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (100743C0) --------------------------------------------------------
void __cdecl sub_100743C0(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (10074460) --------------------------------------------------------
char __cdecl sub_10074460(int a1, char a2, int a3, _DWORD *a4, int a5)
{
  int v5; // esi@1
  char v6; // bl@1
  __int16 v7; // dx@1
  __int16 v8; // cx@1
  unsigned __int16 v9; // cx@1
  int v10; // eax@1
  int v11; // eax@3
  unsigned __int16 v12; // cx@3
  char v13; // cl@8
  char v14; // cl@10
  char v15; // bl@13
  unsigned __int16 v16; // dx@14
  unsigned __int16 v17; // cx@17
  unsigned __int16 v18; // dx@18
  char v20; // [sp+Eh] [bp-1Ah]@1
  unsigned __int8 v21; // [sp+Fh] [bp-19h]@2
  unsigned __int16 i; // [sp+10h] [bp-18h]@1
  char v23; // [sp+18h] [bp-10h]@1
  char v24[8]; // [sp+19h] [bp-Fh]@1
  char v25; // [sp+21h] [bp-7h]@13

  v5 = a1;
  v6 = 7 - a2;
  (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(a1, 10, &v23);
  v7 = (unsigned __int8)v24[0];
  LOBYTE(v8) = 0;
  HIBYTE(v8) = v23;
  v20 = 2;
  *a4 = 0;
  v9 = v7 | v8;
  LOBYTE(v10) = v9;
  for ( i = v9; *a4 < a3; ++*a4 )
  {
    LOBYTE(v10) = 0;
    v21 = 0;
    while ( 1 )
    {
      v11 = 6 * (unsigned __int8)v10;
      v12 = word_100FB2DA[v11] & (i >> (16 - byte_100FB2D8[v11 * 2] - v6));
      if ( v12 >= (unsigned __int16)word_100FB2DC[v11] && v12 <= (unsigned __int16)word_100FB2DE[v11] )
        break;
      LOBYTE(v10) = v21++ + 1;
      if ( v21 >= 4u )
        return v10;
    }
    LOBYTE(v10) = v21;
    if ( v21 >= 4u )
      break;
    v10 = 12 * v21;
    v13 = *((char *)*(&off_100FB2E0 + 3 * v21) + v12 - (unsigned __int16)word_100FB2DC[6 * v21]);
    if ( !v13 )
      break;
    *(_BYTE *)(*a4 + a5) = v13;
    v6 += byte_100FB2D8[v10];
    if ( v6 == 16 )
    {
      v14 = v20;
      if ( v20 == 10 )
      {
        v5 += 10;
        (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v5, 10, &v23);
        LOBYTE(v10) = 0;
        BYTE1(v10) = v23;
        v20 = 2;
        LOWORD(v10) = (unsigned __int8)v24[0] | (unsigned __int16)v10;
        i = v10;
        v6 = 0;
      }
      else if ( v20 == 9 )
      {
        v15 = v25;
        v5 += 10;
        (*(void (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v5, 10, &v23);
        BYTE1(v10) = v15;
        v20 = 1;
        v6 = 0;
        LOBYTE(v10) = v23;
        i = v10;
      }
      else
      {
        HIBYTE(v16) = *(&v23 + (unsigned __int8)v20);
        v20 += 2;
        v6 = 0;
        LOBYTE(v16) = v24[(unsigned __int8)v14];
        LOBYTE(v10) = v24[(unsigned __int8)v14];
        i = v16;
      }
    }
    else if ( v6 >= 8 )
    {
      if ( v20 == 10 )
      {
        v5 += 10;
        LOBYTE(v10) = (*(int (__cdecl **)(int, signed int, char *))dword_1031F1D4)(v5, 10, &v23);
        HIBYTE(v17) = i;
        v20 = 1;
        LOBYTE(v17) = v23;
        i = v17;
      }
      else
      {
        LOBYTE(v18) = *(&v23 + (unsigned __int8)v20);
        HIBYTE(v18) = i;
        LOBYTE(v10) = v20++ + 1;
        i = v18;
      }
      v6 -= 8;
    }
  }
  return v10;
}
// 100FB2DA: using guessed type __int16 word_100FB2DA[];
// 100FB2DC: using guessed type __int16 word_100FB2DC[];
// 100FB2DE: using guessed type __int16 word_100FB2DE[];
// 100FB2E0: using guessed type void *off_100FB2E0;
// 1031F1D4: using guessed type int dword_1031F1D4;
// 10074460: using guessed type char var_F[8];

//----- (100746A0) --------------------------------------------------------
bool __cdecl sub_100746A0(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_1031F2C8[v2 / 4] && word_1031F2C4[v2 / 2] && dword_1031F2C0[v2 / 4] )
      result = 1;
  }
  return result;
}
// 1031F2C0: using guessed type int dword_1031F2C0[];
// 1031F2C4: using guessed type __int16 word_1031F2C4[];
// 1031F2C8: using guessed type int dword_1031F2C8[];

//----- (100746E0) --------------------------------------------------------
int __cdecl sub_100746E0(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_100746A0(0, a1) )
    result = dword_1031F2C8[3 * v1];
  else
    result = 0;
  return result;
}
// 1031F2C8: using guessed type int dword_1031F2C8[];

//----- (10074710) --------------------------------------------------------
bool __cdecl sub_10074710(unsigned int a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // dx@1

  return sub_100746A0(0, a2) && a1 < 0xFFFFFF && a1 >= dword_1031F2C0[3 * v2];
}
// 1031F2C0: using guessed type int dword_1031F2C0[];

//----- (10074750) --------------------------------------------------------
int __cdecl sub_10074750(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_100958C0(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10074850) --------------------------------------------------------
signed int __cdecl sub_10074850(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100748F0) --------------------------------------------------------
int __cdecl sub_100748F0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (10074920) --------------------------------------------------------
bool sub_10074920()
{
  return sub_1008C830(99) == 0;
}

//----- (10074930) --------------------------------------------------------
bool sub_10074930()
{
  return sub_1008C850(99, 10000) == 0;
}

//----- (10074950) --------------------------------------------------------
char __cdecl sub_10074950(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1006E440((_DWORD *)a2, 2u, (int)&unk_100FB380, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100FB384[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_1008C8B0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1008C710();
        sub_10064B00(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10051A40("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100FB384: using guessed type int dword_100FB384[];

//----- (10074A70) --------------------------------------------------------
char __cdecl sub_10074A70(int a1)
{
  return sub_10074950(31, a1);
}

//----- (10074A80) --------------------------------------------------------
char __cdecl sub_10074A80(unsigned __int16 a1)
{
  int v1; // eax@2
  char v3; // [sp+Ah] [bp-2h]@1
  char v4; // [sp+Bh] [bp-1h]@1

  v3 = 0;
  v4 = 1;
  if ( a1 > 0x3E7u )
  {
    if ( (unsigned __int16)(a1 - 1000) > 0x3E7u )
    {
      if ( (unsigned __int16)(a1 - 2000) > 0x1F3u )
      {
        sub_10064B00(byte_10211680, 0x64u, "Invalid alert ID (%u) out of range", a1);
        LOBYTE(v1) = sub_10051A40("..\\lib\\adl\\sys_updt_alrt_data.c", 450, 0, byte_10211680);
      }
      else
      {
        v1 = sub_1008CC30((unsigned __int16)(a1 - 2000) + 26000, &v3, 1, &v4);
        if ( !v1 && !v3 )
        {
          v3 = 1;
          LOBYTE(v1) = sub_1008CB30((unsigned __int16)(a1 - 2000) + 26000, (int)&v3, 1);
        }
      }
    }
    else
    {
      v1 = sub_1008CC30((unsigned __int16)(a1 - 1000) + 27000, &v3, 1, &v4);
      if ( !v1 && !v3 )
      {
        v3 = 1;
        LOBYTE(v1) = sub_1008CB30((unsigned __int16)(a1 - 1000) + 27000, (int)&v3, 1);
      }
    }
  }
  else
  {
    v1 = sub_1008CC30(a1 + 28000, &v3, 1, &v4);
    if ( !v1 && !v3 )
    {
      v3 = 1;
      LOBYTE(v1) = sub_1008CB30(a1 + 28000, (int)&v3, 1);
    }
  }
  return v1;
}

//----- (10074BD0) --------------------------------------------------------
unsigned int __cdecl sub_10074BD0(char *a1)
{
  return sub_10080B10(a1, -100, 100, 0, 0);
}

//----- (10074BF0) --------------------------------------------------------
int __cdecl sub_10074BF0(_BYTE *a1)
{
  return sub_10080D70(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10074C10) --------------------------------------------------------
int __cdecl sub_10074C10(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 1u, 1u, 0);
}

//----- (10074C30) --------------------------------------------------------
unsigned int __cdecl sub_10074C30(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100809D0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10080C80((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_100809D0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080C80((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080C80((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10074F60) --------------------------------------------------------
unsigned int __cdecl sub_10074F60(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100809D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100809D0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10080B10((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100753A0) --------------------------------------------------------
unsigned int __cdecl sub_100753A0(_BYTE *a1)
{
  return sub_10080B60(a1, -1, 5, -1, 0);
}

//----- (100753C0) --------------------------------------------------------
int __cdecl sub_100753C0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 5u, 0, 0);
}

//----- (100753E0) --------------------------------------------------------
int __cdecl sub_100753E0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 4u, 2u, 0);
}

//----- (10075400) --------------------------------------------------------
int __cdecl sub_10075400(_BYTE *a1)
{
  return sub_10080D70(a1, 0, 2u, 0, 0);
}

//----- (10075420) --------------------------------------------------------
int __cdecl sub_10075420(int a1)
{
  return sub_10080A20(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10075470) --------------------------------------------------------
int __cdecl sub_10075470(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10075420((int)(a1 + 4));
  if ( !result )
    result = sub_100753E0(a1);
  return result;
}

//----- (10075490) --------------------------------------------------------
int __cdecl sub_10075490(int a1)
{
  int result; // eax@1

  result = sub_100753C0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_100753C0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_100753C0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10082180((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_100809D0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_100809D0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_100809D0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_100809D0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10075520) --------------------------------------------------------
unsigned int __cdecl sub_10075520(int a1)
{
  unsigned int result; // eax@1

  result = sub_100753A0((_BYTE *)a1);
  if ( !result )
    result = sub_100753A0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10075540) --------------------------------------------------------
signed int __cdecl sub_10075540(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_100809D0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_100809D0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10075590) --------------------------------------------------------
unsigned int __cdecl sub_10075590(int a1)
{
  unsigned int result; // eax@1

  result = sub_100753A0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100753A0((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_100753A0((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_100753A0((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_100809D0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (100755F0) --------------------------------------------------------
int __cdecl sub_100755F0(_BYTE *a1)
{
  return sub_10080D70(a1, 0, 0x20u, 2u, 0);
}

//----- (10075610) --------------------------------------------------------
unsigned int __cdecl sub_10075610(_BYTE *a1)
{
  return sub_10080B60(a1, -1, 4, -1, 0);
}

//----- (10075630) --------------------------------------------------------
int __cdecl sub_10075630(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 9u, 0, 0);
}

//----- (10075650) --------------------------------------------------------
int __cdecl sub_10075650(_BYTE *a1)
{
  return sub_10080D70(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10075670) --------------------------------------------------------
signed int __cdecl sub_10075670(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10080D70(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100756A0) --------------------------------------------------------
int __cdecl sub_100756A0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10080CD0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100756E0) --------------------------------------------------------
int __cdecl sub_100756E0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10075670((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_100756A0((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100756A0((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100823E0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100756A0((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10075770) --------------------------------------------------------
int __cdecl sub_10075770(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 2u, 0, 0);
}

//----- (10075790) --------------------------------------------------------
int __cdecl sub_10075790(int a1)
{
  int result; // eax@1

  result = sub_10080C80((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10080C80((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (100757C0) --------------------------------------------------------
int __cdecl sub_100757C0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 3u, 1u, 0);
}

//----- (100757E0) --------------------------------------------------------
unsigned int __cdecl sub_100757E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10080B60((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10080B60((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10075810) --------------------------------------------------------
int __cdecl sub_10075810(int a1)
{
  int result; // eax@1

  result = sub_10080A20(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10080A20(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10080A20(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10080A20(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10080A20(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10075900) --------------------------------------------------------
int __cdecl sub_10075900(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100809D0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10080C80((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_100757E0(a1 + 36);
        if ( !result )
        {
          result = sub_10080A20(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10075810(a1 + 8);
            if ( !result )
            {
              result = sub_100757E0(a1 + 28);
              if ( !result )
              {
                result = sub_10080CD0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10075770((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10075790(a1 + 57);
                    if ( !result )
                    {
                      result = sub_100809D0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_100757C0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10075A10) --------------------------------------------------------
signed int __cdecl sub_10075A10(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10080C80(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075A40) --------------------------------------------------------
signed int __cdecl sub_10075A40(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10080CD0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075A70) --------------------------------------------------------
int __cdecl sub_10075A70(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_10076860(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10075AA0) --------------------------------------------------------
int __cdecl sub_10075AA0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10075B00) --------------------------------------------------------
int __cdecl sub_10075B00(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100809D0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10075AA0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10075B10) --------------------------------------------------------
signed int __cdecl sub_10075B10(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10080D70(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10075B40) --------------------------------------------------------
int __cdecl sub_10075B40(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10080C80((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10080C80((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10075BD0) --------------------------------------------------------
int __cdecl sub_10075BD0(int a1)
{
  int result; // eax@1

  result = sub_10076770((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_10076770((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_10082410((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10075BC0(a1 + 24);
        if ( !result )
        {
          result = sub_10082410((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_100823C0((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_10082410((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10075BC0: using guessed type _DWORD __cdecl sub_10075BC0(_DWORD);

//----- (10075C50) --------------------------------------------------------
unsigned int __cdecl sub_10075C50(int a1)
{
  unsigned int result; // eax@1

  result = sub_10074BD0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10074BD0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10074BD0((char *)a1);
      if ( !result )
        result = sub_10074BD0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10075C90) --------------------------------------------------------
unsigned int __cdecl sub_10075C90(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10075C50(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10075770((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10074C10((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10075CE0) --------------------------------------------------------
int __cdecl sub_10075CE0(int a1)
{
  int result; // eax@1

  result = sub_10074BF0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10080CD0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10075D10) --------------------------------------------------------
int __cdecl sub_10075D10(int a1)
{
  int result; // eax@1

  result = sub_10075400((_BYTE *)a1);
  if ( !result )
    result = sub_10075650((_BYTE *)(a1 + 4));
  return result;
}

//----- (10075D40) --------------------------------------------------------
unsigned int __cdecl sub_10075D40(int a1)
{
  unsigned int result; // eax@1

  result = sub_100753A0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100753A0((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10075610((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10075D70) --------------------------------------------------------
unsigned int __cdecl sub_10075D70(int a1)
{
  unsigned int result; // eax@1

  result = sub_100753A0((_BYTE *)a1);
  if ( !result )
    result = sub_10075630((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10075D90) --------------------------------------------------------
unsigned int __cdecl sub_10075D90(int a1)
{
  unsigned int result; // eax@1

  result = sub_100753A0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10080C80((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10075610((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10075DD0) --------------------------------------------------------
void __cdecl __noreturn sub_10075DD0(int a1)
{
  exit(a1 + 4);
}

//----- (10075F40) --------------------------------------------------------
signed int __cdecl sub_10075F40(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10075A10((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10075A40((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10075A10((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10075FA0) --------------------------------------------------------
signed int __usercall sub_10075FA0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10075F40(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10080C80((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_100809D0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10074F60(v2 + 5, a2);
    else
      result = sub_10074C30(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10075B10((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10076070) --------------------------------------------------------
signed int __cdecl sub_10076070(int a1)
{
  return sub_10075FA0(a1, 0);
}

//----- (10076080) --------------------------------------------------------
char __cdecl sub_10076080(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (100760C0) --------------------------------------------------------
signed int __cdecl sub_100760C0(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10051A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10076100) --------------------------------------------------------
int __cdecl sub_10076100(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1008D590: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10076170) --------------------------------------------------------
bool __cdecl sub_10076170(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_100641E0(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100FD708[(unsigned __int8)v4](v3) )
    {
      sub_10076100((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_100768B0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10072410(2) )
    result = 0;
  else
    result = sub_100730B0(2, v5, a2) == 1 && !sub_10082360(a2);
  return result;
}
// 100FD708: using guessed type int (__cdecl *off_100FD708[3])(char);

//----- (10076230) --------------------------------------------------------
char __cdecl sub_10076230(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10076170(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10076890(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (100762F0) --------------------------------------------------------
char __cdecl sub_100762F0(char a1)
{
  char result; // al@1

  result = sub_10082430();
  if ( result == 2 )
    result = byte_100FDC8C[8 * sub_1006E440(&a1, 4u, (int)&unk_100FDC88, 8, 7, 7)];
  return result;
}

//----- (10076320) --------------------------------------------------------
char __thiscall sub_10076320(void *this)
{
  char v1; // al@1

  v1 = sub_1006F3C0(this);
  return sub_100762F0(v1);
}

//----- (10076330) --------------------------------------------------------
char __cdecl sub_10076330(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_100730B0(1, v2, a2) || sub_10075BD0((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100763E0) --------------------------------------------------------
char __cdecl sub_100763E0(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_10076330(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (10076440) --------------------------------------------------------
int __cdecl sub_10076440(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10076450) --------------------------------------------------------
unsigned int __usercall sub_10076450@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  char v3; // dl@1
  int v4; // ecx@5
  int v5; // esi@5
  float *v6; // edx@6
  _BYTE *v7; // edx@11
  char *v8; // ecx@11
  char v9; // al@12
  int v10; // eax@14
  int v11; // edi@16
  char *v12; // eax@16
  long double v13; // ST28_8@19
  long double v14; // st6@19
  int v15; // edi@19
  char *v16; // eax@21
  _BYTE *v17; // esi@21
  char v18; // cl@22
  unsigned int result; // eax@23
  _BYTE *v20; // edi@23
  char v21; // cl@24
  const void *v22; // ebx@25
  char *v23; // eax@28
  char v24; // cl@29
  char v25; // cl@31
  char *v26; // eax@34
  _BYTE *v27; // edx@34
  char v28; // cl@35
  _BYTE *v29; // edi@36
  char v30; // cl@37
  __int32 v31; // [sp+18h] [bp-8h]@17

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  if ( *(_BYTE *)v2 <= 1u )
    v3 = 1;
  if ( 9.8999998e24 == *(float *)a1 )
    goto LABEL_10;
  if ( !v3 )
  {
    v4 = *(_BYTE *)v2 - 1;
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = (float *)(v2 + 44);
      while ( *(v6 - 5) > (double)*(float *)a1 || *v6 <= (double)*(float *)a1 )
      {
        ++v5;
        v6 += 5;
        if ( v5 >= v4 )
          goto LABEL_10;
      }
      v10 = v5 + 1;
      if ( *(float *)v1 >= 0.0 )
        v10 = v5;
      v11 = 20 * v10;
      sprintf(*(char **)(v1 + 36), (const char *)(20 * v10 + v2 + 28), *(float *)v1);
      v12 = strrchr((const char *)(v11 + *(_DWORD *)(v1 + 32) + 28), 46);
      if ( v12 )
        v31 = j__atol(v12 + 1);
      else
        v31 = 0;
      v13 = pow(10.0, (double)v31);
      v14 = atof((const char *)*(_DWORD *)(v1 + 36)) * v13;
      v15 = *(_DWORD *)(v1 + 32);
      if ( (signed int)v14 != (signed int)(v13 * *(float *)(v15 + 20 * v5 + 24)) )
        ++v5;
      sprintf(*(char **)(v1 + 36), (const char *)(v15 + 20 * v5 + 28), *(float *)v1);
      v16 = (char *)(*(_DWORD *)(v1 + 32) + 11);
      v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
      do
        v18 = *v16++;
      while ( v18 );
      result = v16 - v17;
      v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
      do
        v21 = (v20++)[1];
      while ( v21 );
      goto LABEL_25;
    }
LABEL_10:
    if ( *(_DWORD *)(a1 + 40) )
    {
      memset(*(void **)(a1 + 36), 95, *(_DWORD *)(a1 + 40));
      *(_BYTE *)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 36)) = 0;
    }
    else
    {
      v7 = *(_BYTE **)(a1 + 36);
      v8 = (char *)(v2 + 1);
      do
      {
        v9 = *v8;
        *v7++ = *v8++;
      }
      while ( v9 );
    }
    v26 = (char *)(*(_DWORD *)(v1 + 32) + 11);
    v27 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
    do
      v28 = *v26++;
    while ( v28 );
    result = v26 - v27;
    v29 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
    do
      v30 = (v29++)[1];
    while ( v30 );
    qmemcpy(v29, v27, result);
    return result;
  }
  sprintf(*(char **)(a1 + 36), (const char *)(v2 + 28), *(float *)a1);
  v23 = (char *)(*(_DWORD *)(v1 + 32) + 11);
  v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
  do
    v24 = *v23++;
  while ( v24 );
  result = v23 - v17;
  v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
  do
    v25 = (v20++)[1];
  while ( v25 );
LABEL_25:
  qmemcpy(v20, v17, result);
  v22 = *(const void **)(v1 + 36);
  if ( !memcmp(v22, "-0", 3u) )
    *(_WORD *)v22 = 48;
  return result;
}

//----- (10076690) --------------------------------------------------------
char __cdecl sub_10076690(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  signed int v8; // ecx@1
  signed int v9; // edx@1
  __int16 v10; // ax@1
  float v12; // [sp+4h] [bp-24h]@1
  float v13; // [sp+8h] [bp-20h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  float v15; // [sp+10h] [bp-18h]@1
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+1Ch] [bp-Ch]@1
  float v19; // [sp+20h] [bp-8h]@1
  float v20; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 8);
  v6 = *(_DWORD *)(a4 + 4);
  v15 = *(float *)(a4 + 12);
  v7 = *(_DWORD *)(a4 + 20);
  v18 = *(float *)(a4 + 24);
  v16 = v5;
  v19 = *(float *)(a4 + 28);
  v17 = v6;
  v8 = *(_WORD *)a3;
  v20 = *(float *)(a4 + 16);
  v14 = v7;
  v9 = *(_WORD *)(a3 + 2);
  v12 = (double)v8;
  v10 = *a5;
  v13 = (double)v9;
  if ( v10 == -32648 || v10 == -32734 || v10 == -32704 )
    sub_10076450(a4);
  if ( (unsigned __int16)*a5 != 32802 )
  {
    if ( (unsigned __int16)*a5 == 32832 )
    {
      sub_10065630(a1, *(_DWORD *)(a4 + 36), (int)&v12);
      return 2;
    }
    if ( (unsigned __int16)*a5 != 32888 )
      return 1;
  }
  sub_10065B70(a1, *(_DWORD *)(a4 + 36), (int)&v12);
  return 2;
}

//----- (10076770) --------------------------------------------------------
int __cdecl sub_10076770(_BYTE *a1)
{
  return sub_10080CD0(a1, 0, 0x2710u, 5000, 0);
}

//----- (10076790) --------------------------------------------------------
int __cdecl sub_10076790(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 5u, 5u, 0);
}

//----- (100767B0) --------------------------------------------------------
int __cdecl sub_100767B0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 6u, 0, 0);
}

//----- (100767D0) --------------------------------------------------------
int __cdecl sub_100767D0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 0xEu, 1u, 0);
}

//----- (100767F0) --------------------------------------------------------
int __cdecl sub_100767F0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 1u, 0, 0);
}

//----- (10076820) --------------------------------------------------------
int __cdecl sub_10076820(int a1)
{
  int result; // eax@1

  result = sub_10076790((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10076810(a1 + 12);
    if ( !result )
    {
      result = sub_100767F0((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_100767D0((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 10076810: using guessed type _DWORD __cdecl sub_10076810(_DWORD);

//----- (10076860) --------------------------------------------------------
int __cdecl sub_10076860(int a1)
{
  int result; // eax@1

  result = sub_10082290((void *)(a1 + 28));
  if ( !result )
    result = sub_10076820(a1);
  return result;
}

//----- (10076880) --------------------------------------------------------
signed int __fastcall sub_10076880(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10076890) --------------------------------------------------------
char __cdecl sub_10076890(unsigned __int8 a1)
{
  return byte_10113734[6 * sub_10076880(a1)];
}

//----- (100768B0) --------------------------------------------------------
__int16 __cdecl sub_100768B0(unsigned __int8 a1)
{
  return word_10113730[3 * sub_10076880(a1)];
}
// 10113730: using guessed type __int16 word_10113730[];

//----- (100768D0) --------------------------------------------------------
int __cdecl sub_100768D0(int a1)
{
  return a1 + 9;
}

//----- (100768E0) --------------------------------------------------------
int __cdecl sub_100768E0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_1008C710();
  memset(a1, 0, 0xDCu);
  sub_10064B00((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_100768D0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10082440((int)a1, (int)v3);
}

//----- (10076960) --------------------------------------------------------
int __cdecl sub_10076960(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10082650(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10076990) --------------------------------------------------------
signed int __cdecl sub_10076990(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1008D710(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_1008C780();
    }
    else if ( v6 != -57 || (unsigned int)(sub_1008C780() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10082440(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (100769B0) --------------------------------------------------------
char __cdecl sub_100769B0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10071410() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10081890("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_100721B0() )
          v7 = 0;
      }
      v5 = sub_10081890("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_100721B0() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10076AC0) --------------------------------------------------------
char __cdecl sub_10076AC0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10076AF0) --------------------------------------------------------
bool __cdecl sub_10076AF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10076B20) --------------------------------------------------------
bool __cdecl sub_10076B20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10076B50) --------------------------------------------------------
bool __cdecl sub_10076B50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10076B80) --------------------------------------------------------
bool __cdecl sub_10076B80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10076BB0) --------------------------------------------------------
bool __cdecl sub_10076BB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10076BE0) --------------------------------------------------------
bool __cdecl sub_10076BE0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10076C20) --------------------------------------------------------
bool __cdecl sub_10076C20(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10076C60) --------------------------------------------------------
bool __cdecl sub_10076C60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10076C90) --------------------------------------------------------
bool __cdecl sub_10076C90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10076CC0) --------------------------------------------------------
char __cdecl sub_10076CC0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10076CF0) --------------------------------------------------------
bool __cdecl sub_10076CF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10076D20) --------------------------------------------------------
bool __cdecl sub_10076D20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10076D50) --------------------------------------------------------
bool __cdecl sub_10076D50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10076D80) --------------------------------------------------------
bool __cdecl sub_10076D80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10076DB0) --------------------------------------------------------
bool __cdecl sub_10076DB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100F81C0, 9u);
}

//----- (10076DE0) --------------------------------------------------------
bool __cdecl sub_10076DE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10076E10) --------------------------------------------------------
bool __cdecl sub_10076E10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10076E40) --------------------------------------------------------
bool __cdecl sub_10076E40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10076E70) --------------------------------------------------------
bool __cdecl sub_10076E70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10076EA0) --------------------------------------------------------
bool __cdecl sub_10076EA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10076ED0) --------------------------------------------------------
int __cdecl sub_10076ED0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10071410() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10076F40) --------------------------------------------------------
int __cdecl sub_10076F40(int a1, char a2)
{
  return sub_10076ED0(a1, (int)&a2, 1);
}

//----- (10076F60) --------------------------------------------------------
int __cdecl sub_10076F60(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10076ED0(a1, (int)&v4, 2);
}

//----- (10076F90) --------------------------------------------------------
int __cdecl sub_10076F90(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10076ED0(a1, (int)&v5, 3);
}

//----- (10076FC0) --------------------------------------------------------
int __cdecl sub_10076FC0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10076ED0(a1, (int)&v6, 4);
}

//----- (10077000) --------------------------------------------------------
int __cdecl sub_10077000(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10076ED0(a1, (int)&v7, 5);
}

//----- (10077040) --------------------------------------------------------
int __cdecl sub_10077040(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10076ED0(a1, (int)&v8, 6);
}

//----- (10077090) --------------------------------------------------------
char __cdecl sub_10077090(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10071410();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (100770C0) --------------------------------------------------------
char __cdecl sub_100770C0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (100770D0) --------------------------------------------------------
char __cdecl sub_100770D0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = byte_100B8180;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10082770(v16) )
        sub_10082750((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10082780((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10082770: using guessed type _DWORD __cdecl sub_10082770(_DWORD);
// 100770D0: using guessed type char var_104[255];

//----- (10077250) --------------------------------------------------------
signed int __cdecl sub_10077250(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10077290) --------------------------------------------------------
signed int __cdecl sub_10077290(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10077330) --------------------------------------------------------
char __cdecl sub_10077330(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10077390) --------------------------------------------------------
char __cdecl sub_10077390(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10082730(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (10077400) --------------------------------------------------------
char *__cdecl sub_10077400(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_102116E8, v1, v2);
  *(&byte_102116E8 + v2) = 0;
  return &byte_102116E8;
}

//----- (100774A0) --------------------------------------------------------
int __cdecl sub_100774A0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10077510) --------------------------------------------------------
bool __cdecl sub_10077510(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10098802(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10098802(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (100775A0) --------------------------------------------------------
char __cdecl sub_100775A0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10077650) --------------------------------------------------------
char __cdecl sub_10077650(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10077660) --------------------------------------------------------
char __cdecl sub_10077660(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10082730(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (100776E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100776E0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10082800((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (10077730) --------------------------------------------------------
signed int __cdecl sub_10077730(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_10077660(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10077780) --------------------------------------------------------
char *__cdecl sub_10077780(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10081890("CFG_ActDir", (int)byte_100B8180);
      v10 = sub_10081890("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10081890("CFG_ExpDir", (int)byte_100B8180);
      v10 = sub_10081890("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10081890("CFG_ActDir", (int)byte_100B8180);
      break;
    case 4:
      v10 = sub_10081890("CFG_ExpDir", (int)byte_100B8180);
      break;
    default:
      v10 = byte_100B8180;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = byte_100B8180;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 10077780: using guessed type char var_104[256];

//----- (10077900) --------------------------------------------------------
int sub_10077900()
{
  return dword_102163D8[sub_100704D0()];
}
// 102163D8: using guessed type int dword_102163D8[];

//----- (10077910) --------------------------------------------------------
const char *__cdecl sub_10077910(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_10113D08[a1];
  return result;
}
// 10113D08: using guessed type char *off_10113D08[7];

//----- (10077930) --------------------------------------------------------
int __cdecl sub_10077930(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10077000(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (100779E0) --------------------------------------------------------
int __cdecl sub_100779E0(int a1)
{
  int result; // eax@1

  result = sub_100704D0();
  dword_102184E4[result] = a1;
  return result;
}
// 102184E4: using guessed type int dword_102184E4[];

//----- (10077A00) --------------------------------------------------------
int __cdecl sub_10077A00(int a1)
{
  int result; // eax@1

  result = sub_100704D0();
  dword_102163D8[result] = a1;
  return result;
}
// 102163D8: using guessed type int dword_102163D8[];

//----- (10077A20) --------------------------------------------------------
char *sub_10077A20(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_100704D0() << 8;
  _vsnprintf(&byte_102117E8[v1], 0x100u, a1, va);
  result = &byte_102117E8[v1];
  byte_102118E6[v1] = 42;
  byte_102118E7[v1] = 0;
  return result;
}

//----- (10077A60) --------------------------------------------------------
char *__usercall sub_10077A60@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_10113D1C[a1 & 1];
  else
    result = off_10113D14[a2];
  return result;
}
// 10113D14: using guessed type char *off_10113D14[4];
// 10113D1C: using guessed type char *off_10113D1C[2];

//----- (10077A80) --------------------------------------------------------
char __usercall sub_10077A80@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_100704D0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_10077900() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_10219AD8[v6];
      v12 = dword_10219AEC[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_102163EC[v6];
      v12 = dword_102184D0[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 102163EC: using guessed type int dword_102163EC[];
// 102184D0: using guessed type int dword_102184D0[];
// 10219AD8: using guessed type int dword_10219AD8[];
// 10219AEC: using guessed type int dword_10219AEC[];

//----- (10077C60) --------------------------------------------------------
int sub_10077C60()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (10077C80) --------------------------------------------------------
int sub_10077C80()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (10077CA0) --------------------------------------------------------
int __cdecl sub_10077CA0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100704D0();
  dword_102184D0[result] = a1;
  if ( a2 >= 0 )
  {
    dword_102163EC[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_10077A20(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10076FC0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_102163EC[result] = 8;
  }
  return result;
}
// 102163EC: using guessed type int dword_102163EC[];
// 102184D0: using guessed type int dword_102184D0[];

//----- (10077D00) --------------------------------------------------------
int __cdecl sub_10077D00(int a1)
{
  return sub_10077CA0(0, a1);
}

//----- (10077D10) --------------------------------------------------------
int __cdecl sub_10077D10(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100704D0();
  dword_10219AEC[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10219AD8[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_10077A20(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10076FC0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_10219AD8[result] = 8;
  }
  return result;
}
// 10219AD8: using guessed type int dword_10219AD8[];
// 10219AEC: using guessed type int dword_10219AEC[];

//----- (10077D70) --------------------------------------------------------
int __cdecl sub_10077D70(int a1)
{
  return sub_10077D10(0, a1);
}

//----- (10077D80) --------------------------------------------------------
bool __cdecl sub_10077D80(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10071430() )
    v8 = v8 == 0;
  v9 = (&off_10113CEC)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_10113CDC[v8 != 0];
  v19 = off_10113CE4[a1];
  v18 = v10;
  v21 = sub_10077A60(0, a6);
  v22 = sub_10077A60(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_100829E0();
  sub_10076ED0(7, (int)&v14, v11);
  sub_100829F0(v12);
  return v8;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10077EC0) --------------------------------------------------------
bool __cdecl sub_10077EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_100704D0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10071430() )
    v16 = v16 == 0;
  sub_10077A80((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_102127D8[v11], 0x400u, &v30, a6);
  byte_10212BD6[v11] = 42;
  byte_10212BD7[v11] = 0;
  v17 = sub_10077A80((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v11], 0x400u, &v30, a7);
  byte_10212FD6[v11] = 42;
  byte_10212FD7[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_10212FD8[v11];
    byte_10212FD8[v11] = 0;
  }
  else
  {
    v17 = sub_10077A80((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_10212FD8[v11];
    _snprintf(&byte_10212FD8[v11], 0x400u, &v30, 0);
    byte_102133D6[v11] = 42;
    byte_102133D7[v11] = 0;
  }
  v19 = (&off_10113CEC)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_102127D8[v11];
  v27 = &byte_10212BD8[v11];
  v13 = off_10113CE4[a1];
  v23 = off_10113CDC[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_100829E0();
  sub_10076ED0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v14);
  return v16;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10078270) --------------------------------------------------------
bool __cdecl sub_10078270(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_100704D0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10071430() )
    v20 = v20 == 0;
  sub_10077A80((int)&v34, (char *)&unk_10113FD0, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_102127D8[v12], 0x400u, &v34);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v21 = sub_10077A80((int)&v34, (char *)&unk_10113FD0, 3, 0xCu, a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v34, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v13 = &byte_10212FD8[v12];
    v21 = sub_10077A80((int)&v34, (char *)&unk_10113FD0, 3, 0xCu, v10);
    _snprintf(&byte_10212FD8[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v23 = (&off_10113CEC)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_102127D8[v12];
  v32 = v13;
  v17 = off_10113CE4[a1];
  v27 = off_10113CDC[v20 != 0];
  v28 = v17;
  v31 = &byte_10212BD8[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_100829E0();
  sub_10076ED0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v18);
  return v20;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (100786C0) --------------------------------------------------------
bool __cdecl sub_100786C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_100704D0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10071430() )
    v25 = v25 == 0;
  sub_10077A80((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_102127D8[v20], 0x400u, &v40);
  byte_10212BD6[v20] = 42;
  byte_10212BD7[v20] = 0;
  v26 = sub_10077A80((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_10212BD8[v20], 0x400u, &v40, a7);
  byte_10212FD6[v20] = 42;
  byte_10212FD7[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_10212FD8[v20];
    byte_10212FD8[v20] = 0;
  }
  else
  {
    v21 = &byte_10212FD8[v20];
    v26 = sub_10077A80((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_10212FD8[v20], 0x400u, &v40, v28);
    byte_102133D6[v20] = 42;
    byte_102133D7[v20] = 0;
  }
  v29 = (&off_10113CEC)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_102127D8[v20];
  v37 = &byte_10212BD8[v20];
  v38 = v21;
  v22 = off_10113CDC[v25 != 0];
  v34 = off_10113CE4[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_100829E0();
  sub_10076ED0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v23);
  return v25;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10078B80) --------------------------------------------------------
bool __cdecl sub_10078B80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1011400C;
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10078F40) --------------------------------------------------------
bool __cdecl sub_10078F40(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v13 = &byte_10212FD8[v12];
    v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_102127D8[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CE4[a1];
  v24 = off_10113CDC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10079340) --------------------------------------------------------
bool __cdecl sub_10079340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10079700) --------------------------------------------------------
bool __cdecl sub_10079700(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_100704D0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10071430() )
        v18 = v18 == 0;
      sub_10077A80((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_102127D8[3072 * v21], 0x400u, &v33, a6);
      byte_10212BD6[v13] = 42;
      byte_10212BD7[v13] = 0;
      v19 = sub_10077A80((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_10212BD8[3072 * v21], 0x400u, &v33, a7);
      byte_10212FD6[v13] = 42;
      byte_10212FD7[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_10212FD8[v13];
        byte_10212FD8[v13] = 0;
      }
      else
      {
        v19 = sub_10077A80((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_10212FD8[v13];
        _snprintf(&byte_10212FD8[v13], 0x400u, &v33, a8);
        byte_102133D6[v13] = 42;
        byte_102133D7[v13] = 0;
      }
      v22 = (&off_10113CEC)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_102127D8[3072 * v21];
      v30 = &byte_10212BD8[3072 * v21];
      v15 = off_10113CE4[a1];
      v26 = off_10113CDC[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_100829E0();
      sub_10076ED0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10076FC0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100829F0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (10079C40) --------------------------------------------------------
bool __cdecl sub_10079C40(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v13 = &byte_10212FD8[v12];
    v18 = sub_10077A80((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_102127D8[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CE4[a1];
  v24 = off_10113CDC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007A020) --------------------------------------------------------
bool __cdecl sub_1007A020(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007A3E0) --------------------------------------------------------
bool __cdecl sub_1007A3E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007A780) --------------------------------------------------------
bool __cdecl sub_1007A780(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v13 = &byte_10212FD8[v12];
    v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_102127D8[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CE4[a1];
  v24 = off_10113CDC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007AB80) --------------------------------------------------------
bool __cdecl sub_1007AB80(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007AF20) --------------------------------------------------------
bool __cdecl sub_1007AF20(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_100704D0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10071430() )
        v19 = v19 == 0;
      sub_10077A80((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_102127D8[3072 * v22];
      _snprintf(&byte_102127D8[3072 * v22], 0x400u, &v35, a6);
      byte_10212BD6[v13] = 42;
      byte_10212BD7[v13] = 0;
      v20 = sub_10077A80((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_10212BD8[3072 * v22];
      _snprintf(&byte_10212BD8[v13], 0x400u, &v35, a7);
      byte_10212FD6[v13] = 42;
      byte_10212FD7[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_10212FD8[v13];
        byte_10212FD8[v13] = 0;
      }
      else
      {
        v20 = sub_10077A80((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_10212FD8[v13];
        _snprintf(&byte_10212FD8[v13], 0x400u, &v35, a8);
        byte_102133D6[v13] = 42;
        byte_102133D7[v13] = 0;
      }
      v24 = (&off_10113CEC)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_10113CE4[a1];
      v28 = off_10113CDC[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_100829E0();
      sub_10076ED0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10076FC0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100829F0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007B500) --------------------------------------------------------
bool __cdecl sub_1007B500(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v13 = &byte_10212FD8[v12];
    v18 = sub_10077A80((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_102127D8[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_10212BD8[v12];
  v29 = v13;
  v14 = off_10113CE4[a1];
  v24 = off_10113CDC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007B8F0) --------------------------------------------------------
bool __cdecl sub_1007B8F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100704D0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10071430() )
    v17 = v17 == 0;
  sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_102127D8[v12], 0x400u, &v31, a6);
  byte_10212BD6[v12] = 42;
  byte_10212BD7[v12] = 0;
  v18 = sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10212BD8[v12], 0x400u, &v31, a7);
  byte_10212FD6[v12] = 42;
  byte_10212FD7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10212FD8[v12];
    byte_10212FD8[v12] = 0;
  }
  else
  {
    v18 = sub_10077A80((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10212FD8[v12];
    _snprintf(&byte_10212FD8[v12], 0x400u, &v31, a8);
    byte_102133D6[v12] = 42;
    byte_102133D7[v12] = 0;
  }
  v20 = (&off_10113CEC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_10113CDC[v17 != 0];
  v25 = off_10113CE4[a1];
  v24 = v14;
  v27 = &byte_102127D8[v12];
  v28 = &byte_10212BD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100829E0();
  sub_10076ED0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10076FC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100829F0(v15);
  return v17;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007BC90) --------------------------------------------------------
int sub_1007BC90()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_100704D0();
  sub_100779E0(1);
  sub_10077D70(-1);
  result = sub_10077D00(-1);
  dword_102163D8[v0] = 0;
  return result;
}
// 102163D8: using guessed type int dword_102163D8[];

//----- (1007BCC0) --------------------------------------------------------
BOOL __usercall sub_1007BCC0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_100704D0();
  sub_10082A20((int)&v13);
  sub_10082A20((int)&v14);
  sub_10082A20((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10083670((int (__cdecl *)(unsigned int))sub_10077C60, v7, (int)&v13) )
  {
    if ( sub_10083670((int (__cdecl *)(unsigned int))sub_10077C60, a2, (int)&v14) )
    {
      v9 = sub_100834E0(
             dword_102184E4[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_10077C60,
             (void (__cdecl *)(_DWORD))sub_10077C80,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10083910((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10082AF0((void (__cdecl *)(_DWORD))sub_10077C80, (int)&v12);
  sub_10082AF0((void (__cdecl *)(_DWORD))sub_10077C80, (int)&v13);
  sub_10082AF0((void (__cdecl *)(_DWORD))sub_10077C80, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 102184E4: using guessed type int dword_102184E4[];

//----- (1007BE30) --------------------------------------------------------
bool __usercall sub_1007BE30@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_100704D0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10071430() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1007A3E0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10071430() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_102127D8[3072 * v24], 0x400u, "%s", v9);
  byte_10212BD6[v15] = 42;
  byte_10212BD7[v15] = 0;
  _snprintf(&byte_10212BD8[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_10113CEC)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_10212FD6[v15] = 42;
  v17 = off_10113CDC[v14 != 0];
  v18 = off_10113CE4[a3];
  byte_10212FD7[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_102127D8[3072 * v24];
  v34 = &byte_10212BD8[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_100829E0();
  sub_10076ED0(7, (int)&v26, v19);
  sub_100829F0(v20);
  return v14;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;

//----- (1007C0A0) --------------------------------------------------------
char __cdecl sub_1007C0A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_100704D0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_102184E4[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_10219B00[v10];
  sub_10077780(a3, 1, a6, 0x230u, &byte_10219B00[v10]);
  v27 = &byte_10216400[v10];
  sub_10077780(a3, 2, a7, 0x230u, &byte_10216400[v10]);
  v24 = &byte_102179E0[v10];
  sub_10077780(a3, 3, a6, 0x230u, &byte_102179E0[v10]);
  v26 = &byte_102184F8[v10];
  sub_10077780(a3, 4, a7, 0x230u, &byte_102184F8[v10]);
  _snprintf(&byte_10218FE8[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_10218FE8[v10];
  byte_10219217[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_10077780(a3, 0, v25, 560 - (v11 - &byte_10218FE8[v10 + 1]), &byte_10218FE8[v10] + v11 - &byte_10218FE8[v10 + 1]);
  v13 = &byte_10218FE8[v10];
  byte_10219217[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_10218FE4[v10] + v13 - &byte_10218FE8[v10 + 1]) = 0;
  sub_10077780(a3, 1, (int)&byte_10218FE8[v10], 0x230u, &byte_10211CE8[v10]);
  sub_10077780(a3, 1, (int)&byte_10218FE8[v10], 0x230u, &byte_10216EF0[v10]);
  v15 = sub_1007BCC0(v22, v27, v21, a2 == 1, (int)&byte_10211CE8[v10], (const char **)&v22);
  if ( sub_10071430() )
    v15 = v15 == 0;
  v30 = (&off_10113CEC)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_10113CE4[a1];
  v34 = off_10113CDC[v15 != 0];
  v17 = dword_102184E4[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_100829E0();
  sub_10076ED0(7, (int)&v30, v18);
  sub_100829F0(v19);
  return v15;
}
// 10113CDC: using guessed type char *off_10113CDC[5];
// 10113CE4: using guessed type char *off_10113CE4[3];
// 10113CEC: using guessed type char *off_10113CEC;
// 102184E4: using guessed type int dword_102184E4[];

//----- (1007C3A0) --------------------------------------------------------
bool __cdecl sub_1007C3A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_10078B80(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1007C450) --------------------------------------------------------
bool __cdecl sub_1007C450(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1007BE30(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1007C490) --------------------------------------------------------
const char *__cdecl sub_1007C490(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1007C4D0) --------------------------------------------------------
char __cdecl sub_1007C4D0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_100704D0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_1021A5F8 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_10077730((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10077250((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_10077730((int)v6, 0);
      return v5;
    case 4:
      sub_100770D0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_10077400((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_100776E0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_100770C0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10076AC0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1007C490((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_100776E0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        if ( v48 )
          sub_100776E0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        if ( v48 )
          sub_100776E0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_100D1710, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_100776E0((int)v6, v55);
              if ( v48 )
                sub_100776E0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_100776E0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_100776E0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_100776E0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10077330((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10076DE0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10076EA0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10076CF0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = byte_100B8180;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = byte_100B8180;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = byte_100B8180;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = byte_100B8180;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = byte_100B8180;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = byte_100B8180;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = byte_100B8180;
          v10 = sub_10076DB0((const void **)a2, a3) == 0;
          v42 = byte_100B8180;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10076AF0((const void **)a2, a3) )
      {
        dword_1021A5F0 = 2;
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0((int)v6, "   Command Format:\r\n");
        sub_100776E0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_100776E0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_100776E0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_100776E0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_100776E0((int)v6, "                                         strings depending upon the command\r\n");
        sub_100776E0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_100776E0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_100776E0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0((int)v6, "   Notes:\r\n");
        sub_100776E0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_100776E0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_100776E0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_100776E0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_100776E0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_100776E0((int)v6, "       without a test suite name.\r\n");
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0((int)v6, "   Examples:\r\n");
        sub_100776E0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_100776E0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_100776E0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_100776E0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_100776E0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_100776E0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_100776E0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_100776E0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_100776E0((int)v6, (const char *)&word_100B5558);
        sub_100776E0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_100776E0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10076B80((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, (const char *)&word_100B5558);
        return v5;
      }
      if ( sub_10076B50((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_1021A5F0,
          byte_100B8180,
          &v58,
          6 - dword_1021A5F0,
          word_100C2700,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
        return v5;
      }
      if ( sub_10076BB0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10076BE0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_1021A5F0 += 2;
          return v5;
        }
        if ( sub_10076C20((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_1021A5F0 < 2 )
            dword_1021A5F0 = 0;
          else
            dword_1021A5F0 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_1021A5F0,
          byte_100B8180,
          a2[2],
          6 - dword_1021A5F0,
          word_100C2700,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
        return v5;
      }
      if ( sub_10076B20((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_1021A5F0,
          byte_100B8180,
          a2[3],
          6 - dword_1021A5F0,
          word_100C2700,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10076C90((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
      }
      else if ( sub_10076C60((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1007C490((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1007C490((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_100776E0((int)v6, v55);
      }
      LOBYTE(v5) = sub_10077390((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_10077660((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100776E0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100B5558: using guessed type __int16 word_100B5558;
// 100D1710: using guessed type __int16 word_100D1710;
// 1021A5F0: using guessed type int dword_1021A5F0;
// 1007C4D0: using guessed type char var_304[508];

//----- (1007D280) --------------------------------------------------------
signed int __cdecl sub_1007D280(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_1021A5F8 + 580 * sub_100704D0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10077290(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1007D300) --------------------------------------------------------
char **__cdecl sub_1007D300(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_1021A5F8 + 580 * sub_100704D0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_100774A0((int)v1, a1, (int)".txt");
  return &off_101143C8;
}
// 101143C8: using guessed type char *off_101143C8;

//----- (1007D340) --------------------------------------------------------
int (**sub_1007D340())()
{
  return off_101150B0;
}
// 101150B0: using guessed type int (*off_101150B0[2])();

//----- (1007D350) --------------------------------------------------------
int (__cdecl *__cdecl sub_1007D350(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_100704D0();
  return sub_100776E0((int)&unk_1021B150 + 1812 * v1, a1);
}

//----- (1007D370) --------------------------------------------------------
const char *sub_1007D370()
{
  return "See version control for test execution date";
}

//----- (1007D380) --------------------------------------------------------
__int64 sub_1007D380()
{
  return 0i64;
}

//----- (1007D390) --------------------------------------------------------
const char *sub_1007D390()
{
  return "Not Available";
}

//----- (1007D3A0) --------------------------------------------------------
int __usercall sub_1007D3A0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1007D3F0) --------------------------------------------------------
signed int __cdecl sub_1007D3F0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100704D0();
  return sub_10077290(a1, a2, (int)&unk_1021B150 + 1812 * v2);
}

//----- (1007D540) --------------------------------------------------------
int __usercall sub_1007D540@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1008B300((int)&a2[151 * (*a2 + 1)], (int)sub_1007D350, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1007D380();
  v4 = sub_10081890("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1008B750((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10081890("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1008B750((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1008B750((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1008B6D0((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1008B560((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10081890("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10070580(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1008B6D0((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1008B6D0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_10077400(v3);
  sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1008B650((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10081850(i, &v15, &v16); ++i )
  {
    sub_1008B6D0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1008B7A0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1008B650((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1008B650((int)&a2[151 * (*a2 + 1)]);
  sub_1008B6D0((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1008B560((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1007D540: using guessed type char var_103[253];

//----- (1007D8C0) --------------------------------------------------------
char __cdecl sub_1007D8C0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_100704D0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_1021B150 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10076E40(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1007D3A0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1008B6D0(v8, (int)"Req");
            sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10076E10(a2, a3) )
      {
        if ( sub_100775A0((int)v5, 3, 1, 0) )
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1008B650(v12);
          sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1008B560(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10076D50(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1008B7A0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10076E70(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1008B7A0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10076DE0(a2, a3) )
      {
        if ( sub_100775A0((int)v5, 3, 1, 0) )
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10077510((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10076D80(a2, a3) )
      {
        sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1008B560(v13, (int)"success", (unsigned __int8 *)&word_100D1710);
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1008B560(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_100775A0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10076D20(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10077650((int)v5) )
            sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1008B7A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_100775A0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_100770D0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1007D540((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_100770C0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1008B7A0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1008B7A0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1008B7A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10077650((int)v5) )
        sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10076CC0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1008B600((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1008B7A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10076AC0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1008B5B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1008B5B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1008B5B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100F61E8, 3u) )
              v44 = byte_100B8180;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_100D1710, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1008B6D0(v19, (int)"Expected");
          sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_100775A0((int)v5, 8, 1, 0) )
        sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10077330((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10077390((int)v5, (void (__cdecl *)(int))sub_1007D420);
      return v4;
    case 0:
    case 11:
      sub_10077730((int)v5, (void (__cdecl *)(int))sub_1007D420);
      goto LABEL_139;
    case 1:
      sub_10077250((int)v5);
      goto LABEL_139;
    case 12:
      sub_10077660((int)v5, (void (__cdecl *)(int))sub_1007D420);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1008B6D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1008B560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_100775A0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1008B650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1007D420: using guessed type int sub_1007D420();
// 100D1710: using guessed type __int16 word_100D1710;
// 1007D8C0: using guessed type char var_104[255];

//----- (1007E6E0) --------------------------------------------------------
char **__cdecl sub_1007E6E0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_1021B150 + 1812 * sub_100704D0();
  *((_DWORD *)v1 + 146) = 0;
  sub_100774A0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1008B300(v2, (int)sub_1007D350, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_10115160;
}
// 10115160: using guessed type char *off_10115160;

//----- (1007E750) --------------------------------------------------------
int __cdecl sub_1007E750(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1021D4B4 = *(_DWORD *)a1;
  dword_1021D4B8 = *(_DWORD *)(a1 + 4);
  dword_1021D4BC = *(_DWORD *)(a1 + 8);
  dword_1021D4C0 = *(_DWORD *)(a1 + 12);
  dword_1031F2AC = (int)&dword_1021D4B4;
  return result;
}
// 1021D4B4: using guessed type int dword_1021D4B4;
// 1021D4B8: using guessed type int dword_1021D4B8;
// 1021D4BC: using guessed type int dword_1021D4BC;
// 1021D4C0: using guessed type int dword_1021D4C0;
// 1031F2AC: using guessed type int dword_1031F2AC;

//----- (1007E790) --------------------------------------------------------
int __cdecl sub_1007E790(char a1)
{
  return sub_1006E440(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (1007E7B0) --------------------------------------------------------
BOOL __cdecl sub_1007E7B0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10065C10(a1);
  return sub_100730B0(0, 604, a2) && sub_10072A80(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1007E810) --------------------------------------------------------
int __usercall sub_1007E810@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1007E790(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_10115594[2 * v1];
  return result;
}
// 10115594: using guessed type int dword_10115594[];

//----- (1007E840) --------------------------------------------------------
BOOL __cdecl sub_1007E840(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1007E810(a1);
  return sub_1008CA60(v2, a2, 16) == 0;
}

//----- (1007E870) --------------------------------------------------------
int __cdecl sub_1007E870(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1007E840(a1, (int)a5);
  else
    result = sub_1007E7B0(a1, a5);
  return result;
}

//----- (1007E8A0) --------------------------------------------------------
char __cdecl sub_1007E8A0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_100730E0(1, 1947, a1, (int)&v3);
}

//----- (1007E8C0) --------------------------------------------------------
BOOL __cdecl sub_1007E8C0(int a1)
{
  return sub_1008CA60(6792, a1, 284) == 0;
}

//----- (1007E8E0) --------------------------------------------------------
char __cdecl sub_1007E8E0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1007E8C0((int)a5);
  else
    result = sub_1007E8A0(a5);
  return result;
}

//----- (1007E910) --------------------------------------------------------
bool __cdecl sub_1007E910(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1006E440(&a2, 4u, (int)&dword_10116408, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1008CA60((unsigned __int16)word_1011640C[a1 + 6 * v3], a3, (unsigned __int16)word_10116410[6 * v3]) == 0;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 10116408: using guessed type int dword_10116408;
// 1011640C: using guessed type __int16 word_1011640C[];
// 10116410: using guessed type __int16 word_10116410[];

//----- (1007E9A0) --------------------------------------------------------
bool __cdecl sub_1007E9A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1008B840(a1);
  v6 = sub_1006E440(&a3, 1u, (int)&unk_1011642C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1006E440(&dword_10116430[2 * v6], 4u, (int)&dword_10116408, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_10116410[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1007E910(v11, *(int *)((char *)&dword_10116408 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10116408: using guessed type int dword_10116408;
// 10116410: using guessed type __int16 word_10116410[];

//----- (1007EA40) --------------------------------------------------------
bool __cdecl sub_1007EA40(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1008CA60((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1007EA80) --------------------------------------------------------
signed int __usercall sub_1007EA80@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1007EAA0) --------------------------------------------------------
bool __cdecl sub_1007EAA0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1007EA80(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10072A80(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_100730E0(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1007EA40(a1, a2);
  }
  else
  {
    v9 = sub_1006F3C0(v4);
    v8 = 1708;
    sub_10072BE0(1, 0, &v8, 0, 8, 1);
    sub_10072D20(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1008D0E0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1008D100: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1007EB90) --------------------------------------------------------
bool __cdecl sub_1007EB90(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1007EA40(a1, a5);
  else
    result = sub_1007EAA0(a1, a5);
  return result;
}

//----- (1007EBC0) --------------------------------------------------------
BOOL __cdecl sub_1007EBC0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1007EBD0) --------------------------------------------------------
BOOL __usercall sub_1007EBD0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1007EBC0(a1) && *v2 < 3u && a2 == 24;
}

//----- (1007EC00) --------------------------------------------------------
bool __cdecl sub_1007EC00(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1007EBC0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10076230((unsigned __int8)byte_10117848[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_100730B0(1, (unsigned __int16)word_10117840[v6], &Tm.tm_mon) || sub_10075C90((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10080910(a1, &v15) || v15 != dword_10117860[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_100730B0(1, (unsigned __int16)word_10117844[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 10117840: using guessed type __int16 word_10117840[];
// 10117844: using guessed type __int16 word_10117844[];
// 10117860: using guessed type int dword_10117860[];

//----- (1007EDB0) --------------------------------------------------------
bool __cdecl sub_1007EDB0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1007EBC0(a1) )
    result = sub_1008CA60((unsigned __int16)word_1011784A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1011784A: using guessed type __int16 word_1011784A[];

//----- (1007EDF0) --------------------------------------------------------
bool __cdecl sub_1007EDF0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10080860(a1);
  if ( !(unsigned __int8)sub_1007EBD0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1007EC00(v9, a3, *a4, (int)a5);
  if ( sub_10076230((unsigned __int8)byte_10117848[20 * v6], (bool *)&v8) && v8 && sub_1007EDB0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1007EDF0: using guessed type int var_20[7];

//----- (1007EEE0) --------------------------------------------------------
char sub_1007EEE0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_100730B0(1, 1309, &v1) )
    sub_10075DD0((int)&v1);
  return 0;
}

//----- (1007EF80) --------------------------------------------------------
BOOL __cdecl sub_1007EF80(int a1, int a2)
{
  return sub_1008CA60(6455, a2, 252) == 0;
}

//----- (1007EFA0) --------------------------------------------------------
char __cdecl sub_1007EFA0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1007EF80(a1, a5);
  }
  else
  {
    result = sub_1007EEE0();
  }
  return result;
}

//----- (1007EFE0) --------------------------------------------------------
char __cdecl sub_1007EFE0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1021FD58, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10081110(a1, (int)byte_1021FD58);
    v3 = 4 * a2 - 64;
    v4 = byte_1021FD59[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1021FD58[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1007F080) --------------------------------------------------------
bool __cdecl sub_1007F080(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1021FD58, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10081110(a1, (int)byte_1021FD58);
    v3 = (char *)&unk_1021FDF8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1007F100) --------------------------------------------------------
char __cdecl sub_1007F100(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1021FD58, 0, 0x890u);
  sub_10081110(a1, (int)byte_1021FD58);
  if ( a2 > 0x10u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_102200C8[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_102200CC[2 * a2];
    result = 1;
  }
  return result;
}
// 102200C8: using guessed type int dword_102200C8[];
// 102200CC: using guessed type int dword_102200CC[];

//----- (1007F170) --------------------------------------------------------
char __cdecl sub_1007F170(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_100730B0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_100730B0(0, 572, a2);
    }
    else
    {
      sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_100730B0(0, 226, a2);
  }
  return result;
}

//----- (1007F1F0) --------------------------------------------------------
char __cdecl sub_1007F1F0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1021FD58, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1007F170(a1, byte_1021FD58);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1021FD59[v4];
    *(_BYTE *)a3 = byte_1021FD58[v4];
  }
  return result;
}

//----- (1007F270) --------------------------------------------------------
char __cdecl sub_1007F270(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1021FD58, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1007F170(a1, byte_1021FD58);
    v4 = (char *)&unk_1021FDF8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1007F2F0) --------------------------------------------------------
char __cdecl sub_1007F2F0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1021FD58, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1007F170(a1, byte_1021FD58);
    *(_DWORD *)a3 = dword_102200C8[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_102200CC[2 * a2];
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 102200C8: using guessed type int dword_102200C8[];
// 102200CC: using guessed type int dword_102200CC[];

//----- (1007F360) --------------------------------------------------------
char __cdecl sub_1007F360(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1008B8C0(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1007F100(v6, *a4, a5);
    else
      result = sub_1007F2F0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1007EFE0(v6, *a4, a5);
    else
      result = sub_1007F1F0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1007F080(v6, *a4, a5);
    else
      result = sub_1007F270(v6, *a4, a5);
  }
  return result;
}

//----- (1007F470) --------------------------------------------------------
char __cdecl sub_1007F470(char a1, void *a2)
{
  return sub_100730B0(6, (unsigned __int16)word_101191F2[8 * (unsigned __int8)a1], a2);
}
// 101191F2: using guessed type __int16 word_101191F2[];

//----- (1007F490) --------------------------------------------------------
bool __cdecl sub_1007F490(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1008CA60(dword_101191F8[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 101191F8: using guessed type int dword_101191F8[];

//----- (1007F4D0) --------------------------------------------------------
char __cdecl sub_1007F4D0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1008B900(a1);
  if ( a2 )
    result = sub_1007F490(v6, (char *)a5);
  else
    result = sub_1007F470(v6, a5);
  return result;
}

//----- (1007F510) --------------------------------------------------------
BOOL sub_1007F510()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10076170(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1007F570) --------------------------------------------------------
char __cdecl sub_1007F570(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_100730B0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1007F510() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10075900((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1007F660) --------------------------------------------------------
BOOL __cdecl sub_1007F660(int a1, int a2)
{
  return sub_1008CA60(6200, a2, 60) == 0;
}

//----- (1007F680) --------------------------------------------------------
char __cdecl sub_1007F680(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1007F660(a1, (int)a5);
  }
  else
  {
    result = sub_1007F570(a1, a5);
  }
  return result;
}

//----- (1007F6C0) --------------------------------------------------------
char __cdecl sub_1007F6C0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_100730B0(2, 284, &v6) || sub_10075B00((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1007F770) --------------------------------------------------------
BOOL __cdecl sub_1007F770(int a1, int a2)
{
  return sub_1008CA60(6169, a2, 40) == 0;
}

//----- (1007F790) --------------------------------------------------------
char __cdecl sub_1007F790(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1007F770(a1, a5);
  }
  else
  {
    result = sub_1007F6C0(a1, a5);
  }
  return result;
}

//----- (1007F7D0) --------------------------------------------------------
char __cdecl sub_1007F7D0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_100730B0(2, 363, a1);
}

//----- (1007F7F0) --------------------------------------------------------
char __cdecl sub_1007F7F0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1008CA60(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1007F940) --------------------------------------------------------
bool __thiscall sub_1007F940(void *this)
{
  return (sub_100521F0(this) & 0x8000) == 0x8000;
}

//----- (1007F960) --------------------------------------------------------
char __cdecl sub_1007F960(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1007F7F0(a5);
      else
        result = sub_1007F7D0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1007F7F0(&unk_102205E8);
      else
        v7 = sub_1007F7D0(&unk_102205E8);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_102205E8 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1007F7F0(&unk_102205E8);
      else
        v9 = sub_1007F7D0(&unk_102205E8);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_102234F0 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1007F7F0(&unk_102205E8);
      else
        v11 = sub_1007F7D0(&unk_102205E8);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_102239F0 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1007F7F0(&unk_102205E8);
      else
        v13 = sub_1007F7D0(&unk_102205E8);
      v14 = v13;
      memcpy_0(a5, &unk_10223A98, a6);
      result = v14;
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1007FB00) --------------------------------------------------------
char __cdecl sub_1007FB00(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1007FB40) --------------------------------------------------------
__int16 __usercall sub_1007FB40@<ax>(unsigned __int8 a1@<al>)
{
  return word_1011BDA8[a1];
}
// 1011BDA8: using guessed type __int16 word_1011BDA8[];

//----- (1007FB50) --------------------------------------------------------
char __cdecl sub_1007FB50(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1007FB40(a1);
    if ( sub_100730E0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1007FC20) --------------------------------------------------------
char __cdecl sub_1007FC20(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1007FB00(a1);
  if ( a3 != 11 )
  {
    sub_10051A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1007FB50(v7, a5);
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1007FCA0) --------------------------------------------------------
char __cdecl sub_1007FCA0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10081140(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1008CA60(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10081160((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1007FE10) --------------------------------------------------------
int __usercall sub_1007FE10@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1007FCA0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1007FE10: using guessed type int var_2C[10];

//----- (1007FE50) --------------------------------------------------------
int __usercall sub_1007FE50@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1007FCA0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1007FE50: using guessed type int var_14[4];

//----- (1007FE90) --------------------------------------------------------
signed int sub_1007FE90()
{
  return sub_1008D490((int)&off_1011CC58);
}
// 1011CC58: using guessed type char *off_1011CC58;

//----- (1007FEA0) --------------------------------------------------------
char __cdecl sub_1007FEA0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1007FE90() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1031F2A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1031F2A8: using guessed type int dword_1031F2A8;

//----- (1007FF00) --------------------------------------------------------
char __cdecl sub_1007FF00(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1007FE90() )
  {
    if ( (sub_10081180(a1)
       || *(_BYTE *)(dword_1031F2A8 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1031F2A8 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1031F2A8 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 176))
      && *(_BYTE *)(dword_1031F2A8 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1031F2A8 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1031F2A8 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1031F2A8 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1031F2A8: using guessed type int dword_1031F2A8;

//----- (10080020) --------------------------------------------------------
char __cdecl sub_10080020(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1007FE90() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1031F2A8 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1031F2A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1031F2A8: using guessed type int dword_1031F2A8;

//----- (100800A0) --------------------------------------------------------
char __cdecl sub_100800A0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1007FE50(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10080020(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1007FE10(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1007FEA0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1007FCA0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1007FF00(v6, a5);
        }
      }
      else
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10080250) --------------------------------------------------------
char __cdecl sub_10080250(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10051A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_100730E0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_100730E0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10076070((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_10223AC0, (char *)&v6 + 1, 0x20u);
      byte_10223AB8 = 1;
      byte_10223AB9 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_10223AE0, (char *)&v6 + 1, 0x20u);
    byte_10223AB9 = 1;
    byte_10223ABA = 1;
    return result;
  }
  return 0;
}
// 10223AB8: using guessed type char byte_10223AB8;
// 10223AB9: using guessed type char byte_10223AB9;
// 10223ABA: using guessed type char byte_10223ABA;

//----- (10080380) --------------------------------------------------------
char __cdecl sub_10080380(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_100810C0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10051A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10080400) --------------------------------------------------------
bool __cdecl sub_10080400(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_10223AB8 == 0;
    qmemcpy(a1, &unk_10223AC0, 0x40u);
    result = !v1 && byte_10223ABA;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 10223AB8: using guessed type char byte_10223AB8;
// 10223ABA: using guessed type char byte_10223ABA;

//----- (10080450) --------------------------------------------------------
char __cdecl sub_10080450(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10051A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1006C3C0(15);
    v3 = 555;
  }
  else
  {
    result = sub_1006C3C0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_10223AB9 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10072BE0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1008D100: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10223AB9: using guessed type char byte_10223AB9;

//----- (10080530) --------------------------------------------------------
__int16 __usercall sub_10080530@<ax>(unsigned __int8 a1@<al>)
{
  return word_1011CD78[a1];
}
// 1011CD78: using guessed type __int16 word_1011CD78[];

//----- (10080540) --------------------------------------------------------
char __cdecl sub_10080540(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10080530(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10072BE0(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10072D20(1, v3, 0xFFFFFFF);
}

//----- (100805D0) --------------------------------------------------------
char __cdecl sub_100805D0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_10223AB9 != 0 ? 25 : 11;
      sub_10080540(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10080540(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 10223AB9: using guessed type char byte_10223AB9;

//----- (10080690) --------------------------------------------------------
bool __cdecl sub_10080690(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10080380(a1, (int)a5);
    return 1;
  }
  if ( byte_10223AB9 )
  {
    if ( sub_10080250(a1, &v6, 1) )
    {
LABEL_14:
      byte_10223ABB = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_10223ABB >= 5u )
    {
      byte_10223AB8 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10080250(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_10223ABB >= 5u )
    {
      byte_10223ABA = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10080380(a1, (int)&v6);
    sub_10080450(a1, (int)&v6);
  }
  sub_100805D0(a1, 11);
  return sub_10080400(a5);
}
// 1008D100: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10223AB8: using guessed type char byte_10223AB8;
// 10223AB9: using guessed type char byte_10223AB9;
// 10223ABA: using guessed type char byte_10223ABA;
// 10223ABB: using guessed type char byte_10223ABB;

//----- (10080790) --------------------------------------------------------
char __cdecl sub_10080790(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_100730B0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_100730B0(0, 183, a2);
  }
  return result;
}

//----- (100807E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100807E0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_1008CB30(dword_1011CDA4[a1], (int)&a2, 1);
  }
  return result;
}
// 1011CDA4: using guessed type int dword_1011CDA4[];

//----- (10080820) --------------------------------------------------------
int __cdecl sub_10080820(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10080790(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10080860) --------------------------------------------------------
char __cdecl sub_10080860(char a1)
{
  return byte_1011DC61[2 * (unsigned __int8)sub_1006E440(&a1, 1u, (int)&unk_1011DC60, 2, 4, 3)];
}

//----- (10080890) --------------------------------------------------------
char __cdecl sub_10080890(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_100730B0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10051A40("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_100820E0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_100730B0(1, 538, a2);
  }
  if ( !v4 || sub_10075CE0((int)v3) )
    return 0;
  return 1;
}

//----- (10080910) --------------------------------------------------------
int __cdecl sub_10080910(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10080890(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10080960) --------------------------------------------------------
void __cdecl sub_10080960(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_1008CB30(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_10082150(a2);
        sub_10051A40("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_1008CB30(2010, (int)&a2, 1);
    }
  }
}

//----- (100809D0) --------------------------------------------------------
signed int __cdecl sub_100809D0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10080A20) --------------------------------------------------------
int __cdecl sub_10080A20(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10080B10) --------------------------------------------------------
unsigned int __cdecl sub_10080B10(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10080B60) --------------------------------------------------------
unsigned int __cdecl sub_10080B60(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10080C20) --------------------------------------------------------
unsigned int __cdecl sub_10080C20(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10064A30(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10080C80) --------------------------------------------------------
int __cdecl sub_10080C80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10080CD0) --------------------------------------------------------
int __cdecl sub_10080CD0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10080D70) --------------------------------------------------------
int __cdecl sub_10080D70(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10080E20) --------------------------------------------------------
char __cdecl sub_10080E20(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_1011DC88[4 * a1];
    *a3 = word_1011DC8A[2 * a1];
    result = 1;
  }
  else
  {
    sub_10051A40("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 1011DC8A: using guessed type __int16 word_1011DC8A[];

//----- (10080E80) --------------------------------------------------------
char __cdecl sub_10080E80(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10051A40("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10142878[8 * a1];
  *a4 = word_1014287A[a2 + 4 * a1];
  return 1;
}
// 1014287A: using guessed type __int16 word_1014287A[];

//----- (10080EE0) --------------------------------------------------------
signed int __cdecl sub_10080EE0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1011E518;
    v6 = &unk_1011E518;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_1011E530;
    v6 = &unk_1011E530;
    v5 = &a1;
  }
  v3 = sub_1006E440(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10080F40) --------------------------------------------------------
int __cdecl sub_10080F40(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_1011E578, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1011E57C[2 * v1];
  return result;
}
// 1011E57C: using guessed type int dword_1011E57C[];

//----- (10080F80) --------------------------------------------------------
signed int __cdecl sub_10080F80(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_1011E588;
    v7 = &unk_1011E588;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_1011E5A0;
    v7 = &unk_1011E5A0;
    v6 = &a1;
  }
  v4 = sub_1006E440(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10080FF0) --------------------------------------------------------
int __cdecl sub_10080FF0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_1011E5B8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1011E5BC[2 * v1];
  return result;
}
// 1011E5BC: using guessed type int dword_1011E5BC[];

//----- (10081030) --------------------------------------------------------
int __cdecl sub_10081030(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_1011E5D0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1011E5D4[2 * v1];
  return result;
}
// 1011E5D4: using guessed type int dword_1011E5D4[];

//----- (10081070) --------------------------------------------------------
char __cdecl sub_10081070(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10080EE0(a1, 11);
  return sub_1008CA80(v2, a2, 24);
}

//----- (10081090) --------------------------------------------------------
char __cdecl sub_10081090(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10080F40(a1);
  return sub_1008CA80(v2, a2, 2720);
}

//----- (100810C0) --------------------------------------------------------
char __cdecl sub_100810C0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10080F80(a1, 11, 1);
  sub_1008CA80(v2, a2, 36);
  v3 = sub_10080F80(a1, 11, 0);
  return sub_1008CA80(v3, a2 + 36, 32);
}

//----- (10081110) --------------------------------------------------------
char __cdecl sub_10081110(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10080FF0(a1);
  return sub_1008CA80(v2, a2, 2192);
}

//----- (10081140) --------------------------------------------------------
char __cdecl sub_10081140(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10081030(a1);
  return sub_1008CA80(v2, a2, 60);
}

//----- (10081160) --------------------------------------------------------
char __cdecl sub_10081160(int a1)
{
  return sub_1008CA80(6453, a1, 5);
}

//----- (10081180) --------------------------------------------------------
char __cdecl sub_10081180(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1006C3C0(11);
  }
  else
  {
    result = sub_1006C3C0(5);
  }
  return result;
}

//----- (100811B0) --------------------------------------------------------
int __cdecl sub_100811B0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_101201E4[2 * sub_1006E440(&a1, 1u, (int)&unk_101201E0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_10120224[2 * sub_1006E440(&a2, 1u, (int)&unk_10120220, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_10120254[2 * sub_1006E440(&a2, 1u, (int)&unk_10120250, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_101201FC[2 * sub_1006E440(&a2, 1u, (int)&unk_101201F8, 8, 5, 5)];
  }
  return result;
}
// 101201E4: using guessed type int dword_101201E4[];
// 101201FC: using guessed type int dword_101201FC[];
// 10120224: using guessed type int dword_10120224[];
// 10120254: using guessed type int dword_10120254[];

//----- (10081260) --------------------------------------------------------
bool __usercall sub_10081260@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_10145677[44 * a1] - (unsigned __int8)byte_10145672[44 * a1];
}

//----- (10081290) --------------------------------------------------------
char __usercall sub_10081290@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10081260(a1, a4, a5) )
  {
    v6 = a3
       + sub_100811B0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_10145672[44 * a1] - (unsigned __int8)byte_10145677[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_100811B0(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10081330) --------------------------------------------------------
char __cdecl sub_10081330(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1006C5D0(a1);
  sub_1008CA80(v5, (int)&v7, 3684);
  return sub_10081290(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (100813B0) --------------------------------------------------------
char __cdecl sub_100813B0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1006C5D0(a1);
  sub_1008CA80(v5, (int)&v7, 3684);
  return sub_10081290(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10081430) --------------------------------------------------------
char __cdecl sub_10081430(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1006C5D0(a1);
  sub_1008CA80(v5, (int)&v7, 3684);
  return sub_10081290(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (100814B0) --------------------------------------------------------
char __cdecl sub_100814B0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1006C5D0(a1);
  sub_1008CA80(v5, (int)&v7, 3684);
  return sub_10081290(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10081530) --------------------------------------------------------
char __cdecl sub_10081530(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100815D0) --------------------------------------------------------
double __cdecl sub_100815D0(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_1031F2AC + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_1031F2AC + 12))() * v1);
}
// 1031F2AC: using guessed type int dword_1031F2AC;

//----- (10081620) --------------------------------------------------------
int __cdecl sub_10081620(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (10081640) --------------------------------------------------------
int __cdecl sub_10081640(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (10081660) --------------------------------------------------------
char sub_10081660()
{
  return sub_1006EAF0(1u);
}

//----- (10081690) --------------------------------------------------------
signed int __cdecl sub_10081690(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_1007F940(v1) )
  {
    v2 = sub_1008CA60(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_100760C0(v8);
      if ( (v4 & sub_100521F0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_1006FAF0(v8, v9);
    v6 = 0;
    while ( !sub_1006C240(v8, byte_101203B9[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10081690: using guessed type char var_1AE[426];
// 10081690: using guessed type char var_1B0[2];
// 10081690: using guessed type char var_24C[68];

//----- (100817C0) --------------------------------------------------------
char sub_100817C0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1008CB00(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 100817C0: using guessed type int var_1C[7];

//----- (10081840) --------------------------------------------------------
int __cdecl sub_10081840(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10081850) --------------------------------------------------------
char __cdecl sub_10081850(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10283858[592 * a1]) || byte_102838A8[v3]) )
  {
    *a2 = &byte_10283858[v3];
    *a3 = &byte_102838A8[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10081890) --------------------------------------------------------
char *__cdecl sub_10081890(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10283858;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_102838A8[592 * v2];
}

//----- (10081900) --------------------------------------------------------
char *__usercall sub_10081900@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10081930) --------------------------------------------------------
void __cdecl sub_10081930(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10081890(v2 + 3, (int)byte_100B8180);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10081930(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (100819F0) --------------------------------------------------------
void __cdecl sub_100819F0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10283850 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10283850;
    v4 = (char *)(&byte_10283858[592 * dword_10283850] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_102838A8[v3];
    v8 = (char *)(&byte_102838A8[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10081930(v7);
    ++dword_10283850;
  }
}
// 10283850: using guessed type int dword_10283850;

//----- (10081A50) --------------------------------------------------------
void *__cdecl sub_10081A50(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10283858, 0, 0x73A0u);
  dword_10283850 = 0;
  if ( a1 )
  {
    v2 = sub_10082780(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10082960((int)&v11, 512, v2) )
      {
        do
        {
          sub_10081900(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_100819F0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_100819F0(&v11, v4 + 1);
          }
        }
        while ( sub_10082960((int)&v11, 512, v3) );
      }
      result = (void *)sub_10082730(v3);
    }
    else
    {
      result = (void *)sub_10077040(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10283850: using guessed type int dword_10283850;

//----- (10081BE0) --------------------------------------------------------
char __thiscall sub_10081BE0(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_1006F3C0(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10081C00) --------------------------------------------------------
_DWORD *__usercall sub_10081C00@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1008B920(a2, a1);
  result = (_DWORD *)sub_100522D0(a3, a4);
  if ( (_BYTE)result )
    result = sub_10001730(a2);
  return result;
}

//----- (10081CE0) --------------------------------------------------------
char __cdecl sub_10081CE0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10064B90(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10064B90(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10081BE0(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10064BC0(v16);
  LOBYTE(v3) = sub_1008B940(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10081DE0) --------------------------------------------------------
_DWORD *sub_10081DE0()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_1008CB00(6463, (int)&v1, 256);
  sub_10081C00((int)sub_10081C90, (int)&unk_1028AC08, &v1, "PAGE_INIT");
  sub_10081C00((int)sub_10081C30, (int)&unk_1028ABF8, &v1, "PAGE_SET_FOCUS");
  return sub_10081C00((int)sub_10081CE0, (int)&unk_1028AC00, &v1, "KEY_PRESS");
}
// 10081C30: using guessed type int sub_10081C30();
// 10081C90: using guessed type int sub_10081C90();

//----- (10081E70) --------------------------------------------------------
int __cdecl sub_10081E70(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1006E440(&a1, 1u, (int)&unk_10122778, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_1012277C + 2 * v1);
  return result;
}
// 1012277C: using guessed type void *off_1012277C;

//----- (10081EB0) --------------------------------------------------------
char __cdecl sub_10081EB0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1031F1D4)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (10081F00) --------------------------------------------------------
char __cdecl sub_10081F00(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (10081FB0) --------------------------------------------------------
char __cdecl sub_10081FB0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1031F1D4)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (10082010) --------------------------------------------------------
char __cdecl sub_10082010(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1031F1D4)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 1031F1D4: using guessed type int dword_1031F1D4;

//----- (100820E0) --------------------------------------------------------
bool __cdecl sub_100820E0(void *a1)
{
  char v1; // cl@1

  v1 = sub_100730B0(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10075CE0((int)a1);
}

//----- (10082120) --------------------------------------------------------
char __cdecl sub_10082120(char a1)
{
  sub_10072BE0(1, 1672, &a1, 0, 1, 1);
  return sub_10072D20(1, 0x688u, 0xFFFFFFF);
}

//----- (10082150) --------------------------------------------------------
char __cdecl sub_10082150(char a1)
{
  int v1; // eax@1

  v1 = sub_1008CB30(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10082120(a1);
  return v1;
}

//----- (10082180) --------------------------------------------------------
int __cdecl sub_10082180(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 0, 0, 0);
}

//----- (100821A0) --------------------------------------------------------
unsigned int __cdecl sub_100821A0(void *a1)
{
  return sub_10080C20(a1, 0x20u, 0);
}

//----- (100821C0) --------------------------------------------------------
unsigned int __cdecl sub_100821C0(void *a1)
{
  return sub_10080C20(a1, 0x1Cu, 0);
}

//----- (100821E0) --------------------------------------------------------
unsigned int __cdecl sub_100821E0(void *a1)
{
  return sub_10080C20(a1, 0x10u, 0);
}

//----- (10082200) --------------------------------------------------------
unsigned int __cdecl sub_10082200(void *a1)
{
  return sub_10080C20(a1, 0xCu, 0);
}

//----- (10082220) --------------------------------------------------------
unsigned int __cdecl sub_10082220(void *a1)
{
  return sub_10080C20(a1, 8u, 0);
}

//----- (10082240) --------------------------------------------------------
int __cdecl sub_10082240(int a1)
{
  int result; // eax@1

  result = sub_10080C80((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10080C80((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_10080CD0((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (10082290) --------------------------------------------------------
int __cdecl sub_10082290(void *a1)
{
  int result; // eax@1

  result = sub_100821A0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100821A0((char *)a1 + 128);
    if ( !result )
    {
      result = sub_10082220((char *)a1 + 120);
      if ( !result )
      {
        result = sub_100821C0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_10082240((int)a1 + 168);
          if ( !result )
          {
            result = sub_10082240((int)a1 + 160);
            if ( !result )
            {
              result = sub_10082240((int)a1 + 164);
              if ( !result )
              {
                result = sub_100821E0(a1);
                if ( !result )
                {
                  result = sub_10082200((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_10082200((char *)a1 + 24);
                    if ( !result )
                      result = sub_10082220((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10082360) --------------------------------------------------------
unsigned int __cdecl sub_10082360(void *a1)
{
  unsigned int result; // eax@1

  result = sub_100821A0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100821C0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_100821E0(a1);
      if ( !result )
      {
        result = sub_10082200((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10082200((char *)a1 + 24);
          if ( !result )
            result = sub_10082220((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (100823C0) --------------------------------------------------------
int __cdecl sub_100823C0(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 0x7Fu, 0, 0);
}

//----- (100823E0) --------------------------------------------------------
int __cdecl sub_100823E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10080C80(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10082410) --------------------------------------------------------
int __cdecl sub_10082410(unsigned __int8 *a1)
{
  return sub_10080C80(a1, 0, 3u, 0, 0);
}

//----- (10082430) --------------------------------------------------------
char sub_10082430()
{
  return 2;
}

//----- (10082440) --------------------------------------------------------
int __cdecl sub_10082440(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1008D680: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1008D690: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1008D6A0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1008D6B0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1008D760: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10082580) --------------------------------------------------------
char __usercall sub_10082580@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10082650) --------------------------------------------------------
signed int __cdecl sub_10082650(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1008D6C0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10082580(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10082440(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1008D770: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10082730) --------------------------------------------------------
BOOL __cdecl sub_10082730(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_1008C420(a1) == 0;
}
// 1008C410: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10082750) --------------------------------------------------------
BOOL __cdecl sub_10082750(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1008C460: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10082780) --------------------------------------------------------
unsigned int __cdecl sub_10082780(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1008C4E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100827E0) --------------------------------------------------------
signed int __cdecl sub_100827E0(void *a1, int a2, unsigned int a3)
{
  return sub_1008C4F0(a3, a1, a2);
}

//----- (10082800) --------------------------------------------------------
int __cdecl sub_10082800(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10082820) --------------------------------------------------------
char __cdecl sub_10082820(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10082780((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10082780((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_100827E0(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10082800((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_100827E0(&v8, 512, v3);
        }
        v2 = i;
        sub_10082730(v4);
      }
      sub_10082730(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10082960) --------------------------------------------------------
int __cdecl sub_10082960(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_100827E0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (100829E0) --------------------------------------------------------
int sub_100829E0()
{
  return 0;
}

//----- (100829F0) --------------------------------------------------------
void __cdecl sub_100829F0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (10082A20) --------------------------------------------------------
int __cdecl sub_10082A20(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10082A40) --------------------------------------------------------
bool __cdecl sub_10082A40(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10082A70) --------------------------------------------------------
void *__cdecl sub_10082A70(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10082AB0) --------------------------------------------------------
unsigned int __usercall sub_10082AB0@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10082AD0) --------------------------------------------------------
int __usercall sub_10082AD0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10082AF0) --------------------------------------------------------
char __cdecl sub_10082AF0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10082A40(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10082A20(a2);
  }
  return result;
}

//----- (10082B20) --------------------------------------------------------
signed int __cdecl sub_10082B20(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10082AB0(v5, v7, v9);
          v11 = (_BYTE *)sub_10082AB0(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10082AB0(a4, v7, v9);
            sub_10082AD0(v16, (int)&unk_10125664);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10082C00) --------------------------------------------------------
void __cdecl sub_10082C00(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10082AB0((int)v3, v4, v6);
          v8 = sub_10082AB0(a2, v4, v6);
          v9 = sub_10082AB0(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10082CB0) --------------------------------------------------------
void *__usercall sub_10082CB0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10082AB0(a1, v31, v4);
      v6 = sub_10082AB0(a2, 0, 0);
      sub_10082AD0(v5, v6);
      v7 = sub_10082AB0(a1, v33, v4);
      v8 = sub_10082AB0(a2, *(_DWORD *)a2 - 1, 0);
      sub_10082AD0(v7, v8);
      v9 = sub_10082AB0(a1, v31, v34 - v4 - 1);
      v10 = sub_10082AB0(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10082AD0(v9, v10);
      v11 = sub_10082AB0(a1, v33, v34 - v4 - 1);
      v12 = sub_10082AB0(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10082AD0(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10082AB0(a2, 0, 1);
    v16 = (void *)sub_10082AB0(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10082AB0(a1, a3 + i, v18);
      v20 = sub_10082AB0(a2, i, 0);
      sub_10082AD0(v19, v20);
      v21 = sub_10082AB0(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10082AB0(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10082AD0(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10082AB0(a2, i, 1);
    v25 = (void *)sub_10082AB0(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10082AB0(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10082AB0(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10082F30) --------------------------------------------------------
void __cdecl sub_10082F30(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10082AB0(a1, v2, v4);
          v6 = sub_10082AB0(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10083000) --------------------------------------------------------
char __cdecl sub_10083000(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10082A40(a1);
  if ( result )
  {
    result = sub_10082A40(a4);
    if ( result )
    {
      sub_10082AF0(a3, a4);
      sub_10082A70(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10083070) --------------------------------------------------------
int __usercall sub_10083070@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10082A70(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10082CB0((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10082AB0((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10082AB0(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10082AF0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10083000(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (100833D0) --------------------------------------------------------
int __usercall sub_100833D0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10082A70(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10082C00(v8, a3, (int)&v16);
  sub_10082A70(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10083070(9u, v7, (int)&v16, (int)&unk_10125640, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10082AB0((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10082AB0(a6, v9, v11);
            sub_10082AD0(v13, (int)&unk_10125664);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10082AF0(a5, (int)&v15);
  sub_10082AF0(a5, (int)&v16);
  return v10;
}

//----- (100834E0) --------------------------------------------------------
int __cdecl sub_100834E0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10082A70(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10082F30(a3, a8);
  if ( a1 )
    result = sub_100833D0(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10082B20((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10083670) --------------------------------------------------------
char __cdecl sub_10083670(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10082780((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_100827E0(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_100827E0(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10082A70(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_100827E0(v6, v7, v12) == v7 && (!v9 || sub_100827E0(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10082730(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100837C0) --------------------------------------------------------
char __usercall sub_100837C0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10082780(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10082800((int)&v14, 14, v9) == 14 && sub_10082800((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10082800(v12, v6, v10) == v6 && (!v7 || sub_10082800((int)&unk_101257F8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10082730(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10082730(v10);
  }
  return v30;
}

//----- (10083910) --------------------------------------------------------
char __cdecl sub_10083910(int a1, int a2)
{
  char result; // al@2

  if ( sub_10082A40(a1) )
    result = sub_100837C0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10083950) --------------------------------------------------------
signed int __cdecl sub_10083950(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_1028CC11 = 1;
    byte_1028CC10 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1028CC10 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1028CC11 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100839B0) --------------------------------------------------------
bool __cdecl sub_100839B0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10076F90(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_1013D3E8, (int)"failing_subroutine( depth-1 )");
    sub_100839B0(a1 - 1);
    exit_0(14);
  }
  return sub_1007C450(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10083A20) --------------------------------------------------------
int sub_10083A20()
{
  const char *v0; // eax@1

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_1028CC10 )
  {
    sub_1007C450(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10076F90(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_100839B0(1);
    exit_0(14);
  }
  return sub_10076FC0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10083D40) --------------------------------------------------------
char sub_10083D40()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  int v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1028CC10 )
  {
    v2 = 0;
    do
    {
      if ( (&off_1012645C)[v2] )
      {
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10126464[v2], 0x100u, &v11);
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 2, (int)(&off_1012645C)[v2], 0x100u, &v12);
        sub_10082820(&v12, &v11);
      }
      if ( byte_10126458[v2] )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = *(int *)((char *)&off_10126460 + v2);
        v4 = *(char **)&off_10126464[v2];
        v5 = sub_10077A20(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10126464[v2],
               *(void **)((char *)&off_10126460 + v2));
        v6 = sub_1007C0A0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10077D80(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = *(int *)((char *)&off_10126460 + v2);
        v8 = *(char **)&off_10126464[v2];
        v9 = sub_10077A20(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10126464[v2],
               *(void **)((char *)&off_10126460 + v2));
        v10 = sub_1007C0A0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10077D80(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1012645C: using guessed type char *off_1012645C;
// 10126460: using guessed type void *off_10126460;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10083F60) --------------------------------------------------------
char sub_10083F60()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1028CC10 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_10077D80(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_10077D80(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_10077D80(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_10077D80(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10077D80(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084160) --------------------------------------------------------
char sub_10084160()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101264EC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_101264E9[v2 * 4];
        v4 = byte_101264E8[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + dword_101264EC[v2])],
               (&off_101264F0)[v2 * 4]);
        v6 = sub_10077EC0(
               0,
               *(&dword_1012643C + dword_101264EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10077A20(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101264EC[v2]],
               (&off_101264F0)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101264EC: using guessed type int dword_101264EC[];
// 101264F0: using guessed type char *off_101264F0;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100842E0) --------------------------------------------------------
char sub_100842E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10126770[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10126768[v2 / 8];
        v4 = dbl_10126760[v2 / 8];
        v5 = dbl_10126758[v2 / 8];
        v6 = sub_10077A20(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_10126774[v2]);
        v7 = sub_10078270(
               0,
               *(&dword_1012643C + dword_10126770[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10126770[v2 / 4]],
               *(_DWORD *)&off_10126774[v2]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10126758: using guessed type double dbl_10126758[];
// 10126760: using guessed type double dbl_10126760[];
// 10126768: using guessed type double dbl_10126768[];
// 10126770: using guessed type int dword_10126770[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084460) --------------------------------------------------------
char sub_10084460()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10127384[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10127380[v2];
        v4 = flt_1012737C[v2];
        v5 = flt_10127378[v2];
        v6 = sub_10077A20(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_10127388[v2 * 4]);
        v7 = sub_100786C0(
               0,
               *(&dword_1012643C + dword_10127384[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10127384[v2]],
               *(_DWORD *)&off_10127388[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10127378: using guessed type float flt_10127378[];
// 1012737C: using guessed type float flt_1012737C[];
// 10127380: using guessed type float flt_10127380[];
// 10127384: using guessed type int dword_10127384[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100845D0) --------------------------------------------------------
char sub_100845D0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1028CC10 )
  {
    sub_1007C3A0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_100845D0,
      (int)sub_100845D0,
      (int)"This test is expected to fail");
    sub_1007C3A0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_100845D0,
      0,
      (int)"This test is expected to fail");
    result = sub_1007C3A0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100845D0,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100846D0) --------------------------------------------------------
char sub_100846D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10127B2C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10127B28[v2];
        v4 = dword_10127B24[v2];
        v5 = dword_10127B20[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_10127B30)[v2 * 4]);
        v7 = sub_10078B80(
               0,
               *(&dword_1012643C + dword_10127B2C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10127B2C[v2]],
               (&off_10127B30)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10127B20: using guessed type int dword_10127B20[];
// 10127B24: using guessed type int dword_10127B24[];
// 10127B28: using guessed type int dword_10127B28[];
// 10127B2C: using guessed type int dword_10127B2C[];
// 10127B30: using guessed type char *off_10127B30;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084830) --------------------------------------------------------
char sub_10084830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101282C0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_101282BC[v2 / 2];
        v4 = word_101282BA[v2 / 2];
        v5 = word_101282B8[v2 / 2];
        v6 = sub_10077A20(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_101282C4)[v2]);
        v7 = sub_10078F40(
               0,
               *(&dword_1012643C + dword_101282C0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101282C0[v2 / 4]],
               (&off_101282C4)[v2]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101282B8: using guessed type __int16 word_101282B8[];
// 101282BA: using guessed type __int16 word_101282BA[];
// 101282BC: using guessed type __int16 word_101282BC[];
// 101282C0: using guessed type int dword_101282C0[];
// 101282C4: using guessed type char *off_101282C4;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084990) --------------------------------------------------------
char sub_10084990()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101288D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101288D0[v2];
        v4 = dword_101288CC[v2];
        v5 = dword_101288C8[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_101288D8[v2 * 4]);
        v7 = sub_10079340(
               0,
               *(&dword_1012643C + dword_101288D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101288D4[v2]],
               *(_DWORD *)&off_101288D8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101288C8: using guessed type int dword_101288C8[];
// 101288CC: using guessed type int dword_101288CC[];
// 101288D0: using guessed type int dword_101288D0[];
// 101288D4: using guessed type int dword_101288D4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084AF0) --------------------------------------------------------
char sub_10084AF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10129078[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10129074[v2];
        LODWORD(v3) = dword_10129070[v2];
        HIDWORD(v4) = dword_1012906C[v2];
        LODWORD(v4) = dword_10129068[v2];
        HIDWORD(v5) = dword_10129064[v2];
        LODWORD(v5) = dword_10129060[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012907C[v2 * 4]);
        v7 = sub_10079700(
               0,
               *(&dword_1012643C + dword_10129078[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10129078[v2]],
               *(_DWORD *)&off_1012907C[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10129060: using guessed type int dword_10129060[];
// 10129064: using guessed type int dword_10129064[];
// 10129068: using guessed type int dword_10129068[];
// 1012906C: using guessed type int dword_1012906C[];
// 10129070: using guessed type int dword_10129070[];
// 10129074: using guessed type int dword_10129074[];
// 10129078: using guessed type int dword_10129078[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084C60) --------------------------------------------------------
char sub_10084C60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10129C84[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10129C82[v2 * 4];
        v4 = byte_10129C81[v2 * 4];
        v5 = byte_10129C80[v2 * 4];
        v6 = sub_10077A20(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_10129C88)[v2 * 4]);
        v7 = sub_10079C40(
               0,
               *(&dword_1012643C + dword_10129C84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10129C84[v2]],
               (&off_10129C88)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10129C84: using guessed type int dword_10129C84[];
// 10129C88: using guessed type char *off_10129C88;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084DC0) --------------------------------------------------------
char sub_10084DC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012A11C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012A118[v2];
        v4 = dword_1012A114[v2];
        v5 = dword_1012A110[v2];
        v6 = sub_10077A20(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012A120)[v2 * 4]);
        v7 = sub_1007A020(
               0,
               *(&dword_1012643C + dword_1012A11C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012A11C[v2]],
               (&off_1012A120)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012A110: using guessed type int dword_1012A110[];
// 1012A114: using guessed type int dword_1012A114[];
// 1012A118: using guessed type int dword_1012A118[];
// 1012A11C: using guessed type int dword_1012A11C[];
// 1012A120: using guessed type char *off_1012A120;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10084F20) --------------------------------------------------------
char sub_10084F20()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1028CC10 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1007C450(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100B8180,
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1007C450(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           byte_100B8180,
           "a",
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1007C450(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           byte_100B8180,
           byte_100B8180,
           (int)"This test is expected to fail");
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1007C450(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_10077D80(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085140) --------------------------------------------------------
char sub_10085140()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012A8B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012A8B0[v2];
        v4 = dword_1012A8AC[v2];
        v5 = dword_1012A8A8[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012A8B8[v2 * 4]);
        v7 = sub_1007A3E0(
               0,
               *(&dword_1012643C + dword_1012A8B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012A8B4[v2]],
               *(_DWORD *)&off_1012A8B8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012A8A8: using guessed type int dword_1012A8A8[];
// 1012A8AC: using guessed type int dword_1012A8AC[];
// 1012A8B0: using guessed type int dword_1012A8B0[];
// 1012A8B4: using guessed type int dword_1012A8B4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100852A0) --------------------------------------------------------
char sub_100852A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012AC20[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1012AC1C[v2 / 2];
        v4 = word_1012AC1A[v2 / 2];
        v5 = word_1012AC18[v2 / 2];
        v6 = sub_10077A20(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012AC24)[v2]);
        v7 = sub_1007A780(
               0,
               *(&dword_1012643C + dword_1012AC20[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012AC20[v2 / 4]],
               (&off_1012AC24)[v2]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012AC18: using guessed type __int16 word_1012AC18[];
// 1012AC1A: using guessed type __int16 word_1012AC1A[];
// 1012AC1C: using guessed type __int16 word_1012AC1C[];
// 1012AC20: using guessed type int dword_1012AC20[];
// 1012AC24: using guessed type char *off_1012AC24;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085400) --------------------------------------------------------
char sub_10085400()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012AEE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012AEE0[v2];
        v4 = dword_1012AEDC[v2];
        v5 = dword_1012AED8[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012AEE8[v2 * 4]);
        v7 = sub_1007AB80(
               0,
               *(&dword_1012643C + dword_1012AEE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012AEE4[v2]],
               *(_DWORD *)&off_1012AEE8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012AED8: using guessed type int dword_1012AED8[];
// 1012AEDC: using guessed type int dword_1012AEDC[];
// 1012AEE0: using guessed type int dword_1012AEE0[];
// 1012AEE4: using guessed type int dword_1012AEE4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085560) --------------------------------------------------------
char sub_10085560()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012B260[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1012B25C[v2];
        LODWORD(v3) = dword_1012B258[v2];
        HIDWORD(v4) = dword_1012B254[v2];
        LODWORD(v4) = dword_1012B250[v2];
        HIDWORD(v5) = dword_1012B24C[v2];
        LODWORD(v5) = dword_1012B248[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012B264)[v2 * 4]);
        v7 = sub_1007AF20(
               0,
               *(&dword_1012643C + dword_1012B260[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012B260[v2]],
               (&off_1012B264)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012B248: using guessed type int dword_1012B248[];
// 1012B24C: using guessed type int dword_1012B24C[];
// 1012B250: using guessed type int dword_1012B250[];
// 1012B254: using guessed type int dword_1012B254[];
// 1012B258: using guessed type int dword_1012B258[];
// 1012B25C: using guessed type int dword_1012B25C[];
// 1012B260: using guessed type int dword_1012B260[];
// 1012B264: using guessed type char *off_1012B264;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100856D0) --------------------------------------------------------
char sub_100856D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012B7CC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1012B7CA[v2 * 4];
        v4 = byte_1012B7C9[v2 * 4];
        v5 = byte_1012B7C8[v2 * 4];
        v6 = sub_10077A20(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012B7D0)[v2 * 4]);
        v7 = sub_1007B500(
               0,
               *(&dword_1012643C + dword_1012B7CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012B7CC[v2]],
               (&off_1012B7D0)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012B7CC: using guessed type int dword_1012B7CC[];
// 1012B7D0: using guessed type char *off_1012B7D0;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085830) --------------------------------------------------------
char sub_10085830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012B9E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012B9E0[v2];
        v4 = dword_1012B9DC[v2];
        v5 = dword_1012B9D8[v2];
        v6 = sub_10077A20(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012B9E8[v2 * 4]);
        v7 = sub_1007B8F0(
               0,
               *(&dword_1012643C + dword_1012B9E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012B9E4[v2]],
               *(_DWORD *)&off_1012B9E8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012B9D8: using guessed type int dword_1012B9D8[];
// 1012B9DC: using guessed type int dword_1012B9DC[];
// 1012B9E0: using guessed type int dword_1012B9E0[];
// 1012B9E4: using guessed type int dword_1012B9E4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085990) --------------------------------------------------------
char sub_10085990()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  int v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1028CC10 )
  {
    v2 = 0;
    do
    {
      if ( (&off_1012BD4C)[v2] )
      {
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1012BD54[v2], 0x100u, &v11);
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 2, (int)(&off_1012BD4C)[v2], 0x100u, &v12);
        sub_10082820(&v12, &v11);
      }
      if ( byte_1012BD48[v2] )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = *(int *)((char *)&off_1012BD50 + v2);
        v4 = *(char **)&off_1012BD54[v2];
        v5 = sub_10077A20(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1012BD54[v2],
               *(void **)((char *)&off_1012BD50 + v2));
        v6 = sub_1007C0A0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10077D80(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = *(int *)((char *)&off_1012BD50 + v2);
        v8 = *(char **)&off_1012BD54[v2];
        v9 = sub_10077A20(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1012BD54[v2],
               *(void **)((char *)&off_1012BD50 + v2));
        v10 = sub_1007C0A0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10077D80(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1012BD4C: using guessed type char *off_1012BD4C;
// 1012BD50: using guessed type void *off_1012BD50;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085BB0) --------------------------------------------------------
char sub_10085BB0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_1028CC10 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_10077D80(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_10077D80(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_10077D80(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_10077D80(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10077D80(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085DB0) --------------------------------------------------------
char sub_10085DB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012BDDC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_1012BDD9[v2 * 4];
        v4 = byte_1012BDD8[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + dword_1012BDDC[v2])],
               (&off_1012BDE0)[v2 * 4]);
        v6 = sub_10077EC0(
               1,
               *(&dword_1012643C + dword_1012BDDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10077A20(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012BDDC[v2]],
               (&off_1012BDE0)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012BDDC: using guessed type int dword_1012BDDC[];
// 1012BDE0: using guessed type char *off_1012BDE0;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10085F30) --------------------------------------------------------
char sub_10085F30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012C060[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1012C058[v2 / 8];
        v4 = dbl_1012C050[v2 / 8];
        v5 = dbl_1012C048[v2 / 8];
        v6 = sub_10077A20(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012C064)[v2]);
        v7 = sub_10078270(
               1,
               *(&dword_1012643C + dword_1012C060[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012C060[v2 / 4]],
               (&off_1012C064)[v2]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012C048: using guessed type double dbl_1012C048[];
// 1012C050: using guessed type double dbl_1012C050[];
// 1012C058: using guessed type double dbl_1012C058[];
// 1012C060: using guessed type int dword_1012C060[];
// 1012C064: using guessed type char *off_1012C064;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100860B0) --------------------------------------------------------
char sub_100860B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012CC74[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1012CC70[v2];
        v4 = flt_1012CC6C[v2];
        v5 = flt_1012CC68[v2];
        v6 = sub_10077A20(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012CC78[v2 * 4]);
        v7 = sub_100786C0(
               1,
               *(&dword_1012643C + dword_1012CC74[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012CC74[v2]],
               *(_DWORD *)&off_1012CC78[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012CC68: using guessed type float flt_1012CC68[];
// 1012CC6C: using guessed type float flt_1012CC6C[];
// 1012CC70: using guessed type float flt_1012CC70[];
// 1012CC74: using guessed type int dword_1012CC74[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086220) --------------------------------------------------------
char sub_10086220()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1028CC10 )
  {
    sub_1007C3A0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10086220,
      (int)sub_10086220,
      0);
    sub_1007C3A0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10086220,
      0,
      0);
    result = sub_1007C3A0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10086220,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086310) --------------------------------------------------------
char sub_10086310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012D40C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012D408[v2];
        v4 = dword_1012D404[v2];
        v5 = dword_1012D400[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012D410)[v2 * 4]);
        v7 = sub_10078B80(
               1,
               *(&dword_1012643C + dword_1012D40C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012D40C[v2]],
               (&off_1012D410)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012D400: using guessed type int dword_1012D400[];
// 1012D404: using guessed type int dword_1012D404[];
// 1012D408: using guessed type int dword_1012D408[];
// 1012D40C: using guessed type int dword_1012D40C[];
// 1012D410: using guessed type char *off_1012D410;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086470) --------------------------------------------------------
char sub_10086470()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012DBA0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1012DB9C[v2 / 2];
        v4 = word_1012DB9A[v2 / 2];
        v5 = word_1012DB98[v2 / 2];
        v6 = sub_10077A20(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012DBA4)[v2]);
        v7 = sub_10078F40(
               1,
               *(&dword_1012643C + dword_1012DBA0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012DBA0[v2 / 4]],
               (&off_1012DBA4)[v2]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012DB98: using guessed type __int16 word_1012DB98[];
// 1012DB9A: using guessed type __int16 word_1012DB9A[];
// 1012DB9C: using guessed type __int16 word_1012DB9C[];
// 1012DBA0: using guessed type int dword_1012DBA0[];
// 1012DBA4: using guessed type char *off_1012DBA4;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100865D0) --------------------------------------------------------
char sub_100865D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012E1B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012E1B0[v2];
        v4 = dword_1012E1AC[v2];
        v5 = dword_1012E1A8[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012E1B8[v2 * 4]);
        v7 = sub_10079340(
               1,
               *(&dword_1012643C + dword_1012E1B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012E1B4[v2]],
               *(_DWORD *)&off_1012E1B8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012E1A8: using guessed type int dword_1012E1A8[];
// 1012E1AC: using guessed type int dword_1012E1AC[];
// 1012E1B0: using guessed type int dword_1012E1B0[];
// 1012E1B4: using guessed type int dword_1012E1B4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086730) --------------------------------------------------------
char sub_10086730()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012E958[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1012E954[v2];
        LODWORD(v3) = dword_1012E950[v2];
        HIDWORD(v4) = dword_1012E94C[v2];
        LODWORD(v4) = dword_1012E948[v2];
        HIDWORD(v5) = dword_1012E944[v2];
        LODWORD(v5) = dword_1012E940[v2];
        v6 = sub_10077A20(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_1012E95C[v2 * 4]);
        v7 = sub_10079700(
               1,
               *(&dword_1012643C + dword_1012E958[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012E958[v2]],
               *(_DWORD *)&off_1012E95C[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012E940: using guessed type int dword_1012E940[];
// 1012E944: using guessed type int dword_1012E944[];
// 1012E948: using guessed type int dword_1012E948[];
// 1012E94C: using guessed type int dword_1012E94C[];
// 1012E950: using guessed type int dword_1012E950[];
// 1012E954: using guessed type int dword_1012E954[];
// 1012E958: using guessed type int dword_1012E958[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100868A0) --------------------------------------------------------
char sub_100868A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012F564[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1012F562[v2 * 4];
        v4 = byte_1012F561[v2 * 4];
        v5 = byte_1012F560[v2 * 4];
        v6 = sub_10077A20(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012F568)[v2 * 4]);
        v7 = sub_10079C40(
               1,
               *(&dword_1012643C + dword_1012F564[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012F564[v2]],
               (&off_1012F568)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012F564: using guessed type int dword_1012F564[];
// 1012F568: using guessed type char *off_1012F568;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086A00) --------------------------------------------------------
char sub_10086A00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1012F9FC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1012F9F8[v2];
        v4 = dword_1012F9F4[v2];
        v5 = dword_1012F9F0[v2];
        v6 = sub_10077A20(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_1012FA00)[v2 * 4]);
        v7 = sub_1007A020(
               1,
               *(&dword_1012643C + dword_1012F9FC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1012F9FC[v2]],
               (&off_1012FA00)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1012F9F0: using guessed type int dword_1012F9F0[];
// 1012F9F4: using guessed type int dword_1012F9F4[];
// 1012F9F8: using guessed type int dword_1012F9F8[];
// 1012F9FC: using guessed type int dword_1012F9FC[];
// 1012FA00: using guessed type char *off_1012FA00;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086B60) --------------------------------------------------------
char sub_10086B60()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1028CC10 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1007C450(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100B8180,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1007C450(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           byte_100B8180,
           "a",
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1007C450(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           byte_100B8180,
           byte_100B8180,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1007C450(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_10077D80(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086D60) --------------------------------------------------------
char sub_10086D60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10130194[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10130190[v2];
        v4 = dword_1013018C[v2];
        v5 = dword_10130188[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_10130198[v2 * 4]);
        v7 = sub_1007A3E0(
               1,
               *(&dword_1012643C + dword_10130194[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10130194[v2]],
               *(_DWORD *)&off_10130198[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10130188: using guessed type int dword_10130188[];
// 1013018C: using guessed type int dword_1013018C[];
// 10130190: using guessed type int dword_10130190[];
// 10130194: using guessed type int dword_10130194[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10086EC0) --------------------------------------------------------
char sub_10086EC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10130500[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_101304FC[v2 / 2];
        v4 = word_101304FA[v2 / 2];
        v5 = word_101304F8[v2 / 2];
        v6 = sub_10077A20(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_10130504)[v2]);
        v7 = sub_1007A780(
               1,
               *(&dword_1012643C + dword_10130500[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10130500[v2 / 4]],
               (&off_10130504)[v2]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101304F8: using guessed type __int16 word_101304F8[];
// 101304FA: using guessed type __int16 word_101304FA[];
// 101304FC: using guessed type __int16 word_101304FC[];
// 10130500: using guessed type int dword_10130500[];
// 10130504: using guessed type char *off_10130504;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10087020) --------------------------------------------------------
char sub_10087020()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101307C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101307C0[v2];
        v4 = dword_101307BC[v2];
        v5 = dword_101307B8[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_101307C8[v2 * 4]);
        v7 = sub_1007AB80(
               1,
               *(&dword_1012643C + dword_101307C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101307C4[v2]],
               *(_DWORD *)&off_101307C8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101307B8: using guessed type int dword_101307B8[];
// 101307BC: using guessed type int dword_101307BC[];
// 101307C0: using guessed type int dword_101307C0[];
// 101307C4: using guessed type int dword_101307C4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10087180) --------------------------------------------------------
char sub_10087180()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10130B40[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10130B3C[v2];
        LODWORD(v3) = dword_10130B38[v2];
        HIDWORD(v4) = dword_10130B34[v2];
        LODWORD(v4) = dword_10130B30[v2];
        HIDWORD(v5) = dword_10130B2C[v2];
        LODWORD(v5) = dword_10130B28[v2];
        v6 = sub_10077A20(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_10130B44)[v2 * 4]);
        v7 = sub_1007AF20(
               1,
               *(&dword_1012643C + dword_10130B40[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10130B40[v2]],
               (&off_10130B44)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10130B28: using guessed type int dword_10130B28[];
// 10130B2C: using guessed type int dword_10130B2C[];
// 10130B30: using guessed type int dword_10130B30[];
// 10130B34: using guessed type int dword_10130B34[];
// 10130B38: using guessed type int dword_10130B38[];
// 10130B3C: using guessed type int dword_10130B3C[];
// 10130B40: using guessed type int dword_10130B40[];
// 10130B44: using guessed type char *off_10130B44;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100872F0) --------------------------------------------------------
char sub_100872F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101310AC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_101310AA[v2 * 4];
        v4 = byte_101310A9[v2 * 4];
        v5 = byte_101310A8[v2 * 4];
        v6 = sub_10077A20(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               (&off_101310B0)[v2 * 4]);
        v7 = sub_1007B500(
               1,
               *(&dword_1012643C + dword_101310AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101310AC[v2]],
               (&off_101310B0)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101310AC: using guessed type int dword_101310AC[];
// 101310B0: using guessed type char *off_101310B0;
// 1028CC10: using guessed type char byte_1028CC10;

//----- (10087450) --------------------------------------------------------
char sub_10087450()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1028CC10 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_101312C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101312C0[v2];
        v4 = dword_101312BC[v2];
        v5 = dword_101312B8[v2];
        v6 = sub_10077A20(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * *(&dword_1012643C + v0)],
               *(_DWORD *)&off_101312C8[v2 * 4]);
        v7 = sub_1007B8F0(
               1,
               *(&dword_1012643C + dword_101312C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10077A20(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_101312C4[v2]],
               *(_DWORD *)&off_101312C8[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101312B8: using guessed type int dword_101312B8[];
// 101312BC: using guessed type int dword_101312BC[];
// 101312C0: using guessed type int dword_101312C0[];
// 101312C4: using guessed type int dword_101312C4[];
// 1028CC10: using guessed type char byte_1028CC10;

//----- (100875B0) --------------------------------------------------------
char sub_100875B0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_1028CC11 )
  {
    sub_1007C450(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10076FC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_10078B80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10071430() )
      v1 = 3;
    sub_10078B80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10071430();
    sub_10078B80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10076FC0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_10078B80(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10087B50) --------------------------------------------------------
char sub_10087B50()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1028CC11 )
  {
    v2 = 0;
    do
    {
      if ( off_1013162C[v2] )
      {
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10131634[v2 * 4], 0x100u, &v13);
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1013162C[v2], 0x100u, &v14);
        sub_10082820(&v14, &v13);
      }
      if ( byte_10131628[v2 * 4] )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_10131630[v2];
        v4 = *(char **)&off_10131634[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10131634[v2 * 4],
               off_10131630[v2]);
        v12 = 1;
        v11 = sub_1007C0A0(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_10131630[v2];
        v7 = *(char **)&off_10131634[v2 * 4];
        v8 = sub_10077A20(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10131634[v2 * 4],
               off_10131630[v2]);
        v12 = 1;
        v11 = sub_1007C0A0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013162C: using guessed type char *off_1013162C[3];
// 10131630: using guessed type char *off_10131630[2];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10087D60) --------------------------------------------------------
char sub_10087D60()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1028CC11 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_10077D80(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_10077D80(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_10077D80(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_10077D80(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10077D80(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10087F50) --------------------------------------------------------
char sub_10087F50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_1013167C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_10131679[v2 * 4];
        v4 = byte_10131678[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * dword_1013167C[v2]],
               (&off_10131680)[v2 * 4]);
        v6 = sub_10077EC0(0, dword_1013167C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_10077A20(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_1013167C[v2]],
               (&off_10131680)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1013167C: using guessed type int dword_1013167C[];
// 10131680: using guessed type char *off_10131680;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100880C0) --------------------------------------------------------
char sub_100880C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_101318F8[v2 / 2];
      v4 = dbl_101318F0[v2 / 2];
      v5 = dbl_101318E8[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10131900[v2]],
             (&off_10131904)[v2 * 4]);
      v7 = sub_10078270(0, dword_10131900[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10131900[v2]],
             (&off_10131904)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101318E8: using guessed type double dbl_101318E8[];
// 101318F0: using guessed type double dbl_101318F0[];
// 101318F8: using guessed type double dbl_101318F8[];
// 10131900: using guessed type int dword_10131900[];
// 10131904: using guessed type char *off_10131904;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088230) --------------------------------------------------------
char sub_10088230()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_10132510[v2];
      v4 = flt_1013250C[v2];
      v5 = flt_10132508[v2];
      v6 = sub_10077A20(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10132514[v2]],
             *(_DWORD *)&off_10132518[v2 * 4]);
      v7 = sub_100786C0(0, dword_10132514[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10132514[v2]],
             *(_DWORD *)&off_10132518[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10132508: using guessed type float flt_10132508[];
// 1013250C: using guessed type float flt_1013250C[];
// 10132510: using guessed type float flt_10132510[];
// 10132514: using guessed type int dword_10132514[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088390) --------------------------------------------------------
char sub_10088390()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1028CC11 )
  {
    sub_1007C3A0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10088390,
      (int)sub_10088390,
      0);
    sub_1007C3A0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10088390,
      0,
      0);
    result = sub_1007C3A0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10088390,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088480) --------------------------------------------------------
char sub_10088480()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_10132CA8[v2];
      v4 = dword_10132CA4[v2];
      v5 = dword_10132CA0[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10132CAC[v2]],
             (&off_10132CB0)[v2 * 4]);
      v7 = sub_10078B80(0, dword_10132CAC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10132CAC[v2]],
             (&off_10132CB0)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10132CA0: using guessed type int dword_10132CA0[];
// 10132CA4: using guessed type int dword_10132CA4[];
// 10132CA8: using guessed type int dword_10132CA8[];
// 10132CAC: using guessed type int dword_10132CAC[];
// 10132CB0: using guessed type char *off_10132CB0;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100885E0) --------------------------------------------------------
char sub_100885E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_1013343C[v2 / 2];
      v4 = word_1013343A[v2 / 2];
      v5 = word_10133438[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10133440[v2 / 4]],
             (&off_10133444)[v2]);
      v7 = sub_10078F40(
             0,
             dword_10133440[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10133440[v2 / 4]],
             (&off_10133444)[v2]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10133438: using guessed type __int16 word_10133438[];
// 1013343A: using guessed type __int16 word_1013343A[];
// 1013343C: using guessed type __int16 word_1013343C[];
// 10133440: using guessed type int dword_10133440[];
// 10133444: using guessed type char *off_10133444;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088740) --------------------------------------------------------
char sub_10088740()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_10133A50[v2];
      v4 = dword_10133A4C[v2];
      v5 = dword_10133A48[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10133A54[v2]],
             *(_DWORD *)&off_10133A58[v2 * 4]);
      v7 = sub_10079340(0, dword_10133A54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10133A54[v2]],
             *(_DWORD *)&off_10133A58[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10133A48: using guessed type int dword_10133A48[];
// 10133A4C: using guessed type int dword_10133A4C[];
// 10133A50: using guessed type int dword_10133A50[];
// 10133A54: using guessed type int dword_10133A54[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100888A0) --------------------------------------------------------
char sub_100888A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_101341F4[v2];
      LODWORD(v3) = dword_101341F0[v2];
      HIDWORD(v4) = dword_101341EC[v2];
      LODWORD(v4) = dword_101341E8[v2];
      HIDWORD(v5) = dword_101341E4[v2];
      LODWORD(v5) = dword_101341E0[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_101341F8[v2]],
             *(_DWORD *)&off_101341FC[v2 * 4]);
      v7 = sub_10079700(0, dword_101341F8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_101341F8[v2]],
             *(_DWORD *)&off_101341FC[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101341E0: using guessed type int dword_101341E0[];
// 101341E4: using guessed type int dword_101341E4[];
// 101341E8: using guessed type int dword_101341E8[];
// 101341EC: using guessed type int dword_101341EC[];
// 101341F0: using guessed type int dword_101341F0[];
// 101341F4: using guessed type int dword_101341F4[];
// 101341F8: using guessed type int dword_101341F8[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088A10) --------------------------------------------------------
char sub_10088A10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_10134E02[v2 * 4];
      v4 = byte_10134E01[v2 * 4];
      v5 = byte_10134E00[v2 * 4];
      v6 = sub_10077A20(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10134E04[v2]],
             (&off_10134E08)[v2 * 4]);
      v7 = sub_10079C40(0, dword_10134E04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10134E04[v2]],
             (&off_10134E08)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10134E04: using guessed type int dword_10134E04[];
// 10134E08: using guessed type char *off_10134E08;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088B70) --------------------------------------------------------
char sub_10088B70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_10135298[v2];
      v4 = dword_10135294[v2];
      v5 = dword_10135290[v2];
      v6 = sub_10077A20(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013529C[v2]],
             (&off_101352A0)[v2 * 4]);
      v7 = sub_1007A020(0, dword_1013529C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013529C[v2]],
             (&off_101352A0)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10135290: using guessed type int dword_10135290[];
// 10135294: using guessed type int dword_10135294[];
// 10135298: using guessed type int dword_10135298[];
// 1013529C: using guessed type int dword_1013529C[];
// 101352A0: using guessed type char *off_101352A0;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088CD0) --------------------------------------------------------
char sub_10088CD0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1028CC11 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1007C450(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           byte_100B8180,
           byte_100B8180,
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1007C450(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1007C450(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100B8180,
           0);
    sub_10077D80(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1007C450(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10077D80(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10088ED0) --------------------------------------------------------
char sub_10088ED0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_10135A30[v2];
      v4 = dword_10135A2C[v2];
      v5 = dword_10135A28[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10135A34[v2]],
             *(_DWORD *)&off_10135A38[v2 * 4]);
      v7 = sub_1007A3E0(0, dword_10135A34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10135A34[v2]],
             *(_DWORD *)&off_10135A38[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10135A28: using guessed type int dword_10135A28[];
// 10135A2C: using guessed type int dword_10135A2C[];
// 10135A30: using guessed type int dword_10135A30[];
// 10135A34: using guessed type int dword_10135A34[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089030) --------------------------------------------------------
char sub_10089030()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_10135D9C[v2 / 2];
      v4 = word_10135D9A[v2 / 2];
      v5 = word_10135D98[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10135DA0[v2 / 4]],
             (&off_10135DA4)[v2]);
      v7 = sub_1007A780(
             0,
             dword_10135DA0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10135DA0[v2 / 4]],
             (&off_10135DA4)[v2]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10135D98: using guessed type __int16 word_10135D98[];
// 10135D9A: using guessed type __int16 word_10135D9A[];
// 10135D9C: using guessed type __int16 word_10135D9C[];
// 10135DA0: using guessed type int dword_10135DA0[];
// 10135DA4: using guessed type char *off_10135DA4;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089190) --------------------------------------------------------
char sub_10089190()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_10136060[v2];
      v4 = dword_1013605C[v2];
      v5 = dword_10136058[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10136064[v2]],
             *(_DWORD *)&off_10136068[v2 * 4]);
      v7 = sub_1007AB80(0, dword_10136064[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10136064[v2]],
             *(_DWORD *)&off_10136068[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10136058: using guessed type int dword_10136058[];
// 1013605C: using guessed type int dword_1013605C[];
// 10136060: using guessed type int dword_10136060[];
// 10136064: using guessed type int dword_10136064[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100892F0) --------------------------------------------------------
char sub_100892F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_101363DC[v2];
      LODWORD(v3) = dword_101363D8[v2];
      HIDWORD(v4) = dword_101363D4[v2];
      LODWORD(v4) = dword_101363D0[v2];
      HIDWORD(v5) = dword_101363CC[v2];
      LODWORD(v5) = dword_101363C8[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_101363E0[v2]],
             (&off_101363E4)[v2 * 4]);
      v7 = sub_1007AF20(0, dword_101363E0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_101363E0[v2]],
             (&off_101363E4)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101363C8: using guessed type int dword_101363C8[];
// 101363CC: using guessed type int dword_101363CC[];
// 101363D0: using guessed type int dword_101363D0[];
// 101363D4: using guessed type int dword_101363D4[];
// 101363D8: using guessed type int dword_101363D8[];
// 101363DC: using guessed type int dword_101363DC[];
// 101363E0: using guessed type int dword_101363E0[];
// 101363E4: using guessed type char *off_101363E4;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089460) --------------------------------------------------------
char sub_10089460()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_1013694A[v2 * 4];
      v4 = byte_10136949[v2 * 4];
      v5 = byte_10136948[v2 * 4];
      v6 = sub_10077A20(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013694C[v2]],
             (&off_10136950)[v2 * 4]);
      v7 = sub_1007B500(0, dword_1013694C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013694C[v2]],
             (&off_10136950)[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013694C: using guessed type int dword_1013694C[];
// 10136950: using guessed type char *off_10136950;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (100895C0) --------------------------------------------------------
char sub_100895C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_10136B60[v2];
      v4 = dword_10136B5C[v2];
      v5 = dword_10136B58[v2];
      v6 = sub_10077A20(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10136B64[v2]],
             *(_DWORD *)&off_10136B68[v2 * 4]);
      v7 = sub_1007B8F0(0, dword_10136B64[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10136B64[v2]],
             *(_DWORD *)&off_10136B68[v2 * 4]);
      result = sub_10077D80(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10136B58: using guessed type int dword_10136B58[];
// 10136B5C: using guessed type int dword_10136B5C[];
// 10136B60: using guessed type int dword_10136B60[];
// 10136B64: using guessed type int dword_10136B64[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089720) --------------------------------------------------------
char sub_10089720()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1028CC11 )
  {
    v2 = 0;
    do
    {
      if ( off_10136ECC[v2] )
      {
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10136ED4[v2 * 4], 0x100u, &v13);
        sub_10077780((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10136ECC[v2], 0x100u, &v14);
        sub_10082820(&v14, &v13);
      }
      if ( byte_10136EC8[v2 * 4] )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_10136ED0[v2];
        v4 = *(char **)&off_10136ED4[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10136ED4[v2 * 4],
               off_10136ED0[v2]);
        v12 = 1;
        v11 = sub_1007C0A0(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_10136ED0[v2];
        v7 = *(char **)&off_10136ED4[v2 * 4];
        v8 = sub_10077A20(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10136ED4[v2 * 4],
               off_10136ED0[v2]);
        v12 = 1;
        v11 = sub_1007C0A0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10136ECC: using guessed type char *off_10136ECC[3];
// 10136ED0: using guessed type char *off_10136ED0[2];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089930) --------------------------------------------------------
char sub_10089930()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1028CC11 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_10077D80(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_10077D80(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_10077D80(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_10077D80(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10077D80(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089B20) --------------------------------------------------------
char sub_10089B20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      v0 = dword_10136F1C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_10136F19[v2 * 4];
        v4 = byte_10136F18[v2 * 4];
        v5 = sub_10077A20(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10126420[4 * dword_10136F1C[v2]],
               (&off_10136F20)[v2 * 4]);
        v6 = sub_10077EC0(1, dword_10136F1C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_10077A20(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10126420[4 * dword_10136F1C[v2]],
               (&off_10136F20)[v2 * 4]);
        LOBYTE(v0) = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10076FC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10136F1C: using guessed type int dword_10136F1C[];
// 10136F20: using guessed type char *off_10136F20;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089C90) --------------------------------------------------------
char sub_10089C90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_10137198[v2 / 2];
      v4 = dbl_10137190[v2 / 2];
      v5 = dbl_10137188[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_101371A0[v2]],
             (&off_101371A4)[v2 * 4]);
      v7 = sub_10078270(1, dword_101371A0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_101371A0[v2]],
             (&off_101371A4)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10137188: using guessed type double dbl_10137188[];
// 10137190: using guessed type double dbl_10137190[];
// 10137198: using guessed type double dbl_10137198[];
// 101371A0: using guessed type int dword_101371A0[];
// 101371A4: using guessed type char *off_101371A4;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089E00) --------------------------------------------------------
char sub_10089E00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_10137DB0[v2];
      v4 = flt_10137DAC[v2];
      v5 = flt_10137DA8[v2];
      v6 = sub_10077A20(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10137DB4[v2]],
             *(_DWORD *)&off_10137DB8[v2 * 4]);
      v7 = sub_100786C0(1, dword_10137DB4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10137DB4[v2]],
             *(_DWORD *)&off_10137DB8[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10137DA8: using guessed type float flt_10137DA8[];
// 10137DAC: using guessed type float flt_10137DAC[];
// 10137DB0: using guessed type float flt_10137DB0[];
// 10137DB4: using guessed type int dword_10137DB4[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (10089F60) --------------------------------------------------------
char sub_10089F60()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1028CC11 )
  {
    sub_1007C3A0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10089F60,
      (int)sub_10089F60,
      0);
    sub_1007C3A0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10089F60,
      0,
      0);
    result = sub_1007C3A0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10089F60,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A050) --------------------------------------------------------
char sub_1008A050()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_10138548[v2];
      v4 = dword_10138544[v2];
      v5 = dword_10138540[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013854C[v2]],
             (&off_10138550)[v2 * 4]);
      v7 = sub_10078B80(1, dword_1013854C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013854C[v2]],
             (&off_10138550)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10138540: using guessed type int dword_10138540[];
// 10138544: using guessed type int dword_10138544[];
// 10138548: using guessed type int dword_10138548[];
// 1013854C: using guessed type int dword_1013854C[];
// 10138550: using guessed type char *off_10138550;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A1B0) --------------------------------------------------------
char sub_1008A1B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_10138CDC[v2 / 2];
      v4 = word_10138CDA[v2 / 2];
      v5 = word_10138CD8[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10138CE0[v2 / 4]],
             (&off_10138CE4)[v2]);
      v7 = sub_10078F40(
             1,
             dword_10138CE0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10138CE0[v2 / 4]],
             (&off_10138CE4)[v2]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10138CD8: using guessed type __int16 word_10138CD8[];
// 10138CDA: using guessed type __int16 word_10138CDA[];
// 10138CDC: using guessed type __int16 word_10138CDC[];
// 10138CE0: using guessed type int dword_10138CE0[];
// 10138CE4: using guessed type char *off_10138CE4;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A310) --------------------------------------------------------
char sub_1008A310()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_101392F0[v2];
      v4 = dword_101392EC[v2];
      v5 = dword_101392E8[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_101392F4[v2]],
             *(_DWORD *)&off_101392F8[v2 * 4]);
      v7 = sub_10079340(1, dword_101392F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_101392F4[v2]],
             *(_DWORD *)&off_101392F8[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101392E8: using guessed type int dword_101392E8[];
// 101392EC: using guessed type int dword_101392EC[];
// 101392F0: using guessed type int dword_101392F0[];
// 101392F4: using guessed type int dword_101392F4[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A470) --------------------------------------------------------
char sub_1008A470()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_10139A94[v2];
      LODWORD(v3) = dword_10139A90[v2];
      HIDWORD(v4) = dword_10139A8C[v2];
      LODWORD(v4) = dword_10139A88[v2];
      HIDWORD(v5) = dword_10139A84[v2];
      LODWORD(v5) = dword_10139A80[v2];
      v6 = sub_10077A20(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_10139A98[v2]],
             *(_DWORD *)&off_10139A9C[v2 * 4]);
      v7 = sub_10079700(1, dword_10139A98[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_10139A98[v2]],
             *(_DWORD *)&off_10139A9C[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10139A80: using guessed type int dword_10139A80[];
// 10139A84: using guessed type int dword_10139A84[];
// 10139A88: using guessed type int dword_10139A88[];
// 10139A8C: using guessed type int dword_10139A8C[];
// 10139A90: using guessed type int dword_10139A90[];
// 10139A94: using guessed type int dword_10139A94[];
// 10139A98: using guessed type int dword_10139A98[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A5E0) --------------------------------------------------------
char sub_1008A5E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_1013A6A2[v2 * 4];
      v4 = byte_1013A6A1[v2 * 4];
      v5 = byte_1013A6A0[v2 * 4];
      v6 = sub_10077A20(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013A6A4[v2]],
             (&off_1013A6A8)[v2 * 4]);
      v7 = sub_10079C40(1, dword_1013A6A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013A6A4[v2]],
             (&off_1013A6A8)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013A6A4: using guessed type int dword_1013A6A4[];
// 1013A6A8: using guessed type char *off_1013A6A8;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A740) --------------------------------------------------------
char sub_1008A740()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_1013AB38[v2];
      v4 = dword_1013AB34[v2];
      v5 = dword_1013AB30[v2];
      v6 = sub_10077A20(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013AB3C[v2]],
             (&off_1013AB40)[v2 * 4]);
      v7 = sub_1007A020(1, dword_1013AB3C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013AB3C[v2]],
             (&off_1013AB40)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013AB30: using guessed type int dword_1013AB30[];
// 1013AB34: using guessed type int dword_1013AB34[];
// 1013AB38: using guessed type int dword_1013AB38[];
// 1013AB3C: using guessed type int dword_1013AB3C[];
// 1013AB40: using guessed type char *off_1013AB40;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008A8A0) --------------------------------------------------------
char sub_1008A8A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10076FC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10077910(0);
  sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10076FC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1028CC11 )
  {
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1007C450(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           byte_100B8180,
           byte_100B8180,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1007C450(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1007C450(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100B8180,
           0);
    sub_10077D80(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1007C450(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10077D80(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008AAA0) --------------------------------------------------------
char sub_1008AAA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_1013B2D0[v2];
      v4 = dword_1013B2CC[v2];
      v5 = dword_1013B2C8[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013B2D4[v2]],
             *(_DWORD *)&off_1013B2D8[v2 * 4]);
      v7 = sub_1007A3E0(1, dword_1013B2D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013B2D4[v2]],
             *(_DWORD *)&off_1013B2D8[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013B2C8: using guessed type int dword_1013B2C8[];
// 1013B2CC: using guessed type int dword_1013B2CC[];
// 1013B2D0: using guessed type int dword_1013B2D0[];
// 1013B2D4: using guessed type int dword_1013B2D4[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008AC00) --------------------------------------------------------
char sub_1008AC00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_1013B63C[v2 / 2];
      v4 = word_1013B63A[v2 / 2];
      v5 = word_1013B638[v2 / 2];
      v6 = sub_10077A20(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013B640[v2 / 4]],
             (&off_1013B644)[v2]);
      v7 = sub_1007A780(
             1,
             dword_1013B640[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013B640[v2 / 4]],
             (&off_1013B644)[v2]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013B638: using guessed type __int16 word_1013B638[];
// 1013B63A: using guessed type __int16 word_1013B63A[];
// 1013B63C: using guessed type __int16 word_1013B63C[];
// 1013B640: using guessed type int dword_1013B640[];
// 1013B644: using guessed type char *off_1013B644;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008AD60) --------------------------------------------------------
char sub_1008AD60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_1013B900[v2];
      v4 = dword_1013B8FC[v2];
      v5 = dword_1013B8F8[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013B904[v2]],
             *(_DWORD *)&off_1013B908[v2 * 4]);
      v7 = sub_1007AB80(1, dword_1013B904[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013B904[v2]],
             *(_DWORD *)&off_1013B908[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013B8F8: using guessed type int dword_1013B8F8[];
// 1013B8FC: using guessed type int dword_1013B8FC[];
// 1013B900: using guessed type int dword_1013B900[];
// 1013B904: using guessed type int dword_1013B904[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008AEC0) --------------------------------------------------------
char sub_1008AEC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_1013BC7C[v2];
      LODWORD(v3) = dword_1013BC78[v2];
      HIDWORD(v4) = dword_1013BC74[v2];
      LODWORD(v4) = dword_1013BC70[v2];
      HIDWORD(v5) = dword_1013BC6C[v2];
      LODWORD(v5) = dword_1013BC68[v2];
      v6 = sub_10077A20(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013BC80[v2]],
             (&off_1013BC84)[v2 * 4]);
      v7 = sub_1007AF20(1, dword_1013BC80[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013BC80[v2]],
             (&off_1013BC84)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013BC68: using guessed type int dword_1013BC68[];
// 1013BC6C: using guessed type int dword_1013BC6C[];
// 1013BC70: using guessed type int dword_1013BC70[];
// 1013BC74: using guessed type int dword_1013BC74[];
// 1013BC78: using guessed type int dword_1013BC78[];
// 1013BC7C: using guessed type int dword_1013BC7C[];
// 1013BC80: using guessed type int dword_1013BC80[];
// 1013BC84: using guessed type char *off_1013BC84;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008B030) --------------------------------------------------------
char sub_1008B030()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_1013C1EA[v2 * 4];
      v4 = byte_1013C1E9[v2 * 4];
      v5 = byte_1013C1E8[v2 * 4];
      v6 = sub_10077A20(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013C1EC[v2]],
             (&off_1013C1F0)[v2 * 4]);
      v7 = sub_1007B500(1, dword_1013C1EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013C1EC[v2]],
             (&off_1013C1F0)[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013C1EC: using guessed type int dword_1013C1EC[];
// 1013C1F0: using guessed type char *off_1013C1F0;
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008B190) --------------------------------------------------------
char sub_1008B190()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1028CC11 )
  {
    sub_10076FC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10077910(0);
    sub_10076FC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10076FC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10077A00(0);
    v2 = 0;
    do
    {
      sub_10077930((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_1013C400[v2];
      v4 = dword_1013C3FC[v2];
      v5 = dword_1013C3F8[v2];
      v6 = sub_10077A20(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10126420[4 * dword_1013C404[v2]],
             *(_DWORD *)&off_1013C408[v2 * 4]);
      v7 = sub_1007B8F0(1, dword_1013C404[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_10077A20(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10126420[4 * dword_1013C404[v2]],
             *(_DWORD *)&off_1013C408[v2 * 4]);
      result = sub_10077D80(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10076FC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013C3F8: using guessed type int dword_1013C3F8[];
// 1013C3FC: using guessed type int dword_1013C3FC[];
// 1013C400: using guessed type int dword_1013C400[];
// 1013C404: using guessed type int dword_1013C404[];
// 1028CC11: using guessed type char byte_1028CC11;

//----- (1008B2F0) --------------------------------------------------------
char **sub_1008B2F0()
{
  return off_10127B0C;
}
// 10127B0C: using guessed type char *off_10127B0C[3];

//----- (1008B300) --------------------------------------------------------
int __cdecl sub_1008B300(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1008B320) --------------------------------------------------------
int (__cdecl *__usercall sub_1008B320@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1008B330) --------------------------------------------------------
int __usercall sub_1008B330@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1008B560) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B560(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1008B320(a1, (int)word_100C2700);
  sub_1008B320(a1, a2);
  sub_1008B320(a1, (int)&unk_10140654);
  v3 = sub_1008B330(a3, a1);
  sub_1008B320(a1, v3);
  return sub_1008B320(a1, (int)&unk_10140650);
}

//----- (1008B5B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B5B0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1008B320(a1, (int)word_100C2700);
  sub_1008B320(a1, a2);
  sub_1008B320(a1, (int)&unk_1014065C);
  v3 = sub_1008B330(a3, a1);
  sub_1008B320(a1, v3);
  return sub_1008B320(a1, (int)&unk_10140658);
}

//----- (1008B600) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B600(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1008B320(a1, (int)&unk_10140660);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1008B330(a2, a1);
    result = sub_1008B320(a1, v3);
  }
  return result;
}

//----- (1008B650) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B650(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_10140668;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1008B320(a1, dword_101405BC[(signed int)result]);
      sub_1008B320(a1, (int)&unk_10140664);
      sub_1008B320(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_10140660;
    }
    result = sub_1008B320(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1008B320(a1, (int)&word_100B5558);
  }
  return result;
}
// 100B5558: using guessed type __int16 word_100B5558;
// 101405BC: using guessed type int dword_101405BC[];

//----- (1008B6D0) --------------------------------------------------------
int __cdecl sub_1008B6D0(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1008B320(a1, (int)&unk_10140660);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1008B320(a1, *((_DWORD *)&off_101405C0 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1008B320(a1, (int)&unk_1014066C);
  sub_1008B320(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1008B750) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B750(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1008B330(a2, a1);
    sub_1008B320(a1, v3);
    result = sub_1008B320(a1, (int)&word_100B5558);
  }
  else
  {
    sub_1008B320(a1, (int)a2);
    result = sub_1008B320(a1, (int)&word_100B5558);
  }
  return result;
}
// 100B5558: using guessed type __int16 word_100B5558;

//----- (1008B7A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B7A0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1008B6D0(a1, a2);
  if ( a3 && *a3 )
    sub_1008B600(a1, a3);
  return sub_1008B650(a1);
}

//----- (1008B7E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1008B7E0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1008B7A0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1008B840) --------------------------------------------------------
char __cdecl sub_1008B840(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1008B8C0) --------------------------------------------------------
char __cdecl sub_1008B8C0(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10051A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1008B900) --------------------------------------------------------
char __cdecl sub_1008B900(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1008B920) --------------------------------------------------------
int __cdecl sub_1008B920(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1008B940) --------------------------------------------------------
char __cdecl sub_1008B940(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10074A70((int)&v12);
}
// 1008B940: using guessed type char var_518[1300];

//----- (1008BA30) --------------------------------------------------------
char __cdecl sub_1008BA30(float a1, int a2, int a3)
{
  char v3; // bl@8
  char result; // al@8
  unsigned __int8 v5; // [sp+Ch] [bp-28h]@1
  unsigned __int8 v6; // [sp+18h] [bp-1Ch]@2
  char v7; // [sp+1Ah] [bp-1Ah]@6

  sub_1008DF20((int)&v5);
  if ( LOBYTE(a1) < v5
    || LOBYTE(a1) >= v6 && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_1031FB2C + 816) != 3)
    || LOBYTE(a1) >= 0x66u
    || v7
    || sub_1008E220(1) )
  {
    result = 0;
  }
  else
  {
    sub_10074930();
    v3 = sub_1008BC80(a1, a2, a3);
    sub_10074920();
    result = v3;
  }
  return result;
}
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008BAE0) --------------------------------------------------------
void __cdecl sub_1008BAE0(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_10095920(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_1008E170(a3);
    else
      sub_100517F0(&v9, &a1);
    sub_1008BC10(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 100517F0: using guessed type _DWORD __cdecl sub_100517F0(_DWORD, _DWORD);

//----- (1008BC10) --------------------------------------------------------
void __cdecl sub_1008BC10(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_1008E880(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_1008E170(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_100958E0(v8);
  }
}

//----- (1008BC80) --------------------------------------------------------
char __cdecl sub_1008BC80(float a1, int a2, int a3)
{
  double v3; // st7@1
  unsigned __int8 v4; // bl@1
  float *v5; // esi@1
  int v6; // ebp@1
  unsigned __int8 v7; // cl@1
  char result; // al@1
  int v9; // edx@5
  int v10; // eax@6
  unsigned int v11; // ecx@6
  double v12; // st6@7
  int v13; // eax@10
  int v14; // edi@10
  double v15; // st6@11
  double v16; // st6@13
  double v17; // st7@16
  double v18; // st6@16
  double v19; // rt1@18
  char v20; // bl@22
  double v21; // st6@25
  float v22; // [sp+10h] [bp+4h]@7
  float v23; // [sp+10h] [bp+4h]@7
  float v24; // [sp+10h] [bp+4h]@7
  float v25; // [sp+10h] [bp+4h]@25
  _BYTE *v26; // [sp+14h] [bp+8h]@1

  v3 = 0.0;
  v4 = LOBYTE(a1);
  v5 = (float *)a2;
  *(float *)a2 = 0.0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  v6 = dword_1031FB2C;
  v26 = (_BYTE *)(dword_1031FB2C + 812);
  v7 = *(_BYTE *)(dword_1031FB2C + 812);
  result = 0;
  if ( LOBYTE(a1) < v7
    || LOBYTE(a1) >= *(_BYTE *)(dword_1031FB20 + 4)
    && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_1031FB2C + 816) != 3) )
  {
    return result;
  }
  v9 = v7 + 1;
  if ( LOBYTE(a1) - v9 + 1 >= 4 )
  {
    v10 = 180 * v9;
    v11 = (((unsigned int)LOBYTE(a1) - v9 - 3) >> 2) + 1;
    v9 += 4 * v11;
    do
    {
      v12 = *(float *)(v10 + dword_1031FB20 + 696);
      v10 += 720;
      --v11;
      v22 = v12 + *v5;
      *v5 = v22;
      v23 = v22 + *(float *)(v10 + dword_1031FB20 + 156);
      *v5 = v23;
      v24 = v23 + *(float *)(v10 + dword_1031FB20 + 336);
      *v5 = v24;
      *v5 = v24 + *(float *)(v10 + dword_1031FB20 + 516);
    }
    while ( v11 );
    v6 = dword_1031FB2C;
  }
  if ( v9 <= v4 )
  {
    v13 = 180 * v9;
    v14 = v4 - v9 + 1;
    do
    {
      v15 = *(float *)(v13 + dword_1031FB20 + 696);
      v13 += 180;
      --v14;
      *v5 = v15 + *v5;
    }
    while ( v14 );
    v6 = dword_1031FB2C;
  }
  v16 = 9.9999996e24;
  if ( 9.9999996e24 == *(float *)(v6 + 316) || 9.9999996e24 == *(float *)(v6 + 332) )
  {
    v18 = 0.0;
    v17 = 9.9999996e24;
    *v5 = 0.0;
  }
  else
  {
    if ( *(_BYTE *)(180 * *v26 + dword_1031FB20 + 671) == 21 )
      goto LABEL_19;
    *v5 = sub_10074910(*(_DWORD *)(v6 + 296)) * *(float *)(dword_1031FB2C + 332)
        + *(float *)(dword_1031FB2C + 316)
        + *v5;
    v17 = 9.9999996e24;
    v18 = 0.0;
  }
  v19 = v18;
  v16 = v17;
  v3 = v19;
LABEL_19:
  *(_DWORD *)v5 = COERCE_UNSIGNED_INT(*v5) & 0x7FFFFFFF;
  if ( (COERCE_UNSIGNED_INT(*v5) & 0x7F800000) == 2139095040 || v16 < *v5 || v3 > *v5 )
  {
    *v5 = v3;
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  if ( *(_BYTE *)(dword_1031FB2C + 660) )
  {
    v25 = *v5 / *(float *)(dword_1031FB2C + 688) + 0.5;
    v21 = v25;
    if ( (LODWORD(v25) & 0x7F800000) == 2139095040 || v21 > 2147418112.0 || v21 < v3 )
    {
      *(_DWORD *)a3 = 0x7FFFFFFF;
      result = 0;
    }
    else
    {
      *(_DWORD *)a3 = (signed int)v21;
      result = v20;
    }
  }
  else
  {
    result = v20;
  }
  return result;
}
// 10074910: using guessed type double __cdecl sub_10074910(_DWORD);
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008BF10) --------------------------------------------------------
int __cdecl sub_1008BF10(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 100960E4: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008BFB0) --------------------------------------------------------
int __cdecl sub_1008BFB0(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_color4f(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 10096108: using guessed type int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008BFE0) --------------------------------------------------------
int __cdecl sub_1008BFE0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_color_pointer(&v6, a1, a2, a3, a4, a5);
}
// 1009610E: using guessed type int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C060) --------------------------------------------------------
int __cdecl sub_1008C060(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 1009612C: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C100) --------------------------------------------------------
int sub_1008C100()
{
  gdi_pvg_init();
  return sub_1008C3B0();
}
// 10096150: using guessed type int gdi_pvg_init(void);

//----- (1008C110) --------------------------------------------------------
int __cdecl sub_1008C110(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 10096156: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (1008C160) --------------------------------------------------------
int __cdecl sub_1008C160(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 10096174: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C1F0) --------------------------------------------------------
int __cdecl sub_1008C1F0(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_rotatef(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 10096198: using guessed type int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C220) --------------------------------------------------------
int __cdecl sub_1008C220(float a1, float a2)
{
  return gdi_pvg_tex_coord2f(LODWORD(a1), LODWORD(a2));
}
// 1009619E: using guessed type int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD);

//----- (1008C240) --------------------------------------------------------
int __cdecl sub_1008C240(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_tex_coord_pointer(&v6, a1, a2, a3, a4, a5);
}
// 100961A4: using guessed type int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C280) --------------------------------------------------------
int __cdecl sub_1008C280(int a1, int a2, float a3)
{
  return gdi_pvg_tex_envf(a1, a2, LODWORD(a3));
}
// 100961AA: using guessed type int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD);

//----- (1008C2B0) --------------------------------------------------------
int __cdecl sub_1008C2B0(float a1, float a2, float a3)
{
  return gdi_pvg_translatef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 100961B6: using guessed type int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD);

//----- (1008C2F0) --------------------------------------------------------
int __cdecl sub_1008C2F0(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 100961C2: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (1008C310) --------------------------------------------------------
int __cdecl sub_1008C310(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_vertex_pointer(&v6, a1, a2, a3, a4, a5);
}
// 100961C8: using guessed type int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C370) --------------------------------------------------------
int __cdecl sub_1008C370(int a1, int a2, int a3)
{
  dword_1028DDEC = a1;
  dword_1028DDE0 = a2;
  dword_1028DDE4 = a3;
  return gdi_pvg_create_window(&dword_1028DDD8);
}
// 100961D4: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 1028DDD8: using guessed type int dword_1028DDD8;
// 1028DDE0: using guessed type int dword_1028DDE0;
// 1028DDE4: using guessed type int dword_1028DDE4;
// 1028DDEC: using guessed type int dword_1028DDEC;

//----- (1008C3B0) --------------------------------------------------------
int sub_1008C3B0()
{
  int result; // eax@1

  result = 0;
  dword_1028DDEC = 0;
  dword_1028DDE0 = 0;
  dword_1028DDE4 = 59;
  dword_1028DDD8 = 1;
  dword_1028DDDC = 0;
  dword_1028DDE8 = 0;
  return result;
}
// 1028DDD8: using guessed type int dword_1028DDD8;
// 1028DDDC: using guessed type int dword_1028DDDC;
// 1028DDE0: using guessed type int dword_1028DDE0;
// 1028DDE4: using guessed type int dword_1028DDE4;
// 1028DDE8: using guessed type int dword_1028DDE8;
// 1028DDEC: using guessed type int dword_1028DDEC;

//----- (1008C400) --------------------------------------------------------
int __cdecl sub_1008C400(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1028DDD8 = a1;
  return result;
}
// 1028DDD8: using guessed type int dword_1028DDD8;

//----- (1008C420) --------------------------------------------------------
signed int __cdecl sub_1008C420(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100A9BF0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_100B19B0(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_1029F528 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_1029F530[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_1029F528 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_1008D990(
      v2,
      *(_DWORD *)(dword_1029F530[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_1008C420(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 100961E6: using guessed type int FIL_vfs_close(void);
// 1029F528: using guessed type int dword_1029F528;
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008C480) --------------------------------------------------------
int __cdecl sub_1008C480(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 100961F8: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C4F0) --------------------------------------------------------
signed int __cdecl sub_1008C4F0(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100A9BF0(a1);
    return sub_100AAAB0(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_1008C6B0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1008DD30(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1009620A: using guessed type int FIL_vfs_read(void);

//----- (1008C530) --------------------------------------------------------
signed int __cdecl sub_1008C530(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_100A9B70(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1008DD30(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10096210: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C5C0) --------------------------------------------------------
signed int __cdecl sub_1008C5C0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_100A9BD0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1009621C: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C610) --------------------------------------------------------
__int64 __cdecl sub_1008C610(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10096222: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1008C630) --------------------------------------------------------
int __cdecl sub_1008C630(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10096228: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1008C660) --------------------------------------------------------
int __cdecl sub_1008C660(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10096234: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C680) --------------------------------------------------------
char __cdecl sub_1008C680(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1008C420(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1008C4E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1008C6B0) --------------------------------------------------------
signed int __cdecl sub_1008C6B0(unsigned int a1, int a2, int a3)
{
  return sub_1008C5C0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1008C6D0) --------------------------------------------------------
int __cdecl sub_1008C6D0(int a1, int a2, int a3)
{
  return sub_1008C630(a1, a2, a3);
}

//----- (1008C6F0) --------------------------------------------------------
int __cdecl sub_1008C6F0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 1009623A: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (1008C710) --------------------------------------------------------
int sub_1008C710()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096240: using guessed type int TSK_pvg_get_id(void);

//----- (1008C730) --------------------------------------------------------
int __cdecl sub_1008C730(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096246: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (1008C760) --------------------------------------------------------
__int16 __cdecl sub_1008C760(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 1009624C: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (1008C780) --------------------------------------------------------
int sub_1008C780()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096252: using guessed type int TSK_pvg_get_timer(void);

//----- (1008C7A0) --------------------------------------------------------
int __cdecl sub_1008C7A0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096258: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C7E0) --------------------------------------------------------
int __cdecl sub_1008C7E0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096264: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C810) --------------------------------------------------------
int __cdecl sub_1008C810(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 1009626A: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (1008C830) --------------------------------------------------------
int __cdecl sub_1008C830(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096270: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (1008C850) --------------------------------------------------------
int __cdecl sub_1008C850(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096276: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (1008C880) --------------------------------------------------------
int __cdecl sub_1008C880(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 1009627C: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008C8B0) --------------------------------------------------------
int __cdecl sub_1008C8B0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096282: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (1008C8E0) --------------------------------------------------------
int __cdecl sub_1008C8E0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096288: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (1008C900) --------------------------------------------------------
int __cdecl sub_1008C900(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 1009628E: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (1008C920) --------------------------------------------------------
char __cdecl sub_1008C920(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_1008C780();
  if ( sub_1008C810(a1) == 5 )
    goto LABEL_4;
  while ( sub_1008C780() < v2 )
  {
    sub_1008C900(20);
    if ( sub_1008C810(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_1008C810(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1008C990) --------------------------------------------------------
int __cdecl sub_1008C990(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1008C710();
    sub_1008C7A0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 10096294: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (1008C9D0) --------------------------------------------------------
int __cdecl sub_1008C9D0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_1008C830(a2);
  return result;
}
// 100CA028: using guessed type void *tsk_app_hdr_ptr;

//----- (1008CA00) --------------------------------------------------------
int __cdecl sub_1008CA00(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_1008C850(a1, a2);
  return result;
}
// 100CA028: using guessed type void *tsk_app_hdr_ptr;

//----- (1008CA20) --------------------------------------------------------
int __cdecl sub_1008CA20(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_10150758[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1015075C[2 * v1];
}
// 10150758: using guessed type int dword_10150758[];
// 1015075C: using guessed type int dword_1015075C[];

//----- (1008CA60) --------------------------------------------------------
int __cdecl sub_1008CA60(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1009629A: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008CA80) --------------------------------------------------------
char __cdecl sub_1008CA80(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1008CA60(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10051A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1008CAC0) --------------------------------------------------------
int __cdecl sub_1008CAC0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1008CA60(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1008CB00) --------------------------------------------------------
int __cdecl sub_1008CB00(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1008CA60(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1008CB30) --------------------------------------------------------
int __cdecl sub_1008CB30(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 100962A0: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008CB50) --------------------------------------------------------
int __cdecl sub_1008CB50(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1008CB30(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1008DE80() )
  {
    v4 = sub_1008CA20(a1);
    if ( v4 != 42066 )
      v3 = sub_1008CB30(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1008DE80: using guessed type int sub_1008DE80(void);

//----- (1008CBB0) --------------------------------------------------------
int __cdecl sub_1008CBB0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1008CB50(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10051A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1008CBF0) --------------------------------------------------------
char __cdecl sub_1008CBF0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1008CB30(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10051A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1008CC30) --------------------------------------------------------
int __cdecl sub_1008CC30(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1008CA60(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_1008CB30(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1008CC80) --------------------------------------------------------
int __cdecl sub_1008CC80(unsigned int a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0x8A )
  {
    if ( a1 < 0x8A && (unsigned __int8)sub_1008D610() )
      result = dword_1029F4A0 + 24 * a1;
    else
      result = 0;
  }
  return result;
}
// 1029F4A0: using guessed type int dword_1029F4A0;

//----- (1008CCA0) --------------------------------------------------------
int __cdecl sub_1008CCA0(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int result; // eax@1

  result = a7;
  *(float *)a7 = a1;
  *(_DWORD *)(a7 + 12) = a6;
  *(float *)(a7 + 4) = a2;
  *(float *)(a7 + 8) = a3;
  *(float *)(a7 + 16) = a4;
  *(float *)(a7 + 20) = a5;
  return result;
}

//----- (1008CCD0) --------------------------------------------------------
void sub_1008CCD0()
{
  dword_10293670 = 0;
  dword_1029F4A0 = -15;
}
// 10293670: using guessed type int dword_10293670;
// 1029F4A0: using guessed type int dword_1029F4A0;

//----- (1008CCE0) --------------------------------------------------------
int __cdecl sub_1008CCE0(int a1)
{
  j_gdi_pvg_bind_buffer(53, *(_DWORD *)a1);
  j_gdi_pvg_enable_client_state(11);
  j_gdi_pvg_enable_client_state(12);
  j_gdi_pvg_enable_client_state(13);
  sub_1008C310(3, 18, 24, *(_DWORD *)(a1 + 8), 0);
  sub_1008BFE0(4, 15, 24, *(_DWORD *)(a1 + 8), 12);
  return sub_1008C240(2, 18, 24, *(_DWORD *)(a1 + 8), 16);
}
// 1008BEF0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 1008C0C0: using guessed type int __cdecl j_gdi_pvg_enable_client_state(_DWORD);

//----- (1008CD40) --------------------------------------------------------
char __cdecl sub_1008CD40(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5)
{
  _DWORD *v5; // esi@1
  char v6; // bl@2
  unsigned int v7; // edi@4
  unsigned int v8; // ebp@4
  _DWORD *v9; // ebx@6

  v5 = a1;
  if ( *a1 )
  {
    v6 = 0;
  }
  else
  {
    j_gdi_pvg_gen_buffers(1, a1);
    v6 = 1;
  }
  v7 = sub_1008C780();
  j_gdi_pvg_bind_buffer(53, *v5);
  v8 = a5;
  if ( v6 )
  {
    v9 = (_DWORD *)a5;
  }
  else
  {
    if ( v7 <= a2 + v5[1] )
      goto LABEL_11;
    v9 = a4;
  }
  a1 = v9;
  j_gdi_pvg_buffer_data(53, &a1, a3, 56);
  if ( a1 != v9 )
    return 0;
  v5[1] = v7;
LABEL_11:
  v5[2] = v8 / 0x18;
  j_gdi_pvg_bind_buffer(53, 0);
  return 1;
}
// 1008BEF0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 1008BF70: using guessed type int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 1008C0F0: using guessed type int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD);

//----- (1008CDE0) --------------------------------------------------------
int sub_1008CDE0()
{
  j_gdi_pvg_bind_buffer(53, 0);
  j_gdi_pvg_disable_client_state(11);
  j_gdi_pvg_disable_client_state(12);
  return j_gdi_pvg_disable_client_state(13);
}
// 1008BEF0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 1008C040: using guessed type int __cdecl j_gdi_pvg_disable_client_state(_DWORD);

//----- (1008CE10) --------------------------------------------------------
signed int __fastcall sub_1008CE10(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (1008CE60) --------------------------------------------------------
int __usercall sub_1008CE60@<eax>(unsigned int a1@<eax>)
{
  return sub_1008D620(a1);
}

//----- (1008CE70) --------------------------------------------------------
double __cdecl sub_1008CE70(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_101C5C80;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_1008CE10((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_1008CE60(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_1008CA60(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_101C5C80, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 1008C2A0: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (1008D010) --------------------------------------------------------
double __cdecl sub_1008D010(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_1008CE60(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (1008D070) --------------------------------------------------------
void __cdecl sub_1008D070(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1008DE90(a1, a2);
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100962A6: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1008D0A0) --------------------------------------------------------
int __cdecl sub_1008D0A0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100962AC: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1008D110) --------------------------------------------------------
int __cdecl sub_1008D110(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1008DEC0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1008D170) --------------------------------------------------------
int __usercall sub_1008D170@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_1008C6B0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_1008C6D0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1008D110((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_1008C780();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1008C4F0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1008C660(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1008C420(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_1008C420(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1008C4D0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1008C4E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1008C5B0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1008D470) --------------------------------------------------------
int __usercall sub_1008D470@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1008DEC0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1008D490) --------------------------------------------------------
signed int __cdecl sub_1008D490(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10051A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_1008CA00(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_1008C9D0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1008D470(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1008D170((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_1008C9D0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1008D560) --------------------------------------------------------
__int16 __cdecl sub_1008D560(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100962CA: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008D5A0) --------------------------------------------------------
__int16 __cdecl sub_1008D5A0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1008D590: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1008D610) --------------------------------------------------------
signed int sub_1008D610()
{
  return sub_1008D490((int)&off_1014E574);
}
// 1014E574: using guessed type char *off_1014E574;

//----- (1008D620) --------------------------------------------------------
int __cdecl sub_1008D620(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_1008D610() )
    result = 8216 * a1 + dword_1029F4A0 + 3312;
  else
    result = 0;
  return result;
}
// 1029F4A0: using guessed type int dword_1029F4A0;

//----- (1008D6C0) --------------------------------------------------------
int __cdecl sub_1008D6C0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100962EE: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1008D710) --------------------------------------------------------
int __cdecl sub_1008D710(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100960A8: using guessed type int SYS_exit_krnl(void);
// 100960B4: using guessed type int SYS_enter_krnl(void);
// 100962F4: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1008D780) --------------------------------------------------------
int __cdecl sub_1008D780(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1006F3C0(v1);
  a1 = v2;
  v3 = sub_1006E440(&a1, 4u, (int)&unk_1014EAB0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014EAB4[2 * v3];
}
// 1014EAB4: using guessed type int dword_1014EAB4[];

//----- (1008D7C0) --------------------------------------------------------
int __cdecl sub_1008D7C0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1006F3C0(v1);
  a1 = v2;
  v3 = sub_1006E440(&a1, 4u, (int)&unk_1014EAE8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014EAEC[2 * v3];
}
// 1014EAEC: using guessed type int dword_1014EAEC[];

//----- (1008D800) --------------------------------------------------------
int __cdecl sub_1008D800(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1006F3C0(v1);
  a1 = v2;
  v3 = sub_1006E440(&a1, 4u, (int)&unk_1014EB20, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014EB24[2 * v3];
}
// 1014EB24: using guessed type int dword_1014EB24[];

//----- (1008D840) --------------------------------------------------------
int __cdecl sub_1008D840(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1006F3C0(v1);
  a1 = v2;
  v3 = sub_1006E440(&a1, 4u, (int)&unk_1014EB58, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1014EB5C[2 * v3];
}
// 1014EB5C: using guessed type int dword_1014EB5C[];

//----- (1008D880) --------------------------------------------------------
int __cdecl sub_1008D880(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1008D7C0(a4);
    result = sub_1008CA60(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1008CA60(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1008D780(a4);
      result = sub_1008CA60(v6, a3, 6);
    }
  }
  return result;
}

//----- (1008D8F0) --------------------------------------------------------
int __cdecl sub_1008D8F0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1008D840(a3);
    result = sub_1008CA60(v4, a1, 64);
    if ( result == -7 )
    {
      sub_1008C900(100);
      v5 = sub_1008D840(a3);
      result = sub_1008CA60(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1008D800(a3);
    result = sub_1008CA60(v6, a2, 8);
    if ( result == -7 )
    {
      sub_1008C900(100);
      v7 = sub_1008D800(a3);
      result = sub_1008CA60(v7, a2, 8);
    }
  }
  return result;
}

//----- (1008D990) --------------------------------------------------------
unsigned int __cdecl sub_1008D990(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1029F530[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1029F4E8[a1];
  dword_1029F4E8[a1] = a3 + v9;
  dword_1029F4A8[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1029F4A8[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1029F4E8: using guessed type int dword_1029F4E8[];
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008DB40) --------------------------------------------------------
int __usercall sub_1008DB40@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1029F530[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1029F530[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008DBF0) --------------------------------------------------------
int __cdecl sub_1008DBF0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1008DB40(a1);
  v3 = &dword_1029F530[a1];
  v4 = sub_1008C530(
         *(_DWORD *)dword_1029F530[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1029F530[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1029F4E8[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1029F4E8: using guessed type int dword_1029F4E8[];
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008DCA0) --------------------------------------------------------
int __usercall sub_1008DCA0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1029F530[a1];
  v3 = (int *)(dword_1029F4E8[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1029F530[a1] + 32)) % *(_WORD *)(dword_1029F530[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1008DBF0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1029F4E8: using guessed type int dword_1029F4E8[];
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008DD30) --------------------------------------------------------
unsigned int __cdecl sub_1008DD30(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1029F528 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1029F530[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1029F528 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_1008C850(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1029F530[v6] + 28);
        v12 = sub_1008DCA0(v6, (unsigned int)v7 & *(_DWORD *)(dword_1029F530[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1029F530[v6] + 4) != 138 )
        sub_1008C830(*(_DWORD *)(dword_1029F530[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1029F530[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_1008C830(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1029F528: using guessed type int dword_1029F528;
// 1029F530: using guessed type int dword_1029F530[];

//----- (1008DE90) --------------------------------------------------------
void __cdecl sub_1008DE90(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_100521D0(v2) && sub_10052230(v3) != 1 )
    *a2 = 0;
}

//----- (1008DED0) --------------------------------------------------------
char sub_1008DED0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10072360() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1031FB2C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1031FB2C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1031FB2C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008DF20) --------------------------------------------------------
char __cdecl sub_1008DF20(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10072360();
  if ( result )
  {
    sub_10074930();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_1031FB2C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_1031FB2C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_1031FB2C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_1031FB20 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_1031FB2C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_1031FB2C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_1031FB2C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_1031FB2C;
    if ( *(_BYTE *)(dword_1031FB2C + 669) && !*(_BYTE *)(dword_1031FB2C + 667)
      || (v3 = *(_BYTE *)(dword_1031FB2C + 159)) != 0
      && *(_BYTE *)(dword_1031FB2C + 667)
      && !*(_BYTE *)(dword_1031FB2C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_1031FB2C + 116))
      || !*(_BYTE *)(dword_1031FB2C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1031FB2C;
    }
    else if ( *(_BYTE *)(dword_1031FB2C + 101) == 4
           && *(_BYTE *)(dword_1031FB2C + 812) >= *(_BYTE *)(dword_1031FB20 + 241)
           && !*(_BYTE *)(dword_1031FB2C + 89)
           && -1.0 == *(float *)(dword_1031FB2C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1031FB2C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_1031FB20 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_1031FB20 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10074920();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_1031FB2C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_1031FB2C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_1031FB2C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_1031FB2C + 825);
      if ( *(_DWORD *)(dword_1031FB2C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_1031FB2C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_1031FB2C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_1031FB2C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_1031FB20 + 4);
      result = sub_10074920();
    }
  }
  return result;
}
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008E170) --------------------------------------------------------
double __cdecl sub_1008E170(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10072360() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_1031FB2C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_1031FB2C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_1031FB2C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008E200) --------------------------------------------------------
char sub_1008E200()
{
  char result; // al@2

  if ( sub_10072360() )
    result = *(_BYTE *)(dword_1031FB2C + 661);
  else
    result = 0;
  return result;
}
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008E220) --------------------------------------------------------
char __cdecl sub_1008E220(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_10072360() )
  {
    sub_10074930();
    v2 = *(_BYTE *)(dword_1031FB2C + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_1031FB20 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_10074920();
  }
  return v1;
}
// 1031FB20: using guessed type int dword_1031FB20;
// 1031FB2C: using guessed type int dword_1031FB2C;

//----- (1008E290) --------------------------------------------------------
void __cdecl sub_1008E290(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_1008E990(a1, a2, a4);
  v4 = sqrt(sub_1008EA50(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (1008E2F0) --------------------------------------------------------
int __cdecl sub_1008E2F0(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (1008E4B0) --------------------------------------------------------
void __cdecl sub_1008E4B0(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_100958E0(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_10095A60(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_10095A60(v29 * v37, v24);
    v20 = sub_10095A60(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_1008E2F0(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (1008E880) --------------------------------------------------------
void __cdecl sub_1008E880(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_10095920(a1, (int)&v9);
  sub_10095920(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_100958E0(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_1008E4B0((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_1008E290(&v9, &v7, a3, (int)&v11);
    *a4 = sub_10095AD0(v11, v12);
  }
}

//----- (1008E960) --------------------------------------------------------
double __cdecl sub_1008E960(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (1008E990) --------------------------------------------------------
void __cdecl sub_1008E990(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_100959E0(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_100958E0(v10) * v12;
}

//----- (1008EA50) --------------------------------------------------------
double __cdecl sub_1008EA50(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (1008EA70) --------------------------------------------------------
int __cdecl sub_1008EA70(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1008EB80) --------------------------------------------------------
unsigned int __cdecl sub_1008EB80(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_1008F6C0(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_1008EC60(v9);
      }
      else
      {
        result = sub_1008F190(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_1008EFB0(v9);
    }
    else
    {
      result = sub_1008F190(v9);
    }
  }
  else
  {
    result = sub_1008F190(v9);
  }
  return result;
}

//----- (1008EC60) --------------------------------------------------------
int __cdecl sub_1008EC60(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_10092F80(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (1008EFB0) --------------------------------------------------------
int __cdecl sub_1008EFB0(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_10092F80(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy_0(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (1008F190) --------------------------------------------------------
unsigned int __cdecl sub_1008F190(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_10092F80(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_101513F0[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_101513F0[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_101513F0[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_101513F0[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (1008F6C0) --------------------------------------------------------
int __cdecl sub_1008F6C0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (1008F720) --------------------------------------------------------
_WORD *__cdecl sub_1008F720(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1008F780) --------------------------------------------------------
int __cdecl sub_1008F780(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1008EA70(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1008F870) --------------------------------------------------------
void sub_1008F870()
{
  ;
}

//----- (1008F880) --------------------------------------------------------
int __cdecl sub_1008F880(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_100902D0(a1, a2, a3);
  return result;
}

//----- (1008F8C0) --------------------------------------------------------
char __cdecl sub_1008F8C0(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_102AC555 = a1;
  byte_102AC554 = a2;
  return result;
}
// 102AC554: using guessed type char byte_102AC554;
// 102AC555: using guessed type char byte_102AC555;

//----- (1008F8E0) --------------------------------------------------------
int __cdecl sub_1008F8E0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_10090120(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_1008F880(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_100916F0(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_100916F0(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_100916F0(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_100916F0(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_100901C0(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_10093150(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_1008EC60(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_10093150(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (10090120) --------------------------------------------------------
bool __cdecl sub_10090120(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (100901C0) --------------------------------------------------------
bool __cdecl sub_100901C0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_102AC555 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_102AC554;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 102AC554: using guessed type char byte_102AC554;
// 102AC555: using guessed type char byte_102AC555;

//----- (100902D0) --------------------------------------------------------
int __cdecl sub_100902D0(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (100903C0) --------------------------------------------------------
int __cdecl sub_100903C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_100916F0(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101513FC[0]);
    *(_WORD *)(a1 + 10) = byte_101513FC[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_101513FC[2] + v11 - byte_101513FC[1] + 1;
    sub_100936D0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101513FC[3]);
    *(_WORD *)(a1 + 8) = byte_101513FC[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_101513FC[5] + v12 - byte_101513FC[4] + 1;
    sub_100938A0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101513FC[6]);
    *(_WORD *)(a1 + 10) = byte_101513FC[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_101513FC[7] - (byte_101513FC[8] + v11) - 1;
    sub_100936D0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101513FC[9]);
    *(_WORD *)(a1 + 8) = byte_101513FC[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_101513FC[10] - (byte_101513FC[11] + v12) - 1;
    sub_100938A0(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (10090620) --------------------------------------------------------
int __cdecl sub_10090620(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_100936D0;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_100938A0;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (10090B70) --------------------------------------------------------
int __cdecl sub_10090B70(int a1, signed int a2, int a3, int a4, int a5)
{
  int result; // eax@3
  __int16 v6; // ST14_2@11
  __int16 v7; // ST18_2@11
  __int16 v8; // ST5C_2@11
  int v9; // edx@47
  int v10; // eax@50
  int v11; // ecx@50
  int v12; // ecx@51
  __int16 v13; // [sp+4h] [bp-6Ch]@55
  __int16 v14; // [sp+Ah] [bp-66h]@11
  __int16 v15; // [sp+Eh] [bp-62h]@11
  signed __int16 j; // [sp+10h] [bp-60h]@6
  unsigned __int16 l; // [sp+10h] [bp-60h]@18
  signed __int16 ii; // [sp+10h] [bp-60h]@47
  unsigned __int16 v19; // [sp+14h] [bp-5Ch]@22
  unsigned __int16 v20; // [sp+18h] [bp-58h]@24
  char *v21; // [sp+20h] [bp-50h]@1
  __int16 k; // [sp+28h] [bp-48h]@15
  int v23; // [sp+2Ch] [bp-44h]@47
  int v24; // [sp+30h] [bp-40h]@47
  int v25; // [sp+34h] [bp-3Ch]@47
  int v26; // [sp+38h] [bp-38h]@15
  int v27; // [sp+3Ch] [bp-34h]@4
  int v28; // [sp+40h] [bp-30h]@11
  __int16 v29; // [sp+44h] [bp-2Ch]@13
  signed __int16 v30; // [sp+48h] [bp-28h]@11
  int v31; // [sp+4Ch] [bp-24h]@11
  signed __int16 v32; // [sp+54h] [bp-1Ch]@11
  __int16 v33; // [sp+5Ch] [bp-14h]@57
  signed __int16 i; // [sp+60h] [bp-10h]@4
  unsigned __int16 m; // [sp+60h] [bp-10h]@36
  signed __int16 n; // [sp+60h] [bp-10h]@44
  unsigned __int16 jj; // [sp+60h] [bp-10h]@53
  __int16 v38; // [sp+64h] [bp-Ch]@11
  __int16 v39; // [sp+68h] [bp-8h]@4
  unsigned __int16 v40; // [sp+6Ch] [bp-4h]@17
  int v41; // [sp+84h] [bp+14h]@1

  v21 = (char *)(a5 + (-a5 & 3));
  v41 = a4 - (-a5 & 3) - (((_BYTE)a4 - (-(char)a5 & 3)) & 3);
  if ( a2 >= 2 && 2 * a2 <= v41 )
  {
    v39 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 6);
    v27 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)v21 = 0;
    for ( i = 1; (unsigned __int16)i < a2; ++i )
    {
      for ( j = i;
            j
         && *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * (unsigned __int16)j - 2] + 2) > (signed int)*(_WORD *)(a3 + 4 * (unsigned __int16)i + 2);
            --j )
      {
        *(_WORD *)&v21[2 * (unsigned __int16)j] = *(_WORD *)&v21[2 * (unsigned __int16)j - 2];
      }
      *(_WORD *)&v21[2 * (unsigned __int16)j] = i;
    }
    v30 = 0;
    v32 = 0;
    v28 = 2 * a2 + (-2 * a2 & 3);
    v31 = (int)&v21[v28];
    v6 = *(_WORD *)(a1 + 26);
    v7 = *(_WORD *)(a1 + 30);
    v15 = *(_WORD *)(a1 + 28);
    v8 = *(_WORD *)(a1 + 42);
    v14 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v38 = *(_WORD *)(a3 + 4 * *(_WORD *)v21 + 2);
    if ( v38 < v14 )
      v38 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v29 = *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * a2 - 2] + 2);
    if ( v29 > v15 + v14 )
      v29 = v15 + v14;
    v26 = 0;
    for ( k = v38; k < v29; ++k )
    {
      while ( 1 )
      {
        v40 = *(_WORD *)&v21[2 * v26];
        if ( *(_WORD *)(a3 + 4 * v40 + 2) > k )
          break;
        for ( l = 0; (signed int)l < 2; ++l )
        {
          if ( l )
          {
            if ( v40 == a2 - 1 )
              v19 = 0;
            else
              v19 = v40 + 1;
            v20 = v40;
          }
          else
          {
            if ( v40 )
              v19 = v40 - 1;
            else
              v19 = a2 - 1;
            v20 = v19;
          }
          if ( *(_WORD *)(a3 + 4 * v19 + 2) <= k )
          {
            if ( *(_WORD *)(a3 + 4 * v19 + 2) < k )
            {
              for ( m = 0; m < (signed int)(unsigned __int16)v30 && *(_WORD *)(v31 + 12 * m) != v20; ++m )
                ;
              if ( (unsigned __int16)v30 - m > 0 )
                memcpy((void *)(v31 + 12 * m), (const void *)(v31 + 12 * (m + 1)), 12 * ((unsigned __int16)--v30 - m));
            }
          }
          else
          {
            if ( (unsigned __int16)v30 == (unsigned __int16)((v41 - v28) / 0xCu) )
            {
              v32 = -1;
              goto LABEL_63;
            }
            *(_WORD *)(v31 + 12 * (unsigned __int16)v30) = v20;
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4) = ((*(_WORD *)(a3 + 4 * v19)
                                                                - (signed int)*(_WORD *)(a3 + 4 * v40)) << 16)
                                                              / (*(_WORD *)(a3 + 4 * v19 + 2)
                                                               - (signed int)*(_WORD *)(a3 + 4 * v40 + 2));
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 8) = (*(_WORD *)(a3 + 4 * v40) << 16)
                                                              + *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4)
                                                              * (k - *(_WORD *)(a3 + 4 * v40 + 2));
            if ( (unsigned __int16)++v30 > (signed int)(unsigned __int16)v32 )
              v32 = v30;
          }
        }
        ++v26;
      }
      for ( n = 1; (unsigned __int16)n < (signed int)(unsigned __int16)v30; ++n )
      {
        if ( *(_DWORD *)(v31 + 12 * ((unsigned __int16)n - 1) + 8) > *(_DWORD *)(v31 + 12 * (unsigned __int16)n + 8) )
        {
          v9 = v31 + 12 * (unsigned __int16)n;
          v23 = *(_DWORD *)v9;
          v24 = *(_DWORD *)(v9 + 4);
          v25 = *(_DWORD *)(v9 + 8);
          for ( ii = n; ii && *(_DWORD *)(v31 + 12 * ((unsigned __int16)ii - 1) + 8) > v25; --ii )
          {
            v10 = v31 + 12 * ((unsigned __int16)ii - 1);
            v11 = v31 + 12 * (unsigned __int16)ii;
            *(_DWORD *)v11 = *(_DWORD *)v10;
            *(_DWORD *)(v11 + 4) = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v11 + 8) = *(_DWORD *)(v10 + 8);
          }
          v12 = v31 + 12 * (unsigned __int16)ii;
          *(_DWORD *)v12 = v23;
          *(_DWORD *)(v12 + 4) = v24;
          *(_DWORD *)(v12 + 8) = v25;
        }
      }
      for ( jj = 0; jj < (unsigned __int16)v30 - 1; jj += 2 )
      {
        v13 = *(_DWORD *)(v31 + 12 * jj + 8) >> 16;
        if ( *(_WORD *)(v31 + 12 * jj + 8) )
          ++v13;
        v33 = *(_DWORD *)(v31 + 12 * (jj + 1) + 8) >> 16;
        if ( !*(_WORD *)(v31 + 12 * (jj + 1) + 8) )
          --v33;
        if ( v13 <= v33 )
        {
          *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + v13;
          *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + k;
          *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + v33;
          sub_10093620(a1);
        }
        *(_DWORD *)(v31 + 12 * jj + 8) += *(_DWORD *)(v31 + 12 * jj + 4);
        *(_DWORD *)(v31 + 12 * (jj + 1) + 8) += *(_DWORD *)(v31 + 12 * (jj + 1) + 4);
      }
    }
LABEL_63:
    *(_WORD *)(a1 + 4) = v39;
    *(_DWORD *)(a1 + 36) = v27;
    if ( (unsigned __int16)v32 == 0xFFFF )
      result = -1;
    else
      result = v31 + 12 * (unsigned __int16)v32 - a5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10091260) --------------------------------------------------------
int __cdecl sub_10091260(int a1, signed int a2, int a3, char a4)
{
  int result; // eax@44
  signed __int16 v5; // [sp+0h] [bp-3Ch]@11
  int v6; // [sp+4h] [bp-38h]@27
  int v7; // [sp+4h] [bp-38h]@33
  __int16 v8; // [sp+8h] [bp-34h]@13
  char v9; // [sp+Fh] [bp-2Dh]@2
  char (__cdecl *v10)(int); // [sp+10h] [bp-2Ch]@3
  char *(__cdecl *v11)(int); // [sp+14h] [bp-28h]@6
  __int16 v12; // [sp+18h] [bp-24h]@8
  __int16 v13; // [sp+1Ch] [bp-20h]@13
  signed __int16 v14; // [sp+20h] [bp-1Ch]@13
  signed __int16 v15; // [sp+24h] [bp-18h]@21
  signed int i; // [sp+28h] [bp-14h]@8
  __int16 v17; // [sp+2Ch] [bp-10h]@11
  __int16 v18; // [sp+30h] [bp-Ch]@11
  signed __int16 v19; // [sp+34h] [bp-8h]@24
  __int16 v20; // [sp+38h] [bp-4h]@8

  if ( a2 >= 2 )
  {
    v9 = 0;
    if ( *(_DWORD *)(a1 + 72) )
      v10 = *(char (__cdecl **)(int))(a1 + 72);
    else
      v10 = sub_100936D0;
    if ( *(_DWORD *)(a1 + 76) )
      v11 = *(char *(__cdecl **)(int))(a1 + 76);
    else
      v11 = sub_100938A0;
    v20 = *(_WORD *)(a1 + 42) + *(_WORD *)a3;
    v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 2);
    for ( i = 1; i < a2; ++i )
    {
      *(_WORD *)(a1 + 10) = v20;
      *(_WORD *)(a1 + 8) = v12;
      v20 = *(_WORD *)(a1 + 42) + *(_WORD *)(a3 + 4 * i);
      v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 4 * i + 2);
      *(_WORD *)(a1 + 14) = v20;
      *(_WORD *)(a1 + 12) = v12;
      v5 = 1;
      v17 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
      v18 = v17;
      if ( v17 < 0 )
      {
        v5 = -1;
        v18 = -v17;
      }
      v14 = 1;
      v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
      v13 = v8;
      if ( v8 < 0 )
      {
        v14 = -1;
        v13 = -v8;
      }
      if ( v8 | v17 )
      {
        if ( *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 10) )
        {
          v9 = 1;
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          *(_WORD *)(a1 + 12) = v8;
          v11(a1);
          *(_WORD *)(a1 + 8) += v8;
        }
        else if ( *(_WORD *)(a1 + 12) == *(_WORD *)(a1 + 8) )
        {
          v9 = 0;
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          *(_WORD *)(a1 + 14) = v17;
          v10(a1);
          *(_WORD *)(a1 + 10) += v17;
        }
        else
        {
          if ( v18 <= 0x3FFF )
            v15 = 2 * v18;
          else
            v15 = 32766;
          if ( v13 <= 0x3FFF )
            v19 = 2 * v13;
          else
            v19 = 32766;
          if ( v18 <= v13 )
          {
            v9 = 1;
            *(_WORD *)(a1 + 16) = 0;
            *(_WORD *)(a1 + 18) = 1;
            v7 = v15 - v13 - (v5 < 0);
            *(_WORD *)(a1 + 12) = 0;
            while ( v13 )
            {
              *(_WORD *)(a1 + 12) += v14;
              if ( v7 >= 0 )
              {
                v11(a1);
                *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
                *(_WORD *)(a1 + 12) = 0;
                *(_WORD *)(a1 + 10) += v5;
                v7 -= v19;
              }
              v7 += v15;
              --v13;
            }
            v11(a1);
            *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
          }
          else
          {
            v9 = 0;
            *(_WORD *)(a1 + 16) = 1;
            *(_WORD *)(a1 + 18) = 0;
            v6 = v19 - v18 - (v14 < 0);
            *(_WORD *)(a1 + 14) = 0;
            while ( v18 )
            {
              *(_WORD *)(a1 + 14) += v5;
              if ( v6 >= 0 )
              {
                v10(a1);
                *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
                *(_WORD *)(a1 + 14) = 0;
                *(_WORD *)(a1 + 8) += v14;
                v6 -= v15;
              }
              v6 += v19;
              --v18;
            }
            v10(a1);
            *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
          }
        }
      }
    }
    if ( a4 & 2 )
    {
      if ( v9 )
      {
        *(_WORD *)(a1 + 12) = 1;
        v11(a1);
      }
      else
      {
        *(_WORD *)(a1 + 14) = 1;
        v10(a1);
      }
    }
    *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 42);
    result = *(_WORD *)(a1 + 40);
    *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 8) - result;
  }
  return result;
}

//----- (100916F0) --------------------------------------------------------
int __cdecl sub_100916F0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_10093150(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (100917E0) --------------------------------------------------------
char __cdecl sub_100917E0(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  char result; // al@4
  char v8; // [sp+0h] [bp-17Ch]@55
  char v9; // [sp+4h] [bp-178h]@49
  char v10; // [sp+8h] [bp-174h]@43
  char v11; // [sp+Ch] [bp-170h]@37
  char v12; // [sp+10h] [bp-16Ch]@31
  char v13; // [sp+14h] [bp-168h]@25
  char v14; // [sp+18h] [bp-164h]@19
  char v15; // [sp+1Ch] [bp-160h]@13
  char v16; // [sp+20h] [bp-15Ch]@98
  char v17; // [sp+21h] [bp-15Bh]@98
  __int16 v18; // [sp+22h] [bp-15Ah]@98
  __int16 v19; // [sp+24h] [bp-158h]@98
  __int16 v20; // [sp+26h] [bp-156h]@98
  int v21; // [sp+2Ch] [bp-150h]@98
  char v22; // [sp+30h] [bp-14Ch]@96
  char v23; // [sp+31h] [bp-14Bh]@96
  __int16 v24; // [sp+32h] [bp-14Ah]@96
  __int16 v25; // [sp+34h] [bp-148h]@96
  __int16 v26; // [sp+36h] [bp-146h]@96
  int v27; // [sp+3Ch] [bp-140h]@96
  char v28; // [sp+40h] [bp-13Ch]@94
  char v29; // [sp+41h] [bp-13Bh]@94
  __int16 v30; // [sp+42h] [bp-13Ah]@94
  __int16 v31; // [sp+44h] [bp-138h]@94
  __int16 v32; // [sp+46h] [bp-136h]@94
  int v33; // [sp+4Ch] [bp-130h]@94
  char v34; // [sp+50h] [bp-12Ch]@92
  char v35; // [sp+51h] [bp-12Bh]@92
  __int16 v36; // [sp+52h] [bp-12Ah]@92
  __int16 v37; // [sp+54h] [bp-128h]@92
  __int16 v38; // [sp+56h] [bp-126h]@92
  int v39; // [sp+5Ch] [bp-120h]@92
  char v40; // [sp+60h] [bp-11Ch]@90
  char v41; // [sp+61h] [bp-11Bh]@90
  __int16 v42; // [sp+62h] [bp-11Ah]@90
  __int16 v43; // [sp+64h] [bp-118h]@90
  __int16 v44; // [sp+66h] [bp-116h]@90
  int v45; // [sp+6Ch] [bp-110h]@90
  char v46; // [sp+70h] [bp-10Ch]@88
  char v47; // [sp+71h] [bp-10Bh]@88
  __int16 v48; // [sp+72h] [bp-10Ah]@88
  __int16 v49; // [sp+74h] [bp-108h]@88
  __int16 v50; // [sp+76h] [bp-106h]@88
  int v51; // [sp+7Ch] [bp-100h]@88
  char v52; // [sp+80h] [bp-FCh]@86
  char v53; // [sp+81h] [bp-FBh]@86
  __int16 v54; // [sp+82h] [bp-FAh]@86
  __int16 v55; // [sp+84h] [bp-F8h]@86
  __int16 v56; // [sp+86h] [bp-F6h]@86
  int v57; // [sp+8Ch] [bp-F0h]@86
  char v58; // [sp+90h] [bp-ECh]@84
  char v59; // [sp+91h] [bp-EBh]@84
  __int16 v60; // [sp+92h] [bp-EAh]@84
  __int16 v61; // [sp+94h] [bp-E8h]@84
  __int16 v62; // [sp+96h] [bp-E6h]@84
  int v63; // [sp+9Ch] [bp-E0h]@84
  char v64; // [sp+A0h] [bp-DCh]@79
  char v65; // [sp+A1h] [bp-DBh]@79
  __int16 v66; // [sp+A2h] [bp-DAh]@79
  __int16 v67; // [sp+A4h] [bp-D8h]@79
  __int16 v68; // [sp+A6h] [bp-D6h]@79
  int v69; // [sp+ACh] [bp-D0h]@79
  char v70; // [sp+B0h] [bp-CCh]@77
  char v71; // [sp+B1h] [bp-CBh]@77
  __int16 v72; // [sp+B2h] [bp-CAh]@77
  __int16 v73; // [sp+B4h] [bp-C8h]@77
  __int16 v74; // [sp+B6h] [bp-C6h]@77
  int v75; // [sp+BCh] [bp-C0h]@77
  char v76; // [sp+C0h] [bp-BCh]@75
  char v77; // [sp+C1h] [bp-BBh]@75
  __int16 v78; // [sp+C2h] [bp-BAh]@75
  __int16 v79; // [sp+C4h] [bp-B8h]@75
  __int16 v80; // [sp+C6h] [bp-B6h]@75
  int v81; // [sp+CCh] [bp-B0h]@75
  char v82; // [sp+D0h] [bp-ACh]@73
  char v83; // [sp+D1h] [bp-ABh]@73
  __int16 v84; // [sp+D2h] [bp-AAh]@73
  __int16 v85; // [sp+D4h] [bp-A8h]@73
  __int16 v86; // [sp+D6h] [bp-A6h]@73
  int v87; // [sp+DCh] [bp-A0h]@73
  char v88; // [sp+E0h] [bp-9Ch]@71
  char v89; // [sp+E1h] [bp-9Bh]@71
  __int16 v90; // [sp+E2h] [bp-9Ah]@71
  __int16 v91; // [sp+E4h] [bp-98h]@71
  __int16 v92; // [sp+E6h] [bp-96h]@71
  int v93; // [sp+ECh] [bp-90h]@71
  char v94; // [sp+F0h] [bp-8Ch]@69
  char v95; // [sp+F1h] [bp-8Bh]@69
  __int16 v96; // [sp+F2h] [bp-8Ah]@69
  __int16 v97; // [sp+F4h] [bp-88h]@69
  __int16 v98; // [sp+F6h] [bp-86h]@69
  int v99; // [sp+FCh] [bp-80h]@69
  char v100; // [sp+100h] [bp-7Ch]@67
  char v101; // [sp+101h] [bp-7Bh]@67
  __int16 v102; // [sp+102h] [bp-7Ah]@67
  __int16 v103; // [sp+104h] [bp-78h]@67
  __int16 v104; // [sp+106h] [bp-76h]@67
  int v105; // [sp+10Ch] [bp-70h]@67
  char v106; // [sp+110h] [bp-6Ch]@65
  char v107; // [sp+111h] [bp-6Bh]@65
  __int16 v108; // [sp+112h] [bp-6Ah]@65
  __int16 v109; // [sp+114h] [bp-68h]@65
  __int16 v110; // [sp+116h] [bp-66h]@65
  int v111; // [sp+11Ch] [bp-60h]@65
  __int16 v112; // [sp+120h] [bp-5Ch]@1
  char v113; // [sp+127h] [bp-55h]@64
  __int16 v114; // [sp+128h] [bp-54h]@1
  int v115; // [sp+12Ch] [bp-50h]@61
  __int16 v116; // [sp+130h] [bp-4Ch]@1
  char v117; // [sp+137h] [bp-45h]@57
  __int16 v118; // [sp+138h] [bp-44h]@61
  __int16 v119; // [sp+13Ah] [bp-42h]@61
  __int16 v120; // [sp+13Ch] [bp-40h]@8
  __int16 v121; // [sp+140h] [bp-3Ch]@61
  __int16 v122; // [sp+144h] [bp-38h]@8
  char v123; // [sp+148h] [bp-34h]@9
  char v124; // [sp+149h] [bp-33h]@21
  char v125; // [sp+14Ah] [bp-32h]@33
  char v126; // [sp+14Bh] [bp-31h]@57
  char v127; // [sp+14Ch] [bp-30h]@45
  char v128; // [sp+14Dh] [bp-2Fh]@27
  char v129; // [sp+14Eh] [bp-2Eh]@15
  char v130; // [sp+14Fh] [bp-2Dh]@39
  __int16 v131; // [sp+150h] [bp-2Ch]@9
  __int16 v132; // [sp+154h] [bp-28h]@1
  __int16 v133; // [sp+158h] [bp-24h]@61
  __int16 v134; // [sp+15Ah] [bp-22h]@61
  char v135; // [sp+15Ch] [bp-20h]@59
  char v136; // [sp+15Dh] [bp-1Fh]@67
  char v137; // [sp+15Eh] [bp-1Eh]@71
  char v138; // [sp+15Fh] [bp-1Dh]@79
  char v139; // [sp+160h] [bp-1Ch]@75
  char v140; // [sp+161h] [bp-1Bh]@69
  char v141; // [sp+162h] [bp-1Ah]@65
  char v142; // [sp+163h] [bp-19h]@73
  __int16 v143; // [sp+168h] [bp-14h]@1
  int v144; // [sp+16Ch] [bp-10h]@57
  __int16 v145; // [sp+170h] [bp-Ch]@1
  __int16 v146; // [sp+174h] [bp-8h]@9
  __int16 v147; // [sp+178h] [bp-4h]@9

  v114 = a2;
  v132 = a3;
  v112 = a6;
  v143 = a7;
  v116 = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  v145 = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 46) = a6;
  *(_WORD *)(a1 + 44) = v143;
  v112 += *(_WORD *)(a1 + 42);
  v143 += *(_WORD *)(a1 + 40);
  v114 += *(_WORD *)(a1 + 42);
  v132 += *(_WORD *)(a1 + 40);
  if ( v116 != v112 || v145 != v143 )
  {
    if ( a5 & 1 )
    {
      v122 = v116;
      v116 = v112;
      v112 = v122;
      v120 = v145;
      v145 = v143;
      v143 = v120;
    }
    sub_10092A30((int)&v123, v116 - v114, v145 - v132, v112 - v114, v143 - v132);
    v146 = (unsigned int)(46341 * a4) >> 16;
    v131 = v146 - 1;
    v147 = v146 + 1;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v15 = 0;
    }
    else
    {
      v15 = -1;
    }
    v129 &= v15;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v124 &= v14;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v128 &= v13;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v125 &= v12;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v130 &= v11;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v127 &= v10;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v123 &= v9;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v126 &= v8;
    v144 = 0;
    v117 = 0;
    while ( v144 < 8 )
    {
      *(&v135 + v144) = *(_BYTE *)(a1 + 1);
      v117 |= *(&v123 + v144++);
    }
    result = v117;
    if ( v117 )
    {
      v121 = 0;
      v122 = 0;
      v120 = a4;
      v115 = 1 - a4;
      v119 = v116;
      v118 = v145;
      v134 = v112;
      v133 = v143;
      while ( v122 < v120 )
      {
        if ( v115 >= 0 )
        {
          v113 = 0;
          if ( v129 )
          {
            v106 = 6;
            v107 = v129;
            v108 = v120 + v132;
            v109 = v121 + v114;
            v110 = v122 + v114;
            v111 = a5;
            *(_BYTE *)(a1 + 1) = v141;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v106, (int)&v118, (int)&v133);
            v141 = *(_BYTE *)(a1 + 1);
          }
          if ( v124 )
          {
            v100 = 1;
            v101 = v124;
            v102 = v132 - v120;
            v103 = v122 + v114;
            v104 = v121 + v114;
            v105 = a5;
            *(_BYTE *)(a1 + 1) = v136;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v100, (int)&v118, (int)&v133);
            v136 = *(_BYTE *)(a1 + 1);
          }
          if ( v128 )
          {
            v94 = 5;
            v95 = v128;
            v96 = v120 + v132;
            v97 = v114 - v122;
            v98 = v114 - v121;
            v99 = a5;
            *(_BYTE *)(a1 + 1) = v140;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v94, (int)&v118, (int)&v133);
            v140 = *(_BYTE *)(a1 + 1);
          }
          if ( v125 )
          {
            v88 = 2;
            v89 = v125;
            v90 = v132 - v120;
            v91 = v114 - v121;
            v92 = v114 - v122;
            v93 = a5;
            *(_BYTE *)(a1 + 1) = v137;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v88, (int)&v118, (int)&v133);
            v137 = *(_BYTE *)(a1 + 1);
          }
          if ( v130 )
          {
            v82 = 7;
            v83 = v130;
            v84 = v120 + v114;
            v85 = v122 + v132;
            v86 = v121 + v132;
            v87 = a5;
            *(_BYTE *)(a1 + 1) = v142;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v82, (int)&v118, (int)&v133);
            v142 = *(_BYTE *)(a1 + 1);
          }
          if ( v127 )
          {
            v76 = 4;
            v77 = v127;
            v78 = v114 - v120;
            v79 = v121 + v132;
            v80 = v122 + v132;
            v81 = a5;
            *(_BYTE *)(a1 + 1) = v139;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v76, (int)&v118, (int)&v133);
            v139 = *(_BYTE *)(a1 + 1);
          }
          if ( v123 )
          {
            v70 = 0;
            v71 = v123;
            v72 = v120 + v114;
            v73 = v132 - v121;
            v74 = v132 - v122;
            v75 = a5;
            *(_BYTE *)(a1 + 1) = v135;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v70, (int)&v118, (int)&v133);
            v135 = *(_BYTE *)(a1 + 1);
          }
          if ( v126 )
          {
            v64 = 3;
            v65 = v126;
            v66 = v114 - v120;
            v67 = v132 - v122;
            v68 = v132 - v121;
            v69 = a5;
            *(_BYTE *)(a1 + 1) = v138;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10092920(a1, (int)&v64, (int)&v118, (int)&v133);
            v138 = *(_BYTE *)(a1 + 1);
          }
          v121 = v122 + 1;
          v115 -= 2 * v120-- - 2;
        }
        v115 += 2 * v122++ + 3;
      }
      result = v120;
      if ( v122 == v120 )
      {
        v113 = 0;
        if ( v129 )
        {
          v58 = 6;
          v59 = v129;
          v60 = v120 + v132;
          v61 = v121 + v114;
          v62 = v122 + v114;
          v63 = a5;
          *(_BYTE *)(a1 + 1) = v141;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v58, (int)&v118, (int)&v133);
          v141 = *(_BYTE *)(a1 + 1);
        }
        if ( v124 )
        {
          v52 = 1;
          v53 = v124;
          v54 = v132 - v120;
          v55 = v122 + v114;
          v56 = v121 + v114;
          v57 = a5;
          *(_BYTE *)(a1 + 1) = v136;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v52, (int)&v118, (int)&v133);
          v136 = *(_BYTE *)(a1 + 1);
        }
        if ( v128 )
        {
          v46 = 5;
          v47 = v128;
          v48 = v120 + v132;
          v49 = v114 - v122;
          v50 = v114 - v121;
          v51 = a5;
          *(_BYTE *)(a1 + 1) = v140;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v46, (int)&v118, (int)&v133);
          v140 = *(_BYTE *)(a1 + 1);
        }
        if ( v125 )
        {
          v40 = 2;
          v41 = v125;
          v42 = v132 - v120;
          v43 = v114 - v121;
          v44 = v114 - v122;
          v45 = a5;
          *(_BYTE *)(a1 + 1) = v137;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v40, (int)&v118, (int)&v133);
          v137 = *(_BYTE *)(a1 + 1);
        }
        if ( v130 )
        {
          v34 = 7;
          v35 = v130;
          v36 = v120 + v114;
          v37 = v122 + v132;
          v38 = v121 + v132;
          v39 = a5;
          *(_BYTE *)(a1 + 1) = v142;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v34, (int)&v118, (int)&v133);
          v142 = *(_BYTE *)(a1 + 1);
        }
        if ( v127 )
        {
          v28 = 4;
          v29 = v127;
          v30 = v114 - v120;
          v31 = v121 + v132;
          v32 = v122 + v132;
          v33 = a5;
          *(_BYTE *)(a1 + 1) = v139;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v28, (int)&v118, (int)&v133);
          v139 = *(_BYTE *)(a1 + 1);
        }
        if ( v123 )
        {
          v22 = 0;
          v23 = v123;
          v24 = v120 + v114;
          v25 = v132 - v121;
          v26 = v132 - v122;
          v27 = a5;
          *(_BYTE *)(a1 + 1) = v135;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v22, (int)&v118, (int)&v133);
          v135 = *(_BYTE *)(a1 + 1);
        }
        result = v126;
        if ( v126 )
        {
          v16 = 3;
          v17 = v126;
          v18 = v114 - v120;
          v19 = v132 - v122;
          v20 = v132 - v121;
          v21 = a5;
          *(_BYTE *)(a1 + 1) = v138;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10092920(a1, (int)&v16, (int)&v118, (int)&v133);
          result = a1;
          v138 = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else if ( a5 & 2 )
  {
    result = sub_10094980(a1, a2, a3, a4, 0);
  }
  else
  {
    result = sub_10094920(a1, a6, a7);
  }
  return result;
}

//----- (10092920) --------------------------------------------------------
char *__cdecl sub_10092920(int a1, int a2, int a3, int a4)
{
  if ( (*(_BYTE *)a2 + 1) & 2 )
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a2 + 10) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)a3;
    *(_WORD *)(a2 + 10) = *(_WORD *)a4;
  }
  return off_10151408[*(_BYTE *)a2](a1, a2);
}
// 10151408: using guessed type int (__cdecl *off_10151408[16])(int, int);

//----- (10092990) --------------------------------------------------------
char __cdecl sub_10092990(int a1, int a2)
{
  *(_WORD *)(a1 + 8) = *(_WORD *)a2;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_100936D0(a1);
}

//----- (100929E0) --------------------------------------------------------
char *__cdecl sub_100929E0(int a1, int a2)
{
  *(_WORD *)(a1 + 10) = *(_WORD *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_100938A0(a1);
}

//----- (10092A30) --------------------------------------------------------
signed int __cdecl sub_10092A30(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  signed int result; // eax@3
  int v6; // edx@7
  int v7; // eax@11
  char v8; // [sp+5h] [bp-3h]@1
  char i; // [sp+5h] [bp-3h]@2
  unsigned __int8 v10; // [sp+5h] [bp-3h]@3
  bool v11; // [sp+6h] [bp-2h]@7
  char v12; // [sp+7h] [bp-1h]@1

  v8 = sub_10092B80(a2, a3);
  v12 = sub_10092B80(a4, a5);
  if ( (unsigned __int8)v8 == (unsigned __int8)v12 )
  {
    switch ( v8 )
    {
      case 0:
      case 7:
        v6 = a5 < a3;
        v11 = a5 > a3;
        break;
      case 1:
      case 2:
        v6 = a4 < a2;
        v11 = a4 > a2;
        break;
      case 3:
      case 4:
        v6 = a5 < a3;
        v11 = a5 < a3;
        break;
      default:
        v6 = a4 < a2;
        v11 = a4 < a2;
        break;
    }
    LOBYTE(v6) = v11;
    BYTE1(v6) = v11;
    v7 = v6 << 16;
    LOWORD(v7) = v6;
    *(_DWORD *)a1 = v7;
    *(_DWORD *)(a1 + 4) = v7;
    result = v11 != 0 ? 10 : 13;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = result;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = 5;
    *(_BYTE *)(a1 + (unsigned __int8)v12) = 9;
    for ( i = v8 + 1; ; i = v10 + 1 )
    {
      v10 = i & 7;
      result = v10;
      if ( v10 == (unsigned __int8)v12 )
        break;
      *(_BYTE *)(a1 + v10) = 1;
    }
  }
  return result;
}

//----- (10092B80) --------------------------------------------------------
char __cdecl sub_10092B80(__int16 a1, __int16 a2)
{
  char v3; // [sp+1h] [bp-1h]@3

  if ( a1 >= 0 )
  {
    if ( a1 <= 0 )
    {
      v3 = 4 * (a2 >= 0) + 2;
    }
    else if ( a2 > 0 )
    {
      v3 = (a1 >= a2) + 6;
    }
    else
    {
      v3 = a1 <= -a2;
    }
  }
  else if ( a2 >= 0 )
  {
    v3 = (a1 >= -a2) + 4;
  }
  else
  {
    v3 = (a1 <= a2) + 2;
  }
  return v3;
}

//----- (10092C20) --------------------------------------------------------
char *__cdecl sub_10092C20(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) >= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      --v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10151428[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) < (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  --*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10151428[*(_BYTE *)a2](a1, (int)&v5);
}
// 10151428: using guessed type int (__cdecl *off_10151428[8])(int, int);

//----- (10092DD0) --------------------------------------------------------
char *__cdecl sub_10092DD0(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) <= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      ++v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10151428[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) > (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  ++*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10151428[*(_BYTE *)a2](a1, (int)&v5);
}
// 10151428: using guessed type int (__cdecl *off_10151428[8])(int, int);

//----- (10092F80) --------------------------------------------------------
int __cdecl sub_10092F80(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10093150) --------------------------------------------------------
int __cdecl sub_10093150(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10151450 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (10093620) --------------------------------------------------------
char __cdecl sub_10093620(int a1)
{
  int v1; // eax@3
  int v3; // [sp+0h] [bp-30h]@3
  __int16 v4; // [sp+4h] [bp-2Ch]@1
  char v5; // [sp+8h] [bp-28h]@6
  int v6; // [sp+14h] [bp-1Ch]@1

  v6 = *(_WORD *)(a1 + 10);
  v4 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
  if ( v4 < 0 )
  {
    v6 = *(_WORD *)(a1 + 14);
    v4 = -v4;
  }
  v1 = (signed __int16)(v4 + 1);
  v6 = v1 + (v6 << 16);
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 == 1 )
  {
    LOBYTE(v1) = sub_100939F0(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  else if ( v3 == 3 )
  {
    LOBYTE(v1) = sub_10093EE0(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  return v1;
}

//----- (100936D0) --------------------------------------------------------
char __cdecl sub_100936D0(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_10093D70(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_100946A0(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_10093D70(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_10093D70(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_10093EE0(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_10094310(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (10093840) --------------------------------------------------------
int __cdecl sub_10093840(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  result = a1;
  v2 = *(_WORD *)(a1 + 4);
  if ( *(_WORD *)(a1 + 4) && v2 != 2 )
  {
    if ( v2 == 3 )
      result = sub_10093FF0(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  else
  {
    result = sub_10093DF0(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  return result;
}

//----- (100938A0) --------------------------------------------------------
char *__cdecl sub_100938A0(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10093E60(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_100940E0(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10094450(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10093E60(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_100947E0(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (100939F0) --------------------------------------------------------
unsigned int __cdecl sub_100939F0(int a1, signed int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  result = sub_10093AB0(a1, a4);
  if ( *(_DWORD *)a4 )
  {
    *(_DWORD *)(a4 + 32) = (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) >> (*(_BYTE *)(a4 + 12) & 0x1F)) | (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) << (32 - (*(_BYTE *)(a4 + 12) & 0x1F)));
    *(_DWORD *)(a4 + 36) = 1;
    result = sub_10093BD0(a1, a4);
  }
  return result;
}

//----- (10093AB0) --------------------------------------------------------
int __cdecl sub_10093AB0(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10093BD0) --------------------------------------------------------
unsigned int __cdecl sub_10093BD0(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (10093D70) --------------------------------------------------------
int __cdecl sub_10093D70(int a1, int a2, int a3)
{
  return sub_10093150(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (10093DF0) --------------------------------------------------------
int __cdecl sub_10093DF0(int a1, int a2, int a3)
{
  return sub_10093150(
           a1,
           (a2 << 16) + *(_WORD *)(a1 + 34) - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           (a3 << 16) + *(_WORD *)(a1 + 32) - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10093E60) --------------------------------------------------------
int __cdecl sub_10093E60(int a1, int a2, int a3)
{
  return sub_10093150(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10093EE0) --------------------------------------------------------
char __cdecl sub_10093EE0(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_10093FF0(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10093AB0(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10151450 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10151450 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (10093FF0) --------------------------------------------------------
int __cdecl sub_10093FF0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (100940E0) --------------------------------------------------------
int __cdecl sub_100940E0(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_100941E0(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (100941E0) --------------------------------------------------------
int __cdecl sub_100941E0(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10094310) --------------------------------------------------------
char *__cdecl sub_10094310(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10093AB0(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10093BD0(a1, (int)v11);
  }
  return result;
}

//----- (10094450) --------------------------------------------------------
char *__cdecl sub_10094450(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_100941E0(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100946A0) --------------------------------------------------------
int __cdecl sub_100946A0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10094310(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_10093EE0(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (100947E0) --------------------------------------------------------
int __cdecl sub_100947E0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10094450(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_100940E0(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10094920) --------------------------------------------------------
int __cdecl sub_10094920(int a1, __int16 a2, __int16 a3)
{
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 46) + *(_WORD *)(a1 + 42);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 40);
  return sub_10093840(a1);
}

//----- (10094980) --------------------------------------------------------
char __cdecl sub_10094980(int a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ST3C_4@5
  char result; // al@5
  char v7; // [sp+0h] [bp-64h]@52
  char v8; // [sp+4h] [bp-60h]@46
  char v9; // [sp+8h] [bp-5Ch]@40
  char v10; // [sp+Ch] [bp-58h]@34
  char v11; // [sp+10h] [bp-54h]@28
  char v12; // [sp+14h] [bp-50h]@22
  char v13; // [sp+18h] [bp-4Ch]@16
  char v14; // [sp+1Ch] [bp-48h]@10
  __int16 v15; // [sp+24h] [bp-40h]@1
  int v16; // [sp+28h] [bp-3Ch]@58
  __int16 v17; // [sp+2Ch] [bp-38h]@58
  __int16 v18; // [sp+30h] [bp-34h]@58
  __int16 v19; // [sp+34h] [bp-30h]@58
  __int16 v20; // [sp+38h] [bp-2Ch]@6
  __int16 v21; // [sp+3Ch] [bp-28h]@1
  char v22; // [sp+40h] [bp-24h]@56
  char v23; // [sp+41h] [bp-23h]@64
  char v24; // [sp+42h] [bp-22h]@68
  char v25; // [sp+43h] [bp-21h]@76
  char v26; // [sp+44h] [bp-20h]@72
  char v27; // [sp+45h] [bp-1Fh]@66
  char v28; // [sp+46h] [bp-1Eh]@62
  char v29; // [sp+47h] [bp-1Dh]@70
  int v30; // [sp+48h] [bp-1Ch]@54
  __int16 v31; // [sp+4Ch] [bp-18h]@6
  char v32; // [sp+50h] [bp-14h]@48
  char v33; // [sp+51h] [bp-13h]@18
  char v34; // [sp+52h] [bp-12h]@30
  char v35; // [sp+53h] [bp-11h]@54
  char v36; // [sp+54h] [bp-10h]@42
  char v37; // [sp+55h] [bp-Fh]@24
  char v38; // [sp+56h] [bp-Eh]@12
  char v39; // [sp+57h] [bp-Dh]@36
  char v40; // [sp+5Fh] [bp-5h]@54
  __int16 v41; // [sp+60h] [bp-4h]@6

  v15 = *(_WORD *)(a1 + 42) + a2;
  v21 = *(_WORD *)(a1 + 40) + a3;
  if ( a5 & 1 )
    sub_10095400(a1, a2, a3, a4);
  if ( *(_WORD *)(a1 + 4) != 4 || (signed int)*(_WORD *)(a1 + 2) <= 1 )
  {
    v31 = 46341 * a4 / 0x10000;
    v20 = v31 - 1;
    v41 = v31 + 1;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v38 = v14;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v33 = v13;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v37 = v12;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v34 = v11;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v39 = v10;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v36 = v9;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v32 = v8;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v7 = 0;
    }
    else
    {
      v7 = -1;
    }
    result = v7;
    v35 = v7;
    v30 = 0;
    v40 = 0;
    while ( v30 < 8 )
    {
      *(&v22 + v30) = *(_BYTE *)(a1 + 1);
      result = *(&v32 + v30);
      v40 |= result;
      ++v30;
    }
    if ( v40 )
    {
      v18 = 0;
      v19 = 0;
      v17 = a4;
      v16 = 1 - a4;
      while ( v19 < v17 )
      {
        if ( v16 >= 0 )
        {
          *(_WORD *)(a1 + 10) = v18 + v15;
          *(_WORD *)(a1 + 14) = v19 + 1 - v18;
          if ( v38 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v28;
            sub_100936D0(a1);
            v28 = *(_BYTE *)(a1 + 1);
          }
          if ( v33 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v23;
            sub_100936D0(a1);
            v23 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 10) = v15 - v18;
          *(_WORD *)(a1 + 14) = v18 - v19 - 1;
          if ( v37 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v27;
            sub_100936D0(a1);
            v27 = *(_BYTE *)(a1 + 1);
          }
          if ( v34 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v24;
            sub_100936D0(a1);
            v24 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v18 + v21;
          *(_WORD *)(a1 + 12) = v19 + 1 - v18;
          if ( v39 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v29;
            sub_100938A0(a1);
            v29 = *(_BYTE *)(a1 + 1);
          }
          if ( v36 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v26;
            sub_100938A0(a1);
            v26 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v21 - v18;
          *(_WORD *)(a1 + 12) = v18 - v19 - 1;
          if ( v32 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v22;
            sub_100938A0(a1);
            v22 = *(_BYTE *)(a1 + 1);
          }
          if ( v35 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v25;
            sub_100938A0(a1);
            v25 = *(_BYTE *)(a1 + 1);
          }
          v18 = v19 + 1;
          v16 -= 2 * v17-- - 2;
        }
        v16 += 2 * v19++ + 3;
      }
      result = v17;
      if ( v19 == v17 )
      {
        *(_WORD *)(a1 + 10) = v18 + v15;
        *(_WORD *)(a1 + 14) = v19 + 1 - v18;
        if ( v38 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v28;
          sub_100936D0(a1);
          v28 = *(_BYTE *)(a1 + 1);
        }
        if ( v33 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v23;
          sub_100936D0(a1);
          v23 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 10) = v15 - v18;
        *(_WORD *)(a1 + 14) = v18 - v19 - 1;
        if ( v37 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v27;
          sub_100936D0(a1);
          v27 = *(_BYTE *)(a1 + 1);
        }
        if ( v34 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v24;
          sub_100936D0(a1);
          v24 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v18 + v21;
        *(_WORD *)(a1 + 12) = v19 + 1 - v18;
        if ( v39 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v29;
          sub_100938A0(a1);
          v29 = *(_BYTE *)(a1 + 1);
        }
        if ( v36 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v26;
          sub_100938A0(a1);
          v26 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v21 - v18;
        result = a1;
        *(_WORD *)(a1 + 12) = v18 - v19 - 1;
        if ( v32 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v22;
          sub_100938A0(a1);
          result = *(_BYTE *)(a1 + 1);
          v22 = *(_BYTE *)(a1 + 1);
        }
        if ( v35 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v25;
          sub_100938A0(a1);
          result = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 44);
    *(_WORD *)(a1 + 46) = a2;
    *(_WORD *)(a1 + 44) = a3 - a4;
    sub_100917E0(a1, a2, a3, a4, 1, a2, a4 + a3);
    sub_100917E0(a1, a2, a3, a4, 1, a2, a3 - a4);
    result = v5;
    *(_DWORD *)(a1 + 44) = v5;
  }
  return result;
}

//----- (10095400) --------------------------------------------------------
int __cdecl sub_10095400(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax@5
  int v5; // [sp+0h] [bp-18h]@6
  __int16 v6; // [sp+4h] [bp-14h]@6
  int v7; // [sp+8h] [bp-10h]@1
  __int16 v8; // [sp+Ch] [bp-Ch]@6
  __int16 v9; // [sp+10h] [bp-8h]@1
  __int16 v10; // [sp+14h] [bp-4h]@1

  v7 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
  v10 = *(_WORD *)(a1 + 42) + a2;
  v9 = *(_WORD *)(a1 + 40) + a3;
  if ( v10 - a4 < *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
    && a4 + v10 >= *(_WORD *)(a1 + 26)
    && v9 - a4 < *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
    && a4 + v9 >= *(_WORD *)(a1 + 24) )
  {
    v8 = 0;
    v6 = a4;
    v5 = 1 - a4;
    while ( v8 < v6 )
    {
      if ( v5 >= 0 )
      {
        *(_WORD *)(a1 + 10) = v8 + v10;
        *(_WORD *)(a1 + 8) = v6 + v9;
        *(_WORD *)(a1 + 14) = v10 - v8;
        sub_10093620(a1);
        *(_WORD *)(a1 + 8) = v9 - v6;
        sub_10093620(a1);
        v5 -= 2 * v6-- - 2;
      }
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_10093620(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      sub_10093620(a1);
      v5 += 2 * v8++ + 3;
    }
    result = v8;
    if ( v8 == v6 )
    {
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_10093620(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      LOBYTE(result) = sub_10093620(a1);
    }
    *(_DWORD *)(a1 + 36) = v7;
  }
  else
  {
    result = v7;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

//----- (10095660) --------------------------------------------------------
int __cdecl sub_10095660(signed int a1, signed int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( a2 > 0 )
  {
    v3 = a2 * (a1 / a2);
    if ( a1 == v3 )
      result = a1;
    else
      result = (a1 < 0 ? 0 : a2) + v3;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100956A0) --------------------------------------------------------
double __cdecl sub_100956A0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10095740) --------------------------------------------------------
double __cdecl sub_10095740(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100957E0) --------------------------------------------------------
double __cdecl sub_100957E0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (10095840) --------------------------------------------------------
double __cdecl sub_10095840(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100958C0) --------------------------------------------------------
void __cdecl sub_100958C0(double a1)
{
  sub_100957E0(a1, 3.1415926535898);
}

//----- (100958E0) --------------------------------------------------------
double __cdecl sub_100958E0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10095840(a1, 3.1415927);
  return result;
}

//----- (10095920) --------------------------------------------------------
int __cdecl sub_10095920(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (10095940) --------------------------------------------------------
int __cdecl sub_10095940(float a1)
{
  double v1; // st7@1
  int result; // eax@2

  v1 = a1;
  if ( a1 >= 0.0 )
    result = (signed int)(v1 + 0.5);
  else
    result = (signed int)(v1 - 0.5);
  return result;
}

//----- (10095970) --------------------------------------------------------
double __cdecl sub_10095970(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100959E0) --------------------------------------------------------
int __cdecl sub_100959E0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (10095A00) --------------------------------------------------------
int __cdecl sub_10095A00(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_100958E0(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (10095A60) --------------------------------------------------------
double __cdecl sub_10095A60(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_100958C0(result);
    }
  }
  return result;
}

//----- (10095AD0) --------------------------------------------------------
double __cdecl sub_10095AD0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_100958E0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (10095B60) --------------------------------------------------------
double __cdecl sub_10095B60(int a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@1

  v1 = *(float *)a1 * *(float *)a1 + 0.0;
  v2 = *(float *)(a1 + 4) * *(float *)(a1 + 4) + v1;
  return (float)sqrt(v2);
}

//----- (10095BA0) --------------------------------------------------------
int __cdecl sub_10095BA0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = a1 * *(float *)(a2 + 4);
  return result;
}

//----- (10095BC0) --------------------------------------------------------
int __cdecl sub_10095BC0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 - *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) - *(float *)(a2 + 4);
  return result;
}

//----- (10095BE0) --------------------------------------------------------
int __cdecl sub_10095BE0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(float *)a1;
  *(float *)(a2 + 4) = *(float *)(a1 + 4);
  return result;
}

//----- (10095C00) --------------------------------------------------------
void __cdecl sub_10095C00(int a1, int a2)
{
  int v2; // edx@1
  float v3; // ST10_4@1
  double v4; // st7@1

  sub_10095BE0(a1, a2);
  v3 = sub_10095B60(v2);
  v4 = v3;
  if ( v3 > 0.0 )
  {
    *(float *)a2 = *(float *)a2 / v4;
    *(float *)(a2 + 4) = *(float *)(a2 + 4) / v4;
  }
}

//----- (10095C50) --------------------------------------------------------
int __cdecl sub_10095C50(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (10095C80) --------------------------------------------------------
int __cdecl sub_10095C80(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10095CB0) --------------------------------------------------------
int __cdecl sub_10095CB0(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx@0
  int v3; // eax@1
  __int64 v4; // ST30_8@1
  unsigned int v5; // eax@1
  unsigned int v6; // ST28_4@1
  unsigned int v7; // ST20_4@1
  __int64 v8; // rax@1
  unsigned __int64 v9; // ST3C_8@1
  unsigned __int64 v10; // rax@1
  signed __int64 v11; // rdi@1
  unsigned __int64 v12; // ST3C_8@1
  __int64 v13; // ST20_8@1
  unsigned __int64 v14; // ST3C_8@1
  signed __int64 v15; // kr00_8@1
  signed __int64 v16; // rdi@1
  unsigned __int64 v17; // ST3C_8@1
  int result; // eax@1

  v3 = 1686629713i64 * a1 >> 29;
  v4 = v3;
  v5 = v3 * (signed __int64)v3 >> 30;
  v6 = v5;
  v7 = v5 >> 1;
  v8 = v5 >> 1;
  v9 = __PAIR__(HIDWORD(v8), v7);
  v10 = __PAIR__(HIDWORD(v8), v7) << 31;
  v11 = -715827883i64 * v9 + 0x7FFFFFFFFFFFFFFFi64;
  v12 = v7 * (unsigned __int64)v6;
  v13 = SHIDWORD(v12);
  v14 = HIDWORD(v12) * (unsigned __int64)v6;
  v15 = -5965232i64 * SHIDWORD(v14) + 178956971i64 * (signed int)v13 + 0x7FFFFFFFFFFFFFFFi64 - v10;
  v16 = -852176i64 * SHIDWORD(v14) + 35791394 * v13 + v11;
  v17 = HIDWORD(v14) * (unsigned __int64)v6;
  result = (signed int)((unsigned __int64)(-108i64 * SHIDWORD(v17) + 11836i64 * SHIDWORD(v17) + v16) >> 32) * v4 >> 31;
  *v2 = result;
  *a2 = (unsigned __int64)(-1184i64 * SHIDWORD(v17) + 106522i64 * SHIDWORD(v17) + v15) >> 32;
  return result;
}

//----- (10095EC0) --------------------------------------------------------
int __cdecl sub_10095EC0(int a1, int *a2, int *a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // edx@2
  int result; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  sub_10095CB0(((a1 + 0x20000000) & 0x3FFFFFFF) - 0x20000000, &v7);
  v3 = ((a1 + 0x20000000) >> 30) & 3;
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = v7;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        *a2 = -a1;
        result = (int)a3;
        *a3 = -v5;
      }
      else
      {
        result = (int)a2;
        *a2 = -v7;
        *a3 = a1;
      }
    }
    else
    {
      *a2 = v7;
      result = -a1;
      *a3 = -a1;
    }
  }
  else
  {
    result = a1;
    *a2 = a1;
    *a3 = v7;
  }
  return result;
}

//----- (10095F60) --------------------------------------------------------
int __cdecl sub_10095F60(unsigned __int8 a1, unsigned int a2)
{
  return dword_10151D90[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10151D90: using guessed type int dword_10151D90[];

//----- (10095F80) --------------------------------------------------------
unsigned int __cdecl sub_10095F80(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10151D90[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10151D90[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10151D90[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10151D90[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10151D90[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10151D90[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10151D90[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10151D90[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10151D90[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10151D90[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10151D90: using guessed type int dword_10151D90[];

//----- (1009814A) --------------------------------------------------------
int __thiscall sub_1009814A(void *this)
{
  return _cintrindisp2(this, &unk_10166A30);
}
// 1009F9B0: using guessed type int __fastcall _cintrindisp2(_DWORD, _DWORD);

//----- (10098802) --------------------------------------------------------
int __cdecl sub_10098802(int a1, int a2, char a3)
{
  return vscan_fn(sub_100A17BB, a2, 0, &a3);
}
// 1009879A: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1009991A) --------------------------------------------------------
int __cdecl sub_1009991A(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_100A3A2E() + 8 && (void **)v2 != sub_100A3A2E() + 16 || !sub_100A39D0((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_10166340;
      else
        v9 = (_BYTE *)(dword_10320BA0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_100A38B0((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_100A38B0((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 100A398C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (1009A4AF) --------------------------------------------------------
int __cdecl sub_1009A4AF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102AC574 = a1;
  return result;
}
// 102AC574: using guessed type int dword_102AC574;

//----- (1009C295) --------------------------------------------------------
signed int __cdecl sub_1009C295(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_102AC8A0 )
  {
    *a1 = dword_102AC8A0;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102AC8A0: using guessed type int dword_102AC8A0;

//----- (1009C2CC) --------------------------------------------------------
signed int __cdecl sub_1009C2CC(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_102AC8A0 )
  {
    *a1 = dword_102AC8AC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102AC8A0: using guessed type int dword_102AC8A0;
// 102AC8AC: using guessed type int dword_102AC8AC;

//----- (1009CF12) --------------------------------------------------------
void sub_1009CF12()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_10320BA0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_10320CA0 );
}
// 10320BA0: using guessed type int dword_10320BA0[];
// 10320CA0: using guessed type int dword_10320CA0;

//----- (1009D3BF) --------------------------------------------------------
int (*sub_1009D3BF())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_10164350;
  v1 = (int (**)(void))&unk_10164350;
  if ( &unk_10164350 < &unk_10164350 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_10164350 );
  }
  return result;
}

//----- (1009D3E3) --------------------------------------------------------
void __cdecl sub_1009D3E3()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_10164358;
  if ( &unk_10164358 < &unk_10164358 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_10164358 );
  }
}

//----- (1009FD54) --------------------------------------------------------
#error "1009FD59: positive sp value has been found (funcsize=0)"

//----- (1009FD5F) --------------------------------------------------------
#error "1009FD64: positive sp value has been found (funcsize=0)"

//----- (1009FD6A) --------------------------------------------------------
#error "1009FD6F: positive sp value has been found (funcsize=0)"

//----- (1009FD70) --------------------------------------------------------
#error "1009FD75: positive sp value has been found (funcsize=0)"

//----- (1009FD76) --------------------------------------------------------
#error "1009FD7B: positive sp value has been found (funcsize=0)"

//----- (1009FD7C) --------------------------------------------------------
#error "1009FD81: positive sp value has been found (funcsize=0)"

//----- (1009FD82) --------------------------------------------------------
#error "1009FD9D: positive sp value has been found (funcsize=0)"

//----- (1009FDA3) --------------------------------------------------------
#error "1009FDB8: positive sp value has been found (funcsize=0)"

//----- (1009FDBE) --------------------------------------------------------
#error "1009FDD9: positive sp value has been found (funcsize=0)"

//----- (1009FDDA) --------------------------------------------------------
#error "1009FDE9: positive sp value has been found (funcsize=0)"

//----- (1009FDEA) --------------------------------------------------------
#error "1009FDFD: positive sp value has been found (funcsize=0)"

//----- (1009FDFE) --------------------------------------------------------
#error "1009FE0D: positive sp value has been found (funcsize=0)"

//----- (1009FE0E) --------------------------------------------------------
#error "1009FE2D: positive sp value has been found (funcsize=0)"

//----- (1009FE33) --------------------------------------------------------
#error "1009FE4C: positive sp value has been found (funcsize=0)"

//----- (1009FE52) --------------------------------------------------------
#error "1009FE71: positive sp value has been found (funcsize=0)"

//----- (1009FE72) --------------------------------------------------------
#error "1009FE85: positive sp value has been found (funcsize=0)"

//----- (1009FE86) --------------------------------------------------------
#error "1009FE9D: positive sp value has been found (funcsize=0)"

//----- (1009FE9E) --------------------------------------------------------
#error "1009FEB1: positive sp value has been found (funcsize=0)"

//----- (1009FEB2) --------------------------------------------------------
#error "1009FED1: positive sp value has been found (funcsize=0)"

//----- (1009FED7) --------------------------------------------------------
#error "1009FEF0: positive sp value has been found (funcsize=0)"

//----- (1009FEF6) --------------------------------------------------------
#error "1009FF15: positive sp value has been found (funcsize=0)"

//----- (1009FF16) --------------------------------------------------------
#error "1009FF29: positive sp value has been found (funcsize=0)"

//----- (1009FF2A) --------------------------------------------------------
#error "1009FF41: positive sp value has been found (funcsize=0)"

//----- (1009FF42) --------------------------------------------------------
#error "1009FF55: positive sp value has been found (funcsize=0)"

//----- (1009FF56) --------------------------------------------------------
#error "1009FF75: positive sp value has been found (funcsize=0)"

//----- (1009FF7B) --------------------------------------------------------
#error "1009FF94: positive sp value has been found (funcsize=0)"

//----- (1009FF9A) --------------------------------------------------------
#error "1009FFB9: positive sp value has been found (funcsize=0)"

//----- (1009FFBA) --------------------------------------------------------
#error "1009FFCD: positive sp value has been found (funcsize=0)"

//----- (1009FFCE) --------------------------------------------------------
#error "1009FFE5: positive sp value has been found (funcsize=0)"

//----- (1009FFE6) --------------------------------------------------------
#error "1009FFF9: positive sp value has been found (funcsize=0)"

//----- (1009FFFA) --------------------------------------------------------
#error "100A0019: positive sp value has been found (funcsize=0)"

//----- (100A001F) --------------------------------------------------------
#error "100A0038: positive sp value has been found (funcsize=0)"

//----- (100A003E) --------------------------------------------------------
#error "100A005D: positive sp value has been found (funcsize=0)"

//----- (100A005E) --------------------------------------------------------
#error "100A0071: positive sp value has been found (funcsize=0)"

//----- (100A0072) --------------------------------------------------------
#error "100A0089: positive sp value has been found (funcsize=0)"

//----- (100A008A) --------------------------------------------------------
#error "100A009D: positive sp value has been found (funcsize=0)"

//----- (100A009E) --------------------------------------------------------
#error "100A00BD: positive sp value has been found (funcsize=0)"

//----- (100A00C3) --------------------------------------------------------
#error "100A00DC: positive sp value has been found (funcsize=0)"

//----- (100A00E2) --------------------------------------------------------
#error "100A0101: positive sp value has been found (funcsize=0)"

//----- (100A0102) --------------------------------------------------------
#error "100A0115: positive sp value has been found (funcsize=0)"

//----- (100A0116) --------------------------------------------------------
#error "100A012D: positive sp value has been found (funcsize=0)"

//----- (100A012E) --------------------------------------------------------
#error "100A0141: positive sp value has been found (funcsize=0)"

//----- (100A0142) --------------------------------------------------------
#error "100A0161: positive sp value has been found (funcsize=0)"

//----- (100A0167) --------------------------------------------------------
#error "100A0180: positive sp value has been found (funcsize=0)"

//----- (100A0186) --------------------------------------------------------
#error "100A01A5: positive sp value has been found (funcsize=0)"

//----- (100A01A6) --------------------------------------------------------
#error "100A01B9: positive sp value has been found (funcsize=0)"

//----- (100A01BA) --------------------------------------------------------
#error "100A01D1: positive sp value has been found (funcsize=0)"

//----- (100A01D2) --------------------------------------------------------
#error "100A01E5: positive sp value has been found (funcsize=0)"

//----- (100A17BB) --------------------------------------------------------
int __cdecl sub_100A17BB(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_10166340;
  }
  else
  {
    v6 = &dword_10320BA0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_10166340) : (v8 = &dword_10320BA0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_100A77AC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_100A77AC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_100A77AC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_100A77AC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_100A77AC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1016628C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_100A77AC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_100A77AC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_100A77AC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_100A77AC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1009C5CB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 100A1780: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100A1796: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1016628C: using guessed type int (*off_1016628C[3])();
// 10320BA0: using guessed type int dword_10320BA0[];
// 100A17BB: using guessed type char var_24[11];

//----- (100A2BE0) --------------------------------------------------------
int __cdecl sub_100A2BE0(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100A6029((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1009E4F1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100A2C86) --------------------------------------------------------
int __cdecl sub_100A2C86(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100A656B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1009E4F1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100A30F2) --------------------------------------------------------
DWORD __cdecl sub_100A30F2(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_100A876C(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_10320BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10098D80: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A328E) --------------------------------------------------------
_WORD *__cdecl sub_100A328E(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_10320BA0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_10320BA0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_100A30F2(a1, 0, 0, 2u);
  if ( sub_100A39D0(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10098D80: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1009C7E7: using guessed type int _getptd(void);
// 10320BA0: using guessed type int dword_10320BA0[];
// 100A328E: using guessed type CHAR var_410[688];

//----- (100A38B0) --------------------------------------------------------
_WORD *__cdecl sub_100A38B0(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_10320BA0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_100A328E(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_100A887D(a1);
  return v6;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100A87DD: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A39D0) --------------------------------------------------------
int __cdecl sub_100A39D0(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_10320BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A3A2E) --------------------------------------------------------
void **sub_100A3A2E()
{
  return &off_10166D10;
}
// 10166D10: using guessed type void *off_10166D10;

//----- (100A3A34) --------------------------------------------------------
signed int sub_100A3A34()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_10320B80;
  if ( !dword_10320B80 )
  {
    v0 = 512;
LABEL_5:
    dword_10320B80 = v0;
    goto LABEL_6;
  }
  if ( dword_10320B80 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_1031FB64 = v1;
  if ( v1 || (dword_10320B80 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_1031FB64 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_10166D10;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dbl_10166F90 )
        break;
      v1 = dword_1031FB64;
    }
    v5 = 0;
    v6 = &unk_10166D20;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_10320BA0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_10166D80 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1009CBDB: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 10166D10: using guessed type void *off_10166D10;
// 10166F90: using guessed type double dbl_10166F90;
// 10320B80: using guessed type int dword_10320B80;
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A3E25) --------------------------------------------------------
void sub_100A3E25()
{
  dword_1031FB60 = 0;
}
// 1031FB60: using guessed type int dword_1031FB60;

//----- (100A3EDD) --------------------------------------------------------
int sub_100A3EDD()
{
  dword_10320CB8 = _get_sse2_info();
  return 0;
}
// 100A3E7D: using guessed type int _get_sse2_info(void);
// 10320CB8: using guessed type int dword_10320CB8;

//----- (100A46A2) --------------------------------------------------------
int sub_100A46A2()
{
  return _decode_pointer(dword_102ACED0);
}
// 1009C5CB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 102ACED0: using guessed type int dword_102ACED0;

//----- (100A485F) --------------------------------------------------------
int __cdecl sub_100A485F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102ACEDC = a1;
  return result;
}
// 102ACEDC: using guessed type int dword_102ACEDC;

//----- (100A4869) --------------------------------------------------------
int __cdecl sub_100A4869(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102ACEE8 = a1;
  return result;
}
// 102ACEE8: using guessed type int dword_102ACEE8;

//----- (100A4873) --------------------------------------------------------
int __cdecl sub_100A4873(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102ACEEC = a1;
  return result;
}
// 102ACEEC: using guessed type int dword_102ACEEC;

//----- (100A4952) --------------------------------------------------------
int __cdecl sub_100A4952(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102ACEF0 = a1;
  return result;
}
// 102ACEF0: using guessed type int dword_102ACEF0;

//----- (100A6029) --------------------------------------------------------
signed int __cdecl sub_100A6029(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10167188 - 1;
    v64 = v3;
    v65 = dword_10167188 / 32;
    v9 = dword_10167188 % 32;
    v10 = (int *)(&v60 + dword_10167188 / 32);
    v66 = 31 - dword_10167188 % 32;
    if ( (1 << (31 - dword_10167188 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10167184 - dword_10167188 )
    {
      if ( v3 > dword_10167184 )
      {
        if ( v3 < dword_10167180 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10167194 + v3;
          v50 = dword_1016718C / 32;
          v51 = dword_1016718C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1016718C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1016718C / 32;
          v44 = dword_1016718C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1016718C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10167194 + dword_10167180;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10167184 - v64) / 32;
      v62 = v59;
      v18 = (dword_10167184 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10167188 - 1;
      v25 = dword_10167188 / 32;
      v65 = dword_10167188 / 32;
      v26 = (int *)(&v60 + dword_10167188 / 32);
      v64 = 31 - dword_10167188 % 32;
      if ( (1 << (31 - dword_10167188 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10167188 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1016718C + 1) / 32;
      v37 = (dword_1016718C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1016718C));
  if ( dword_10167190 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10167190 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10167180: using guessed type int dword_10167180;
// 10167184: using guessed type int dword_10167184;
// 10167188: using guessed type int dword_10167188;
// 1016718C: using guessed type int dword_1016718C;
// 10167190: using guessed type int dword_10167190;
// 10167194: using guessed type int dword_10167194;

//----- (100A656B) --------------------------------------------------------
signed int __cdecl sub_100A656B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_101671A0 - 1;
    v64 = v3;
    v65 = dword_101671A0 / 32;
    v9 = dword_101671A0 % 32;
    v10 = (int *)(&v60 + dword_101671A0 / 32);
    v66 = 31 - dword_101671A0 % 32;
    if ( (1 << (31 - dword_101671A0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1016719C - dword_101671A0 )
    {
      if ( v3 > dword_1016719C )
      {
        if ( v3 < dword_10167198 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_101671AC + v3;
          v50 = dword_101671A4 / 32;
          v51 = dword_101671A4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_101671A4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_101671A4 / 32;
          v44 = dword_101671A4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_101671A4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_101671AC + dword_10167198;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1016719C - v64) / 32;
      v62 = v59;
      v18 = (dword_1016719C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_101671A0 - 1;
      v25 = dword_101671A0 / 32;
      v65 = dword_101671A0 / 32;
      v26 = (int *)(&v60 + dword_101671A0 / 32);
      v64 = 31 - dword_101671A0 % 32;
      if ( (1 << (31 - dword_101671A0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_101671A0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_101671A4 + 1) / 32;
      v37 = (dword_101671A4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_101671A4));
  if ( dword_101671A8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_101671A8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10167198: using guessed type int dword_10167198;
// 1016719C: using guessed type int dword_1016719C;
// 101671A0: using guessed type int dword_101671A0;
// 101671A4: using guessed type int dword_101671A4;
// 101671A8: using guessed type int dword_101671A8;
// 101671AC: using guessed type int dword_101671AC;

//----- (100A6C79) --------------------------------------------------------
int sub_100A6C79()
{
  return 0;
}

//----- (100A768C) --------------------------------------------------------
int __cdecl sub_100A768C(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_10166340;
    }
    else
    {
      v7 = &dword_10320BA0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100A398C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A77AC) --------------------------------------------------------
int __cdecl sub_100A77AC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_10166340;
    }
    else
    {
      v2 = &dword_10320BA0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_10166340) : (v4 = &dword_10320BA0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100A398C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A86EB) --------------------------------------------------------
signed int __cdecl sub_100A86EB(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_10320BA0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_102AC570 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 102AC570: using guessed type int dword_102AC570;
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A876C) --------------------------------------------------------
signed int __cdecl sub_100A876C(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_10320BA0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1009A5B5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A887D) --------------------------------------------------------
void __cdecl sub_100A887D(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_10320BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A8B7E) --------------------------------------------------------
int sub_100A8B7E()
{
  return flsall(1);
}
// 100A8AA4: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100A8B87) --------------------------------------------------------
int __cdecl sub_100A8B87(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_102ACF0C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_102ACF0C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_102ACF10 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_102ACF14 = _encode_pointer(v7);
    if ( sub_1009C295(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_102ACF1C = _encode_pointer(v8);
      if ( dword_102ACF1C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_102ACF18 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_102ACF18 == v23
    || dword_102ACF1C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_102ACF18),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_102ACF1C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_102ACF10 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_102ACF10);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_102ACF14 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_102ACF14);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1009C2CC(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_102ACF0C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1009A4B9: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1009C554: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1009C5C2: using guessed type int _encoded_null(void);
// 1009C5CB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 102ACF0C: using guessed type int dword_102ACF0C;
// 102ACF10: using guessed type int dword_102ACF10;
// 102ACF14: using guessed type int dword_102ACF14;
// 102ACF18: using guessed type int dword_102ACF18;
// 102ACF1C: using guessed type int dword_102ACF1C;

//----- (100A9991) --------------------------------------------------------
signed int __cdecl sub_100A9991(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_100A876C(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_10320BA0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_10320BA0[0] + 68) & 1)
    && (v1 = sub_100A876C(2), sub_100A876C(1) == v1)
    || (v2 = (void *)sub_100A876C(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_100A86EB(a1);
  *(_BYTE *)(dword_10320BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10098D80: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10320BA0: using guessed type int dword_10320BA0[];

//----- (100A9B70) --------------------------------------------------------
signed int __cdecl sub_100A9B70(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_100A9BF0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_100AAB10(v4, a4, 0) == a4 )
      result = sub_100AAAB0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100A9BD0) --------------------------------------------------------
signed int __cdecl sub_100A9BD0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_100A9BF0(a1);
  return sub_100AAB10(v3, a2, a3);
}

//----- (100A9BF0) --------------------------------------------------------
unsigned int __cdecl sub_100A9BF0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (100A9C10) --------------------------------------------------------
bool __cdecl sub_100A9C10(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (100A9CE0) --------------------------------------------------------
int __cdecl sub_100A9CE0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (100A9D00) --------------------------------------------------------
int __cdecl sub_100A9D00(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_100A9CE0(a1 + 20);
  return result;
}

//----- (100A9D40) --------------------------------------------------------
signed int __cdecl sub_100A9D40(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1008C530(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1008C530(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (100A9E00) --------------------------------------------------------
int __cdecl sub_100A9E00(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100A9E40) --------------------------------------------------------
int __usercall sub_100A9E40@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_100AE870(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1008C610(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1008C630(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100A9EF0) --------------------------------------------------------
signed int __usercall sub_100A9EF0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1008C660(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100AECC0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_100A9D40(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1008C530(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1008C530(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100AEB90(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1008C660(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1008C660(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (100AA0C0) --------------------------------------------------------
char __usercall sub_100AA0C0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_100AE820(a2, a3, a1 + 212);
}

//----- (100AA0D0) --------------------------------------------------------
int __usercall sub_100AA0D0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_100A9E40(result + 148, result);
  return result;
}

//----- (100AA0F0) --------------------------------------------------------
char __usercall sub_100AA0F0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100AA110) --------------------------------------------------------
int __usercall sub_100AA110@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10095F60(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10095F60(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (100AA150) --------------------------------------------------------
int __fastcall sub_100AA150(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (100AA170) --------------------------------------------------------
int __usercall sub_100AA170@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1008C6B0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1008C630(v4, v3, 0);
}
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100AA1B0) --------------------------------------------------------
signed int __usercall sub_100AA1B0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_100AA150(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10095F80(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_100AA0C0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_100B0A70(a2 + 28, 4);
      else
        v22 = sub_100B0A70(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_100AA0C0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100AA3C0) --------------------------------------------------------
int __cdecl sub_100AA3C0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100AA0D0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10051BD0(&v23);
    sub_10073990((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_100A9D00(v1, (int)&v24);
  v13 = sub_1008C610(v31);
  if ( v3 == v31 )
  {
    result = sub_1008C480(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1008C6B0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1008C480(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1008C6B0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_100A9CE0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_100AA170(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1008C610(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 1008C650: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100AA630) --------------------------------------------------------
signed int __cdecl sub_100AA630(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1008C6B0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_100AA1B0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100AA6D0) --------------------------------------------------------
int __usercall sub_100AA6D0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100AA0F0(a1);
  *v3 ^= v2;
  return sub_100AA110(v1, *v3);
}

//----- (100AA6F0) --------------------------------------------------------
int __usercall sub_100AA6F0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_100AA6D0(a2);
  return result;
}

//----- (100AA720) --------------------------------------------------------
signed int __usercall sub_100AA720@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100AA110(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1008C530(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (100AA810) --------------------------------------------------------
char __usercall sub_100AA810@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_100AE7D0(a1, a2, a3 + 212);
  else
    result = sub_100AA6F0(a2, a3 + 148);
  return result;
}

//----- (100AA840) --------------------------------------------------------
signed int __usercall sub_100AA840@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_100A9EF0(v3, v1);
  else
    result = sub_100AA720(v3, v1);
  return result;
}

//----- (100AA870) --------------------------------------------------------
signed int __cdecl sub_100AA870(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_100A9E00(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_100B24E0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100AA840(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100AA8C0) --------------------------------------------------------
signed int __cdecl sub_100AA8C0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1008C530(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_100AA810(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1008C530(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_100AE870(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_100AA150(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_100B38A0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10095F80(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10095F80(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (100AAAB0) --------------------------------------------------------
signed int __cdecl sub_100AAAB0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_100AA8C0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_100A9C10(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100AAB10) --------------------------------------------------------
signed int __cdecl sub_100AAB10(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100AA870(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_100A9E00(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100AA870(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_100AAAB0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (100AACA0) --------------------------------------------------------
signed int __usercall sub_100AACA0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_10160F50[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_10160350[2 * (unsigned __int8)v68] ^ dword_10160750[2 * BYTE1(v65)] ^ dword_10160B50[2 * (unsigned __int8)(v66 >> 16)] ^ dword_10160F50[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_10160F50[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_10160F50[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_10160F50[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_10160F50[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_10160F50[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_10160F50[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_10160F50[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_10160F50[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_10161350[(unsigned __int8)v57] ^ dword_10161F50[v58 >> 24] ^ dword_10161750[BYTE1(v59)] ^ dword_10161B50[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_10161350[(unsigned __int8)v59] ^ dword_10161B50[(unsigned __int8)(v58 >> 16)] ^ dword_10161F50[v57 >> 24] ^ dword_10161750[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_10161350[(unsigned __int8)v60] ^ dword_10161750[BYTE1(v58)] ^ dword_10161B50[(unsigned __int8)(v57 >> 16)] ^ dword_10161F50[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_10161350[(unsigned __int8)v58] ^ dword_10161750[BYTE1(v57)] ^ dword_10161B50[(unsigned __int8)(v59 >> 16)] ^ dword_10161F50[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10160F50[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_10160F50[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10160F50[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10160F50[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10160F50[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10160350[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10160750[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10160B50[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10160F50[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 10161350: using guessed type int dword_10161350[];
// 10161750: using guessed type int dword_10161750[];
// 10161B50: using guessed type int dword_10161B50[];
// 10161F50: using guessed type int dword_10161F50[];

//----- (100ABD50) --------------------------------------------------------
int __usercall sub_100ABD50@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_100AACA0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (100ABDB0) --------------------------------------------------------
signed int __usercall sub_100ABDB0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_10161F50[(unsigned __int8)v9] ^ dword_10161350[BYTE1(v9)] ^ dword_10161750[(unsigned __int8)(v9 >> 16)] ^ dword_10161B50[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_10161F50[(unsigned __int8)v129] ^ dword_10161350[BYTE1(v129)] ^ dword_10161750[(unsigned __int8)(v129 >> 16)] ^ dword_10161B50[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_10161F50[(unsigned __int8)v133] ^ dword_10161350[BYTE1(v133)] ^ dword_10161750[(unsigned __int8)(v133 >> 16)] ^ dword_10161B50[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_10161F50[(unsigned __int8)v137] ^ dword_10161350[BYTE1(v137)] ^ dword_10161750[(unsigned __int8)(v137 >> 16)] ^ dword_10161B50[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_10161F50[(unsigned __int8)v141] ^ dword_10161350[BYTE1(v141)] ^ dword_10161750[(unsigned __int8)(v141 >> 16)] ^ dword_10161B50[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_10161F50[(unsigned __int8)v145] ^ dword_10161350[BYTE1(v145)] ^ dword_10161750[(unsigned __int8)(v145 >> 16)] ^ dword_10161B50[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_10161F50[(unsigned __int8)v149] ^ dword_10161350[BYTE1(v149)] ^ dword_10161750[(unsigned __int8)(v149 >> 16)] ^ dword_10161B50[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_10161F50[(unsigned __int8)v153] ^ dword_10161350[BYTE1(v153)] ^ dword_10161750[(unsigned __int8)(v153 >> 16)] ^ dword_10161B50[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_10161F50[(unsigned __int8)v157] ^ dword_10161350[BYTE1(v157)] ^ dword_10161750[(unsigned __int8)(v157 >> 16)] ^ dword_10161B50[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_10161F50[(unsigned __int8)v161] ^ dword_10161350[BYTE1(v161)] ^ dword_10161750[(unsigned __int8)(v161 >> 16)] ^ dword_10161B50[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_10161F50[(unsigned __int8)v77] ^ dword_10161350[BYTE1(v77)] ^ dword_10161750[(unsigned __int8)(v77 >> 16)] ^ dword_10161B50[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_10161F50[(unsigned __int8)v82] ^ dword_10161350[BYTE1(v82)] ^ dword_10161750[(unsigned __int8)(v82 >> 16)] ^ dword_10161B50[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_10161F50[(unsigned __int8)v89] ^ dword_10161350[BYTE1(v89)] ^ dword_10161750[(unsigned __int8)(v89 >> 16)] ^ dword_10161B50[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_10161F50[(unsigned __int8)v94] ^ dword_10161350[BYTE1(v94)] ^ dword_10161750[(unsigned __int8)(v94 >> 16)] ^ dword_10161B50[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_10161F50[(unsigned __int8)v100] ^ dword_10161350[BYTE1(v100)] ^ dword_10161750[(unsigned __int8)(v100 >> 16)] ^ dword_10161B50[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_10161F50[(unsigned __int8)v100] ^ dword_10161350[BYTE1(v100)] ^ dword_10161750[(unsigned __int8)(v100 >> 16)] ^ dword_10161B50[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_10161F50[(unsigned __int8)v108] ^ dword_10161350[BYTE1(v108)] ^ dword_10161750[(unsigned __int8)(v108 >> 16)] ^ dword_10161B50[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_10161F50[(unsigned __int8)v114] ^ dword_10161350[BYTE1(v114)] ^ dword_10161750[(unsigned __int8)(v114 >> 16)] ^ dword_10161B50[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_10161F50[(unsigned __int8)v120] ^ dword_10161350[BYTE1(v120)] ^ dword_10161750[(unsigned __int8)(v120 >> 16)] ^ dword_10161B50[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_10161F50[(unsigned __int8)v19] ^ dword_10161350[BYTE1(v19)] ^ dword_10161750[(unsigned __int8)(v19 >> 16)] ^ dword_10161B50[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_10161350[(unsigned __int8)v23] ^ dword_10161750[BYTE1(v23)] ^ dword_10161B50[(unsigned __int8)(v23 >> 16)] ^ dword_10161F50[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_10161F50[(unsigned __int8)v26] ^ dword_10161350[BYTE1(v26)] ^ dword_10161750[(unsigned __int8)(v26 >> 16)] ^ dword_10161B50[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_10161350[(unsigned __int8)v31] ^ dword_10161750[BYTE1(v31)] ^ dword_10161B50[(unsigned __int8)(v31 >> 16)] ^ dword_10161F50[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_10161F50[(unsigned __int8)v35] ^ dword_10161350[BYTE1(v35)] ^ dword_10161750[(unsigned __int8)(v35 >> 16)] ^ dword_10161B50[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_10161350[(unsigned __int8)v41] ^ dword_10161750[BYTE1(v41)] ^ dword_10161B50[(unsigned __int8)(v41 >> 16)] ^ dword_10161F50[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_10161F50[(unsigned __int8)v43] ^ dword_10161350[BYTE1(v43)] ^ dword_10161750[(unsigned __int8)(v43 >> 16)] ^ dword_10161B50[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_10161350[(unsigned __int8)v47] ^ dword_10161750[BYTE1(v47)] ^ dword_10161B50[(unsigned __int8)(v47 >> 16)] ^ dword_10161F50[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_10161F50[(unsigned __int8)v52] ^ dword_10161350[BYTE1(v52)] ^ dword_10161750[(unsigned __int8)(v52 >> 16)] ^ dword_10161B50[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_10161350[(unsigned __int8)v58] ^ dword_10161750[BYTE1(v58)] ^ dword_10161B50[(unsigned __int8)(v58 >> 16)] ^ dword_10161F50[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_10161F50[(unsigned __int8)v60] ^ dword_10161350[BYTE1(v60)] ^ dword_10161750[(unsigned __int8)(v60 >> 16)] ^ dword_10161B50[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_10161350[(unsigned __int8)v66] ^ dword_10161750[BYTE1(v66)] ^ dword_10161B50[(unsigned __int8)(v66 >> 16)] ^ dword_10161F50[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_10161F50[(unsigned __int8)v69] ^ dword_10161350[BYTE1(v69)] ^ dword_10161750[(unsigned __int8)(v69 >> 16)] ^ dword_10161B50[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 10161350: using guessed type int dword_10161350[];
// 10161750: using guessed type int dword_10161750[];
// 10161B50: using guessed type int dword_10161B50[];
// 10161F50: using guessed type int dword_10161F50[];

//----- (100ACB30) --------------------------------------------------------
void *__usercall sub_100ACB30@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (100ACB50) --------------------------------------------------------
unsigned int __cdecl sub_100ACB50(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_1008C780();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 1008C7D0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (100ACBB0) --------------------------------------------------------
int __usercall sub_100ACBB0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100ACBF0) --------------------------------------------------------
int __usercall sub_100ACBF0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (100AE310) --------------------------------------------------------
unsigned int __usercall sub_100AE310@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_10162378[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_10162388[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100ACBF0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100ACBF0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 10162378: using guessed type int dword_10162378[];
// 10162388: using guessed type int dword_10162388[];

//----- (100AE410) --------------------------------------------------------
void *__usercall sub_100AE410@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100ACBF0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (100AE490) --------------------------------------------------------
void *__usercall sub_100AE490@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_100AE310(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_100ACBB0(v3 + 64);
    result = sub_100AE410(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_100AE410(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (100AE530) --------------------------------------------------------
int __usercall sub_100AE530@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_100AE490(a1, 0, 0);
  sub_100AE310(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_100ACBB0(a1 + 64);
  sub_100AE410(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_100AE410(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_100AE310(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (100AE5F0) --------------------------------------------------------
int __usercall sub_100AE5F0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_100ACBB0(a2 + 64);
    sub_100AE410(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_100AE410(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (100AE650) --------------------------------------------------------
int __usercall sub_100AE650@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_100ACBF0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 100AE650: using guessed type char var_40[64];

//----- (100AE710) --------------------------------------------------------
int __usercall sub_100AE710@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_100AE650((char *)a1);
  return sub_100AE650(v8);
}

//----- (100AE7D0) --------------------------------------------------------
char __cdecl sub_100AE7D0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_100AE490(a3 + 296, a2, a1);
    sub_100ABD50(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100AE820) --------------------------------------------------------
char __cdecl sub_100AE820(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_100ABD50(a3, (int)a1, a2);
    sub_100AE490(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100AE870) --------------------------------------------------------
bool __cdecl sub_100AE870(int a1, int a2)
{
  if ( a2 )
    sub_100AE530(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (100AE8A0) --------------------------------------------------------
int __usercall sub_100AE8A0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_100ACB30(&v24);
  sub_100AE5F0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_100AE490((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_100AE490((int)&v23, v12, (char *)&v31);
          sub_100AE530((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 100AE8A0: using guessed type char var_14[16];

//----- (100AEAB0) --------------------------------------------------------
int __usercall sub_100AEAB0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_100AE710(v2);
  v3 = 20;
  do
  {
    sub_100AE650((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_100AE710(v2);
}

//----- (100AEB00) --------------------------------------------------------
char *__cdecl sub_100AEB00(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_100AE710(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100AEB90) --------------------------------------------------------
signed int __cdecl sub_100AEB90(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_100AE8A0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_100ABDB0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_100ACB30((void *)(a6 + 296));
      sub_100AE5F0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100AEB90: using guessed type char var_40[8];
// 100AEB90: using guessed type __int16 var_38[26];

//----- (100AECC0) --------------------------------------------------------
bool __cdecl sub_100AECC0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_100AEAB0(&v4, (int)sub_100ACB50);
  if ( v2 )
    sub_100AEB00(a2, (int)&v4);
  return v2;
}

//----- (100AED40) --------------------------------------------------------
BOOL __usercall sub_100AED40@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_10162B90[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_10162A90[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_10162990[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (100AEDE0) --------------------------------------------------------
int __usercall sub_100AEDE0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (100AEE70) --------------------------------------------------------
unsigned int __fastcall sub_100AEE70(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100AEE90) --------------------------------------------------------
int __usercall sub_100AEE90@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (100AEF20) --------------------------------------------------------
int __usercall sub_100AEF20@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_10162B90[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_10162B90[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_10162398[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_10162C90[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_10162A90[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_10162990[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_10162420[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_10162D08[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 10162398: using guessed type int dword_10162398[];
// 10162420: using guessed type int dword_10162420[];
// 10162C90: using guessed type int dword_10162C90[];
// 10162D08: using guessed type int dword_10162D08[];

//----- (100AF3A0) --------------------------------------------------------
int __usercall sub_100AF3A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100AEE90(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (100AF450) --------------------------------------------------------
void *__usercall sub_100AF450@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (100AF4B0) --------------------------------------------------------
int __usercall sub_100AF4B0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (100AF680) --------------------------------------------------------
signed int __usercall sub_100AF680@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_100AEE70(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (100AF700) --------------------------------------------------------
_WORD *__fastcall sub_100AF700(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (100AF770) --------------------------------------------------------
unsigned int __usercall sub_100AF770@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (100AF920) --------------------------------------------------------
unsigned int __usercall sub_100AF920@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (100AF9F0) --------------------------------------------------------
int __usercall sub_100AF9F0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (100AFAA0) --------------------------------------------------------
int __usercall sub_100AFAA0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (100AFAE0) --------------------------------------------------------
unsigned int __usercall sub_100AFAE0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_100B18B0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100AFB40) --------------------------------------------------------
signed int __usercall sub_100AFB40@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (100AFC20) --------------------------------------------------------
int __usercall sub_100AFC20@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (100B01C0) --------------------------------------------------------
int __usercall sub_100B01C0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_100AEDE0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_100AEDE0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_100AEDE0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (100B0400) --------------------------------------------------------
int __usercall sub_100B0400@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_100AF3A0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_100AF3A0(a1, a3, a4);
  }
  return result;
}

//----- (100B04A0) --------------------------------------------------------
signed int __usercall sub_100B04A0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_100AF9F0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_100AF9F0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_100AF9F0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_100AF4B0(a1, a2);
  return sub_100AF680(a1, v16, v5);
}

//----- (100B0680) --------------------------------------------------------
unsigned int __usercall sub_100B0680@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_100AFAE0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (100B07C0) --------------------------------------------------------
int __usercall sub_100B07C0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_1016240C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_100AFC20(a1, a1 + 2936, a2 - 1);
  return sub_100AFC20(v24, v24 + 5228, a3 - 1);
}

//----- (100B0A70) --------------------------------------------------------
signed int __cdecl sub_100B0A70(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_100AFAA0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_100AFAA0(v9, *(_WORD *)(a1 + 30));
      sub_100AFAA0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_100B18B0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_100AF450(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_10162D88 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_100B01C0(v2);
    }
    else
    {
      sub_100B0400(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_100AF450(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_100AFAA0(v2, *(_WORD *)(a1 + 30));
    sub_100AFAA0(v13, *(_WORD *)(a1 + 28));
    sub_100AF450(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10162D88: using guessed type int (__cdecl *off_10162D88)(int, int);

//----- (100B0D30) --------------------------------------------------------
signed int __usercall sub_100B0D30@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_100AFB40(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_100AFB40(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_100B04A0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_1016240C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1016240B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1016240A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10162409[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (100B0E00) --------------------------------------------------------
_WORD *__usercall sub_100B0E00@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_100B04A0(a2, a2 + 5628);
  sub_100B04A0(v4, v4 + 5640);
  v8 = sub_100B0D30(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_100B0400(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_100AEF20(v4, (int)&unk_10162498, (int)&unk_10162918);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_100B07C0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_100AEF20(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_100AF700(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100AEE90(v4);
  return result;
}

//----- (100B1020) --------------------------------------------------------
signed int __cdecl sub_100B1020(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100B0680(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_100AF770(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_100AF920(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_100AED40(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_100AED40(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_100B0E00(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_100AF450(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_100B0E00(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100AF450(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100B1330) --------------------------------------------------------
signed int __cdecl sub_100B1330(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100B0680(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_100AF770(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_100AF920(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_100AED40(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_100B0E00(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_100AF450(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_100AED40(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_100B0E00(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_100AF450(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_100AED40(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_100B0E00(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100AF450(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (100B1740) --------------------------------------------------------
signed int __cdecl sub_100B1740(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_100B0680(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_100B0E00(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_100AF450(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_100B0E00(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_100AF450(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_100B0E00(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_100AF450(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100B18B0) --------------------------------------------------------
int __cdecl sub_100B18B0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (100B19B0) --------------------------------------------------------
signed int __cdecl sub_100B19B0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100B19D0) --------------------------------------------------------
signed int __usercall sub_100B19D0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 100B19D0: using guessed type int var_78[14];
// 100B19D0: using guessed type int var_3C[15];

//----- (100B1E70) --------------------------------------------------------
int (__cdecl *__usercall sub_100B1E70@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (100B1EC0) --------------------------------------------------------
int __usercall sub_100B1EC0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (100B1EE0) --------------------------------------------------------
signed int __cdecl sub_100B1EE0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_10162F70[a1];
  v51 = dword_10162F70[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_10162F70[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_10162F70[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_10162F70[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_10162F70[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 10162F70: using guessed type int dword_10162F70[];

//----- (100B2290) --------------------------------------------------------
int __usercall sub_100B2290@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (100B23D0) --------------------------------------------------------
signed int __usercall sub_100B23D0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_100B19D0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (100B2420) --------------------------------------------------------
signed int __usercall sub_100B2420@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_100B19D0(a7, a6, a4, 257, (int)&unk_10163008, (int)&unk_10163088, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_100B19D0(a8, &a6[a4], a5, 0, (int)&unk_10163108, (int)&unk_10163180, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100B24C0) --------------------------------------------------------
int __usercall sub_100B24C0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_101631F8;
  *a4 = &unk_101641F8;
  return 0;
}

//----- (100B24E0) --------------------------------------------------------
signed int __cdecl sub_100B24E0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_100B1E70(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100B24F0) --------------------------------------------------------
int __usercall sub_100B24F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_100B1EE0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_10162F70[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_10162F70[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_10162F70[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_10162F70[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_100B2290(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_100B2290(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_100B2290(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_100B2290(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 10162F70: using guessed type int dword_10162F70[];

//----- (100B2B90) --------------------------------------------------------
int __usercall sub_100B2B90@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_100B24C0(&v67, &v69, &v66, &v68);
          sub_100B1EC0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_100B2290(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_10162FB8[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_10162FB8[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_100B23D0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_100B2420(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_100B1EC0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_100B24F0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_100B2290(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_100B2290(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_100B2290(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_10162F70[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_10162F70[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_100B2290(v7, v3, v58);
}
// 10162F70: using guessed type int dword_10162F70[];
// 10162FB8: using guessed type int dword_10162FB8[];

//----- (100B3570) --------------------------------------------------------
signed int __usercall sub_100B3570@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_100B2B90(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_100B1E70((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (100B38A0) --------------------------------------------------------
signed int __cdecl sub_100B38A0(int a1, int a2)
{
  return sub_100B3570(a1, a2);
}

#error "There were 52 decompilation failure(s) on 1952 function(s)"
