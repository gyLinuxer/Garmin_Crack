/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012C0(int a1, int a2);
int sub_100014A0(void); // weak
signed int sub_100014B0();
int __cdecl sub_10001510(int a1);
signed int sub_10001540();
int __cdecl sub_10001560(int a1, char *a2, int a3, int a4);
char __cdecl sub_100015F0(int a1, int a2, int a3);
char __cdecl sub_10001660(int a1, int a2, int a3);
int sub_100016D0();
_DWORD *__cdecl sub_100016F0(int a1);
// void __usercall sub_10001710(int a1@<esi>);
// int __usercall sub_10001740@<eax>(int a1@<esi>);
// void __usercall sub_10001820(int a1@<esi>, int a2);
// void __usercall sub_100018F0(int a1@<esi>, int a2);
// int __usercall sub_10001990@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001B60(int this);
signed int __cdecl sub_10001B80(int a1, int a2);
char __cdecl sub_10001CD0(int a1, int a2, __int16 a3);
char __cdecl sub_10001D00(int a1, int a2, __int16 a3);
char __cdecl sub_10001D30(int a1);
// int __usercall sub_10002060@<eax>(int a1@<eax>);
void __noreturn sub_100020F0();
char __cdecl sub_10002330(char a1, char *a2);
int __cdecl sub_100023A0(char, void *); // idb
int __cdecl sub_10002440(char a1, char a2);
int __cdecl sub_100024A0(char a1, char a2);
int __cdecl sub_100024F0(int a1, int a2);
char __cdecl sub_10002510(int a1, unsigned int a2);
char sub_10002550();
char __thiscall sub_10002570(int this);
int __cdecl sub_100026E0(int a1);
char __cdecl sub_10002830(int a1);
int __cdecl sub_10002850(int a1, int a2);
int __cdecl sub_100028D0(int a1, __int16 a2, __int16 a3);
_WORD *__cdecl sub_100028F0(int a1);
char sub_10002960();
BOOL __thiscall sub_100029A0(void *this);
// char __usercall sub_100029D0@<al>(int a1@<esi>);
// int __usercall sub_10002A10@<eax>(int a1@<esi>);
// _WORD *__usercall sub_10002A40@<eax>(int a1@<esi>);
int __cdecl sub_10002AA0(int a1);
// char __usercall sub_10002AC0@<al>(int a1@<edi>);
// int __usercall sub_10003040@<eax>(int a1@<esi>);
// int __usercall sub_10003080@<eax>(int a1@<ebx>);
// signed int __usercall sub_100031E0@<eax>(int a1@<eax>);
// bool __usercall sub_10003260@<al>(void *a1@<ecx>, int a2@<edi>);
// int __usercall sub_10003300@<eax>(int a1@<eax>);
// char __usercall sub_100033E0@<al>(int a1@<edi>);
char __cdecl sub_10003520(int a1);
int sub_100036C0(void); // weak
char __cdecl sub_100036D0(char a1);
char sub_100036F0();
int __cdecl sub_10003700(int a1);
char sub_10003740();
int __cdecl sub_10003750(int a1);
char __cdecl sub_10003770(int a1);
int sub_100037E0(void); // weak
int __cdecl nullsub_1(_DWORD, _DWORD);
_DWORD sub_10003800(); // weak
int __cdecl sub_10003880(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_100038D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_10003920();
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10003970(float, float, float, float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_100039D0(int a1, char *a2, int a3, char *a4, int a5);
char sub_10003B00();
char __cdecl sub_10003B10(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10003C10(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10003C80(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10003CC0();
int __cdecl sub_10003D10(int a1);
int __cdecl sub_10003D20(int a1);
int sub_10003D40();
int __cdecl sub_10003D60(int a1, int a2);
__int16 __cdecl sub_10003D90(int a1);
int sub_10003DB0();
int __cdecl sub_10003DD0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10003E10(int a1, int a2, int a3, int a4);
int __cdecl sub_10003E40(int a1);
int __cdecl sub_10003E60(int a1);
int __cdecl sub_10003E80(int a1, int a2);
int __cdecl sub_10003EB0(int a1, int a2);
int __cdecl sub_10003EE0(int a1, int a2, int a3, int a4);
int __cdecl sub_10003F10(int a1, int a2);
int __cdecl sub_10003F40(int a1);
int __cdecl sub_10003F60(int a1);
char __cdecl sub_10003F80(int a1, int a2);
int __cdecl sub_10003FF0(_BYTE *a1);
int __cdecl sub_10004030(int a1, int a2);
int __cdecl sub_10004060(int a1, int a2);
int __cdecl sub_10004080(int a1);
int __cdecl sub_100040C0(int a1, int a2, int a3);
char __cdecl sub_100040E0(int a1, int a2, int a3);
int __cdecl sub_10004120(int, void *, int, void *); // idb
int __cdecl sub_10004160(int a1, int a2, int a3);
int __cdecl sub_10004190(int a1, int a2, int a3);
int __cdecl sub_100041B0(int a1, int a2, int a3);
int __cdecl sub_10004210(int a1, int a2, int a3);
int __cdecl sub_10004250(int, void *, int, void *); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_100042B0(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_10004310(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10004380(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_100043C0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10004450(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_100044A0(int a1);
int __cdecl sub_100044C0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100044F0(int a1, int a2, int a3, char a4);
char __cdecl sub_10004510(int a1);
signed int __cdecl sub_10004540(unsigned int a1, int a2, int a3);
int __cdecl sub_10004560(int a1, int a2, int a3);
void __cdecl sub_10004580(int a1, _BYTE *a2);
int __cdecl sub_100045B0(int a1, int a2);
int sub_100045D0(void); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_keys(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int sub_10004630(void); // weak
unsigned int __cdecl sub_10004640(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_100047F0@<eax>(int a1@<esi>);
int __cdecl sub_100048A0(int a1, unsigned __int64 a2);
// int __usercall sub_10004950@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_100049E0(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10004B30(__int16 a1, _BYTE *a2);
int __cdecl sub_10004B60(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_10004C70(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_10004D50(int a1);
int __cdecl sub_100050A0(int a1);
unsigned int __cdecl sub_10005280(int a1);
int __cdecl sub_100057B0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_10005810(int a1);
int __cdecl sub_10005870(int a1, int a2, char a3);
void sub_10005960();
int __cdecl sub_10005970(int a1, _BYTE *a2, int a3);
char __cdecl sub_100059B0(char a1, char a2);
int __cdecl sub_100059D0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_10006210(_BYTE *a1);
bool __cdecl sub_100062B0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_100063C0(int a1, _BYTE *a2, int a3);
int __cdecl sub_100064B0(int a1);
int __cdecl sub_10006680(int a1, signed int a2, signed int a3);
int __cdecl sub_10006B50(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_10006C40(int a1);
char *__cdecl sub_10006DB0(int a1);
int __cdecl sub_10006F00(int a1, int a2);
unsigned int __cdecl sub_10007020(int a1, int a2);
int __cdecl sub_100071C0(int a1, int a2, int a3);
int __cdecl sub_10007240(int a1, int a2, int a3);
char __cdecl sub_100072C0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100073D0(int a1, signed int a2, signed int a3);
int __cdecl sub_100074C0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_100075C0(int a1, int a2);
char *__cdecl sub_100076F0(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10007830(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_10007A80(int a1, signed int a2, int a3);
int __cdecl sub_10007BC0(int a1, signed int a2, int a3);
int __cdecl sub_10007D00(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10007D20(unsigned int *a1, signed int a2, unsigned int a3);
int __cdecl sub_10007E50(int a1, int a2, const char *a3);
int sub_10007EE0();
int __cdecl sub_10007F80(int a1, int a2, int a3);
int __cdecl sub_10008000(int a1);
int __cdecl sub_10008060(int a1, int a2);
int __cdecl sub_10008080(int a1, int a2, int a3);
int __cdecl sub_100080E0(int a1);
_DWORD __cdecl sub_10008100(char, char, __int16, __int16, __int16, __int16); // weak
// BOOL __usercall sub_10008110@<eax>(int a1@<eax>);
// char __usercall sub_10008140@<al>(int a1@<ebx>, int a2@<edi>);
// char __usercall sub_10008260@<al>(unsigned __int8 a1@<al>, int a2@<edi>, int a3, unsigned __int8 a4, char a5);
// char __usercall sub_100083B0@<al>(char result@<al>, int a2@<ecx>);
// int __usercall sub_100083C0@<eax>(int a1@<eax>);
// int __usercall sub_10008410@<eax>(int a1@<esi>);
// unsigned __int8 __usercall sub_10008570@<al>(unsigned int a1@<edi>, int a2@<esi>);
// int __usercall sub_10008620@<eax>(int a1@<eax>);
// char __usercall sub_10008870@<al>(int a1@<esi>);
// int __usercall sub_100089D0@<eax>(int a1@<esi>);
// char __usercall sub_10008A30@<al>(int a1@<esi>);
// int __usercall sub_10008AF0@<eax>(int a1@<esi>);
// int __usercall sub_10008B60@<eax>(int a1@<esi>);
int __thiscall sub_10008BD0(int this);
int __thiscall sub_10008C70(int this);
// int __usercall sub_10008D20@<eax>(int a1@<esi>);
// int __usercall sub_10008D90@<eax>(int a1@<esi>);
// int __usercall sub_10008E00@<eax>(unsigned int a1@<eax>, int a2, char a3);
// int __usercall sub_10008EE0@<eax>(int a1@<eax>, int a2);
int __cdecl sub_10009050(int, double, int); // idb
// int __usercall sub_100094E0@<eax>(int a1@<esi>, int a2, double a3, int a4, int a5);
int sub_100095D0(); // weak
// int __usercall sub_100095F0@<eax>(char *a1@<esi>, const char *a2);
int __thiscall sub_100096B0(void *this);
// char __usercall sub_10009720@<al>(int a1@<eax>, char a2@<cl>);
// int __usercall sub_10009790@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, char a4);
int __cdecl sub_100098A0(int a1, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_10009970(int a1, int a2, int a3, _BYTE *a4);
int __cdecl sub_10009AA0(int a1);
// char __usercall sub_1000A170@<al>(int a1@<esi>);
// char __usercall sub_1000A1E0@<al>(int a1@<eax>);
char __thiscall sub_1000A3F0(int this);
char __cdecl sub_1000A640(int a1, int a2, int a3, char a4);
char __cdecl sub_1000A690(int a1, int a2, int a3, _BYTE *a4);
// char __usercall sub_1000A760@<al>(int a1@<ecx>, int a2@<ebp>);
char __cdecl sub_1000B0B0(int a1, int a2, _WORD *a3, int a4, int a5);
char __cdecl sub_1000B760(int a1, int a2, _WORD *a3, int a4, _WORD *a5);
// char __usercall sub_1000B860@<al>(_BYTE *a1@<ecx>, char a2@<bl>);
char sub_1000B900();
signed int __cdecl sub_1000B930(char a1, char a2, int a3);
char __cdecl sub_1000BA30(char a1, int a2);
char __cdecl sub_1000BB20(int a1, int a2, char a3);
int __cdecl sub_1000BC20(int, char, char *); // idb
void sub_1000BE10();
char __cdecl sub_1000BE20(char a1);
char __cdecl sub_1000BF10(_BYTE *a1, char a2, char a3, int a4);
signed int sub_1000C060();
int __cdecl sub_1000C070(int a1, int a2, int a3);
char __cdecl sub_1000C0F0(int a1, char a2, char a3, char a4, int a5);
int sub_1000C2E0(void); // weak
char __cdecl sub_1000C2F0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_1000C390(unsigned __int8 a1, char a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
signed int __cdecl sub_1000C550(int a1, int a2);
int __cdecl sub_1000C6E0(const char *a1, int a2, int a3);
signed int __cdecl sub_1000C7B0(char a1);
signed int __cdecl sub_1000C870(__int16 a1);
signed int __cdecl sub_1000C9C0(__int16 a1);
int __cdecl sub_1000CAB0(char a1);
char __cdecl sub_1000CB90(int a1, int a2, int *a3, int a4, int a5);
// int __usercall sub_1000CC00@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_1000CCE0(int a1, int a2, int a3, int a4, _WORD *a5);
bool __cdecl sub_1000D290(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// char __usercall sub_1000D390@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
int sub_1000D3E0();
int sub_1000D480();
void sub_1000D4E0();
signed int sub_1000D4F0();
void sub_1000D500();
double *__cdecl sub_1000D510(char a1, char a2, double *a3);
char __cdecl sub_1000D640(__int64 a1);
// char __usercall sub_1000D670@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3);
char __cdecl sub_1000D770(unsigned int a1, int a2);
char __cdecl sub_1000D790(unsigned int a1, int a2);
int __cdecl sub_1000D7B0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_1000D810(int a1, int a2);
char __cdecl sub_1000D880(unsigned __int8 a1, char *a2);
signed int __cdecl sub_1000D910(unsigned __int8 a1);
int __cdecl sub_1000D990(int, char, void *); // idb
char __cdecl sub_1000DA10(int a1, char a2);
char __cdecl sub_1000DA40(int a1, unsigned __int8 a2);
char __cdecl sub_1000DB90(unsigned __int8 a1, char a2);
char __cdecl sub_1000DBE0(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_1000DC20(unsigned __int8 a1);
signed int __cdecl sub_1000DC60(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_1000DCC0(int a1);
char __cdecl sub_1000DD00(unsigned __int8 a1);
int __cdecl sub_1000DD40(int a1);
// signed int __usercall sub_1000DD80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __thiscall sub_1000DDC0(int this);
// signed int __usercall sub_1000DE70@<eax>(int a1@<edi>);
signed int __thiscall sub_1000DF00(int this);
// int __usercall sub_1000DFA0@<eax>(int a1@<esi>);
// char __usercall sub_1000DFC0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_1000E080@<eax>(int a1@<eax>, char *a2@<esi>);
// int __usercall sub_1000E0E0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>);
// __int16 __usercall sub_1000E180@<ax>(int a1@<eax>, int a2@<esi>, int a3);
void *__cdecl sub_1000E2F0(unsigned int a1, char *a2);
signed int __cdecl sub_1000E340(unsigned __int8 a1);
// signed int __usercall sub_1000E3C0@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_1000E430(unsigned __int8 a1);
// int __usercall sub_1000E4A0@<eax>(int a1@<eax>, char a2);
// void __usercall sub_1000E530(int a1@<edi>, int a2, int a3);
__int16 __cdecl sub_1000E570(unsigned int a1, char a2, int a3);
char __cdecl sub_1000EA50(unsigned int a1);
int __cdecl sub_1000EAC0(__int64 a1);
char __cdecl sub_1000EB70(int a1, int a2);
__int16 __cdecl sub_1000EBE0(int a1, int a2);
signed int __cdecl sub_1000EC20(int a1, _WORD *a2, _BYTE *a3);
// char __usercall sub_1000ED20@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_1000ED80@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_1000EDA0(unsigned __int16 a1, int a2);
int __cdecl sub_1000EE30(unsigned __int16 a1, int a2);
int __cdecl sub_1000EEA0(unsigned __int16 a1, int a2);
signed int __cdecl sub_1000EF10(int a1, _WORD *a2, _BYTE *a3);
signed int __cdecl sub_1000EF60(int a1);
signed int __cdecl sub_1000EFC0(const char *a1);
char __cdecl sub_1000F100(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000F330(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
char __cdecl sub_1000F410(int a1, int a2);
signed int __cdecl sub_1000F580(const void *a1, _DWORD *a2, _BYTE *a3);
char sub_1000F680();
int __cdecl sub_1000F6E0(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1000F710(int a1, int a2);
void __cdecl sub_1000F870(_BYTE *a1, signed int a2, int a3);
unsigned int __cdecl sub_1000F910(unsigned int a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_1000F930(char, int, float, char, int); // idb
int __cdecl sub_1000FA00(unsigned __int8 a1);
int __fastcall sub_1000FA40(int a1, int a2);
char __cdecl sub_1000FA70(unsigned int a1, int a2);
// void __usercall sub_1000FB20(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_1000FB50(unsigned int a1, int a2);
unsigned __int8 __cdecl sub_1000FC70(unsigned int a1);
int __cdecl sub_1000FCA0(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1000FD20(unsigned int a1);
char __cdecl sub_1000FD50(__int64 a1);
double __cdecl sub_1000FDF0(unsigned int a1);
int sub_1000FE60();
char __cdecl sub_1000FF00(float *a1);
char __cdecl sub_100101C0(int a1, float *a2);
char *__cdecl sub_100101E0(unsigned __int8 a1);
signed int sub_100102A0();
int sub_100102C0();
int sub_10010320();
char *sub_10010390();
int __cdecl sub_10010460(const void *a1);
char __cdecl sub_10010510(unsigned int a1, int a2);
_DWORD __cdecl sub_10010580(_DWORD, _DWORD); // weak
int __cdecl sub_10010590(_BYTE *a1, _BYTE *a2);
int sub_100105C0();
int __fastcall sub_100105D0(unsigned __int8 a1);
int __fastcall sub_100105F0(unsigned __int8 a1);
void *__cdecl sub_10010610(char a1, void *a2);
int __cdecl sub_100106E0(int a1);
char sub_100108A0();
_DWORD *__cdecl sub_10010A00(_DWORD *a1);
int __cdecl sub_10010A10(int *a1, int a2);
_DWORD *__cdecl sub_10010A40(_DWORD *a1, int a2);
char __cdecl sub_10010A50(int a1, int a2, int a3);
char __cdecl sub_10010A80(int a1, _WORD *a2, int a3);
bool __cdecl sub_10010AB0(char *a1, int *a2, _DWORD *a3);
int __cdecl sub_10010B00(int a1, int a2, char *a3, int a4);
char __cdecl sub_10010B70(int a1, char *a2, int a3);
int __cdecl sub_10010C20(int a1);
char __thiscall sub_10010CA0(void *this);
int sub_10010CF0();
char __cdecl sub_10010D20(int a1);
int __cdecl sub_10010D40(int, char *); // idb
char __thiscall sub_10010DA0(void *this);
char __thiscall sub_10010DC0(void *this);
int __thiscall sub_10010DE0(void *this);
int __cdecl sub_10010E00(char *); // idb
char __thiscall sub_10010E10(void *this);
char __thiscall sub_10010E30(void *this);
char sub_10010E50();
int __cdecl sub_10010E70(char a1);
void __cdecl sub_10010E80(unsigned __int8 a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6);
char __cdecl sub_10010F00(char a1);
char __cdecl sub_10010F40(char a1);
signed int __cdecl sub_10010FB0(char a1);
char __cdecl sub_10011030(char a1);
char __cdecl sub_100110A0(char a1);
char __cdecl sub_10011150(int a1);
char __thiscall sub_10011250(void *this);
int __cdecl sub_10011260(int *a1);
// char __usercall sub_10011290@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10011330(const char *a1);
char __cdecl sub_10011370(void *a1);
signed int __cdecl sub_100113C0(unsigned int a1, int a2);
char **sub_10011760();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10011780(int a1);
int __cdecl sub_10011790(int a1);
int sub_100117A0(void); // weak
int __cdecl sub_100117D0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_10011960(_BYTE *a1, unsigned int a2, char a3);
void __cdecl sub_10011BA0(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_10011C30(int a1, _BYTE *a2, int a3);
int __cdecl sub_10011C80(void *, size_t); // idb
void __cdecl sub_10011CB0(const char *a1, int a2, int (__cdecl *a3)(int, int), int a4);
int __cdecl sub_10011D30(int, char *, int); // idb
int __cdecl sub_10011D90(char *, size_t, char *, va_list); // idb
int sub_10011DD0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_10011E00(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_10011E40(int a1, int a2);
char __cdecl sub_10011E60(unsigned __int8 a1);
int __cdecl sub_10011EA0(char *, char *); // idb
// void *__usercall sub_10011EE0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10011F30();
int __cdecl sub_10013D30(int a1);
int __cdecl sub_10013D60(int a1);
_DWORD *sub_10013D90();
int sub_10013DA0();
BOOL __cdecl sub_10013DC0(unsigned int a1);
char __thiscall sub_10013E30(void *this);
void __cdecl sub_10013E50(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_10013E80(int a1);
signed int sub_10013EA0();
void __cdecl sub_10013ED0(_BYTE *a1);
char __cdecl sub_10013EF0(int a1, size_t a2, void *a3);
int __cdecl sub_10013F30(int a1);
char __fastcall sub_10013F50(int *a1);
char sub_10014170();
int __cdecl sub_10014190(double, double); // idb
void sub_100141E0();
signed int sub_100141F0();
bool __cdecl sub_10014200(char a1, int a2);
void sub_10014420();
signed int __cdecl sub_10014430(_DWORD *a1);
int __cdecl sub_10014450(char a1);
signed int sub_10014470();
// signed int __usercall sub_100144C0@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10014560@<eax>(char a1@<al>);
// int __usercall sub_10014580@<eax>(char a1@<al>);
// signed __int16 __usercall sub_100145A0@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_100147E0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10014960(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10014AC0(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10014C00(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10014CE0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10014F60(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10014F90(char a1, int a2, void *a3);
char __cdecl sub_10014FC0(char a1, int a2, void *a3, int a4);
signed int sub_10015000();
int sub_10015020();
char __cdecl sub_10015030(char *a1);
signed int __cdecl sub_100150A0(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10015100(unsigned int a1, int a2, int a3);
int __cdecl sub_10015120(unsigned __int8 *a1, int a2);
int __cdecl sub_10015150(int a1, signed int a2, signed int a3);
int __cdecl sub_10015170(int, double, double); // idb
int __cdecl sub_10015250(int, float, float); // idb
signed int __cdecl sub_10015340(int a1);
double __cdecl sub_10015360(signed int a1, char a2);
bool __cdecl sub_100153A0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_100153E0(unsigned __int16 a1);
char __thiscall sub_10015410(void *this);
char sub_10015440();
int __thiscall sub_100154C0(void *this);
char __cdecl sub_100154E0(char a1);
BOOL sub_10015560();
char __thiscall sub_100155A0(void *this);
char __cdecl sub_10015630(int a1, char a2);
char __cdecl sub_100156F0(int a1, char a2);
char __cdecl sub_100157B0(char a1);
char __cdecl sub_100157E0(char a1);
char __cdecl sub_10015810(char a1);
char __cdecl sub_10015840(int a1, int a2);
char __cdecl sub_10015960(int a1);
int __cdecl sub_10015970(_BYTE *a1);
char __cdecl sub_100159A0(_BYTE *a1, _BYTE *a2);
char __cdecl sub_100159F0(_BYTE *a1, _BYTE *a2);
int sub_10015A40();
__int16 sub_10015B10();
// int __usercall sub_10015B70@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_10015BF0();
int (__cdecl *(*sub_10015DB0())[2])(int, int);
signed int sub_10015EE0();
int __cdecl sub_10015EF0(int a1);
signed int __cdecl sub_10015FF0(int a1, int a2);
int sub_10016090();
int __cdecl sub_100160C0(int a1, int a2);
bool sub_100160E0();
bool sub_100160F0();
char sub_10016110();
unsigned int __cdecl sub_100161B0(char *a1);
int __cdecl sub_100161D0(_BYTE *a1);
int __cdecl sub_100161F0(unsigned __int8 *a1);
unsigned int __cdecl sub_10016210(int a1, int a2);
unsigned int __cdecl sub_10016540(int a1, int a2);
unsigned int __cdecl sub_10016980(_BYTE *a1);
int __cdecl sub_100169A0(unsigned __int8 *a1);
int __cdecl sub_100169C0(unsigned __int8 *a1);
int __cdecl sub_100169E0(_BYTE *a1);
int __cdecl sub_10016A00(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_10016A50(unsigned __int8 *a1);
int __cdecl sub_10016A70(int a1);
unsigned int __cdecl sub_10016B00(int a1);
signed int __cdecl sub_10016B20(int a1);
unsigned int __cdecl sub_10016B70(int a1);
int __cdecl sub_10016BD0(_BYTE *a1);
unsigned int __cdecl sub_10016BF0(_BYTE *a1);
int __cdecl sub_10016C10(unsigned __int8 *a1);
int __cdecl sub_10016C30(_BYTE *a1);
signed int __cdecl sub_10016C50(_BYTE *a1, int a2);
int __cdecl sub_10016C80(_BYTE *a1, int a2);
signed int __cdecl sub_10016CC0(_BYTE *a1, int a2);
int __cdecl sub_10016CF0(int a1, int a2);
int __cdecl sub_10016D80(unsigned __int8 *a1);
int __cdecl sub_10016DA0(int a1);
int __cdecl sub_10016DD0(unsigned __int8 *a1);
unsigned int __cdecl sub_10016DF0(int a1);
int __cdecl sub_10016E20(int a1);
int __cdecl sub_10016F10(int a1);
signed int __cdecl sub_10017020(unsigned __int8 *a1, int a2);
int __cdecl sub_10017050(unsigned __int8 *a1);
int __cdecl sub_100170B0(int a1);
signed int __cdecl sub_100170C0(_BYTE *a1, int a2);
int __cdecl sub_100170F0(int a1, int a2);
unsigned int __cdecl sub_10017170(int a1);
unsigned int __cdecl sub_100171B0(int a1);
int __cdecl sub_10017200(int a1);
int __cdecl sub_10017230(int a1);
unsigned int __cdecl sub_10017260(int a1);
unsigned int __cdecl sub_10017290(int a1);
unsigned int __cdecl sub_100172B0(int a1);
void __cdecl __noreturn sub_100172F0(int a1);
signed int __cdecl sub_10017460(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_100174C0@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10017590(int a1);
char __cdecl sub_100175A0(char a1);
signed int __cdecl sub_100175E0(char a1);
int __cdecl sub_10017620(char *a1, char a2);
bool __cdecl sub_10017690(int a1, void *a2);
char __cdecl sub_10017750(int a1, bool *a2);
signed int __fastcall sub_10017860(unsigned __int8 a1);
char __cdecl sub_10017870(unsigned __int8 a1);
__int16 __cdecl sub_10017890(unsigned __int8 a1);
char *__cdecl sub_100178B0(char **a1);
int sub_10017900();
int __cdecl sub_10017940(_BYTE *a1, int a2);
signed int __cdecl sub_100179B0(_BYTE *a1, int a2);
// int __usercall sub_10017A50@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10017A80@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10017C50@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10017CB0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10017D40@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10017D90@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10017DF0@<eax>(int a1@<eax>);
// int __usercall sub_10017E10@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10017E50@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10017EE0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10018030@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_100180D0@<eax>(int result@<eax>);
char *__cdecl sub_10018110(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_100182C0@<eax>(int a1@<eax>);
// int __usercall sub_100182F0@<eax>(int a1@<esi>);
void __cdecl sub_10018320(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10018790();
void *sub_100187E0();
char *sub_10018840();
char sub_10018860();
char __cdecl sub_10018870(int a1, int a2, unsigned int a3);
// int *__usercall sub_100188B0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10018900();
int __cdecl sub_10018910(_DWORD *a1, int a2, int a3);
int __cdecl sub_100189C0(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10018BD0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10018C90(char a1);
int *__cdecl sub_10018D30(_BYTE *a1);
// int __usercall sub_10018DF0@<eax>(int a1@<eax>);
// signed int __usercall sub_10018F50@<eax>(int a1@<esi>);
int __cdecl sub_10018FC0(int, int); // weak
char **sub_100192A0();
// int __usercall sub_100192B0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_100193A0(char *a1);
int sub_100195E0();
int __cdecl sub_100196C0(int a1, int a2, char a3);
int __cdecl sub_10019710(int a1);
int __cdecl sub_10019720(void *); // idb
int __cdecl sub_100197A0(int a1, int a2);
signed int __cdecl sub_100197D0(int a1, int a2, int a3);
char __cdecl sub_100197F0(_DWORD *a1);
char __cdecl sub_10019900(int a1, unsigned int a2);
bool __cdecl sub_10019930(const void **a1, int a2);
bool __cdecl sub_10019960(const void **a1, int a2);
bool __cdecl sub_10019990(const void **a1, int a2);
bool __cdecl sub_100199C0(const void **a1, int a2);
bool __cdecl sub_100199F0(const void **a1, int a2);
bool __cdecl sub_10019A20(int a1, int a2);
bool __cdecl sub_10019A60(int a1, int a2);
bool __cdecl sub_10019AA0(const void **a1, int a2);
bool __cdecl sub_10019AD0(const void **a1, int a2);
char __cdecl sub_10019B00(int a1, unsigned int a2);
bool __cdecl sub_10019B30(const void **a1, int a2);
bool __cdecl sub_10019B60(const void **a1, int a2);
bool __cdecl sub_10019B90(const void **a1, int a2);
bool __cdecl sub_10019BC0(const void **a1, int a2);
bool __cdecl sub_10019BF0(const void **a1, int a2);
bool __cdecl sub_10019C20(const void **a1, int a2);
bool __cdecl sub_10019C50(const void **a1, int a2);
bool __cdecl sub_10019C80(const void **a1, int a2);
bool __cdecl sub_10019CB0(const void **a1, int a2);
bool __cdecl sub_10019CE0(const void **a1, int a2);
int __cdecl sub_10019D10(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10019D80(int a1, char a2);
int __cdecl sub_10019DA0(int a1, int a2, int a3);
int __cdecl sub_10019DD0(int a1, int a2, int a3, int a4);
int __cdecl sub_10019E00(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10019E40(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10019E80(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10019ED0(int a1);
char __cdecl sub_10019F00(int a1);
char __cdecl sub_10019F10(int a1, int a2);
signed int __cdecl sub_1001A090(int a1);
signed int __cdecl sub_1001A0D0(int a1, int a2, int a3);
char __cdecl sub_1001A170(int a1);
char __cdecl sub_1001A1D0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001A240(char *a1);
int __cdecl sub_1001A2E0(int a1, int a2, int a3);
bool __cdecl sub_1001A350(int a1, unsigned int a2, int a3);
char __cdecl sub_1001A3E0(int a1, int a2, char a3, char a4);
char __cdecl sub_1001A490(int a1);
char __cdecl sub_1001A4A0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1001A520(int a1, const char *a2))(const char *);
signed int __cdecl sub_1001A570(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001A5C0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1001A740();
const char *__cdecl sub_1001A750(unsigned int a1);
int __cdecl sub_1001A770(int a1, int a2, int a3, int a4);
int __cdecl sub_1001A820(int a1);
int __cdecl sub_1001A840(int a1);
char *sub_1001A860(char *a1, ...);
// char *__usercall sub_1001A8A0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1001A8C0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1001AAA0();
int sub_1001AAC0();
int __cdecl sub_1001AAE0(int a1, int a2);
int __cdecl sub_1001AB40(int a1);
int __cdecl sub_1001AB50(int a1, int a2);
int __cdecl sub_1001ABB0(int a1);
bool __cdecl sub_1001ABC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001AD00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001B0B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1001B500(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1001B9C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001BD80(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1001C180(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001C540(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1001CA80(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1001CE60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001D220(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001D5C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1001D9C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001DD60(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1001E340(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1001E730(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1001EAD0();
// BOOL __usercall sub_1001EB00@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1001EC70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1001EEE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1001F1E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1001F290(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1001F2D0(int a1, int a2);
char __cdecl sub_1001F310(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_100200C0(int a1, int a2);
char **__cdecl sub_10020140(int a1);
int (**sub_10020180())();
int (__cdecl *__cdecl sub_10020190(const char *a1))(const char *);
const char *sub_100201B0();
__int64 sub_100201C0();
const char *sub_100201D0();
// int __usercall sub_100201E0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10020230(int a1, int a2);
int sub_10020260(); // weak
// int __usercall sub_10020380@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10020700(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10021520(int a1);
char __thiscall sub_10021590(void *this);
// char __usercall sub_10021600@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10021640@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_100216E0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10021720(char a1, char a2, void *a3);
char __cdecl sub_10021780(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100217C0(char a1, char a2, void *a3);
char __cdecl sub_100217F0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10021830(char a1, char a2, void *a3);
char __cdecl sub_10021870(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100218B0(char a1, char a2, void *a3);
char __cdecl sub_10021900(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10021940(char a1, char a2, void *a3);
char __cdecl sub_10021980(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100219C0(char a1, char a2, void *a3);
char __cdecl sub_10021A00(char a1, void *a2);
char __cdecl sub_10021A30(char a1, void *a2);
char __cdecl sub_10021A60(char a1, void *a2);
char __cdecl sub_10021A90(char a1, void *a2);
char __cdecl sub_10021AC0(char a1, void *a2);
char __cdecl sub_10021AF0(char a1, void *a2);
char __cdecl sub_10021B20(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10021B60(char a1, char a2, void *a3);
char __cdecl sub_10021BB0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10021BF0(char a1, char a2, void *a3);
char __cdecl sub_10021C20(char a1, void *a2);
char __cdecl sub_10021C50(char a1, void *a2);
char __cdecl sub_10021C80(char a1, void *a2);
char __cdecl sub_10021CB0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10022050(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100220C0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10022120(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10022190(char a1, _BYTE *a2);
char __thiscall sub_100221D0(void *this);
char __cdecl sub_10022240(char a1, int a2);
char __cdecl sub_10022270(char a1, int a2);
char __cdecl sub_100222A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10022470(int a1);
char __thiscall sub_100224B0(void *this);
// _DWORD *__usercall sub_100224D0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10022500(); // weak
int sub_10022560(); // weak
char __cdecl sub_100225B0(int a1, int a2);
_DWORD *sub_100226B0();
double __cdecl sub_10022740(int a1);
int __cdecl sub_10022790(int a1, unsigned int a2);
__int16 __cdecl sub_10022880(int a1, unsigned int a2);
__int16 __cdecl sub_100228D0(unsigned int *a1, _WORD *a2, _WORD *a3);
unsigned int __cdecl sub_10022950(unsigned int a1);
bool __cdecl sub_10022970(int a1);
int __cdecl sub_10022A40(int a1);
int __cdecl sub_10022A60(int a1, int a2);
signed int __cdecl sub_10022AA0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10022B60(int a1);
// int __usercall sub_10022BA0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10022C50@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10022E20@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10022E30@<eax>(int result@<eax>);
// char __usercall sub_10022E50@<al>(int a1@<eax>);
// int __usercall sub_10022E70@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10022EB0(int a1, int a2);
// int __usercall sub_10022ED0@<eax>(int a1@<esi>);
// signed int __usercall sub_10022F10@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10023120(int a1);
signed int __cdecl sub_10023390(unsigned int a1, int a2, int a3);
// int __usercall sub_10023430@<eax>(int a1@<eax>);
// int __usercall sub_10023450@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10023480@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_10023570@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100235A0@<eax>(int a1@<eax>);
signed int __cdecl sub_100235D0(unsigned int a1);
signed int __cdecl sub_10023620(int a1, int a2);
signed int __cdecl sub_10023810(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10023870(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10023A00(_BYTE *a1, char a2, int a3);
int __cdecl sub_10023A50(int, float, float, int, int); // idb
unsigned int __cdecl sub_10023B40(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10023B90(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10023C50(void *a1, size_t a2, int a3);
int __cdecl sub_10023CB0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10023D00(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10023DA0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
signed int __cdecl sub_10023E70(unsigned __int8 a1);
signed int __cdecl sub_10023FA0(char a1, char a2);
int __cdecl sub_10024000(char a1);
signed int __cdecl sub_10024040(char a1, char a2, char a3);
int __cdecl sub_100240B0(char a1);
int __cdecl sub_100240F0(char a1);
char __cdecl sub_10024130(char a1, int a2);
char __cdecl sub_10024150(char a1, int a2);
char __cdecl sub_10024180(char a1, int a2);
char __cdecl sub_100241D0(char a1, int a2);
char __cdecl sub_10024200(char a1, int a2);
char __cdecl sub_10024220(int a1);
char __cdecl sub_10024240(char a1);
char sub_10024270();
BOOL __cdecl sub_10024310(int a1, int a2);
char __cdecl sub_10024330(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10024370(char a1, void *a2);
unsigned __int8 __cdecl sub_100243C0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10024400(char a1, _DWORD *a2);
char __cdecl sub_10024440(char a1);
char __cdecl sub_10024470(char a1, void *a2);
int __cdecl sub_100244F0(char a1, _DWORD *a2);
void __cdecl sub_10024540(char a1, char a2);
char __cdecl sub_100245B0(int a1, int a2);
char __cdecl sub_10024600(int a1, int a2);
char __cdecl sub_100246B0(int a1, int a2);
char __cdecl sub_10024710(int a1, int a2);
char __cdecl sub_100247E0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_100248F0(char a1);
bool __cdecl sub_10024940(void *a1);
char __cdecl sub_10024980(char a1);
char __cdecl sub_100249B0(char a1);
int __cdecl sub_100249E0(unsigned __int8 *a1);
unsigned int __cdecl sub_10024A00(void *a1);
unsigned int __cdecl sub_10024A20(void *a1);
unsigned int __cdecl sub_10024A40(void *a1);
unsigned int __cdecl sub_10024A60(void *a1);
unsigned int __cdecl sub_10024A80(void *a1);
unsigned int __cdecl sub_10024AA0(void *a1);
char sub_10024B00();
int __cdecl sub_10024B80(int a1);
char __cdecl sub_10024B90(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10024BD0(const char *a1, int a2);
// char *__usercall sub_10024C40@<eax>(char *result@<eax>);
void __cdecl sub_10024C70(char *a1);
void __cdecl sub_10024D30(char *a1, char *a2);
void *__cdecl sub_10024D90(int a1);
int __cdecl sub_10024F20(int a1, int a2);
// char __usercall sub_10025060@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10025130(_DWORD *a1, char *a2);
BOOL __cdecl sub_10025210(unsigned int a1);
BOOL __cdecl sub_10025230(int a1);
_DWORD __cdecl sub_10025250(_DWORD); // weak
unsigned int __cdecl sub_10025260(int a1, char a2);
signed int __cdecl sub_100252C0(void *a1, int a2, unsigned int a3);
int __cdecl sub_100252E0(int a1, int a2, int a3);
char __cdecl sub_10025300(const char *a1, const char *a2);
int __cdecl sub_10025440(int a1, int a2, unsigned int a3);
int sub_100254C0();
void __cdecl sub_100254D0(int a1);
int __cdecl sub_10025500(int a1);
bool __cdecl sub_10025520(int a1);
void *__cdecl sub_10025550(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10025590@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_100255B0@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_100255D0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10025600(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_100256E0(int a1, int a2, int a3);
// void *__usercall sub_10025790@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10025A10(int a1, int a2);
char __cdecl sub_10025AE0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10025B50@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10025EB0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10025FC0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10026150(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_100262A0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_100263F0(int a1, int a2);
signed int __cdecl sub_10026430(int a1, int a2);
bool __cdecl sub_10026490(signed int a1);
int sub_10026500();
char sub_10026820();
char sub_10026A40();
char sub_10026C40();
char sub_10026DC0();
char sub_10026F40();
char sub_100270B0();
char sub_100271B0();
char sub_10027310();
char sub_10027470();
char sub_100275D0();
char sub_10027740();
char sub_100278A0();
char sub_10027A00();
char sub_10027C20();
char sub_10027D80();
char sub_10027EE0();
char sub_10028040();
char sub_100281B0();
char sub_10028310();
char sub_10028470();
char sub_10028690();
char sub_10028890();
char sub_10028A10();
char sub_10028B90();
char sub_10028D00();
char sub_10028DF0();
char sub_10028F50();
char sub_100290B0();
char sub_10029210();
char sub_10029380();
char sub_100294E0();
char sub_10029640();
char sub_10029840();
char sub_100299A0();
char sub_10029B00();
char sub_10029C60();
char sub_10029DD0();
char sub_10029F30();
char sub_1002A090();
char sub_1002A630();
char sub_1002A840();
char sub_1002AA30();
char sub_1002ABA0();
char sub_1002AD10();
char sub_1002AE70();
char sub_1002AF60();
char sub_1002B0C0();
char sub_1002B220();
char sub_1002B380();
char sub_1002B4F0();
char sub_1002B650();
char sub_1002B7B0();
char sub_1002B9B0();
char sub_1002BB10();
char sub_1002BC70();
char sub_1002BDD0();
char sub_1002BF40();
char sub_1002C0A0();
char sub_1002C200();
char sub_1002C410();
char sub_1002C600();
char sub_1002C770();
char sub_1002C8E0();
char sub_1002CA40();
char sub_1002CB30();
char sub_1002CC90();
char sub_1002CDF0();
char sub_1002CF50();
char sub_1002D0C0();
char sub_1002D220();
char sub_1002D380();
char sub_1002D580();
char sub_1002D6E0();
char sub_1002D840();
char sub_1002D9A0();
char sub_1002DB10();
char sub_1002DC70();
char **sub_1002DDD0();
int __cdecl sub_1002DDE0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1002DE00@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1002DE10@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1002E040(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002E090(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002E0E0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1002E130(int a1))(int);
int __cdecl sub_1002E1B0(int a1, int a2);
int (__cdecl *__cdecl sub_1002E230(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1002E280(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002E2C0(int a1, int a2, int a3))(int);
int __cdecl sub_1002E320(char a1);
int __cdecl sub_1002E370(int a1, int a2);
char __cdecl sub_1002E390(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
signed int __cdecl sub_1002E460(int (__cdecl *a1)(int));
char *__cdecl sub_1002E490(unsigned __int8 a1);
// signed int __usercall sub_1002E4C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1002F570@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1002F5D0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10030350@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10030370(int a1, unsigned int a2);
// int __usercall sub_100303D0@<eax>(int result@<eax>);
// int __usercall sub_10030410@<eax>(int result@<eax>);
// unsigned int __usercall sub_10031B30@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10031C30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10031CB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10031D50@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10031E10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10031E70@<eax>(char *a1@<edi>);
// int __usercall sub_10031F30@<eax>(int a1@<ebx>);
char __cdecl sub_10031FF0(char *a1, size_t a2, int a3);
char __cdecl sub_10032040(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10032090(int a1, int a2);
// int __usercall sub_100320C0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_100322D0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10032320(int a1, int a2);
signed int __cdecl sub_100323B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_100324E0(void *a1, int a2);
// BOOL __usercall sub_10032560@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10032600@<eax>(int result@<eax>);
unsigned int __fastcall sub_10032690(unsigned int a1, int a2);
// int __usercall sub_100326B0@<eax>(int result@<eax>);
// int __usercall sub_10032740@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10032BC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10032C70@<eax>(int a1@<edi>);
// int __usercall sub_10032CD0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10032EA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10032F20(int a1, int a2);
// unsigned int __usercall sub_10032F90@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10033140@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10033210@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_100332C0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10033300@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10033360@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10033440@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100339E0@<eax>(int a1@<eax>);
// int __usercall sub_10033C20@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10033CC0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10033EA0@<eax>(int a1@<edi>);
// int __usercall sub_10033FE0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10034290(int a1, int a2);
// signed int __usercall sub_10034550@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10034620@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10034840(int a1, int a2);
signed int __cdecl sub_10034B50(int a1, int a2);
signed int __cdecl sub_10034F60(int a1, int a2);
int __cdecl sub_100350D0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_100351D0(int a1);
// signed int __usercall sub_100351F0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10035690@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_100356E0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10035700(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10035AB0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10035BF0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10035C40@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10035CE0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10035D00(int a1);
// int __usercall sub_10035D10@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100363B0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10036D90@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_100370C0(int a1, int a2);
char __cdecl sub_100370E0(void *a1);
char __cdecl sub_10037100(void *a1);
bool __thiscall sub_10037250(void *this);
char __cdecl sub_10037270(int a1, char a2, char a3, int a4, void *a5, size_t a6);
bool __cdecl sub_10037410(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_100374A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_10037540(char a1);
char __cdecl sub_100375C0(char a1, int a2);
// int __usercall sub_10037730@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10037770@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_100377B0();
char __cdecl sub_100377C0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10037820(char a1, void *a2);
char __cdecl sub_10037940(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100379C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
BOOL __cdecl sub_10037B70(unsigned __int8 a1);
// BOOL __usercall sub_10037B80@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10037BB0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10037D60(unsigned __int8 a1, int a2);
bool __cdecl sub_10037DA0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_10037E90(char a1, char a2);
// bool __usercall sub_10037F40@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10037F70@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10038010(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10038090(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10038110(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10038190(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10038210(char a1);
int __cdecl sub_100382B0(char a1);
int __cdecl sub_100382D0(int, void *); // idb
// int __usercall sub_10038330@<eax>(char a1@<al>);
BOOL __cdecl sub_10038360(char a1, int a2);
int __cdecl sub_10038390(int, char, int, int, void *); // idb
char __cdecl sub_100383C0(void *a1);
BOOL __cdecl sub_100383E0(int a1);
char __cdecl sub_10038400(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10038430(char a1, void *a2);
// signed int __usercall sub_10038470@<eax>(char a1@<al>);
bool __cdecl sub_10038490(char a1, void *a2);
bool __cdecl sub_10038580(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_100385B0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10038650(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100386D0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10038740(char a1, void *a2);
char __cdecl sub_100387C0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10038840(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100388C0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10038930(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10038A40(char a1, void *a2);
bool __cdecl sub_10038A60(unsigned __int8 a1, char *a2);
char __cdecl sub_10038AA0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10038AE0();
char __cdecl sub_10038B40(int a1, char *a2);
BOOL __cdecl sub_10038C30(int a1, int a2);
char __cdecl sub_10038C50(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10038C90(int a1, int a2);
BOOL __cdecl sub_10038D40(int a1, int a2);
char __cdecl sub_10038D60(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10038DA0(char a1);
// __int16 __usercall sub_10038DE0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10038DF0(unsigned __int8 a1, char *a2);
char __cdecl sub_10038EC0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10038F40(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10039070(char a1, int a2);
bool __cdecl sub_100390F0(void *a1);
char __cdecl sub_10039140(char a1, int a2);
// __int16 __usercall sub_10039220@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10039230(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_100392C0(unsigned __int8 a1, char a2);
bool __cdecl sub_10039380(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10039480(char a1);
char __cdecl sub_100394C0(char a1);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int sprintf(char *, const char *, ...);
// char *__cdecl strchr(const char *, int);
// int __cdecl strncmp(const char *, const char *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int __cdecl toupper(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003B6D3(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
signed int __cdecl sub_1003CD7C(_DWORD *a1);
signed int __cdecl sub_1003CDB3(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1003D9F9();
int (*sub_1003DEA6())(void);
void __cdecl sub_1003DECA(); // idb
int __cdecl sub_1003F95E(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003FA88(int, FILE *); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1004310F(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_100448B0(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10044956(int, int, struct localeinfo_struct *); // idb
void sub_10044DC2();
int sub_10045352();
int __cdecl sub_1004550F(int a1);
int __cdecl sub_10045519(int a1);
int __cdecl sub_10045523(int a1);
int __cdecl sub_10045602(int a1);
// int _get_sse2_info(void); weak
int sub_100467C7();
DWORD __cdecl sub_10047840(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_100479DC(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10047FFE(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1004811E(signed int a1);
void **sub_1004817C();
signed int sub_10048182();
// int __cdecl _fileno(FILE *);
signed int __cdecl sub_10048A99(int a1, int a2);
signed int __cdecl sub_10048FDB(int a1, int a2);
int __cdecl sub_1004991C(FILE *); // idb
int __cdecl sub_10049A3C(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_10049C84();
int __cdecl sub_1004B160(int a1, int a2, int a3);
signed int __cdecl sub_1004B633(signed int a1);
signed int __cdecl sub_1004B6B4(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1004B7C5(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1004BAC6();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1004C411(signed int a1);
int __cdecl sub_1004C5B0(int a1, int a2);
// int __usercall sub_1004C610@<eax>(const char **a1@<esi>);
// int __usercall sub_1004C910@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1004C930(int a1);
__int16 __cdecl sub_1004CA00(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_1004CA40(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1004CAE0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1004CB30(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1004CBA0(int a1);
int __cdecl sub_1004CBE0(int a1);
int __cdecl sub_1004CC20(int a1);
int __cdecl sub_1004CC60(int a1);
int __cdecl sub_1004CCA0(int a1, int a2, int a3, int a4);
int __cdecl sub_1004CD10(int a1, int a2, int a3);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
double __cdecl sub_1004CDC0(char a1);
void __cdecl sub_1004CE50(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_1004CEB0(float, float, int); // idb
void __cdecl sub_1004D070(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_1004D440(float *a1, float *a2, int a3);
double __cdecl sub_1004D500(int a1, int a2);
int __cdecl sub_1004D520(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_1004D780(unsigned __int8 a1);
int __cdecl sub_1004D7A0(int, float, float, int, int); // idb
char __cdecl sub_1004D810(unsigned __int8 a1, int a2, int a3);
// void __usercall sub_1004D890(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_1004D910(char a1, char a2, int a3, int a4);
// void __usercall sub_1004DC90(int a1@<ebx>, int a2@<edi>, float a3, float a4);
// void __usercall sub_1004DF80(int a1@<esi>);
void __cdecl sub_1004DFF0(int a1, float a2, float a3, int a4);
void __cdecl sub_1004E200(int a1, float a2, float a3, int a4);
int __cdecl sub_1004E2B0(int, float, float, int, int, float); // idb
signed int __cdecl sub_1004E340(int a1, char a2);
bool __cdecl sub_1004E3A0(char a1);
bool __cdecl sub_1004E3B0(char a1);
double __cdecl sub_1004E3C0(float a1, float a2, int a3);
bool __cdecl sub_1004E430(float a1, float a2, float a3);
double __cdecl sub_1004E4B0(double a1, double a2);
double __cdecl sub_1004E510(float a1, float a2);
int __cdecl sub_1004E590(double); // idb
double __cdecl sub_1004E5B0(float a1);
int __cdecl sub_1004E5F0(int a1, int a2);
int __cdecl sub_1004E610(float, int, int); // idb
int __cdecl sub_1004E630(int a1, int a2);
double __cdecl sub_1004E650(double a1, double a2);
double __cdecl sub_1004E6C0(float a1, float a2);
int __cdecl sub_1004E750(int a1, int a2, int a3);
int __cdecl sub_1004E780(float, int, int); // idb
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_100503A8; // weak
_UNKNOWN unk_100503B0; // weak
_UNKNOWN unk_100503D0; // weak
_UNKNOWN unk_10051C14; // weak
_UNKNOWN unk_10051C24; // weak
_UNKNOWN unk_10051C30; // weak
_UNKNOWN unk_10051C38; // weak
char byte_10051C3C[] = { '\0' }; // weak
_UNKNOWN unk_10051D78; // weak
char byte_10051D7C[] = { '\0' }; // weak
_UNKNOWN unk_10051DE8; // weak
__int16 word_10051DEC[] = { 35 }; // weak
_UNKNOWN unk_10051F18; // weak
void *off_100530B8 = &unk_100E0890; // weak
int (__cdecl *off_10053B6C)(int) = &sub_10003520; // weak
char aInset[6] = "INSET"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_100561E1; // weak
int dword_10057EC0[] = { 6103 }; // weak
int dword_10057EC4[] = { 8000 }; // weak
char byte_10058AF8[] = { '\0' }; // weak
int dword_10058B08 = 0; // idb
int dword_10059408[] = { 0 }; // weak
char *off_1005A87C = "/shr_mem/mpm_c_intf.shr"; // weak
_UNKNOWN unk_1005E02C; // weak
_UNKNOWN unk_1005E5C5; // weak
_UNKNOWN unk_1005E5FE; // weak
char *off_1005E630 = "/shr_mem/udb_intf.shr"; // weak
char byte_1005F1A0[] = { ' ' }; // weak
char byte_1005F1A8[] = { ' ' }; // weak
_UNKNOWN unk_1005F1B0; // weak
char byte_10060370[] = { '\b' }; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_10062DBC; // weak
_UNKNOWN unk_100648BC; // weak
_UNKNOWN unk_100648CC; // weak
_UNKNOWN unk_100648D4; // weak
_UNKNOWN unk_10064980; // weak
void *off_10064984 = &unk_100648F4; // weak
char *off_10065B40[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100659B0 }; // weak
_UNKNOWN unk_10065B54; // weak
char byte_10067268[] = { '\0' }; // weak
int (__cdecl *off_1006C498)(int, size_t, void *) = &sub_10013EF0; // weak
char *off_1006C4CC = "/shr_mem/pvt_intf.shr"; // weak
char *off_1006C884 = "/shr_mem/gdl69_xm_wx_intf.shr"; // weak
int dword_1006D25C[] = { 88 }; // weak
__int16 word_1006D70C[] = { 836 }; // weak
char *off_1006D72C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1006D740 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1006D754 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1006D768 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1006D77C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1006D790 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int (*off_1006DD70[4])() = { &sub_10015010, &sub_10015000, &sub_10014FF0, &sub_10015000 }; // weak
_UNKNOWN unk_10083ECC; // weak
_UNKNOWN unk_10085508; // weak
int dword_1008550C[] = { 1312 }; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_1008580C = "006-D0170-"; // weak
int (__cdecl *(*off_10085810)[2])(int, int) = &off_100951E8; // weak
char *off_1008583C = "/shr_mem/prx_intf.shr"; // weak
char *off_10086374 = "/shr_mem/nav_intf.shr"; // weak
int (__cdecl *off_10089B58[3])(char) = { &sub_10011030, &sub_10010F40, &sub_10010F00 }; // weak
__int16 word_1008B9C8[] = { 43 }; // weak
char byte_1008B9CC[] = { '\x06' }; // weak
_UNKNOWN unk_1008BFD0; // weak
char *off_1008C174[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1008C188 }; // weak
char *off_1008C318 = "true"; // weak
char byte_1008C31C[] = { '\x01' }; // weak
char *off_1008C380 = "failure listener"; // weak
_UNKNOWN unk_1008CB20; // weak
char *off_1008CD1C[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_1008CD24[3] = { "normal", "robust", "EQ" }; // weak
char *off_1008CD2C = "EQ"; // weak
char *off_1008CD48[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1008CD54[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1008CD5C[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1008D010; // weak
_UNKNOWN unk_1008D04C; // weak
char *off_1008D408 = "printf_listener"; // weak
__int16 word_1008E03C = 2573; // weak
int (*off_1008E0F8[2])() = { &sub_1002DDD0, &sub_10011760 }; // weak
char *off_1008E1A8 = "gate_listener"; // weak
_BYTE word_1008F222[1362] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  0,
  0,
  0,
  0,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  255,
  255,
  255,
  255,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0
}; // idb
char byte_10091E61[] = { '\x1E' }; // weak
_UNKNOWN unk_10091F48; // weak
_UNKNOWN unk_10091F60; // weak
_UNKNOWN unk_10091FA8; // weak
int dword_10091FAC[] = { 6767 }; // weak
_UNKNOWN unk_10091FB8; // weak
_UNKNOWN unk_10091FD0; // weak
_UNKNOWN unk_10091FE8; // weak
int dword_10091FEC[] = { 6769 }; // weak
_UNKNOWN unk_10092000; // weak
int dword_10092004[] = { 6093 }; // weak
int dword_100942F8[] = { 1600085855 }; // weak
_UNKNOWN unk_100951B8; // weak
char byte_100951B9[] = { '\0' }; // weak
int (__cdecl *off_100951E8[2])(int, int) = { &sub_100246B0, &sub_10024710 }; // weak
_UNKNOWN unk_10096318; // weak
int dword_1009631C[] = { 6006 }; // weak
_UNKNOWN unk_1009A348; // weak
_UNKNOWN unk_1009A36C; // weak
_UNKNOWN unk_1009A510; // weak
char off_1009B140[] = { '\b', '', '\b', '\x10' }; // idb
int dword_1009B15C = 1; // idb
char byte_1009B178[] = { '\x01' }; // weak
void *off_1009B17C = &unk_10062DBC; // weak
char *off_1009B180[2] = { "2", "fail_normal_1" }; // weak
char off_1009B184[8] = { '(', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1009B208[] = { '\0' }; // weak
char byte_1009B209[] = { '\0' }; // weak
int dword_1009B20C[] = { 0 }; // weak
char *off_1009B210 = "0, 0, 0"; // weak
double dbl_1009B478[] = {  0.0 }; // weak
double dbl_1009B480[] = {  0.0 }; // weak
double dbl_1009B488[] = {  0.0 }; // weak
int dword_1009B490[] = { 0 }; // weak
char off_1009B494[32] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1009C098[] = {  0.0 }; // weak
float flt_1009C09C[] = {  0.0 }; // weak
float flt_1009C0A0[] = {  0.0 }; // weak
int dword_1009C0A4[] = { 0 }; // weak
char off_1009C0A8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_1009C82C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100B1488
}; // weak
int dword_1009C840[] = { 0 }; // weak
int dword_1009C844[] = { 0 }; // weak
int dword_1009C848[] = { 0 }; // weak
int dword_1009C84C[] = { 0 }; // weak
char *off_1009C850 = "0, 0, 0"; // weak
__int16 word_1009CFD8[] = { 0 }; // weak
__int16 word_1009CFDA[] = { 0 }; // weak
__int16 word_1009CFDC[] = { 0 }; // weak
int dword_1009CFE0[] = { 0 }; // weak
char *off_1009CFE4 = "0, 0, 0"; // weak
int dword_1009D5E8[] = { 0 }; // weak
int dword_1009D5EC[] = { 0 }; // weak
int dword_1009D5F0[] = { 0 }; // weak
int dword_1009D5F4[] = { 0 }; // weak
char off_1009D5F8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009DD80[] = { 0 }; // weak
int dword_1009DD84[] = { 0 }; // weak
int dword_1009DD88[] = { 0 }; // weak
int dword_1009DD8C[] = { 0 }; // weak
int dword_1009DD90[] = { 0 }; // weak
int dword_1009DD94[] = { 0 }; // weak
int dword_1009DD98[] = { 0 }; // weak
char off_1009DD9C[32] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1009E9A0[] = { '\0' }; // weak
char byte_1009E9A1[] = { '\0' }; // weak
char byte_1009E9A2[] = { '\0' }; // weak
int dword_1009E9A4[] = { 0 }; // weak
char *off_1009E9A8 = "0, 0, 0"; // weak
int dword_1009EE30[] = { 0 }; // weak
int dword_1009EE34[] = { 0 }; // weak
int dword_1009EE38[] = { 0 }; // weak
int dword_1009EE3C[] = { 0 }; // weak
char *off_1009EE40 = "0, 0, 0"; // weak
int dword_1009F5C8[] = { 0 }; // weak
int dword_1009F5CC[] = { 0 }; // weak
int dword_1009F5D0[] = { 0 }; // weak
int dword_1009F5D4[] = { 0 }; // weak
char off_1009F5D8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1009F938[] = { 0 }; // weak
__int16 word_1009F93A[] = { 0 }; // weak
__int16 word_1009F93C[] = { 0 }; // weak
int dword_1009F940[] = { 0 }; // weak
char *off_1009F944 = "0, 0, 0"; // weak
int dword_1009FBF8[] = { 0 }; // weak
int dword_1009FBFC[] = { 0 }; // weak
int dword_1009FC00[] = { 0 }; // weak
int dword_1009FC04[] = { 0 }; // weak
char off_1009FC08[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009FF68[] = { 0 }; // weak
int dword_1009FF6C[] = { 0 }; // weak
int dword_1009FF70[] = { 0 }; // weak
int dword_1009FF74[] = { 0 }; // weak
int dword_1009FF78[] = { 0 }; // weak
int dword_1009FF7C[] = { 0 }; // weak
int dword_1009FF80[] = { 0 }; // weak
char *off_1009FF84 = "0, 0, 0"; // weak
char byte_100A04E8[] = { '\0' }; // weak
char byte_100A04E9[] = { '\0' }; // weak
char byte_100A04EA[] = { '\0' }; // weak
int dword_100A04EC[] = { 0 }; // weak
char *off_100A04F0 = "0, 0, 0"; // weak
int dword_100A06F8[] = { 0 }; // weak
int dword_100A06FC[] = { 0 }; // weak
int dword_100A0700[] = { 0 }; // weak
int dword_100A0704[] = { 0 }; // weak
char off_100A0708[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A0A68[] = { '\x01' }; // weak
void *off_100A0A6C = &unk_10062DBC; // weak
char *off_100A0A70[2] = { "2", "fail_robust_1" }; // weak
char off_100A0A74[8] = { '', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A0AF8[] = { '\0' }; // weak
char byte_100A0AF9[] = { '\0' }; // weak
int dword_100A0AFC[] = { 0 }; // weak
char *off_100A0B00 = "0, 0, 0"; // weak
double dbl_100A0D68[] = {  0.0 }; // weak
double dbl_100A0D70[] = {  0.0 }; // weak
double dbl_100A0D78[] = {  0.0 }; // weak
int dword_100A0D80[] = { 0 }; // weak
char *off_100A0D84 = "0, 0, 0"; // weak
float flt_100A1988[] = {  0.0 }; // weak
float flt_100A198C[] = {  0.0 }; // weak
float flt_100A1990[] = {  0.0 }; // weak
int dword_100A1994[] = { 0 }; // weak
char off_100A1998[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A2120[] = { 0 }; // weak
int dword_100A2124[] = { 0 }; // weak
int dword_100A2128[] = { 0 }; // weak
int dword_100A212C[] = { 0 }; // weak
char *off_100A2130 = "0, 0, 0"; // weak
__int16 word_100A28B8[] = { 0 }; // weak
__int16 word_100A28BA[] = { 0 }; // weak
__int16 word_100A28BC[] = { 0 }; // weak
int dword_100A28C0[] = { 0 }; // weak
char *off_100A28C4 = "0, 0, 0"; // weak
int dword_100A2EC8[] = { 0 }; // weak
int dword_100A2ECC[] = { 0 }; // weak
int dword_100A2ED0[] = { 0 }; // weak
int dword_100A2ED4[] = { 0 }; // weak
char off_100A2ED8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A3660[] = { 0 }; // weak
int dword_100A3664[] = { 0 }; // weak
int dword_100A3668[] = { 0 }; // weak
int dword_100A366C[] = { 0 }; // weak
int dword_100A3670[] = { 0 }; // weak
int dword_100A3674[] = { 0 }; // weak
int dword_100A3678[] = { 0 }; // weak
char off_100A367C[32] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A4280[] = { '\0' }; // weak
char byte_100A4281[] = { '\0' }; // weak
char byte_100A4282[] = { '\0' }; // weak
int dword_100A4284[] = { 0 }; // weak
char *off_100A4288 = "0, 0, 0"; // weak
int dword_100A4710[] = { 0 }; // weak
int dword_100A4714[] = { 0 }; // weak
int dword_100A4718[] = { 0 }; // weak
int dword_100A471C[] = { 0 }; // weak
char *off_100A4720 = "0, 0, 0"; // weak
int dword_100A4EA8[] = { 0 }; // weak
int dword_100A4EAC[] = { 0 }; // weak
int dword_100A4EB0[] = { 0 }; // weak
int dword_100A4EB4[] = { 0 }; // weak
char off_100A4EB8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A5218[] = { 0 }; // weak
__int16 word_100A521A[] = { 0 }; // weak
__int16 word_100A521C[] = { 0 }; // weak
int dword_100A5220[] = { 0 }; // weak
char *off_100A5224 = "0, 0, 0"; // weak
int dword_100A54D8[] = { 0 }; // weak
int dword_100A54DC[] = { 0 }; // weak
int dword_100A54E0[] = { 0 }; // weak
int dword_100A54E4[] = { 0 }; // weak
char off_100A54E8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A5848[] = { 0 }; // weak
int dword_100A584C[] = { 0 }; // weak
int dword_100A5850[] = { 0 }; // weak
int dword_100A5854[] = { 0 }; // weak
int dword_100A5858[] = { 0 }; // weak
int dword_100A585C[] = { 0 }; // weak
int dword_100A5860[] = { 0 }; // weak
char *off_100A5864 = "0, 0, 0"; // weak
char byte_100A5DC8[] = { '\0' }; // weak
char byte_100A5DC9[] = { '\0' }; // weak
char byte_100A5DCA[] = { '\0' }; // weak
int dword_100A5DCC[] = { 0 }; // weak
char *off_100A5DD0 = "0, 0, 0"; // weak
int dword_100A5FD8[] = { 0 }; // weak
int dword_100A5FDC[] = { 0 }; // weak
int dword_100A5FE0[] = { 0 }; // weak
int dword_100A5FE4[] = { 0 }; // weak
char off_100A5FE8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A6348[] = { '\x01' }; // weak
void *off_100A634C = &unk_10062DBC; // weak
void *off_100A6350 = &unk_10062DBC; // weak
char off_100A6354[8] = { '\x10', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A6398[] = { '\0' }; // weak
char byte_100A6399[] = { '\0' }; // weak
int dword_100A639C[] = { 0 }; // weak
char *off_100A63A0 = "0, 0, 0"; // weak
double dbl_100A6608[] = {  0.0 }; // weak
double dbl_100A6610[] = {  0.0 }; // weak
double dbl_100A6618[] = {  0.0 }; // weak
int dword_100A6620[] = { 0 }; // weak
char *off_100A6624 = "0, 0, 0"; // weak
float flt_100A7228[] = {  0.0 }; // weak
float flt_100A722C[] = {  0.0 }; // weak
float flt_100A7230[] = {  0.0 }; // weak
int dword_100A7234[] = { 0 }; // weak
char off_100A7238[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A79C0[] = { 0 }; // weak
int dword_100A79C4[] = { 0 }; // weak
int dword_100A79C8[] = { 0 }; // weak
int dword_100A79CC[] = { 0 }; // weak
char *off_100A79D0 = "0, 0, 0"; // weak
__int16 word_100A8158[] = { 0 }; // weak
__int16 word_100A815A[] = { 0 }; // weak
__int16 word_100A815C[] = { 0 }; // weak
int dword_100A8160[] = { 0 }; // weak
char *off_100A8164 = "0, 0, 0"; // weak
int dword_100A8768[] = { 0 }; // weak
int dword_100A876C[] = { 0 }; // weak
int dword_100A8770[] = { 0 }; // weak
int dword_100A8774[] = { 0 }; // weak
char off_100A8778[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A8F00[] = { 0 }; // weak
int dword_100A8F04[] = { 0 }; // weak
int dword_100A8F08[] = { 0 }; // weak
int dword_100A8F0C[] = { 0 }; // weak
int dword_100A8F10[] = { 0 }; // weak
int dword_100A8F14[] = { 0 }; // weak
int dword_100A8F18[] = { 0 }; // weak
char off_100A8F1C[32] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A9B20[] = { '\0' }; // weak
char byte_100A9B21[] = { '\0' }; // weak
char byte_100A9B22[] = { '\0' }; // weak
int dword_100A9B24[] = { 0 }; // weak
char *off_100A9B28 = "0, 0, 0"; // weak
int dword_100A9FB0[] = { 0 }; // weak
int dword_100A9FB4[] = { 0 }; // weak
int dword_100A9FB8[] = { 0 }; // weak
int dword_100A9FBC[] = { 0 }; // weak
char *off_100A9FC0 = "0, 0, 0"; // weak
int dword_100AA748[] = { 0 }; // weak
int dword_100AA74C[] = { 0 }; // weak
int dword_100AA750[] = { 0 }; // weak
int dword_100AA754[] = { 0 }; // weak
char off_100AA758[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100AAAB8[] = { 0 }; // weak
__int16 word_100AAABA[] = { 0 }; // weak
__int16 word_100AAABC[] = { 0 }; // weak
int dword_100AAAC0[] = { 0 }; // weak
char *off_100AAAC4 = "0, 0, 0"; // weak
int dword_100AAD78[] = { 0 }; // weak
int dword_100AAD7C[] = { 0 }; // weak
int dword_100AAD80[] = { 0 }; // weak
int dword_100AAD84[] = { 0 }; // weak
char off_100AAD88[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AB0E8[] = { 0 }; // weak
int dword_100AB0EC[] = { 0 }; // weak
int dword_100AB0F0[] = { 0 }; // weak
int dword_100AB0F4[] = { 0 }; // weak
int dword_100AB0F8[] = { 0 }; // weak
int dword_100AB0FC[] = { 0 }; // weak
int dword_100AB100[] = { 0 }; // weak
char *off_100AB104 = "0, 0, 0"; // weak
char byte_100AB668[] = { '\0' }; // weak
char byte_100AB669[] = { '\0' }; // weak
char byte_100AB66A[] = { '\0' }; // weak
int dword_100AB66C[] = { 0 }; // weak
char *off_100AB670 = "0, 0, 0"; // weak
int dword_100AB878[] = { 0 }; // weak
int dword_100AB87C[] = { 0 }; // weak
int dword_100AB880[] = { 0 }; // weak
int dword_100AB884[] = { 0 }; // weak
char off_100AB888[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100ABBE8[] = { '\x01' }; // weak
void *off_100ABBEC = &unk_10062DBC; // weak
void *off_100ABBF0 = &unk_10062DBC; // weak
char off_100ABBF4[8] = { '', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100ABC38[] = { '\0' }; // weak
char byte_100ABC39[] = { '\0' }; // weak
int dword_100ABC3C[] = { 0 }; // weak
char *off_100ABC40 = "0, 0, 0"; // weak
double dbl_100ABEA8[] = {  0.0 }; // weak
double dbl_100ABEB0[] = {  0.0 }; // weak
double dbl_100ABEB8[] = {  0.0 }; // weak
int dword_100ABEC0[] = { 0 }; // weak
char *off_100ABEC4 = "0, 0, 0"; // weak
float flt_100ACAC8[] = {  0.0 }; // weak
float flt_100ACACC[] = {  0.0 }; // weak
float flt_100ACAD0[] = {  0.0 }; // weak
int dword_100ACAD4[] = { 0 }; // weak
char off_100ACAD8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AD260[] = { 0 }; // weak
int dword_100AD264[] = { 0 }; // weak
int dword_100AD268[] = { 0 }; // weak
int dword_100AD26C[] = { 0 }; // weak
char *off_100AD270 = "0, 0, 0"; // weak
__int16 word_100AD9F8[] = { 0 }; // weak
__int16 word_100AD9FA[] = { 0 }; // weak
__int16 word_100AD9FC[] = { 0 }; // weak
int dword_100ADA00[] = { 0 }; // weak
char *off_100ADA04 = "0, 0, 0"; // weak
int dword_100AE008[] = { 0 }; // weak
int dword_100AE00C[] = { 0 }; // weak
int dword_100AE010[] = { 0 }; // weak
int dword_100AE014[] = { 0 }; // weak
char off_100AE018[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AE7A0[] = { 0 }; // weak
int dword_100AE7A4[] = { 0 }; // weak
int dword_100AE7A8[] = { 0 }; // weak
int dword_100AE7AC[] = { 0 }; // weak
int dword_100AE7B0[] = { 0 }; // weak
int dword_100AE7B4[] = { 0 }; // weak
int dword_100AE7B8[] = { 0 }; // weak
char off_100AE7BC[32] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AF3C0[] = { '\0' }; // weak
char byte_100AF3C1[] = { '\0' }; // weak
char byte_100AF3C2[] = { '\0' }; // weak
int dword_100AF3C4[] = { 0 }; // weak
char *off_100AF3C8 = "0, 0, 0"; // weak
int dword_100AF850[] = { 0 }; // weak
int dword_100AF854[] = { 0 }; // weak
int dword_100AF858[] = { 0 }; // weak
int dword_100AF85C[] = { 0 }; // weak
char *off_100AF860 = "0, 0, 0"; // weak
int dword_100AFFE8[] = { 0 }; // weak
int dword_100AFFEC[] = { 0 }; // weak
int dword_100AFFF0[] = { 0 }; // weak
int dword_100AFFF4[] = { 0 }; // weak
char off_100AFFF8[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B0358[] = { 0 }; // weak
__int16 word_100B035A[] = { 0 }; // weak
__int16 word_100B035C[] = { 0 }; // weak
int dword_100B0360[] = { 0 }; // weak
char *off_100B0364 = "0, 0, 0"; // weak
int dword_100B0618[] = { 0 }; // weak
int dword_100B061C[] = { 0 }; // weak
int dword_100B0620[] = { 0 }; // weak
int dword_100B0624[] = { 0 }; // weak
char off_100B0628[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B0988[] = { 0 }; // weak
int dword_100B098C[] = { 0 }; // weak
int dword_100B0990[] = { 0 }; // weak
int dword_100B0994[] = { 0 }; // weak
int dword_100B0998[] = { 0 }; // weak
int dword_100B099C[] = { 0 }; // weak
int dword_100B09A0[] = { 0 }; // weak
char *off_100B09A4 = "0, 0, 0"; // weak
char byte_100B0F08[] = { '\0' }; // weak
char byte_100B0F09[] = { '\0' }; // weak
char byte_100B0F0A[] = { '\0' }; // weak
int dword_100B0F0C[] = { 0 }; // weak
char *off_100B0F10 = "0, 0, 0"; // weak
int dword_100B1118[] = { 0 }; // weak
int dword_100B111C[] = { 0 }; // weak
int dword_100B1120[] = { 0 }; // weak
int dword_100B1124[] = { 0 }; // weak
char off_100B1128[20] =
{
  '',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100B2108; // weak
int dword_100B52E4[] = { 0 }; // weak
_UNKNOWN off_100B52E8; // weak
_UNKNOWN unk_100B5378; // weak
_UNKNOWN unk_100B537C; // weak
_UNKNOWN unk_100B5380; // weak
_UNKNOWN unk_100B5384; // weak
_UNKNOWN unk_100B5388; // weak
_UNKNOWN unk_100B538C; // weak
_UNKNOWN unk_100B5390; // weak
_UNKNOWN unk_100B5394; // weak
_UNKNOWN unk_100B6E08; // weak
int dword_100B6E0C[] = { 0 }; // weak
_WORD dword_100B7BF8[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100B7FF8[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100B83F8[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100B87F8[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100B8BF8[] = { 99 }; // weak
int dword_100B8FF8[] = { 25344 }; // weak
int dword_100B93F8[] = { 6488064 }; // weak
int dword_100B97F8[] = { 1660944384 }; // weak
int dword_100B9C20[] = { 128 }; // weak
int dword_100B9C30[] = { 0 }; // weak
int dword_100B9C40[] = { 0 }; // weak
char byte_100B9CB1[] = { '\0' }; // weak
char byte_100B9CB2[] = { '\0' }; // weak
char byte_100B9CB3[] = { '\0' }; // weak
char byte_100B9CB4[] = { '\x10' }; // weak
int dword_100B9CC8[] = { 0 }; // weak
_UNKNOWN unk_100B9D40; // weak
_UNKNOWN unk_100BA1C0; // weak
char byte_100BA238[] = { '\0' }; // weak
char byte_100BA338[] = { '\0' }; // weak
char byte_100BA438[] = { '\0' }; // weak
int dword_100BA538[] = { 0 }; // weak
int dword_100BA5B0[] = { 0 }; // weak
int (__cdecl *off_100BA630)(int, int) = &sub_10034F60; // weak
int dword_100BA818[] = { 0 }; // weak
int dword_100BA860[] = { 16 }; // weak
_UNKNOWN unk_100BA8B0; // weak
_UNKNOWN unk_100BA930; // weak
_UNKNOWN unk_100BA9B0; // weak
_UNKNOWN unk_100BAA28; // weak
_UNKNOWN unk_100BAAA0; // weak
_UNKNOWN unk_100BBAA0; // weak
int dword_100BD8A0 = 64; // weak
__int16 word_100BD8A4[] = { 6782 }; // weak
__int16 word_100BD8A8[] = { 128 }; // weak
_UNKNOWN unk_100BD8C4; // weak
_DWORD dword_100BD8C8[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_100BF768 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_100C0B58[] = { 1565 }; // weak
__int16 word_100C0B5C[] = { 534 }; // weak
char byte_100C0B60[] = { '\x04' }; // weak
__int16 word_100C0B62[] = { 6512 }; // weak
int dword_100C0B78[] = { 118000 }; // weak
_UNKNOWN unk_100C1908; // weak
int dword_100C190C[] = { 0 }; // weak
_UNKNOWN unk_100C1920; // weak
int dword_100C1924[] = { 0 }; // weak
_UNKNOWN unk_100C1948; // weak
int dword_100C194C[] = { 0 }; // weak
_UNKNOWN unk_100C1978; // weak
int dword_100C197C[] = { 0 }; // weak
int dword_100C1A34[] = { 6829 }; // weak
__int16 word_100C2A6A[] = { 233 }; // weak
int dword_100C2A70[] = { 6201 }; // weak
__int16 word_100C478C[] = { 114 }; // weak
__int16 word_100C4898[] = { 551 }; // weak
char byte_100C779A[] = { '\x04' }; // weak
char byte_100C779F[] = { '\a' }; // weak
_UNKNOWN unk_100D9510; // weak
int dword_100D9514[] = { 3535 }; // weak
_UNKNOWN unk_100D9548; // weak
int dword_100D954C[] = { 6813 }; // weak
_UNKNOWN unk_100D9580; // weak
int dword_100D9584[] = { 9036 }; // weak
_UNKNOWN unk_100D95B8; // weak
int dword_100D95BC[] = { 6763 }; // weak
char byte_100D96A0[104] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '@',
  '\0',
  '\0',
  ' ',
  'A',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\0',
  '\0',
  ' ',
  'A',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '?',
  '\0',
  '\0',
  '',
  '?',
  '\x03',
  '\0',
  '\0',
  '\0',
  '',
  '',
  '',
  '>',
  '',
  '',
  '',
  '>',
  '\x04',
  '\0',
  '\0',
  '\0',
  '',
  '',
  '',
  '>',
  '',
  '',
  '',
  '>',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  'A',
  '\0',
  '\0',
  ' ',
  'A',
  '\x06',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  'A',
  '\0',
  '\0',
  ' ',
  'A',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100DC140; // weak
_UNKNOWN unk_100DC148; // weak
int (*off_100DE210[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100DE228; // weak
void *off_100DED28 = &unk_101E3280; // weak
_UNKNOWN unk_100DED38; // weak
_UNKNOWN unk_100DED98; // weak
wchar_t *off_100DEFA8 = L"         (((((                  H"; // weak
int dword_100DF0B0 = 1024; // weak
int dword_100DF0B4 = 4294966273; // weak
int dword_100DF0B8 = 53; // weak
int dword_100DF0BC = 11; // weak
int dword_100DF0C0 = 64; // weak
int dword_100DF0C4 = 1023; // weak
int dword_100DF0C8 = 128; // weak
int dword_100DF0CC = 4294967169; // weak
int dword_100DF0D0 = 24; // weak
int dword_100DF0D4 = 8; // weak
int dword_100DF0D8 = 32; // weak
int dword_100DF0DC = 127; // weak
_UNKNOWN unk_100DF760; // weak
char byte_100DF764 = '\0'; // weak
int dword_100DF768 = 0; // weak
_UNKNOWN unk_100DF770; // weak
int dword_100DF83C = 0; // weak
int dword_100DF840 = 0; // weak
int dword_100DF844[] = { 0 }; // weak
int dword_100DF848 = 0; // weak
int dword_100DF84C[] = { 0 }; // weak
char byte_100DF850 = '\0'; // weak
char byte_100DF858 = '\0'; // idb
int dword_100E0858; // weak
char byte_100E085C; // weak
char byte_100E085D; // weak
char byte_100E085E; // weak
_UNKNOWN unk_100E0860; // weak
char byte_100E0861[2]; // idb
char byte_100E0863; // idb
char byte_100E0864; // idb
char byte_100E0865; // idb
char byte_100E0866; // idb
char byte_100E0867; // weak
char byte_100E0868; // idb
char byte_100E0869; // idb
char byte_100E086A; // idb
char byte_100E086B; // idb
char byte_100E086C; // weak
char byte_100E086D; // idb
char byte_100E0878; // weak
char byte_100E087D[19]; // idb
_UNKNOWN unk_100E0890; // weak
char byte_100FC510; // weak
char byte_100FC511; // weak
int dword_100FC514; // weak
int dword_100FC518; // weak
int dword_100FC51C; // weak
int dword_100FC520; // weak
int dword_100FC524; // weak
int dword_100FC528; // weak
_DWORD dword_1010ED18[16]; // idb
int dword_1010ED58[]; // weak
int dword_1010ED98; // weak
int dword_1010EDA0[]; // weak
char byte_1010EDE0; // weak
char byte_1010EDE1; // weak
int dword_1010EDE4; // weak
char byte_1010EDE8[]; // weak
char byte_1010EDF2; // weak
char byte_1010EDF3; // weak
int dword_1010EDF4; // weak
char byte_1010EDF8; // weak
char byte_1010EDF9; // weak
__int16 word_1010EDFC; // weak
char byte_1010EDFE; // weak
__int16 word_1010EE10[]; // weak
char byte_1010EE38[]; // weak
int dword_1010EF38; // weak
__int16 word_1010EF3C; // weak
__int16 word_1010EF40; // weak
__int16 word_1010EF44; // weak
int dword_1010EF48; // weak
void (__cdecl *dword_1010EFD8[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_1010EFF8; // weak
int dword_101196D0[]; // weak
int dword_101196E4; // weak
int dword_101196E8; // weak
_UNKNOWN unk_101196F0; // weak
_UNKNOWN unk_101196F1; // weak
_UNKNOWN unk_10119707; // weak
_UNKNOWN unk_10119708; // weak
_UNKNOWN unk_10119709; // weak
_UNKNOWN unk_1011970A; // weak
_UNKNOWN unk_1011970C; // weak
_UNKNOWN unk_10119710; // weak
_UNKNOWN unk_10119714; // weak
_UNKNOWN unk_10119734; // weak
_UNKNOWN unk_10119754; // weak
_UNKNOWN unk_10119774; // weak
_UNKNOWN unk_10119794; // weak
_UNKNOWN unk_101197B4; // weak
_UNKNOWN unk_101197D4; // weak
_UNKNOWN unk_101197F4; // weak
_UNKNOWN unk_10119814; // weak
_UNKNOWN unk_10119834; // weak
_UNKNOWN unk_10119854; // weak
_UNKNOWN unk_10119874; // weak
_UNKNOWN unk_10119894; // weak
_UNKNOWN unk_101198B4; // weak
_UNKNOWN unk_101198D4; // weak
_UNKNOWN unk_101198F4; // weak
_UNKNOWN unk_10119914; // weak
_UNKNOWN unk_10119934; // weak
_UNKNOWN unk_10119954; // weak
_UNKNOWN unk_10119974; // weak
_UNKNOWN unk_10119994; // weak
_UNKNOWN unk_101199B4; // weak
_UNKNOWN unk_101199D4; // weak
_UNKNOWN unk_101199F4; // weak
_UNKNOWN unk_10119A14; // weak
_UNKNOWN unk_10119A34; // weak
_UNKNOWN unk_10119A54; // weak
_UNKNOWN unk_10119A74; // weak
_UNKNOWN unk_10119A94; // weak
_UNKNOWN unk_10119A98; // weak
_UNKNOWN unk_10119A9C; // weak
_UNKNOWN unk_10119AA0; // weak
_UNKNOWN unk_10119AA4; // weak
_UNKNOWN unk_10119AA8; // weak
_UNKNOWN unk_10119AAC; // weak
_UNKNOWN unk_10119ACC; // weak
_UNKNOWN unk_10119AEC; // weak
_UNKNOWN unk_10119B0C; // weak
_UNKNOWN unk_10119B2C; // weak
_UNKNOWN unk_10119B4C; // weak
_UNKNOWN unk_10119B6C; // weak
_UNKNOWN unk_10119B8C; // weak
_UNKNOWN unk_10119BAC; // weak
_UNKNOWN unk_10119BAD; // weak
_UNKNOWN unk_10119BAE; // weak
_UNKNOWN unk_10119C00; // weak
_UNKNOWN unk_10119C20; // weak
_UNKNOWN unk_10119C40; // weak
_UNKNOWN unk_10119C44; // weak
_UNKNOWN unk_10119C48; // weak
_UNKNOWN unk_10119C4C; // weak
_UNKNOWN unk_10119C6C; // weak
_UNKNOWN unk_10119C8C; // weak
_UNKNOWN unk_10119CAC; // weak
_UNKNOWN unk_10119CCC; // weak
_UNKNOWN unk_10119CEC; // weak
_UNKNOWN unk_10119D0C; // weak
_UNKNOWN unk_10119D2C; // weak
_UNKNOWN unk_10119D4C; // weak
_UNKNOWN unk_10119D6C; // weak
_UNKNOWN unk_10119DB4; // weak
_UNKNOWN unk_10119DFC; // weak
_UNKNOWN unk_10119E44; // weak
_UNKNOWN unk_10119E8C; // weak
_UNKNOWN unk_10119ED4; // weak
_UNKNOWN unk_10119F1C; // weak
_UNKNOWN unk_10119F64; // weak
_UNKNOWN unk_10119FAC; // weak
_UNKNOWN unk_10119FF4; // weak
_UNKNOWN unk_1011A03C; // weak
_UNKNOWN unk_1011A084; // weak
_UNKNOWN unk_1011A0CC; // weak
_UNKNOWN unk_1011A114; // weak
_UNKNOWN unk_1011A15C; // weak
_UNKNOWN unk_1011A1A4; // weak
_UNKNOWN unk_1011A1EC; // weak
_UNKNOWN unk_1011A234; // weak
_UNKNOWN unk_1011A27C; // weak
_UNKNOWN unk_1011A2C4; // weak
_UNKNOWN unk_1011A30C; // weak
_UNKNOWN unk_1011A354; // weak
_UNKNOWN unk_1011A39C; // weak
_UNKNOWN unk_1011A3E4; // weak
_UNKNOWN unk_1011A42C; // weak
_UNKNOWN unk_1011A474; // weak
_UNKNOWN unk_1011A4BC; // weak
_UNKNOWN unk_1011A504; // weak
_UNKNOWN unk_1011A54C; // weak
_UNKNOWN unk_1011A594; // weak
_UNKNOWN unk_1011A5DC; // weak
_UNKNOWN unk_1011A5F4; // weak
_UNKNOWN unk_1011A614; // weak
_UNKNOWN unk_1011A634; // weak
_UNKNOWN unk_1011A638; // weak
_UNKNOWN unk_1011A6DC; // weak
_UNKNOWN unk_1011A780; // weak
_UNKNOWN unk_1011A824; // weak
_UNKNOWN unk_1011A8C8; // weak
_UNKNOWN unk_1011A96C; // weak
_UNKNOWN unk_1011AA10; // weak
_UNKNOWN unk_1011AAB4; // weak
_UNKNOWN unk_1011AB58; // weak
_UNKNOWN unk_1011ABFC; // weak
_UNKNOWN unk_1011ACA0; // weak
_UNKNOWN unk_1011AD44; // weak
_UNKNOWN unk_1011ADE8; // weak
_UNKNOWN unk_1011AE8C; // weak
_UNKNOWN unk_1011AF30; // weak
_UNKNOWN unk_1011AFD4; // weak
_UNKNOWN unk_1011B078; // weak
_UNKNOWN unk_1011B11C; // weak
_UNKNOWN unk_1011B1C0; // weak
_UNKNOWN unk_1011B264; // weak
_UNKNOWN unk_1011B308; // weak
_UNKNOWN unk_1011B3AC; // weak
_UNKNOWN unk_1011B450; // weak
_UNKNOWN unk_1011B4F4; // weak
_UNKNOWN unk_1011B598; // weak
_UNKNOWN unk_1011B63C; // weak
_UNKNOWN unk_1011B6E0; // weak
_UNKNOWN unk_1011B784; // weak
_UNKNOWN unk_1011B828; // weak
_UNKNOWN unk_1011B8CC; // weak
_UNKNOWN unk_1011B970; // weak
_UNKNOWN unk_1011BA14; // weak
_UNKNOWN unk_1011BAB8; // weak
_UNKNOWN unk_1011BB5C; // weak
_UNKNOWN unk_1011BC00; // weak
_UNKNOWN unk_1011BCA4; // weak
_UNKNOWN unk_1011BD48; // weak
_UNKNOWN unk_1011BDEC; // weak
_UNKNOWN unk_1011BE90; // weak
_UNKNOWN unk_1011BF34; // weak
_UNKNOWN unk_1011BFD8; // weak
_UNKNOWN unk_1011C07C; // weak
_UNKNOWN unk_1011C120; // weak
_UNKNOWN unk_1011C1C4; // weak
_UNKNOWN unk_1011C268; // weak
_UNKNOWN unk_1011C30C; // weak
_UNKNOWN unk_1011C3B0; // weak
_UNKNOWN unk_1011C454; // weak
_UNKNOWN unk_1011C4F8; // weak
_UNKNOWN unk_1011C59C; // weak
_UNKNOWN unk_1011C640; // weak
_UNKNOWN unk_1011C6E4; // weak
_UNKNOWN unk_1011C788; // weak
_UNKNOWN unk_1011C82C; // weak
_UNKNOWN unk_1011C8D0; // weak
_UNKNOWN unk_1011C974; // weak
_UNKNOWN unk_1011CA18; // weak
_UNKNOWN unk_1011CABC; // weak
_UNKNOWN unk_1011CB60; // weak
_UNKNOWN unk_1011CC04; // weak
_UNKNOWN unk_1011CCA8; // weak
_UNKNOWN unk_1011CD4C; // weak
_UNKNOWN unk_1011CDF0; // weak
_UNKNOWN unk_1011CE94; // weak
_UNKNOWN unk_1011CF38; // weak
_UNKNOWN unk_1011CFDC; // weak
_UNKNOWN unk_1011D080; // weak
_UNKNOWN unk_1011D124; // weak
_UNKNOWN unk_1011D1C8; // weak
_UNKNOWN unk_1011D26C; // weak
_UNKNOWN unk_1011D310; // weak
_UNKNOWN unk_1011D3B4; // weak
_UNKNOWN unk_1011D458; // weak
_UNKNOWN unk_1011D4FC; // weak
_UNKNOWN unk_1011D5A0; // weak
_UNKNOWN unk_1011D644; // weak
_UNKNOWN unk_1011D6E8; // weak
_UNKNOWN unk_1011D78C; // weak
_UNKNOWN unk_1011D830; // weak
_UNKNOWN unk_1011D8D4; // weak
_UNKNOWN unk_1011D978; // weak
_UNKNOWN unk_1011DA1C; // weak
_UNKNOWN unk_1011DAC0; // weak
_UNKNOWN unk_1011DB64; // weak
_UNKNOWN unk_1011DC08; // weak
_UNKNOWN unk_1011DCAC; // weak
_UNKNOWN unk_1011DD50; // weak
_UNKNOWN unk_1011DDF4; // weak
_UNKNOWN unk_1011DE98; // weak
_UNKNOWN unk_1011DF3C; // weak
_UNKNOWN unk_1011DFE0; // weak
_UNKNOWN unk_1011E084; // weak
_UNKNOWN unk_1011E128; // weak
_UNKNOWN unk_1011E1CC; // weak
_UNKNOWN unk_1011E270; // weak
_UNKNOWN unk_1011E314; // weak
_UNKNOWN unk_1011E3B8; // weak
_UNKNOWN unk_1011E45C; // weak
_UNKNOWN unk_1011E500; // weak
_UNKNOWN unk_1011E5A4; // weak
_UNKNOWN unk_1011E648; // weak
_UNKNOWN unk_1011E668; // weak
_UNKNOWN unk_1011E688; // weak
_UNKNOWN unk_1011E6A8; // weak
_UNKNOWN unk_1011E6C8; // weak
_UNKNOWN unk_1011E6F0; // weak
_UNKNOWN unk_1011E70C; // weak
_UNKNOWN unk_1011E728; // weak
_UNKNOWN unk_1011E744; // weak
_UNKNOWN unk_1011E760; // weak
_UNKNOWN unk_1011E77C; // weak
_UNKNOWN unk_1011E798; // weak
_UNKNOWN unk_1011E7B4; // weak
_UNKNOWN unk_1011E7D0; // weak
_UNKNOWN unk_1011E7EC; // weak
_UNKNOWN unk_1011E808; // weak
_UNKNOWN unk_1011E824; // weak
_UNKNOWN unk_1011E840; // weak
_UNKNOWN unk_1011E85C; // weak
_UNKNOWN unk_1011E878; // weak
_UNKNOWN unk_1011E894; // weak
_UNKNOWN unk_1011E8B0; // weak
_UNKNOWN unk_1011E8CC; // weak
_UNKNOWN unk_1011E8E8; // weak
_UNKNOWN unk_1011E904; // weak
_UNKNOWN unk_1011E920; // weak
_UNKNOWN unk_1011E93C; // weak
_UNKNOWN unk_1011E958; // weak
_UNKNOWN unk_1011E974; // weak
_UNKNOWN unk_1011E990; // weak
_UNKNOWN unk_1011E9AC; // weak
_UNKNOWN unk_1011E9C8; // weak
_UNKNOWN unk_1011E9E4; // weak
_UNKNOWN unk_1011EA00; // weak
_UNKNOWN unk_1011EA1C; // weak
_UNKNOWN unk_1011EA38; // weak
_UNKNOWN unk_1011EA54; // weak
_UNKNOWN unk_1011EA70; // weak
_UNKNOWN unk_1011EA8C; // weak
_UNKNOWN unk_1011EAA8; // weak
_UNKNOWN unk_1011EAC4; // weak
_UNKNOWN unk_1011EAE0; // weak
_UNKNOWN unk_1011EAFC; // weak
_UNKNOWN unk_1011EB18; // weak
_UNKNOWN unk_1011EB34; // weak
_UNKNOWN unk_1011EB50; // weak
_UNKNOWN unk_1011EB6C; // weak
_UNKNOWN unk_1011EB88; // weak
_UNKNOWN unk_1011EBA4; // weak
_UNKNOWN unk_1011EBC0; // weak
_UNKNOWN unk_1011EBDC; // weak
_UNKNOWN unk_1011EBF8; // weak
_UNKNOWN unk_1011EC14; // weak
_UNKNOWN unk_1011EC30; // weak
_UNKNOWN unk_1011EC4C; // weak
_UNKNOWN unk_1011EC68; // weak
_UNKNOWN unk_1011EC84; // weak
_UNKNOWN unk_1011ECA0; // weak
_UNKNOWN unk_1011ECBC; // weak
_UNKNOWN unk_1011ECD8; // weak
_UNKNOWN unk_1011ECF4; // weak
_UNKNOWN unk_1011ED10; // weak
_UNKNOWN unk_1011ED2C; // weak
_UNKNOWN unk_1011ED48; // weak
_UNKNOWN unk_1011ED64; // weak
_UNKNOWN unk_1011ED80; // weak
_UNKNOWN unk_1011ED9C; // weak
_UNKNOWN unk_1011EDB8; // weak
_UNKNOWN unk_1011EDD4; // weak
_UNKNOWN unk_1011EDF0; // weak
_UNKNOWN unk_1011EE0C; // weak
_UNKNOWN unk_1011EE28; // weak
_UNKNOWN unk_1011EE44; // weak
_UNKNOWN unk_1011EE60; // weak
_UNKNOWN unk_1011EE7C; // weak
_UNKNOWN unk_1011EE98; // weak
_UNKNOWN unk_1011EEB4; // weak
_UNKNOWN unk_1011EED0; // weak
_UNKNOWN unk_1011EEEC; // weak
_UNKNOWN unk_1011EF08; // weak
_UNKNOWN unk_1011EF24; // weak
_UNKNOWN unk_1011EF40; // weak
_UNKNOWN unk_1011EF5C; // weak
_UNKNOWN unk_1011EF78; // weak
_UNKNOWN unk_1011EF94; // weak
_UNKNOWN unk_1011EFB0; // weak
_UNKNOWN unk_1011EFCC; // weak
_UNKNOWN unk_1011EFE8; // weak
_UNKNOWN unk_1011F004; // weak
_UNKNOWN unk_1011F020; // weak
_UNKNOWN unk_1011F03C; // weak
_UNKNOWN unk_1011F058; // weak
_UNKNOWN unk_1011F074; // weak
_UNKNOWN unk_1011F090; // weak
_UNKNOWN unk_1011F0AC; // weak
_UNKNOWN unk_1011F0C8; // weak
_UNKNOWN unk_1011F0E4; // weak
_UNKNOWN unk_1011F100; // weak
_UNKNOWN unk_1011F11C; // weak
_UNKNOWN unk_1011F138; // weak
_UNKNOWN unk_1011F154; // weak
_UNKNOWN unk_1011F170; // weak
_UNKNOWN unk_1011F18C; // weak
_UNKNOWN unk_1011F1A8; // weak
_UNKNOWN unk_1011F1C4; // weak
_UNKNOWN unk_1011F1E0; // weak
_UNKNOWN unk_1011F1E4; // weak
_UNKNOWN unk_1011F1E8; // weak
_UNKNOWN unk_1011F1EC; // weak
_UNKNOWN unk_1011F1F0; // weak
_UNKNOWN unk_1011F1F4; // weak
_UNKNOWN unk_1011F1F8; // weak
_UNKNOWN unk_1011F1FC; // weak
_UNKNOWN unk_1011F200; // weak
_UNKNOWN unk_1011F204; // weak
_UNKNOWN unk_1011F208; // weak
_UNKNOWN unk_1011F20C; // weak
_UNKNOWN unk_1011F210; // weak
_UNKNOWN unk_1011F214; // weak
_UNKNOWN unk_1011F218; // weak
_UNKNOWN unk_1011F21C; // weak
_UNKNOWN unk_1011F220; // weak
_UNKNOWN unk_1011F224; // weak
_UNKNOWN unk_1011F228; // weak
_UNKNOWN unk_1011F30C; // weak
_UNKNOWN unk_101204CC; // weak
_UNKNOWN unk_101204D0; // weak
_UNKNOWN unk_101204F8; // weak
_UNKNOWN unk_10120520; // weak
_UNKNOWN unk_10120560; // weak
_UNKNOWN unk_101205E0; // weak
_UNKNOWN unk_101205E4; // weak
_UNKNOWN unk_101205E8; // weak
_UNKNOWN unk_101205EA; // weak
_UNKNOWN unk_101205EC; // weak
_UNKNOWN unk_101205ED; // weak
_UNKNOWN unk_101205EE; // weak
_UNKNOWN unk_101205F0; // weak
_UNKNOWN unk_10120654; // weak
_UNKNOWN unk_1012065C; // weak
_UNKNOWN unk_10120664; // weak
_UNKNOWN unk_1012066C; // weak
_UNKNOWN unk_10120674; // weak
_UNKNOWN unk_1012067C; // weak
_UNKNOWN unk_10120684; // weak
_UNKNOWN unk_1012068C; // weak
_UNKNOWN unk_10120694; // weak
_UNKNOWN unk_1012069C; // weak
_UNKNOWN unk_101206A4; // weak
_UNKNOWN unk_101206AC; // weak
_UNKNOWN unk_101206B4; // weak
_UNKNOWN unk_101206BC; // weak
_UNKNOWN unk_101206C4; // weak
_UNKNOWN unk_101206CC; // weak
_UNKNOWN unk_101206D4; // weak
_UNKNOWN unk_101206DC; // weak
_UNKNOWN unk_101206E4; // weak
_UNKNOWN unk_101206EC; // weak
_UNKNOWN unk_101206F4; // weak
_UNKNOWN unk_101206FC; // weak
_UNKNOWN unk_10120704; // weak
_UNKNOWN unk_1012070C; // weak
_UNKNOWN unk_10120714; // weak
_UNKNOWN unk_1012071C; // weak
_UNKNOWN unk_10120724; // weak
_UNKNOWN unk_1012072C; // weak
_UNKNOWN unk_10120734; // weak
_UNKNOWN unk_1012073C; // weak
_UNKNOWN unk_10120744; // weak
_UNKNOWN unk_1012074C; // weak
_UNKNOWN unk_10120754; // weak
_UNKNOWN unk_1012075C; // weak
_UNKNOWN unk_10120764; // weak
_UNKNOWN unk_1012076C; // weak
_UNKNOWN unk_10120774; // weak
_UNKNOWN unk_1012077C; // weak
_UNKNOWN unk_10120784; // weak
_UNKNOWN unk_1012078C; // weak
_UNKNOWN unk_10120974; // weak
_UNKNOWN unk_10120984; // weak
_UNKNOWN unk_10120994; // weak
_UNKNOWN unk_101209A4; // weak
_UNKNOWN unk_101209A5; // weak
_UNKNOWN unk_101209A6; // weak
_UNKNOWN unk_101209A8; // weak
_UNKNOWN unk_101209AC; // weak
_UNKNOWN unk_10120A54; // weak
_UNKNOWN unk_10120A58; // weak
_UNKNOWN unk_10120A5C; // weak
_UNKNOWN unk_10120AAC; // weak
_UNKNOWN unk_10120AB0; // weak
_UNKNOWN unk_10120AB4; // weak
_UNKNOWN unk_10120BA4; // weak
_UNKNOWN unk_10120C94; // weak
_UNKNOWN unk_10120C98; // weak
_UNKNOWN unk_10120CA0; // weak
_UNKNOWN unk_10120CA8; // weak
_UNKNOWN unk_10120CB0; // weak
_UNKNOWN unk_10120CB8; // weak
_UNKNOWN unk_10120CC0; // weak
_UNKNOWN unk_10120CC8; // weak
_UNKNOWN unk_10120CD0; // weak
_UNKNOWN unk_10120CD8; // weak
_UNKNOWN unk_10120CE0; // weak
_UNKNOWN unk_10120CE8; // weak
_UNKNOWN unk_10120CF0; // weak
_UNKNOWN unk_10120CF4; // weak
_UNKNOWN unk_10120CF8; // weak
_UNKNOWN unk_10120CFC; // weak
_UNKNOWN unk_10120D50; // weak
_UNKNOWN unk_10120DA4; // weak
_UNKNOWN unk_10120DAC; // weak
_UNKNOWN unk_10120DB0; // weak
_UNKNOWN unk_10120DB4; // weak
_UNKNOWN unk_10120DB8; // weak
_UNKNOWN unk_10120DBC; // weak
_UNKNOWN unk_10120FC4; // weak
_UNKNOWN unk_10121124; // weak
_UNKNOWN unk_1012113C; // weak
_UNKNOWN unk_10121154; // weak
_UNKNOWN unk_1012115E; // weak
_UNKNOWN unk_10121160; // weak
_UNKNOWN unk_10121170; // weak
_UNKNOWN unk_10121174; // weak
_UNKNOWN unk_10121178; // weak
_UNKNOWN unk_1012117C; // weak
_UNKNOWN unk_1012117D; // weak
_UNKNOWN unk_10121180; // weak
_UNKNOWN unk_101211D0; // weak
_UNKNOWN unk_101211D4; // weak
_UNKNOWN unk_101211D5; // weak
_UNKNOWN unk_101211D6; // weak
_UNKNOWN unk_101211D7; // weak
_UNKNOWN unk_101211EB; // weak
_UNKNOWN unk_101211EC; // weak
_UNKNOWN unk_101211ED; // weak
_UNKNOWN unk_101211EE; // weak
_UNKNOWN unk_101211F0; // weak
_UNKNOWN unk_10121290; // weak
_UNKNOWN unk_101212E0; // weak
_UNKNOWN unk_101212E4; // weak
_UNKNOWN unk_101212E8; // weak
_UNKNOWN unk_101212EC; // weak
_UNKNOWN unk_101212F0; // weak
_UNKNOWN unk_101212F4; // weak
_UNKNOWN unk_101212F8; // weak
_UNKNOWN unk_101212FC; // weak
_UNKNOWN unk_10121300; // weak
_UNKNOWN unk_10121304; // weak
_UNKNOWN unk_10121308; // weak
_UNKNOWN unk_1012130C; // weak
_UNKNOWN unk_10121310; // weak
_UNKNOWN unk_10121450; // weak
_UNKNOWN unk_1012145C; // weak
_UNKNOWN unk_101214A4; // weak
_UNKNOWN unk_101214A5; // weak
_UNKNOWN unk_101214D0; // weak
_UNKNOWN unk_10121500; // weak
_UNKNOWN unk_10121528; // weak
_UNKNOWN unk_1012152C; // weak
_UNKNOWN unk_10121530; // weak
_UNKNOWN unk_10121534; // weak
_UNKNOWN unk_10121564; // weak
_UNKNOWN unk_10121565; // weak
_UNKNOWN unk_10121566; // weak
_UNKNOWN unk_10121568; // weak
_UNKNOWN unk_1012156C; // weak
_UNKNOWN unk_10121570; // weak
_UNKNOWN unk_10121574; // weak
_UNKNOWN unk_10121578; // weak
_UNKNOWN unk_1012157C; // weak
_UNKNOWN unk_10121580; // weak
_UNKNOWN unk_10121584; // weak
_UNKNOWN unk_10121588; // weak
_UNKNOWN unk_1012158C; // weak
_UNKNOWN unk_101218EC; // weak
_UNKNOWN unk_101218F0; // weak
_UNKNOWN unk_101218FA; // weak
_UNKNOWN unk_10121904; // weak
int dword_101230C0; // weak
int dword_101230C4; // weak
int dword_101230C8; // weak
int dword_101230CC; // weak
int dword_101230D0; // weak
int dword_101230D4; // weak
int dword_101230D8; // weak
int dword_101230DC; // weak
int dword_101230E0; // weak
int dword_101230E4; // weak
int dword_101230E8; // weak
int dword_101230EC; // weak
int dword_101230F0; // weak
int dword_10130840; // weak
_UNKNOWN unk_10130848; // weak
char byte_10130B20[]; // weak
char byte_10130B21[]; // weak
char byte_10130B40[]; // weak
char byte_10130B41[]; // weak
_UNKNOWN unk_10131D88; // weak
_UNKNOWN unk_10133738; // weak
int dword_1013373C; // weak
int dword_10133740; // weak
int dword_10133744; // weak
int dword_10133748; // weak
char byte_1013374C; // weak
_UNKNOWN unk_10133750; // weak
_UNKNOWN unk_10133754; // weak
int dword_10133758; // weak
int dword_1013375C; // weak
int dword_101337F0[]; // weak
int dword_101337F4; // weak
int dword_101337F8; // weak
int dword_101337FC; // weak
int dword_10133800; // weak
int dword_10133804[]; // weak
int dword_10133808; // weak
int dword_1013380C; // weak
int dword_10133810; // weak
int dword_10133814; // weak
_UNKNOWN unk_10133818; // weak
char byte_10133930; // idb
char byte_10133A30[254]; // idb
char byte_10133B2E[]; // weak
char byte_10133B2F[]; // weak
char byte_10133F30[2800]; // idb
char byte_10134A20[1022]; // idb
char byte_10134E1E[]; // weak
char byte_10134E1F[]; // weak
char byte_10134E20[1022]; // idb
char byte_1013521E[]; // weak
char byte_1013521F[]; // weak
char byte_10135220[1022]; // idb
char byte_1013561E[]; // weak
char byte_1013561F[]; // weak
int dword_10138620[]; // weak
int dword_10138634[]; // weak
char byte_10138648[2800]; // idb
char byte_10139138[2800]; // idb
char byte_10139C28[2800]; // idb
int dword_1013A718[]; // weak
int dword_1013A72C[]; // weak
char byte_1013A740[2796]; // idb
char byte_1013B22C[]; // weak
char byte_1013B230[559]; // idb
char byte_1013B45F[]; // weak
int dword_1013BD20[]; // weak
int dword_1013BD34[]; // weak
char byte_1013BD48[2800]; // idb
int dword_1013C838; // weak
_UNKNOWN unk_1013C840; // weak
_UNKNOWN unk_1013D398; // weak
int dword_1013F700; // weak
_UNKNOWN unk_1013F708; // weak
int dword_10140C48; // weak
char byte_10140C50[]; // weak
char byte_10140C54[]; // weak
char byte_10140C55[]; // weak
int dword_10140C5C[]; // weak
int dword_10140C64[]; // weak
int dword_10140C98; // weak
int dword_10140C9C; // weak
int dword_10140CA0; // weak
int dword_10140CA4; // weak
_UNKNOWN unk_10140CA8; // weak
_UNKNOWN unk_10140CB0; // weak
_UNKNOWN unk_10140CB8; // weak
int dword_101A0A10; // weak
char byte_101A0A18[]; // weak
char byte_101A0A68[]; // weak
char byte_101A7DB8; // weak
char byte_101A7DB9; // weak
_UNKNOWN unk_101A7DC8; // weak
_UNKNOWN unk_101AACD0; // weak
_UNKNOWN unk_101AB1D0; // weak
_UNKNOWN unk_101AB278; // weak
char byte_101ADB30[]; // weak
char byte_101ADB31[]; // weak
_UNKNOWN unk_101ADBD0; // weak
int dword_101ADEA0[]; // weak
int dword_101ADEA4[]; // weak
char byte_101AE3C0; // weak
char byte_101AE3C1; // weak
char byte_101AE3C2; // weak
char byte_101AE3C3; // weak
_UNKNOWN unk_101AE3C8; // weak
_UNKNOWN unk_101AE3E8; // weak
int dword_101AF4A4; // weak
int dword_101AF7D0; // weak
int dword_101AF7DC; // weak
int dword_101AF938; // weak
int dword_101AFE00; // weak
int dword_101AFE0C; // weak
int dword_101AFE18; // weak
int dword_101AFE1C; // weak
int dword_101AFE20; // weak
int dword_101AFE3C; // weak
int dword_101AFE40; // weak
int dword_101AFE44; // weak
int dword_101AFE48; // weak
int dword_101AFE4C; // weak
char byte_101B0230; // weak
int dword_101B0240; // weak
_UNKNOWN unk_101B0244; // weak
char byte_101E2260; // weak
char byte_101E2261; // weak
char byte_101E2262; // weak
char byte_101E2264; // weak
char byte_101E226B; // weak
__int16 word_101E226E; // weak
__int16 word_101E2270; // weak
__int16 word_101E2274; // weak
int dword_101E2278; // weak
int dword_101E227C; // weak
int dword_101E2294; // weak
int dword_101E22A0; // weak
int dword_101E22A8; // weak
char byte_101E23E8; // weak
int dword_101E243C; // weak
char byte_101E2440; // weak
int dword_101E2460[]; // weak
char byte_101E2464[]; // weak
int dword_101E2670; // weak
int dword_101E2674; // weak
int dword_101E26B8; // weak
int dword_101E26BC; // weak
int dword_101E2708; // weak
int dword_101E270C; // weak
int dword_101E28C8; // weak
int dword_101E28CC; // weak
int dword_101E28D0; // weak
char byte_101E28D4; // weak
int dword_101E28D8; // weak
char byte_101E28DC; // weak
int dword_101E28E0; // weak
char byte_101E28E4; // weak
int dword_101E28E8; // weak
int dword_101E28EC; // weak
_UNKNOWN unk_101E2900; // weak
int dword_101E29CC; // weak
int dword_101E29D0; // weak
int dword_101E29E0; // weak
int dword_101E29E4; // weak
int dword_101E29E8; // weak
int dword_101E29EC; // weak
int dword_101E29F0; // weak
char byte_101E29F4; // weak
int dword_101E2A00[]; // weak
__int16 word_101E2A04[]; // weak
int dword_101E2A08[]; // weak
int dword_101E2A0C; // weak
int dword_101E2A10; // weak
int dword_101E2A14; // weak
int dword_101E2A18; // weak
__int16 word_101E2A1C; // weak
int dword_101E2A20; // weak
int dword_101E2A68; // weak
int dword_101E2A84; // weak
__int16 word_101E2A88; // weak
int dword_101E2AC8; // weak
int dword_101E2AF8; // weak
int dword_101E2B40; // weak
int dword_101E2BE8; // weak
int dword_101E2BF4; // weak
int dword_101E2C04; // weak
__int16 word_101E2C08; // weak
int dword_101E2C10; // weak
__int16 word_101E2C14; // weak
int dword_101E2C1C; // weak
__int16 word_101E2C20; // weak
int dword_101E2D24; // weak
int dword_101E2D9C; // weak
__int16 word_101E2DA0; // weak
int dword_101E2E44; // weak
__int16 word_101E2E48; // weak
_UNKNOWN unk_101E3108; // weak
_UNKNOWN unk_101E3109; // weak
_UNKNOWN unk_101E310A; // weak
__int16 word_101E3120[]; // weak
__int16 word_101E3122; // weak
__int16 word_101E3124; // weak
__int16 word_101E3126; // weak
__int16 word_101E3128; // weak
__int16 word_101E312A; // weak
__int16 word_101E312C; // weak
__int16 word_101E312E; // weak
__int16 word_101E3144; // weak
__int16 word_101E3146; // weak
char byte_101E324C; // weak
char byte_101E324D; // weak
int dword_101E3250; // weak
char byte_101E3254; // weak
int dword_101E3258; // weak
int dword_101E325C; // weak
void *dword_101E3260; // idb
int dword_101E4280; // weak
int dword_101E429C; // weak
int dword_101E42A8; // weak
UINT uNumber; // idb
int dword_101E42C0[]; // weak
int dword_101E43C0; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_101E28C8;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 101E28C8: using guessed type int dword_101E28C8;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_10003970(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10003930: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10003950: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10003960: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 100039C0: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100028D0(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10003CC0();
        sub_10003D10(1);
        v6 = sub_10003C80(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_100E0890;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10003CC0();
      sub_10003D10(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10003C80(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10003C10(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 100530B8: using guessed type void *off_100530B8;

//----- (100012C0) --------------------------------------------------------
char __cdecl sub_100012C0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10003C10(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = &unk_100E0890;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&off_100530B8 + 1);
      *(_DWORD *)(v7 + 8) = *(&off_100530B8 + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_10004B60(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10003C10(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10003950: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100530B8: using guessed type void *off_100530B8;

//----- (100014B0) --------------------------------------------------------
signed int sub_100014B0()
{
  char *v0; // eax@1
  signed int result; // eax@3

  v0 = byte_101E2464;
  do
  {
    *((_DWORD *)v0 - 1) = 0;
    *v0 = 0;
    v0 += 8;
  }
  while ( (signed int)v0 < (signed int)&dword_101E28CC );
  dword_101E2670 = (int)sub_1000CCE0;
  result = 4;
  dword_101E2674 = 8;
  dword_101E26B8 = (int)sub_1000CB90;
  dword_101E26BC = 4;
  dword_101E2708 = (int)sub_1000B760;
  dword_101E270C = 12;
  return result;
}
// 101E2670: using guessed type int dword_101E2670;
// 101E2674: using guessed type int dword_101E2674;
// 101E26B8: using guessed type int dword_101E26B8;
// 101E26BC: using guessed type int dword_101E26BC;
// 101E2708: using guessed type int dword_101E2708;
// 101E270C: using guessed type int dword_101E270C;
// 101E28CC: using guessed type int dword_101E28CC;

//----- (10001510) --------------------------------------------------------
int __cdecl sub_10001510(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (10001540) --------------------------------------------------------
signed int sub_10001540()
{
  signed int result; // eax@1

  byte_101E2440 = 0;
  sub_10010A00(&unk_100DF760);
  dword_100DF83C = (int)sub_10003520;
  result = 12;
  dword_100DF840 = 0;
  dword_100DF844[0] = 42066;
  dword_100DF848 = 12;
  dword_100DF84C[0] = 42066;
  return result;
}
// 100DF83C: using guessed type int dword_100DF83C;
// 100DF840: using guessed type int dword_100DF840;
// 100DF844: using guessed type int dword_100DF844[];
// 100DF848: using guessed type int dword_100DF848;
// 100DF84C: using guessed type int dword_100DF84C[];
// 101E2440: using guessed type char byte_101E2440;

//----- (10001560) --------------------------------------------------------
int __cdecl sub_10001560(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10003C10(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10002850(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10002850(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10002850(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10002850(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (100015F0) --------------------------------------------------------
char __cdecl sub_100015F0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10003F10(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003C10(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10001660) --------------------------------------------------------
char __cdecl sub_10001660(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10003F10(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003C10(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (100016D0) --------------------------------------------------------
int sub_100016D0()
{
  int result; // eax@1

  result = sub_10003DB0();
  dword_100DF768 = result;
  byte_100DF764 = 0;
  return result;
}
// 100DF764: using guessed type char byte_100DF764;
// 100DF768: using guessed type int dword_100DF768;

//----- (100016F0) --------------------------------------------------------
_DWORD *__cdecl sub_100016F0(int a1)
{
  return sub_10010A40(&unk_100DF760, a1);
}

//----- (10001710) --------------------------------------------------------
void __usercall sub_10001710(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10003920();
    sub_10003CC0();
    *(_DWORD *)(a1 + 28) = sub_10003C80(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
  }
}

//----- (10001740) --------------------------------------------------------
int __usercall sub_10001740@<eax>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  int result; // eax@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_101B0230 = *v1 == -32749;
  byte_101E2440 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_10004120(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_10011250(v3) != 2 && v7 & 0x1C )
  {
    byte_101B0230 = 0;
    byte_101E2440 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_10010E50() )
  {
    byte_101B0230 = 0;
    byte_101E2440 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_10010B70(a1, (char *)v5, (int)&unk_100648D4);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = nullsub_1(a1, v2);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101B0230: using guessed type char byte_101B0230;
// 101E2440: using guessed type char byte_101E2440;

//----- (10001820) --------------------------------------------------------
void __usercall sub_10001820(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_10003880(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_100038D0(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_10003880(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10003950: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (100018F0) --------------------------------------------------------
void __usercall sub_100018F0(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_10004C70(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001990) --------------------------------------------------------
int __usercall sub_10001990@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_100038D0(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_10003880(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001820(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_100018F0(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_100038D0(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10003940: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10003950: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100039B0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001B60) --------------------------------------------------------
char __thiscall sub_10001B60(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001B80) --------------------------------------------------------
signed int __cdecl sub_10001B80(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_100015F0(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_100015F0(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001CD0) --------------------------------------------------------
char __cdecl sub_10001CD0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100015F0(a1, (int)&v4, 8);
}

//----- (10001D00) --------------------------------------------------------
char __cdecl sub_10001D00(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001660(a1, (int)&v4, 8);
}

//----- (10001D30) --------------------------------------------------------
char __cdecl sub_10001D30(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10010A10((int *)&unk_100DF760, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10003740();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001740(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10001510(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_10010E50() != byte_100DF764 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100DF764 = sub_10010E50();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10002850(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_100503D0, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        nullsub_1(a1, v17);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001B60(a1) )
          (*(void (__cdecl **)(int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            sub_10003700(a1);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002510(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001CD0(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10003CB0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100DF764: using guessed type char byte_100DF764;

//----- (10002060) --------------------------------------------------------
int __usercall sub_10002060@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_10003D60(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_10003D60(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001D30(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001990(v1, (int)&off_100530B8);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 100530B8: using guessed type void *off_100530B8;

//----- (100020F0) --------------------------------------------------------
void __noreturn sub_100020F0()
{
  void *v0; // ecx@8
  unsigned int v1; // esi@16
  int v2; // eax@19
  int v3; // [sp+10h] [bp-ECh]@1
  char v4; // [sp+14h] [bp-E8h]@9
  char v5; // [sp+18h] [bp-E4h]@5

  dword_101E243C = (int)&dword_101B0240;
  sub_10003FF0(&v3);
  if ( !(v3 & 0x10) )
    sub_10003C10(".\\cdp_main.c", 403, 1, 0);
  v3 |= 0x10u;
  if ( !sub_10003F80(1, 20000) )
    sub_10003C10(".\\cdp_main.c", 428, 1, 0);
  sub_100117A0();
  sub_10011370(&v5);
  while ( 1 )
  {
    byte_101E23E8 = 0;
    if ( v3 & 0x10 || v3 & 0x8000 )
    {
      sub_10001510((int)&byte_101E2260);
      byte_101E2262 = sub_10010DC0(v0);
      byte_101E2264 = 0;
      dword_101E2294 = (int)&unk_100DF770;
      word_101E226E = 222;
      word_101E2270 = 306;
      dword_101E22A0 = 6;
      word_101E2274 = 250;
      dword_101E2278 = -1;
      dword_101E227C = -1;
      byte_101E226B = 1;
      dword_101E22A8 = 0;
      byte_101E2260 = 0;
      while ( sub_10003D60(dword_101E2294, (int)&v4) != 1 )
        ;
      sub_100014A0();
      sub_10002830((int)&byte_101E2260);
      sub_10003750((int)&byte_101E2260);
      sub_10011790((int)&unk_100503A8);
      sub_10011780((int)&unk_100503B0);
      sub_10001710((int)&byte_101E2260);
      sub_10003770((int)&byte_101E2260);
    }
    if ( v3 & 2 )
      sub_10002060((int)&byte_101E2260);
    if ( v3 & 1 )
    {
      v3 |= 0x20000000u;
      if ( (unsigned int)(sub_10003DB0() - dword_100DF768) >= 0x3E8 )
      {
        dword_100DF768 += 1000;
        j_nullsub_1(&byte_101E2260);
        sub_10011260((int *)&v5);
      }
    }
    v1 = 0x40000000;
    do
    {
      if ( v1 != 0x8000 && v1 & v3 )
      {
        v2 = sub_10010C20(v1);
        sub_10001B80((int)&byte_101E2260, v2);
        sub_10002060((int)&byte_101E2260);
      }
      v1 >>= 1;
    }
    while ( v1 >= 0x200 );
    if ( byte_101E23E8 || byte_101E2261 )
      sub_10001990((int)&byte_101E2260, (int)&off_100530B8);
    sub_10003FF0(&v3);
  }
}
// 100014A0: using guessed type int sub_100014A0(void);
// 10011770: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 100117A0: using guessed type int sub_100117A0(void);
// 100530B8: using guessed type void *off_100530B8;
// 100DF768: using guessed type int dword_100DF768;
// 101B0240: using guessed type int dword_101B0240;
// 101E2260: using guessed type char byte_101E2260;
// 101E2261: using guessed type char byte_101E2261;
// 101E2262: using guessed type char byte_101E2262;
// 101E2264: using guessed type char byte_101E2264;
// 101E226B: using guessed type char byte_101E226B;
// 101E226E: using guessed type __int16 word_101E226E;
// 101E2270: using guessed type __int16 word_101E2270;
// 101E2274: using guessed type __int16 word_101E2274;
// 101E2278: using guessed type int dword_101E2278;
// 101E227C: using guessed type int dword_101E227C;
// 101E2294: using guessed type int dword_101E2294;
// 101E22A0: using guessed type int dword_101E22A0;
// 101E22A8: using guessed type int dword_101E22A8;
// 101E23E8: using guessed type char byte_101E23E8;
// 101E243C: using guessed type int dword_101E243C;

//----- (10002330) --------------------------------------------------------
char __cdecl sub_10002330(char a1, char *a2)
{
  int v2; // eax@1
  char *v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@2
  int v6; // eax@2
  char result; // al@4
  char v8; // [sp+7h] [bp-1h]@3

  v2 = sub_100117D0(&a1, 4u, (int)&dword_100DF83C, 20, 1, -1);
  v3 = a2;
  *a2 = 0;
  if ( v2 < 0 )
    goto LABEL_4;
  v4 = 10 * v2;
  v5 = dword_100DF844[2 * v4 / 4u];
  v6 = 2 * v4;
  if ( v5 != 42066 )
  {
    sub_10004120(v5, &v8, 1, (char *)&dword_100DF840 + v6);
LABEL_4:
    result = v8;
    goto LABEL_5;
  }
  result = *((_BYTE *)&dword_100DF840 + v6);
LABEL_5:
  if ( (unsigned __int8)(result + 4) <= 7u )
    *v3 = result;
  return result;
}
// 100DF83C: using guessed type int dword_100DF83C;
// 100DF840: using guessed type int dword_100DF840;
// 100DF844: using guessed type int dword_100DF844[];

//----- (100023A0) --------------------------------------------------------
int __cdecl sub_100023A0(char a1, void *a2)
{
  int result; // eax@1
  void *v3; // edx@1
  int v4; // eax@2
  int v5; // ecx@2

  result = sub_100117D0(&a1, 4u, (int)&dword_100DF83C, 20, 1, -1);
  v3 = a2;
  *(_BYTE *)a2 = 16;
  if ( result >= 0 )
  {
    v4 = 10 * result;
    v5 = dword_100DF84C[2 * v4 / 4u];
    result = 2 * v4;
    if ( v5 == 42066 )
      *(_BYTE *)v3 = *((_BYTE *)&dword_100DF848 + result);
    else
      result = sub_10004120(v5, v3, 1, (char *)&dword_100DF848 + result);
  }
  return result;
}
// 100DF83C: using guessed type int dword_100DF83C;
// 100DF848: using guessed type int dword_100DF848;
// 100DF84C: using guessed type int dword_100DF84C[];

//----- (10002440) --------------------------------------------------------
int __cdecl sub_10002440(char a1, char a2)
{
  int result; // eax@1
  int v3; // eax@3
  int v4; // ecx@3

  result = sub_100117D0(&a1, 4u, (int)&dword_100DF83C, 20, 1, -1);
  if ( result >= 0 && (unsigned __int8)(a2 + 4) <= 7u )
  {
    v3 = 10 * result;
    v4 = dword_100DF844[2 * v3 / 4u];
    result = 2 * v3;
    if ( v4 == 42066 )
      *((_BYTE *)&dword_100DF840 + result) = a2;
    else
      result = sub_10004190(v4, (int)&a2, 1);
  }
  return result;
}
// 100DF83C: using guessed type int dword_100DF83C;
// 100DF840: using guessed type int dword_100DF840;
// 100DF844: using guessed type int dword_100DF844[];

//----- (100024A0) --------------------------------------------------------
int __cdecl sub_100024A0(char a1, char a2)
{
  int result; // eax@1
  int v3; // eax@2
  int v4; // ecx@2

  result = sub_100117D0(&a1, 4u, (int)&dword_100DF83C, 20, 1, -1);
  if ( result >= 0 )
  {
    v3 = 10 * result;
    v4 = dword_100DF84C[2 * v3 / 4u];
    result = 2 * v3;
    if ( v4 == 42066 )
      *((_BYTE *)&dword_100DF848 + result) = a2;
    else
      result = sub_10004190(v4, (int)&a2, 1);
  }
  return result;
}
// 100DF83C: using guessed type int dword_100DF83C;
// 100DF848: using guessed type int dword_100DF848;
// 100DF84C: using guessed type int dword_100DF84C[];

//----- (100024F0) --------------------------------------------------------
int __cdecl sub_100024F0(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002510) --------------------------------------------------------
char __cdecl sub_10002510(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_101B0244 || a2 >= dword_101B0240 )
    result = sub_10003C10(".\\cdp_mem.c", 222, 1, 0);
  dword_101B0240 = a2;
  return result;
}
// 101B0240: using guessed type int dword_101B0240;

//----- (10002550) --------------------------------------------------------
char sub_10002550()
{
  char result; // al@1

  byte_100DF850 = 0;
  result = sub_10004510((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100DF850 = 1;
  return result;
}
// 100DF850: using guessed type char byte_100DF850;

//----- (10002570) --------------------------------------------------------
char __thiscall sub_10002570(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10003DD0((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10011DD0(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_10004510((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10004380(v1, &byte_100DF858, 4096),
          sub_100042B0(v2),
          (v1 = (unsigned int)strstr(&byte_100DF858, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100DF858;
      v4 = v1 - (_DWORD)&byte_100DF858 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !(((unsigned __int8)byte_10067268[2 * (unsigned __int8)*(&byte_100DF858 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100DF858 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100E0858 = v1;
    }
    else
    {
      dword_100E0858 = 0;
    }
  }
  else
  {
    dword_100E0858 = 0;
  }
  return v1;
}
// 10004370: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100E0858: using guessed type int dword_100E0858;

//----- (100026E0) --------------------------------------------------------
int __cdecl sub_100026E0(int a1)
{
  unsigned int v1; // ecx@0
  int result; // eax@1
  unsigned int v3; // edi@1
  int v4; // eax@3
  unsigned int v5; // esi@3
  int v6; // edi@7
  char v7; // [sp+4h] [bp-160h]@3
  char v8; // [sp+18h] [bp-14Ch]@4
  char v9; // [sp+E0h] [bp-84h]@3

  result = a1;
  v3 = v1;
  if ( a1 && dword_100E0858 < v1 )
  {
    v4 = *(_DWORD *)(a1 + 64);
    dword_100E0858 = v1;
    sub_10003DD0((int)&v7, 1, v4, 20);
    sub_10011DD0(&v9, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v7);
    v5 = j_FIL_vfs_open(&v9, 10, 0);
    sub_10011C30((int)&byte_100DF858, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_10011C30((int)&v8, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_10011E00(&byte_100DF858, &v8, 4096);
    }
    sub_10011DD0(&v8, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v7, v3, 204800);
    result = sub_10011E00(&byte_100DF858, &v8, 4096);
    if ( v5 < 0xFFFFFFC2 )
    {
      if ( v5 )
      {
        v6 = sub_10011C80(&byte_100DF858, 0x1000u);
        j_FIL_vfs_write(v5, &byte_100DF858, v6);
        sub_100044C0(v5, v6, 0);
        result = sub_100042B0(v5);
      }
    }
  }
  return result;
}
// 10004370: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100E0858: using guessed type int dword_100E0858;

//----- (10002830) --------------------------------------------------------
char __cdecl sub_10002830(int a1)
{
  char result; // al@2

  dword_101B0240 = (int)&unk_101B0244;
  if ( byte_100DF850 )
    result = sub_10002570(a1);
  return result;
}
// 100DF850: using guessed type char byte_100DF850;
// 101B0240: using guessed type int dword_101B0240;

//----- (10002850) --------------------------------------------------------
int __cdecl sub_10002850(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100DF850 )
  {
    v3 = 4 * v2 - *(_DWORD *)(a1 + 476);
    sub_100026E0(a1);
  }
  if ( !a2 || (result = dword_101B0240, dword_101B0240 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_10003C10(".\\cdp_mem.c", 371, 1, 0);
    result = dword_101B0240;
  }
  dword_101B0240 = result + 4 * v2;
  return result;
}
// 100DF850: using guessed type char byte_100DF850;
// 101B0240: using guessed type int dword_101B0240;

//----- (100028D0) --------------------------------------------------------
int __cdecl sub_100028D0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_100024F0(a2, a3);
  return sub_10002850(a1, v3);
}

//----- (100028F0) --------------------------------------------------------
_WORD *__cdecl sub_100028F0(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10002850(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_100503D0, 0x14Cu);
  sub_10001560(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_10005870(a1 + 392, (int)&off_100530B8, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_10005810(a1 + 392);
}
// 100530B8: using guessed type void *off_100530B8;

//----- (10002960) --------------------------------------------------------
char sub_10002960()
{
  unsigned __int8 v0; // bl@1
  char v1; // al@2
  char v3; // [sp+7h] [bp-5h]@1
  unsigned __int8 v4; // [sp+8h] [bp-4h]@1

  v0 = 0;
  v3 = 0;
  v4 = 0;
  do
  {
    v1 = sub_10011E60(v4);
    if ( (unsigned __int8)v1 > (unsigned __int8)v3 )
      v3 = v1;
    v4 = ++v0;
  }
  while ( v0 < 0x34u );
  return v3;
}

//----- (100029A0) --------------------------------------------------------
BOOL __thiscall sub_100029A0(void *this)
{
  return sub_10010E30(this) == 1 || *(_BYTE *)dword_101E325C == 45 || *(_BYTE *)dword_101E325C == 46;
}
// 101E325C: using guessed type int dword_101E325C;

//----- (100029D0) --------------------------------------------------------
char __usercall sub_100029D0@<al>(int a1@<esi>)
{
  char result; // al@1

  sub_1000D290(a1, *(_WORD **)(a1 + 52), (char *)&unk_10051C14, (int)&unk_10051C30, 0, 255);
  result = sub_10001D00(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002A10) --------------------------------------------------------
int __usercall sub_10002A10@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = sub_10010B00(
             a1,
             *(_DWORD *)(a1 + 52),
             (char *)&unk_10051C24,
             *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 364));
  *(_BYTE *)(a1 + 6) = result;
  return result;
}

//----- (10002A40) --------------------------------------------------------
_WORD *__usercall sub_10002A40@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  _WORD *result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10010B00(a1, *(_DWORD *)(a1 + 52), (char *)&unk_10051C24, *(_DWORD *)(v1 + 364));
  result = *(_WORD **)(a1 + 52);
  *(_BYTE *)(a1 + 6) = (*result != -32665) + 1;
  if ( *result == -32683 )
  {
    sub_10013D30((int)&unk_100E0860);
    byte_100E086D = *(_BYTE *)(v1 + 116);
    result = (_WORD *)sub_10013D60((int)&unk_100E0860);
  }
  return result;
}

//----- (10002AA0) --------------------------------------------------------
int __cdecl sub_10002AA0(int a1)
{
  int result; // eax@1

  sub_10013D30((int)&unk_100E0860);
  result = a1;
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002AC0) --------------------------------------------------------
char __usercall sub_10002AC0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // eax@4
  int v3; // esi@27
  int v4; // esi@31
  int v5; // esi@35
  int v6; // esi@39
  char v8; // [sp+Bh] [bp-39h]@1
  char v9; // [sp+Ch] [bp-38h]@12
  char v10; // [sp+Dh] [bp-37h]@4
  char v11; // [sp+Eh] [bp-36h]@10
  char v12; // [sp+Fh] [bp-35h]@13
  char v13; // [sp+10h] [bp-34h]@15
  char v14; // [sp+11h] [bp-33h]@30
  char v15; // [sp+12h] [bp-32h]@34
  char v16; // [sp+13h] [bp-31h]@1
  int v17; // [sp+14h] [bp-30h]@1
  char v18; // [sp+18h] [bp-2Ch]@37
  char v19; // [sp+19h] [bp-2Bh]@37
  char v20; // [sp+1Bh] [bp-29h]@37
  char v21; // [sp+1Ch] [bp-28h]@8
  char v22; // [sp+20h] [bp-24h]@17
  char v23; // [sp+24h] [bp-20h]@19
  char v24; // [sp+28h] [bp-1Ch]@21
  char v25; // [sp+2Ch] [bp-18h]@33
  char v26; // [sp+2Dh] [bp-17h]@33
  char v27; // [sp+2Fh] [bp-15h]@33
  char v28; // [sp+34h] [bp-10h]@23
  char v29; // [sp+35h] [bp-Fh]@24

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v17 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12);
  v8 = 0;
  v16 = 0;
  sub_10013D30((int)&unk_100E0860);
  if ( (unsigned int)v17 > 0x26A2 )
  {
LABEL_40:
    LOBYTE(v2) = sub_10003C10(".\\cdp_pg_inst_map.c", 1093, 1, 0);
  }
  else if ( v17 == 9890 )
  {
    LOBYTE(v2) = sub_10004120(9890, &v8, 1, &v16);
    if ( v8 )
    {
      sub_1000B900();
      v6 = v1 + 28;
      sub_100080E0(v6);
      sub_10008060(a1, v6);
      v8 = 0;
      LOBYTE(v2) = sub_10004190(9890, (int)&v8, 1);
    }
  }
  else
  {
    switch ( v17 )
    {
      case 3060:
        v2 = sub_100040C0(3060, (int)&v10, 1);
        if ( !v2 && byte_100E0878 != 2 && !*(_BYTE *)(v1 + 361) )
        {
          sub_1000A640(a1, v1, v1 + 28, 0);
          LOBYTE(v2) = sub_1000BC20(34, -2, &v10);
        }
        break;
      case 3071:
        v2 = sub_100040C0(3071, (int)&v21, 4);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(30, -2, &v21);
        break;
      case 3061:
        v2 = sub_100040C0(3061, (int)&v11, 1);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(53, -2, &v11);
        break;
      case 3149:
        sub_10013D30((int)&unk_100E0860);
        v9 = 0;
        sub_10004120(3149, &byte_100E086B, 1, &v9);
        sub_1000BC20(51, -2, &byte_100E086B);
        LOBYTE(v2) = sub_10013D60((int)&unk_100E0860);
        break;
      case 3063:
        v2 = sub_100040C0(3063, (int)&v12, 1);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(61, -2, &v12);
        break;
      case 3065:
        v2 = sub_100040C0(3065, (int)&v13, 1);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(14, -2, &v13);
        break;
      case 3182:
        v2 = sub_100040C0(3182, (int)&v22, 4);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(16, -2, &v22);
        break;
      case 3183:
        v2 = sub_100040C0(3183, (int)&v23, 4);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(17, -2, &v23);
        break;
      case 3187:
        v2 = sub_100040C0(3187, (int)&v24, 4);
        if ( !v2 )
          LOBYTE(v2) = sub_1000BC20(18, -2, &v24);
        break;
      case 3073:
      case 3176:
        v2 = sub_100040C0(3073, (int)&v28, 1);
        if ( !v2 )
        {
          v2 = sub_100040C0(3176, (int)&v29, 1);
          if ( !v2 )
            LOBYTE(v2) = sub_1000BC20(63, -2, &v28);
        }
        break;
      case 3066:
      case 3070:
      case 3072:
      case 3074:
      case 3075:
      case 3141:
      case 3209:
        v2 = sub_100040C0(v17, (int)&v9, 1);
        if ( !v2 )
        {
          v3 = sub_100117D0(&v17, 4u, (int)&unk_10051DE8, 8, 7, -1);
          if ( v3 < 0 )
            sub_10003C10(".\\cdp_pg_inst_map.c", 1000, 1, 0);
          LOBYTE(v2) = sub_1000BC20((unsigned __int16)word_10051DEC[4 * v3], -2, &v9);
        }
        break;
      case 3076:
      case 3077:
      case 3078:
      case 3079:
      case 3080:
      case 3081:
      case 3082:
      case 3083:
      case 3084:
      case 3085:
      case 3086:
      case 3087:
      case 3088:
      case 3089:
      case 3090:
      case 3091:
      case 3092:
      case 3093:
      case 3094:
      case 3095:
      case 3096:
      case 3097:
      case 3098:
      case 3099:
      case 3100:
      case 3101:
      case 3102:
      case 3103:
      case 3104:
      case 3105:
      case 3106:
      case 3107:
      case 3108:
      case 3128:
      case 3142:
      case 3143:
      case 3151:
      case 3152:
      case 3154:
      case 3174:
        v2 = sub_100040C0(v17, (int)&v14, 1);
        if ( !v2 )
        {
          v4 = sub_100117D0(&v17, 4u, (int)&unk_10051C38, 8, 40, -1);
          if ( v4 < 0 )
            sub_10003C10(".\\cdp_pg_inst_map.c", 1054, 1, 0);
          v25 = byte_10051C3C[8 * v4];
          v26 = v14;
          v27 = 0;
          LOBYTE(v2) = sub_1000BC20(32, -2, &v25);
        }
        break;
      case 3109:
      case 3110:
      case 3111:
      case 3112:
      case 3113:
      case 3114:
      case 3115:
      case 3116:
      case 3117:
      case 3118:
      case 3119:
      case 3120:
      case 3121:
      case 3122:
        v2 = sub_100040C0(v17, (int)&v15, 1);
        if ( !v2 )
        {
          v5 = sub_100117D0(&v17, 4u, (int)&unk_10051D78, 8, 14, -1);
          if ( v5 < 0 )
            sub_10003C10(".\\cdp_pg_inst_map.c", 1082, 1, 0);
          v18 = byte_10051D7C[8 * v5];
          v19 = v15;
          v20 = 0;
          LOBYTE(v2) = sub_1000BC20(33, -2, &v18);
        }
        break;
      default:
        goto LABEL_40;
    }
  }
  return v2;
}
// 10051DEC: using guessed type __int16 word_10051DEC[];
// 100E0878: using guessed type char byte_100E0878;

//----- (10003040) --------------------------------------------------------
int __usercall sub_10003040@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10013D30((int)&unk_100E0860);
  sub_10008080(a1, (int)&unk_10051C24, v1 + 28);
  byte_100E086C = *(_BYTE *)(v1 + 117);
  result = sub_10013D60((int)&unk_100E0860);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100E086C: using guessed type char byte_100E086C;

//----- (10003080) --------------------------------------------------------
int __usercall sub_10003080@<eax>(int a1@<ebx>)
{
  int v1; // esi@1
  char *v2; // edi@3
  char v3; // ST3C_1@4
  int result; // eax@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10013D30((int)&unk_100E0860);
  if ( byte_100E0878 != 2 )
  {
    sub_1000BC20(56, -2, &byte_100E0863);
    sub_1000BC20(58, -2, &byte_100E0865);
    sub_1000BC20(31, -2, &byte_100E0869);
    sub_1000BC20(65, -2, &byte_100E086A);
    sub_1000BC20(40, -2, byte_100E0861);
    sub_1000BC20(51, -2, &byte_100E086B);
    sub_1000BC20(38, -2, &byte_100E0864);
    sub_1000BC20(43, -2, byte_100E087D);
  }
  sub_1000BC20(60, -2, &byte_100E0866);
  sub_1000BC20(62, -2, &byte_100E0868);
  v2 = (char *)(v1 + 117);
  if ( *(_BYTE *)(v1 + 117) != byte_100E086C )
  {
    v3 = *(_BYTE *)(v1 + 39);
    *v2 = byte_100E086C;
    sub_1000BC20(47, v3, (char *)(v1 + 117));
    sub_10002440(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 8), *v2);
  }
  if ( byte_100E0867 )
  {
    sub_1000A640(a1, v1, v1 + 28, 0);
    sub_1000BC20(67, -2, &byte_100E086D);
    byte_100E0867 = 0;
    result = sub_10013D60((int)&unk_100E0860);
  }
  else
  {
    result = sub_1000BC20(66, -2, &byte_100E086D);
  }
  return result;
}
// 100E0867: using guessed type char byte_100E0867;
// 100E086C: using guessed type char byte_100E086C;
// 100E0878: using guessed type char byte_100E0878;

//----- (100031E0) --------------------------------------------------------
signed int __usercall sub_100031E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 362) )
  {
    sub_10001180(a1, 0, 0, 306, 222, 1);
    result = 2;
    *(_WORD *)(v1 + 14) = 2;
    *(_WORD *)(v1 + 16) = 2;
    *(_WORD *)(v1 + 6) = 218;
    *(_WORD *)(v1 + 4) = 302;
  }
  else
  {
    sub_10001180(a1, 0, 0, 221, 221, 1);
    *(_WORD *)(v1 + 14) = 2;
    *(_WORD *)(v1 + 16) = 2;
    result = 217;
    *(_WORD *)(v1 + 6) = 217;
    *(_WORD *)(v1 + 4) = 217;
  }
  return result;
}

//----- (10003260) --------------------------------------------------------
bool __usercall sub_10003260@<al>(void *a1@<ecx>, int a2@<edi>)
{
  int v2; // esi@1
  char v3; // al@1
  bool result; // al@10

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v3 = sub_100029A0(a1);
  *(_BYTE *)(v2 + 362) = v3;
  if ( v3 )
  {
    if ( *(_WORD *)(v2 + 4) != 217 || *(_WORD *)(v2 + 6) != 217 )
      goto LABEL_8;
LABEL_7:
    sub_100031E0(a2);
    sub_1000A690(a2, v2, v2 + 14, (_BYTE *)(v2 + 28));
    goto LABEL_8;
  }
  if ( *(_WORD *)(v2 + 4) == 302 && *(_WORD *)(v2 + 6) == 218 )
    goto LABEL_7;
LABEL_8:
  if ( *(_BYTE *)(v2 + 360) != sub_10002960() )
  {
    sub_10008060(a2, v2 + 28);
    *(_BYTE *)(v2 + 360) = sub_10002960();
  }
  result = sub_1000D290(a2, *(_WORD **)(a2 + 52), (char *)&unk_10051C24, v2 + 364, 0, 255);
  *(_BYTE *)(a2 + 6) = 2;
  return result;
}

//----- (10003300) --------------------------------------------------------
int __usercall sub_10003300@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  _BYTE *v3; // esi@3

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10013D30((int)&unk_100E0860);
  if ( !byte_100E0878 )
  {
    if ( byte_100E0878 != byte_100E085E )
      sub_1000B930(23, -2, (int)&byte_100E085D);
    byte_100E086D = byte_100E085C;
    sub_10013D60((int)&unk_100E0860);
    goto LABEL_9;
  }
  if ( byte_100E0878 != 2 )
  {
LABEL_9:
    v3 = (_BYTE *)(v2 + 28);
    *(_BYTE *)(v2 + 28) = 4;
    goto LABEL_10;
  }
  v3 = (_BYTE *)(v2 + 28);
  *(_BYTE *)(v2 + 28) = 12;
  if ( byte_100E0878 != byte_100E085E )
    sub_1000B930(23, -2, (int)&byte_100E085C);
  byte_100E086D = byte_100E085D;
  sub_10013D60((int)&unk_100E0860);
LABEL_10:
  byte_100E085E = byte_100E0878;
  sub_10008060(v1, (int)v3);
  sub_100031E0(v1);
  sub_1000A690(v1, v2, v2 + 14, v3);
  return sub_10003080(v1);
}
// 100E085C: using guessed type char byte_100E085C;
// 100E085D: using guessed type char byte_100E085D;
// 100E085E: using guessed type char byte_100E085E;
// 100E0878: using guessed type char byte_100E0878;

//----- (100033E0) --------------------------------------------------------
char __usercall sub_100033E0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  void *v2; // ecx@1
  bool v3; // zf@1
  signed int v4; // ecx@2
  _WORD *v5; // ST08_4@4
  char result; // al@7

  v1 = sub_10001560(a1, *(char **)(a1 + 56), 368, 0);
  *(_BYTE *)(v1 + 362) = sub_100029A0(v2);
  sub_100031E0(a1);
  sub_10004580(83, (_BYTE *)(v1 + 361));
  *(_DWORD *)(v1 + 44) = 0;
  *(_BYTE *)(v1 + 28) = 4;
  *(_BYTE *)(v1 + 100) = 0;
  *(_DWORD *)(v1 + 104) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 108) = 0x7FFFFFFF;
  v3 = *(_BYTE *)(v1 + 361) == 0;
  *(_DWORD *)(v1 + 112) = 0;
  if ( v3 )
    v4 = 0;
  else
    v4 = 256;
  *(_DWORD *)(v1 + 344) = 0;
  *(_DWORD *)(v1 + 348) = v4;
  *(_DWORD *)(v1 + 352) = 0;
  *(_DWORD *)(v1 + 356) = 0;
  *(_BYTE *)(v1 + 13) = 0;
  *(_BYTE *)(v1 + 12) = 1;
  *(_DWORD *)(v1 + 20) = v1;
  *(_DWORD *)(v1 + 24) = v1 + 28;
  *(_DWORD *)v1 = 85;
  *(_BYTE *)(v1 + 8) = 2;
  *(_BYTE *)(v1 + 9) = 0;
  *(_DWORD *)(v1 + 364) = v1 + 12;
  byte_100E085C = 12;
  byte_100E085D = 3;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_BYTE *)(v1 + 34) = 2;
  v5 = *(_WORD **)(a1 + 52);
  byte_100E085E = 4;
  sub_1000D290(a1, v5, (char *)&unk_10051C24, v1 + 364, 0, 255);
  sub_10013D30((int)&unk_100E0860);
  if ( byte_100E0878 == 2 )
    sub_10003300(a1);
  else
    sub_10003080(a1);
  *(_BYTE *)(v1 + 360) = sub_10002960();
  result = sub_10001D00(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100E085C: using guessed type char byte_100E085C;
// 100E085D: using guessed type char byte_100E085D;
// 100E085E: using guessed type char byte_100E085E;
// 100E0878: using guessed type char byte_100E0878;

//----- (10003520) --------------------------------------------------------
char __cdecl sub_10003520(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@8
  void *v3; // ecx@8

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8018:
      sub_10002A40(a1);
      break;
    case 0x8022:
      sub_100029D0(a1);
      break;
    case 0x8041:
      sub_100033E0(a1);
      break;
    case 0x8045:
      sub_10003080(a1);
      break;
    case 0x8061:
      sub_10002AA0(a1);
      break;
    case 0x8062:
      sub_10002AC0(a1);
      break;
    default:
      break;
  }
  LOBYTE(v2) = sub_10010CA0(v1);
  if ( (_BYTE)v2 )
  {
    v2 = **(_WORD **)(a1 + 52);
    switch ( v2 )
    {
      case 32834:
        LOBYTE(v2) = sub_10003040(a1);
        break;
      case 32838:
        LOBYTE(v2) = sub_10003300(a1);
        break;
      case 32840:
        LOBYTE(v2) = sub_10002A10(a1);
        break;
      case 32888:
        LOBYTE(v2) = sub_10003260(v3, a1);
        break;
      case 32773:
      case 32774:
      case 32841:
      case 32851:
      case 32852:
      case 32853:
      case 32871:
        LOBYTE(v2) = (unsigned int)sub_10002A40(a1);
        break;
      default:
        return v2;
    }
  }
  return v2;
}

//----- (100036D0) --------------------------------------------------------
char __cdecl sub_100036D0(char a1)
{
  return sub_100059B0(a1, -122);
}

//----- (100036F0) --------------------------------------------------------
char sub_100036F0()
{
  sub_10005960();
  return sub_100036D0(0);
}

//----- (10003700) --------------------------------------------------------
int __cdecl sub_10003700(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)result == -32696 )
  {
    if ( *(_WORD *)(result + 10) & 0xC000 )
      *(_BYTE *)(a1 + 6) = 2;
    if ( *(_BYTE *)(a1 + 6) == 1 )
      *(_BYTE *)(a1 + 6) = 0;
  }
  return result;
}

//----- (10003740) --------------------------------------------------------
char sub_10003740()
{
  return 0;
}

//----- (10003750) --------------------------------------------------------
int __cdecl sub_10003750(int a1)
{
  sub_100028F0(a1);
  return sub_10007EE0();
}

//----- (10003770) --------------------------------------------------------
char __cdecl sub_10003770(int a1)
{
  __int16 v2; // [sp+4h] [bp-D0h]@1
  int v3; // [sp+8h] [bp-CCh]@1
  char (__cdecl *v4)(int); // [sp+Ch] [bp-C8h]@1

  ++*(_BYTE *)(a1 + 4);
  v2 = -32703;
  v3 = 0;
  v4 = sub_10003520;
  sub_10001660(a1, (int)&v2, 204);
  **(_WORD **)(a1 + 52) = -32671;
  return sub_10003520(a1);
}

//----- (10003800) --------------------------------------------------------
#error "10003819: call analysis failed (funcsize=28)"

//----- (10003880) --------------------------------------------------------
int __cdecl sub_10003880(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 100394DE: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100038D0) --------------------------------------------------------
int __cdecl sub_100038D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 100394E4: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003920) --------------------------------------------------------
int sub_10003920()
{
  gdi_pvg_init();
  return sub_10003CC0();
}
// 100394EA: using guessed type int gdi_pvg_init(void);

//----- (10003970) --------------------------------------------------------
int __cdecl sub_10003970(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 10039508: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100039D0) --------------------------------------------------------
char *__cdecl sub_100039D0(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10003D40();
  *(_DWORD *)(a5 + 596) = sub_10003DB0();
  sub_10003DD0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10011C30(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10015030((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10003B00) --------------------------------------------------------
char sub_10003B00()
{
  char result; // al@1

  result = 0;
  byte_100FC510 = 0;
  byte_100FC511 = 0;
  return result;
}
// 100FC510: using guessed type char byte_100FC510;
// 100FC511: using guessed type char byte_100FC511;

//----- (10003B10) --------------------------------------------------------
char __cdecl sub_10003B10(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_100039D0(-5, a1, a2, a4, a5);
  else
    sub_100039D0(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_10011E00((const char *)(a5 + 485), " DBGA", 100);
  sub_10003DD0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100FC510 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100FC511 )
LABEL_15:
      result = sub_10003E10(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10004600: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100FC510: using guessed type char byte_100FC510;
// 100FC511: using guessed type char byte_100FC511;

//----- (10003C10) --------------------------------------------------------
char __cdecl sub_10003C10(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10003B10(a1, a2, a3, a4, (int)&v5);
}

//----- (10003C80) --------------------------------------------------------
int __cdecl sub_10003C80(int a1, int a2, int a3)
{
  dword_100FC528 = a1;
  dword_100FC51C = a2;
  dword_100FC520 = a3;
  return gdi_pvg_create_window(&dword_100FC514);
}
// 1003951A: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 100FC514: using guessed type int dword_100FC514;
// 100FC51C: using guessed type int dword_100FC51C;
// 100FC520: using guessed type int dword_100FC520;
// 100FC528: using guessed type int dword_100FC528;

//----- (10003CC0) --------------------------------------------------------
int sub_10003CC0()
{
  int result; // eax@1

  result = 0;
  dword_100FC528 = 0;
  dword_100FC51C = 0;
  dword_100FC520 = 59;
  dword_100FC514 = 1;
  dword_100FC518 = 0;
  dword_100FC524 = 0;
  return result;
}
// 100FC514: using guessed type int dword_100FC514;
// 100FC518: using guessed type int dword_100FC518;
// 100FC51C: using guessed type int dword_100FC51C;
// 100FC520: using guessed type int dword_100FC520;
// 100FC524: using guessed type int dword_100FC524;
// 100FC528: using guessed type int dword_100FC528;

//----- (10003D10) --------------------------------------------------------
int __cdecl sub_10003D10(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100FC514 = a1;
  return result;
}
// 100FC514: using guessed type int dword_100FC514;

//----- (10003D20) --------------------------------------------------------
int __cdecl sub_10003D20(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039532: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10003D40) --------------------------------------------------------
int sub_10003D40()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039538: using guessed type int TSK_pvg_get_id(void);

//----- (10003D60) --------------------------------------------------------
int __cdecl sub_10003D60(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003953E: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10003D90) --------------------------------------------------------
__int16 __cdecl sub_10003D90(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039544: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10003DB0) --------------------------------------------------------
int sub_10003DB0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003954A: using guessed type int TSK_pvg_get_timer(void);

//----- (10003DD0) --------------------------------------------------------
int __cdecl sub_10003DD0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039550: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003E10) --------------------------------------------------------
int __cdecl sub_10003E10(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003955C: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003E40) --------------------------------------------------------
int __cdecl sub_10003E40(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039562: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10003E60) --------------------------------------------------------
int __cdecl sub_10003E60(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039568: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10003E80) --------------------------------------------------------
int __cdecl sub_10003E80(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003956E: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10003EB0) --------------------------------------------------------
int __cdecl sub_10003EB0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039574: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10003EE0) --------------------------------------------------------
int __cdecl sub_10003EE0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003957A: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003F10) --------------------------------------------------------
int __cdecl sub_10003F10(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039580: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10003F40) --------------------------------------------------------
int __cdecl sub_10003F40(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039586: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10003F60) --------------------------------------------------------
int __cdecl sub_10003F60(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003958C: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10003F80) --------------------------------------------------------
char __cdecl sub_10003F80(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10003DB0();
  if ( sub_10003E40(a1) == 5 )
    goto LABEL_4;
  while ( sub_10003DB0() < v2 )
  {
    sub_10003F60(20);
    if ( sub_10003E40(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10003E40(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10003FF0) --------------------------------------------------------
int __cdecl sub_10003FF0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10003D40();
    sub_10003DD0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039592: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10004030) --------------------------------------------------------
int __cdecl sub_10004030(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10003E60(a2);
  return result;
}
// 100551E0: using guessed type void *tsk_app_hdr_ptr;

//----- (10004060) --------------------------------------------------------
int __cdecl sub_10004060(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10003E80(a1, a2);
  return result;
}
// 100551E0: using guessed type void *tsk_app_hdr_ptr;

//----- (10004080) --------------------------------------------------------
int __cdecl sub_10004080(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_10057EC0[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_10057EC4[2 * v1];
}
// 10057EC0: using guessed type int dword_10057EC0[];
// 10057EC4: using guessed type int dword_10057EC4[];

//----- (100040C0) --------------------------------------------------------
int __cdecl sub_100040C0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10039598: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100040E0) --------------------------------------------------------
char __cdecl sub_100040E0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_100040C0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10003C10("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10004120) --------------------------------------------------------
int __cdecl sub_10004120(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_100040C0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10004160) --------------------------------------------------------
int __cdecl sub_10004160(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_100040C0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10004190) --------------------------------------------------------
int __cdecl sub_10004190(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1003959E: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100041B0) --------------------------------------------------------
int __cdecl sub_100041B0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10004190(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10004630() )
  {
    v4 = sub_10004080(a1);
    if ( v4 != 42066 )
      v3 = sub_10004190(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10004630: using guessed type int sub_10004630(void);

//----- (10004210) --------------------------------------------------------
int __cdecl sub_10004210(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_100041B0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10003C10("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10004250) --------------------------------------------------------
int __cdecl sub_10004250(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_100040C0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10004190(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (100042B0) --------------------------------------------------------
signed int __cdecl sub_100042B0(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10022950(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_100351D0(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_1010ED98 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_1010EDA0[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_1010ED98 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10004640(
      v2,
      *(_DWORD *)(dword_1010EDA0[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_100042B0(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 100395AA: using guessed type int FIL_vfs_close(void);
// 1010ED98: using guessed type int dword_1010ED98;
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (10004310) --------------------------------------------------------
int __cdecl sub_10004310(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 100395BC: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004380) --------------------------------------------------------
signed int __cdecl sub_10004380(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10022950(a1);
    return sub_10023810(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10004540(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_100049E0(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 100395CE: using guessed type int FIL_vfs_read(void);

//----- (100043C0) --------------------------------------------------------
signed int __cdecl sub_100043C0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_100150A0(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_100049E0(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 100395D4: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004450) --------------------------------------------------------
signed int __cdecl sub_10004450(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10015100(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 100395E0: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100044A0) --------------------------------------------------------
__int64 __cdecl sub_100044A0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 100395E6: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100044C0) --------------------------------------------------------
int __cdecl sub_100044C0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 100395EC: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100044F0) --------------------------------------------------------
int __cdecl sub_100044F0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 100395F8: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004510) --------------------------------------------------------
char __cdecl sub_10004510(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_100042B0(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10004370: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10004540) --------------------------------------------------------
signed int __cdecl sub_10004540(unsigned int a1, int a2, int a3)
{
  return sub_10004450(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10004560) --------------------------------------------------------
int __cdecl sub_10004560(int a1, int a2, int a3)
{
  return sub_100044C0(a1, a2, a3);
}

//----- (10004580) --------------------------------------------------------
void __cdecl sub_10004580(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10004B30(a1, a2);
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 100395FE: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (100045B0) --------------------------------------------------------
int __cdecl sub_100045B0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039604: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10004640) --------------------------------------------------------
unsigned int __cdecl sub_10004640(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1010EDA0[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1010ED58[a1];
  dword_1010ED58[a1] = a3 + v9;
  dword_1010ED18[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1010ED18[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1010ED58: using guessed type int dword_1010ED58[];
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (100047F0) --------------------------------------------------------
int __usercall sub_100047F0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1010EDA0[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1010EDA0[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (100048A0) --------------------------------------------------------
int __cdecl sub_100048A0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_100047F0(a1);
  v3 = &dword_1010EDA0[a1];
  v4 = sub_100043C0(
         *(_DWORD *)dword_1010EDA0[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1010EDA0[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1010ED58[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1010ED58: using guessed type int dword_1010ED58[];
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (10004950) --------------------------------------------------------
int __usercall sub_10004950@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1010EDA0[a1];
  v3 = (int *)(dword_1010ED58[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1010EDA0[a1] + 32)) % *(_WORD *)(dword_1010EDA0[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_100048A0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1010ED58: using guessed type int dword_1010ED58[];
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (100049E0) --------------------------------------------------------
unsigned int __cdecl sub_100049E0(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1010ED98 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1010EDA0[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1010ED98 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10003E80(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1010EDA0[v6] + 28);
        v12 = sub_10004950(v6, (unsigned int)v7 & *(_DWORD *)(dword_1010EDA0[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1010EDA0[v6] + 4) != 138 )
        sub_10003E60(*(_DWORD *)(dword_1010EDA0[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1010EDA0[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10003E60(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1010ED98: using guessed type int dword_1010ED98;
// 1010EDA0: using guessed type int dword_1010EDA0[];

//----- (10004B30) --------------------------------------------------------
void __cdecl sub_10004B30(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10010DC0(v2) && sub_10010E30(v3) != 1 )
    *a2 = 0;
}

//----- (10004B60) --------------------------------------------------------
int __cdecl sub_10004B60(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (10004C70) --------------------------------------------------------
unsigned int __cdecl sub_10004C70(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_100057B0(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_10004D50(v9);
      }
      else
      {
        result = sub_10005280(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_100050A0(v9);
    }
    else
    {
      result = sub_10005280(v9);
    }
  }
  else
  {
    result = sub_10005280(v9);
  }
  return result;
}

//----- (10004D50) --------------------------------------------------------
int __cdecl sub_10004D50(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_100064B0(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (100050A0) --------------------------------------------------------
int __cdecl sub_100050A0(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_100064B0(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (10005280) --------------------------------------------------------
unsigned int __cdecl sub_10005280(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_100064B0(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_10058AF8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_10058AF8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_10058AF8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_10058AF8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (100057B0) --------------------------------------------------------
int __cdecl sub_100057B0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (10005810) --------------------------------------------------------
_WORD *__cdecl sub_10005810(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (10005870) --------------------------------------------------------
int __cdecl sub_10005870(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_10004B60(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (10005960) --------------------------------------------------------
void sub_10005960()
{
  ;
}

//----- (10005970) --------------------------------------------------------
int __cdecl sub_10005970(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_100063C0(a1, a2, a3);
  return result;
}

//----- (100059B0) --------------------------------------------------------
char __cdecl sub_100059B0(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_1010EDE1 = a1;
  byte_1010EDE0 = a2;
  return result;
}
// 1010EDE0: using guessed type char byte_1010EDE0;
// 1010EDE1: using guessed type char byte_1010EDE1;

//----- (100059D0) --------------------------------------------------------
int __cdecl sub_100059D0(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_10006210(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_10005970(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_10006B50(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_10006B50(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_10006B50(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_10006B50(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_100062B0(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_10006680(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_10004D50(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_10006680(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (10006210) --------------------------------------------------------
bool __cdecl sub_10006210(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (100062B0) --------------------------------------------------------
bool __cdecl sub_100062B0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_1010EDE1 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_1010EDE0;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 1010EDE0: using guessed type char byte_1010EDE0;
// 1010EDE1: using guessed type char byte_1010EDE1;

//----- (100063C0) --------------------------------------------------------
int __cdecl sub_100063C0(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (100064B0) --------------------------------------------------------
int __cdecl sub_100064B0(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10006680) --------------------------------------------------------
int __cdecl sub_10006680(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10058B08 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (10006B50) --------------------------------------------------------
int __cdecl sub_10006B50(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_10006680(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (10006C40) --------------------------------------------------------
char __cdecl sub_10006C40(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_100071C0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_10007A80(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_100071C0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_100071C0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_100072C0(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_100076F0(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (10006DB0) --------------------------------------------------------
char *__cdecl sub_10006DB0(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10007240(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_100074C0(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10007830(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10007240(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10007BC0(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10006F00) --------------------------------------------------------
int __cdecl sub_10006F00(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10007020) --------------------------------------------------------
unsigned int __cdecl sub_10007020(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (100071C0) --------------------------------------------------------
int __cdecl sub_100071C0(int a1, int a2, int a3)
{
  return sub_10006680(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (10007240) --------------------------------------------------------
int __cdecl sub_10007240(int a1, int a2, int a3)
{
  return sub_10006680(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (100072C0) --------------------------------------------------------
char __cdecl sub_100072C0(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_100073D0(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10006F00(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10058B08 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10058B08 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (100073D0) --------------------------------------------------------
int __cdecl sub_100073D0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (100074C0) --------------------------------------------------------
int __cdecl sub_100074C0(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_100075C0(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (100075C0) --------------------------------------------------------
int __cdecl sub_100075C0(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100076F0) --------------------------------------------------------
char *__cdecl sub_100076F0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10006F00(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10007020(a1, (int)v11);
  }
  return result;
}

//----- (10007830) --------------------------------------------------------
char *__cdecl sub_10007830(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_100075C0(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (10007A80) --------------------------------------------------------
int __cdecl sub_10007A80(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_100076F0(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_100072C0(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10007BC0) --------------------------------------------------------
int __cdecl sub_10007BC0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10007830(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_100074C0(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10007D00) --------------------------------------------------------
int __cdecl sub_10007D00(unsigned __int8 a1, unsigned int a2)
{
  return dword_10059408[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10059408: using guessed type int dword_10059408[];

//----- (10007D20) --------------------------------------------------------
unsigned int __cdecl sub_10007D20(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10059408[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10059408[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10059408[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10059408[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10059408[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10059408[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10059408[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10059408[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10059408[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10059408[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10059408: using guessed type int dword_10059408[];

//----- (10007E50) --------------------------------------------------------
int __cdecl sub_10007E50(int a1, int a2, const char *a3)
{
  int result; // eax@1
  int v4; // eax@2
  __int16 v5; // [sp+0h] [bp-D0h]@2
  int v6; // [sp+4h] [bp-CCh]@2
  char v7; // [sp+8h] [bp-C8h]@2
  int v8; // [sp+10h] [bp-C0h]@2
  int v9; // [sp+14h] [bp-BCh]@2

  result = a2;
  if ( *(_DWORD *)(a1 + 64) == 9 )
  {
    v4 = *(_DWORD *)(a2 + 80);
    v8 = *(_DWORD *)(a2 + 76);
    v9 = v4;
    strcpy(&v7, a3);
    v5 = -32607;
    v6 = 0;
    result = sub_10003EE0(9, (int)&v5, 60000, 1);
  }
  return result;
}

//----- (10007EE0) --------------------------------------------------------
int sub_10007EE0()
{
  signed int v0; // ecx@1
  unsigned int v1; // eax@2
  int result; // eax@5
  signed int v3; // [sp+4h] [bp-Ch]@1

  v0 = 0;
  byte_1010EDF3 = 0;
  byte_1010EDF8 = 0;
  v3 = 0;
  do
  {
    v1 = 5 - (unsigned __int64)(signed __int64)((double)v3 / 10.0 * -15.0);
    if ( v1 <= 5 )
      LOBYTE(v1) = 5;
    byte_1010EDE8[v0++] = v1;
    v3 = v0;
  }
  while ( v0 < 10 );
  word_1010EDFC = 0;
  byte_1010EDFE = 0;
  result = sub_10003D40();
  if ( result == 9 )
    result = nullsub_1(100, 1);
  return result;
}
// 1010EDF3: using guessed type char byte_1010EDF3;
// 1010EDF8: using guessed type char byte_1010EDF8;
// 1010EDFC: using guessed type __int16 word_1010EDFC;
// 1010EDFE: using guessed type char byte_1010EDFE;

//----- (10007F80) --------------------------------------------------------
int __cdecl sub_10007F80(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  __int16 v5; // [sp+0h] [bp-D0h]@2
  int v6; // [sp+4h] [bp-CCh]@2
  int v7; // [sp+8h] [bp-C8h]@2

  result = a1;
  if ( *(_DWORD *)(a1 + 64) == 9 )
  {
    v4 = *(_DWORD *)(a1 + 56);
    v6 = 0;
    v5 = -32604;
    v7 = *(_DWORD *)(a3 + 84);
    LOWORD(v7) = *(_WORD *)(v4 + 28) + v7;
    HIWORD(v7) += *(_WORD *)(v4 + 30);
    result = sub_10003EE0(9, (int)&v5, 60000, 1);
  }
  return result;
}

//----- (10008000) --------------------------------------------------------
int __cdecl sub_10008000(int a1)
{
  int result; // eax@1
  __int16 v2; // [sp+0h] [bp-D0h]@2
  int v3; // [sp+4h] [bp-CCh]@2

  result = a1;
  if ( *(_DWORD *)(a1 + 64) == 9 )
  {
    v3 = 0;
    v2 = -32606;
    result = sub_10003EE0(9, (int)&v2, 60000, 1);
  }
  return result;
}

//----- (10008060) --------------------------------------------------------
int __cdecl sub_10008060(int a1, int a2)
{
  return sub_1000BC20(12, *(_BYTE *)(a2 + 11), 0);
}

//----- (10008080) --------------------------------------------------------
int __cdecl sub_10008080(int a1, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(a3 + 16);
  if ( result
    && *(_BYTE *)(result + 10) == 1
    && *(_BYTE *)(result + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a3 + 7)) - 1 )
  {
    result = *(_DWORD *)(result + 48) & 0x10;
    if ( result )
    {
      sub_1000BC20(8, *(_BYTE *)(a3 + 11), (char *)(a3 + 89));
      result = sub_10002440(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 8), *(_BYTE *)(a3 + 89));
    }
  }
  return result;
}
// 1010EDFC: using guessed type __int16 word_1010EDFC;

//----- (100080E0) --------------------------------------------------------
int __cdecl sub_100080E0(int a1)
{
  return sub_1000BC20(1, *(_BYTE *)(a1 + 11), 0);
}

//----- (10008110) --------------------------------------------------------
BOOL __usercall sub_10008110@<eax>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 64);
  return v1 == 9 || v1 == 6 || v1 == 3 || v1 == 15 || v1 == 16;
}

//----- (10008140) --------------------------------------------------------
char __usercall sub_10008140@<al>(int a1@<ebx>, int a2@<edi>)
{
  signed int v2; // eax@1
  char v3; // si@1
  double v4; // st7@5
  float v5; // ST24_4@6
  float v6; // ST24_4@8
  __int64 v8; // [sp+Ch] [bp-28h]@0
  int v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@3
  double v11; // [sp+24h] [bp-10h]@3
  double v12; // [sp+2Ch] [bp-8h]@3

  v2 = sub_10015340(v8);
  v3 = v2;
  if ( v2 != 0x3FFFF )
  {
    LODWORD(v8) = v2;
    LOBYTE(v2) = sub_1000D640(v8);
    if ( (_BYTE)v2 != 11 )
    {
      sub_1000D510(0, v3, &v11);
      sub_10015170((int)&v9, v11, v12);
      sub_1000C070(v9, v10, a1);
      LOBYTE(v2) = *(_BYTE *)a2;
      if ( *(_BYTE *)a2 == 3 )
      {
        v6 = *(float *)(a2 + 40) - 3.1415926535898;
        v4 = sub_1004E5B0(v6);
        goto LABEL_6;
      }
      if ( (_BYTE)v2 == 8 )
      {
        v4 = *(float *)(a2 + 40);
LABEL_6:
        v5 = v4;
        sub_1004D7A0((int)&v11, *(float *)(a2 + 44), v5, 1, (int)&v11);
        sub_10015170((int)&v9, v11, v12);
        LOBYTE(v2) = sub_1000C070(v9, v10, a1);
        return v2;
      }
    }
  }
  return v2;
}

//----- (10008260) --------------------------------------------------------
char __usercall sub_10008260@<al>(unsigned __int8 a1@<al>, int a2@<edi>, int a3, unsigned __int8 a4, char a5)
{
  char v5; // bl@1
  signed int v6; // eax@1
  double v7; // st7@5
  float v8; // ST20_4@10
  float v9; // ST1C_4@10
  char result; // al@11
  char v11; // bl@11
  char v12; // [sp+1Ch] [bp-5Ch]@11
  int v13; // [sp+24h] [bp-54h]@1
  int v14; // [sp+28h] [bp-50h]@1
  double v15; // [sp+2Ch] [bp-4Ch]@10
  double v16; // [sp+34h] [bp-44h]@10
  char v17; // [sp+3Ch] [bp-3Ch]@4
  int v18; // [sp+60h] [bp-18h]@10
  float v19; // [sp+64h] [bp-14h]@10
  float v20; // [sp+68h] [bp-10h]@7
  bool v21; // [sp+84h] [bp+Ch]@12

  v5 = a1;
  v13 = 0x7FFFFFFF;
  v14 = 0x7FFFFFFF;
  v6 = sub_1000DC60(a3, a1);
  if ( a5 )
    sub_1000D790(v6, (int)&v13);
  else
    sub_1000D770(v6, (int)&v13);
  sub_1000D990(a3, v5, &v17);
  if ( v17 == 7 )
  {
    v7 = 9260.0;
  }
  else if ( v17 == 8 )
  {
    v7 = v20;
  }
  else
  {
    if ( v17 != 10 )
      goto LABEL_11;
    v7 = 55560.0;
  }
  v8 = v7;
  v9 = v19;
  sub_1000D510(0, v18, &v15);
  sub_1004D7A0((int)&v15, v8, v9, 1, (int)&v15);
  sub_10015170((int)&v13, v15, v16);
LABEL_11:
  result = sub_1000C070(v13, v14, a2);
  v11 = v5 + 1;
  v12 = v11;
  if ( (unsigned __int8)v11 <= a4 )
  {
    v21 = a5 == 0;
    do
    {
      result = sub_1000C0F0(a3, (_BYTE)a3 != 0, v12, v21, a2);
      v12 = ++v11;
    }
    while ( (unsigned __int8)v11 <= a4 );
  }
  return result;
}

//----- (100083B0) --------------------------------------------------------
char __usercall sub_100083B0@<al>(char result@<al>, int a2@<ecx>)
{
  if ( result == 1 )
    *(_BYTE *)(*(_DWORD *)(a2 + 20) + 10) = 0;
  return result;
}

//----- (100083C0) --------------------------------------------------------
int __usercall sub_100083C0@<eax>(int a1@<eax>)
{
  int v1; // ecx@1
  int v2; // ecx@1
  int v3; // eax@1
  __int16 v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+2h] [bp-Ah]@1
  __int16 v7; // [sp+4h] [bp-8h]@1
  __int16 v8; // [sp+6h] [bp-6h]@1
  __int16 v9; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 4);
  v5 = **(_WORD **)(a1 + 20);
  v6 = *(_WORD *)v1;
  v7 = *(_WORD *)(v1 + 2);
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 24);
  v8 = *(_WORD *)(v2 + 4);
  v9 = *(_WORD *)(v2 + 6);
  return sub_1000BC20(4, *(_BYTE *)(v3 + 11), (char *)&v5);
}

//----- (10008410) --------------------------------------------------------
int __usercall sub_10008410@<eax>(int a1@<esi>)
{
  int v1; // eax@3
  int v2; // ebx@7
  signed __int16 v3; // ax@7
  int v4; // ebp@7
  __int16 v5; // di@7
  __int16 v6; // ST14_2@7
  int v7; // ST18_4@7

  *(_WORD *)(*(_DWORD *)(a1 + 8) + 396) = 3;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 394) = 1;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 428) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 430) = 16;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 398) = 3;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 440) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 442) = 16;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 64) != 6 )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(a1 + 20) + 2) )
    {
      v1 = FNT_get_fnt_hdr(13);
      goto LABEL_7;
    }
LABEL_6:
    v1 = FNT_get_fnt_hdr(7);
    goto LABEL_7;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 20) + 2) )
    goto LABEL_6;
  v1 = FNT_get_fnt_hdr(13);
LABEL_7:
  v2 = v1;
  v3 = sub_10005970(v1, "LOADING...", 0);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = **(_WORD **)(a1 + 4) + *(_WORD *)(v4 + 4) / 2 - v3 / 2;
  LOWORD(v4) = *(_WORD *)(*(_DWORD *)(a1 + 4) + 2) + *(_WORD *)(v4 + 6) / 2;
  sub_1004D520(*(_DWORD *)(a1 + 8) + 392, v5 - 3, v4 - *(_WORD *)(v2 + 24), v3 + 6, *(_WORD *)(v2 + 22) + 2, 1);
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 428) = -1;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 430) = 0;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 438) = v5;
  *(_WORD *)(*(_DWORD *)(a1 + 8) + 436) = v4;
  return sub_100059D0(*(_DWORD *)(a1 + 8) + 392, v2, "LOADING...", 0, 2, v6, v7);
}
// 1004E7A6: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (10008570) --------------------------------------------------------
unsigned __int8 __usercall sub_10008570@<al>(unsigned int a1@<edi>, int a2@<esi>)
{
  int v2; // ecx@1
  unsigned __int8 result; // al@1
  unsigned __int8 v4; // bl@1
  unsigned __int8 v5; // [sp+7h] [bp-65h]@1
  char v6; // [sp+8h] [bp-64h]@1
  double v7; // [sp+Ch] [bp-60h]@1
  double v8; // [sp+14h] [bp-58h]@1
  char v9; // [sp+1Ch] [bp-50h]@2
  char v10; // [sp+1Eh] [bp-4Eh]@2
  int v11; // [sp+34h] [bp-38h]@3
  int v12; // [sp+38h] [bp-34h]@3
  int v13; // [sp+3Ch] [bp-30h]@3
  int v14; // [sp+40h] [bp-2Ch]@3

  sub_1000D510(0, a1, &v7);
  sub_10015170(a2, v7, v8);
  v2 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 12) = v2;
  result = sub_1000EA50(a1);
  v4 = 0;
  v5 = result;
  v6 = 0;
  if ( result )
  {
    do
    {
      result = sub_1000E570(a1, v6, (int)&v9);
      if ( v10 )
      {
        sub_1000C070(v11, v12, a2);
        result = sub_1000C070(v13, v14, a2);
      }
      v6 = ++v4;
    }
    while ( v4 < v5 );
  }
  return result;
}

//----- (10008620) --------------------------------------------------------
int __usercall sub_10008620@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@4
  int v4; // edi@5
  _DWORD *v5; // eax@5
  char v6; // cl@5
  int v7; // eax@12
  int v8; // eax@12
  int result; // eax@12
  int v10; // eax@13
  char v11; // [sp+Fh] [bp-5h]@9
  char v12; // [sp+10h] [bp-4h]@5

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 && !*(_BYTE *)(v2 + 10) && *(_BYTE *)(v2 + 13) != -1 )
  {
    v3 = *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7);
    --*((_BYTE *)&word_1010EDFC + v3);
    *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11) = -1;
    *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7) = *(_BYTE *)(*(_DWORD *)(v1 + 12) + 9);
  }
  v4 = *(_DWORD *)(v1 + 8);
  v5 = *(_DWORD **)(v4 + 32);
  v6 = 1;
  v12 = 1;
  if ( v5 )
  {
    do
    {
      if ( v5 == *(_DWORD **)(v4 + 56) )
        break;
      v5 = (_DWORD *)*v5;
      ++v6;
    }
    while ( v5 );
    v12 = v6;
  }
  sub_10008100(
    *(_BYTE *)(*(_DWORD *)(v1 + 12) + 9),
    -1,
    **(_WORD **)(v1 + 4) + *(_WORD *)(*(_DWORD *)(v4 + 56) + 28),
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 30) + *(_WORD *)(*(_DWORD *)(v1 + 4) + 2),
    *(_WORD *)(*(_DWORD *)(v1 + 12) + 4),
    *(_WORD *)(*(_DWORD *)(v1 + 12) + 6));
  v11 = sub_1000BF10(
          (_BYTE *)(*(_DWORD *)(v1 + 24) + 11),
          *(_BYTE *)(*(_DWORD *)(v1 + 12) + 9),
          v12,
          *(_DWORD *)(*(_DWORD *)(v1 + 8) + 64));
  if ( !*(_DWORD *)(*(_DWORD *)(v1 + 24) + 16) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + 16) = sub_10002850(*(_DWORD *)(v1 + 8), 84);
    *(_DWORD *)(v1 + 20) = *(_DWORD *)(*(_DWORD *)(v1 + 24) + 16);
  }
  if ( v11 )
  {
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 10) = 0;
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 13) = -1;
    *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11) = -1;
    v10 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)(v10 + 72) = 0;
    *(_DWORD *)(v10 + 76) = 0;
    *(_DWORD *)(v10 + 80) = 0;
    *(_DWORD *)(v10 + 84) = 0;
    *(_DWORD *)(v10 + 88) = 0;
    *(_WORD *)(*(_DWORD *)(v1 + 8) + 440) = word_1010EE10[1];
    *(_WORD *)(*(_DWORD *)(v1 + 8) + 442) = word_1010EE10[1];
    result = sub_10006B50(
               *(_DWORD *)(v1 + 8) + 392,
               **(_WORD **)(v1 + 4),
               *(_WORD *)(*(_DWORD *)(v1 + 4) + 2),
               *(_WORD *)(*(_DWORD *)(v1 + 12) + 4),
               *(_WORD *)(*(_DWORD *)(v1 + 12) + 6));
    byte_1010EDF9 = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 4) = 0;
    *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7) = *(_BYTE *)(*(_DWORD *)(v1 + 12) + 9);
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 13) = *((_BYTE *)&word_1010EDFC + *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7));
    v7 = *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7);
    ++*((_BYTE *)&word_1010EDFC + v7);
    *(_DWORD *)(*(_DWORD *)(v1 + 20) + 44) = 0x3FFFF;
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 9) = 1;
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 11) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 249) = 0;
    v8 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)(v8 + 76) = 0x7FFFFFFF;
    *(_DWORD *)(v8 + 80) = 0x7FFFFFFF;
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) = 0;
    *(_BYTE *)(*(_DWORD *)(v1 + 24) + 72) = 0;
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 10) = 1;
    *(_BYTE *)(*(_DWORD *)(v1 + 20) + 2) = sub_1000C2E0();
    result = sub_10008100(
               *(_BYTE *)(*(_DWORD *)(v1 + 24) + 7),
               *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11),
               **(_WORD **)(v1 + 4) + *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 28),
               *(_WORD *)(*(_DWORD *)(v1 + 4) + 2) + *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 30),
               *(_WORD *)(*(_DWORD *)(v1 + 12) + 4),
               *(_WORD *)(*(_DWORD *)(v1 + 12) + 6));
    byte_1010EDF9 = 0;
  }
  return result;
}
// 10008100: using guessed type _DWORD __cdecl sub_10008100(char, char, __int16, __int16, __int16, __int16);
// 1000C2E0: using guessed type int sub_1000C2E0(void);
// 1010EDF9: using guessed type char byte_1010EDF9;
// 1010EDFC: using guessed type __int16 word_1010EDFC;
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (10008870) --------------------------------------------------------
char __usercall sub_10008870@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // edi@1
  int v4; // ecx@1
  int v5; // edx@1
  bool v6; // zf@1
  unsigned int v7; // eax@5
  int v8; // ecx@7
  int v9; // eax@26
  char v11[2]; // [sp+4h] [bp-24h]@4
  __int16 v12; // [sp+6h] [bp-22h]@4
  int v13; // [sp+8h] [bp-20h]@25
  int v14; // [sp+Ch] [bp-1Ch]@26
  int v15; // [sp+10h] [bp-18h]@26
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  int v18; // [sp+1Ch] [bp-Ch]@1
  int v19; // [sp+24h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 16);
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(_DWORD *)(v1 + 12);
  v16 = *(_DWORD *)v1;
  v4 = *(_DWORD *)(v1 + 8);
  v17 = v2;
  v5 = *(_DWORD *)(v1 + 16);
  v6 = *(_BYTE *)(*(_DWORD *)(a1 + 20) + 9) == 0;
  v18 = v4;
  v19 = v5;
  if ( !v6 || !sub_10015440() && (_WORD)v3 )
    return 1;
  *(_WORD *)v11 = 0;
  v12 = 0;
  if ( (unsigned __int16)v3 >= 0xAu )
  {
    v8 = 15;
  }
  else
  {
    v7 = (unsigned __int8)byte_1010EDE8[(unsigned __int16)v3];
    if ( v7 < 5 )
      v7 = 5;
    v8 = v7;
  }
  if ( HIWORD(v18) == 47 || HIWORD(v18) == 48 || HIWORD(v18) == 46 )
  {
    v12 = -(signed __int16)v8;
  }
  else if ( HIWORD(v18) == 51 || HIWORD(v18) == 50 || HIWORD(v18) == 52 )
  {
    v12 = v8;
  }
  if ( HIWORD(v18) == 49 || HIWORD(v18) == 48 || HIWORD(v18) == 50 )
    goto LABEL_24;
  if ( HIWORD(v18) == 53 || HIWORD(v18) == 46 || HIWORD(v18) == 52 )
  {
    v8 = -v8;
LABEL_24:
    *(_WORD *)v11 = v8;
  }
  sub_1000BC20(9, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), v11);
  if ( v13 != 0x7FFFFFFF )
  {
    v9 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(v9 + 76) = v13;
    *(_DWORD *)(v9 + 80) = v14;
    *(_DWORD *)(*(_DWORD *)(a1 + 24) + 84) = v15;
    sub_1000C2F0(
      *(_DWORD *)(a1 + 8) + 392,
      **(_WORD **)(a1 + 4),
      *(_WORD *)(*(_DWORD *)(a1 + 4) + 2),
      *(_WORD *)(*(_DWORD *)(a1 + 12) + 4),
      *(_WORD *)(*(_DWORD *)(a1 + 12) + 6),
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11));
    *(_BYTE *)(*(_DWORD *)(a1 + 24) + 280) = 9;
    return 0;
  }
  return 1;
}

//----- (100089D0) --------------------------------------------------------
int __usercall sub_100089D0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // ST10_4@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 20);
  v2 = *(_DWORD *)(v1 + 48);
  v3 = *(_DWORD *)(v1 + 52);
  result = *(_DWORD *)(v1 + 48) & 0x80;
  if ( !(v2 & 0x80) )
  {
    if ( !(result | v2 & 0x1000) || (result = *(_DWORD *)(a1 + 24), *(_BYTE *)(result + 72)) )
      result = sub_1000BC20(13, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), 0);
    else
      *(_BYTE *)(result + 280) = 9;
  }
  return result;
}

//----- (10008A30) --------------------------------------------------------
char __usercall sub_10008A30@<al>(int a1@<esi>)
{
  char result; // al@1
  int v2; // eax@2
  int v3; // eax@2
  int v4; // ecx@2
  char v5; // [sp+0h] [bp-9Ch]@2
  char v6; // [sp+1h] [bp-9Bh]@2
  char v7; // [sp+4h] [bp-98h]@2
  int v8; // [sp+8h] [bp-94h]@2
  int v9; // [sp+Ch] [bp-90h]@2
  char v10; // [sp+1Ch] [bp-80h]@2
  char v11; // [sp+34h] [bp-68h]@1
  char v12[4]; // [sp+38h] [bp-64h]@2
  int v13; // [sp+3Ch] [bp-60h]@2

  result = sub_1000BA30(*(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (int)&v11);
  if ( result )
  {
    v8 = *(_DWORD *)v12;
    v2 = *(_DWORD *)(a1 + 24);
    v5 = 4;
    v7 = 1;
    v10 = 0;
    v9 = v13;
    v6 = -1;
    sub_1000BC20(48, *(_BYTE *)(v2 + 11), &v5);
    *(_BYTE *)(*(_DWORD *)(a1 + 20) + 60) = 4;
    sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 20) + 60));
    v3 = *(_DWORD *)(a1 + 24);
    v4 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(v4 + 64) = *(_DWORD *)(v3 + 76);
    *(_DWORD *)(v4 + 68) = *(_DWORD *)(v3 + 80);
    result = sub_1000BC20(37, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), v12);
  }
  return result;
}

//----- (10008AF0) --------------------------------------------------------
int __usercall sub_10008AF0@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  char v3; // [sp+0h] [bp-38h]@1
  char v4; // [sp+1h] [bp-37h]@1
  char v5; // [sp+4h] [bp-34h]@1
  char v6; // [sp+1Ch] [bp-1Ch]@1

  v1 = *(_DWORD *)(a1 + 24);
  v3 = 5;
  v5 = 1;
  v6 = 0;
  v4 = -1;
  sub_1000BC20(48, *(_BYTE *)(v1 + 11), &v3);
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 60) = 1;
  return sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 20) + 60));
}

//----- (10008B60) --------------------------------------------------------
int __usercall sub_10008B60@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  char v3; // [sp+0h] [bp-38h]@1
  char v4; // [sp+1h] [bp-37h]@1
  char v5; // [sp+4h] [bp-34h]@1
  char v6; // [sp+1Ch] [bp-1Ch]@1

  v1 = *(_DWORD *)(a1 + 24);
  v3 = 6;
  v5 = 1;
  v6 = 0;
  v4 = -1;
  sub_1000BC20(48, *(_BYTE *)(v1 + 11), &v3);
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 60) = 1;
  return sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 20) + 60));
}

//----- (10008BD0) --------------------------------------------------------
int __thiscall sub_10008BD0(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@1
  int v4; // ecx@1
  char v6; // [sp+4h] [bp-38h]@1
  char v7; // [sp+5h] [bp-37h]@1
  char v8; // [sp+8h] [bp-34h]@1
  int v9; // [sp+Ch] [bp-30h]@1
  int v10; // [sp+10h] [bp-2Ch]@1
  char v11; // [sp+20h] [bp-1Ch]@1

  v1 = this;
  v2 = *(_DWORD *)(this + 24);
  v6 = 4;
  v8 = 1;
  v11 = 0;
  v9 = *(_DWORD *)(v2 + 76);
  v10 = *(_DWORD *)(v2 + 80);
  v7 = -1;
  sub_1000BC20(48, *(_BYTE *)(v2 + 11), &v6);
  *(_BYTE *)(*(_DWORD *)(v1 + 20) + 60) = 2;
  sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(v1 + 20) + 60));
  v3 = *(_DWORD *)(v1 + 24);
  v4 = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(v4 + 64) = *(_DWORD *)(v3 + 76);
  *(_DWORD *)(v4 + 68) = *(_DWORD *)(v3 + 80);
  return sub_1000BC20(37, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(v1 + 24) + 76));
}

//----- (10008C70) --------------------------------------------------------
int __thiscall sub_10008C70(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ecx@1
  int result; // eax@1
  char v8; // [sp+4h] [bp-38h]@1
  char v9; // [sp+5h] [bp-37h]@1
  char v10; // [sp+8h] [bp-34h]@1
  char v11; // [sp+Ch] [bp-30h]@1
  int v12; // [sp+10h] [bp-2Ch]@1
  char v13; // [sp+20h] [bp-1Ch]@1

  v1 = this;
  v2 = *(_DWORD *)(this + 20);
  v8 = *(_BYTE *)(v2 + 12);
  v13 = 0;
  v10 = 1;
  v3 = *(_DWORD *)(v2 + 20);
  v11 = 0;
  v4 = *(_DWORD *)(this + 24);
  v12 = v3;
  v9 = -1;
  sub_1000BC20(48, *(_BYTE *)(v4 + 11), &v8);
  *(_BYTE *)(*(_DWORD *)(v1 + 20) + 60) = 3;
  sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(v1 + 20) + 60));
  v5 = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(v5 + 64) = *(_DWORD *)(v5 + 16);
  v6 = v5 + 64;
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 20);
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 24);
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(v5 + 28);
  result = *(_DWORD *)(v5 + 32);
  *(_DWORD *)(v6 + 16) = result;
  return result;
}

//----- (10008D20) --------------------------------------------------------
int __usercall sub_10008D20@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  char v3; // [sp+4h] [bp-38h]@1
  char v4; // [sp+5h] [bp-37h]@1
  char v5; // [sp+8h] [bp-34h]@1
  char v6; // [sp+20h] [bp-1Ch]@1

  v1 = *(_DWORD *)(a1 + 24);
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v4 = -1;
  sub_1000BC20(48, *(_BYTE *)(v1 + 11), &v3);
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 60) = 0;
  return sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 20) + 60));
}

//----- (10008D90) --------------------------------------------------------
int __usercall sub_10008D90@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  char v3; // [sp+0h] [bp-38h]@1
  char v4; // [sp+1h] [bp-37h]@1
  char v5; // [sp+4h] [bp-34h]@1
  char v6; // [sp+1Ch] [bp-1Ch]@1

  v1 = *(_DWORD *)(a1 + 24);
  v3 = 3;
  v5 = 1;
  v6 = 0;
  v4 = -1;
  sub_1000BC20(48, *(_BYTE *)(v1 + 11), &v3);
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 60) = 1;
  return sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 20) + 60));
}

//----- (10008E00) --------------------------------------------------------
int __usercall sub_10008E00@<eax>(unsigned int a1@<eax>, int a2, char a3)
{
  unsigned int v3; // edi@1
  char v4; // bl@1
  char v5; // al@2
  int result; // eax@2
  char v7; // [sp+Fh] [bp-61h]@2
  char v8[4]; // [sp+10h] [bp-60h]@7
  int v9; // [sp+14h] [bp-5Ch]@10
  int v10; // [sp+18h] [bp-58h]@7
  int v11; // [sp+1Ch] [bp-54h]@10
  char v12; // [sp+20h] [bp-50h]@1
  char v13; // [sp+22h] [bp-4Eh]@5
  int v14; // [sp+38h] [bp-38h]@6
  int v15; // [sp+3Ch] [bp-34h]@9
  int v16; // [sp+40h] [bp-30h]@6
  int v17; // [sp+44h] [bp-2Ch]@9

  v3 = a1;
  v4 = sub_1000EA50(a1);
  sub_1000E570(v3, a3, (int)&v12);
  if ( v3 == 0x3FFFF )
  {
    v5 = *(_BYTE *)(a2 + 11);
    v7 = 15;
    result = sub_1000BC20(66, v5, &v7);
  }
  else if ( v4 && a3 != -1 && v13 )
  {
    if ( v14 >= v16 )
    {
      *(_DWORD *)v8 = v14;
      v10 = v16;
    }
    else
    {
      *(_DWORD *)v8 = v16;
      v10 = v14;
    }
    if ( v15 >= v17 )
    {
      v9 = v15;
      v11 = v17;
    }
    else
    {
      v9 = v17;
      v11 = v15;
    }
    result = sub_1000BC20(2, *(_BYTE *)(a2 + 11), v8);
  }
  else
  {
    sub_10008570(v3, (int)v8);
    result = sub_1000BC20(2, *(_BYTE *)(a2 + 11), v8);
  }
  return result;
}

//----- (10008EE0) --------------------------------------------------------
int __usercall sub_10008EE0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // edi@1
  int result; // eax@10
  char v5; // ST10_1@11
  bool v6; // [sp+12h] [bp-202h]@2
  char v7; // [sp+13h] [bp-201h]@11
  char v8[4]; // [sp+14h] [bp-200h]@5
  double v9; // [sp+18h] [bp-1FCh]@2
  double v10; // [sp+20h] [bp-1F4h]@11
  char v11; // [sp+28h] [bp-1ECh]@11
  char v12; // [sp+29h] [bp-1EBh]@11
  int v13; // [sp+2Ch] [bp-1E8h]@11
  char v14; // [sp+34h] [bp-1E0h]@2
  char v15; // [sp+44h] [bp-1D0h]@6
  char v16; // [sp+4Ah] [bp-1CAh]@6
  float v17; // [sp+70h] [bp-1A4h]@8
  unsigned __int8 v18; // [sp+80h] [bp-194h]@2

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 == 0x3FFFF )
  {
    v6 = 0;
    *(_BYTE *)a1 = 4;
    sub_10014200(0, (int)&v9);
  }
  else
  {
    sub_10008570(v3, (int)&v14);
    sub_1000D880(0x64u, (char *)&v18);
    v6 = v18 != 0;
    sub_1000D510(0, *(_DWORD *)(v2 + 4), &v9);
  }
  sub_1000BC20(46, *(_BYTE *)(a2 + 11), (char *)v2);
  if ( v6 )
  {
    v8[0] = 0;
    if ( v18 )
    {
      do
      {
        sub_1000D990(100, v8[0], &v15);
        if ( v16 == 2 && v15 == 3 )
          v17 = 3704.0;
        sub_10008140((int)&v14, (int)&v15);
        ++v8[0];
      }
      while ( v8[0] < v18 );
    }
    result = sub_1000BC20(2, *(_BYTE *)(a2 + 11), &v14);
  }
  else
  {
    sub_10015170((int)&v13, v9, v10);
    v5 = *(_BYTE *)(a2 + 11);
    v11 = 1;
    v12 = 1;
    v7 = 15;
    sub_1000BC20(3, v5, &v11);
    result = sub_1000BC20(66, *(_BYTE *)(a2 + 11), &v7);
  }
  return result;
}

//----- (10009050) --------------------------------------------------------
int __cdecl sub_10009050(int a1, double a2, int a3)
{
  int v3; // ebp@1
  char v4; // al@1
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  unsigned __int8 v8; // bl@3
  int v9; // ecx@12
  int v10; // eax@12
  int v11; // eax@12
  unsigned __int8 v12; // cl@12
  char v13; // al@16
  char v14; // ST04_1@16
  signed int v15; // eax@17
  char v16; // cl@20
  char v17; // al@27
  char v18; // cl@43
  char v19; // ST18_1@52
  char v21; // [sp+13h] [bp-55h]@20
  char v22; // [sp+14h] [bp-54h]@46
  char v23; // [sp+15h] [bp-53h]@46
  char v24; // [sp+16h] [bp-52h]@47
  int v25; // [sp+18h] [bp-50h]@3
  int v26; // [sp+1Ch] [bp-4Ch]@16
  int v27; // [sp+20h] [bp-48h]@16
  int v28; // [sp+24h] [bp-44h]@1
  int v29; // [sp+28h] [bp-40h]@1
  char v30; // [sp+2Ch] [bp-3Ch]@16
  char v31; // [sp+2Dh] [bp-3Bh]@16
  int v32; // [sp+30h] [bp-38h]@16
  int v33; // [sp+34h] [bp-34h]@16
  char v34; // [sp+38h] [bp-30h]@5
  unsigned __int8 v35; // [sp+39h] [bp-2Fh]@5
  unsigned __int8 v36; // [sp+3Ah] [bp-2Eh]@5
  unsigned __int8 v37; // [sp+3Bh] [bp-2Dh]@9
  unsigned __int8 v38; // [sp+3Ch] [bp-2Ch]@9
  unsigned __int8 v39; // [sp+3Dh] [bp-2Bh]@7
  unsigned __int8 v40; // [sp+3Eh] [bp-2Ah]@7
  unsigned __int8 v41; // [sp+3Fh] [bp-29h]@11
  unsigned __int8 v42; // [sp+40h] [bp-28h]@11
  unsigned __int8 v43; // [sp+43h] [bp-25h]@12
  double v44; // [sp+48h] [bp-20h]@16
  double v45; // [sp+50h] [bp-18h]@16
  char v46[4]; // [sp+58h] [bp-10h]@3
  int v47; // [sp+5Ch] [bp-Ch]@3
  int v48; // [sp+60h] [bp-8h]@3
  int v49; // [sp+64h] [bp-4h]@3
  char v50; // [sp+6Ch] [bp+4h]@1
  unsigned __int8 v51; // [sp+78h] [bp+10h]@25

  v3 = a1;
  v4 = sub_1000DC20(LOBYTE(a2));
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_DWORD *)(v5 + 48);
  v7 = *(_DWORD *)(v5 + 52);
  v28 = v6;
  v29 = v7;
  v50 = 0;
  if ( v4 && BYTE4(a2) != 9 )
  {
    *(_DWORD *)v46 = 0x7FFFFFFF;
    v47 = 0x7FFFFFFF;
    v48 = 0x7FFFFFFF;
    v49 = 0x7FFFFFFF;
    v8 = 0;
    LOBYTE(v25) = v4 - 1;
    switch ( BYTE4(a2) )
    {
      case 4u:
        v8 = 0;
        LOBYTE(v25) = v4 - 1;
        goto LABEL_26;
      case 5u:
        sub_1000C390(LOBYTE(a2), 0, 0xFFu, 0xFFu, (int)&v34);
        v8 = v36;
        LOBYTE(v25) = v35;
        if ( v36 < v35 )
          goto LABEL_26;
        goto LABEL_27;
      case 6u:
        sub_1000C390(LOBYTE(a2), 0, 0xFFu, 0xFFu, (int)&v34);
        v8 = v40;
        LOBYTE(v25) = v39;
        if ( v40 < v39 )
          goto LABEL_26;
        goto LABEL_27;
      case 7u:
        sub_1000C390(LOBYTE(a2), 0, 0xFFu, 0xFFu, (int)&v34);
        v8 = v38;
        LOBYTE(v25) = v37;
        if ( v38 < v37 )
          goto LABEL_26;
        goto LABEL_27;
      case 8u:
        sub_1000C390(LOBYTE(a2), 0, 0xFFu, 0xFFu, (int)&v34);
        if ( v42 <= v41 )
        {
          v9 = v42 - 1;
          v10 = v9 < 0;
          LOBYTE(v10) = v9 <= 0;
          v11 = v9 & (v10 - 1);
          v8 = v11;
          v12 = v41 + 1;
          if ( v41 + 1 >= v43 - 1 )
            v12 = v43 - 1;
          LOBYTE(v25) = v12;
          if ( (unsigned __int8)v11 < v12 )
            goto LABEL_26;
        }
        goto LABEL_27;
      case 2u:
        v13 = sub_1000DC60(LOBYTE(a2), a3);
        sub_1000D510(0, v13, &v44);
        sub_10015170((int)&v26, v44, v45);
        v32 = v26;
        v14 = *(_BYTE *)(v3 + 11);
        v30 = 1;
        v33 = v27;
        v31 = 1;
        sub_1000BC20(3, v14, &v30);
        goto LABEL_26;
      case 0xAu:
        v15 = sub_1000D910(LOBYTE(a2));
        if ( v15 != 0x3FFFF )
        {
          v50 = 1;
          sub_1000D510(0, v15, &v44);
          sub_10015170((int)&v26, v44, v45);
          v30 = 1;
          v32 = v26;
          v33 = v27;
          v31 = 1;
          if ( !byte_1010EDF8 )
            sub_1000B930(23, *(_BYTE *)(v3 + 11), (int)&byte_1010EDF3);
          v16 = *(_BYTE *)(v3 + 11);
          v21 = 17;
          sub_1000BC20(66, v16, &v21);
          sub_1000BC20(3, *(_BYTE *)(v3 + 11), &v30);
        }
        goto LABEL_27;
      case 0u:
        if ( (_BYTE)a3 )
        {
          v8 = a3 - 1;
          LOBYTE(v25) = a3;
        }
        else
        {
          v8 = 0;
          LOBYTE(v25) = 0;
          if ( v4 == 1 )
            goto LABEL_27;
          LOBYTE(v25) = 1;
        }
LABEL_26:
        v50 = 1;
LABEL_27:
        v17 = BYTE4(a2);
        if ( BYTE4(a2) != 10 && BYTE4(a2) != 2 && v50 == 1 )
        {
          if ( !byte_1010EDF8 )
            sub_1000B930(23, *(_BYTE *)(v3 + 11), (int)&byte_1010EDF3);
          sub_10008260(v8, (int)v46, SLODWORD(a2), v25, *(_BYTE *)(v3 + 312));
          sub_1000BC20(2, *(_BYTE *)(v3 + 11), v46);
          goto LABEL_45;
        }
        if ( v50 )
          goto LABEL_46;
        v6 = v28;
        v7 = v29;
        break;
      case 1u:
        v51 = sub_1000DB90(LOBYTE(a2), a3);
        v8 = v51 - 1;
        LOBYTE(v25) = v51 - 1 + sub_1000DBE0(LOBYTE(a2), v51);
        goto LABEL_26;
      default:
        goto LABEL_27;
    }
  }
  if ( BYTE4(a2) != 2 )
  {
    if ( byte_1010EDF8 && byte_1010EDF3 )
    {
      if ( v6 == -1426060602 && v7 == 32849 )
      {
        sub_1000BC20(66, *(_BYTE *)(v3 + 11), &byte_1010EDF3);
        goto LABEL_44;
      }
    }
    else if ( v6 == -1426060602 && v7 == 32849 )
    {
      goto LABEL_44;
    }
    v18 = *(_BYTE *)(v3 + 11);
    v21 = 17;
    sub_1000BC20(66, v18, &v21);
  }
LABEL_44:
  sub_1000BC20(10, *(_BYTE *)(v3 + 11), 0);
LABEL_45:
  v17 = BYTE4(a2);
LABEL_46:
  byte_1010EDF8 = v50;
  v23 = LOBYTE(a2);
  v22 = 1;
  if ( v17 == 1 || (v24 = 0, v17 == 2) )
    v24 = 1;
  if ( !LOBYTE(a2) && !*(_BYTE *)(v3 + 312) )
    v22 = 2;
  v19 = *(_BYTE *)(v3 + 11);
  *(_BYTE *)(v3 + 312) = 0;
  return sub_1000BC20(50, v19, &v22);
}
// 1010EDF3: using guessed type char byte_1010EDF3;
// 1010EDF8: using guessed type char byte_1010EDF8;

//----- (100094E0) --------------------------------------------------------
int __usercall sub_100094E0@<eax>(int a1@<esi>, int a2, double a3, int a4, int a5)
{
  char v6; // [sp+0h] [bp-3Ch]@4
  char v7; // [sp+1h] [bp-3Bh]@4
  int v8; // [sp+4h] [bp-38h]@4
  unsigned int v9; // [sp+8h] [bp-34h]@4
  int v10; // [sp+Ch] [bp-30h]@7
  unsigned int v11; // [sp+10h] [bp-2Ch]@7
  double v12; // [sp+14h] [bp-28h]@7
  double v13; // [sp+1Ch] [bp-20h]@7
  char v14[4]; // [sp+24h] [bp-18h]@1
  double v15; // [sp+28h] [bp-14h]@1
  int v16; // [sp+30h] [bp-Ch]@1
  int v17; // [sp+34h] [bp-8h]@1

  *(_DWORD *)v14 = a2;
  v17 = a5;
  v15 = a3;
  v16 = a4;
  if ( (_BYTE)a2 == 4 )
  {
    if ( LODWORD(a3) == 0x3FFFF )
      goto LABEL_4;
LABEL_7:
    sub_1000D510(0, SLOBYTE(a3), &v12);
    sub_10015170((int)&v10, v12, v13);
    v6 = 1;
    v8 = v10;
    v9 = v11;
    v7 = 1;
    goto LABEL_5;
  }
  if ( LODWORD(a3) != 0x3FFFF )
    goto LABEL_7;
  v14[0] = 0;
LABEL_4:
  v6 = 0;
  v8 = 2147483648;
  v9 = 2147483648;
  v7 = 0;
LABEL_5:
  sub_1000BC20(3, *(_BYTE *)(a1 + 11), &v6);
  return sub_1000BC20(21, *(_BYTE *)(a1 + 11), v14);
}

//----- (100095F0) --------------------------------------------------------
int __usercall sub_100095F0@<eax>(char *a1@<esi>, const char *a2)
{
  char *v2; // eax@1
  unsigned __int8 v3; // bl@1
  char v4; // cl@2
  int v5; // ecx@4
  unsigned int v6; // kr00_4@7
  int result; // eax@8
  char v8[72]; // [sp+4h] [bp-4Ch]@1
  char v9[72]; // [sp+5h] [bp-4Bh]@3

  strcpy(v8, a2);
  sub_10011960(v8, 6u, 1);
  v2 = v8;
  v3 = 0;
  do
    v4 = *v2++;
  while ( v4 );
  if ( v2 != v9 )
  {
    v5 = 0;
    do
    {
      if ( !(byte_10067268[2 * (unsigned __int8)v8[v5]] & 0x51) )
        v8[v5] = 32;
      ++v3;
      v6 = strlen(v8);
      v5 = v3;
    }
    while ( v3 < v6 );
  }
  sub_10011CB0(v8, 7, (int (__cdecl *)(int, int))sub_100095D0, 0);
  strcpy(a1, v8);
  return result;
}
// 100095D0: using guessed type int sub_100095D0();
// 100095F0: using guessed type char var_4C[72];

//----- (100096B0) --------------------------------------------------------
int __thiscall sub_100096B0(void *this)
{
  void *v1; // esi@1
  __int16 v3; // [sp+4h] [bp-60h]@1
  int v4; // [sp+8h] [bp-5Ch]@1
  int v5; // [sp+Ch] [bp-58h]@1
  __int16 *v6; // [sp+10h] [bp-54h]@1
  char *v7; // [sp+14h] [bp-50h]@1
  char v8; // [sp+18h] [bp-4Ch]@1

  v1 = this;
  v6 = &v3;
  v8 = 0;
  v3 = 71;
  v4 = 1100;
  v7 = &v8;
  v5 = 24;
  sub_1000C550((int)this + 12, (int)&v5);
  return sub_100095F0((char *)v1 + 28, &v8);
}

//----- (10009720) --------------------------------------------------------
char __usercall sub_10009720@<al>(int a1@<eax>, char a2@<cl>)
{
  char result; // al@2

  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 12) = a2;
  switch ( *(_BYTE *)(*(_DWORD *)(a1 + 20) + 12) )
  {
    case 1:
      result = sub_10008A30(a1);
      break;
    case 4:
      result = sub_10008BD0(a1);
      break;
    case 3:
      result = sub_10008D90(a1);
      break;
    case 2:
      result = sub_10008C70(a1);
      break;
    case 6:
      result = sub_10008B60(a1);
      break;
    case 5:
      result = sub_10008AF0(a1);
      break;
    default:
      result = sub_10008D20(a1);
      break;
  }
  return result;
}

//----- (10009790) --------------------------------------------------------
int __usercall sub_10009790@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, char a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // ecx@1
  char v9[4]; // [sp+4h] [bp-18h]@1
  int v10; // [sp+8h] [bp-14h]@1
  int v11; // [sp+Ch] [bp-10h]@1
  int v12; // [sp+10h] [bp-Ch]@1
  int v13; // [sp+14h] [bp-8h]@1

  v4 = *(_DWORD *)(a3 + 36);
  *(_DWORD *)v9 = *(_DWORD *)(a3 + 28);
  v5 = a1;
  v6 = *(_DWORD *)(a3 + 32);
  v12 = *(_DWORD *)(a3 + 40);
  v10 = v6;
  v7 = *(_DWORD *)(a3 + 44);
  v11 = v4;
  v13 = v7;
  v10 = 0x3FFFF;
  if ( a4 == 1 )
  {
    if ( *(_WORD *)(a2 + 24) != -1 && *(_DWORD *)a2 )
      sub_10009720(v5, 5);
    else
      sub_10008D20(v5);
    sub_1000BC20(22, *(_BYTE *)(a3 + 11), (char *)(a2 + 26));
    sub_1000BC20(21, *(_BYTE *)(*(_DWORD *)(v5 + 24) + 11), v9);
  }
  else if ( a4 == 2 )
  {
    if ( *(_WORD *)(a2 + 44) != -1 && *(_DWORD *)(a2 + 28) )
      sub_10009720(v5, 5);
    else
      sub_10008D20(v5);
    sub_1000BC20(22, *(_BYTE *)(a3 + 11), (char *)(a2 + 44));
    sub_1000BC20(21, *(_BYTE *)(*(_DWORD *)(v5 + 24) + 11), v9);
  }
  sub_1000BC20(26, *(_BYTE *)(a3 + 11), &a4);
  return sub_1000BC20(25, *(_BYTE *)(a3 + 11), (char *)a2);
}

//----- (100098A0) --------------------------------------------------------
int __cdecl sub_100098A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  char v8; // [sp+14h] [bp-3Ch]@2
  char v9[4]; // [sp+24h] [bp-2Ch]@4
  int v10; // [sp+28h] [bp-28h]@4
  int v11; // [sp+2Ch] [bp-24h]@4
  int v12; // [sp+30h] [bp-20h]@4
  int v13; // [sp+34h] [bp-1Ch]@4
  int v14; // [sp+38h] [bp-18h]@1

  v6 = a1;
  v14 = a2;
  if ( a3 == 0x3FFFF )
  {
    LOBYTE(v14) = 0;
  }
  else
  {
    sub_1000D510(0, a3, (double *)&v8);
    sub_1000BC20(72, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v8);
    v6 = a1;
  }
  *(_DWORD *)v9 = v14;
  v10 = a3;
  v11 = a4;
  v12 = a5;
  v13 = a6;
  if ( a3 == 0x3FFFF )
    sub_10008D20(v6);
  else
    sub_10009720(v6, 6);
  return sub_1000BC20(21, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), v9);
}

//----- (10009970) --------------------------------------------------------
char __cdecl sub_10009970(int a1, int a2, int a3, _BYTE *a4)
{
  int v4; // ecx@1
  int v5; // edx@1
  int v6; // eax@1
  char result; // al@3
  int v8; // [sp+10h] [bp-148h]@1
  __int16 *v9; // [sp+14h] [bp-144h]@1
  char *v10; // [sp+18h] [bp-140h]@1
  __int16 v11; // [sp+1Ch] [bp-13Ch]@1
  int v12; // [sp+24h] [bp-134h]@1
  int v13; // [sp+28h] [bp-130h]@1
  int v14; // [sp+2Ch] [bp-12Ch]@1
  int v15; // [sp+30h] [bp-128h]@1
  __int16 v16; // [sp+34h] [bp-124h]@3
  int v17; // [sp+38h] [bp-120h]@3
  int v18; // [sp+3Ch] [bp-11Ch]@3
  int v19; // [sp+40h] [bp-118h]@3
  int v20; // [sp+44h] [bp-114h]@3
  int v21; // [sp+48h] [bp-110h]@3
  char v22; // [sp+100h] [bp-58h]@1
  int v23; // [sp+11Ch] [bp-3Ch]@2

  v4 = *(_DWORD *)(a3 + 292);
  v5 = *(_DWORD *)(a3 + 296);
  v12 = *(_DWORD *)(a3 + 288);
  v6 = *(_DWORD *)(a3 + 300);
  v13 = v4;
  v15 = v6;
  v9 = &v11;
  v14 = v5;
  v11 = 50;
  v10 = &v22;
  v8 = 38;
  sub_1000C550((int)&v12, (int)&v8);
  if ( *(_DWORD *)(a1 + 64) != 9 || v23 )
  {
    result = sub_1000BA30(*(_BYTE *)(a3 + 11), a2);
    if ( result )
    {
      sub_100096B0((void *)a2);
      result = sub_10007E50(a1, a3, (const char *)(a2 + 28));
      *a4 = 2;
    }
  }
  else
  {
    v19 = v13;
    v18 = v12;
    v17 = 0;
    v16 = -32605;
    v20 = v14;
    v21 = v15;
    result = sub_10003EE0(9, (int)&v16, 60000, 1);
  }
  return result;
}

//----- (10009AA0) --------------------------------------------------------
int __cdecl sub_10009AA0(int a1)
{
  char v1; // bl@1
  int v2; // ecx@1
  int v3; // eax@1
  int v4; // eax@2
  int v5; // eax@8
  int v6; // eax@9
  int v7; // eax@10
  int v8; // eax@11
  int v9; // eax@12
  int v10; // eax@13
  int v11; // eax@14
  int v12; // eax@15
  int v13; // eax@16
  int v14; // eax@17
  int v15; // eax@18
  int v16; // eax@20
  int v17; // eax@21
  int v18; // eax@22
  int v19; // eax@23
  int v20; // ecx@26
  int v21; // eax@26
  int v22; // edx@26
  int v23; // ecx@26
  int v24; // edx@26
  int v25; // eax@26
  int v26; // eax@38
  int v27; // edx@38
  int v28; // ecx@38
  int v29; // eax@38
  int v30; // eax@40
  char v32; // [sp+10h] [bp-48h]@41
  char v33; // [sp+11h] [bp-47h]@41
  char v34; // [sp+12h] [bp-46h]@40
  char v35; // [sp+14h] [bp-44h]@5
  char v36; // [sp+16h] [bp-42h]@6
  char v37; // [sp+17h] [bp-41h]@6
  char v38; // [sp+18h] [bp-40h]@6
  char v39; // [sp+19h] [bp-3Fh]@6
  char v40; // [sp+1Ah] [bp-3Eh]@6
  char v41; // [sp+1Bh] [bp-3Dh]@6
  char v42; // [sp+1Dh] [bp-3Bh]@6
  char v43; // [sp+1Eh] [bp-3Ah]@6
  int v44; // [sp+24h] [bp-34h]@38
  char v45; // [sp+28h] [bp-30h]@2
  char v46; // [sp+29h] [bp-2Fh]@3
  char v47; // [sp+2Bh] [bp-2Dh]@3
  char v48; // [sp+2Ch] [bp-2Ch]@3
  char v49; // [sp+2Dh] [bp-2Bh]@3
  char v50; // [sp+2Eh] [bp-2Ah]@3
  char v51; // [sp+31h] [bp-27h]@3
  char v52; // [sp+32h] [bp-26h]@3
  char v53; // [sp+33h] [bp-25h]@3
  char v54; // [sp+45h] [bp-13h]@3

  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 8) = **(_BYTE **)(a1 + 24);
  v1 = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 16) = 0;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20) = 0x3FFFF;
  v2 = *(_DWORD *)(a1 + 8);
  byte_1010EDF2 = *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11);
  v3 = *(_DWORD *)(v2 + 64);
  dword_1010EDF4 = 0;
  dword_1010EDE4 = 0;
  if ( v3 == 6 )
  {
    v4 = sub_100154C0((void *)v2);
    if ( !sub_100040C0(3168 - (v4 != 2), (int)&v45, 41) )
    {
      sub_1000BC20(56, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v47);
      sub_1000BC20(38, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v48);
      sub_1000BC20(58, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v49);
      sub_1000BC20(60, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v50);
      sub_1000BC20(31, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v51);
      sub_1000BC20(65, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v52);
      sub_1000BC20(40, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v46);
      sub_1000BC20(51, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v53);
      sub_1000BC20(43, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v54);
    }
  }
  else if ( v3 == 9 && !sub_100040C0(3156, (int)&v35, 11) )
  {
    sub_1000BC20(56, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v36);
    sub_1000BC20(58, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v37);
    sub_1000BC20(60, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v38);
    sub_1000BC20(31, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v39);
    sub_1000BC20(65, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v40);
    sub_1000BC20(40, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v35);
    sub_1000BC20(51, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v41);
    sub_1000BC20(38, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v42);
    sub_1000BC20(76, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), &v43);
  }
  switch ( **(_BYTE **)(a1 + 24) & 0x1F )
  {
    case 0:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v5 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v5 + 48) = 38289540;
      *(_DWORD *)(v5 + 52) = 97;
      break;
    case 1:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 102;
      v6 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v6 + 48) = 704649729;
      *(_DWORD *)(v6 + 52) = 32853;
      break;
    case 3:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 102;
      v7 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v7 + 48) = -1440596393;
      *(_DWORD *)(v7 + 52) = 114903;
      break;
    case 4:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v8 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v8 + 48) = 672270931;
      *(_DWORD *)(v8 + 52) = 32785;
      break;
    case 5:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v9 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v9 + 48) = 167805573;
      *(_DWORD *)(v9 + 52) = 32849;
      break;
    case 6:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v10 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v10 + 48) = 167838341;
      *(_DWORD *)(v10 + 52) = 32849;
      break;
    case 7:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v11 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v11 + 48) = 8667268;
      *(_DWORD *)(v11 + 52) = 1;
      break;
    case 8:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v12 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v12 + 48) = -1426060602;
      *(_DWORD *)(v12 + 52) = 32849;
      break;
    case 9:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v13 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v13 + 48) = -1426046332;
      *(_DWORD *)(v13 + 52) = 81;
      break;
    case 0xA:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v14 + 48) = 67109377;
      goto LABEL_25;
    case 0xB:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v15 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v15 + 48) = -536731647;
      *(_DWORD *)(v15 + 52) = 3072;
      break;
    case 0xC:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v14 + 48) = 402653185;
      goto LABEL_25;
    case 0xD:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v16 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v16 + 48) = 34095244;
      *(_DWORD *)(v16 + 52) = 97;
      break;
    case 0xE:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v17 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v17 + 48) = 34095244;
      *(_DWORD *)(v17 + 52) = 101;
      break;
    case 0xF:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 102;
      v18 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v18 + 48) = 35667029;
      *(_DWORD *)(v18 + 52) = 12;
      break;
    case 0x10:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 37;
      v19 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v19 + 48) = 537010178;
      *(_DWORD *)(v19 + 52) = 8193;
      break;
    default:
      *(_WORD *)(*(_DWORD *)(a1 + 20) + 6) = 102;
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(v14 + 48) = 0;
LABEL_25:
      *(_DWORD *)(v14 + 52) = 0;
      break;
  }
  v20 = *(_DWORD *)(a1 + 24);
  v21 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(v21 + 48) |= *(_DWORD *)(v20 + 316);
  *(_DWORD *)(v21 + 52) |= *(_DWORD *)(v20 + 320);
  v22 = *(_DWORD *)(a1 + 24);
  v23 = *(_DWORD *)(v22 + 324);
  v24 = *(_DWORD *)(v22 + 328);
  v25 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(v25 + 48) &= ~v23;
  *(_DWORD *)(v25 + 52) &= ~v24;
  **(_WORD **)(a1 + 20) = *(_WORD *)(*(_DWORD *)(a1 + 20) + 6);
  sub_100083C0(a1);
  sub_1000BB20(
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48),
    *(_DWORD *)(*(_DWORD *)(a1 + 20) + 52),
    *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11));
  sub_1000BC20(24, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 24) + 6));
  sub_100023A0(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 8), (void *)(*(_DWORD *)(a1 + 24) + 88));
  sub_1000BC20(66, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 24) + 88));
  *(_BYTE *)(*(_DWORD *)(a1 + 24) + 89) = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x10 )
    sub_10002330(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 56) + 8), (char *)(*(_DWORD *)(a1 + 24) + 89));
  sub_1000BC20(47, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), (char *)(*(_DWORD *)(a1 + 24) + 89));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x400000 )
    sub_10008E00(*(_DWORD *)(*(_DWORD *)(a1 + 24) + 32), *(_DWORD *)(a1 + 24), *(_BYTE *)(*(_DWORD *)(a1 + 24) + 9));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 8 )
    sub_100094E0(
      *(_DWORD *)(a1 + 24),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 28),
      *(double *)(*(_DWORD *)(a1 + 24) + 32),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 40),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 44));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x10000 )
    sub_100098A0(
      a1,
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 28),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 32),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 36),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 40),
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 44));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x8000 )
  {
    sub_10009790(a1, *(_DWORD *)(a1 + 24) + 92, *(_DWORD *)(a1 + 24), *(_BYTE *)(*(_DWORD *)(a1 + 24) + 1));
    v1 = 0;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x800000 )
    sub_10008EE0(*(_DWORD *)(a1 + 24) + 48, *(_DWORD *)(a1 + 24));
  v26 = *(_DWORD *)(a1 + 20);
  v27 = *(_DWORD *)(v26 + 52);
  v28 = *(_DWORD *)(v26 + 48);
  v29 = *(_DWORD *)(v26 + 48);
  v44 = v27;
  if ( v29 & 0x1000000 )
  {
    sub_10009050(
      *(_DWORD *)(a1 + 24),
      COERCE_DOUBLE(__PAIR__(*(_BYTE *)(*(_DWORD *)(a1 + 24) + 3), *(_BYTE *)(*(_DWORD *)(a1 + 24) + 10))),
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + 2));
  }
  else
  {
    v30 = *(_DWORD *)(a1 + 24);
    v34 = v1;
    if ( v28 & 1 )
    {
      v32 = v1;
      v33 = v1;
    }
    else
    {
      v32 = 3;
      v33 = -1;
    }
    sub_1000BC20(50, *(_BYTE *)(v30 + 11), &v32);
  }
  sub_10009720(a1, 0);
  *(_BYTE *)(*(_DWORD *)(a1 + 24) + 12) = sub_10002960();
  return sub_1000BC20(5, *(_BYTE *)(*(_DWORD *)(a1 + 24) + 11), 0);
}
// 1010EDE4: using guessed type int dword_1010EDE4;
// 1010EDF2: using guessed type char byte_1010EDF2;
// 1010EDF4: using guessed type int dword_1010EDF4;

//----- (1000A170) --------------------------------------------------------
char __usercall sub_1000A170@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  char v2; // al@1
  char result; // al@3
  int v4; // eax@5
  int v5; // edx@5
  int v6; // ecx@5

  v1 = *(_DWORD *)(a1 + 24);
  v2 = *(_BYTE *)(v1 + 280);
  if ( v2 )
  {
    if ( (unsigned __int8)(v2 - 4) > 2u )
    {
      result = sub_10009720(a1, 4);
      *(_BYTE *)a1 = 2;
    }
    else
    {
      result = sub_10009720(a1, 1);
      *(_BYTE *)a1 = 2;
    }
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 20);
    v5 = *(_DWORD *)(v1 + 284);
    v6 = v1 + 284;
    *(_DWORD *)(v4 + 16) = v5;
    v4 += 16;
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(v4 + 12) = *(_DWORD *)(v6 + 12);
    *(_DWORD *)(v4 + 16) = *(_DWORD *)(v6 + 16);
    result = sub_10009720(a1, 2);
    *(_BYTE *)a1 = 2;
  }
  return result;
}

//----- (1000A1E0) --------------------------------------------------------
char __usercall sub_1000A1E0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  int v6; // eax@5
  int v7; // eax@6
  int v8; // ecx@6
  int v9; // eax@6
  __int64 v10; // rax@6
  __int64 v11; // rax@6
  char v12; // ST10_1@7
  int v13; // eax@8
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // eax@8
  int v17; // eax@13
  int v18; // ecx@14
  char v20; // [sp+Bh] [bp-15h]@7
  int v21; // [sp+10h] [bp-10h]@8
  char v22; // [sp+14h] [bp-Ch]@13
  char v23; // [sp+15h] [bp-Bh]@13
  int v24; // [sp+18h] [bp-8h]@13
  int v25; // [sp+1Ch] [bp-4h]@13

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(_DWORD *)(v2 + 48);
  v4 = *(_DWORD *)(v2 + 52);
  v5 = *(_DWORD *)(v2 + 48) & 0x4000000;
  if ( !v5 )
  {
    LOBYTE(v5) = 0;
    if ( !(v3 & 0x40000000) && !(v3 & 0x10000000) )
    {
      LOBYTE(v5) = 0;
      if ( !(v4 & 0x2000) )
      {
        sub_1000BC20(42, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 249));
        v6 = *(_DWORD *)(v1 + 20);
        if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 249) == 1 )
        {
          *(_DWORD *)(v6 + 36) = *(_DWORD *)(v6 + 48);
          *(_DWORD *)(v6 + 40) = *(_DWORD *)(v6 + 52);
          v7 = *(_DWORD *)(v1 + 20);
          v8 = *(_DWORD *)(v7 + 52);
          *(_DWORD *)(v7 + 48) &= 0xFFFFFF7F;
          *(_DWORD *)(v7 + 52) = v8;
          *(_BYTE *)(*(_DWORD *)(v1 + 20) + 60) = 1;
          sub_1000BC20(49, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(v1 + 20) + 60));
          *(_BYTE *)(*(_DWORD *)(v1 + 24) + 72) = 1;
          sub_100089D0(v1);
          dword_1010EDF4 = sub_10003DB0();
          v9 = *(_DWORD *)(v1 + 24);
          byte_1010EDF2 = *(_BYTE *)(v9 + 11);
          sub_1000B930(13, byte_1010EDF2, v9 + 76);
          v10 = *(_WORD *)(*(_DWORD *)(v1 + 12) + 4);
          *(_WORD *)(*(_DWORD *)(v1 + 24) + 84) = ((signed int)v10 - HIDWORD(v10)) >> 1;
          v11 = *(_WORD *)(*(_DWORD *)(v1 + 12) + 6);
          v5 = ((signed int)v11 - HIDWORD(v11)) >> 1;
          *(_WORD *)(*(_DWORD *)(v1 + 24) + 86) = v5;
        }
        else
        {
          *(_DWORD *)(v6 + 48) = *(_DWORD *)(v6 + 36);
          *(_DWORD *)(v6 + 52) = *(_DWORD *)(v6 + 40);
          v12 = *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11);
          dword_1010EDF4 = 0;
          byte_1010EDF2 = v12;
          sub_1000B930(22, v12, (int)&v20);
          if ( v20 )
          {
            v17 = *(_DWORD *)(v1 + 24);
            v22 = 1;
            v24 = *(_DWORD *)(v17 + 20);
            v25 = *(_DWORD *)(v17 + 24);
            v23 = 1;
            sub_1000BC20(3, *(_BYTE *)(v17 + 11), &v22);
          }
          else
          {
            v13 = *(_DWORD *)(v1 + 20);
            v14 = *(_DWORD *)(v13 + 52);
            v15 = *(_DWORD *)(v13 + 48);
            v16 = *(_DWORD *)(v13 + 48);
            v21 = v14;
            if ( v16 & 0x80000 )
            {
              sub_1000BC20(68, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), 0);
            }
            else if ( v15 & 0x40000 )
            {
              sub_10008EE0(*(_DWORD *)(v1 + 24) + 48, *(_DWORD *)(v1 + 24));
            }
            else
            {
              sub_1000BC20(10, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), 0);
            }
          }
          v5 = *(_DWORD *)(v1 + 24);
          *(_BYTE *)(v5 + 72) = 0;
          v18 = *(_DWORD *)(v1 + 24);
          if ( *(_BYTE *)(v18 + 4) == 1 )
          {
            *(_BYTE *)(v18 + 4) = 0;
            sub_1000BC20(36, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), (char *)(*(_DWORD *)(v1 + 24) + 4));
            LOBYTE(v5) = sub_10009720(v1, 0);
          }
        }
      }
    }
  }
  return v5;
}
// 1010EDF2: using guessed type char byte_1010EDF2;
// 1010EDF4: using guessed type int dword_1010EDF4;

//----- (1000A3F0) --------------------------------------------------------
char __thiscall sub_1000A3F0(int this)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // edx@2
  int v4; // edx@3
  int v5; // eax@8
  int v6; // eax@8
  int v7; // eax@9
  char v8; // al@13
  unsigned int v9; // edi@13
  char v10; // al@16
  int v11; // eax@18
  char result; // al@25
  int v13; // ecx@26
  char v14; // [sp+Eh] [bp-16h]@13
  char v15; // [sp+Fh] [bp-15h]@6
  __int16 v16; // [sp+10h] [bp-14h]@8
  __int16 v17; // [sp+12h] [bp-12h]@8
  int v18; // [sp+14h] [bp-10h]@8
  __int16 v19; // [sp+18h] [bp-Ch]@8
  __int16 v20; // [sp+1Ah] [bp-Ah]@8
  __int16 v21; // [sp+1Ch] [bp-8h]@10

  v1 = this;
  v2 = *(_DWORD *)(this + 24);
  if ( *(_BYTE *)(*(_DWORD *)(this + 20) + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(v2 + 7)) - 1 )
  {
    v3 = *(_DWORD *)(this + 8);
    if ( *(_DWORD *)(v3 + 56) == *(_DWORD *)(v3 + 48) )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v3 + 56) + 264);
      if ( v4 )
      {
        if ( *(_BYTE *)(v4 + 114) != 2 && *(_BYTE *)(v2 + 7) != 1 )
        {
          sub_1000B930(32, *(_BYTE *)(v2 + 11), (int)&v15);
          if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 264) + 114) != (v15 != 0) )
          {
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 264) + 114) = v15 != 0;
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 330) = 1;
          }
        }
      }
    }
    v5 = *(_DWORD *)(v1 + 4);
    v16 = *(_WORD *)v5 - 1;
    v17 = *(_WORD *)(v5 + 2) - 1;
    v6 = *(_DWORD *)(v1 + 12);
    v18 = 96;
    v20 = *(_WORD *)(v6 + 6) + 2;
    v19 = *(_WORD *)(v6 + 4) + 2;
    if ( *(_BYTE *)(v6 + 8) & 0x40 )
    {
      v7 = *(_DWORD *)(v1 + 20);
      if ( *(_BYTE *)(v7 + 3) )
      {
        v21 = 2095;
        *(_BYTE *)(v7 + 3) = 0;
      }
      else
      {
        v21 = 18479;
      }
      sub_1000F330(*(_DWORD *)(v1 + 8), (int)&v18, (int)&v16, 0, &unk_100648D4);
    }
    v8 = sub_1000BC20(0, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), &v14);
    sub_100083B0(v8, v1);
    v9 = 0;
    do
    {
      if ( v14 )
        break;
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 248) != 1 )
        goto LABEL_23;
      sub_10003F60(25);
      v10 = sub_1000BC20(0, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), &v14);
      sub_100083B0(v10, v1);
      ++v9;
    }
    while ( v9 < 0xC );
    if ( v14 == 1 )
    {
      v11 = *(_DWORD *)(v1 + 20);
      if ( *(_BYTE *)(v11 + 9)
        && *(_BYTE *)(v11 + 11)
        && *(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) == *(_DWORD *)(*(_DWORD *)(v1 + 8) + 48) )
      {
        *(_BYTE *)(v11 + 11) = 0;
        sub_1000A1E0(v1);
      }
      *(_BYTE *)(*(_DWORD *)(v1 + 20) + 9) = 0;
      sub_1000C2F0(
        *(_DWORD *)(v1 + 8) + 392,
        **(_WORD **)(v1 + 4),
        *(_WORD *)(*(_DWORD *)(v1 + 4) + 2),
        *(_WORD *)(*(_DWORD *)(v1 + 12) + 4),
        *(_WORD *)(*(_DWORD *)(v1 + 12) + 6),
        *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11));
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 56) + 248) = 0;
      *(_BYTE *)(*(_DWORD *)(v1 + 8) + 392) = 1;
    }
LABEL_23:
    if ( *(_BYTE *)(*(_DWORD *)(v1 + 20) + 9) )
      sub_10008410(v1);
  }
  result = sub_10015560();
  if ( result )
  {
    result = sub_10002960();
    v13 = *(_DWORD *)(v1 + 24);
    if ( result != *(_BYTE *)(v13 + 12) )
    {
      *(_BYTE *)(v13 + 12) = result;
      result = sub_1000BC20(12, *(_BYTE *)(*(_DWORD *)(v1 + 24) + 11), 0);
    }
  }
  return result;
}
// 1010EDFC: using guessed type __int16 word_1010EDFC;

//----- (1000A640) --------------------------------------------------------
char __cdecl sub_1000A640(int a1, int a2, int a3, char a4)
{
  int v4; // ecx@1
  int v5; // eax@1
  char v7; // [sp+0h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+14h] [bp-8h]@1
  int v11; // [sp+18h] [bp-4h]@1

  v4 = *(_DWORD *)(a3 + 16);
  v11 = a3;
  v8 = a1;
  v5 = *(_DWORD *)(a1 + 56);
  v10 = v4;
  LOBYTE(v4) = *(_BYTE *)(v5 + 249);
  v9 = a2;
  v7 = 1;
  if ( (_BYTE)v4 != a4 )
    LOBYTE(v5) = sub_1000A1E0((int)&v7);
  return v5;
}

//----- (1000A690) --------------------------------------------------------
char __cdecl sub_1000A690(int a1, int a2, int a3, _BYTE *a4)
{
  char v4; // ST00_1@1
  __int16 v5; // ax@1
  char v7; // [sp+10h] [bp-1Ch]@1
  int v8; // [sp+14h] [bp-18h]@1
  int v9; // [sp+18h] [bp-14h]@1
  int v10; // [sp+1Ch] [bp-10h]@1
  int v11; // [sp+24h] [bp-8h]@1
  _BYTE *v12; // [sp+28h] [bp-4h]@1

  v4 = a4[11];
  v11 = *((_DWORD *)a4 + 4);
  v10 = a2;
  v8 = a3;
  v12 = a4;
  v7 = 1;
  v9 = a1;
  LOBYTE(v5) = sub_1000BE20(v4);
  if ( !(_BYTE)v5 )
  {
    --*((_BYTE *)&word_1010EDFC + a4[7]);
    *((_DWORD *)a4 + 4) = 0;
    a4[11] = -1;
    sub_10008620((int)&v7);
    LOBYTE(v5) = v11;
    if ( v11 )
    {
      if ( *(_BYTE *)(v11 + 10) == 1 )
      {
        *(_BYTE *)(v11 + 3) = 1;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 1;
        LOBYTE(v5) = sub_10009AA0((int)&v7);
        if ( *v12 & 0x40 )
        {
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) = *(_WORD *)a3;
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42) = *(_WORD *)(a3 + 2);
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 44) = *(_WORD *)(a2 + 4);
          v5 = *(_WORD *)(a2 + 6);
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46) = v5;
        }
      }
    }
  }
  return v5;
}
// 1010EDFC: using guessed type __int16 word_1010EDFC;

//----- (1000A760) --------------------------------------------------------
char __usercall sub_1000A760@<al>(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // esi@1
  int v3; // eax@1
  char v4; // al@2
  int v5; // edi@3
  int v6; // eax@7
  __int64 v7; // rax@8
  __int64 v8; // rax@8
  int v9; // ecx@13
  unsigned __int8 v10; // al@14
  int v11; // eax@19
  int v12; // eax@20
  int v13; // edx@30
  int v14; // esi@31
  int v15; // ecx@32
  int v16; // eax@49
  int v17; // ecx@49
  int v18; // edx@49
  int v19; // edi@51
  unsigned __int8 v20; // al@51
  char v21; // cl@52
  unsigned __int16 v22; // di@69
  int v23; // edx@74
  int v24; // edi@75
  char v25; // cl@76
  bool v26; // zf@94
  __int16 *v28; // [sp-18h] [bp-1F8h]@112
  __int16 *v29; // [sp-10h] [bp-1F0h]@20
  __int64 v30; // [sp-10h] [bp-1F0h]@74
  char v31; // [sp+7h] [bp-1D9h]@31
  char v32; // [sp+8h] [bp-1D8h]@5
  char v33; // [sp+Fh] [bp-1D1h]@44
  int v34; // [sp+14h] [bp-1CCh]@49
  unsigned __int16 v35; // [sp+18h] [bp-1C8h]@67
  char v36; // [sp+80h] [bp-160h]@44
  __int16 v37; // [sp+82h] [bp-15Eh]@116
  int v38; // [sp+84h] [bp-15Ch]@116
  int v39; // [sp+88h] [bp-158h]@116
  __int16 v40; // [sp+8Ch] [bp-154h]@116
  int v41; // [sp+90h] [bp-150h]@120
  int v42; // [sp+94h] [bp-14Ch]@120
  unsigned __int16 v43; // [sp+98h] [bp-148h]@67
  __int16 v44; // [sp+A4h] [bp-13Ch]@19
  int v45; // [sp+A8h] [bp-138h]@19
  int v46; // [sp+ACh] [bp-134h]@19
  int v47; // [sp+B0h] [bp-130h]@19
  int v48; // [sp+B4h] [bp-12Ch]@19
  int v49; // [sp+B8h] [bp-128h]@19
  int v50; // [sp+BCh] [bp-124h]@19
  char v51; // [sp+170h] [bp-70h]@18
  char v52; // [sp+18Ch] [bp-54h]@19
  char v53; // [sp+1D4h] [bp-Ch]@70

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  *(_BYTE *)a1 = 1;
  switch ( *(_WORD *)(v3 + 10) )
  {
    case 0x3C:
      v4 = *(_BYTE *)(v3 + 8);
      if ( v4 >= 0 )
      {
        v5 = 71;
      }
      else
      {
        v5 = 70;
        v4 = -v4;
      }
      v32 = v4;
      if ( dword_1010EDF4 )
        dword_1010EDF4 = sub_10003DB0();
      v6 = *(_DWORD *)(v2 + 24);
      *(_BYTE *)v2 = 0;
      LOBYTE(v3) = sub_1000BC20(v5, *(_BYTE *)(v6 + 11), &v32);
      if ( !(_BYTE)v3 )
      {
        v7 = *(_WORD *)(*(_DWORD *)(v2 + 12) + 4);
        *(_WORD *)(*(_DWORD *)(v2 + 24) + 84) = ((signed int)v7 - HIDWORD(v7)) >> 1;
        v8 = *(_WORD *)(*(_DWORD *)(v2 + 12) + 6);
        v3 = ((signed int)v8 - HIDWORD(v8)) >> 1;
        *(_WORD *)(*(_DWORD *)(v2 + 24) + 86) = v3;
        *(_BYTE *)v2 = 2;
      }
      return v3;
    case 0x2D:
      v3 = *(_DWORD *)(a1 + 20);
      if ( *(_BYTE *)(v3 + 9) )
      {
        *(_BYTE *)(v3 + 11) = 1;
        *(_BYTE *)a1 = 2;
      }
      else
      {
        LOBYTE(v3) = sub_1000A1E0(a1);
        *(_BYTE *)v2 = 2;
      }
      return v3;
    case 0x1C:
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x80;
      if ( v3 )
        return v3;
      v9 = *(_DWORD *)(a1 + 24);
      if ( !*(_BYTE *)(v9 + 72) )
        return v3;
      v10 = *(_BYTE *)(v9 + 280);
      if ( v10 >= 4u && v10 <= 6u )
        goto LABEL_18;
      if ( v10 )
      {
        v48 = *(int *)(v9 + 76);
        v49 = *(_DWORD *)(v9 + 80);
        v44 = -32614;
        LOBYTE(v46) = -1;
        v47 = 0x3FFFF;
        v29 = &v44;
      }
      else
      {
        if ( *(_BYTE *)(v9 + 284) == 2 )
        {
LABEL_18:
          LOBYTE(v3) = sub_1000BA30(*(_BYTE *)(v9 + 11), (int)&v51);
          if ( (_BYTE)v3 )
          {
            sub_100096B0(&v51);
            v11 = *(_DWORD *)(v2 + 24);
            v48 = *(int *)(v11 + 76);
            v49 = *(_DWORD *)(v11 + 80);
            v45 = 0;
            v44 = -32612;
            LOBYTE(v46) = -1;
            v47 = 0x3FFFF;
            sub_10011C30((int)&v50, &v52, 7);
            LOBYTE(v3) = sub_10003EE0(9, (int)&v44, 60000, 0);
            *(_BYTE *)v2 = 2;
            return v3;
          }
LABEL_23:
          *(_BYTE *)v2 = 2;
          return v3;
        }
        LOBYTE(v46) = -1;
        v12 = *(_DWORD *)(v9 + 288);
        *(float *)&v47 = 9.9999996e24;
        *(float *)&v48 = 0.0;
        v50 = v12;
        v49 = 16744448;
        v44 = -32613;
        v29 = &v44;
      }
      v45 = 0;
      LOBYTE(v3) = sub_10003EE0(9, (int)v29, 60000, 0);
      goto LABEL_23;
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
      if ( !(*(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x80) && *(_BYTE *)(*(_DWORD *)(a1 + 24) + 72) )
      {
        if ( !sub_10008870(a1) )
        {
          sub_100089D0(v2);
          dword_1010EDF4 = sub_10003DB0();
        }
        *(_BYTE *)v2 = 2;
      }
      v3 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 52) & 0x10000;
      if ( v3 )
      {
        v13 = *(_DWORD *)(v2 + 24);
        if ( !*(_BYTE *)(v13 + 72) )
        {
          v14 = *(_DWORD *)(v2 + 16);
          v31 = 0;
          v3 = *(_WORD *)(v14 + 10);
          switch ( v3 )
          {
            case 47:
              v15 = 78;
              goto LABEL_36;
            case 51:
              LOBYTE(v3) = *(_BYTE *)(v14 + 8);
              v15 = 78;
              goto LABEL_37;
            case 49:
              LOBYTE(v3) = *(_BYTE *)(v14 + 8);
              v15 = 77;
              goto LABEL_37;
            case 53:
              v15 = 77;
LABEL_36:
              LOBYTE(v3) = -*(_BYTE *)(v14 + 8);
LABEL_37:
              v31 = v3;
              if ( (_BYTE)v3 )
                LOBYTE(v3) = sub_1000BC20(v15, *(_BYTE *)(v13 + 11), &v31);
              break;
            default:
              return v3;
          }
        }
      }
      return v3;
    case 0x20:
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x400;
      if ( v3 )
      {
        v3 = *(_DWORD *)(a1 + 24);
        if ( *(_BYTE *)(v3 + 4) == 1 )
          LOBYTE(v3) = sub_10009720(a1, 0);
      }
      return v3;
    case 0x21:
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 20) + 48) & 0x80;
      if ( v3 )
        return v3;
      v3 = *(_DWORD *)(a1 + 24);
      if ( !*(_BYTE *)(v3 + 72) )
        return v3;
      sub_1000B930(25, *(_BYTE *)(v3 + 11), v3 + 280);
      sub_1000B930(40, *(_BYTE *)(*(_DWORD *)(v2 + 24) + 11), (int)&v36);
      LOBYTE(v3) = sub_1000B930(39, *(_BYTE *)(*(_DWORD *)(v2 + 24) + 11), (int)&v33);
      if ( *(_BYTE *)v2 != 1 )
        return v3;
      v3 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 48) & 0x400;
      if ( v3 )
      {
        sub_1000B930(16, *(_BYTE *)(*(_DWORD *)(v2 + 24) + 11), *(_DWORD *)(v2 + 24) + 4);
        v3 = *(_DWORD *)(v2 + 24);
        if ( *(_BYTE *)(v3 + 4) == 1 )
          LOBYTE(v3) = sub_1000A170(v2);
      }
      if ( *(_BYTE *)v2 != 1 )
        return v3;
      v16 = *(_DWORD *)(v2 + 20);
      v17 = *(_DWORD *)(v16 + 52);
      v18 = *(_DWORD *)(v16 + 48);
      LOBYTE(v16) = *(_DWORD *)(v16 + 48);
      v34 = v17;
      if ( v16 & 4 && !(*(_BYTE *)(*(_DWORD *)(v2 + 12) + 8) & 0x20) )
      {
        if ( ((v19 = *(_DWORD *)(v2 + 24), (v20 = *(_BYTE *)(v19 + 280)) != 0)
           || (v21 = *(_BYTE *)(v19 + 284)) != 0 && v21 != 1 && v21 != 3)
          && (v20 < 4u || v20 > 6u)
          && (v20 || *(_BYTE *)(v19 + 284) != 2)
          && (v20 == 7 || v20 || *(_BYTE *)(v19 + 284) != 3)
          || v20 == 7 )
        {
          if ( v36 != 1 && v36 != 2 && v36 != 6 && v36 != 7 )
          {
            sub_1000F410((int)&v35, (int)&v43);
            if ( v35 || v43 )
            {
              LOBYTE(v3) = sub_10007F80(*(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 12), *(_DWORD *)(v2 + 24));
              *(_BYTE *)v2 = 2;
            }
            else
            {
              v22 = 0;
              do
              {
                sprintf(&v53, "USR%03d", v22);
                if ( sub_1000EF60((int)&v53) == 0x3FFFF )
                  break;
                ++v22;
              }
              while ( v22 < 0x3E8u );
              LOBYTE(v3) = sub_10007E50(*(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 24), &v53);
              *(_BYTE *)v2 = 2;
            }
            return v3;
          }
        }
      }
      v23 = v18 & 0x2000000;
      HIDWORD(v30) = a2;
      if ( !v23
        || ((v24 = *(_DWORD *)(v2 + 24), LOBYTE(v3) = *(_BYTE *)(v24 + 280), (_BYTE)v3)
         || (v25 = *(_BYTE *)(v24 + 284)) != 0 && v25 != 1 && v25 != 3)
        && ((unsigned __int8)v3 < 4u || (unsigned __int8)v3 > 6u)
        && ((_BYTE)v3 || *(_BYTE *)(v24 + 284) != 2)
        && (_BYTE)v3 != 7
        && ((_BYTE)v3 || *(_BYTE *)(v24 + 284) != 3)
        || v36 && v36 != 3 )
      {
        LOBYTE(v3) = v23;
        if ( v23 && (v36 == 1 || v36 == 2) )
        {
          v47 = v38;
          HIWORD(v46) = v37;
          v48 = v39;
          v44 = -32601;
          LOWORD(v49) = v40;
        }
        else
        {
          if ( !v23 || v36 != 6 && v36 != 7 )
            return v3;
          v44 = -32615;
          v47 = v41;
          v48 = v42;
        }
        LOBYTE(v46) = v36;
        v45 = 0;
        goto LABEL_122;
      }
      if ( ((_BYTE)v3 == 7 || !(_BYTE)v3 && *(_BYTE *)(v24 + 284) == 3) && (_BYTE)v3 && (_BYTE)v3 != 7 )
        goto LABEL_99;
      if ( (unsigned __int8)v3 >= 4u )
      {
        v26 = (_BYTE)v3 == 6;
        if ( (unsigned __int8)v3 <= 6u )
          goto LABEL_98;
      }
      if ( !(_BYTE)v3 && *(_BYTE *)(v24 + 284) == 2 )
      {
        v26 = 0;
LABEL_98:
        if ( !v26 )
        {
LABEL_99:
          if ( !(*(_BYTE *)(*(_DWORD *)(v2 + 12) + 8) & 0x20) )
          {
            sub_1000F410((int)&v35, (int)&v43);
            if ( v35 > 0u || v43 > 0u )
            {
              LOBYTE(v3) = sub_10007F80(*(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 12), *(_DWORD *)(v2 + 24));
            }
            else
            {
              LOBYTE(v3) = sub_1000BA30(*(_BYTE *)(*(_DWORD *)(v2 + 24) + 11), (int)&v51);
              if ( !(_BYTE)v3 )
                return v3;
              sub_100096B0(&v51);
              LOBYTE(v3) = sub_10007E50(*(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 24), &v52);
            }
            goto LABEL_124;
          }
        }
      }
      if ( (_BYTE)v3 == 6 && !(*(_BYTE *)(*(_DWORD *)(v2 + 12) + 8) & 0x20) )
      {
        LOBYTE(v3) = sub_10009970(*(_DWORD *)(v2 + 8), (int)&v51, v24, (_BYTE *)v2);
        return v3;
      }
      if ( !(_BYTE)v3 )
      {
        if ( !(*(_BYTE *)(*(_DWORD *)(v2 + 12) + 8) & 0x20) )
        {
          LODWORD(v30) = *(_DWORD *)(v24 + 288);
          LOBYTE(v3) = sub_1000D640(v30);
          if ( (unsigned __int8)v3 > 7u )
            return v3;
          v46 = *(_DWORD *)(*(_DWORD *)(v2 + 24) + 288);
          v45 = 0;
          v44 = -32608;
          v28 = &v44;
          goto LABEL_123;
        }
        v45 = 0;
        v44 = -32682;
        v46 = *(_DWORD *)(v24 + 288);
LABEL_122:
        v28 = &v44;
LABEL_123:
        LOBYTE(v3) = sub_10003EE0(9, (int)v28, 60000, 1);
LABEL_124:
        *(_BYTE *)v2 = 2;
      }
      return v3;
    default:
      return v3;
  }
}
// 1000A760: could not find valid save-restore pair for ebp
// 1010EDF4: using guessed type int dword_1010EDF4;

//----- (1000B0B0) --------------------------------------------------------
char __cdecl sub_1000B0B0(int a1, int a2, _WORD *a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // esi@1
  int v7; // ebp@1
  _WORD *v8; // eax@5
  __int16 v9; // dx@5
  int v10; // eax@5
  int v11; // eax@14
  char v12; // dl@14
  bool v13; // zf@15
  char v14; // al@16
  unsigned __int16 v15; // si@23
  __int16 v16; // ax@30
  unsigned __int8 v17; // al@34
  char v18; // cl@35
  unsigned __int16 v19; // si@46
  int v20; // eax@66
  char v22; // [sp+12h] [bp-F6h]@16
  char v23; // [sp+13h] [bp-F5h]@1
  char v24; // [sp+14h] [bp-F4h]@1
  _WORD *v25; // [sp+18h] [bp-F0h]@1
  int v26; // [sp+1Ch] [bp-ECh]@1
  int v27; // [sp+20h] [bp-E8h]@1
  int v28; // [sp+24h] [bp-E4h]@1
  int v29; // [sp+28h] [bp-E0h]@1
  _BYTE *v30; // [sp+2Ch] [bp-DCh]@1
  char v31; // [sp+33h] [bp-D5h]@62
  int v32; // [sp+34h] [bp-D4h]@1
  int v33; // [sp+38h] [bp-D0h]@24
  char v34; // [sp+3Fh] [bp-C9h]@28
  _WORD *v35; // [sp+40h] [bp-C8h]@1
  int v36; // [sp+44h] [bp-C4h]@1
  __int16 v37; // [sp+48h] [bp-C0h]@21
  int v38; // [sp+4Ch] [bp-BCh]@21
  int v39; // [sp+50h] [bp-B8h]@22
  char v40; // [sp+54h] [bp-B4h]@26
  char v41; // [sp+58h] [bp-B0h]@26
  char v42; // [sp+94h] [bp-74h]@26
  char v43; // [sp+98h] [bp-70h]@50
  char v44; // [sp+B4h] [bp-54h]@51
  char v45; // [sp+FCh] [bp-Ch]@24

  v36 = a2;
  v27 = a2;
  v5 = *(_WORD *)a5;
  v6 = a1;
  v7 = *(_DWORD *)(a4 + 16);
  v32 = a1;
  v35 = a3;
  v29 = v7;
  v25 = a3;
  v30 = (_BYTE *)a4;
  v28 = a5;
  v24 = 1;
  v26 = a1;
  v23 = 0;
  switch ( v5 )
  {
    case 32833:
      sub_10008620((int)&v24);
      if ( v29 )
      {
        if ( *(_BYTE *)(v29 + 10) == 1 )
        {
          *(_BYTE *)(v29 + 3) = 1;
          sub_10009AA0((int)&v24);
          if ( *v30 & 0x40 )
          {
            v8 = v25;
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) = *v25;
            v9 = v8[1];
            v10 = v27;
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 42) = v9;
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 44) = *(_WORD *)(v10 + 4);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 46) = *(_WORD *)(v10 + 6);
          }
        }
      }
      return 2;
    case 32802:
    case 32871:
      if ( *(_BYTE *)(v7 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7)) - 1 )
      {
        if ( !(*(_BYTE *)(v7 + 4) & 1) )
          goto LABEL_77;
        if ( *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 48) )
          *(_BYTE *)(v7 + 4) &= 0xFEu;
        if ( !(*(_BYTE *)(v7 + 4) & 1) )
        {
LABEL_77:
          sub_100089D0((int)&v24);
          v6 = v32;
        }
        if ( *(_BYTE *)(*(_DWORD *)(v6 + 56) + 249) == 1 )
        {
          v11 = sub_10003DB0();
          v12 = *(_BYTE *)(a4 + 11);
          dword_1010EDF4 = v11;
          byte_1010EDF2 = v12;
        }
      }
      v13 = *(_WORD *)a5 == -32665;
      v24 = 2;
      if ( v13 )
      {
        v22 = 1;
        v14 = sub_1000BC20(23, *(_BYTE *)(a4 + 11), &v22);
        if ( sub_100083B0(v14, (int)&v24) == 1 )
          sub_1000B0B0(v6, v36, v35, a4, &unk_100648CC);
        if ( *(_BYTE *)(a5 + 8) )
        {
          *(_BYTE *)(v7 + 3) = 1;
          sub_1000BC20(12, *(_BYTE *)(a4 + 11), 0);
        }
      }
      return v24;
    case 32843:
      if ( *(_BYTE *)(a4 + 72) == 1 )
      {
        v38 = 0;
        v37 = -32691;
        if ( *(_BYTE *)(a4 + 280) )
        {
          v15 = 0;
          do
          {
            sprintf(&v45, "USR%03d", v15);
            v33 = sub_1000EF60((int)&v45);
            if ( v33 == 0x3FFFF )
              break;
            ++v15;
          }
          while ( v15 < 0x3E8u );
          sub_10015150((int)&v41, *(_DWORD *)(a4 + 76), *(_DWORD *)(a4 + 80));
          sub_1000C6E0(&v45, (int)&v41, (int)&v40);
          v42 |= 6u;
          sub_100040C0(3201, (int)&v23, 1);
          if ( v23 == 1 )
            v42 |= 1u;
          sub_1000F580(&v40, &v33, &v34);
          v39 = v33;
          sub_100015F0(v32, (int)&v37, 12);
        }
        else
        {
          v39 = *(_DWORD *)(a4 + 288);
          sub_100015F0(a1, (int)&v37, 12);
        }
      }
      return v24;
    case 32840:
      sub_1000A760((int)&v24, v7);
      return v24;
    case 32849:
      v16 = *(_WORD *)(a5 + 10);
      if ( !v16 )
      {
        sub_10008000(a1);
        return 2;
      }
      if ( v16 != 1 )
        goto LABEL_52;
      if ( *(_DWORD *)(v7 + 48) & 4
        && (((v17 = *(_BYTE *)(a4 + 280)) != 0 || (v18 = *(_BYTE *)(a4 + 284)) != 0 && v18 != 1 && v18 != 3)
         && (v17 < 4u || v17 > 6u)
         && (v17 || *(_BYTE *)(a4 + 284) != 2)
         && (v17 == 7 || v17 || *(_BYTE *)(a4 + 284) != 3)
         || v17 == 7) )
      {
        v19 = 0;
        do
        {
          sprintf(&v45, "USR%03d", v19);
          if ( sub_1000EF60((int)&v45) == 0x3FFFF )
            break;
          ++v19;
        }
        while ( v19 < 0x3E8u );
        sub_10007E50(v32, a4, &v45);
        v24 = 2;
      }
      else
      {
        if ( sub_1000BA30(*(_BYTE *)(a4 + 11), (int)&v43) )
        {
          sub_100096B0(&v43);
          sub_10007E50(a1, a4, &v44);
        }
LABEL_52:
        v24 = 2;
      }
      return v24;
    case 32773:
      if ( *(_BYTE *)(v7 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7)) - 1 )
      {
        sub_1000B930(23, *(_BYTE *)(a4 + 11), a4 + 88);
        sub_1000A3F0((int)&v24);
        sub_100089D0((int)&v24);
      }
      dword_1010EDE4 = sub_10003DB0();
      return 2;
    case 32851:
      if ( *(_BYTE *)(v7 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7)) - 1 )
      {
        sub_1000B930(25, *(_BYTE *)(a4 + 11), a4 + 280);
        sub_1000A3F0((int)&v24);
      }
      goto LABEL_58;
    case 32774:
      if ( *(_BYTE *)(v7 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7)) - 1 )
      {
        sub_1000A3F0((int)&v24);
        v24 = 2;
      }
      else
      {
LABEL_58:
        v24 = 2;
      }
      return v24;
    case 32852:
      *(_BYTE *)(v7 + 9) = 1;
      sub_10008410((int)&v24);
      return 2;
    case 32853:
      sub_1000B930(12, *(_BYTE *)(a4 + 11), (int)&v31);
      sub_1000B930(23, *(_BYTE *)(a4 + 11), a4 + 88);
      sub_100024A0(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 8), *(_BYTE *)(a4 + 88));
      sub_1000B930(13, *(_BYTE *)(a4 + 11), a4 + 76);
      return 2;
    case 32888:
      if ( *(_BYTE *)(v7 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7)) - 1 )
      {
        if ( dword_1010EDF4 )
        {
          if ( byte_1010EDF2 == *(_BYTE *)(a4 + 11) )
          {
            v20 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(v20 + 249) == 1
              && v20 == *(_DWORD *)(a1 + 48)
              && (unsigned int)(sub_10003DB0() - dword_1010EDF4) >= 0xEA60 )
            {
              sub_1000A1E0((int)&v24);
            }
          }
        }
        sub_1000A3F0((int)&v24);
      }
      return 2;
    case 32841:
      v22 = 0;
      sub_1000BC20(23, *(_BYTE *)(a4 + 11), &v22);
      *(_BYTE *)(v7 + 4) |= 1u;
      return 2;
    case 32792:
      sub_10008100(*(_BYTE *)(a4 + 7), *(_BYTE *)(a4 + 11), 0, 0, 0, 0);
      sub_1000BE20(*(_BYTE *)(a4 + 11));
      --*((_BYTE *)&word_1010EDFC + *(_BYTE *)(a4 + 7));
      *(_DWORD *)(a4 + 16) = 0;
      *(_BYTE *)(a4 + 11) = -1;
      return v24;
    default:
      return v24;
  }
}
// 10008100: using guessed type _DWORD __cdecl sub_10008100(char, char, __int16, __int16, __int16, __int16);
// 1010EDE4: using guessed type int dword_1010EDE4;
// 1010EDF2: using guessed type char byte_1010EDF2;
// 1010EDF4: using guessed type int dword_1010EDF4;
// 1010EDFC: using guessed type __int16 word_1010EDFC;

//----- (1000B760) --------------------------------------------------------
char __cdecl sub_1000B760(int a1, int a2, _WORD *a3, int a4, _WORD *a5)
{
  int v6; // esi@5

  if ( !(unsigned __int8)sub_10008110(a1) )
    return 2;
  if ( *a5 != -32671 && *a5 != -32703 )
  {
    v6 = *(_DWORD *)(a4 + 16);
    if ( v6 && !*(_BYTE *)(v6 + 10) )
    {
      sub_1000B0B0(a1, a2, a3, a4, (int)&unk_100648CC);
      if ( !*(_BYTE *)(v6 + 10) )
        return 2;
      v6 = *(_DWORD *)(a4 + 16);
    }
    if ( *a5 != -32734
      && *a5 != -32665
      && *(_BYTE *)(v6 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a2 + 9)) - 1
      && *(_BYTE *)(v6 + 4) & 2 )
    {
      sub_1000B0B0(a1, a2, a3, a4, (int)&unk_100648BC);
      *(_BYTE *)(v6 + 4) &= 0xFDu;
    }
    *(_BYTE *)(v6 + 4) |= 2u;
    if ( *(_BYTE *)(v6 + 13) == *((_BYTE *)&word_1010EDFC + *(_BYTE *)(a2 + 9)) - 1 )
      *(_BYTE *)(v6 + 4) &= 0xFDu;
  }
  return sub_1000B0B0(a1, a2, a3, a4, (int)a5);
}
// 1010EDFC: using guessed type __int16 word_1010EDFC;

//----- (1000B860) --------------------------------------------------------
char __usercall sub_1000B860@<al>(_BYTE *a1@<ecx>, char a2@<bl>)
{
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  switch ( a2 )
  {
    case 2:
      LOBYTE(v4) = *a1;
      break;
    case 3:
      LOBYTE(v4) = *a1;
      break;
    case 5:
      LOBYTE(v4) = *a1;
      break;
    default:
      if ( a2 != 1 )
        sub_10003C10("..\\lib\\acl\\iop\\strm\\iop_strm_intf.c", 1404, 1, 0);
      break;
  }
  LOBYTE(v3) = a2;
  sub_10014AC0(2, 9, &v3, 0, 8, 1);
  sub_10014C00(2, 9u, 0xFFFFFFF);
  return 1;
}

//----- (1000B900) --------------------------------------------------------
char sub_1000B900()
{
  char result; // al@1

  result = sub_1000F680();
  if ( result )
  {
    result = sub_100157B0(4);
    if ( result )
      result = sub_1000B860(0, 1);
  }
  return result;
}

//----- (1000B930) --------------------------------------------------------
signed int __cdecl sub_1000B930(char a1, char a2, int a3)
{
  signed int v3; // esi@1
  signed int result; // eax@2
  int v5; // [sp+4h] [bp-B8h]@1
  int v6; // [sp+8h] [bp-B4h]@1
  int v7; // [sp+Ch] [bp-B0h]@1
  __int16 *v8; // [sp+10h] [bp-ACh]@1
  int v9; // [sp+14h] [bp-A8h]@1
  int *v10; // [sp+18h] [bp-A4h]@1
  int v11; // [sp+1Ch] [bp-A0h]@1
  int v12; // [sp+20h] [bp-9Ch]@1
  __int16 v13; // [sp+24h] [bp-98h]@1
  char v14; // [sp+28h] [bp-94h]@1
  char v15; // [sp+29h] [bp-93h]@1

  v7 = 0;
  v13 = -32765;
  v14 = a1;
  v15 = a2;
  v8 = &v13;
  v3 = sub_1000C7B0(a1);
  v12 = 4;
  v9 = 6;
  v10 = &v5;
  v11 = 300;
  v5 = a3;
  v6 = v3;
  if ( sub_10003F10(38, (int)&v8) )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 177, 0, 0);
    result = 1;
  }
  else
  {
    result = v7;
    if ( v7 || v6 != v3 )
    {
      sub_10003C10(".\\mpm\\mpm_intf.c", 186, 0, 0);
      result = 3;
    }
  }
  return result;
}

//----- (1000BA30) --------------------------------------------------------
char __cdecl sub_1000BA30(char a1, int a2)
{
  char result; // al@4
  int v3; // [sp+8h] [bp-B8h]@1
  int v4; // [sp+Ch] [bp-B4h]@1
  int v5; // [sp+10h] [bp-B0h]@1
  __int16 *v6; // [sp+14h] [bp-ACh]@1
  int v7; // [sp+18h] [bp-A8h]@1
  int *v8; // [sp+1Ch] [bp-A4h]@1
  int v9; // [sp+20h] [bp-A0h]@1
  int v10; // [sp+24h] [bp-9Ch]@1
  __int16 v11; // [sp+28h] [bp-98h]@1
  char v12; // [sp+2Ch] [bp-94h]@1

  v5 = 0;
  v12 = a1;
  v11 = -32764;
  v10 = 4;
  v6 = &v11;
  v7 = 5;
  v8 = &v3;
  v9 = 300;
  v3 = a2;
  v4 = 100;
  if ( sub_10003F10(38, (int)&v6) || v5 || v4 != 100 )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 258, 0, 0);
    result = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 98) = 0;
    result = 1;
  }
  return result;
}

//----- (1000BB20) --------------------------------------------------------
char __cdecl sub_1000BB20(int a1, int a2, char a3)
{
  char result; // al@4
  char v4; // [sp+3h] [bp-B9h]@1
  char *v5; // [sp+4h] [bp-B8h]@1
  int v6; // [sp+8h] [bp-B4h]@1
  int v7; // [sp+Ch] [bp-B0h]@1
  __int16 *v8; // [sp+10h] [bp-ACh]@1
  int v9; // [sp+14h] [bp-A8h]@1
  int *v10; // [sp+18h] [bp-A4h]@1
  int v11; // [sp+1Ch] [bp-A0h]@1
  int v12; // [sp+20h] [bp-9Ch]@1
  __int16 v13; // [sp+24h] [bp-98h]@1
  int v14; // [sp+28h] [bp-94h]@1
  int v15; // [sp+2Ch] [bp-90h]@1
  char v16; // [sp+30h] [bp-8Ch]@1

  v7 = 0;
  v14 = a1;
  v8 = &v13;
  v15 = a2;
  v16 = a3;
  v13 = -32763;
  v12 = 4;
  v9 = 16;
  v10 = (int *)&v5;
  v11 = 300;
  v5 = &v4;
  v6 = 1;
  if ( sub_10003F10(38, (int)&v8) || v4 || v6 != 1 )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 338, 0, 0);
    result = 3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000BC20) --------------------------------------------------------
int __cdecl sub_1000BC20(int a1, char a2, char *a3)
{
  signed int v3; // edi@1
  signed int v4; // esi@7
  int i; // eax@7
  int result; // eax@11
  char *v7; // [sp+Ch] [bp-BCh]@1
  int v8; // [sp+10h] [bp-B8h]@1
  int v9; // [sp+14h] [bp-B4h]@1
  __int16 *v10; // [sp+18h] [bp-B0h]@1
  int v11; // [sp+1Ch] [bp-ACh]@1
  int *v12; // [sp+20h] [bp-A8h]@1
  int v13; // [sp+24h] [bp-A4h]@1
  int v14; // [sp+28h] [bp-A0h]@1
  int v15; // [sp+2Ch] [bp-9Ch]@1
  __int16 v16; // [sp+30h] [bp-98h]@1
  __int16 v17; // [sp+34h] [bp-94h]@1
  char v18; // [sp+36h] [bp-92h]@1
  char v19; // [sp+37h] [bp-91h]@6

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v16 = -32762;
  v17 = a1;
  v18 = a2;
  v3 = sub_1000C870(a1);
  v15 = sub_1000C9C0(a1);
  switch ( (unsigned __int16)a1 )
  {
    case 8u:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x22u:
    case 0x23u:
    case 0x26u:
    case 0x27u:
    case 0x28u:
    case 0x29u:
    case 0x2Au:
    case 0x2Fu:
    case 0x33u:
    case 0x35u:
    case 0x36u:
    case 0x37u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x3Bu:
    case 0x3Cu:
    case 0x3Du:
    case 0x3Fu:
    case 0x40u:
    case 0x41u:
    case 0x45u:
    case 0x48u:
    case 0x4Cu:
      sub_1000CAB0(4);
      break;
    default:
      break;
  }
  if ( v3 )
  {
    if ( !a3 )
      sub_10003C10(".\\mpm\\mpm_intf.c", 479, 1, 0);
    memcpy(&v19, a3, v3);
  }
  v10 = &v16;
  v14 = 4;
  v11 = v3 + 7;
  v12 = (int *)&v7;
  v13 = 300;
  v7 = a3;
  v8 = v15;
  v4 = 1;
  for ( i = sub_10003F10(38, (int)&v10); i == 16; i = sub_10003F10(38, (int)&v10) )
  {
    if ( v4 >= 6 )
      break;
    sub_10003C10(".\\mpm\\mpm_intf.c", 507, 0, 0);
    ++v4;
    v14 = 4;
    v10 = &v16;
    v12 = (int *)&v7;
  }
  if ( i || (result = v9) != 0 || v8 != v15 )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 524, 0, 0);
    result = 1;
  }
  return result;
}

//----- (1000BE10) --------------------------------------------------------
void sub_1000BE10()
{
  dword_101E28CC = -15;
}
// 101E28CC: using guessed type int dword_101E28CC;

//----- (1000BE20) --------------------------------------------------------
char __cdecl sub_1000BE20(char a1)
{
  char result; // al@4
  char v2; // [sp+3h] [bp-B9h]@1
  char *v3; // [sp+4h] [bp-B8h]@1
  int v4; // [sp+8h] [bp-B4h]@1
  int v5; // [sp+Ch] [bp-B0h]@1
  __int16 *v6; // [sp+10h] [bp-ACh]@1
  int v7; // [sp+14h] [bp-A8h]@1
  int *v8; // [sp+18h] [bp-A4h]@1
  int v9; // [sp+1Ch] [bp-A0h]@1
  int v10; // [sp+20h] [bp-9Ch]@1
  __int16 v11; // [sp+24h] [bp-98h]@1
  char v12; // [sp+28h] [bp-94h]@1

  v5 = 0;
  v6 = &v11;
  v12 = a1;
  v11 = -32761;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 300;
  v3 = &v2;
  v4 = 1;
  if ( sub_10003F10(38, (int)&v6) || v5 || v4 != 1 )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 622, 0, 0);
    result = 3;
  }
  else
  {
    result = v2;
  }
  return result;
}

//----- (1000BF10) --------------------------------------------------------
char __cdecl sub_1000BF10(_BYTE *a1, char a2, char a3, int a4)
{
  int v4; // eax@1
  char result; // al@3
  char v6; // [sp+4h] [bp-BCh]@1
  char v7; // [sp+5h] [bp-BBh]@7
  char *v8; // [sp+8h] [bp-B8h]@1
  int v9; // [sp+Ch] [bp-B4h]@1
  int v10; // [sp+10h] [bp-B0h]@1
  __int16 *v11; // [sp+14h] [bp-ACh]@1
  int v12; // [sp+18h] [bp-A8h]@1
  int *v13; // [sp+1Ch] [bp-A4h]@1
  int v14; // [sp+20h] [bp-A0h]@1
  int v15; // [sp+24h] [bp-9Ch]@1
  __int16 v16; // [sp+28h] [bp-98h]@1
  char v17; // [sp+2Ch] [bp-94h]@1
  char v18; // [sp+2Dh] [bp-93h]@1
  int v19; // [sp+30h] [bp-90h]@1

  v10 = 0;
  v17 = a2;
  v11 = &v16;
  v18 = a3;
  v19 = a4;
  v16 = -32759;
  v15 = 4;
  v12 = 12;
  v13 = (int *)&v8;
  v14 = 300;
  v8 = &v6;
  v9 = 2;
  v4 = sub_10003F10(38, (int)&v11);
  if ( v4 )
  {
    *a1 = -1;
    if ( v4 == 16 )
    {
      v6 = 2;
      sub_10003C10(".\\mpm\\mpm_intf.c", 788, 0, 0);
      result = v6;
    }
    else
    {
      sub_10003C10(".\\mpm\\mpm_intf.c", 795, 0, 0);
      result = 1;
    }
  }
  else if ( v10 || v9 != 2 )
  {
    sub_10003C10(".\\mpm\\mpm_intf.c", 805, 0, 0);
    result = 3;
    *a1 = -1;
  }
  else
  {
    result = v6;
    *a1 = v7;
  }
  return result;
}

//----- (1000C060) --------------------------------------------------------
signed int sub_1000C060()
{
  return sub_1004C930((int)&off_1005A87C);
}
// 1005A87C: using guessed type char *off_1005A87C;

//----- (1000C070) --------------------------------------------------------
int __cdecl sub_1000C070(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@5
  int v5; // edx@9
  int v6; // edx@13

  result = a3;
  if ( (a1 > *(_DWORD *)a3 || *(_DWORD *)a3 == 0x7FFFFFFF) && a1 != 0x7FFFFFFF )
    *(_DWORD *)a3 = a1;
  v4 = *(_DWORD *)(a3 + 8);
  if ( (a1 < v4 || v4 == 0x7FFFFFFF) && a1 != 0x7FFFFFFF )
    *(_DWORD *)(a3 + 8) = a1;
  v5 = *(_DWORD *)(a3 + 4);
  if ( (a2 > v5 || v5 == 0x7FFFFFFF) && a2 != 0x7FFFFFFF )
    *(_DWORD *)(a3 + 4) = a2;
  v6 = *(_DWORD *)(a3 + 12);
  if ( (a2 < v6 || v6 == 0x7FFFFFFF) && a2 != 0x7FFFFFFF )
    *(_DWORD *)(a3 + 12) = a2;
  return result;
}

//----- (1000C0F0) --------------------------------------------------------
char __cdecl sub_1000C0F0(int a1, char a2, char a3, char a4, int a5)
{
  char result; // al@4
  int v6; // [sp+10h] [bp-74h]@9
  int v7; // [sp+14h] [bp-70h]@9
  int v8; // [sp+18h] [bp-6Ch]@12
  int v9; // [sp+1Ch] [bp-68h]@12
  int v10; // [sp+20h] [bp-64h]@2
  int v11; // [sp+24h] [bp-60h]@4
  float v12; // [sp+28h] [bp-5Ch]@5
  float v13; // [sp+2Ch] [bp-58h]@12
  float v14; // [sp+30h] [bp-54h]@5
  float v15; // [sp+34h] [bp-50h]@12
  double v16; // [sp+38h] [bp-4Ch]@9
  double v17; // [sp+40h] [bp-44h]@9
  char v18; // [sp+48h] [bp-3Ch]@1
  unsigned int v19; // [sp+6Ch] [bp-18h]@2
  double v20; // [sp+70h] [bp-14h]@9

  sub_1000D990(a1, a3, &v18);
  if ( a4 )
    sub_1000D770(v19, (int)&v10);
  else
    sub_1000D790(v19, (int)&v10);
  sub_1000C070(v10, v11, a5);
  result = v18;
  switch ( v18 )
  {
    case 0:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xF:
    case 0x10:
      result = sub_1004D910(a2, a3, (int)&v12, (int)&v14);
      if ( result )
      {
        if ( v18 )
        {
          if ( v18 == 15 )
          {
            sub_1000D990(a1, a3 + 1, &v18);
            sub_1004D910(a2, a3 + 1, (int)&v12, (int)&v14);
          }
          else if ( v18 == 16 )
          {
            sub_1000D510(0, SLOBYTE(v20), &v16);
            sub_10015170((int)&v6, v16, v17);
            sub_1000C070(v6, v7, a5);
          }
        }
        else
        {
          sub_1000D510(0, SLOBYTE(v20), &v16);
          sub_10015170((int)&v6, v16, v17);
          sub_1000C070(v6, v7, a5);
        }
        sub_10015250((int)&v8, v12, v13);
        sub_1000C070(v8, v9, a5);
        sub_10015250((int)&v8, v14, v15);
        result = sub_1000C070(v8, v9, a5);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000C2F0) --------------------------------------------------------
char __cdecl sub_1000C2F0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  char result; // al@4
  int v7; // [sp+0h] [bp-Ch]@2
  __int16 v8; // [sp+4h] [bp-8h]@2
  __int16 v9; // [sp+6h] [bp-6h]@2
  char v10; // [sp+8h] [bp-4h]@2
  char v11; // [sp+9h] [bp-3h]@2
  __int16 v12; // [sp+Ah] [bp-2h]@2

  if ( (unsigned __int8)sub_1000C060() )
  {
    v12 = 4 * ((8 * a4 + 31) / 32);
    v9 = a4;
    v8 = a5;
    v10 = 8;
    v11 = 0;
    v7 = dword_101E28CC + 4;
    if ( *(_BYTE *)dword_101E28CC == a6 )
      sub_10004C70(a1, (int)&v7, 0, 0, a2 + *(_WORD *)(a1 + 42), a3 + *(_WORD *)(a1 + 40), a4, a5);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}
// 101E28CC: using guessed type int dword_101E28CC;

//----- (1000C390) --------------------------------------------------------
char __cdecl sub_1000C390(unsigned __int8 a1, char a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  char result; // al@1
  int v6; // esi@1
  unsigned __int8 v7; // bl@2
  char v8; // al@3
  char v9; // cl@14
  char v10; // al@24
  char v11; // al@28
  char v12; // al@36
  char v13; // cl@37
  char v14; // dl@40
  unsigned __int8 v15; // cl@41
  unsigned __int8 v16; // cl@43
  char v17; // dl@44
  unsigned __int8 v18; // cl@45
  char v19; // al@46
  unsigned __int8 v20; // cl@47
  unsigned __int8 v21; // [sp+1Ch] [bp+14h]@2

  result = sub_1000DC20(a1);
  v6 = a5;
  *(_BYTE *)(a5 + 11) = result;
  *(_BYTE *)(a5 + 12) = 0;
  *(_BYTE *)(a5 + 2) = -1;
  *(_BYTE *)(a5 + 1) = 0;
  *(_BYTE *)(a5 + 4) = -1;
  *(_BYTE *)(a5 + 3) = 0;
  *(_BYTE *)(a5 + 6) = -1;
  *(_BYTE *)(a5 + 5) = 0;
  *(_BYTE *)(a5 + 8) = -1;
  *(_BYTE *)(a5 + 7) = 0;
  *(_BYTE *)(a5 + 10) = -1;
  *(_BYTE *)(a5 + 9) = 0;
  if ( !result )
    return result;
  v7 = 0;
  v21 = 0;
  if ( result )
  {
    while ( 1 )
    {
      v8 = sub_1000D7B0(a1, v21);
      if ( !v8 )
      {
        if ( *(_BYTE *)(v6 + 8) == -1 )
          *(_BYTE *)(v6 + 8) = v7;
        *(_BYTE *)(v6 + 7) = v7;
      }
      if ( v8 & 2 )
      {
        if ( *(_BYTE *)(v6 + 6) == -1 )
          *(_BYTE *)(v6 + 6) = v7;
        *(_BYTE *)(v6 + 5) = v7;
      }
      if ( v8 & 4 )
        break;
LABEL_21:
      if ( !(v8 & 1) )
        goto LABEL_35;
      if ( *(_BYTE *)(v6 + 2) != -1 )
        goto LABEL_34;
      if ( v7 )
      {
        v10 = *(_BYTE *)(v6 + 5);
        if ( v7 != v10 || v7 != a3 )
        {
          v11 = *(_BYTE *)(v6 + 3);
          if ( v7 == v11 && v7 == a3 )
          {
            if ( a2 == 1 )
              goto LABEL_33;
            *(_BYTE *)(v6 + 3) = v11 - 1;
          }
        }
        else
        {
          if ( a2 == 1 )
            goto LABEL_33;
          *(_BYTE *)(v6 + 5) = v10 - 1;
        }
      }
      *(_BYTE *)(v6 + 2) = v7;
LABEL_33:
      if ( *(_BYTE *)(v6 + 2) != -1 )
LABEL_34:
        *(_BYTE *)(v6 + 1) = v7;
LABEL_35:
      v21 = ++v7;
      if ( v7 >= *(_BYTE *)(v6 + 11) )
        goto LABEL_36;
    }
    if ( *(_BYTE *)(v6 + 4) != -1 )
    {
LABEL_20:
      *(_BYTE *)(v6 + 3) = v7;
      goto LABEL_21;
    }
    if ( v7 )
    {
      v9 = *(_BYTE *)(v6 + 5);
      if ( v7 == v9 && v7 == a3 )
      {
        if ( a2 == 1 )
          goto LABEL_19;
        *(_BYTE *)(v6 + 5) = v9 - 1;
      }
    }
    *(_BYTE *)(v6 + 4) = v7;
LABEL_19:
    if ( *(_BYTE *)(v6 + 4) == -1 )
      goto LABEL_21;
    goto LABEL_20;
  }
LABEL_36:
  v12 = sub_1000DD00(a1);
  *(_BYTE *)(v6 + 10) = v12;
  *(_BYTE *)(v6 + 9) = 0;
  if ( v12 != -1 )
  {
    v13 = *(_BYTE *)(v6 + 1);
    *(_BYTE *)(v6 + 1) = v12;
    *(_BYTE *)(v6 + 9) = v13;
    *(_BYTE *)(v6 + 10) = v12 + 1;
  }
  *(_BYTE *)v6 = 0;
  if ( a3 != -1 )
  {
    if ( a3 >= *(_BYTE *)(v6 + 10) )
    {
      v14 = *(_BYTE *)(v6 + 2);
      *(_BYTE *)v6 = *(_BYTE *)(v6 + 9);
LABEL_49:
      *(_BYTE *)(v6 + 12) = v14;
      goto LABEL_50;
    }
    v15 = *(_BYTE *)(v6 + 2);
    if ( a3 < v15 )
    {
      v16 = *(_BYTE *)(v6 + 4);
      if ( a3 < v16 )
      {
        v18 = *(_BYTE *)(v6 + 8);
        if ( a3 < v18 )
        {
          v20 = *(_BYTE *)(v6 + 5);
          if ( a3 <= v20 )
          {
            v14 = *(_BYTE *)(v6 + 6);
            *(_BYTE *)v6 = v20;
            goto LABEL_49;
          }
        }
        else
        {
          v19 = *(_BYTE *)(v6 + 7);
          *(_BYTE *)(v6 + 12) = v18;
          *(_BYTE *)v6 = v19;
        }
      }
      else
      {
        v17 = *(_BYTE *)(v6 + 3);
        *(_BYTE *)(v6 + 12) = v16;
        *(_BYTE *)v6 = v17;
      }
    }
    else
    {
      *(_BYTE *)(v6 + 12) = v15;
      *(_BYTE *)v6 = *(_BYTE *)(v6 + 1);
    }
  }
LABEL_50:
  result = a4;
  if ( *(_BYTE *)(v6 + 12) < (unsigned int)a4 )
    result = *(_BYTE *)(v6 + 12);
  *(_BYTE *)(v6 + 12) = result;
  return result;
}

//----- (1000C550) --------------------------------------------------------
signed int __cdecl sub_1000C550(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // ecx@2
  signed int v4; // esi@2
  int v5; // esi@6
  const void *v6; // edx@6
  int v7; // esi@6
  signed int result; // eax@8
  int v9; // [sp-Ch] [bp-C8h]@5
  char v10; // [sp-8h] [bp-C4h]@5
  const void *v11; // [sp+4h] [bp-B8h]@1
  int v12; // [sp+8h] [bp-B4h]@1
  int v13; // [sp+Ch] [bp-B0h]@1
  __int16 *v14; // [sp+10h] [bp-ACh]@1
  int v15; // [sp+14h] [bp-A8h]@1
  int *v16; // [sp+18h] [bp-A4h]@1
  int v17; // [sp+1Ch] [bp-A0h]@1
  int v18; // [sp+20h] [bp-9Ch]@1
  __int16 v19; // [sp+24h] [bp-98h]@2
  int v20; // [sp+28h] [bp-94h]@6
  char v21; // [sp+2Ch] [bp-90h]@6
  int v22; // [sp+80h] [bp-3Ch]@2
  int v23; // [sp+84h] [bp-38h]@2
  int v24; // [sp+88h] [bp-34h]@2
  int v25; // [sp+8Ch] [bp-30h]@2
  int v26; // [sp+90h] [bp-2Ch]@2
  int v27; // [sp+94h] [bp-28h]@7

  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 == 24 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    v19 = -32752;
    v22 = *(_DWORD *)v3;
    v23 = *(_DWORD *)(v3 + 4);
    v24 = *(_DWORD *)a1;
    v25 = *(_DWORD *)(a1 + 4);
    v26 = *(_DWORD *)(a1 + 8);
    v11 = *(const void **)(a2 + 8);
    v4 = (unsigned __int16)v22;
  }
  else
  {
    if ( v2 != 38 && v2 != 39 )
    {
      v10 = 0;
      v9 = 171;
LABEL_11:
      sub_10003C10(".\\mdb\\mdb_intf_map.c", v9, v10, 0);
      return 1;
    }
    v5 = *(_DWORD *)(a2 + 4);
    v6 = *(const void **)(a2 + 8);
    v19 = -32750;
    v22 = *(_DWORD *)v5;
    v7 = *(_DWORD *)(v5 + 4);
    v20 = v2;
    v23 = v7;
    qmemcpy(&v21, v6, 0x54u);
    v24 = *(_DWORD *)a1;
    v25 = *(_DWORD *)(a1 + 4);
    v26 = *(_DWORD *)(a1 + 8);
    v11 = v6;
    v4 = 84;
  }
  v27 = *(_DWORD *)(a1 + 12);
  v15 = 116;
  v18 = 4;
  v14 = &v19;
  v16 = (int *)&v11;
  v17 = 100;
  v12 = v4;
  if ( sub_10003F10(38, (int)&v14) || (result = v13) != 0 || v12 != v4 )
  {
    v10 = 0;
    v9 = 194;
    goto LABEL_11;
  }
  return result;
}

//----- (1000C6E0) --------------------------------------------------------
int __cdecl sub_1000C6E0(const char *a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@3
  char v5; // [sp+13h] [bp-71h]@1
  int v6; // [sp+14h] [bp-70h]@1
  int v7; // [sp+1Ch] [bp-68h]@1
  int v8; // [sp+20h] [bp-64h]@2

  v5 = 0;
  strcpy((char *)(a3 + 20), a1);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 56) = 0x3FFFF;
  *(_DWORD *)(a3 + 60) = 0x3FFFF;
  *(_DWORD *)(a3 + 16) = v3;
  sub_1004E5F0(a2, (int)&v6);
  sub_1000F930(3, (int)&v6, 370400.0, 0, (int)&v7);
  if ( v7 > 0 )
    *(_DWORD *)(a3 + 56) = v8;
  *(_BYTE *)(a3 + 27) = 0;
  *(_WORD *)a3 = 5;
  *(_BYTE *)(a3 + 64) = 4;
  result = sub_100040C0(3201, (int)&v5, 1);
  if ( v5 == 1 )
    *(_BYTE *)(a3 + 64) |= 1u;
  return result;
}

//----- (1000C7B0) --------------------------------------------------------
signed int __cdecl sub_1000C7B0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
    case 1:
    case 5:
    case 6:
    case 7:
    case 8:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
      result = 1;
      break;
    case 2:
    case 3:
    case 4:
    case 9:
      result = 4;
      break;
    case 0xD:
    case 0x18:
      result = 8;
      break;
    case 0x19:
    case 0x28:
      result = 24;
      break;
    case 0x23:
      result = 16;
      break;
    case 0x22:
      result = 44;
      break;
    default:
      sub_10003C10(".\\mpm\\mpm_utl_intf.c", 263, 1, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000C870) --------------------------------------------------------
signed int __cdecl sub_1000C870(__int16 a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 8:
    case 0xE:
    case 0xF:
    case 0x13:
    case 0x14:
    case 0x17:
    case 0x18:
    case 0x1A:
    case 0x1C:
    case 0x1D:
    case 0x1F:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2F:
    case 0x31:
    case 0x33:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x49:
    case 0x4A:
    case 0x4B:
    case 0x4C:
    case 0x4D:
    case 0x4E:
      result = 1;
      break;
    case 0x25:
    case 0x2D:
      result = 8;
      break;
    case 2:
    case 9:
    case 0x3F:
    case 0x48:
      result = 16;
      break;
    case 3:
    case 0xB:
      result = 12;
      break;
    case 4:
      result = 10;
      break;
    case 6:
    case 0x20:
      result = 6;
      break;
    case 7:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x1E:
    case 0x21:
    case 0x34:
    case 0x45:
      result = 4;
      break;
    case 0x15:
      result = 20;
      break;
    case 0x19:
      result = 48;
      break;
    case 0x1B:
      result = 140;
      break;
    case 0x2E:
      result = 24;
      break;
    case 0x30:
      result = 52;
      break;
    case 0x32:
      result = 3;
      break;
    case 0x16:
    case 0x46:
    case 0x47:
      result = 2;
      break;
    case 0:
    case 1:
    case 5:
    case 0xA:
    case 0xC:
    case 0xD:
    case 0x44:
      result = 0;
      break;
    default:
      sub_10003C10(".\\mpm\\mpm_utl_intf.c", 509, 1, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000C9C0) --------------------------------------------------------
signed int __cdecl sub_1000C9C0(__int16 a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
    case 8:
    case 0x2A:
    case 0x3E:
    case 0x43:
      result = 1;
      break;
    case 2:
    case 9:
      result = 16;
      break;
    case 0xB:
      result = 12;
      break;
    case 6:
    case 0x20:
      result = 6;
      break;
    case 7:
    case 0x21:
      result = 4;
      break;
    case 0x2D:
      result = 8;
      break;
    case 0x46:
    case 0x47:
      result = 2;
      break;
    case 1:
    case 3:
    case 4:
    case 5:
    case 0xA:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2B:
    case 0x2C:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x44:
    case 0x45:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x4B:
    case 0x4C:
    case 0x4D:
    case 0x4E:
      result = 0;
      break;
    default:
      sub_10003C10(".\\mpm\\mpm_utl_intf.c", 668, 1, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000CAB0) --------------------------------------------------------
int __cdecl sub_1000CAB0(char a1)
{
  void *v1; // ecx@0
  int v2; // edi@2
  int v3; // eax@8
  void *v4; // ecx@8
  int v5; // esi@10
  void *v6; // ecx@10

  switch ( a1 )
  {
    case 0:
      v2 = 0x100000;
      break;
    case 2:
      v2 = 1024;
      break;
    case 3:
      v2 = 2048;
      break;
    case 4:
      v2 = 4096;
      break;
    case 5:
      v2 = 0x2000;
      break;
    default:
      v2 = 512;
      break;
  }
  v3 = (unsigned __int8)sub_10010E10(v1) - 2;
  if ( v3 )
  {
    if ( v3 == 6 )
    {
      v5 = 15;
      if ( sub_10003D90(16) )
        return sub_10003EB0(16, v2);
    }
    else
    {
      v5 = 9;
      if ( sub_100154C0(v4) & 3 || sub_10010E30(v6) == 1 )
        return sub_10003EB0(8 * (v2 == 0x100000) + 6, v2);
    }
  }
  else
  {
    v5 = 3;
  }
  return sub_10003EB0(v5, v2);
}

//----- (1000CB90) --------------------------------------------------------
char __cdecl sub_1000CB90(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_101E2460[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 101E2460: using guessed type int dword_101E2460[];

//----- (1000CC00) --------------------------------------------------------
int __usercall sub_1000CC00@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1004D520(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_1010EE10[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_1010EE10[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_1010EE10[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_1010EE10[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1004D520(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (1000CCE0) --------------------------------------------------------
char __cdecl sub_1000CCE0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_1010EE10[(unsigned __int8)sub_10015810(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1004D520(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1004D520(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1004D520(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1004D520(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1004D520(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
      *(_WORD *)(a1 + 430) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
      *(_WORD *)(a1 + 440) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
      *(_WORD *)(a1 + 442) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
      sub_1000CC00(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_1010EE10[1];
      *(_WORD *)(a1 + 430) = word_1010EE10[1];
      *(_WORD *)(a1 + 440) = word_1010EE10[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_1010EE10[1];
      sub_1004D520(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_1010EE10[15];
      *(_WORD *)(a1 + 430) = word_1010EE10[14];
      sub_1004D520(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_1010EE10[13];
      *(_WORD *)(a1 + 430) = word_1010EE10[1];
      sub_1004D520(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_1010EE10[14];
      *(_WORD *)(a1 + 430) = word_1010EE10[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1004D520(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1004D520(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1004D520(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1004D520(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1004D520(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1004D520(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1004D520(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_1010EE10[15];
        *(_WORD *)(a1 + 430) = word_1010EE10[15];
        *(_WORD *)(a1 + 440) = word_1010EE10[1];
        *(_WORD *)(a1 + 442) = word_1010EE10[1];
        sub_1004D520(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
    *(_WORD *)(a1 + 430) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
    *(_WORD *)(a1 + 440) = word_1010EE10[(unsigned __int8)sub_10015810(15)];
    v15 = sub_10015810(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_1010EE10[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_1000CC00(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_1000CC00(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (1000D290) --------------------------------------------------------
bool __cdecl sub_1000D290(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012C0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_10010AB0(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_10010A50(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_10010A80(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101E2460[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_10010AB0(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 101E2460: using guessed type int dword_101E2460[];

//----- (1000D390) --------------------------------------------------------
char __usercall sub_1000D390@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_10005970(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (1000D3E0) --------------------------------------------------------
int sub_1000D3E0()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_1005E02C;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_101E2900 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_10005970(v4, ".", 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_1000D390(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_1000D390(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"EFGHJKLMPQRS" );
  return result;
}
// 1004E7A6: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (1000D480) --------------------------------------------------------
int sub_1000D480()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_1010EE38, 127, 0x100u);
  v0 = 0;
  v1 = &unk_1005E5C5;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_1010EE10[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_1010EE38[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_1005E5FE );
  return result;
}
// 100045E0: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (1000D4E0) --------------------------------------------------------
void sub_1000D4E0()
{
  dword_101E28EC = -15;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000D4F0) --------------------------------------------------------
signed int sub_1000D4F0()
{
  return sub_1004C930((int)&off_1005E630);
}
// 1005E630: using guessed type char *off_1005E630;

//----- (1000D500) --------------------------------------------------------
void sub_1000D500()
{
  dword_1010EF38 = -15;
}
// 1010EF38: using guessed type int dword_1010EF38;

//----- (1000D510) --------------------------------------------------------
double *__cdecl sub_1000D510(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_10014200(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_1000D640(v5) != 11 )
    {
      sub_1000FB50(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_1000F910(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_1000DC60(v6, a2) == v3 )
    {
      sub_1000D990(v6, a2, &v10);
      sub_1000D810((int)&v10, (int)&v7);
      sub_1004E630((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_1000EE30(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (1000D640) --------------------------------------------------------
char __cdecl sub_1000D640(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_1000FD50(a1);
  }
  return result;
}

//----- (1000D670) --------------------------------------------------------
char __usercall sub_1000D670@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3)
{
  char result; // al@2
  __int64 v4; // [sp-4h] [bp-68h]@5
  int v5; // [sp+4h] [bp-60h]@6
  float v6; // [sp+8h] [bp-5Ch]@11
  float v7; // [sp+Ch] [bp-58h]@11
  char v8; // [sp+10h] [bp-54h]@8
  double v9; // [sp+18h] [bp-4Ch]@4
  double v10; // [sp+20h] [bp-44h]@4
  char v11; // [sp+28h] [bp-3Ch]@11

  if ( a2 < 0x3E8 )
    return sub_1000EEA0(a2, a1);
  if ( a2 == 262141 )
  {
    sub_10014200(0, (int)&v9);
    return sub_10015170(a1, v9, v10);
  }
  if ( sub_1000D640(v4) == 11 )
  {
    sub_1000F910(a2, &v5, (_BYTE *)&v4 + 4);
    result = v5;
    if ( (_BYTE)v5 )
    {
      if ( (_BYTE)v5 == -1 )
      {
LABEL_12:
        *(_DWORD *)a1 = 2147483648;
        *(_DWORD *)(a1 + 4) = 2147483648;
        return result;
      }
    }
    else if ( a3 != (_BYTE)v5 )
    {
      return sub_1004D810(BYTE4(v4), (int)&v8, a1);
    }
    if ( BYTE4(v4) != -1 )
    {
      sub_1000D990(v5, SBYTE4(v4), &v11);
      sub_1000D810((int)&v11, (int)&v6);
      return sub_10015250(a1, v6, v7);
    }
    goto LABEL_12;
  }
  return sub_1000FA70(a2, a1);
}

//----- (1000D770) --------------------------------------------------------
char __cdecl sub_1000D770(unsigned int a1, int a2)
{
  return sub_1000D670(a2, a1, 1);
}

//----- (1000D790) --------------------------------------------------------
char __cdecl sub_1000D790(unsigned int a1, int a2)
{
  return sub_1000D670(a2, a1, 0);
}

//----- (1000D7B0) --------------------------------------------------------
int __cdecl sub_1000D7B0(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  char v3; // bl@2
  int result; // eax@2

  sub_10003E80(54, 60000);
  v2 = sub_1000FA00(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(84 * a2 + v2 + 125);
    sub_10003E60(54);
    result = v3 & 0xC7;
  }
  else
  {
    sub_10003E60(54);
    result = 0;
  }
  return result;
}

//----- (1000D810) --------------------------------------------------------
int __cdecl sub_1000D810(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000D880) --------------------------------------------------------
char __cdecl sub_1000D880(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  int v3; // esi@1
  unsigned __int8 v4; // bl@2
  int v5; // edi@3
  signed int v6; // eax@3
  char result; // al@6
  char *v8; // edi@7
  unsigned int v9; // ecx@7

  sub_10003E80(54, 60000);
  v2 = sub_1000FA00(a1);
  v3 = v2;
  if ( v2 )
  {
    v4 = 0;
    *a2 = *(_BYTE *)(v2 + 1);
    if ( *(_BYTE *)(v2 + 1) )
    {
      do
      {
        v5 = v4;
        v6 = sub_10015340(84 * v4++ + v3 + 148);
        *(_DWORD *)&a2[4 * v5 + 4] = v6;
      }
      while ( v4 < *(_BYTE *)(v3 + 1) );
    }
  }
  else
  {
    *a2 = 0;
  }
  sub_10003E60(54);
  result = *a2;
  if ( (unsigned __int8)*a2 < 0x64u )
  {
    v8 = &a2[4 * (unsigned __int8)result + 4];
    v9 = (unsigned __int8)(100 - result);
    result = -1;
    memset32(v8, 0x3FFFF, v9);
  }
  return result;
}

//----- (1000D910) --------------------------------------------------------
signed int __cdecl sub_1000D910(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1
  char v3; // cl@2

  v1 = 0x3FFFF;
  sub_10003E80(54, 60000);
  v2 = sub_1000FA00(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(v2 + 1);
    if ( v3 )
    {
      if ( *(_BYTE *)(v2 + 90) == -1 || (v1 = *(_DWORD *)(v2 + 104), v1 == 0x3FFFF) )
      {
        if ( *(_BYTE *)(v2 + 60) == 3 || *(_BYTE *)(v2 + 61) == 3 || (v1 = *(_DWORD *)(v2 + 64), v1 == 0x3FFFF) )
          v1 = sub_10015340(84 * (unsigned __int8)(v3 - 1) + v2 + 148);
      }
    }
  }
  sub_10003E60(54);
  return v1;
}

//----- (1000D990) --------------------------------------------------------
int __cdecl sub_1000D990(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_10003E80(54, 60000);
  v3 = sub_1000FA00(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_10003E60(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_10003E60(54);
  }
  return result;
}

//----- (1000DA10) --------------------------------------------------------
char __cdecl sub_1000DA10(int a1, char a2)
{
  char v2; // cl@1
  char result; // al@1

  v2 = a2;
  result = -1;
  if ( a2 )
  {
    while ( !(*(_BYTE *)(84 * (unsigned __int8)v2 + a1 + 125) & 0x10) )
    {
      if ( !--v2 )
        return result;
    }
    result = v2;
  }
  return result;
}

//----- (1000DA40) --------------------------------------------------------
char __cdecl sub_1000DA40(int a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // bl@2
  int v3; // eax@3
  int v4; // edx@3
  int v5; // edx@4
  unsigned int v6; // ecx@5
  _DWORD *v7; // edx@5
  int *v8; // esi@5
  int v9; // eax@9
  int v10; // edi@9
  int v11; // ecx@10
  _BYTE *v12; // edx@10
  _BYTE *v13; // esi@10
  int v14; // eax@11
  int v15; // ecx@12
  _BYTE *v16; // edx@12
  _BYTE *v17; // esi@12
  int v18; // eax@13
  _BYTE *v19; // edx@14
  _BYTE *v20; // esi@14
  signed int v21; // ecx@16
  char result; // al@21
  char v23; // [sp+7h] [bp-Dh]@1
  int v24; // [sp+8h] [bp-Ch]@3
  char v25; // [sp+Ch] [bp-8h]@3

  v23 = 0;
  if ( a1 )
  {
    v2 = a2;
    if ( a2 >= *(_BYTE *)(a1 + 1) )
    {
      result = 0;
    }
    else
    {
      v3 = 84 * a2;
      v4 = *(_DWORD *)(v3 + a1 + 131);
      LOBYTE(v3) = *(_BYTE *)(v3 + a1 + 135);
      v24 = v4;
      v25 = v3;
      do
      {
        v5 = 84 * v2 + a1;
        if ( *(_DWORD *)(v5 + 136) == 0x3FFFF )
          break;
        v6 = 5;
        v7 = (_DWORD *)(v5 + 131);
        v8 = &v24;
        do
        {
          if ( *v8 != *v7 )
            goto LABEL_9;
          v6 -= 4;
          ++v7;
          ++v8;
        }
        while ( v6 >= 4 );
        if ( !v6 )
        {
LABEL_18:
          v21 = 0;
          goto LABEL_19;
        }
LABEL_9:
        v9 = *(_BYTE *)v7;
        v10 = *(_BYTE *)v8 - v9;
        if ( *(_BYTE *)v8 == v9 )
        {
          v11 = v6 - 1;
          v12 = (char *)v7 + 1;
          v13 = (char *)v8 + 1;
          if ( !v11 )
            goto LABEL_18;
          v14 = *v12;
          v10 = *v13 - v14;
          if ( *v13 == v14 )
          {
            v15 = v11 - 1;
            v16 = v12 + 1;
            v17 = v13 + 1;
            if ( !v15 )
              goto LABEL_18;
            v18 = *v16;
            v10 = *v17 - v18;
            if ( *v17 == v18 )
            {
              v19 = v16 + 1;
              v20 = v17 + 1;
              if ( v15 == 1 )
                goto LABEL_18;
              v10 = *v20 - *v19;
              if ( *v20 == *v19 )
                goto LABEL_18;
            }
          }
        }
        v21 = 1;
        if ( v10 <= 0 )
          v21 = -1;
LABEL_19:
        if ( v21 )
          break;
        ++v23;
        ++v2;
      }
      while ( v2 < *(_BYTE *)(a1 + 1) );
      result = v23;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000DB90) --------------------------------------------------------
char __cdecl sub_1000DB90(unsigned __int8 a1, char a2)
{
  char v2; // bl@1
  int v3; // eax@1

  v2 = -1;
  sub_10003E80(54, 60000);
  v3 = sub_1000FA00(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_1000DA10(v3, a2);
  sub_10003E60(54);
  return v2;
}

//----- (1000DBE0) --------------------------------------------------------
char __cdecl sub_1000DBE0(unsigned __int8 a1, unsigned __int8 a2)
{
  char v2; // bl@1
  int v3; // eax@1

  v2 = 0;
  sub_10003E80(54, 60000);
  v3 = sub_1000FA00(a1);
  if ( v3 )
    v2 = sub_1000DA40(v3, a2);
  sub_10003E60(54);
  return v2;
}

//----- (1000DC20) --------------------------------------------------------
char __cdecl sub_1000DC20(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10003E80(54, 60000);
  v1 = 0;
  v2 = sub_1000FA00(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_10003E60(54);
  return v1;
}

//----- (1000DC60) --------------------------------------------------------
signed int __cdecl sub_1000DC60(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_10003E80(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_1000FA00(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_10015340(84 * a2 + v3 + 148);
  sub_10003E60(54);
  return v2;
}

//----- (1000DCC0) --------------------------------------------------------
char __cdecl sub_1000DCC0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (1000DD00) --------------------------------------------------------
char __cdecl sub_1000DD00(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10003E80(54, 60000);
  v1 = -1;
  v2 = sub_1000FA00(a1);
  if ( v2 )
    v1 = sub_1000DCC0(v2);
  sub_10003E60(54);
  return v1;
}

//----- (1000DD40) --------------------------------------------------------
int __cdecl sub_1000DD40(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_101E3122;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 101E3122: using guessed type __int16 word_101E3122;

//----- (1000DD80) --------------------------------------------------------
signed int __usercall sub_1000DD80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax@4

  if ( !a3 )
    return 1000;
  if ( a1 != 1000 )
  {
    v4 = 5 * a1;
    goto LABEL_7;
  }
  if ( a2 != 1000 )
  {
    v4 = 5 * a2 - 90;
LABEL_7:
    if ( abs(2 * v4 - a3) > 90 )
      a3 += 180;
  }
  return a3;
}

//----- (1000DDC0) --------------------------------------------------------
signed int __thiscall sub_1000DDC0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1000DD40(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E28E0)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101E3122;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3122;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3122;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3122: using guessed type __int16 word_101E3122;

//----- (1000DE70) --------------------------------------------------------
signed int __usercall sub_1000DE70@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_1000DD40(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E28E0)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_101E3122;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3122: using guessed type __int16 word_101E3122;

//----- (1000DF00) --------------------------------------------------------
signed int __thiscall sub_1000DF00(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1000DD40(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E28E0)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101E3122;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3122;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3122: using guessed type __int16 word_101E3122;

//----- (1000DFA0) --------------------------------------------------------
int __usercall sub_1000DFA0@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_1000DD40(a1);
  return result;
}

//----- (1000DFC0) --------------------------------------------------------
char __usercall sub_1000DFC0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_1005F1A8[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_1005F1A0[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_101E28E0)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_101E3126;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_1005F1A0[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3126: using guessed type __int16 word_101E3126;

//----- (1000E080) --------------------------------------------------------
void *__usercall sub_1000E080@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_101E2A84;
    *(_DWORD *)a2 = v2 + dword_101E2A84;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_101E28E0)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_101E2A88;
  }
  else
  {
    result = memcpy_0(a2, &unk_1005F1B0, 6u);
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2A84: using guessed type int dword_101E2A84;
// 101E2A88: using guessed type __int16 word_101E2A88;

//----- (1000E0E0) --------------------------------------------------------
int __usercall sub_1000E0E0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>)
{
  int v2; // edi@1
  int *v3; // edx@1
  int v4; // esi@4
  int result; // eax@4
  char v6; // cl@4
  char v7; // [sp+Ch] [bp-34h]@3
  char v8; // [sp+30h] [bp-10h]@2
  int v9; // [sp+3Ch] [bp-4h]@1

  v2 = a1;
  *a2 = 0;
  v3 = &v9;
  do
  {
    if ( v3 > (int *)&v8 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v2, 48, &v7);
      v3 = (int *)&v7;
    }
    ++*a2;
    v2 += (unsigned __int16)word_101E3124;
    v4 = (unsigned __int16)word_101E3124;
    result = *(_WORD *)((char *)v3 + 5);
    v6 = *((_BYTE *)v3 + 2) >> 7;
    if ( result & 4 )
    {
      v2 += (unsigned __int16)word_101E3126;
      v4 = (unsigned __int16)word_101E3126 + (unsigned __int16)word_101E3124;
    }
    if ( result & 8 )
    {
      v2 += (unsigned __int16)word_101E3128;
      v4 += (unsigned __int16)word_101E3128;
    }
    if ( result & 0x10 )
    {
      result = (unsigned __int16)word_101E312A;
      v2 += (unsigned __int16)word_101E312A;
      v4 += (unsigned __int16)word_101E312A;
    }
    v3 = (int *)((char *)v3 + v4);
  }
  while ( v6 );
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3124: using guessed type __int16 word_101E3124;
// 101E3126: using guessed type __int16 word_101E3126;
// 101E3128: using guessed type __int16 word_101E3128;
// 101E312A: using guessed type __int16 word_101E312A;

//----- (1000E180) --------------------------------------------------------
__int16 __usercall sub_1000E180@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_1000FA70(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E28E0)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E28E0)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_101E3124 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_101E3126;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3124: using guessed type __int16 word_101E3124;
// 101E3126: using guessed type __int16 word_101E3126;

//----- (1000E2F0) --------------------------------------------------------
void *__cdecl sub_1000E2F0(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_1000FD50(v4) )
  {
    v2 = sub_1000FD20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v2, 28, &v5);
  }
  return sub_1000E080((int)&v5, a2);
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (1000E340) --------------------------------------------------------
signed int __cdecl sub_1000E340(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_1000DDC0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E28E0)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E312C;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_101E312E;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E312C: using guessed type __int16 word_101E312C;
// 101E312E: using guessed type __int16 word_101E312E;

//----- (1000E3C0) --------------------------------------------------------
signed int __usercall sub_1000E3C0@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_1000DE70(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E28E0)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E3144;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3144: using guessed type __int16 word_101E3144;

//----- (1000E430) --------------------------------------------------------
signed int __cdecl sub_1000E430(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_1000DF00(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E28E0)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E3146;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3146: using guessed type __int16 word_101E3146;

//----- (1000E4A0) --------------------------------------------------------
int __usercall sub_1000E4A0@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_1000DFA0(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_101E3124;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_101E3126;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_101E3128;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_101E312A;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3124: using guessed type __int16 word_101E3124;
// 101E3126: using guessed type __int16 word_101E3126;
// 101E3128: using guessed type __int16 word_101E3128;
// 101E312A: using guessed type __int16 word_101E312A;

//----- (1000E530) --------------------------------------------------------
void __usercall sub_1000E530(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_1000E180(a3, (int)&v3, a2);
  *(double *)a1 = sub_10015360(v3, 24);
  *(double *)(a1 + 8) = sub_10015360(v4, 24);
}

//----- (1000E570) --------------------------------------------------------
__int16 __cdecl sub_1000E570(unsigned int a1, char a2, int a3)
{
  int v3; // ebp@1
  __int16 v4; // bx@1
  unsigned int v5; // eax@1
  double v6; // st7@1
  unsigned int v7; // esi@1
  signed int v8; // eax@3
  unsigned __int16 v9; // dx@3
  int v10; // edx@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // ecx@3
  int v14; // edi@3
  int v15; // ecx@3
  double v16; // st7@3
  unsigned __int16 v17; // cx@3
  __int16 v18; // ax@3
  __int16 v19; // dx@3
  __int16 v20; // ax@3
  unsigned int v21; // edx@6
  __int16 v22; // cx@7
  double v23; // st5@8
  char v24; // al@12
  char v25; // cl@12
  unsigned int v26; // ecx@25
  unsigned int v27; // ecx@25
  unsigned __int16 v28; // dx@25
  float v30; // [sp+Ch] [bp-3Ch]@3
  char v31; // [sp+10h] [bp-38h]@1
  int v32; // [sp+18h] [bp-30h]@3
  int v33; // [sp+1Ch] [bp-2Ch]@3
  unsigned int v34; // [sp+20h] [bp-28h]@25
  unsigned int v35; // [sp+24h] [bp-24h]@25
  unsigned __int16 v36; // [sp+28h] [bp-20h]@2
  char v37; // [sp+2Ah] [bp-1Eh]@3
  unsigned __int16 v38; // [sp+2Bh] [bp-1Dh]@3
  unsigned __int16 v39; // [sp+2Dh] [bp-1Bh]@2
  __int16 v40; // [sp+34h] [bp-14h]@3
  __int16 v41; // [sp+36h] [bp-12h]@3
  __int16 v42; // [sp+38h] [bp-10h]@3
  __int16 v43; // [sp+3Ah] [bp-Eh]@3
  unsigned __int16 v44; // [sp+3Ch] [bp-Ch]@3
  unsigned __int8 v45; // [sp+3Eh] [bp-Ah]@3
  __int16 v46; // [sp+3Fh] [bp-9h]@7
  unsigned int v47; // [sp+41h] [bp-7h]@6
  unsigned __int16 v48; // [sp+45h] [bp-3h]@24

  v3 = a3;
  v4 = 0;
  *(_BYTE *)(a3 + 2) = 0;
  sub_1000E2F0(a1, &v31);
  v5 = sub_1000E4A0((int)&v31, a2);
  v6 = 9.9999996e24;
  v7 = v5;
  if ( v5 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(unsigned int, signed int, unsigned __int16 *))dword_101E28E0)(v5, 12, &v36);
    LOWORD(v5) = word_101E3124;
    a3 = (unsigned __int16)word_101E3124 + v7;
    if ( v39 & 8 )
    {
      *(_BYTE *)(v3 + 2) = 1;
      sub_1000DFC0(v3 + 7, (unsigned int *)(v3 + 16), (_BYTE *)(v3 + 8), (int)&v36, &a3, (int *)(v3 + 12));
      v8 = sub_1000DD80(*(_DWORD *)(v3 + 12), *(_DWORD *)(v3 + 16), (unsigned int)v38 >> 8);
      v9 = v39;
      *(_DWORD *)(v3 + 20) = v8;
      LOBYTE(v8) = v37 & 0xF;
      *(_WORD *)(v3 + 10) = v9 >> 5;
      v10 = a3;
      *(_BYTE *)(v3 + 9) = v8;
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(v10, 19, &v40);
      sub_1000FA70(a1, (int)&v32);
      v11 = v32 >> 7;
      v12 = v40;
      v13 = v33 >> 7;
      *(_DWORD *)(v3 + 24) = ((v32 >> 7) - v41) << 7;
      v14 = v13 - v12;
      v32 = v11;
      *(_DWORD *)(v3 + 32) = (v11 - v43) << 7;
      v33 = v13;
      v15 = (v13 - v42) << 7;
      *(_DWORD *)(v3 + 28) = v14 << 7;
      *(_DWORD *)(v3 + 36) = v15;
      v16 = sub_1000FDF0(a1);
      v17 = v44;
      v30 = v16;
      a3 = (signed __int16)((signed __int16)(16 * v44) >> 4);
      v18 = 16 * v45;
      v19 = ((signed __int16)(16 * v44) >> 4) & 0xF00F;
      *(float *)(v3 + 40) = (double)a3 * 0.3048000037670135 + v30;
      v20 = (v17 >> 12) | (v19 | v18) & 0xFFF0;
      LOWORD(a3) = v20;
      if ( v20 & 0x800 )
        LOWORD(v5) = v5 | 0xF000;
      else
        LOWORD(v5) = v5 & 0xFFF;
      a3 = (signed __int16)v5;
      v21 = v47;
      *(_BYTE *)(v3 + 3) = 0;
      *(_BYTE *)(v3 + 4) = 0;
      *(_BYTE *)(v3 + 5) = 0;
      *(_BYTE *)(v3 + 6) = 0;
      *(float *)(v3 + 56) = v30 + 0.3048000037670135 * (double)(signed __int16)v5;
      v6 = 9.9999996e24;
      *(float *)(v3 + 44) = 9.9999996e24;
      *(float *)(v3 + 60) = 9.9999996e24;
      *(float *)(v3 + 52) = 9.9999996e24;
      *(float *)(v3 + 68) = 9.9999996e24;
      *(float *)(v3 + 76) = 9.9999996e24;
      *(float *)(v3 + 72) = 9.9999996e24;
      if ( (unsigned __int16)word_101E3128 >= 0xBu )
      {
        v22 = v46;
        LOWORD(v5) = v46 & 0x3FFF;
        if ( (v46 & 0x3FFF) != 0x3FFF )
        {
          a3 = (unsigned __int16)v5;
          LOWORD(v5) = (unsigned __int8)v21;
          *(float *)&a3 = (double)a3 / 10.0 - 350.0;
          v23 = *(float *)&a3;
          a3 = (unsigned __int8)v21;
          *(float *)(v3 + 44) = v23;
          *(float *)&a3 = (double)a3 / 10.0;
          if ( v22 & 0x8000 )
            *(float *)&a3 = -*(float *)&a3;
          *(float *)(v3 + 60) = v23 + *(float *)&a3;
        }
      }
      if ( (unsigned __int16)word_101E3128 < 0x13u )
      {
        *(float *)(v3 + 48) = 9.9999996e24;
        *(_BYTE *)v3 = 0;
        *(float *)(v3 + 64) = 9.9999996e24;
        *(_BYTE *)(v3 + 1) = 0;
        goto LABEL_33;
      }
      v24 = (v21 >> 18) & 1;
      v25 = (v21 >> 20) & 1;
      *(_BYTE *)v3 = v24;
      *(_BYTE *)(v3 + 1) = v25;
      if ( v24 )
      {
        a3 = (v21 >> 8) & 0x3FF;
        *(float *)(v3 + 48) = (double)(unsigned int)a3 / 100.0;
      }
      else
      {
        *(float *)(v3 + 48) = 9.9999996e24;
      }
      if ( v25 )
      {
        a3 = v21 >> 22;
        *(float *)(v3 + 64) = (double)(v21 >> 22) / 100.0;
      }
      else
      {
        *(float *)(v3 + 64) = 9.9999996e24;
      }
      if ( v24 && !(v21 & 0x80000) )
        *(float *)(v3 + 48) = *(float *)(v3 + 48) * -1.0;
      if ( v25 && !(v21 & 0x200000) )
        *(float *)(v3 + 64) = -1.0 * *(float *)(v3 + 64);
      LOWORD(v5) = v48;
      if ( v48 == -1 )
        goto LABEL_33;
      (*(void (__cdecl **)(int, signed int, unsigned int *))dword_101E28E0)(
        dword_101E2E44 + (unsigned __int16)word_101E2E48 * v48,
        8,
        &v34);
      v5 = v34;
      v26 = v34 >> 31;
      *(_BYTE *)(v3 + 3) = (v34 >> 15) & 1;
      *(_BYTE *)(v3 + 4) = v26 & 1;
      v27 = v35;
      *(_BYTE *)(v3 + 5) = (v35 >> 15) & 1;
      *(_BYTE *)(v3 + 6) = (v27 >> 31) & 1;
      v28 = v36;
      if ( v5 & 0x4000 )
      {
        a3 = v36 - (v5 & 0x3FFF);
        *(float *)(v3 + 52) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v5 & 0x40000000 )
      {
        v5 = (v5 >> 16) & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 68) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x4000 )
      {
        v5 = v27 & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 76) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x40000000 )
      {
        a3 = v28 - ((v27 >> 16) & 0x3FFF);
        *(float *)(v3 + 72) = 0.3048 * (double)(unsigned int)a3;
        v6 = 9.9999996e24;
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
      v4 = 0;
    }
    v6 = 9.9999996e24;
  }
LABEL_34:
  if ( *(_BYTE *)(v3 + 2) == (_BYTE)v4 )
  {
    *(_BYTE *)v3 = v4;
    *(_BYTE *)(v3 + 1) = v4;
    *(_DWORD *)(v3 + 12) = 1000;
    *(_DWORD *)(v3 + 16) = 1000;
    *(_DWORD *)(v3 + 20) = 1000;
    *(_WORD *)(v3 + 10) = v4;
    *(_BYTE *)(v3 + 7) = 95;
    *(_BYTE *)(v3 + 8) = 95;
    LOBYTE(v5) = byte_101E324C;
    *(float *)(v3 + 40) = v6;
    *(float *)(v3 + 44) = v6;
    *(_BYTE *)(v3 + 9) = v5;
    *(float *)(v3 + 56) = v6;
    LOWORD(v5) = -1;
    *(float *)(v3 + 60) = v6;
    *(float *)(v3 + 48) = v6;
    *(_BYTE *)(v3 + 3) = v4;
    *(float *)(v3 + 64) = v6;
    *(_BYTE *)(v3 + 4) = v4;
    *(float *)(v3 + 52) = v6;
    *(_BYTE *)(v3 + 5) = v4;
    *(float *)(v3 + 68) = v6;
    *(_BYTE *)(v3 + 6) = v4;
    *(float *)(v3 + 76) = v6;
    *(_DWORD *)(v3 + 24) = 0x7FFFFFFF;
    *(float *)(v3 + 72) = v6;
    *(_DWORD *)(v3 + 28) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 32) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  }
  return v5;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2E44: using guessed type int dword_101E2E44;
// 101E2E48: using guessed type __int16 word_101E2E48;
// 101E3124: using guessed type __int16 word_101E3124;
// 101E3128: using guessed type __int16 word_101E3128;
// 101E324C: using guessed type char byte_101E324C;

//----- (1000EA50) --------------------------------------------------------
char __cdecl sub_1000EA50(unsigned int a1)
{
  __int64 v1; // ST00_8@1
  int v2; // esi@1
  char result; // al@3
  char v4; // [sp+Fh] [bp-9h]@1
  char v5; // [sp+10h] [bp-8h]@1

  v4 = 0;
  sub_1000E2F0(a1, &v5);
  LODWORD(v1) = a1;
  v2 = sub_1000DFA0((int)&v5);
  if ( sub_1000FD50(v1) )
  {
    result = 0;
  }
  else if ( v2 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_1000E0E0(v2, &v4);
    result = v4;
  }
  return result;
}

//----- (1000EAC0) --------------------------------------------------------
int __cdecl sub_1000EAC0(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_1000E2F0(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_1000E4A0((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_1000E3C0((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_1000E430(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_1000E340(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (1000EB70) --------------------------------------------------------
char __cdecl sub_1000EB70(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_1000EAC0(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_1000FD20(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_1000E530(a2, a1, v3);
  }
  return v2;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (1000EBE0) --------------------------------------------------------
__int16 __cdecl sub_1000EBE0(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_1000EAC0(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_1000E180(v2, a2, a1);
  return v2;
}

//----- (1000EC20) --------------------------------------------------------
signed int __cdecl sub_1000EC20(int a1, _WORD *a2, _BYTE *a3)
{
  signed int result; // eax@1
  int v4; // ecx@2
  int v5; // edi@3
  int i; // ebx@3
  int v7; // esi@4

  result = sub_1000D4F0();
  if ( (_BYTE)result && (v4 = dword_101E28EC, result = *(_WORD *)(dword_101E28EC + 2), (signed __int16)result > 0) )
  {
    v5 = (signed __int16)result - 1;
    for ( i = 0; v5 > i; v4 = dword_101E28EC )
    {
      v7 = (v5 + i) / 2;
      if ( sub_1000F6E0((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v7 + 4) + 15721) + 4), 5) <= 0 )
        v5 = (v5 + i) / 2;
      else
        i = v7 + 1;
    }
    result = sub_1000F6E0((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v5 + 4) + 15721) + 4), 5);
    if ( result <= 0 )
    {
      if ( result >= 0 )
      {
        result = (signed int)a3;
        *a2 = v5;
        *a3 = 1;
      }
      else
      {
        result = (signed int)a2;
        *a2 = v5;
        *a3 = 0;
      }
    }
    else
    {
      *a2 = v5 + 1;
      *a3 = 0;
    }
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000ED20) --------------------------------------------------------
char __usercall sub_1000ED20@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_1000D4F0() && v2 < 0x3E8u && *(_WORD *)(dword_101E28EC + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_101E28EC + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000ED80) --------------------------------------------------------
int __usercall sub_1000ED80@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (1000EDA0) --------------------------------------------------------
int __cdecl sub_1000EDA0(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+8h] [bp-38h]@3

  sub_10003E80(58, 60000);
  if ( sub_1000ED20(a1, &v3) )
  {
    sub_1000F870(&v4, 6, a2);
    sub_10011E40(a2, 6);
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return sub_10003E60(58);
}

//----- (1000EE30) --------------------------------------------------------
int __cdecl sub_1000EE30(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_10003E80(58, 60000);
  if ( sub_1000ED20(a1, &v3) )
  {
    sub_1000ED80(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_10003E60(58);
}

//----- (1000EEA0) --------------------------------------------------------
int __cdecl sub_1000EEA0(unsigned __int16 a1, int a2)
{
  int v2; // edx@3
  char v4; // [sp+4h] [bp-3Ch]@1
  int v5; // [sp+Ch] [bp-34h]@3
  int v6; // [sp+10h] [bp-30h]@3

  sub_10003E80(58, 60000);
  if ( sub_1000ED20(a1, &v4) )
  {
    v2 = v6;
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return sub_10003E60(58);
}

//----- (1000EF10) --------------------------------------------------------
signed int __cdecl sub_1000EF10(int a1, _WORD *a2, _BYTE *a3)
{
  char v4; // [sp+8h] [bp-Ch]@1

  sub_1000F710(a1, (int)&v4);
  return sub_1000EC20((int)&v4, a2, a3);
}

//----- (1000EF60) --------------------------------------------------------
signed int __cdecl sub_1000EF60(int a1)
{
  signed int v1; // esi@1
  char v3; // [sp+7h] [bp-5h]@1
  __int16 v4; // [sp+8h] [bp-4h]@1

  v1 = 0x3FFFF;
  sub_10003E80(58, 60000);
  sub_1000EF10(a1, &v4, &v3);
  if ( v3 )
    v1 = *(_WORD *)(dword_101E28EC + 2 * v4 + 4);
  sub_10003E60(58);
  return v1;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000EFC0) --------------------------------------------------------
signed int __cdecl sub_1000EFC0(const char *a1)
{
  signed int v1; // edi@1
  unsigned int v2; // eax@5
  char *v3; // ecx@5
  const char *v4; // edx@5
  int v5; // esi@9
  int v6; // eax@10
  _BYTE *v7; // ecx@10
  _BYTE *v8; // edx@10
  int v9; // eax@12
  _BYTE *v10; // ecx@12
  _BYTE *v11; // edx@12
  _BYTE *v12; // ecx@14
  _BYTE *v13; // edx@14
  signed int v14; // eax@16
  bool v15; // zf@19
  signed int result; // eax@19
  __int16 v17; // [sp+Ch] [bp-14h]@1
  char v18; // [sp+13h] [bp-Dh]@1
  char v19; // [sp+14h] [bp-Ch]@5

  v1 = 0x3FFFF;
  sub_10003E80(58, 60000);
  sub_1000EF10((int)a1, &v17, &v18);
  if ( (unsigned __int8)sub_1000D4F0() && v17 < *(_WORD *)(dword_101E28EC + 2) )
    v1 = *(_WORD *)(dword_101E28EC + 2 * v17 + 4);
  sub_10003E60(58);
  if ( v1 != 0x3FFFF )
  {
    sub_1000EDA0(v1, (int)&v19);
    v2 = strlen(a1);
    v3 = &v19;
    v4 = a1;
    if ( v2 < 4 )
    {
LABEL_8:
      if ( !v2 )
        goto LABEL_18;
    }
    else
    {
      while ( *(_DWORD *)v4 == *(_DWORD *)v3 )
      {
        v2 -= 4;
        v3 += 4;
        v4 += 4;
        if ( v2 < 4 )
          goto LABEL_8;
      }
    }
    v5 = *v4 - (unsigned __int8)*v3;
    if ( *v4 != (unsigned __int8)*v3
      || (v6 = v2 - 1, v7 = v3 + 1, v8 = v4 + 1, v6)
      && ((v5 = *v8 - *v7, *v8 != *v7)
       || (v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, v9)
       && ((v5 = *v11 - *v10, *v11 != *v10)
        || (v12 = v10 + 1, v13 = v11 + 1, v9 != 1) && (v5 = *v13 - *v12, *v13 != *v12))) )
    {
      v14 = 1;
      if ( v5 <= 0 )
        v14 = -1;
LABEL_19:
      v15 = v14 == 0;
      result = v1;
      if ( v15 )
        return result;
      return 0x3FFFF;
    }
LABEL_18:
    v14 = 0;
    goto LABEL_19;
  }
  return 0x3FFFF;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000F100) --------------------------------------------------------
char __cdecl sub_1000F100(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_1010EE10[1];
  v19 = word_1010EE10[0];
  v20 = word_1010EE10[0];
  v21 = word_1010EE10[0];
  v22 = word_1010EE10[0];
  v6 = word_1010EE10[(unsigned __int8)sub_10015810(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_10051F18;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1004D520(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (1000F330) --------------------------------------------------------
char __cdecl sub_1000F330(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_1010EE10[(unsigned __int8)sub_10015810(v7)];
    v9 = word_1010EE10[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_1010EE10[(unsigned __int8)sub_10015810(v5 & 0x1F)];
    v9 = word_1010EE10[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_1000F100(a1, (int)&v13, a3, (int)&v11, a5);
}
// 1010EE10: using guessed type __int16 word_1010EE10[];

//----- (1000F410) --------------------------------------------------------
char __cdecl sub_1000F410(int a1, int a2)
{
  int v2; // edi@3
  char result; // al@3
  int v4; // eax@4
  signed int v5; // edx@4
  int v6; // eax@16
  int v7; // ecx@16
  int v8; // edx@16

  if ( a1 && a2 )
  {
    *(_WORD *)a1 = 0;
    *(_WORD *)a2 = 0;
    *(_DWORD *)(a1 + 4) = 0x3FFFF;
    *(_DWORD *)(a1 + 8) = 0x3FFFF;
    *(_DWORD *)(a1 + 12) = 0x3FFFF;
    *(_DWORD *)(a1 + 16) = 0x3FFFF;
    *(_DWORD *)(a1 + 20) = 0x3FFFF;
    *(_DWORD *)(a1 + 24) = 0x3FFFF;
    *(_DWORD *)(a1 + 28) = 0x3FFFF;
    *(_DWORD *)(a1 + 32) = 0x3FFFF;
    *(_DWORD *)(a1 + 36) = 0x3FFFF;
    *(_DWORD *)(a1 + 40) = 0x3FFFF;
    *(_DWORD *)(a1 + 44) = 0x3FFFF;
    *(_DWORD *)(a1 + 48) = 0x3FFFF;
    v2 = a1 + 4;
    *(_DWORD *)(v2 + 48) = 0x3FFFF;
    *(_DWORD *)(v2 + 52) = 0x3FFFF;
    *(_DWORD *)(v2 + 56) = 0x3FFFF;
    *(_DWORD *)(v2 + 60) = 0x3FFFF;
    *(_DWORD *)(v2 + 64) = 0x3FFFF;
    *(_DWORD *)(v2 + 68) = 0x3FFFF;
    *(_DWORD *)(v2 + 72) = 0x3FFFF;
    *(_DWORD *)(v2 + 76) = 0x3FFFF;
    *(_DWORD *)(v2 + 80) = 0x3FFFF;
    *(_DWORD *)(v2 + 84) = 0x3FFFF;
    *(_DWORD *)(v2 + 88) = 0x3FFFF;
    *(_DWORD *)(v2 + 92) = 0x3FFFF;
    *(_DWORD *)(v2 + 96) = 0x3FFFF;
    *(_DWORD *)(a2 + 2) = -1;
    *(_DWORD *)(a2 + 6) = -1;
    result = sub_10015EE0();
    if ( result )
    {
      sub_10003E80(100, 60000);
      qmemcpy((void *)v2, (const void *)(dword_101E29F0 + 1428), 0x64u);
      v4 = a1 + 8;
      v5 = 5;
      do
      {
        if ( *(_DWORD *)(v4 - 4) != 0x3FFFF )
          ++*(_WORD *)a1;
        if ( *(_DWORD *)v4 != 0x3FFFF )
          ++*(_WORD *)a1;
        if ( *(_DWORD *)(v4 + 4) != 0x3FFFF )
          ++*(_WORD *)a1;
        if ( *(_DWORD *)(v4 + 8) != 0x3FFFF )
          ++*(_WORD *)a1;
        if ( *(_DWORD *)(v4 + 12) != 0x3FFFF )
          ++*(_WORD *)a1;
        v4 += 20;
        --v5;
      }
      while ( v5 );
      v6 = dword_101E29F0;
      v7 = *(_DWORD *)(dword_101E29F0 + 1538);
      *(_DWORD *)(a2 + 2) = v7;
      v8 = *(_DWORD *)(v6 + 1542);
      *(_DWORD *)(a2 + 6) = v8;
      if ( (_WORD)v7 != -1 )
        ++*(_WORD *)a2;
      if ( *(_WORD *)(a2 + 4) != -1 )
        ++*(_WORD *)a2;
      if ( (_WORD)v8 != -1 )
        ++*(_WORD *)a2;
      if ( *(_WORD *)(a2 + 8) != -1 )
        ++*(_WORD *)a2;
      result = sub_10003E60(100);
    }
  }
  else
  {
    result = sub_10003C10("..\\lib\\acl\\prx\\prx_intf.c", 382, 0, 0);
  }
  return result;
}
// 101E29F0: using guessed type int dword_101E29F0;

//----- (1000F580) --------------------------------------------------------
signed int __cdecl sub_1000F580(const void *a1, _DWORD *a2, _BYTE *a3)
{
  signed int result; // eax@2
  _DWORD *v4; // [sp+10h] [bp-A4h]@1
  int v5; // [sp+14h] [bp-A0h]@1
  int v6; // [sp+18h] [bp-9Ch]@1
  __int16 *v7; // [sp+1Ch] [bp-98h]@1
  int v8; // [sp+20h] [bp-94h]@1
  int *v9; // [sp+24h] [bp-90h]@1
  int v10; // [sp+28h] [bp-8Ch]@1
  int v11; // [sp+2Ch] [bp-88h]@1
  __int16 v12; // [sp+30h] [bp-84h]@1
  char v13; // [sp+34h] [bp-80h]@1

  *a2 = 0x3FFFF;
  v12 = -32758;
  qmemcpy(&v13, a1, 0x44u);
  v6 = 0;
  v11 = 4;
  v7 = &v12;
  v8 = 128;
  v9 = (int *)&v4;
  v10 = 400;
  v4 = a2;
  v5 = 4;
  if ( sub_10003F10(21, (int)&v7) )
  {
    sub_10003C10("..\\lib\\adl\\udb_intf_wpt.c", 156, 0, 0);
    result = v6;
  }
  else
  {
    result = v6;
    if ( !v6 && v5 == 4 )
      goto LABEL_7;
  }
  *a2 = 0x3FFFF;
  if ( !result )
    result = 29;
LABEL_7:
  *a3 = result;
  return result;
}

//----- (1000F680) --------------------------------------------------------
char sub_1000F680()
{
  char v1; // [sp+3h] [bp-Dh]@1
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = sub_10003DB0();
  v1 = 1;
  sub_10004190(9890, (int)&v1, 1);
  LOWORD(v2) = -32765;
  sub_10015960((int)&v2);
  return 1;
}

//----- (1000F6E0) --------------------------------------------------------
int __cdecl sub_1000F6E0(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // edx@1
  _BYTE *v4; // ecx@1
  int v5; // esi@1
  int result; // eax@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = 0;
  do
  {
    if ( v5 <= 0 )
      break;
    result = *v4-- - *v3--;
    --v5;
  }
  while ( !result );
  return result;
}

//----- (1000F710) --------------------------------------------------------
int __cdecl sub_1000F710(int a1, int a2)
{
  unsigned int v2; // edx@1
  int v3; // ebx@1
  int v4; // ecx@1
  signed int v5; // esi@1
  unsigned int v6; // eax@2
  unsigned int v7; // eax@12
  unsigned int v8; // eax@15
  int v9; // ecx@15
  unsigned int v10; // eax@25
  unsigned int v11; // eax@28
  int v12; // ecx@28
  unsigned int v13; // eax@38
  int result; // eax@47

  v2 = 0;
  v3 = 0;
  v4 = 34;
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_BYTE *)(v5 + a1);
    if ( v6 - 65 > 0x19 )
    {
      if ( v6 - 48 > 9 )
      {
        if ( v6 == 32 )
        {
          v6 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1) )
        {
          goto LABEL_45;
        }
      }
      else
      {
        v6 -= 16;
      }
    }
    else
    {
      v6 -= 64;
    }
    if ( v4 == 34 )
    {
      v3 |= 4 * v6;
    }
    else
    {
      if ( v4 == 28 )
      {
        v3 |= v6 >> 4;
        v7 = v6 << 28;
      }
      else
      {
        v7 = v6 << v4;
      }
      v2 |= v7;
    }
    v8 = *(_BYTE *)(v5 + a1 + 1);
    v9 = v4 - 6;
    if ( v8 - 65 > 0x19 )
    {
      if ( v8 - 48 > 9 )
      {
        if ( v8 == 32 )
        {
          v8 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1 + 1) )
        {
          ++v5;
          goto LABEL_45;
        }
      }
      else
      {
        v8 -= 16;
      }
    }
    else
    {
      v8 -= 64;
    }
    if ( v9 == 34 )
    {
      v3 |= 4 * v8;
    }
    else
    {
      if ( v9 == 28 )
      {
        v3 |= v8 >> 4;
        v10 = v8 << 28;
      }
      else
      {
        v10 = v8 << v9;
      }
      v2 |= v10;
    }
    v11 = *(_BYTE *)(v5 + a1 + 2);
    v12 = v9 - 6;
    if ( v11 - 65 > 0x19 )
      break;
    v11 -= 64;
LABEL_35:
    if ( v12 == 34 )
    {
      v3 |= 4 * v11;
    }
    else
    {
      if ( v12 == 28 )
      {
        v3 |= v11 >> 4;
        v13 = v11 << 28;
      }
      else
      {
        v13 = v11 << v12;
      }
      v2 |= v13;
    }
    v5 += 3;
    v4 = v12 - 6;
    if ( v5 >= 6 )
      goto LABEL_45;
  }
  if ( v11 - 48 <= 9 )
  {
    v11 -= 16;
    goto LABEL_35;
  }
  if ( v11 == 32 )
  {
    v11 = 0;
    goto LABEL_35;
  }
  if ( *(_BYTE *)(v5 + a1 + 2) )
    goto LABEL_35;
  v5 += 2;
LABEL_45:
  if ( *(_BYTE *)(v5 + a1) )
  {
    v2 = -136348176;
    LOBYTE(v3) = 125;
  }
  result = a2;
  *(_BYTE *)(a2 + 1) = BYTE1(v2);
  *(_BYTE *)a2 = v2;
  *(_BYTE *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 2) = v2 >> 16;
  *(_BYTE *)(a2 + 3) = BYTE3(v2);
  return result;
}

//----- (1000F870) --------------------------------------------------------
void __cdecl sub_1000F870(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (1000F910) --------------------------------------------------------
unsigned int __cdecl sub_1000F910(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (1000F930) --------------------------------------------------------
int __cdecl sub_1000F930(char a1, int a2, float a3, char a4, int a5)
{
  int v5; // edx@1
  int v6; // eax@1
  int result; // eax@1
  int v8; // [sp+0h] [bp-48h]@1
  int v9; // [sp+4h] [bp-44h]@1
  int v10; // [sp+8h] [bp-40h]@1
  __int16 *v11; // [sp+Ch] [bp-3Ch]@1
  int v12; // [sp+10h] [bp-38h]@1
  int *v13; // [sp+14h] [bp-34h]@1
  int v14; // [sp+18h] [bp-30h]@1
  int v15; // [sp+1Ch] [bp-2Ch]@1
  __int16 v16; // [sp+20h] [bp-28h]@1
  char v17; // [sp+24h] [bp-24h]@1
  int v18; // [sp+28h] [bp-20h]@1
  int v19; // [sp+2Ch] [bp-1Ch]@1
  float v20; // [sp+30h] [bp-18h]@1
  char v21; // [sp+34h] [bp-14h]@1

  v5 = *(_DWORD *)a2;
  v20 = a3;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v17 = a1;
  v6 = *(_DWORD *)(a2 + 4);
  v21 = a4;
  v18 = v5;
  v19 = v6;
  v16 = -32765;
  v15 = 4;
  v11 = &v16;
  v12 = 36;
  v13 = &v8;
  v14 = 400;
  v8 = a5;
  v9 = 104;
  result = sub_10003F10(43, (int)&v11);
  if ( result || v10 || v9 != 104 )
    *(_DWORD *)a5 = 0;
  return result;
}

//----- (1000FA00) --------------------------------------------------------
int __cdecl sub_1000FA00(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_1000D4F0()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_101E28EC + 2004), result = v1 + dword_101E28EC + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 101E28EC: using guessed type int dword_101E28EC;

//----- (1000FA40) --------------------------------------------------------
int __fastcall sub_1000FA40(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (1000FA70) --------------------------------------------------------
char __cdecl sub_1000FA70(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101E3250 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_10010510(a1, a2);
      else
        result = sub_1000EBE0(a1, a2);
    }
    else
    {
      v3 = sub_1000FC70(a1);
      v4 = sub_1000FCA0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v4, 7, &v5);
      result = sub_1000FA40((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3250: using guessed type int dword_101E3250;

//----- (1000FB20) --------------------------------------------------------
void __usercall sub_1000FB20(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_1000FA40(a1, (int)&v2);
  *(double *)a2 = sub_10015360(v2, 24);
  *(double *)(a2 + 8) = sub_10015360(v3, 24);
}

//----- (1000FB50) --------------------------------------------------------
char __cdecl sub_1000FB50(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101E3250 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_10010510(a1, (int)&v7);
        if ( v6 )
        {
          sub_10015150(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_1000EB70(a1, a2);
      }
    }
    else
    {
      v3 = sub_1000FC70(a1);
      v4 = sub_1000FCA0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_101E28E0)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_1000FB20((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3250: using guessed type int dword_101E3250;

//----- (1000FC70) --------------------------------------------------------
unsigned __int8 __cdecl sub_1000FC70(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_101E3250 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 101E3250: using guessed type int dword_101E3250;

//----- (1000FCA0) --------------------------------------------------------
int __cdecl sub_1000FCA0(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_101E3250 + 4 * a2 + 20812);
    v4 = byte_10060370[12 * a2];
    if ( sub_100153A0(v3, (unsigned __int8)byte_10060370[12 * a2]) )
      result = dword_101E2A00[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_101E2A04[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 101E2A00: using guessed type int dword_101E2A00[];
// 101E2A04: using guessed type __int16 word_101E2A04[];
// 101E3250: using guessed type int dword_101E3250;

//----- (1000FD20) --------------------------------------------------------
int __cdecl sub_1000FD20(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_1000FC70(a1);
  return sub_1000FCA0(a1, v1, 1);
}

//----- (1000FD50) --------------------------------------------------------
char __cdecl sub_1000FD50(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_1000FC70(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_100153E0(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (1000FDF0) --------------------------------------------------------
double __cdecl sub_1000FDF0(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  float v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@2
  int v6; // [sp+12h] [bp-12h]@2

  v4 = 9.9999996e24;
  LODWORD(v3) = a1;
  if ( !sub_1000FD50(v3) )
  {
    v1 = sub_1000FD20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v1, 28, &v5);
    v4 = (double)((v6 & 0x7FFF) - 5000) * 0.3048000037670135;
  }
  return v4;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (1000FE60) --------------------------------------------------------
int sub_1000FE60()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_100153A0(0x4Du, 1u) )
  {
    result = dword_101E2D9C;
    dword_1010EF48 = dword_101E2D9C;
    if ( dword_101E2D9C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101E28E0)(dword_101E2D9C, 8, &v1);
      word_1010EF40 = v1;
      result = v3 & 0x1FF;
      dword_1010EF48 += (unsigned __int16)word_101E2DA0;
      word_1010EF44 = v2 & 0x1FF;
      word_1010EF3C = v3 & 0x1FF;
    }
  }
  else
  {
    word_1010EF40 = 6;
    word_1010EF44 = 6;
    result = dword_101E2C1C;
    word_1010EF3C = 60;
    dword_1010EF48 = dword_101E2C1C;
  }
  return result;
}
// 1010EF3C: using guessed type __int16 word_1010EF3C;
// 1010EF40: using guessed type __int16 word_1010EF40;
// 1010EF44: using guessed type __int16 word_1010EF44;
// 1010EF48: using guessed type int dword_1010EF48;
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2C1C: using guessed type int dword_101E2C1C;
// 101E2D9C: using guessed type int dword_101E2D9C;
// 101E2DA0: using guessed type __int16 word_101E2DA0;

//----- (1000FF00) --------------------------------------------------------
char __cdecl sub_1000FF00(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10015FF0(v1, 0);
  if ( dword_1010EF48 && v4 && sub_100153A0(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_1010EF40;
    v12 = v9 / word_1010EF44;
    v13 = (signed __int16)(v7 / word_1010EF40);
    v14 = v7 / word_1010EF40 + 1;
    v23 = v24 / (double)word_1010EF40 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_1010EF44 - (double)v12;
    v16 = (v12 + 1) % word_1010EF3C;
    (*(void (__cdecl **)(int, signed int, int *))dword_101E28E0)(
      dword_1010EF48 + (unsigned __int16)word_101E2C20 * (v12 + v11 * word_1010EF3C),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(
      dword_1010EF48 + (unsigned __int16)word_101E2C20 * (v16 + v13 * word_1010EF3C),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_101E28E0)(
      dword_1010EF48 + (unsigned __int16)word_101E2C20 * (v15 + v14 * word_1010EF3C),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_101E28E0)(
      dword_1010EF48 + (unsigned __int16)word_101E2C20 * (v16 + v14 * word_1010EF3C),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 1010EF3C: using guessed type __int16 word_1010EF3C;
// 1010EF40: using guessed type __int16 word_1010EF40;
// 1010EF44: using guessed type __int16 word_1010EF44;
// 1010EF48: using guessed type int dword_1010EF48;
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2C20: using guessed type __int16 word_101E2C20;

//----- (100101C0) --------------------------------------------------------
char __cdecl sub_100101C0(int a1, float *a2)
{
  return sub_1000FF00(a2);
}

//----- (100101E0) --------------------------------------------------------
char *__cdecl sub_100101E0(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_101E2A00[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_101E2A08];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_101E2A04];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_101E2A08];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_101E28E0)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2A00: using guessed type int dword_101E2A00[];
// 101E2A04: using guessed type __int16 word_101E2A04[];
// 101E2A08: using guessed type int dword_101E2A08[];
// 100101E0: using guessed type char var_20[28];

//----- (100102A0) --------------------------------------------------------
signed int sub_100102A0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_101E28E4 = 0;
  dword_101E28E8 = 0xFFFFFF;
  byte_101E28D4 = 0;
  dword_101E28D8 = 0xFFFFFF;
  return result;
}
// 101E28D4: using guessed type char byte_101E28D4;
// 101E28D8: using guessed type int dword_101E28D8;
// 101E28E4: using guessed type char byte_101E28E4;
// 101E28E8: using guessed type int dword_101E28E8;

//----- (100102C0) --------------------------------------------------------
int sub_100102C0()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_101E28E0 + 16))();
  byte_101E28DC = (_BYTE)result == 0;
  return result;
}
// 101E28DC: using guessed type char byte_101E28DC;
// 101E28E0: using guessed type int dword_101E28E0;

//----- (10010320) --------------------------------------------------------
int sub_10010320()
{
  int result; // eax@1

  *(_DWORD *)(dword_101E3250 + 20812) = 1000;
  *(_DWORD *)(dword_101E3250 + 20816) = dword_101E2A68 + *(_DWORD *)(dword_101E3250 + 20812);
  *(_DWORD *)(dword_101E3250 + 20820) = dword_101E2AC8 + *(_DWORD *)(dword_101E3250 + 20816);
  *(_DWORD *)(dword_101E3250 + 20824) = dword_101E2AF8 + *(_DWORD *)(dword_101E3250 + 20820);
  result = dword_101E3250;
  *(_DWORD *)(dword_101E3250 + 20828) = dword_101E2B40 + *(_DWORD *)(dword_101E3250 + 20824);
  return result;
}
// 101E2A68: using guessed type int dword_101E2A68;
// 101E2AC8: using guessed type int dword_101E2AC8;
// 101E2AF8: using guessed type int dword_101E2AF8;
// 101E2B40: using guessed type int dword_101E2B40;
// 101E3250: using guessed type int dword_101E3250;

//----- (10010390) --------------------------------------------------------
char *sub_10010390()
{
  sub_100101E0(0x40u);
  sub_100101E0(0x39u);
  sub_100101E0(0x33u);
  sub_100101E0(0x31u);
  sub_100101E0(0x32u);
  sub_100101E0(0x4Eu);
  sub_100101E0(0x4Fu);
  sub_100101E0(0x3Du);
  sub_100101E0(0x3Eu);
  sub_100101E0(0x45u);
  return sub_100101E0(0x38u);
}
// 101E3250: using guessed type int dword_101E3250;

//----- (10010460) --------------------------------------------------------
int __cdecl sub_10010460(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_1010EFD8, a1, 0x1Cu);
  dword_101E28E0 = (int)dword_1010EFD8;
  dword_101E3250 = (int)&unk_1010EFF8;
  memset(&unk_1010EFF8, 0, 0x516Cu);
  dword_1010EFD8[5](dword_101E3250 + 20832, dword_101E3250 + 20833, dword_101E3250 + 20836);
  (*(void (__cdecl **)(int))(dword_101E28E0 + 24))(dword_101E3250 + 20840);
  sub_10015DB0();
  sub_10015A40();
  sub_10015BF0();
  sub_10015B10();
  sub_10010390();
  sub_100102A0();
  sub_100108A0();
  sub_1000FE60();
  sub_100102C0();
  sub_10010320();
  *(_DWORD *)(dword_101E3250 + 20800) = 0;
  *(_DWORD *)(dword_101E3250 + 20804) = dword_101E2BE8;
  result = dword_101E3250;
  *(_DWORD *)(dword_101E3250 + 20808) = dword_101E2BF4 + *(_DWORD *)(dword_101E3250 + 20804);
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2BE8: using guessed type int dword_101E2BE8;
// 101E2BF4: using guessed type int dword_101E2BF4;
// 101E3250: using guessed type int dword_101E3250;

//----- (10010510) --------------------------------------------------------
char __cdecl sub_10010510(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (10010590) --------------------------------------------------------
int __cdecl sub_10010590(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_100153E0(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (100105C0) --------------------------------------------------------
int sub_100105C0()
{
  return (*(int (**)(void))(dword_101E28E0 + 8))();
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (100105D0) --------------------------------------------------------
int __fastcall sub_100105D0(unsigned __int8 a1)
{
  return dword_101E2C04 + a1 * (unsigned __int16)word_101E2C08;
}
// 101E2C04: using guessed type int dword_101E2C04;
// 101E2C08: using guessed type __int16 word_101E2C08;

//----- (100105F0) --------------------------------------------------------
int __fastcall sub_100105F0(unsigned __int8 a1)
{
  return dword_101E2C10 + a1 * (unsigned __int16)word_101E2C14;
}
// 101E2C10: using guessed type int dword_101E2C10;
// 101E2C14: using guessed type __int16 word_101E2C14;

//----- (10010610) --------------------------------------------------------
void *__cdecl sub_10010610(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_10010590(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_100105D0(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_101E28E0)(v3, 22, &v7);
      result = (void *)sub_10015B70(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (100106E0) --------------------------------------------------------
int __cdecl sub_100106E0(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_100105D0(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(v2, 22, &v22);
    sub_10015B70((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_100105F0(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_101E28E0)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10015B70((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_101E28E0 + 12))(a1);
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (100108A0) --------------------------------------------------------
char sub_100108A0()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_100105C0();
  sub_10010590(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10010610(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_100153E0(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10010610(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_100106E0((int)&v8);
  }
  return v0;
}

//----- (10010A00) --------------------------------------------------------
_DWORD *__cdecl sub_10010A00(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10010A10) --------------------------------------------------------
int __cdecl sub_10010A10(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (10010A40) --------------------------------------------------------
_DWORD *__cdecl sub_10010A40(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (10010A50) --------------------------------------------------------
char __cdecl sub_10010A50(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (10010A80) --------------------------------------------------------
char __cdecl sub_10010A80(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (10010AB0) --------------------------------------------------------
bool __cdecl sub_10010AB0(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[(unsigned __int8)byte_101E2464[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (10010B00) --------------------------------------------------------
int __cdecl sub_10010B00(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_10010AB0(a3, &v8, 0);
  sub_100012C0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_101E2460[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 101E2460: using guessed type int dword_101E2460[];

//----- (10010B70) --------------------------------------------------------
char __cdecl sub_10010B70(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10003C10("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_10010A80(a1, v7, (int)v3);
    sub_10010AB0(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012C0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_101E2460[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 101E2460: using guessed type int dword_101E2460[];

//----- (10010C20) --------------------------------------------------------
int __cdecl sub_10010C20(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_100117D0(&a1, 4u, (int)&unk_10064980, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10003C10(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_10064984 + 2 * v2);
}
// 10064984: using guessed type void *off_10064984;

//----- (10010CA0) --------------------------------------------------------
char __thiscall sub_10010CA0(void *this)
{
  char result; // al@2
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE3(v2) = 0;
  if ( (unsigned __int8)sub_10011250(this) > 1u )
  {
    sub_10004120(41069, (char *)&v2 + 2, 1, (char *)&v2 + 3);
    result = BYTE2(v2);
  }
  else
  {
    sub_10004120(41068, (char *)&v2 + 2, 1, (char *)&v2 + 3);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10010CF0) --------------------------------------------------------
int sub_10010CF0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10004250(3012, &v2, 4, &v1);
  return v2;
}

//----- (10010D20) --------------------------------------------------------
char __cdecl sub_10010D20(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 10039628: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10010D40) --------------------------------------------------------
int __cdecl sub_10010D40(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10003C10("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10003C10("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1003962E: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10010DA0) --------------------------------------------------------
char __thiscall sub_10010DA0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10010D40(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10010DC0) --------------------------------------------------------
char __thiscall sub_10010DC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10010D40(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10010DE0) --------------------------------------------------------
int __thiscall sub_10010DE0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10010D40(29, (char *)&v2);
  return (int)v2;
}

//----- (10010E00) --------------------------------------------------------
int __cdecl sub_10010E00(char *a1)
{
  return sub_10010D40(30, a1);
}

//----- (10010E10) --------------------------------------------------------
char __thiscall sub_10010E10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10010D40(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10010E30) --------------------------------------------------------
char __thiscall sub_10010E30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10010D40(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10010E50) --------------------------------------------------------
char sub_10010E50()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10010D40(48, &v1);
  return v1;
}

//----- (10010E70) --------------------------------------------------------
int __cdecl sub_10010E70(char a1)
{
  return sub_10010D40(56, &a1);
}

//----- (10010E80) --------------------------------------------------------
void __cdecl sub_10010E80(unsigned __int8 a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  unsigned int v6; // esi@2
  char v7[2]; // [sp+4h] [bp-30h]@2
  __int16 v8; // [sp+6h] [bp-2Eh]@2
  __int16 v9; // [sp+8h] [bp-2Ch]@2
  __int16 v10; // [sp+Ah] [bp-2Ah]@2
  __int16 v11[2]; // [sp+Ch] [bp-28h]@2
  int v12[9]; // [sp+10h] [bp-24h]@2

  if ( a1 < 3u )
  {
    memset(v7, 0, 0x30u);
    sub_10010E00(v7);
    v6 = 16 * a1;
    v7[v6] = a2;
    *(__int16 *)((char *)&v8 + v6) = a3;
    *(__int16 *)((char *)&v9 + v6) = a4;
    *(__int16 *)((char *)&v10 + v6) = a5;
    v11[v6 / 2] = a6;
    v12[v6 / 4] = sub_10003D40();
    sub_10010D40(74, v7);
  }
}
// 10010E80: using guessed type char var_30[2];
// 10010E80: using guessed type __int16 var_28[2];
// 10010E80: using guessed type int var_24[9];

//----- (10010F00) --------------------------------------------------------
char __cdecl sub_10010F00(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10010F40) --------------------------------------------------------
char __cdecl sub_10010F40(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10003C10("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10010FB0) --------------------------------------------------------
signed int __cdecl sub_10010FB0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10003C10("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10011030) --------------------------------------------------------
char __cdecl sub_10011030(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10003C10("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100110A0) --------------------------------------------------------
char __cdecl sub_100110A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10003C10("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10011150) --------------------------------------------------------
char __cdecl sub_10011150(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10003C10("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10011250) --------------------------------------------------------
char __thiscall sub_10011250(void *this)
{
  int v1; // eax@1

  v1 = sub_100154C0(this);
  return sub_10011150(v1);
}

//----- (10011260) --------------------------------------------------------
int __cdecl sub_10011260(int *a1)
{
  int result; // eax@1

  result = sub_100197A0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10003DB0();
    result = sub_100195E0();
  }
  return result;
}

//----- (10011290) --------------------------------------------------------
char __usercall sub_10011290@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10003E80(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1001A860("%i %i\r\n", 13, v2);
    sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10003E60(*(_DWORD *)(a1 + 4));
    v6 = sub_1001A860("%i %i\r\n", 14, v5);
    sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_10065B54, (int)v6);
    result = 1;
  }
  else
  {
    sub_10003C10(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10011330) --------------------------------------------------------
int __cdecl sub_10011330(const char *a1)
{
  int result; // eax@1

  result = sub_10017900();
  if ( a1 )
    result = sub_100197D0(dword_101196D0[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 101196D0: using guessed type int dword_101196D0[];

//----- (10011370) --------------------------------------------------------
char __cdecl sub_10011370(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_10019720((char *)a1 + 4);
  v1 = sub_10020180();
  sub_100196C0((int)v1, 0, 0);
  dword_101196D0[sub_10017900()] = (int)a1;
  v2 = sub_10020140((int)sub_10011330);
  return sub_100197F0(v2);
}
// 101196D0: using guessed type int dword_101196D0[];

//----- (100113C0) --------------------------------------------------------
signed int __cdecl sub_100113C0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10003DB0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10003F60(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10003DB0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10003FF0(&v23);
          }
          while ( sub_10003DB0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10003D90(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10003DD0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1001A860("The %s task is loaded.", &v24);
            sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1001A860("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1001A860("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1001A860(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10003D20(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1001A860("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1001A860("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10019E00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10019E00(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10003E10(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10020140((int)sub_10011330);
        sub_10019ED0((int)v15);
        v16 = sub_10021520((int)sub_10011330);
        sub_10019ED0((int)v16);
        v17 = sub_10021520((int)sub_10011330);
        sub_100197F0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10020140((int)sub_10011330);
        sub_10019ED0((int)v18);
        v19 = sub_10021520((int)sub_10011330);
        sub_10019ED0((int)v19);
        v20 = sub_10020140((int)sub_10011330);
        sub_100197F0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10011290(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10011760) --------------------------------------------------------
char **sub_10011760()
{
  return off_10065B40;
}
// 10065B40: using guessed type char *off_10065B40[3];

//----- (10011780) --------------------------------------------------------
int __cdecl sub_10011780(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101196E4 = a1;
  return result;
}
// 101196E4: using guessed type int dword_101196E4;

//----- (10011790) --------------------------------------------------------
int __cdecl sub_10011790(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101196E8 = a1;
  return result;
}
// 101196E8: using guessed type int dword_101196E8;

//----- (100117A0) --------------------------------------------------------
#error "100117A5: call analysis failed (funcsize=28)"

//----- (100117D0) --------------------------------------------------------
int __cdecl sub_100117D0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10011960) --------------------------------------------------------
void __cdecl sub_10011960(_BYTE *a1, unsigned int a2, char a3)
{
  _BYTE *v3; // edi@1
  int v4; // ebp@2
  char *v5; // esi@2
  char v6; // al@3
  unsigned int v7; // esi@4
  unsigned int v8; // ebx@5
  unsigned int i; // ebx@7
  int j; // ebp@9
  int k; // ebp@15
  int v12; // ebp@22
  unsigned int l; // ebp@29
  char v14; // cl@31
  int m; // ebp@37
  int v16; // [sp+8h] [bp+4h]@2

  v3 = a1;
  if ( a1 )
  {
    v4 = 0;
    v5 = a1;
    v16 = 0;
    do
      v6 = *v5++;
    while ( v6 );
    v7 = v5 - (v3 + 1);
    if ( a3 )
    {
      v8 = 0;
      if ( v7 )
      {
        do
        {
          v3[v8] = toupper(v3[v8]);
          ++v8;
        }
        while ( v8 < v7 );
      }
    }
    for ( i = a2; v7 > i; ++v16 )
    {
      switch ( v4 )
      {
        case 4:
          for ( j = v7 - 2; v7 > i; --j )
          {
            if ( j <= 0 )
              break;
            if ( ((unsigned __int8)byte_10067268[2 * v3[j]] >> 3) & 1 )
              memcpy_0(&v3[j], &v3[j + 1], v7-- - j);
          }
          break;
        case 3:
          for ( k = v7 - 2; v7 > i; --k )
          {
            if ( k < 0 )
              break;
            if ( ((unsigned __int8)byte_10067268[2 * v3[k]] >> 3) & 1
              && ((unsigned __int8)byte_10067268[2 * v3[k + 1]] >> 3) & 1 )
            {
              memcpy_0(&v3[k + 1], &v3[k + 2], v7-- - k - 1);
            }
          }
          break;
        case 1:
        case 5:
          v12 = v7 - 2;
          if ( v7 > i )
          {
            do
            {
              if ( v12 < 0 )
                break;
              if ( isalpha(v3[v12]) && v3[v12] == v3[v12 + 1] )
                memcpy_0(&v3[v12], &v3[v12 + 1], v7-- - v12);
              i = a2;
              --v12;
            }
            while ( v7 > a2 );
          }
          break;
        case 2:
          for ( l = 0; v7 > i; ++l )
          {
            if ( l >= v7 )
              break;
            v14 = v3[l];
            if ( v14 == 32 || v14 == 45 )
            {
              memcpy_0(&v3[l], &v3[l + 1], v7-- - l);
              --l;
            }
          }
          break;
        case 0:
          if ( a3 )
          {
            for ( m = v7 - 1; m >= 0; --m )
            {
              if ( !(byte_10067268[2 * v3[m]] & 0x51) )
                memcpy_0(&v3[m], &v3[m + 1], v7-- - m);
            }
          }
          break;
        default:
          v3[i] = 0;
          v7 = i;
          break;
      }
      v4 = v16 + 1;
    }
  }
}

//----- (10011BA0) --------------------------------------------------------
void __cdecl sub_10011BA0(int a1, _DWORD *a2, int a3, int a4)
{
  unsigned int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // ecx@3
  char v7[12]; // [sp+8h] [bp-10h]@3

  if ( a1 && a2 )
  {
    v4 = a3 - 1;
    v5 = sprintf(v7, " %d", a4);
    v6 = 0;
    if ( v5 + *a2 > a3 - 1 )
    {
      if ( v5 <= v4 )
      {
        *a2 = v4 - v5;
      }
      else
      {
        v6 = v5 - v4;
        *a2 = 0;
      }
    }
    memcpy((void *)(a1 + *a2), &v7[v6], v5 - v6 + 1);
  }
}
// 10011BA0: using guessed type char var_10[12];

//----- (10011C30) --------------------------------------------------------
int __cdecl sub_10011C30(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10011C80) --------------------------------------------------------
int __cdecl sub_10011C80(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10011CB0) --------------------------------------------------------
void __cdecl sub_10011CB0(const char *a1, int a2, int (__cdecl *a3)(int, int), int a4)
{
  int v4; // esi@1
  int v5; // ebx@2
  int (__cdecl *v6)(int, int); // ebp@2
  const char *v7; // ST10_4@2
  int v8; // edi@2

  v4 = (int)a1;
  if ( a1 )
  {
    v5 = a4;
    v6 = a3;
    v7 = a1;
    a1 = (const char *)strlen(a1);
    v8 = 0;
    if ( (unsigned __int8)a3(v7, a4) )
    {
      do
      {
        if ( ++v8 >= (*(int (**)(void))(dword_101E29D0 + 4))() )
          break;
        sub_10011BA0(v4, &a1, a2, v8);
      }
      while ( (unsigned __int8)v6(v4, v5) );
    }
  }
}
// 101E29D0: using guessed type int dword_101E29D0;

//----- (10011D30) --------------------------------------------------------
int __cdecl sub_10011D30(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10011D90) --------------------------------------------------------
int __cdecl sub_10011D90(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10011DD0) --------------------------------------------------------
int sub_10011DD0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10011D90(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (10011E00) --------------------------------------------------------
int __cdecl sub_10011E00(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10011C30((int)&a1[v3], a2, a3 - v3);
}

//----- (10011E40) --------------------------------------------------------
int __cdecl sub_10011E40(int a1, int a2)
{
  return sub_10011D30(a1, "_ ", a2);
}

//----- (10011E60) --------------------------------------------------------
char __cdecl sub_10011E60(unsigned __int8 a1)
{
  char result; // al@3
  int v2; // [sp+4h] [bp-4h]@2

  if ( a1 < 0x34u && (unsigned __int8)sub_10014430(&v2) )
    result = *(_BYTE *)(a1 + v2 + 14618950);
  else
    result = -1;
  return result;
}

//----- (10011EA0) --------------------------------------------------------
int __cdecl sub_10011EA0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10011EE0) --------------------------------------------------------
void *__usercall sub_10011EE0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_100040C0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10004210(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10011F30) --------------------------------------------------------
signed int sub_10011F30()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_101E325C = 0;
  v4 = 0;
  sub_10004580(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10004190(3201, (int)&v4, 1);
    sub_100045B0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10004190(3201, (int)&v4, 1);
    sub_100045B0(94, (int)&v4);
  }
  sub_10011EE0(1u, 6011, &unk_101196F0);
  sub_10011EE0(0x16u, 6194, &unk_101196F1);
  sub_10011EE0(1u, 6012, &unk_10119707);
  sub_10011EE0(1u, 6013, &unk_10119708);
  sub_10011EE0(1u, 6014, &unk_10119709);
  sub_10011EE0(1u, 6015, &unk_1011970A);
  sub_10011EE0(4u, 6078, &unk_1011970C);
  sub_10011EE0(4u, 6104, &unk_10119710);
  sub_10011EE0(0x20u, 6016, &unk_10119714);
  sub_10011EE0(0x20u, 6017, &unk_10119734);
  sub_10011EE0(0x20u, 6018, &unk_10119754);
  sub_10011EE0(0x20u, 6019, &unk_10119774);
  sub_10011EE0(0x20u, 6020, &unk_10119794);
  sub_10011EE0(0x20u, 6021, &unk_101197B4);
  sub_10011EE0(0x20u, 6022, &unk_101197D4);
  sub_10011EE0(0x20u, 6023, &unk_101197F4);
  sub_10011EE0(0x20u, 6024, &unk_10119814);
  sub_10011EE0(0x20u, 6025, &unk_10119834);
  sub_10011EE0(0x20u, 6026, &unk_10119854);
  sub_10011EE0(0x20u, 6027, &unk_10119874);
  sub_10011EE0(0x20u, 6028, &unk_10119894);
  sub_10011EE0(0x20u, 6029, &unk_101198B4);
  sub_10011EE0(0x20u, 6030, &unk_101198D4);
  sub_10011EE0(0x20u, 6031, &unk_101198F4);
  sub_10011EE0(0x20u, 6032, &unk_10119914);
  sub_10011EE0(0x20u, 6033, &unk_10119934);
  sub_10011EE0(0x20u, 6034, &unk_10119954);
  sub_10011EE0(0x20u, 6035, &unk_10119974);
  sub_10011EE0(0x20u, 6036, &unk_10119994);
  sub_10011EE0(0x20u, 6037, &unk_101199B4);
  sub_10011EE0(0x20u, 6038, &unk_101199D4);
  sub_10011EE0(0x20u, 6039, &unk_101199F4);
  sub_10011EE0(0x20u, 6040, &unk_10119A14);
  sub_10011EE0(0x20u, 6041, &unk_10119A34);
  sub_10011EE0(0x20u, 6042, &unk_10119A54);
  sub_10011EE0(0x20u, 6043, &unk_10119A74);
  sub_10011EE0(4u, 6044, &unk_10119A94);
  sub_10011EE0(4u, 6045, &unk_10119A98);
  sub_10011EE0(4u, 6046, &unk_10119A9C);
  sub_10011EE0(4u, 6357, &unk_10119AA0);
  sub_10011EE0(4u, 6358, &unk_10119AA4);
  sub_10011EE0(4u, 6359, &unk_10119AA8);
  sub_10011EE0(0x20u, 6047, &unk_10119AAC);
  sub_10011EE0(0x20u, 6048, &unk_10119ACC);
  sub_10011EE0(0x20u, 6049, &unk_10119AEC);
  sub_10011EE0(0x20u, 6050, &unk_10119B0C);
  sub_10011EE0(0x20u, 6051, &unk_10119B2C);
  sub_10011EE0(0x20u, 6052, &unk_10119B4C);
  sub_10011EE0(0x20u, 6053, &unk_10119B6C);
  sub_10011EE0(0x20u, 6054, &unk_10119B8C);
  sub_10011EE0(1u, 6511, &unk_10119BAC);
  sub_10011EE0(1u, 6522, &unk_10119BAD);
  sub_10011EE0(1u, 6057, &unk_10119BAE);
  sub_10011EE0(0x20u, 6075, &unk_10119C00);
  sub_10011EE0(0x20u, 6076, &unk_10119C20);
  sub_10011EE0(1u, 6077, &unk_10119C40);
  sub_10011EE0(4u, 6079, &unk_10119C44);
  sub_10011EE0(4u, 6080, &unk_10119C48);
  sub_10011EE0(0x20u, 6082, &unk_10119C4C);
  sub_10011EE0(0x20u, 6083, &unk_10119C6C);
  sub_10011EE0(0x20u, 6084, &unk_10119C8C);
  sub_10011EE0(0x20u, 6085, &unk_10119CAC);
  sub_10011EE0(0x20u, 6086, &unk_10119CCC);
  sub_10011EE0(0x20u, 6087, &unk_10119CEC);
  sub_10011EE0(0x20u, 6088, &unk_10119D0C);
  sub_10011EE0(0x20u, 6089, &unk_10119D2C);
  sub_10011EE0(0x20u, 6123, &unk_10119D4C);
  sub_10011EE0(0x48u, 6906, &unk_10119D6C);
  sub_10011EE0(0x48u, 6907, &unk_10119DB4);
  sub_10011EE0(0x48u, 6908, &unk_10119DFC);
  sub_10011EE0(0x48u, 6909, &unk_10119E44);
  sub_10011EE0(0x48u, 6910, &unk_10119E8C);
  sub_10011EE0(0x48u, 6911, &unk_10119ED4);
  sub_10011EE0(0x48u, 6912, &unk_10119F1C);
  sub_10011EE0(0x48u, 6913, &unk_10119F64);
  sub_10011EE0(0x48u, 6914, &unk_10119FAC);
  sub_10011EE0(0x48u, 6915, &unk_10119FF4);
  sub_10011EE0(0x48u, 6916, &unk_1011A03C);
  sub_10011EE0(0x48u, 6917, &unk_1011A084);
  sub_10011EE0(0x48u, 6918, &unk_1011A0CC);
  sub_10011EE0(0x48u, 6919, &unk_1011A114);
  sub_10011EE0(0x48u, 6920, &unk_1011A15C);
  sub_10011EE0(0x48u, 6921, &unk_1011A1A4);
  sub_10011EE0(0x48u, 6922, &unk_1011A1EC);
  sub_10011EE0(0x48u, 6923, &unk_1011A234);
  sub_10011EE0(0x48u, 6924, &unk_1011A27C);
  sub_10011EE0(0x48u, 6925, &unk_1011A2C4);
  sub_10011EE0(0x48u, 6926, &unk_1011A30C);
  sub_10011EE0(0x48u, 6927, &unk_1011A354);
  sub_10011EE0(0x48u, 6928, &unk_1011A39C);
  sub_10011EE0(0x48u, 6929, &unk_1011A3E4);
  sub_10011EE0(0x48u, 6930, &unk_1011A42C);
  sub_10011EE0(0x48u, 6931, &unk_1011A474);
  sub_10011EE0(0x48u, 6932, &unk_1011A4BC);
  sub_10011EE0(0x48u, 6933, &unk_1011A504);
  sub_10011EE0(0x48u, 6934, &unk_1011A54C);
  sub_10011EE0(0x48u, 6935, &unk_1011A594);
  sub_10011EE0(0x18u, 6163, &unk_1011A5DC);
  sub_10011EE0(0x20u, 6164, &unk_1011A5F4);
  sub_10011EE0(0x20u, 6165, &unk_1011A614);
  sub_10011EE0(2u, 6166, &unk_1011A634);
  sub_10011EE0(0xA4u, 40100, &unk_1011A638);
  sub_10011EE0(0xA4u, 40101, &unk_1011A6DC);
  sub_10011EE0(0xA4u, 40102, &unk_1011A780);
  sub_10011EE0(0xA4u, 40103, &unk_1011A824);
  sub_10011EE0(0xA4u, 40104, &unk_1011A8C8);
  sub_10011EE0(0xA4u, 40105, &unk_1011A96C);
  sub_10011EE0(0xA4u, 40106, &unk_1011AA10);
  sub_10011EE0(0xA4u, 40107, &unk_1011AAB4);
  sub_10011EE0(0xA4u, 40108, &unk_1011AB58);
  sub_10011EE0(0xA4u, 40109, &unk_1011ABFC);
  sub_10011EE0(0xA4u, 40110, &unk_1011ACA0);
  sub_10011EE0(0xA4u, 40111, &unk_1011AD44);
  sub_10011EE0(0xA4u, 40112, &unk_1011ADE8);
  sub_10011EE0(0xA4u, 40113, &unk_1011AE8C);
  sub_10011EE0(0xA4u, 40114, &unk_1011AF30);
  sub_10011EE0(0xA4u, 40115, &unk_1011AFD4);
  sub_10011EE0(0xA4u, 40116, &unk_1011B078);
  sub_10011EE0(0xA4u, 40117, &unk_1011B11C);
  sub_10011EE0(0xA4u, 40118, &unk_1011B1C0);
  sub_10011EE0(0xA4u, 40119, &unk_1011B264);
  sub_10011EE0(0xA4u, 40120, &unk_1011B308);
  sub_10011EE0(0xA4u, 40121, &unk_1011B3AC);
  sub_10011EE0(0xA4u, 40122, &unk_1011B450);
  sub_10011EE0(0xA4u, 40123, &unk_1011B4F4);
  sub_10011EE0(0xA4u, 40124, &unk_1011B598);
  sub_10011EE0(0xA4u, 40125, &unk_1011B63C);
  sub_10011EE0(0xA4u, 40126, &unk_1011B6E0);
  sub_10011EE0(0xA4u, 40127, &unk_1011B784);
  sub_10011EE0(0xA4u, 40128, &unk_1011B828);
  sub_10011EE0(0xA4u, 40129, &unk_1011B8CC);
  sub_10011EE0(0xA4u, 40130, &unk_1011B970);
  sub_10011EE0(0xA4u, 40131, &unk_1011BA14);
  sub_10011EE0(0xA4u, 40132, &unk_1011BAB8);
  sub_10011EE0(0xA4u, 40133, &unk_1011BB5C);
  sub_10011EE0(0xA4u, 40134, &unk_1011BC00);
  sub_10011EE0(0xA4u, 40135, &unk_1011BCA4);
  sub_10011EE0(0xA4u, 40136, &unk_1011BD48);
  sub_10011EE0(0xA4u, 40137, &unk_1011BDEC);
  sub_10011EE0(0xA4u, 40138, &unk_1011BE90);
  sub_10011EE0(0xA4u, 40139, &unk_1011BF34);
  sub_10011EE0(0xA4u, 40140, &unk_1011BFD8);
  sub_10011EE0(0xA4u, 40141, &unk_1011C07C);
  sub_10011EE0(0xA4u, 40142, &unk_1011C120);
  sub_10011EE0(0xA4u, 40143, &unk_1011C1C4);
  sub_10011EE0(0xA4u, 40144, &unk_1011C268);
  sub_10011EE0(0xA4u, 40145, &unk_1011C30C);
  sub_10011EE0(0xA4u, 40146, &unk_1011C3B0);
  sub_10011EE0(0xA4u, 40147, &unk_1011C454);
  sub_10011EE0(0xA4u, 40148, &unk_1011C4F8);
  sub_10011EE0(0xA4u, 40149, &unk_1011C59C);
  sub_10011EE0(0xA4u, 40150, &unk_1011C640);
  sub_10011EE0(0xA4u, 40151, &unk_1011C6E4);
  sub_10011EE0(0xA4u, 40152, &unk_1011C788);
  sub_10011EE0(0xA4u, 40153, &unk_1011C82C);
  sub_10011EE0(0xA4u, 40154, &unk_1011C8D0);
  sub_10011EE0(0xA4u, 40155, &unk_1011C974);
  sub_10011EE0(0xA4u, 40156, &unk_1011CA18);
  sub_10011EE0(0xA4u, 40157, &unk_1011CABC);
  sub_10011EE0(0xA4u, 40158, &unk_1011CB60);
  sub_10011EE0(0xA4u, 40159, &unk_1011CC04);
  sub_10011EE0(0xA4u, 40160, &unk_1011CCA8);
  sub_10011EE0(0xA4u, 40161, &unk_1011CD4C);
  sub_10011EE0(0xA4u, 40162, &unk_1011CDF0);
  sub_10011EE0(0xA4u, 40163, &unk_1011CE94);
  sub_10011EE0(0xA4u, 40164, &unk_1011CF38);
  sub_10011EE0(0xA4u, 40165, &unk_1011CFDC);
  sub_10011EE0(0xA4u, 40166, &unk_1011D080);
  sub_10011EE0(0xA4u, 40167, &unk_1011D124);
  sub_10011EE0(0xA4u, 40168, &unk_1011D1C8);
  sub_10011EE0(0xA4u, 40169, &unk_1011D26C);
  sub_10011EE0(0xA4u, 40170, &unk_1011D310);
  sub_10011EE0(0xA4u, 40171, &unk_1011D3B4);
  sub_10011EE0(0xA4u, 40172, &unk_1011D458);
  sub_10011EE0(0xA4u, 40173, &unk_1011D4FC);
  sub_10011EE0(0xA4u, 40174, &unk_1011D5A0);
  sub_10011EE0(0xA4u, 40175, &unk_1011D644);
  sub_10011EE0(0xA4u, 40176, &unk_1011D6E8);
  sub_10011EE0(0xA4u, 40177, &unk_1011D78C);
  sub_10011EE0(0xA4u, 40178, &unk_1011D830);
  sub_10011EE0(0xA4u, 40179, &unk_1011D8D4);
  sub_10011EE0(0xA4u, 40180, &unk_1011D978);
  sub_10011EE0(0xA4u, 40181, &unk_1011DA1C);
  sub_10011EE0(0xA4u, 40182, &unk_1011DAC0);
  sub_10011EE0(0xA4u, 40183, &unk_1011DB64);
  sub_10011EE0(0xA4u, 40184, &unk_1011DC08);
  sub_10011EE0(0xA4u, 40185, &unk_1011DCAC);
  sub_10011EE0(0xA4u, 40186, &unk_1011DD50);
  sub_10011EE0(0xA4u, 40187, &unk_1011DDF4);
  sub_10011EE0(0xA4u, 40188, &unk_1011DE98);
  sub_10011EE0(0xA4u, 40189, &unk_1011DF3C);
  sub_10011EE0(0xA4u, 40190, &unk_1011DFE0);
  sub_10011EE0(0xA4u, 40191, &unk_1011E084);
  sub_10011EE0(0xA4u, 40192, &unk_1011E128);
  sub_10011EE0(0xA4u, 40193, &unk_1011E1CC);
  sub_10011EE0(0xA4u, 40194, &unk_1011E270);
  sub_10011EE0(0xA4u, 40195, &unk_1011E314);
  sub_10011EE0(0xA4u, 40196, &unk_1011E3B8);
  sub_10011EE0(0xA4u, 40197, &unk_1011E45C);
  sub_10011EE0(0xA4u, 40198, &unk_1011E500);
  sub_10011EE0(0xA4u, 40199, &unk_1011E5A4);
  sub_10011EE0(0x20u, 6190, &unk_1011E648);
  sub_10011EE0(0x20u, 6191, &unk_1011E668);
  sub_10011EE0(0x20u, 6192, &unk_1011E688);
  sub_10011EE0(0x20u, 6199, &unk_1011E6A8);
  sub_10011EE0(0x28u, 6207, &unk_1011E6C8);
  sub_10011EE0(4u, 6231, &unk_1011F1E0);
  sub_10011EE0(4u, 6232, &unk_1011F1E4);
  sub_10011EE0(4u, 6233, &unk_1011F1E8);
  sub_10011EE0(4u, 6234, &unk_1011F1EC);
  sub_10011EE0(0x1Cu, 40000, &unk_1011E6F0);
  sub_10011EE0(0x1Cu, 40001, &unk_1011E70C);
  sub_10011EE0(0x1Cu, 40002, &unk_1011E728);
  sub_10011EE0(0x1Cu, 40003, &unk_1011E744);
  sub_10011EE0(0x1Cu, 40004, &unk_1011E760);
  sub_10011EE0(0x1Cu, 40005, &unk_1011E77C);
  sub_10011EE0(0x1Cu, 40006, &unk_1011E798);
  sub_10011EE0(0x1Cu, 40007, &unk_1011E7B4);
  sub_10011EE0(0x1Cu, 40008, &unk_1011E7D0);
  sub_10011EE0(0x1Cu, 40009, &unk_1011E7EC);
  sub_10011EE0(0x1Cu, 40010, &unk_1011E808);
  sub_10011EE0(0x1Cu, 40011, &unk_1011E824);
  sub_10011EE0(0x1Cu, 40012, &unk_1011E840);
  sub_10011EE0(0x1Cu, 40013, &unk_1011E85C);
  sub_10011EE0(0x1Cu, 40014, &unk_1011E878);
  sub_10011EE0(0x1Cu, 40015, &unk_1011E894);
  sub_10011EE0(0x1Cu, 40016, &unk_1011E8B0);
  sub_10011EE0(0x1Cu, 40017, &unk_1011E8CC);
  sub_10011EE0(0x1Cu, 40018, &unk_1011E8E8);
  sub_10011EE0(0x1Cu, 40019, &unk_1011E904);
  sub_10011EE0(0x1Cu, 40020, &unk_1011E920);
  sub_10011EE0(0x1Cu, 40021, &unk_1011E93C);
  sub_10011EE0(0x1Cu, 40022, &unk_1011E958);
  sub_10011EE0(0x1Cu, 40023, &unk_1011E974);
  sub_10011EE0(0x1Cu, 40024, &unk_1011E990);
  sub_10011EE0(0x1Cu, 40025, &unk_1011E9AC);
  sub_10011EE0(0x1Cu, 40026, &unk_1011E9C8);
  sub_10011EE0(0x1Cu, 40027, &unk_1011E9E4);
  sub_10011EE0(0x1Cu, 40028, &unk_1011EA00);
  sub_10011EE0(0x1Cu, 40029, &unk_1011EA1C);
  sub_10011EE0(0x1Cu, 40030, &unk_1011EA38);
  sub_10011EE0(0x1Cu, 40031, &unk_1011EA54);
  sub_10011EE0(0x1Cu, 40032, &unk_1011EA70);
  sub_10011EE0(0x1Cu, 40033, &unk_1011EA8C);
  sub_10011EE0(0x1Cu, 40034, &unk_1011EAA8);
  sub_10011EE0(0x1Cu, 40035, &unk_1011EAC4);
  sub_10011EE0(0x1Cu, 40036, &unk_1011EAE0);
  sub_10011EE0(0x1Cu, 40037, &unk_1011EAFC);
  sub_10011EE0(0x1Cu, 40038, &unk_1011EB18);
  sub_10011EE0(0x1Cu, 40039, &unk_1011EB34);
  sub_10011EE0(0x1Cu, 40040, &unk_1011EB50);
  sub_10011EE0(0x1Cu, 40041, &unk_1011EB6C);
  sub_10011EE0(0x1Cu, 40042, &unk_1011EB88);
  sub_10011EE0(0x1Cu, 40043, &unk_1011EBA4);
  sub_10011EE0(0x1Cu, 40044, &unk_1011EBC0);
  sub_10011EE0(0x1Cu, 40045, &unk_1011EBDC);
  sub_10011EE0(0x1Cu, 40046, &unk_1011EBF8);
  sub_10011EE0(0x1Cu, 40047, &unk_1011EC14);
  sub_10011EE0(0x1Cu, 40048, &unk_1011EC30);
  sub_10011EE0(0x1Cu, 40049, &unk_1011EC4C);
  sub_10011EE0(0x1Cu, 40050, &unk_1011EC68);
  sub_10011EE0(0x1Cu, 40051, &unk_1011EC84);
  sub_10011EE0(0x1Cu, 40052, &unk_1011ECA0);
  sub_10011EE0(0x1Cu, 40053, &unk_1011ECBC);
  sub_10011EE0(0x1Cu, 40054, &unk_1011ECD8);
  sub_10011EE0(0x1Cu, 40055, &unk_1011ECF4);
  sub_10011EE0(0x1Cu, 40056, &unk_1011ED10);
  sub_10011EE0(0x1Cu, 40057, &unk_1011ED2C);
  sub_10011EE0(0x1Cu, 40058, &unk_1011ED48);
  sub_10011EE0(0x1Cu, 40059, &unk_1011ED64);
  sub_10011EE0(0x1Cu, 40060, &unk_1011ED80);
  sub_10011EE0(0x1Cu, 40061, &unk_1011ED9C);
  sub_10011EE0(0x1Cu, 40062, &unk_1011EDB8);
  sub_10011EE0(0x1Cu, 40063, &unk_1011EDD4);
  sub_10011EE0(0x1Cu, 40064, &unk_1011EDF0);
  sub_10011EE0(0x1Cu, 40065, &unk_1011EE0C);
  sub_10011EE0(0x1Cu, 40066, &unk_1011EE28);
  sub_10011EE0(0x1Cu, 40067, &unk_1011EE44);
  sub_10011EE0(0x1Cu, 40068, &unk_1011EE60);
  sub_10011EE0(0x1Cu, 40069, &unk_1011EE7C);
  sub_10011EE0(0x1Cu, 40070, &unk_1011EE98);
  sub_10011EE0(0x1Cu, 40071, &unk_1011EEB4);
  sub_10011EE0(0x1Cu, 40072, &unk_1011EED0);
  sub_10011EE0(0x1Cu, 40073, &unk_1011EEEC);
  sub_10011EE0(0x1Cu, 40074, &unk_1011EF08);
  sub_10011EE0(0x1Cu, 40075, &unk_1011EF24);
  sub_10011EE0(0x1Cu, 40076, &unk_1011EF40);
  sub_10011EE0(0x1Cu, 40077, &unk_1011EF5C);
  sub_10011EE0(0x1Cu, 40078, &unk_1011EF78);
  sub_10011EE0(0x1Cu, 40079, &unk_1011EF94);
  sub_10011EE0(0x1Cu, 40080, &unk_1011EFB0);
  sub_10011EE0(0x1Cu, 40081, &unk_1011EFCC);
  sub_10011EE0(0x1Cu, 40082, &unk_1011EFE8);
  sub_10011EE0(0x1Cu, 40083, &unk_1011F004);
  sub_10011EE0(0x1Cu, 40084, &unk_1011F020);
  sub_10011EE0(0x1Cu, 40085, &unk_1011F03C);
  sub_10011EE0(0x1Cu, 40086, &unk_1011F058);
  sub_10011EE0(0x1Cu, 40087, &unk_1011F074);
  sub_10011EE0(0x1Cu, 40088, &unk_1011F090);
  sub_10011EE0(0x1Cu, 40089, &unk_1011F0AC);
  sub_10011EE0(0x1Cu, 40090, &unk_1011F0C8);
  sub_10011EE0(0x1Cu, 40091, &unk_1011F0E4);
  sub_10011EE0(0x1Cu, 40092, &unk_1011F100);
  sub_10011EE0(0x1Cu, 40093, &unk_1011F11C);
  sub_10011EE0(0x1Cu, 40094, &unk_1011F138);
  sub_10011EE0(0x1Cu, 40095, &unk_1011F154);
  sub_10011EE0(0x1Cu, 40096, &unk_1011F170);
  sub_10011EE0(0x1Cu, 40097, &unk_1011F18C);
  sub_10011EE0(0x1Cu, 40098, &unk_1011F1A8);
  sub_10011EE0(0x1Cu, 40099, &unk_1011F1C4);
  sub_10011EE0(4u, 6238, &unk_1011F1F0);
  sub_10011EE0(4u, 6239, &unk_1011F1F4);
  sub_10011EE0(4u, 6240, &unk_1011F1F8);
  sub_10011EE0(4u, 6242, &unk_1011F1FC);
  sub_10011EE0(4u, 6244, &unk_1011F200);
  sub_10011EE0(4u, 6245, &unk_1011F204);
  sub_10011EE0(4u, 6246, &unk_1011F208);
  sub_10011EE0(4u, 6251, &unk_1011F20C);
  sub_10011EE0(4u, 6252, &unk_1011F210);
  sub_10011EE0(4u, 6253, &unk_1011F214);
  sub_10011EE0(4u, 6254, &unk_1011F218);
  sub_10011EE0(1u, 6255, &unk_1011F21C);
  sub_10011EE0(4u, 6256, &unk_1011F220);
  sub_10011EE0(4u, 6257, &unk_1011F224);
  sub_10011EE0(0xE2u, 6286, &unk_1011F228);
  v0 = 18000;
  v1 = &unk_1011F30C;
  v2 = 16;
  do
  {
    sub_10011EE0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10011EE0(4u, 6262, &unk_101204CC);
  sub_10011EE0(0x28u, 6263, &unk_101204D0);
  sub_10011EE0(0x28u, 6264, &unk_101204F8);
  sub_10011EE0(0x40u, 6268, &unk_10120520);
  sub_10011EE0(4u, 6272, &unk_101205E0);
  sub_10011EE0(4u, 6273, &unk_101205E4);
  sub_10011EE0(1u, 6274, &unk_101205E8);
  sub_10011EE0(2u, 6275, &unk_101205EA);
  sub_10011EE0(1u, 6276, &unk_101205EC);
  sub_10011EE0(1u, 6277, &unk_101205ED);
  sub_10011EE0(1u, 6278, &unk_101205EE);
  sub_10011EE0(0x40u, 6279, &unk_101205F0);
  sub_10011EE0(0x28u, 6753, &unk_101214A5);
  sub_10011EE0(0x30u, 6754, &unk_101214D0);
  sub_10011EE0(0x28u, 6958, &unk_10121500);
  sub_10011EE0(0x80u, 6802, &unk_10120560);
  sub_10011EE0(1u, 6760, &unk_10121528);
  sub_10011EE0(0x10u, 6312, &unk_10120974);
  sub_10011EE0(0x10u, 6313, &unk_10120984);
  sub_10011EE0(0x10u, 6314, &unk_10120994);
  sub_10011EE0(1u, 6307, &unk_101209A4);
  sub_10011EE0(1u, 6308, &unk_101209A5);
  sub_10011EE0(1u, 6309, &unk_101209A6);
  sub_10011EE0(4u, 6285, &unk_101209A8);
  sub_10011EE0(0xA8u, 6318, &unk_101209AC);
  sub_10011EE0(4u, 6319, &unk_10120A54);
  sub_10011EE0(1u, 6350, &unk_10120A58);
  sub_10011EE0(0x50u, 6351, &unk_10120A5C);
  sub_10011EE0(4u, 6352, &unk_10120AAC);
  sub_10011EE0(4u, 6353, &unk_10120AB0);
  sub_10011EE0(0x54u, 6448, &unk_10120CFC);
  sub_10011EE0(0x54u, 6449, &unk_10120D50);
  sub_10011EE0(8u, 6287, &unk_10120654);
  sub_10011EE0(8u, 6288, &unk_1012065C);
  sub_10011EE0(8u, 6289, &unk_10120664);
  sub_10011EE0(8u, 6290, &unk_1012066C);
  sub_10011EE0(8u, 6291, &unk_10120674);
  sub_10011EE0(8u, 6292, &unk_1012067C);
  sub_10011EE0(8u, 6293, &unk_10120684);
  sub_10011EE0(8u, 6294, &unk_1012068C);
  sub_10011EE0(8u, 6295, &unk_10120694);
  sub_10011EE0(8u, 6296, &unk_1012069C);
  sub_10011EE0(8u, 6297, &unk_101206A4);
  sub_10011EE0(8u, 6298, &unk_101206AC);
  sub_10011EE0(8u, 6299, &unk_101206B4);
  sub_10011EE0(8u, 6300, &unk_101206BC);
  sub_10011EE0(8u, 6301, &unk_101206C4);
  sub_10011EE0(8u, 6302, &unk_101206CC);
  sub_10011EE0(8u, 6303, &unk_101206D4);
  sub_10011EE0(8u, 6304, &unk_101206DC);
  sub_10011EE0(8u, 6305, &unk_101206E4);
  sub_10011EE0(8u, 6306, &unk_101206EC);
  sub_10011EE0(8u, 6409, &unk_101206F4);
  sub_10011EE0(8u, 6410, &unk_101206FC);
  sub_10011EE0(8u, 6411, &unk_10120704);
  sub_10011EE0(8u, 6412, &unk_1012070C);
  sub_10011EE0(8u, 6413, &unk_10120714);
  sub_10011EE0(8u, 6414, &unk_1012071C);
  sub_10011EE0(8u, 6415, &unk_10120724);
  sub_10011EE0(8u, 6416, &unk_1012072C);
  sub_10011EE0(8u, 6417, &unk_10120734);
  sub_10011EE0(8u, 6418, &unk_1012073C);
  sub_10011EE0(8u, 6419, &unk_10120744);
  sub_10011EE0(8u, 6420, &unk_1012074C);
  sub_10011EE0(8u, 6421, &unk_10120754);
  sub_10011EE0(8u, 6422, &unk_1012075C);
  sub_10011EE0(8u, 6423, &unk_10120764);
  sub_10011EE0(8u, 6424, &unk_1012076C);
  sub_10011EE0(8u, 6425, &unk_10120774);
  sub_10011EE0(8u, 6426, &unk_1012077C);
  sub_10011EE0(8u, 6427, &unk_10120784);
  sub_10011EE0(8u, 6428, &unk_1012078C);
  sub_10011EE0(4u, 6429, &unk_10120C94);
  sub_10011EE0(8u, 6430, &unk_10120C98);
  sub_10011EE0(8u, 6431, &unk_10120CA0);
  sub_10011EE0(8u, 6432, &unk_10120CA8);
  sub_10011EE0(8u, 6433, &unk_10120CB0);
  sub_10011EE0(8u, 6434, &unk_10120CB8);
  sub_10011EE0(8u, 6435, &unk_10120CC0);
  sub_10011EE0(8u, 6436, &unk_10120CC8);
  sub_10011EE0(8u, 6437, &unk_10120CD0);
  sub_10011EE0(8u, 6438, &unk_10120CD8);
  sub_10011EE0(8u, 6439, &unk_10120CE0);
  sub_10011EE0(8u, 6440, &unk_10120CE8);
  sub_10011EE0(0xAu, 6519, &unk_10121154);
  sub_10011EE0(4u, 6442, &unk_10120CF0);
  sub_10011EE0(4u, 6443, &unk_10120CF4);
  sub_10011EE0(0xF0u, 6367, &unk_10120AB4);
  sub_10011EE0(0xF0u, 6368, &unk_10120BA4);
  sub_10011EE0(1u, 6446, &unk_10120CF8);
  sub_10011EE0(6u, 6452, &unk_10120DA4);
  sub_10011EE0(4u, 6457, &unk_10120DAC);
  sub_10011EE0(4u, 6458, &unk_10120DB0);
  sub_10011EE0(4u, 6459, &unk_10120DB4);
  sub_10011EE0(4u, 6460, &unk_10120DB8);
  sub_10011EE0(0x208u, 6515, &unk_10120DBC);
  sub_10011EE0(0x160u, 6516, &unk_10120FC4);
  sub_10011EE0(0x18u, 6517, &unk_10121124);
  sub_10011EE0(0x18u, 6518, &unk_1012113C);
  sub_10011EE0(1u, 6520, &unk_1012115E);
  sub_10011EE0(0x10u, 6521, &unk_10121160);
  sub_10011EE0(4u, 6523, &unk_10121170);
  sub_10011EE0(4u, 6524, &unk_10121174);
  sub_10011EE0(4u, 6525, &unk_10121178);
  sub_10011EE0(1u, 6526, &unk_1012117C);
  sub_10011EE0(1u, 6527, &unk_1012117D);
  sub_10011EE0(0x50u, 6528, &unk_10121180);
  sub_10011EE0(4u, 6529, &unk_101211D0);
  sub_10011EE0(1u, 6530, &unk_101211D4);
  sub_10011EE0(1u, 6531, &unk_101211D5);
  sub_10011EE0(1u, 6532, &unk_101211D6);
  sub_10011EE0(0x14u, 6533, &unk_101211D7);
  sub_10011EE0(0xAu, 6883, &unk_101218F0);
  sub_10011EE0(0xAu, 6884, &unk_101218FA);
  sub_10011EE0(0xAu, 6885, &unk_10121904);
  sub_10011EE0(1u, 6664, &unk_101211EB);
  sub_10011EE0(1u, 6666, &unk_101211EC);
  sub_10011EE0(1u, 6667, &unk_101211ED);
  sub_10011EE0(1u, 6668, &unk_101211EE);
  sub_10011EE0(0xA0u, 6669, &unk_101211F0);
  sub_10011EE0(2u, 6670, &unk_101212E0);
  sub_10011EE0(4u, 6671, &unk_101212E4);
  sub_10011EE0(4u, 6672, &unk_101212E8);
  sub_10011EE0(4u, 6673, &unk_101212EC);
  sub_10011EE0(4u, 6674, &unk_101212F0);
  sub_10011EE0(4u, 6675, &unk_101212F4);
  sub_10011EE0(4u, 6676, &unk_101212FC);
  sub_10011EE0(4u, 6677, &unk_10121304);
  sub_10011EE0(4u, 6678, &unk_10121308);
  sub_10011EE0(1u, 6679, &unk_1012130C);
  sub_10011EE0(0x140u, 6680, &unk_10121310);
  sub_10011EE0(4u, 6882, &unk_101218EC);
  sub_10011EE0(0xCu, 6652, &unk_10121450);
  sub_10011EE0(0x48u, 6653, &unk_1012145C);
  sub_10011EE0(1u, 6688, &unk_101214A4);
  sub_10011EE0(4u, 6771, &unk_1012152C);
  sub_10011EE0(4u, 6772, &unk_10121530);
  sub_10011EE0(8u, 6787, &unk_10121534);
  sub_10011EE0(1u, 6832, &unk_10121564);
  sub_10011EE0(1u, 6833, &unk_10121565);
  sub_10011EE0(1u, 6834, &unk_10121566);
  sub_10011EE0(4u, 6835, &unk_10121568);
  sub_10011EE0(4u, 6836, &unk_1012156C);
  sub_10011EE0(4u, 6837, &unk_10121570);
  sub_10011EE0(4u, 6838, &unk_10121574);
  sub_10011EE0(1u, 6839, &unk_10121578);
  sub_10011EE0(0x50u, 6840, &unk_10121290);
  sub_10011EE0(4u, 6841, &unk_1012157C);
  sub_10011EE0(4u, 6842, &unk_10121580);
  sub_10011EE0(4u, 6843, &unk_10121584);
  sub_10011EE0(1u, 6844, &unk_10121588);
  sub_10011EE0(0x360u, 6845, &unk_1012158C);
  sub_10011EE0(4u, 6846, &unk_101212F8);
  sub_10011EE0(4u, 6847, &unk_10121300);
  result = 1;
  dword_101E325C = (int)&unk_101196F0;
  return result;
}
// 101E325C: using guessed type int dword_101E325C;

//----- (10013D30) --------------------------------------------------------
int __cdecl sub_10013D30(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1

  v2 = sub_100154C0(v1);
  return sub_100040C0(3168 - (v2 != 2), a1, 41);
}

//----- (10013D60) --------------------------------------------------------
int __cdecl sub_10013D60(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1

  v2 = sub_100154C0(v1);
  return sub_10004190(3168 - (v2 != 2), a1, 41);
}

//----- (10013D90) --------------------------------------------------------
_DWORD *sub_10013D90()
{
  sub_10001540();
  return sub_100226B0();
}

//----- (10013DA0) --------------------------------------------------------
#error "10013DAF: call analysis failed (funcsize=5)"

//----- (10013DC0) --------------------------------------------------------
BOOL __cdecl sub_10013DC0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10003DB0();
  for ( i = sub_1004CA00(6, 0, 1, (int)&v4); i == 12; i = sub_1004CA00(6, 0, 1, (int)&v4) )
  {
    if ( sub_10003DB0() - v1 >= a1 )
      break;
    sub_10003F60(100);
  }
  return i == 12;
}

//----- (10013E30) --------------------------------------------------------
char __thiscall sub_10013E30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10004580(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10013E50) --------------------------------------------------------
void __cdecl sub_10013E50(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10004580(120, a1);
  sub_10004580(124, a2);
  sub_10004580(121, a3);
}

//----- (10013E80) --------------------------------------------------------
int __cdecl sub_10013E80(int a1)
{
  return sub_100040C0(3025, a1, 84);
}

//----- (10013EA0) --------------------------------------------------------
signed int sub_10013EA0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1004CA40(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10013ED0) --------------------------------------------------------
void __cdecl sub_10013ED0(_BYTE *a1)
{
  sub_10004580(129, a1);
}

//----- (10013EF0) --------------------------------------------------------
char __cdecl sub_10013EF0(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1004CA00(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10013F30) --------------------------------------------------------
int __cdecl sub_10013F30(int a1)
{
  return sub_10004190(3025, a1, 84);
}

//----- (10013F50) --------------------------------------------------------
char __fastcall sub_10013F50(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_101E3254 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10013EF0(147, 0xCu, &v38);
  sub_10013EF0(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_10004120(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_10015410(a1);
  if ( !result || result == 3 )
    result = sub_10010E70(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10004190(2000, (int)&v20, 29);
  }
  return result;
}
// 101E3254: using guessed type char byte_101E3254;

//----- (10014170) --------------------------------------------------------
char sub_10014170()
{
  int *v0; // ecx@1

  sub_10013DC0(0x9C40u);
  sub_10010460(&off_1006C498);
  return sub_10013F50(v0);
}
// 1006C498: using guessed type int (__cdecl *off_1006C498)(int, size_t, void *);

//----- (10014190) --------------------------------------------------------
int __cdecl sub_10014190(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100141E0) --------------------------------------------------------
void sub_100141E0()
{
  dword_101E3258 = -15;
}
// 101E3258: using guessed type int dword_101E3258;

//----- (100141F0) --------------------------------------------------------
signed int sub_100141F0()
{
  return sub_1004C930((int)&off_1006C4CC);
}
// 1006C4CC: using guessed type char *off_1006C4CC;

//----- (10014200) --------------------------------------------------------
bool __cdecl sub_10014200(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_100040C0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_100141F0() )
  {
    sub_10003E80(101, 10000);
    v3 = 0.0;
    v4 = dword_101E3258;
    v2 = *(_WORD *)(dword_101E3258 + 1456) > 1u;
    if ( *(_BYTE *)(dword_101E3258 + 1296) )
    {
      v14 = sub_10022740(*(_DWORD *)(dword_101E3258 + 1292));
      v4 = dword_101E3258;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10014190(6.2831853071796, -6.2831853071796);
      sub_10014190(6.2831853071796, -6.2831853071796);
      sub_1004E780(v14, dword_101E3258 + 1512, (int)&v17);
      v4 = dword_101E3258;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_1004E750((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_101E3258;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_101E3258 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10003E60(101);
    sub_10015EF0(a2);
  }
  return v2;
}
// 101E3258: using guessed type int dword_101E3258;

//----- (10014420) --------------------------------------------------------
void sub_10014420()
{
  dword_101230C0 = -15;
}
// 101230C0: using guessed type int dword_101230C0;

//----- (10014430) --------------------------------------------------------
signed int __cdecl sub_10014430(_DWORD *a1)
{
  signed int result; // eax@1

  result = sub_1004C930((int)&off_1006C884);
  *a1 = dword_101230C0;
  return result;
}
// 1006C884: using guessed type char *off_1006C884;
// 101230C0: using guessed type int dword_101230C0;

//----- (10014450) --------------------------------------------------------
int __cdecl sub_10014450(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1006D70C[a1];
  return result;
}
// 1006D70C: using guessed type __int16 word_1006D70C[];

//----- (10014470) --------------------------------------------------------
signed int sub_10014470()
{
  signed int result; // eax@1

  result = -15;
  dword_101230E0 = -15;
  dword_101230EC = -15;
  dword_101230C8 = -15;
  dword_101230F0 = -15;
  dword_101230DC = -15;
  dword_101230CC = -15;
  dword_101230C4 = -15;
  dword_101230D8 = -15;
  dword_101230E8 = -15;
  dword_101230E4 = -15;
  dword_101230D4 = -15;
  dword_101230D0 = -15;
  return result;
}
// 101230C4: using guessed type int dword_101230C4;
// 101230C8: using guessed type int dword_101230C8;
// 101230CC: using guessed type int dword_101230CC;
// 101230D0: using guessed type int dword_101230D0;
// 101230D4: using guessed type int dword_101230D4;
// 101230D8: using guessed type int dword_101230D8;
// 101230DC: using guessed type int dword_101230DC;
// 101230E0: using guessed type int dword_101230E0;
// 101230E4: using guessed type int dword_101230E4;
// 101230E8: using guessed type int dword_101230E8;
// 101230EC: using guessed type int dword_101230EC;
// 101230F0: using guessed type int dword_101230F0;

//----- (100144C0) --------------------------------------------------------
signed int __usercall sub_100144C0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1004C930((int)&off_1006D72C);
      break;
    case 0:
      result = sub_1004C930((int)&off_1006D740);
      break;
    case 1:
      result = sub_1004C930((int)&off_1006D754);
      break;
    case 2:
      result = sub_1004C930((int)&off_1006D77C);
      break;
    case 3:
      result = sub_1004C930((int)&off_1006D768);
      break;
    case 5:
      result = sub_1004C930((int)&off_1006D790);
      break;
    default:
      result = sub_1004C930(a2);
      break;
  }
  return result;
}
// 1006D72C: using guessed type char *off_1006D72C;
// 1006D740: using guessed type char *off_1006D740;
// 1006D754: using guessed type char *off_1006D754;
// 1006D768: using guessed type char *off_1006D768;
// 1006D77C: using guessed type char *off_1006D77C;
// 1006D790: using guessed type char *off_1006D790;

//----- (10014560) --------------------------------------------------------
int __usercall sub_10014560@<eax>(char a1@<al>)
{
  return sub_10003E60(dword_1006D25C[a1]);
}
// 1006D25C: using guessed type int dword_1006D25C[];

//----- (10014580) --------------------------------------------------------
int __usercall sub_10014580@<eax>(char a1@<al>)
{
  return sub_10003E80(dword_1006D25C[a1], 10);
}
// 1006D25C: using guessed type int dword_1006D25C[];

//----- (100145A0) --------------------------------------------------------
signed __int16 __usercall sub_100145A0@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_100144C0(a1, a1) )
        {
          sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_101230E0 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_100144C0(a1, a1) )
      {
        result = *(_WORD *)(dword_101230EC + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10010D20(15000) )
        goto LABEL_6;
      sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_100144C0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101230C8 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_100144C0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101230F0 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_100144C0(a1, a1) )
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_101230DC + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_100144C0(a1, a1) )
        {
          result = *(_WORD *)(dword_101230CC + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 101230C8: using guessed type int dword_101230C8;
// 101230CC: using guessed type int dword_101230CC;
// 101230DC: using guessed type int dword_101230DC;
// 101230E0: using guessed type int dword_101230E0;
// 101230EC: using guessed type int dword_101230EC;
// 101230F0: using guessed type int dword_101230F0;

//----- (100147E0) --------------------------------------------------------
char __cdecl sub_100147E0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_100145A0(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_100144C0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230E0 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_100144C0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230EC + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_100144C0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230C8 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_100144C0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230F0 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_100144C0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230DC + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_100144C0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101230CC + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 101230C8: using guessed type int dword_101230C8;
// 101230CC: using guessed type int dword_101230CC;
// 101230DC: using guessed type int dword_101230DC;
// 101230E0: using guessed type int dword_101230E0;
// 101230EC: using guessed type int dword_101230EC;
// 101230F0: using guessed type int dword_101230F0;

//----- (10014960) --------------------------------------------------------
char __cdecl sub_10014960(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_100145A0(a1, a2);
  if ( v3 != -1 && !sub_10014580(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230E0 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230EC + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230C8 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230F0 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230DC + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_100144C0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101230CC + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10014560(a1);
        return 1;
      default:
LABEL_17:
        sub_10014560(a1);
        break;
    }
  }
  return 0;
}
// 101230C8: using guessed type int dword_101230C8;
// 101230CC: using guessed type int dword_101230CC;
// 101230DC: using guessed type int dword_101230DC;
// 101230E0: using guessed type int dword_101230E0;
// 101230EC: using guessed type int dword_101230EC;
// 101230F0: using guessed type int dword_101230F0;

//----- (10014AC0) --------------------------------------------------------
char __cdecl sub_10014AC0(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_100144C0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_100145A0(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_100147E0(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10003DB0();
      v13 = 0;
      LOBYTE(v7) = sub_10015840(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10014C00) --------------------------------------------------------
char __cdecl sub_10014C00(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_100145A0(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10015840(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10014CE0) --------------------------------------------------------
char __cdecl sub_10014CE0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10003DB0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_100145A0(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_101230E0 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_101230E0 + 210116;
          v12 = dword_101230E0 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_101230EC + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_101230EC + 257156;
          v12 = dword_101230EC + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_101230C8 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_101230C8 + 321708;
          v12 = dword_101230C8 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_101230F0 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_101230F0 + 326220;
          v12 = dword_101230F0 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_101230DC + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_101230DC + 18832;
          v12 = dword_101230DC + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_100144C0(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_101230CC + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_101230CC + 1596;
          v12 = dword_101230CC + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10014580(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10014560(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101230C4: using guessed type int dword_101230C4;
// 101230C8: using guessed type int dword_101230C8;
// 101230CC: using guessed type int dword_101230CC;
// 101230D8: using guessed type int dword_101230D8;
// 101230DC: using guessed type int dword_101230DC;
// 101230E0: using guessed type int dword_101230E0;
// 101230E8: using guessed type int dword_101230E8;
// 101230EC: using guessed type int dword_101230EC;
// 101230F0: using guessed type int dword_101230F0;

//----- (10014F60) --------------------------------------------------------
char __cdecl sub_10014F60(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10014CE0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10014F90) --------------------------------------------------------
char __cdecl sub_10014F90(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10014CE0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10014FC0) --------------------------------------------------------
char __cdecl sub_10014FC0(char a1, int a2, void *a3, int a4)
{
  return sub_10014CE0(a1, a2, 0, 0, a3, a4);
}

//----- (10015000) --------------------------------------------------------
signed int sub_10015000()
{
  return 1000;
}

//----- (10015020) --------------------------------------------------------
int sub_10015020()
{
  return sub_10022470((int)off_1006DD70);
}
// 1006DD70: using guessed type int (*off_1006DD70[4])();

//----- (10015030) --------------------------------------------------------
char __cdecl sub_10015030(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10010D40(13, (char *)&v3 + 3);
  sub_10010D40(12, a1);
  return BYTE3(v3);
}

//----- (100150A0) --------------------------------------------------------
signed int __cdecl sub_100150A0(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10022950(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10023870(v4, a4, 0) == a4 )
      result = sub_10023810(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10015100) --------------------------------------------------------
signed int __cdecl sub_10015100(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10022950(a1);
  return sub_10023870(v3, a2, a3);
}

//----- (10015120) --------------------------------------------------------
int __cdecl sub_10015120(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10023CB0(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10015150) --------------------------------------------------------
int __cdecl sub_10015150(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (10015170) --------------------------------------------------------
int __cdecl sub_10015170(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_10015EF0((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10015250) --------------------------------------------------------
int __cdecl sub_10015250(int a1, float a2, float a3)
{
  double v3; // st7@1
  int result; // eax@3
  double v5; // st7@6
  float v6; // [sp+0h] [bp-14h]@1
  double v7; // [sp+4h] [bp-10h]@6
  double v8; // [sp+Ch] [bp-8h]@6
  float v9; // [sp+1Ch] [bp+8h]@1

  v3 = a2;
  v6 = fabs(a2);
  v9 = fabs(a3);
  if ( v6 > 1.570796370506287 || v9 >= 3.141592741012573 )
  {
    if ( v6 > 4.7123889803847 || v9 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = v3;
      v8 = a3;
      sub_10015EF0((int)&v7);
      v5 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v5;
      *(_DWORD *)(a1 + 4) = (signed int)v5;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(v3 * 683565248.0);
    result = (signed int)(683565248.0 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10015340) --------------------------------------------------------
signed int __cdecl sub_10015340(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (10015360) --------------------------------------------------------
double __cdecl sub_10015360(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (100153A0) --------------------------------------------------------
bool __cdecl sub_100153A0(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_101E2A08[v2 / 4] && word_101E2A04[v2 / 2] && dword_101E2A00[v2 / 4] )
      result = 1;
  }
  return result;
}
// 101E2A00: using guessed type int dword_101E2A00[];
// 101E2A04: using guessed type __int16 word_101E2A04[];
// 101E2A08: using guessed type int dword_101E2A08[];

//----- (100153E0) --------------------------------------------------------
int __cdecl sub_100153E0(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_100153A0(0, a1) )
    result = dword_101E2A08[3 * v1];
  else
    result = 0;
  return result;
}
// 101E2A08: using guessed type int dword_101E2A08[];

//----- (10015410) --------------------------------------------------------
char __thiscall sub_10015410(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10010D40(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 100394D8: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10015440) --------------------------------------------------------
char sub_10015440()
{
  char v1; // [sp+3h] [bp-11h]@1
  char v2; // [sp+4h] [bp-10h]@1
  unsigned int v3; // [sp+8h] [bp-Ch]@1

  sub_10010D40(36, &v1);
  j_HWM_pvg_read_keys(&v2);
  return ((v3 >> 23) | BYTE3(v3) | (v3 >> 25) | (v3 >> 26) | (v3 >> 28) | (v3 >> 29) | (v3 >> 30) | (v3 >> 31)) & 1 | v1;
}
// 10004610: using guessed type int __cdecl j_HWM_pvg_read_keys(_DWORD);

//----- (100154C0) --------------------------------------------------------
int __thiscall sub_100154C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10010D40(46, (char *)&v2);
  return (int)v2;
}

//----- (100154E0) --------------------------------------------------------
char __cdecl sub_100154E0(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_100040E0(6470, (int)&a1, 1);
      result = a1 && sub_10023E70(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_100157E0(14);
    }
    else
    {
      sub_10003C10("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = (sub_10010DE0(v1) & 0x800) == 2048;
  }
  return result;
}

//----- (10015560) --------------------------------------------------------
BOOL sub_10015560()
{
  return sub_100154E0(0) || sub_100154E0(1) || sub_100154E0(2);
}

//----- (100155A0) --------------------------------------------------------
char __thiscall sub_100155A0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_10130840 = sub_10010E10(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10130848, 0, 0x1540u);
  memset(&unk_10131D88, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_10130848;
  do
  {
    sub_10024150(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_10131D88 );
  v3 = 0;
  v4 = &unk_10131D88;
  do
  {
    result = sub_100241D0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_10133738 );
  return result;
}
// 10130840: using guessed type int dword_10130840;

//----- (10015630) --------------------------------------------------------
char __cdecl sub_10015630(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10130840 != 1379255385;
  v7 = 0;
  v8 = dword_10130840 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10004060(86, 10);
      memset((char *)&unk_10130848 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10024150(a1, (int)&unk_10130848 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10130B20[v6] == a2 || byte_10130B21[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10004030(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10130840: using guessed type int dword_10130840;

//----- (100156F0) --------------------------------------------------------
char __cdecl sub_100156F0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10130840 != 1379255385;
  v7 = 0;
  v8 = dword_10130840 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10004060(86, 10);
      memset((char *)&unk_10130848 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10024150(a1, (int)&unk_10130848 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_10130B40[v6] == a2 || byte_10130B41[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10004030(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10130840: using guessed type int dword_10130840;

//----- (100157B0) --------------------------------------------------------
char __cdecl sub_100157B0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10015630(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (100157E0) --------------------------------------------------------
char __cdecl sub_100157E0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_100156F0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10015810) --------------------------------------------------------
char __cdecl sub_10015810(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_10004580(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10015840) --------------------------------------------------------
char __cdecl sub_10015840(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_100117D0((_DWORD *)a2, 2u, (int)&unk_10085508, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_1008550C[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10003F10(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10003D40();
        sub_10011DD0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10003C10("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 1008550C: using guessed type int dword_1008550C[];

//----- (10015960) --------------------------------------------------------
char __cdecl sub_10015960(int a1)
{
  return sub_10015840(31, a1);
}

//----- (10015970) --------------------------------------------------------
int __cdecl sub_10015970(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_101E3254 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_101E28E0)(146, 1, a1);
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E3254: using guessed type char byte_101E3254;

//----- (100159A0) --------------------------------------------------------
char __cdecl sub_100159A0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101E3254 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_101E28E0)(dword_101E2D24, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2D24: using guessed type int dword_101E2D24;
// 101E3254: using guessed type char byte_101E3254;

//----- (100159F0) --------------------------------------------------------
char __cdecl sub_100159F0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101E3254 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101E28E0)(dword_101E2D24, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2D24: using guessed type int dword_101E2D24;
// 101E3254: using guessed type char byte_101E3254;

//----- (10015A40) --------------------------------------------------------
int sub_10015A40()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_101E2A00, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_101E28D0)(512, &v6);
  v1 = 0;
  do
  {
    word_101E2A04[v1 / 2] = 0;
    dword_101E2A08[v1 / 4] = 0;
    dword_101E2A00[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_101E2A0C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_101E2A10 = v7;
    dword_101E2A14 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_101E2A18;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_101E28D0)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_101E2A10;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 101E28D0: using guessed type int dword_101E28D0;
// 101E2A00: using guessed type int dword_101E2A00[];
// 101E2A04: using guessed type __int16 word_101E2A04[];
// 101E2A08: using guessed type int dword_101E2A08[];
// 101E2A0C: using guessed type int dword_101E2A0C;
// 101E2A10: using guessed type int dword_101E2A10;
// 101E2A14: using guessed type int dword_101E2A14;
// 101E2A18: using guessed type int dword_101E2A18;

//----- (10015B10) --------------------------------------------------------
__int16 sub_10015B10()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_101E2A1C;
  v1 = dword_101E2A20;
  v2 = 1;
  v3 = dword_101E2A18;
  if ( (unsigned int)dword_101E2A20 >= 1 )
  {
    v4 = (unsigned __int16)word_101E2A1C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(v3, 2, &v5);
      result = v5;
      word_101E3120[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;
// 101E2A18: using guessed type int dword_101E2A18;
// 101E2A1C: using guessed type __int16 word_101E2A1C;
// 101E2A20: using guessed type int dword_101E2A20;
// 101E3120: using guessed type __int16 word_101E3120[];

//----- (10015B70) --------------------------------------------------------
int __usercall sub_10015B70@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10015BF0) --------------------------------------------------------
char sub_10015BF0()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_101E3254 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_101E28E0)(147, 12, &v17);
  byte_101E3254 = 1;
  dword_1013373C = 0;
  dword_10133740 = 0;
  dword_10133744 = 0;
  dword_10133748 = 0;
  byte_1013374C = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  sub_10015B70((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  }
  byte_101E3254 = 0;
  sub_10015970(&v16);
  if ( v16 != 101 )
  {
    byte_101E3254 = 2;
    return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  }
  if ( byte_101E3254 )
    return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  sub_100159F0(&unk_101E3108, &byte_101E324D);
  byte_101E324C = byte_101E324D - 1;
  if ( byte_101E3254 )
    return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  result = sub_100159A0(&unk_101E3109, &unk_101E310A);
  byte_101E29F4 = 0;
  if ( byte_101E3254 )
    return (unsigned int)memset(dword_101E2A00, 0, 0x708u);
  return result;
}
// 1013373C: using guessed type int dword_1013373C;
// 10133740: using guessed type int dword_10133740;
// 10133744: using guessed type int dword_10133744;
// 10133748: using guessed type int dword_10133748;
// 1013374C: using guessed type char byte_1013374C;
// 101E28E0: using guessed type int dword_101E28E0;
// 101E29F4: using guessed type char byte_101E29F4;
// 101E2A00: using guessed type int dword_101E2A00[];
// 101E324C: using guessed type char byte_101E324C;
// 101E324D: using guessed type char byte_101E324D;
// 101E3254: using guessed type char byte_101E3254;

//----- (10015DB0) --------------------------------------------------------
int (__cdecl *(*sub_10015DB0())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_101E28D0 = (int)off_100951E8;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_101E28E0)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10015B70((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_1008580C)[8 * v1];
      v3 = strlen((&off_1008580C)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_10085810)[v1];
        dword_101E28D0 = (int)(&off_10085810)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 1008580C: using guessed type char *off_1008580C;
// 10085810: using guessed type int (__cdecl *(*off_10085810)[2])(int, int);
// 100951E8: using guessed type int (__cdecl *off_100951E8[2])(int, int);
// 101E28D0: using guessed type int dword_101E28D0;
// 101E28E0: using guessed type int dword_101E28E0;

//----- (10015EE0) --------------------------------------------------------
signed int sub_10015EE0()
{
  return sub_1004C930((int)&off_1008583C);
}
// 1008583C: using guessed type char *off_1008583C;

//----- (10015EF0) --------------------------------------------------------
int __cdecl sub_10015EF0(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_1004E590(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10015FF0) --------------------------------------------------------
signed int __cdecl sub_10015FF0(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10016090) --------------------------------------------------------
int sub_10016090()
{
  int result; // eax@1

  sub_10004160(6361, (int)&unk_10133750, 4);
  result = sub_10004160(6362, (int)&unk_10133754, 4);
  dword_10133758 = 1379255385;
  return result;
}
// 10133758: using guessed type int dword_10133758;

//----- (100160C0) --------------------------------------------------------
int __cdecl sub_100160C0(int a1, int a2)
{
  return sub_10015250(a1, *(float *)a2, *(float *)(a2 + 4));
}

//----- (100160E0) --------------------------------------------------------
bool sub_100160E0()
{
  return sub_10003E60(99) == 0;
}

//----- (100160F0) --------------------------------------------------------
bool sub_100160F0()
{
  return sub_10003E80(99, 10000) == 0;
}

//----- (10016110) --------------------------------------------------------
char sub_10016110()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1004C930((int)&off_10086374);
  if ( v0 )
  {
    dword_101E29EC = dword_1013375C;
    v1 = *(_BYTE *)(dword_1013375C + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_101E29EC + 36) < (unsigned int)sub_10003DB0() )
      v0 = 0;
    dword_101E29E8 = dword_1013375C + 56116;
    result = v0;
    dword_101E29E0 = dword_1013375C + 1516;
    dword_101E29E4 = dword_1013375C + 20484;
  }
  else
  {
    dword_101E29EC = 0;
    dword_101E29E0 = 0;
    dword_101E29E4 = 0;
    dword_101E29E8 = 0;
    result = 0;
  }
  return result;
}
// 10086374: using guessed type char *off_10086374;
// 1013375C: using guessed type int dword_1013375C;
// 101E29E0: using guessed type int dword_101E29E0;
// 101E29E4: using guessed type int dword_101E29E4;
// 101E29E8: using guessed type int dword_101E29E8;
// 101E29EC: using guessed type int dword_101E29EC;

//----- (100161B0) --------------------------------------------------------
unsigned int __cdecl sub_100161B0(char *a1)
{
  return sub_10023B40(a1, -100, 100, 0, 0);
}

//----- (100161D0) --------------------------------------------------------
int __cdecl sub_100161D0(_BYTE *a1)
{
  return sub_10023DA0(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100161F0) --------------------------------------------------------
int __cdecl sub_100161F0(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 1u, 1u, 0);
}

//----- (10016210) --------------------------------------------------------
unsigned int __cdecl sub_10016210(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10023A00((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10023CB0((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10023A00((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023CB0((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023CB0((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10016540) --------------------------------------------------------
unsigned int __cdecl sub_10016540(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10023A00((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023A00((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023B40((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10016980) --------------------------------------------------------
unsigned int __cdecl sub_10016980(_BYTE *a1)
{
  return sub_10023B90(a1, -1, 5, -1, 0);
}

//----- (100169A0) --------------------------------------------------------
int __cdecl sub_100169A0(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 5u, 0, 0);
}

//----- (100169C0) --------------------------------------------------------
int __cdecl sub_100169C0(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 4u, 2u, 0);
}

//----- (100169E0) --------------------------------------------------------
int __cdecl sub_100169E0(_BYTE *a1)
{
  return sub_10023DA0(a1, 0, 2u, 0, 0);
}

//----- (10016A00) --------------------------------------------------------
int __cdecl sub_10016A00(int a1)
{
  return sub_10023A50(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10016A50) --------------------------------------------------------
int __cdecl sub_10016A50(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10016A00((int)(a1 + 4));
  if ( !result )
    result = sub_100169C0(a1);
  return result;
}

//----- (10016A70) --------------------------------------------------------
int __cdecl sub_10016A70(int a1)
{
  int result; // eax@1

  result = sub_100169A0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_100169A0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_100169A0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_100249E0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10023A00((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10023A00((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10023A00((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10023A00((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10016B00) --------------------------------------------------------
unsigned int __cdecl sub_10016B00(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016980((_BYTE *)a1);
  if ( !result )
    result = sub_10016980((_BYTE *)(a1 + 4));
  return result;
}

//----- (10016B20) --------------------------------------------------------
signed int __cdecl sub_10016B20(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10023A00((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10023A00((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10016B70) --------------------------------------------------------
unsigned int __cdecl sub_10016B70(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10016980((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10016980((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10016980((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10023A00((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10016BD0) --------------------------------------------------------
int __cdecl sub_10016BD0(_BYTE *a1)
{
  return sub_10023DA0(a1, 0, 0x20u, 2u, 0);
}

//----- (10016BF0) --------------------------------------------------------
unsigned int __cdecl sub_10016BF0(_BYTE *a1)
{
  return sub_10023B90(a1, -1, 4, -1, 0);
}

//----- (10016C10) --------------------------------------------------------
int __cdecl sub_10016C10(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 9u, 0, 0);
}

//----- (10016C30) --------------------------------------------------------
int __cdecl sub_10016C30(_BYTE *a1)
{
  return sub_10023DA0(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10016C50) --------------------------------------------------------
signed int __cdecl sub_10016C50(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10023DA0(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10016C80) --------------------------------------------------------
int __cdecl sub_10016C80(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10023D00(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10016CC0) --------------------------------------------------------
signed int __cdecl sub_10016CC0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10023D00(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10016CF0) --------------------------------------------------------
int __cdecl sub_10016CF0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10016C50((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10016C80((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016C80((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10015120((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016C80((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10016D80) --------------------------------------------------------
int __cdecl sub_10016D80(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 2u, 0, 0);
}

//----- (10016DA0) --------------------------------------------------------
int __cdecl sub_10016DA0(int a1)
{
  int result; // eax@1

  result = sub_10023CB0((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10023CB0((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10016DD0) --------------------------------------------------------
int __cdecl sub_10016DD0(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 3u, 1u, 0);
}

//----- (10016DF0) --------------------------------------------------------
unsigned int __cdecl sub_10016DF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023B90((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10023B90((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10016E20) --------------------------------------------------------
int __cdecl sub_10016E20(int a1)
{
  int result; // eax@1

  result = sub_10023A50(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10023A50(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10023A50(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10023A50(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10023A50(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10016F10) --------------------------------------------------------
int __cdecl sub_10016F10(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10023A00((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10023CB0((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10016DF0(a1 + 36);
        if ( !result )
        {
          result = sub_10023A50(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10016E20(a1 + 8);
            if ( !result )
            {
              result = sub_10016DF0(a1 + 28);
              if ( !result )
              {
                result = sub_10023D00((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10016D80((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10016DA0(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10023A00((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10016DD0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10017020) --------------------------------------------------------
signed int __cdecl sub_10017020(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10023CB0(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10017050) --------------------------------------------------------
int __cdecl sub_10017050(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 0x64u, 0x64u, 0);
}

//----- (100170B0) --------------------------------------------------------
int __cdecl sub_100170B0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10023A00((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10017050((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (100170C0) --------------------------------------------------------
signed int __cdecl sub_100170C0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10023DA0(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100170F0) --------------------------------------------------------
int __cdecl sub_100170F0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10023CB0((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10023CB0((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10017170) --------------------------------------------------------
unsigned int __cdecl sub_10017170(int a1)
{
  unsigned int result; // eax@1

  result = sub_100161B0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100161B0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100161B0((char *)a1);
      if ( !result )
        result = sub_100161B0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (100171B0) --------------------------------------------------------
unsigned int __cdecl sub_100171B0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10017170(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10016D80((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100161F0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10017200) --------------------------------------------------------
int __cdecl sub_10017200(int a1)
{
  int result; // eax@1

  result = sub_100161D0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10023D00((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10017230) --------------------------------------------------------
int __cdecl sub_10017230(int a1)
{
  int result; // eax@1

  result = sub_100169E0((_BYTE *)a1);
  if ( !result )
    result = sub_10016C30((_BYTE *)(a1 + 4));
  return result;
}

//----- (10017260) --------------------------------------------------------
unsigned int __cdecl sub_10017260(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10016980((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10016BF0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10017290) --------------------------------------------------------
unsigned int __cdecl sub_10017290(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016980((_BYTE *)a1);
  if ( !result )
    result = sub_10016C10((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (100172B0) --------------------------------------------------------
unsigned int __cdecl sub_100172B0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10023CB0((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10016BF0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (100172F0) --------------------------------------------------------
void __cdecl __noreturn sub_100172F0(int a1)
{
  exit(a1 + 4);
}

//----- (10017460) --------------------------------------------------------
signed int __cdecl sub_10017460(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10017020((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10016CC0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10017020((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (100174C0) --------------------------------------------------------
signed int __usercall sub_100174C0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10017460(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10023CB0((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10023A00((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10016540(v2 + 5, a2);
    else
      result = sub_10016210(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100170C0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10017590) --------------------------------------------------------
signed int __cdecl sub_10017590(int a1)
{
  return sub_100174C0(a1, 0);
}

//----- (100175A0) --------------------------------------------------------
char __cdecl sub_100175A0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (100175E0) --------------------------------------------------------
signed int __cdecl sub_100175E0(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10003C10("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10017620) --------------------------------------------------------
int __cdecl sub_10017620(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1004CA30: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10017690) --------------------------------------------------------
bool __cdecl sub_10017690(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10011250(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_10089B58[(unsigned __int8)v4](v3) )
    {
      sub_10017620((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10017890(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10014450(2) )
    result = 0;
  else
    result = sub_10014F90(2, v5, a2) == 1 && !sub_10024AA0(a2);
  return result;
}
// 10089B58: using guessed type int (__cdecl *off_10089B58[3])(char);

//----- (10017750) --------------------------------------------------------
char __cdecl sub_10017750(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10017690(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10017870(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10017860) --------------------------------------------------------
signed int __fastcall sub_10017860(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10017870) --------------------------------------------------------
char __cdecl sub_10017870(unsigned __int8 a1)
{
  return byte_1008B9CC[6 * sub_10017860(a1)];
}

//----- (10017890) --------------------------------------------------------
__int16 __cdecl sub_10017890(unsigned __int8 a1)
{
  return word_1008B9C8[3 * sub_10017860(a1)];
}
// 1008B9C8: using guessed type __int16 word_1008B9C8[];

//----- (100178B0) --------------------------------------------------------
char *__cdecl sub_100178B0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_100561E1;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10017900) --------------------------------------------------------
int sub_10017900()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10003D40();
  result = 0;
  while ( 1 )
  {
    v3 = dword_10133804[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_10133804[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 10133804: using guessed type int dword_10133804[];

//----- (10017940) --------------------------------------------------------
int __cdecl sub_10017940(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100179B0) --------------------------------------------------------
signed int __cdecl sub_100179B0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10017A50) --------------------------------------------------------
int __usercall sub_10017A50@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_100179B0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017A80) --------------------------------------------------------
signed int __usercall sub_10017A80@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_100179B0((_BYTE *)a3, (int)(&off_1008C318)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1008C31C[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1003B6D3(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1003B6D3(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1003B6D3(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1008C318: using guessed type char *off_1008C318;

//----- (10017C50) --------------------------------------------------------
char *__usercall sub_10017C50@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10017CB0) --------------------------------------------------------
int __usercall sub_10017CB0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_100179B0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017D40) --------------------------------------------------------
int __usercall sub_10017D40@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10017A50(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10017D90) --------------------------------------------------------
char **__usercall sub_10017D90@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_100178B0(v6);
      if ( !sub_100179B0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10017DF0) --------------------------------------------------------
const char *__usercall sub_10017DF0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10017E10) --------------------------------------------------------
int __usercall sub_10017E10@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_101337F0[sub_10017900()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (10017E50) --------------------------------------------------------
int __usercall sub_10017E50@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10017A80(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10017EE0) --------------------------------------------------------
int __usercall sub_10017EE0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10018030) --------------------------------------------------------
int __usercall sub_10018030@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10019D80(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10018910(v3, v6, 0);
        v7 = -*v3;
        sub_10019D80(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10019D80(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1008BFD0);
      sub_10024B80(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1008BFD0);
      sub_10019D80(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (100180D0) --------------------------------------------------------
int __usercall sub_100180D0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10018110) --------------------------------------------------------
char *__cdecl sub_10018110(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10017C50(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10017C50(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10017C50(result, v5, (int)&v20);
      v10 = (const char *)&unk_100561E1;
    }
    LOBYTE(v9) = 0;
    sub_10017C50(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10017C50(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10017C50(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10017C50(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10019D10(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10018110: using guessed type int var_61C[6];

//----- (100182C0) --------------------------------------------------------
int __usercall sub_100182C0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_100178B0((char **)a1);
  result = sub_10019DA0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1008BFD0);
  return result;
}

//----- (100182F0) --------------------------------------------------------
int __usercall sub_100182F0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1008BFD0);
  v2 = (unsigned int)sub_100178B0((char **)a1);
  return sub_10019D80(10, v2);
}

//----- (10018320) --------------------------------------------------------
void __cdecl sub_10018320(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_100178B0(v5);
            v7 = sub_100178B0((char **)v3);
            if ( !sub_10017940(v7, (int)v6) )
            {
              v8 = sub_100178B0((char **)v3);
              sub_10019E40(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_100178B0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_100178B0((char **)v3);
        sub_10019E40(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10017DF0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1001A860("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_100178B0((char **)v3);
            sub_10019E80(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10017940(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10017DF0(v18);
                  v25 = sub_1001A860("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_100178B0((char **)v3);
                  sub_10019E80(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_100178B0((char **)v3);
                  sub_10019E80(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_100178B0((char **)v3);
              sub_10019E80(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_100178B0((char **)v3);
              sub_10019E80(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_100178B0((char **)v3);
              sub_10019E80(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10018320(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_100178B0((char **)v3);
            sub_10019E80(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_100178B0((char **)v3);
            sub_10019E80(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_100178B0((char **)v3);
          sub_10019E80(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_100178B0((char **)v3);
        sub_10019E80(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_100178B0(a2);
      sub_10019E40(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10018790) --------------------------------------------------------
int sub_10018790()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_101337F0[sub_10017900()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10018320(i, 0, &v2);
  }
  return v2;
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (100187E0) --------------------------------------------------------
void *sub_100187E0()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_101337F0[0] = 0;
  dword_101337F4 = 0;
  dword_101337F8 = 0;
  dword_101337FC = 0;
  dword_10133800 = 0;
  result = &unk_10133818;
  dword_10133804[0] = -1;
  dword_10133808 = -1;
  dword_1013380C = -1;
  dword_10133810 = -1;
  dword_10133814 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_100180D0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 101337F0: using guessed type int dword_101337F0[];
// 101337F4: using guessed type int dword_101337F4;
// 101337F8: using guessed type int dword_101337F8;
// 101337FC: using guessed type int dword_101337FC;
// 10133800: using guessed type int dword_10133800;
// 10133804: using guessed type int dword_10133804[];
// 10133808: using guessed type int dword_10133808;
// 1013380C: using guessed type int dword_1013380C;
// 10133810: using guessed type int dword_10133810;
// 10133814: using guessed type int dword_10133814;

//----- (10018840) --------------------------------------------------------
char *sub_10018840()
{
  return (char *)&unk_10133818 + 56 * sub_10017900();
}

//----- (10018860) --------------------------------------------------------
char sub_10018860()
{
  return sub_10018840()[33];
}

//----- (10018870) --------------------------------------------------------
char __cdecl sub_10018870(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10018840();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10019900(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (100188B0) --------------------------------------------------------
int *__usercall sub_100188B0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10018840() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_100179B0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10018900) --------------------------------------------------------
char **sub_10018900()
{
  return &off_1008C380;
}
// 1008C380: using guessed type char *off_1008C380;

//----- (10018910) --------------------------------------------------------
int __cdecl sub_10018910(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1001EAD0();
  v3 = sub_10018840();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10018790();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_100182C0(a2);
    if ( a3 )
    {
      v7 = sub_10018030(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10018030(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_100182F0(a2);
        return v7;
      }
    }
    sub_100182F0(a2);
    result = v7;
  }
  return result;
}

//----- (100189C0) --------------------------------------------------------
int __cdecl sub_100189C0(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10017C50(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10017C50(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10017C50(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10019D10(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10017C50(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10017C50(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10017C50(v14, "group-begin", (int)&v29);
          sub_10019D10(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_100178B0(v15);
          sub_100189C0(v16[2], v16[3], v16[4], v17, a4);
          sub_100178B0(v16);
          v18 = sub_10018110((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10017C50(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10017C50(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10017C50(v20, "group-end", (int)&v29);
          result = sub_10019D10(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10017C50(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10017C50(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10017C50(v21, a4, (int)&v28);
          v23 = (const char *)&unk_100561E1;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10017C50(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10017C50(v24, *(const char **)v5, (int)&v30);
        result = sub_10019D10(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 100189C0: using guessed type int var_414[4];

//----- (10018BD0) --------------------------------------------------------
char *__usercall sub_10018BD0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10017C50(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10017C50(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10019D10(2, (int)v11, 2);
  if ( a6 )
  {
    sub_100189C0(a3, (int)a4, a5, a2, 0);
    result = sub_10018110(a3, a4, a5, 0);
  }
  return result;
}
// 10018BD0: using guessed type int var_20C[2];

//----- (10018C90) --------------------------------------------------------
char *__cdecl sub_10018C90(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_101337F0[sub_10017900()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_100178B0((char **)v2);
    sub_10018BD0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10018840() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10018BD0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (10018D30) --------------------------------------------------------
int *__cdecl sub_10018D30(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_101337F0[sub_10017900()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_100178B0(v2);
      if ( !sub_100179B0(a1, (int)v4) )
      {
        v5 = sub_100178B0(v3);
        sub_10018BD0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10018840();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_100179B0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10018BD0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (10018DF0) --------------------------------------------------------
int __usercall sub_10018DF0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10017E10(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10018910((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10017E10(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10018910((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_100182C0(v5);
        sub_10018030(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_100182F0(v8);
          v10 = sub_10017E10(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10018F50) --------------------------------------------------------
signed int __usercall sub_10018F50@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_101337F0[sub_10017900()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10018910((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (10018FC0) --------------------------------------------------------
int __cdecl sub_10018FC0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10018840();
  switch ( a1 )
  {
    case 9:
      sub_10019D80(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_100179B0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_100179B0(v6, (int)"-q") )
            {
              sub_10018D30(v6);
              v9 = sub_10018790();
              sub_10019D80(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10018C90(0);
              v8 = sub_10018790();
              sub_10019D80(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10018C90(1);
            v7 = sub_10018790();
            sub_10019D80(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10019E00(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10019D80(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10018C90(0);
        v4 = sub_10018790();
        sub_10019D80(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10019D80(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_101337F0[sub_10017900()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10018FC0 )
              v12(2, (int)&unk_1008BFD0);
          }
        }
      }
      sub_1001EAD0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10019D80(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_101337F0[sub_10017900()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10019E00(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10018DF0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10019E00(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10018F50((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10019E00(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10018FC0 )
          v15(3, (int)&unk_1008BFD0);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10018FC0: using guessed type int __cdecl sub_10018FC0(int, int);
// 101337F0: using guessed type int dword_101337F0[];

//----- (100192A0) --------------------------------------------------------
char **sub_100192A0()
{
  return off_1008C174;
}
// 1008C174: using guessed type char *off_1008C174[3];

//----- (100192B0) --------------------------------------------------------
int __usercall sub_100192B0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10017D40(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10017E50(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_100192A0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (100193A0) --------------------------------------------------------
int __cdecl sub_100193A0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10018840();
  *a1 = 0;
  v4 = sub_1001A860("Processing command '%s'", v2);
  sub_10019E00(3, (int)&unk_1008CB20, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10017EE0(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10018DF0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10018F50((int)v3);
    v11 = 0;
    v6 = sub_10017900();
    v7 = sub_10017D90((int (**)(void))dword_101337F0[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10017CB0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10017CB0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10018910(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10018910(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_100192B0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_100188B0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_100192B0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_100192A0();
        result = sub_100192B0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 101337F0: using guessed type int dword_101337F0[];
// 100193A0: using guessed type char var_2D4[720];

//----- (100195E0) --------------------------------------------------------
int sub_100195E0()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_100193A0(&v4);
  if ( !sub_10018840()[32] )
    sub_10019D80(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1001A860("%s %i, %s", "Command status:", v0, &v4);
    sub_10019E00(3, (int)&unk_1008CB20, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1001A860("%s %i", "Command status:", v0);
    sub_10019E00(3, (int)&unk_1008CB20, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (100196C0) --------------------------------------------------------
int __cdecl sub_100196C0(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_101337F0[sub_10017900()] = a1;
  sub_10018840()[32] = a3;
  sub_1001EAD0();
  sub_10024D90(a2);
  v3 = sub_10018900();
  sub_100197F0(v3);
  return sub_100195E0();
}
// 101337F0: using guessed type int dword_101337F0[];

//----- (10019710) --------------------------------------------------------
int __cdecl sub_10019710(int a1)
{
  return a1 + 9;
}

//----- (10019720) --------------------------------------------------------
int __cdecl sub_10019720(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10003D40();
  memset(a1, 0, 0xDCu);
  sub_10011DD0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_10019710(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10024F20((int)a1, (int)v3);
}

//----- (100197A0) --------------------------------------------------------
int __cdecl sub_100197A0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10025130(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (100197D0) --------------------------------------------------------
signed int __cdecl sub_100197D0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1004CB30(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10003DB0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10003DB0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10024F20(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (100197F0) --------------------------------------------------------
char __cdecl sub_100197F0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10018840() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10024BD0("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_100195E0() )
          v7 = 0;
      }
      v5 = sub_10024BD0("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_100195E0() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10019900) --------------------------------------------------------
char __cdecl sub_10019900(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10019930) --------------------------------------------------------
bool __cdecl sub_10019930(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10019960) --------------------------------------------------------
bool __cdecl sub_10019960(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10019990) --------------------------------------------------------
bool __cdecl sub_10019990(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (100199C0) --------------------------------------------------------
bool __cdecl sub_100199C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (100199F0) --------------------------------------------------------
bool __cdecl sub_100199F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10019A20) --------------------------------------------------------
bool __cdecl sub_10019A20(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10019A60) --------------------------------------------------------
bool __cdecl sub_10019A60(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10019AA0) --------------------------------------------------------
bool __cdecl sub_10019AA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10019AD0) --------------------------------------------------------
bool __cdecl sub_10019AD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10019B00) --------------------------------------------------------
char __cdecl sub_10019B00(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10019B30) --------------------------------------------------------
bool __cdecl sub_10019B30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10019B60) --------------------------------------------------------
bool __cdecl sub_10019B60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10019B90) --------------------------------------------------------
bool __cdecl sub_10019B90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10019BC0) --------------------------------------------------------
bool __cdecl sub_10019BC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10019BF0) --------------------------------------------------------
bool __cdecl sub_10019BF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1008CB20, 9u);
}

//----- (10019C20) --------------------------------------------------------
bool __cdecl sub_10019C20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10019C50) --------------------------------------------------------
bool __cdecl sub_10019C50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10019C80) --------------------------------------------------------
bool __cdecl sub_10019C80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10019CB0) --------------------------------------------------------
bool __cdecl sub_10019CB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10019CE0) --------------------------------------------------------
bool __cdecl sub_10019CE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10019D10) --------------------------------------------------------
int __cdecl sub_10019D10(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10018840() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10019D80) --------------------------------------------------------
int __cdecl sub_10019D80(int a1, char a2)
{
  return sub_10019D10(a1, (int)&a2, 1);
}

//----- (10019DA0) --------------------------------------------------------
int __cdecl sub_10019DA0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10019D10(a1, (int)&v4, 2);
}

//----- (10019DD0) --------------------------------------------------------
int __cdecl sub_10019DD0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10019D10(a1, (int)&v5, 3);
}

//----- (10019E00) --------------------------------------------------------
int __cdecl sub_10019E00(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10019D10(a1, (int)&v6, 4);
}

//----- (10019E40) --------------------------------------------------------
int __cdecl sub_10019E40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10019D10(a1, (int)&v7, 5);
}

//----- (10019E80) --------------------------------------------------------
int __cdecl sub_10019E80(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10019D10(a1, (int)&v8, 6);
}

//----- (10019ED0) --------------------------------------------------------
char __cdecl sub_10019ED0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10018840();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10019F00) --------------------------------------------------------
char __cdecl sub_10019F00(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10019F10) --------------------------------------------------------
char __cdecl sub_10019F10(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_100561E1;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10025250(v16) )
        sub_10025230((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10025260((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10025250: using guessed type _DWORD __cdecl sub_10025250(_DWORD);
// 10019F10: using guessed type char var_104[255];

//----- (1001A090) --------------------------------------------------------
signed int __cdecl sub_1001A090(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1001A0D0) --------------------------------------------------------
signed int __cdecl sub_1001A0D0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1001A170) --------------------------------------------------------
char __cdecl sub_1001A170(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1001A1D0) --------------------------------------------------------
char __cdecl sub_1001A1D0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10025210(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1001A240) --------------------------------------------------------
char *__cdecl sub_1001A240(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10133930, v1, v2);
  *(&byte_10133930 + v2) = 0;
  return &byte_10133930;
}

//----- (1001A2E0) --------------------------------------------------------
int __cdecl sub_1001A2E0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001A350) --------------------------------------------------------
bool __cdecl sub_1001A350(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1003B6D3(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1003B6D3(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1001A3E0) --------------------------------------------------------
char __cdecl sub_1001A3E0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1001A490) --------------------------------------------------------
char __cdecl sub_1001A490(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1001A4A0) --------------------------------------------------------
char __cdecl sub_1001A4A0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10025210(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1001A520) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001A520(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_100252E0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1001A570) --------------------------------------------------------
signed int __cdecl sub_1001A570(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1001A4A0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001A5C0) --------------------------------------------------------
char *__cdecl sub_1001A5C0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10024BD0("CFG_ActDir", (int)&unk_100561E1);
      v10 = sub_10024BD0("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10024BD0("CFG_ExpDir", (int)&unk_100561E1);
      v10 = sub_10024BD0("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10024BD0("CFG_ActDir", (int)&unk_100561E1);
      break;
    case 4:
      v10 = sub_10024BD0("CFG_ExpDir", (int)&unk_100561E1);
      break;
    default:
      v10 = (char *)&unk_100561E1;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_100561E1;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1001A5C0: using guessed type char var_104[256];

//----- (1001A740) --------------------------------------------------------
int sub_1001A740()
{
  return dword_10138620[sub_10017900()];
}
// 10138620: using guessed type int dword_10138620[];

//----- (1001A750) --------------------------------------------------------
const char *__cdecl sub_1001A750(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1008CD48[a1];
  return result;
}
// 1008CD48: using guessed type char *off_1008CD48[7];

//----- (1001A770) --------------------------------------------------------
int __cdecl sub_1001A770(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10019E40(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1001A820) --------------------------------------------------------
int __cdecl sub_1001A820(int a1)
{
  int result; // eax@1

  result = sub_10017900();
  dword_1013A72C[result] = a1;
  return result;
}
// 1013A72C: using guessed type int dword_1013A72C[];

//----- (1001A840) --------------------------------------------------------
int __cdecl sub_1001A840(int a1)
{
  int result; // eax@1

  result = sub_10017900();
  dword_10138620[result] = a1;
  return result;
}
// 10138620: using guessed type int dword_10138620[];

//----- (1001A860) --------------------------------------------------------
char *sub_1001A860(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10017900() << 8;
  _vsnprintf(&byte_10133A30[v1], 0x100u, a1, va);
  result = &byte_10133A30[v1];
  byte_10133B2E[v1] = 42;
  byte_10133B2F[v1] = 0;
  return result;
}

//----- (1001A8A0) --------------------------------------------------------
char *__usercall sub_1001A8A0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1008CD5C[a1 & 1];
  else
    result = off_1008CD54[a2];
  return result;
}
// 1008CD54: using guessed type char *off_1008CD54[4];
// 1008CD5C: using guessed type char *off_1008CD5C[2];

//----- (1001A8C0) --------------------------------------------------------
char __usercall sub_1001A8C0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10017900();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1001A740() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_1013BD20[v6];
      v12 = dword_1013BD34[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_10138634[v6];
      v12 = dword_1013A718[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 10138634: using guessed type int dword_10138634[];
// 1013A718: using guessed type int dword_1013A718[];
// 1013BD20: using guessed type int dword_1013BD20[];
// 1013BD34: using guessed type int dword_1013BD34[];

//----- (1001AAA0) --------------------------------------------------------
int sub_1001AAA0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1001AAC0) --------------------------------------------------------
int sub_1001AAC0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1001AAE0) --------------------------------------------------------
int __cdecl sub_1001AAE0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10017900();
  dword_1013A718[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10138634[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1001A860(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10019E00(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_10138634[result] = 8;
  }
  return result;
}
// 10138634: using guessed type int dword_10138634[];
// 1013A718: using guessed type int dword_1013A718[];

//----- (1001AB40) --------------------------------------------------------
int __cdecl sub_1001AB40(int a1)
{
  return sub_1001AAE0(0, a1);
}

//----- (1001AB50) --------------------------------------------------------
int __cdecl sub_1001AB50(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10017900();
  dword_1013BD34[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1013BD20[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1001A860(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10019E00(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_1013BD20[result] = 8;
  }
  return result;
}
// 1013BD20: using guessed type int dword_1013BD20[];
// 1013BD34: using guessed type int dword_1013BD34[];

//----- (1001ABB0) --------------------------------------------------------
int __cdecl sub_1001ABB0(int a1)
{
  return sub_1001AB50(0, a1);
}

//----- (1001ABC0) --------------------------------------------------------
bool __cdecl sub_1001ABC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10018860() )
    v8 = v8 == 0;
  v9 = (&off_1008CD2C)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1008CD1C[v8 != 0];
  v19 = off_1008CD24[a1];
  v18 = v10;
  v21 = sub_1001A8A0(0, a6);
  v22 = sub_1001A8A0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_100254C0();
  sub_10019D10(7, (int)&v14, v11);
  sub_100254D0(v12);
  return v8;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001AD00) --------------------------------------------------------
bool __cdecl sub_1001AD00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10017900();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10018860() )
    v16 = v16 == 0;
  sub_1001A8C0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_10134A20[v11], 0x400u, &v30, a6);
  byte_10134E1E[v11] = 42;
  byte_10134E1F[v11] = 0;
  v17 = sub_1001A8C0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v11], 0x400u, &v30, a7);
  byte_1013521E[v11] = 42;
  byte_1013521F[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_10135220[v11];
    byte_10135220[v11] = 0;
  }
  else
  {
    v17 = sub_1001A8C0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_10135220[v11];
    _snprintf(&byte_10135220[v11], 0x400u, &v30, 0);
    byte_1013561E[v11] = 42;
    byte_1013561F[v11] = 0;
  }
  v19 = (&off_1008CD2C)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_10134A20[v11];
  v27 = &byte_10134E20[v11];
  v13 = off_1008CD24[a1];
  v23 = off_1008CD1C[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_100254C0();
  sub_10019D10(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v14);
  return v16;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001B0B0) --------------------------------------------------------
bool __cdecl sub_1001B0B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10017900();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10018860() )
    v20 = v20 == 0;
  sub_1001A8C0((int)&v34, (char *)&unk_1008D010, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_10134A20[v12], 0x400u, &v34);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v21 = sub_1001A8C0((int)&v34, (char *)&unk_1008D010, 3, 0xCu, a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v34, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v13 = &byte_10135220[v12];
    v21 = sub_1001A8C0((int)&v34, (char *)&unk_1008D010, 3, 0xCu, v10);
    _snprintf(&byte_10135220[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v23 = (&off_1008CD2C)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_10134A20[v12];
  v32 = v13;
  v17 = off_1008CD24[a1];
  v27 = off_1008CD1C[v20 != 0];
  v28 = v17;
  v31 = &byte_10134E20[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_100254C0();
  sub_10019D10(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v18);
  return v20;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001B500) --------------------------------------------------------
bool __cdecl sub_1001B500(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10017900();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10018860() )
    v25 = v25 == 0;
  sub_1001A8C0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_10134A20[v20], 0x400u, &v40);
  byte_10134E1E[v20] = 42;
  byte_10134E1F[v20] = 0;
  v26 = sub_1001A8C0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_10134E20[v20], 0x400u, &v40, a7);
  byte_1013521E[v20] = 42;
  byte_1013521F[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_10135220[v20];
    byte_10135220[v20] = 0;
  }
  else
  {
    v21 = &byte_10135220[v20];
    v26 = sub_1001A8C0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_10135220[v20], 0x400u, &v40, v28);
    byte_1013561E[v20] = 42;
    byte_1013561F[v20] = 0;
  }
  v29 = (&off_1008CD2C)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_10134A20[v20];
  v37 = &byte_10134E20[v20];
  v38 = v21;
  v22 = off_1008CD1C[v25 != 0];
  v34 = off_1008CD24[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_100254C0();
  sub_10019D10(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v23);
  return v25;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001B9C0) --------------------------------------------------------
bool __cdecl sub_1001B9C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1008D04C;
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001BD80) --------------------------------------------------------
bool __cdecl sub_1001BD80(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v13 = &byte_10135220[v12];
    v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10134A20[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD24[a1];
  v24 = off_1008CD1C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001C180) --------------------------------------------------------
bool __cdecl sub_1001C180(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001C540) --------------------------------------------------------
bool __cdecl sub_1001C540(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10017900();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10018860() )
        v18 = v18 == 0;
      sub_1001A8C0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_10134A20[3072 * v21], 0x400u, &v33, a6);
      byte_10134E1E[v13] = 42;
      byte_10134E1F[v13] = 0;
      v19 = sub_1001A8C0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_10134E20[3072 * v21], 0x400u, &v33, a7);
      byte_1013521E[v13] = 42;
      byte_1013521F[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_10135220[v13];
        byte_10135220[v13] = 0;
      }
      else
      {
        v19 = sub_1001A8C0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_10135220[v13];
        _snprintf(&byte_10135220[v13], 0x400u, &v33, a8);
        byte_1013561E[v13] = 42;
        byte_1013561F[v13] = 0;
      }
      v22 = (&off_1008CD2C)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_10134A20[3072 * v21];
      v30 = &byte_10134E20[3072 * v21];
      v15 = off_1008CD24[a1];
      v26 = off_1008CD1C[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_100254C0();
      sub_10019D10(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10019E00(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100254D0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001CA80) --------------------------------------------------------
bool __cdecl sub_1001CA80(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v13 = &byte_10135220[v12];
    v18 = sub_1001A8C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10134A20[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD24[a1];
  v24 = off_1008CD1C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001CE60) --------------------------------------------------------
bool __cdecl sub_1001CE60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001D220) --------------------------------------------------------
bool __cdecl sub_1001D220(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001D5C0) --------------------------------------------------------
bool __cdecl sub_1001D5C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v13 = &byte_10135220[v12];
    v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10134A20[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD24[a1];
  v24 = off_1008CD1C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001D9C0) --------------------------------------------------------
bool __cdecl sub_1001D9C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001DD60) --------------------------------------------------------
bool __cdecl sub_1001DD60(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10017900();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10018860() )
        v19 = v19 == 0;
      sub_1001A8C0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_10134A20[3072 * v22];
      _snprintf(&byte_10134A20[3072 * v22], 0x400u, &v35, a6);
      byte_10134E1E[v13] = 42;
      byte_10134E1F[v13] = 0;
      v20 = sub_1001A8C0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_10134E20[3072 * v22];
      _snprintf(&byte_10134E20[v13], 0x400u, &v35, a7);
      byte_1013521E[v13] = 42;
      byte_1013521F[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_10135220[v13];
        byte_10135220[v13] = 0;
      }
      else
      {
        v20 = sub_1001A8C0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_10135220[v13];
        _snprintf(&byte_10135220[v13], 0x400u, &v35, a8);
        byte_1013561E[v13] = 42;
        byte_1013561F[v13] = 0;
      }
      v24 = (&off_1008CD2C)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1008CD24[a1];
      v28 = off_1008CD1C[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_100254C0();
      sub_10019D10(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10019E00(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100254D0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001E340) --------------------------------------------------------
bool __cdecl sub_1001E340(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v13 = &byte_10135220[v12];
    v18 = sub_1001A8C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10134A20[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_10134E20[v12];
  v29 = v13;
  v14 = off_1008CD24[a1];
  v24 = off_1008CD1C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001E730) --------------------------------------------------------
bool __cdecl sub_1001E730(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10017900();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10018860() )
    v17 = v17 == 0;
  sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10134A20[v12], 0x400u, &v31, a6);
  byte_10134E1E[v12] = 42;
  byte_10134E1F[v12] = 0;
  v18 = sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10134E20[v12], 0x400u, &v31, a7);
  byte_1013521E[v12] = 42;
  byte_1013521F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10135220[v12];
    byte_10135220[v12] = 0;
  }
  else
  {
    v18 = sub_1001A8C0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10135220[v12];
    _snprintf(&byte_10135220[v12], 0x400u, &v31, a8);
    byte_1013561E[v12] = 42;
    byte_1013561F[v12] = 0;
  }
  v20 = (&off_1008CD2C)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1008CD1C[v17 != 0];
  v25 = off_1008CD24[a1];
  v24 = v14;
  v27 = &byte_10134A20[v12];
  v28 = &byte_10134E20[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_100254C0();
  sub_10019D10(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019E00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100254D0(v15);
  return v17;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001EAD0) --------------------------------------------------------
int sub_1001EAD0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10017900();
  sub_1001A820(1);
  sub_1001ABB0(-1);
  result = sub_1001AB40(-1);
  dword_10138620[v0] = 0;
  return result;
}
// 10138620: using guessed type int dword_10138620[];

//----- (1001EB00) --------------------------------------------------------
BOOL __usercall sub_1001EB00@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10017900();
  sub_10025500((int)&v13);
  sub_10025500((int)&v14);
  sub_10025500((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10026150((int (__cdecl *)(unsigned int))sub_1001AAA0, v7, (int)&v13) )
  {
    if ( sub_10026150((int (__cdecl *)(unsigned int))sub_1001AAA0, a2, (int)&v14) )
    {
      v9 = sub_10025FC0(
             dword_1013A72C[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1001AAA0,
             (void (__cdecl *)(_DWORD))sub_1001AAC0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_100263F0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_100255D0((void (__cdecl *)(_DWORD))sub_1001AAC0, (int)&v12);
  sub_100255D0((void (__cdecl *)(_DWORD))sub_1001AAC0, (int)&v13);
  sub_100255D0((void (__cdecl *)(_DWORD))sub_1001AAC0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1013A72C: using guessed type int dword_1013A72C[];

//----- (1001EC70) --------------------------------------------------------
bool __usercall sub_1001EC70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10017900();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10018860() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1001D220(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10018860() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_10134A20[3072 * v24], 0x400u, "%s", v9);
  byte_10134E1E[v15] = 42;
  byte_10134E1F[v15] = 0;
  _snprintf(&byte_10134E20[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_1008CD2C)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_1013521E[v15] = 42;
  v17 = off_1008CD1C[v14 != 0];
  v18 = off_1008CD24[a3];
  byte_1013521F[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_10134A20[3072 * v24];
  v34 = &byte_10134E20[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_100254C0();
  sub_10019D10(7, (int)&v26, v19);
  sub_100254D0(v20);
  return v14;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;

//----- (1001EEE0) --------------------------------------------------------
char __cdecl sub_1001EEE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10017900();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1013A72C[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_1013BD48[v10];
  sub_1001A5C0(a3, 1, a6, 0x230u, &byte_1013BD48[v10]);
  v27 = &byte_10138648[v10];
  sub_1001A5C0(a3, 2, a7, 0x230u, &byte_10138648[v10]);
  v24 = &byte_10139C28[v10];
  sub_1001A5C0(a3, 3, a6, 0x230u, &byte_10139C28[v10]);
  v26 = &byte_1013A740[v10];
  sub_1001A5C0(a3, 4, a7, 0x230u, &byte_1013A740[v10]);
  _snprintf(&byte_1013B230[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_1013B230[v10];
  byte_1013B45F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1001A5C0(a3, 0, v25, 560 - (v11 - &byte_1013B230[v10 + 1]), &byte_1013B230[v10] + v11 - &byte_1013B230[v10 + 1]);
  v13 = &byte_1013B230[v10];
  byte_1013B45F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1013B22C[v10] + v13 - &byte_1013B230[v10 + 1]) = 0;
  sub_1001A5C0(a3, 1, (int)&byte_1013B230[v10], 0x230u, &byte_10133F30[v10]);
  sub_1001A5C0(a3, 1, (int)&byte_1013B230[v10], 0x230u, &byte_10139138[v10]);
  v15 = sub_1001EB00(v22, v27, v21, a2 == 1, (int)&byte_10133F30[v10], (const char **)&v22);
  if ( sub_10018860() )
    v15 = v15 == 0;
  v30 = (&off_1008CD2C)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1008CD24[a1];
  v34 = off_1008CD1C[v15 != 0];
  v17 = dword_1013A72C[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_100254C0();
  sub_10019D10(7, (int)&v30, v18);
  sub_100254D0(v19);
  return v15;
}
// 1008CD1C: using guessed type char *off_1008CD1C[5];
// 1008CD24: using guessed type char *off_1008CD24[3];
// 1008CD2C: using guessed type char *off_1008CD2C;
// 1013A72C: using guessed type int dword_1013A72C[];

//----- (1001F1E0) --------------------------------------------------------
bool __cdecl sub_1001F1E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1001B9C0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1001F290) --------------------------------------------------------
bool __cdecl sub_1001F290(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1001EC70(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1001F2D0) --------------------------------------------------------
const char *__cdecl sub_1001F2D0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1001F310) --------------------------------------------------------
char __cdecl sub_1001F310(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10017900();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_1013C840 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1001A570((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1001A090((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1001A570((int)v6, 0);
      return v5;
    case 4:
      sub_10019F10((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1001A240((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1001A520((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10019F00((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10019900((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1001F2D0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1001A520((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        if ( v48 )
          sub_1001A520((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        if ( v48 )
          sub_1001A520((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1001A520((int)v6, v55);
              if ( v48 )
                sub_1001A520((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1001A520((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1001A520((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1001A520((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1001A170((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10019C20((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10019CE0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10019B30((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_100561E1;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_100561E1;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_100561E1;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_100561E1;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_100561E1;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_100561E1;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_100561E1;
          v10 = sub_10019BF0((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_100561E1;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10019930((const void **)a2, a3) )
      {
        dword_1013C838 = 2;
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520((int)v6, "   Command Format:\r\n");
        sub_1001A520(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1001A520(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1001A520(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1001A520(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1001A520((int)v6, "                                         strings depending upon the command\r\n");
        sub_1001A520((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1001A520(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1001A520(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520((int)v6, "   Notes:\r\n");
        sub_1001A520((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1001A520(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1001A520(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1001A520((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1001A520(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1001A520((int)v6, "       without a test suite name.\r\n");
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520((int)v6, "   Examples:\r\n");
        sub_1001A520(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1001A520((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1001A520(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1001A520(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1001A520(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1001A520(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1001A520(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1001A520(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1001A520((int)v6, (const char *)&word_1008E03C);
        sub_1001A520((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1001A520(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_100199C0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, (const char *)&word_1008E03C);
        return v5;
      }
      if ( sub_10019990((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_1013C838,
          &unk_100561E1,
          &v58,
          6 - dword_1013C838,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
        return v5;
      }
      if ( sub_100199F0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10019A20((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_1013C838 += 2;
          return v5;
        }
        if ( sub_10019A60((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_1013C838 < 2 )
            dword_1013C838 = 0;
          else
            dword_1013C838 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_1013C838,
          &unk_100561E1,
          a2[2],
          6 - dword_1013C838,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
        return v5;
      }
      if ( sub_10019960((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_1013C838,
          &unk_100561E1,
          a2[3],
          6 - dword_1013C838,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10019AD0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
      }
      else if ( sub_10019AA0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1001F2D0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1001F2D0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1001A520((int)v6, v55);
      }
      LOBYTE(v5) = sub_1001A1D0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1001A4A0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001A520((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1008E03C: using guessed type __int16 word_1008E03C;
// 1013C838: using guessed type int dword_1013C838;
// 1001F310: using guessed type char var_304[508];

//----- (100200C0) --------------------------------------------------------
signed int __cdecl sub_100200C0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_1013C840 + 580 * sub_10017900();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1001A0D0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10020140) --------------------------------------------------------
char **__cdecl sub_10020140(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_1013C840 + 580 * sub_10017900();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1001A2E0((int)v1, a1, (int)".txt");
  return &off_1008D408;
}
// 1008D408: using guessed type char *off_1008D408;

//----- (10020180) --------------------------------------------------------
int (**sub_10020180())()
{
  return off_1008E0F8;
}
// 1008E0F8: using guessed type int (*off_1008E0F8[2])();

//----- (10020190) --------------------------------------------------------
int (__cdecl *__cdecl sub_10020190(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10017900();
  return sub_1001A520((int)&unk_1013D398 + 1812 * v1, a1);
}

//----- (100201B0) --------------------------------------------------------
const char *sub_100201B0()
{
  return "See version control for test execution date";
}

//----- (100201C0) --------------------------------------------------------
__int64 sub_100201C0()
{
  return 0i64;
}

//----- (100201D0) --------------------------------------------------------
const char *sub_100201D0()
{
  return "Not Available";
}

//----- (100201E0) --------------------------------------------------------
int __usercall sub_100201E0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10020230) --------------------------------------------------------
signed int __cdecl sub_10020230(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10017900();
  return sub_1001A0D0(a1, a2, (int)&unk_1013D398 + 1812 * v2);
}

//----- (10020380) --------------------------------------------------------
int __usercall sub_10020380@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1002DDE0((int)&a2[151 * (*a2 + 1)], (int)sub_10020190, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_100201C0();
  v4 = sub_10024BD0("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1002E230((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10024BD0("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1002E230((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1002E230((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1002E1B0((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1002E040((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10024BD0("CFG_OutputTestRevision", (int)"False");
  if ( !sub_100179B0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1002E1B0((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1002E1B0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1001A240(v3);
  sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1002E130((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10024B90(i, &v15, &v16); ++i )
  {
    sub_1002E1B0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1002E280((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1002E130((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1002E130((int)&a2[151 * (*a2 + 1)]);
  sub_1002E1B0((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1002E040((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10020380: using guessed type char var_103[253];

//----- (10020700) --------------------------------------------------------
char __cdecl sub_10020700(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10017900();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_1013D398 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10019C80(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_100201E0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1002E1B0(v8, (int)"Req");
            sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10019C50(a2, a3) )
      {
        if ( sub_1001A3E0((int)v5, 3, 1, 0) )
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1002E130(v12);
          sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1002E040(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10019B90(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1002E280(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10019CB0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1002E280(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10019C20(a2, a3) )
      {
        if ( sub_1001A3E0((int)v5, 3, 1, 0) )
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001A350((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10019BC0(a2, a3) )
      {
        sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1002E040(v13, (int)"success", (unsigned __int8 *)"0");
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1002E040(v13, (int)"success", (unsigned __int8 *)&unk_10062DBC);
        }
        if ( v5[309] )
        {
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001A3E0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10019B60(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1001A490((int)v5) )
            sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1002E280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1001A3E0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10019F10((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10020380((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10019F00((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1002E280(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1002E280(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1002E280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1001A490((int)v5) )
        sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10019B00((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1002E0E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1002E280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10019900((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1002E090((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1002E090((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1002E090((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_10083ECC, 3u) )
              v44 = (const char *)&unk_100561E1;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1002E1B0(v19, (int)"Expected");
          sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1001A3E0((int)v5, 8, 1, 0) )
        sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1001A170((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1001A1D0((int)v5, (void (__cdecl *)(int))sub_10020260);
      return v4;
    case 0:
    case 11:
      sub_1001A570((int)v5, (void (__cdecl *)(int))sub_10020260);
      goto LABEL_139;
    case 1:
      sub_1001A090((int)v5);
      goto LABEL_139;
    case 12:
      sub_1001A4A0((int)v5, (void (__cdecl *)(int))sub_10020260);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1002E1B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1002E040((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1001A3E0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1002E130((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10020260: using guessed type int sub_10020260();
// 10020700: using guessed type char var_104[255];

//----- (10021520) --------------------------------------------------------
char **__cdecl sub_10021520(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_1013D398 + 1812 * sub_10017900();
  *((_DWORD *)v1 + 146) = 0;
  sub_1001A2E0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1002DDE0(v2, (int)sub_10020190, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_1008E1A8;
}
// 1008E1A8: using guessed type char *off_1008E1A8;

//----- (10021590) --------------------------------------------------------
char __thiscall sub_10021590(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_1013F700 = sub_10010E10(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1013F708, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_1013F708;
  do
  {
    result = sub_10024150(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 1013F700: using guessed type int dword_1013F700;

//----- (10021600) --------------------------------------------------------
char __usercall sub_10021600@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10014F60(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10014F60(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10021640) --------------------------------------------------------
void *__usercall sub_10021640@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_1013F700 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10004060(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_1013F708 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10024150(a1, (int)&unk_1013F708 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_1013F708 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_1013F700 != 1379255385 )
    result = (void *)sub_10004030(v4, 86);
  return result;
}
// 1013F700: using guessed type int dword_1013F700;

//----- (100216E0) --------------------------------------------------------
char __cdecl sub_100216E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10021600(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10021720) --------------------------------------------------------
bool __cdecl sub_10021720(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10021640(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10021780) --------------------------------------------------------
char __cdecl sub_10021780(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10021600(a2, 1, a3, a1);
  return result;
}

//----- (100217C0) --------------------------------------------------------
char __cdecl sub_100217C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10021640(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (100217F0) --------------------------------------------------------
char __cdecl sub_100217F0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10021600(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10021830) --------------------------------------------------------
char __cdecl sub_10021830(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10021640(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10021870) --------------------------------------------------------
char __cdecl sub_10021870(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10021600(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (100218B0) --------------------------------------------------------
bool __cdecl sub_100218B0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10021640(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10021900) --------------------------------------------------------
char __cdecl sub_10021900(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10021600(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10021940) --------------------------------------------------------
bool __cdecl sub_10021940(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10021640(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10021980) --------------------------------------------------------
char __cdecl sub_10021980(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10021600(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (100219C0) --------------------------------------------------------
bool __cdecl sub_100219C0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10021640(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10021A00) --------------------------------------------------------
char __cdecl sub_10021A00(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10021600(1229, 1, a2, a1);
  return result;
}

//----- (10021A30) --------------------------------------------------------
char __cdecl sub_10021A30(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10021640(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10021A60) --------------------------------------------------------
char __cdecl sub_10021A60(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10021600(1212, 16, a2, a1);
  return result;
}

//----- (10021A90) --------------------------------------------------------
char __cdecl sub_10021A90(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10021640(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10021AC0) --------------------------------------------------------
char __cdecl sub_10021AC0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10021600(2400, 65, a2, a1);
  return result;
}

//----- (10021AF0) --------------------------------------------------------
char __cdecl sub_10021AF0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10021640(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10021B20) --------------------------------------------------------
char __cdecl sub_10021B20(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10021600(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10021B60) --------------------------------------------------------
char __cdecl sub_10021B60(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10003C10("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10021640(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10021BB0) --------------------------------------------------------
char __cdecl sub_10021BB0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10021600(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10021BF0) --------------------------------------------------------
char __cdecl sub_10021BF0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10021640(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10021C20) --------------------------------------------------------
char __cdecl sub_10021C20(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10021600(22, 1, a2, a1);
  return result;
}

//----- (10021C50) --------------------------------------------------------
char __cdecl sub_10021C50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10021600(832, 4, a2, a1);
  return result;
}

//----- (10021C80) --------------------------------------------------------
char __cdecl sub_10021C80(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10021640(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10021CB0) --------------------------------------------------------
char __cdecl sub_10021CB0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100175A0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10021B60(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10021B20(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10021BF0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10021BB0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10021720(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100216E0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10021940(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10021900(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_100219C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10021980(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_100217C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10021780(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10021830(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100217F0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10021C20(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10021A90(v6, a5);
        else
          result = sub_10021A60(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_100218B0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10021870(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10021AF0(v6, a5);
        else
          result = sub_10021AC0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10021A30(v6, a5);
        else
          result = sub_10021A00(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10021C80(v6, a5);
        else
          result = sub_10021C50(v6, a5);
        break;
      default:
        sub_10003C10("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10004620: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10022050) --------------------------------------------------------
bool __cdecl sub_10022050(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10140C48 != 1379255385 )
    {
      sub_10024130(a1, (int)&byte_10140C50[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10140C55[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10140C54[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10140C48: using guessed type int dword_10140C48;

//----- (100220C0) --------------------------------------------------------
bool __cdecl sub_100220C0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10140C48 != 1379255385 )
      sub_10024130(a1, (int)&byte_10140C50[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10140C64[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10140C48: using guessed type int dword_10140C48;
// 10140C64: using guessed type int dword_10140C64[];

//----- (10022120) --------------------------------------------------------
bool __cdecl sub_10022120(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10140C48 != 1379255385 )
    {
      sub_10024130(a1, (int)&byte_10140C50[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10140C5C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10140C48: using guessed type int dword_10140C48;
// 10140C5C: using guessed type int dword_10140C5C[];

//----- (10022190) --------------------------------------------------------
char __cdecl sub_10022190(char a1, _BYTE *a2)
{
  if ( dword_10140C48 != 1379255385 )
    sub_10024130(a1, (int)&byte_10140C50[24 * (unsigned __int8)a1]);
  *a2 = byte_10140C50[24 * (unsigned __int8)a1];
  return 1;
}
// 10140C48: using guessed type int dword_10140C48;

//----- (100221D0) --------------------------------------------------------
char __thiscall sub_100221D0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10140C48 = sub_10010E10(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10140C50, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10140C50;
  do
  {
    result = sub_10024130(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10140C48: using guessed type int dword_10140C48;

//----- (10022240) --------------------------------------------------------
char __cdecl sub_10022240(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10010FB0(a1);
  v3 = sub_1004CCA0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10022270) --------------------------------------------------------
char __cdecl sub_10022270(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10010FB0(a1);
  v3 = sub_1004CD10(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100222A0) --------------------------------------------------------
char __cdecl sub_100222A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_100110A0(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10022120(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10022050(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100220C0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10022190(v7, a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10022270(v7, (int)a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10022240(v7, (int)a5);
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10022470) --------------------------------------------------------
int __cdecl sub_10022470(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10140C98 = *(_DWORD *)a1;
  dword_10140C9C = *(_DWORD *)(a1 + 4);
  dword_10140CA0 = *(_DWORD *)(a1 + 8);
  dword_10140CA4 = *(_DWORD *)(a1 + 12);
  dword_101E29D0 = (int)&dword_10140C98;
  return result;
}
// 10140C98: using guessed type int dword_10140C98;
// 10140C9C: using guessed type int dword_10140C9C;
// 10140CA0: using guessed type int dword_10140CA0;
// 10140CA4: using guessed type int dword_10140CA4;
// 101E29D0: using guessed type int dword_101E29D0;

//----- (100224B0) --------------------------------------------------------
char __thiscall sub_100224B0(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_100154C0(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100224D0) --------------------------------------------------------
_DWORD *__usercall sub_100224D0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1002E370(a2, a1);
  result = (_DWORD *)sub_10011EA0(a3, a4);
  if ( (_BYTE)result )
    result = sub_100016F0(a2);
  return result;
}

//----- (100225B0) --------------------------------------------------------
char __cdecl sub_100225B0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_1002E460(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_1002E460(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_100224B0(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_1002E490(v16);
  LOBYTE(v3) = sub_1002E390(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (100226B0) --------------------------------------------------------
_DWORD *sub_100226B0()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10004160(6463, (int)&v1, 256);
  sub_100224D0((int)sub_10022560, (int)&unk_10140CB8, &v1, "PAGE_INIT");
  sub_100224D0((int)sub_10022500, (int)&unk_10140CA8, &v1, "PAGE_SET_FOCUS");
  return sub_100224D0((int)sub_100225B0, (int)&unk_10140CB0, &v1, "KEY_PRESS");
}
// 10022500: using guessed type int sub_10022500();
// 10022560: using guessed type int sub_10022560();

//----- (10022740) --------------------------------------------------------
double __cdecl sub_10022740(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_101E29D0 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_101E29D0 + 12))() * v1);
}
// 101E29D0: using guessed type int dword_101E29D0;

//----- (10022790) --------------------------------------------------------
int __cdecl sub_10022790(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_1008F222[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_1008F222[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10022880) --------------------------------------------------------
__int16 __cdecl sub_10022880(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (100228D0) --------------------------------------------------------
__int16 __cdecl sub_100228D0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10022880((int)&v5, *a1);
  sub_10022790((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10022950) --------------------------------------------------------
unsigned int __cdecl sub_10022950(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10022970) --------------------------------------------------------
bool __cdecl sub_10022970(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10022A40) --------------------------------------------------------
int __cdecl sub_10022A40(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10022A60) --------------------------------------------------------
int __cdecl sub_10022A60(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10022A40(a1 + 20);
  return result;
}

//----- (10022AA0) --------------------------------------------------------
signed int __cdecl sub_10022AA0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100043C0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100043C0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10022B60) --------------------------------------------------------
int __cdecl sub_10022B60(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10022BA0) --------------------------------------------------------
int __usercall sub_10022BA0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10032090(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_100044A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100044C0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10022C50) --------------------------------------------------------
signed int __usercall sub_10022C50@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100044F0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100324E0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10022AA0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100043C0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100043C0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100323B0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100044F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100044F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10022E20) --------------------------------------------------------
char __usercall sub_10022E20@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10032040(a2, a3, a1 + 212);
}

//----- (10022E30) --------------------------------------------------------
int __usercall sub_10022E30@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10022BA0(result + 148, result);
  return result;
}

//----- (10022E50) --------------------------------------------------------
char __usercall sub_10022E50@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10022E70) --------------------------------------------------------
int __usercall sub_10022E70@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10007D00(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10007D00(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10022EB0) --------------------------------------------------------
int __fastcall sub_10022EB0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10022ED0) --------------------------------------------------------
int __usercall sub_10022ED0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10004540(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100044C0(v4, v3, 0);
}
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10022F10) --------------------------------------------------------
signed int __usercall sub_10022F10@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10022EB0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10007D20(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10022E20(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10034290(a2 + 28, 4);
      else
        v22 = sub_10034290(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10022E20(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10023120) --------------------------------------------------------
int __cdecl sub_10023120(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10022E30(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10015030(&v23);
    sub_100228D0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10022A60(v1, (int)&v24);
  v13 = sub_100044A0(v31);
  if ( v3 == v31 )
  {
    result = sub_10004310(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10004540(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_10004310(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10004540(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10022A40(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10022ED0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_100044A0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10023390) --------------------------------------------------------
signed int __cdecl sub_10023390(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10004540(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10022F10(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10023430) --------------------------------------------------------
int __usercall sub_10023430@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10022E50(a1);
  *v3 ^= v2;
  return sub_10022E70(v1, *v3);
}

//----- (10023450) --------------------------------------------------------
int __usercall sub_10023450@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10023430(a2);
  return result;
}

//----- (10023480) --------------------------------------------------------
signed int __usercall sub_10023480@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10022E70(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100043C0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10023570) --------------------------------------------------------
char __usercall sub_10023570@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10031FF0(a1, a2, a3 + 212);
  else
    result = sub_10023450(a2, a3 + 148);
  return result;
}

//----- (100235A0) --------------------------------------------------------
signed int __usercall sub_100235A0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10022C50(v3, v1);
  else
    result = sub_10023480(v3, v1);
  return result;
}

//----- (100235D0) --------------------------------------------------------
signed int __cdecl sub_100235D0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10022B60(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10035D00(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100235A0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10023620) --------------------------------------------------------
signed int __cdecl sub_10023620(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100043C0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10023570(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100043C0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10032090(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10022EB0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_100370C0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10007D20(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10007D20(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10023810) --------------------------------------------------------
signed int __cdecl sub_10023810(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10023620(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10022970(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10023870) --------------------------------------------------------
signed int __cdecl sub_10023870(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100235D0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10022B60(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100235D0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10023810(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10023A00) --------------------------------------------------------
signed int __cdecl sub_10023A00(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10023A50) --------------------------------------------------------
int __cdecl sub_10023A50(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10023B40) --------------------------------------------------------
unsigned int __cdecl sub_10023B40(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10023B90) --------------------------------------------------------
unsigned int __cdecl sub_10023B90(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10023C50) --------------------------------------------------------
unsigned int __cdecl sub_10023C50(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10011C80(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10023CB0) --------------------------------------------------------
int __cdecl sub_10023CB0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10023D00) --------------------------------------------------------
int __cdecl sub_10023D00(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10023DA0) --------------------------------------------------------
int __cdecl sub_10023DA0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10023E70) --------------------------------------------------------
signed int __cdecl sub_10023E70(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10037250(v1) )
  {
    v2 = sub_100040C0(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_100175E0(v8);
      if ( (v4 & sub_10010DE0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_10021AF0(v8, v9);
    v6 = 0;
    while ( !sub_10015630(v8, byte_10091E61[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10023E70: using guessed type char var_1AE[426];
// 10023E70: using guessed type char var_1B0[2];
// 10023E70: using guessed type char var_24C[68];

//----- (10023FA0) --------------------------------------------------------
signed int __cdecl sub_10023FA0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_10091F48;
    v6 = &unk_10091F48;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10091F60;
    v6 = &unk_10091F60;
    v5 = &a1;
  }
  v3 = sub_100117D0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10024000) --------------------------------------------------------
int __cdecl sub_10024000(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100117D0(&a1, 1u, (int)&unk_10091FA8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10091FAC[2 * v1];
  return result;
}
// 10091FAC: using guessed type int dword_10091FAC[];

//----- (10024040) --------------------------------------------------------
signed int __cdecl sub_10024040(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10091FB8;
    v7 = &unk_10091FB8;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10091FD0;
    v7 = &unk_10091FD0;
    v6 = &a1;
  }
  v4 = sub_100117D0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100240B0) --------------------------------------------------------
int __cdecl sub_100240B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100117D0(&a1, 1u, (int)&unk_10091FE8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_10091FEC[2 * v1];
  return result;
}
// 10091FEC: using guessed type int dword_10091FEC[];

//----- (100240F0) --------------------------------------------------------
int __cdecl sub_100240F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100117D0(&a1, 1u, (int)&unk_10092000, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10092004[2 * v1];
  return result;
}
// 10092004: using guessed type int dword_10092004[];

//----- (10024130) --------------------------------------------------------
char __cdecl sub_10024130(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10023FA0(a1, 11);
  return sub_100040E0(v2, a2, 24);
}

//----- (10024150) --------------------------------------------------------
char __cdecl sub_10024150(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10024000(a1);
  return sub_100040E0(v2, a2, 2720);
}

//----- (10024180) --------------------------------------------------------
char __cdecl sub_10024180(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10024040(a1, 11, 1);
  sub_100040E0(v2, a2, 36);
  v3 = sub_10024040(a1, 11, 0);
  return sub_100040E0(v3, a2 + 36, 32);
}

//----- (100241D0) --------------------------------------------------------
char __cdecl sub_100241D0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100240B0(a1);
  return sub_100040E0(v2, a2, 2192);
}

//----- (10024200) --------------------------------------------------------
char __cdecl sub_10024200(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100240F0(a1);
  return sub_100040E0(v2, a2, 60);
}

//----- (10024220) --------------------------------------------------------
char __cdecl sub_10024220(int a1)
{
  return sub_100040E0(6453, a1, 5);
}

//----- (10024240) --------------------------------------------------------
char __cdecl sub_10024240(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100157B0(11);
  }
  else
  {
    result = sub_100157B0(5);
  }
  return result;
}

//----- (10024270) --------------------------------------------------------
char sub_10024270()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10014F90(1, 1309, &v1) )
    sub_100172F0((int)&v1);
  return 0;
}

//----- (10024310) --------------------------------------------------------
BOOL __cdecl sub_10024310(int a1, int a2)
{
  return sub_100040C0(6455, a2, 252) == 0;
}

//----- (10024330) --------------------------------------------------------
char __cdecl sub_10024330(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10024310(a1, a5);
  }
  else
  {
    result = sub_10024270();
  }
  return result;
}

//----- (10024370) --------------------------------------------------------
char __cdecl sub_10024370(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_10014F90(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10014F90(0, 183, a2);
  }
  return result;
}

//----- (100243C0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100243C0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10004190(dword_100942F8[a1], (int)&a2, 1);
  }
  return result;
}
// 100942F8: using guessed type int dword_100942F8[];

//----- (10024400) --------------------------------------------------------
int __cdecl sub_10024400(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10024370(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10024440) --------------------------------------------------------
char __cdecl sub_10024440(char a1)
{
  return byte_100951B9[2 * (unsigned __int8)sub_100117D0(&a1, 1u, (int)&unk_100951B8, 2, 4, 3)];
}

//----- (10024470) --------------------------------------------------------
char __cdecl sub_10024470(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10014F90(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10024940(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10014F90(1, 538, a2);
  }
  if ( !v4 || sub_10017200((int)v3) )
    return 0;
  return 1;
}

//----- (100244F0) --------------------------------------------------------
int __cdecl sub_100244F0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10024470(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10024540) --------------------------------------------------------
void __cdecl sub_10024540(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10004190(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_100249B0(a2);
        sub_10003C10("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10004190(2010, (int)&a2, 1);
    }
  }
}

//----- (100245B0) --------------------------------------------------------
char __cdecl sub_100245B0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101E28E0)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (10024600) --------------------------------------------------------
char __cdecl sub_10024600(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (100246B0) --------------------------------------------------------
char __cdecl sub_100246B0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101E28E0)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (10024710) --------------------------------------------------------
char __cdecl sub_10024710(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101E28E0)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 101E28E0: using guessed type int dword_101E28E0;

//----- (100247E0) --------------------------------------------------------
char __cdecl sub_100247E0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10038210(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10038010(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10038090(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10038110(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10038190(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (100248F0) --------------------------------------------------------
int __cdecl sub_100248F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100117D0(&a1, 1u, (int)&unk_10096318, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_1009631C[2 * v1];
  }
  return result;
}
// 1009631C: using guessed type int dword_1009631C[];

//----- (10024940) --------------------------------------------------------
bool __cdecl sub_10024940(void *a1)
{
  char v1; // cl@1

  v1 = sub_10014F90(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10017200((int)a1);
}

//----- (10024980) --------------------------------------------------------
char __cdecl sub_10024980(char a1)
{
  sub_10014AC0(1, 1672, &a1, 0, 1, 1);
  return sub_10014C00(1, 0x688u, 0xFFFFFFF);
}

//----- (100249B0) --------------------------------------------------------
char __cdecl sub_100249B0(char a1)
{
  int v1; // eax@1

  v1 = sub_10004190(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10024980(a1);
  return v1;
}

//----- (100249E0) --------------------------------------------------------
int __cdecl sub_100249E0(unsigned __int8 *a1)
{
  return sub_10023CB0(a1, 0, 0, 0, 0);
}

//----- (10024A00) --------------------------------------------------------
unsigned int __cdecl sub_10024A00(void *a1)
{
  return sub_10023C50(a1, 0xCu, 0);
}

//----- (10024A20) --------------------------------------------------------
unsigned int __cdecl sub_10024A20(void *a1)
{
  return sub_10023C50(a1, 0x20u, 0);
}

//----- (10024A40) --------------------------------------------------------
unsigned int __cdecl sub_10024A40(void *a1)
{
  return sub_10023C50(a1, 0x1Cu, 0);
}

//----- (10024A60) --------------------------------------------------------
unsigned int __cdecl sub_10024A60(void *a1)
{
  return sub_10023C50(a1, 0x10u, 0);
}

//----- (10024A80) --------------------------------------------------------
unsigned int __cdecl sub_10024A80(void *a1)
{
  return sub_10023C50(a1, 8u, 0);
}

//----- (10024AA0) --------------------------------------------------------
unsigned int __cdecl sub_10024AA0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10024A20((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10024A40((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10024A60(a1);
      if ( !result )
      {
        result = sub_10024A00((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10024A00((char *)a1 + 24);
          if ( !result )
            result = sub_10024A80((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10024B00) --------------------------------------------------------
char sub_10024B00()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10004160(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10024B00: using guessed type int var_1C[7];

//----- (10024B80) --------------------------------------------------------
int __cdecl sub_10024B80(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10024B90) --------------------------------------------------------
char __cdecl sub_10024B90(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_101A0A18[592 * a1]) || byte_101A0A68[v3]) )
  {
    *a2 = &byte_101A0A18[v3];
    *a3 = &byte_101A0A68[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10024BD0) --------------------------------------------------------
char *__cdecl sub_10024BD0(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_101A0A18;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_101A0A68[592 * v2];
}

//----- (10024C40) --------------------------------------------------------
char *__usercall sub_10024C40@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10024C70) --------------------------------------------------------
void __cdecl sub_10024C70(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10024BD0(v2 + 3, (int)&unk_100561E1);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10024C70(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10024D30) --------------------------------------------------------
void __cdecl sub_10024D30(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_101A0A10 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_101A0A10;
    v4 = (char *)(&byte_101A0A18[592 * dword_101A0A10] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_101A0A68[v3];
    v8 = (char *)(&byte_101A0A68[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10024C70(v7);
    ++dword_101A0A10;
  }
}
// 101A0A10: using guessed type int dword_101A0A10;

//----- (10024D90) --------------------------------------------------------
void *__cdecl sub_10024D90(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_101A0A18, 0, 0x73A0u);
  dword_101A0A10 = 0;
  if ( a1 )
  {
    v2 = sub_10025260(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10025440((int)&v11, 512, v2) )
      {
        do
        {
          sub_10024C40(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10024D30((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10024D30(&v11, v4 + 1);
          }
        }
        while ( sub_10025440((int)&v11, 512, v3) );
      }
      result = (void *)sub_10025210(v3);
    }
    else
    {
      result = (void *)sub_10019E80(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 101A0A10: using guessed type int dword_101A0A10;

//----- (10024F20) --------------------------------------------------------
int __cdecl sub_10024F20(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1004CAA0: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1004CAB0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1004CAC0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1004CAD0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1004CB80: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10025060) --------------------------------------------------------
char __usercall sub_10025060@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10025130) --------------------------------------------------------
signed int __cdecl sub_10025130(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1004CAE0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10025060(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10024F20(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1004CB90: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10025210) --------------------------------------------------------
BOOL __cdecl sub_10025210(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_100042B0(a1) == 0;
}
// 100042A0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10025230) --------------------------------------------------------
BOOL __cdecl sub_10025230(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100042F0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10025260) --------------------------------------------------------
unsigned int __cdecl sub_10025260(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10004370: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100252C0) --------------------------------------------------------
signed int __cdecl sub_100252C0(void *a1, int a2, unsigned int a3)
{
  return sub_10004380(a3, a1, a2);
}

//----- (100252E0) --------------------------------------------------------
int __cdecl sub_100252E0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 100044E0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10025300) --------------------------------------------------------
char __cdecl sub_10025300(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10025260((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10025260((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_100252C0(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_100252E0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_100252C0(&v8, 512, v3);
        }
        v2 = i;
        sub_10025210(v4);
      }
      sub_10025210(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10025440) --------------------------------------------------------
int __cdecl sub_10025440(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_100252C0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (100254C0) --------------------------------------------------------
int sub_100254C0()
{
  return 0;
}

//----- (100254D0) --------------------------------------------------------
void __cdecl sub_100254D0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (10025500) --------------------------------------------------------
int __cdecl sub_10025500(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10025520) --------------------------------------------------------
bool __cdecl sub_10025520(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10025550) --------------------------------------------------------
void *__cdecl sub_10025550(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10025590) --------------------------------------------------------
unsigned int __usercall sub_10025590@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (100255B0) --------------------------------------------------------
int __usercall sub_100255B0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (100255D0) --------------------------------------------------------
char __cdecl sub_100255D0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10025520(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10025500(a2);
  }
  return result;
}

//----- (10025600) --------------------------------------------------------
signed int __cdecl sub_10025600(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10025590(v5, v7, v9);
          v11 = (_BYTE *)sub_10025590(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10025590(a4, v7, v9);
            sub_100255B0(v16, (int)&unk_1009A36C);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (100256E0) --------------------------------------------------------
void __cdecl sub_100256E0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10025590((int)v3, v4, v6);
          v8 = sub_10025590(a2, v4, v6);
          v9 = sub_10025590(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10025790) --------------------------------------------------------
void *__usercall sub_10025790@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10025590(a1, v31, v4);
      v6 = sub_10025590(a2, 0, 0);
      sub_100255B0(v5, v6);
      v7 = sub_10025590(a1, v33, v4);
      v8 = sub_10025590(a2, *(_DWORD *)a2 - 1, 0);
      sub_100255B0(v7, v8);
      v9 = sub_10025590(a1, v31, v34 - v4 - 1);
      v10 = sub_10025590(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_100255B0(v9, v10);
      v11 = sub_10025590(a1, v33, v34 - v4 - 1);
      v12 = sub_10025590(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_100255B0(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10025590(a2, 0, 1);
    v16 = (void *)sub_10025590(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10025590(a1, a3 + i, v18);
      v20 = sub_10025590(a2, i, 0);
      sub_100255B0(v19, v20);
      v21 = sub_10025590(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10025590(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_100255B0(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10025590(a2, i, 1);
    v25 = (void *)sub_10025590(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10025590(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10025590(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10025A10) --------------------------------------------------------
void __cdecl sub_10025A10(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10025590(a1, v2, v4);
          v6 = sub_10025590(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10025AE0) --------------------------------------------------------
char __cdecl sub_10025AE0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10025520(a1);
  if ( result )
  {
    result = sub_10025520(a4);
    if ( result )
    {
      sub_100255D0(a3, a4);
      sub_10025550(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10025B50) --------------------------------------------------------
int __usercall sub_10025B50@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10025550(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10025790((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10025590((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10025590(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_100255D0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10025AE0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10025EB0) --------------------------------------------------------
int __usercall sub_10025EB0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10025550(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_100256E0(v8, a3, (int)&v16);
  sub_10025550(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10025B50(9u, v7, (int)&v16, (int)&unk_1009A348, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10025590((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10025590(a6, v9, v11);
            sub_100255B0(v13, (int)&unk_1009A36C);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_100255D0(a5, (int)&v15);
  sub_100255D0(a5, (int)&v16);
  return v10;
}

//----- (10025FC0) --------------------------------------------------------
int __cdecl sub_10025FC0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10025550(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10025A10(a3, a8);
  if ( a1 )
    result = sub_10025EB0(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10025600((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10026150) --------------------------------------------------------
char __cdecl sub_10026150(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10025260((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_100252C0(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_100252C0(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10025550(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_100252C0(v6, v7, v12) == v7 && (!v9 || sub_100252C0(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10025210(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100262A0) --------------------------------------------------------
char __usercall sub_100262A0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10025260(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_100252E0((int)&v14, 14, v9) == 14 && sub_100252E0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_100252E0(v12, v6, v10) == v6 && (!v7 || sub_100252E0((int)&unk_1009A510, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10025210(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10025210(v10);
  }
  return v30;
}

//----- (100263F0) --------------------------------------------------------
char __cdecl sub_100263F0(int a1, int a2)
{
  char result; // al@2

  if ( sub_10025520(a1) )
    result = sub_100262A0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10026430) --------------------------------------------------------
signed int __cdecl sub_10026430(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_101A7DB9 = 1;
    byte_101A7DB8 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101A7DB8 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101A7DB9 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (10026490) --------------------------------------------------------
bool __cdecl sub_10026490(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10019DD0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100B2108, (int)"failing_subroutine( depth-1 )");
    sub_10026490(a1 - 1);
    exit_0(14);
  }
  return sub_1001F290(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10026500) --------------------------------------------------------
int sub_10026500()
{
  const char *v0; // eax@1

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_101A7DB8 )
  {
    sub_1001F290(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10019DD0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10026490(1);
    exit_0(14);
  }
  return sub_10019E00(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10026820) --------------------------------------------------------
char sub_10026820()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A7DB8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1009B17C + v2) )
      {
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1009B184[v2], 0x100u, &v11);
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1009B17C + v2), 0x100u, &v12);
        sub_10025300(&v12, &v11);
      }
      if ( byte_1009B178[v2] )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_1009B180[v2 / 4];
        v4 = *(char **)&off_1009B184[v2];
        v5 = sub_1001A860(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009B184[v2],
               off_1009B180[v2 / 4]);
        v6 = sub_1001EEE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001ABC0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_1009B180[v2 / 4];
        v8 = *(char **)&off_1009B184[v2];
        v9 = sub_1001A860(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009B184[v2],
               off_1009B180[v2 / 4]);
        v10 = sub_1001EEE0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001ABC0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1009B17C: using guessed type void *off_1009B17C;
// 1009B180: using guessed type char *off_1009B180[2];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10026A40) --------------------------------------------------------
char sub_10026A40()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A7DB8 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1001ABC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1001ABC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1001ABC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1001ABC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001ABC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10026C40) --------------------------------------------------------
char sub_10026C40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009B20C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_1009B209[v2 * 4];
        v4 = byte_1009B208[v2 * 4];
        v5 = sub_1001A860(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + dword_1009B20C[v2])],
               (&off_1009B210)[v2 * 4]);
        v6 = sub_1001AD00(
               0,
               *(&dword_1009B15C + dword_1009B20C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001A860(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009B20C[v2]],
               (&off_1009B210)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009B20C: using guessed type int dword_1009B20C[];
// 1009B210: using guessed type char *off_1009B210;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10026DC0) --------------------------------------------------------
char sub_10026DC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009B490[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1009B488[v2 / 8];
        v4 = dbl_1009B480[v2 / 8];
        v5 = dbl_1009B478[v2 / 8];
        v6 = sub_1001A860(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009B494[v2]);
        v7 = sub_1001B0B0(
               0,
               *(&dword_1009B15C + dword_1009B490[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009B490[v2 / 4]],
               *(_DWORD *)&off_1009B494[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009B478: using guessed type double dbl_1009B478[];
// 1009B480: using guessed type double dbl_1009B480[];
// 1009B488: using guessed type double dbl_1009B488[];
// 1009B490: using guessed type int dword_1009B490[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10026F40) --------------------------------------------------------
char sub_10026F40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009C0A4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1009C0A0[v2];
        v4 = flt_1009C09C[v2];
        v5 = flt_1009C098[v2];
        v6 = sub_1001A860(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009C0A8[v2 * 4]);
        v7 = sub_1001B500(
               0,
               *(&dword_1009B15C + dword_1009C0A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009C0A4[v2]],
               *(_DWORD *)&off_1009C0A8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009C098: using guessed type float flt_1009C098[];
// 1009C09C: using guessed type float flt_1009C09C[];
// 1009C0A0: using guessed type float flt_1009C0A0[];
// 1009C0A4: using guessed type int dword_1009C0A4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100270B0) --------------------------------------------------------
char sub_100270B0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A7DB8 )
  {
    sub_1001F1E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_100270B0,
      (int)sub_100270B0,
      (int)"This test is expected to fail");
    sub_1001F1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_100270B0,
      0,
      (int)"This test is expected to fail");
    result = sub_1001F1E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100270B0,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100271B0) --------------------------------------------------------
char sub_100271B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009C84C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009C848[v2];
        v4 = dword_1009C844[v2];
        v5 = dword_1009C840[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009C850)[v2 * 4]);
        v7 = sub_1001B9C0(
               0,
               *(&dword_1009B15C + dword_1009C84C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009C84C[v2]],
               (&off_1009C850)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009C840: using guessed type int dword_1009C840[];
// 1009C844: using guessed type int dword_1009C844[];
// 1009C848: using guessed type int dword_1009C848[];
// 1009C84C: using guessed type int dword_1009C84C[];
// 1009C850: using guessed type char *off_1009C850;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027310) --------------------------------------------------------
char sub_10027310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009CFE0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009CFDC[v2 / 2];
        v4 = word_1009CFDA[v2 / 2];
        v5 = word_1009CFD8[v2 / 2];
        v6 = sub_1001A860(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009CFE4)[v2]);
        v7 = sub_1001BD80(
               0,
               *(&dword_1009B15C + dword_1009CFE0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009CFE0[v2 / 4]],
               (&off_1009CFE4)[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009CFD8: using guessed type __int16 word_1009CFD8[];
// 1009CFDA: using guessed type __int16 word_1009CFDA[];
// 1009CFDC: using guessed type __int16 word_1009CFDC[];
// 1009CFE0: using guessed type int dword_1009CFE0[];
// 1009CFE4: using guessed type char *off_1009CFE4;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027470) --------------------------------------------------------
char sub_10027470()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009D5F4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009D5F0[v2];
        v4 = dword_1009D5EC[v2];
        v5 = dword_1009D5E8[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009D5F8[v2 * 4]);
        v7 = sub_1001C180(
               0,
               *(&dword_1009B15C + dword_1009D5F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009D5F4[v2]],
               *(_DWORD *)&off_1009D5F8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009D5E8: using guessed type int dword_1009D5E8[];
// 1009D5EC: using guessed type int dword_1009D5EC[];
// 1009D5F0: using guessed type int dword_1009D5F0[];
// 1009D5F4: using guessed type int dword_1009D5F4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100275D0) --------------------------------------------------------
char sub_100275D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009DD98[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009DD94[v2];
        LODWORD(v3) = dword_1009DD90[v2];
        HIDWORD(v4) = dword_1009DD8C[v2];
        LODWORD(v4) = dword_1009DD88[v2];
        HIDWORD(v5) = dword_1009DD84[v2];
        LODWORD(v5) = dword_1009DD80[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009DD9C[v2 * 4]);
        v7 = sub_1001C540(
               0,
               *(&dword_1009B15C + dword_1009DD98[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009DD98[v2]],
               *(_DWORD *)&off_1009DD9C[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009DD80: using guessed type int dword_1009DD80[];
// 1009DD84: using guessed type int dword_1009DD84[];
// 1009DD88: using guessed type int dword_1009DD88[];
// 1009DD8C: using guessed type int dword_1009DD8C[];
// 1009DD90: using guessed type int dword_1009DD90[];
// 1009DD94: using guessed type int dword_1009DD94[];
// 1009DD98: using guessed type int dword_1009DD98[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027740) --------------------------------------------------------
char sub_10027740()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009E9A4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1009E9A2[v2 * 4];
        v4 = byte_1009E9A1[v2 * 4];
        v5 = byte_1009E9A0[v2 * 4];
        v6 = sub_1001A860(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009E9A8)[v2 * 4]);
        v7 = sub_1001CA80(
               0,
               *(&dword_1009B15C + dword_1009E9A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009E9A4[v2]],
               (&off_1009E9A8)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009E9A4: using guessed type int dword_1009E9A4[];
// 1009E9A8: using guessed type char *off_1009E9A8;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100278A0) --------------------------------------------------------
char sub_100278A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009EE3C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009EE38[v2];
        v4 = dword_1009EE34[v2];
        v5 = dword_1009EE30[v2];
        v6 = sub_1001A860(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009EE40)[v2 * 4]);
        v7 = sub_1001CE60(
               0,
               *(&dword_1009B15C + dword_1009EE3C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009EE3C[v2]],
               (&off_1009EE40)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009EE30: using guessed type int dword_1009EE30[];
// 1009EE34: using guessed type int dword_1009EE34[];
// 1009EE38: using guessed type int dword_1009EE38[];
// 1009EE3C: using guessed type int dword_1009EE3C[];
// 1009EE40: using guessed type char *off_1009EE40;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027A00) --------------------------------------------------------
char sub_10027A00()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A7DB8 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1001F290(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100561E1,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1001F290(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100561E1,
           "a",
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1001F290(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100561E1,
           (const char *)&unk_100561E1,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1001F290(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1001ABC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027C20) --------------------------------------------------------
char sub_10027C20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F5D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009F5D0[v2];
        v4 = dword_1009F5CC[v2];
        v5 = dword_1009F5C8[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009F5D8[v2 * 4]);
        v7 = sub_1001D220(
               0,
               *(&dword_1009B15C + dword_1009F5D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009F5D4[v2]],
               *(_DWORD *)&off_1009F5D8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F5C8: using guessed type int dword_1009F5C8[];
// 1009F5CC: using guessed type int dword_1009F5CC[];
// 1009F5D0: using guessed type int dword_1009F5D0[];
// 1009F5D4: using guessed type int dword_1009F5D4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027D80) --------------------------------------------------------
char sub_10027D80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F940[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009F93C[v2 / 2];
        v4 = word_1009F93A[v2 / 2];
        v5 = word_1009F938[v2 / 2];
        v6 = sub_1001A860(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009F944)[v2]);
        v7 = sub_1001D5C0(
               0,
               *(&dword_1009B15C + dword_1009F940[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009F940[v2 / 4]],
               (&off_1009F944)[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F938: using guessed type __int16 word_1009F938[];
// 1009F93A: using guessed type __int16 word_1009F93A[];
// 1009F93C: using guessed type __int16 word_1009F93C[];
// 1009F940: using guessed type int dword_1009F940[];
// 1009F944: using guessed type char *off_1009F944;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10027EE0) --------------------------------------------------------
char sub_10027EE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009FC04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009FC00[v2];
        v4 = dword_1009FBFC[v2];
        v5 = dword_1009FBF8[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_1009FC08[v2 * 4]);
        v7 = sub_1001D9C0(
               0,
               *(&dword_1009B15C + dword_1009FC04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009FC04[v2]],
               *(_DWORD *)&off_1009FC08[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009FBF8: using guessed type int dword_1009FBF8[];
// 1009FBFC: using guessed type int dword_1009FBFC[];
// 1009FC00: using guessed type int dword_1009FC00[];
// 1009FC04: using guessed type int dword_1009FC04[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028040) --------------------------------------------------------
char sub_10028040()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_1009FF80[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009FF7C[v2];
        LODWORD(v3) = dword_1009FF78[v2];
        HIDWORD(v4) = dword_1009FF74[v2];
        LODWORD(v4) = dword_1009FF70[v2];
        HIDWORD(v5) = dword_1009FF6C[v2];
        LODWORD(v5) = dword_1009FF68[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_1009FF84)[v2 * 4]);
        v7 = sub_1001DD60(
               0,
               *(&dword_1009B15C + dword_1009FF80[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_1009FF80[v2]],
               (&off_1009FF84)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009FF68: using guessed type int dword_1009FF68[];
// 1009FF6C: using guessed type int dword_1009FF6C[];
// 1009FF70: using guessed type int dword_1009FF70[];
// 1009FF74: using guessed type int dword_1009FF74[];
// 1009FF78: using guessed type int dword_1009FF78[];
// 1009FF7C: using guessed type int dword_1009FF7C[];
// 1009FF80: using guessed type int dword_1009FF80[];
// 1009FF84: using guessed type char *off_1009FF84;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100281B0) --------------------------------------------------------
char sub_100281B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A04EC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A04EA[v2 * 4];
        v4 = byte_100A04E9[v2 * 4];
        v5 = byte_100A04E8[v2 * 4];
        v6 = sub_1001A860(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A04F0)[v2 * 4]);
        v7 = sub_1001E340(
               0,
               *(&dword_1009B15C + dword_100A04EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A04EC[v2]],
               (&off_100A04F0)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A04EC: using guessed type int dword_100A04EC[];
// 100A04F0: using guessed type char *off_100A04F0;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028310) --------------------------------------------------------
char sub_10028310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A0704[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A0700[v2];
        v4 = dword_100A06FC[v2];
        v5 = dword_100A06F8[v2];
        v6 = sub_1001A860(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A0708[v2 * 4]);
        v7 = sub_1001E730(
               0,
               *(&dword_1009B15C + dword_100A0704[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A0704[v2]],
               *(_DWORD *)&off_100A0708[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A06F8: using guessed type int dword_100A06F8[];
// 100A06FC: using guessed type int dword_100A06FC[];
// 100A0700: using guessed type int dword_100A0700[];
// 100A0704: using guessed type int dword_100A0704[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028470) --------------------------------------------------------
char sub_10028470()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A7DB8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100A0A6C + v2) )
      {
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A0A74[v2], 0x100u, &v11);
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100A0A6C + v2), 0x100u, &v12);
        sub_10025300(&v12, &v11);
      }
      if ( byte_100A0A68[v2] )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100A0A70[v2 / 4];
        v4 = *(char **)&off_100A0A74[v2];
        v5 = sub_1001A860(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A0A74[v2],
               off_100A0A70[v2 / 4]);
        v6 = sub_1001EEE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001ABC0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100A0A70[v2 / 4];
        v8 = *(char **)&off_100A0A74[v2];
        v9 = sub_1001A860(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A0A74[v2],
               off_100A0A70[v2 / 4]);
        v10 = sub_1001EEE0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001ABC0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100A0A6C: using guessed type void *off_100A0A6C;
// 100A0A70: using guessed type char *off_100A0A70[2];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028690) --------------------------------------------------------
char sub_10028690()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_101A7DB8 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1001ABC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1001ABC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1001ABC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1001ABC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001ABC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028890) --------------------------------------------------------
char sub_10028890()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A0AFC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100A0AF9[v2 * 4];
        v4 = byte_100A0AF8[v2 * 4];
        v5 = sub_1001A860(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + dword_100A0AFC[v2])],
               (&off_100A0B00)[v2 * 4]);
        v6 = sub_1001AD00(
               1,
               *(&dword_1009B15C + dword_100A0AFC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001A860(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A0AFC[v2]],
               (&off_100A0B00)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A0AFC: using guessed type int dword_100A0AFC[];
// 100A0B00: using guessed type char *off_100A0B00;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028A10) --------------------------------------------------------
char sub_10028A10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A0D80[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100A0D78[v2 / 8];
        v4 = dbl_100A0D70[v2 / 8];
        v5 = dbl_100A0D68[v2 / 8];
        v6 = sub_1001A860(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A0D84)[v2]);
        v7 = sub_1001B0B0(
               1,
               *(&dword_1009B15C + dword_100A0D80[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A0D80[v2 / 4]],
               (&off_100A0D84)[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A0D68: using guessed type double dbl_100A0D68[];
// 100A0D70: using guessed type double dbl_100A0D70[];
// 100A0D78: using guessed type double dbl_100A0D78[];
// 100A0D80: using guessed type int dword_100A0D80[];
// 100A0D84: using guessed type char *off_100A0D84;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028B90) --------------------------------------------------------
char sub_10028B90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A1994[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100A1990[v2];
        v4 = flt_100A198C[v2];
        v5 = flt_100A1988[v2];
        v6 = sub_1001A860(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A1998[v2 * 4]);
        v7 = sub_1001B500(
               1,
               *(&dword_1009B15C + dword_100A1994[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A1994[v2]],
               *(_DWORD *)&off_100A1998[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A1988: using guessed type float flt_100A1988[];
// 100A198C: using guessed type float flt_100A198C[];
// 100A1990: using guessed type float flt_100A1990[];
// 100A1994: using guessed type int dword_100A1994[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028D00) --------------------------------------------------------
char sub_10028D00()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A7DB8 )
  {
    sub_1001F1E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10028D00,
      (int)sub_10028D00,
      0);
    sub_1001F1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10028D00,
      0,
      0);
    result = sub_1001F1E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10028D00,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028DF0) --------------------------------------------------------
char sub_10028DF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A212C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A2128[v2];
        v4 = dword_100A2124[v2];
        v5 = dword_100A2120[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A2130)[v2 * 4]);
        v7 = sub_1001B9C0(
               1,
               *(&dword_1009B15C + dword_100A212C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A212C[v2]],
               (&off_100A2130)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A2120: using guessed type int dword_100A2120[];
// 100A2124: using guessed type int dword_100A2124[];
// 100A2128: using guessed type int dword_100A2128[];
// 100A212C: using guessed type int dword_100A212C[];
// 100A2130: using guessed type char *off_100A2130;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10028F50) --------------------------------------------------------
char sub_10028F50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A28C0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A28BC[v2 / 2];
        v4 = word_100A28BA[v2 / 2];
        v5 = word_100A28B8[v2 / 2];
        v6 = sub_1001A860(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A28C4)[v2]);
        v7 = sub_1001BD80(
               1,
               *(&dword_1009B15C + dword_100A28C0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A28C0[v2 / 4]],
               (&off_100A28C4)[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A28B8: using guessed type __int16 word_100A28B8[];
// 100A28BA: using guessed type __int16 word_100A28BA[];
// 100A28BC: using guessed type __int16 word_100A28BC[];
// 100A28C0: using guessed type int dword_100A28C0[];
// 100A28C4: using guessed type char *off_100A28C4;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100290B0) --------------------------------------------------------
char sub_100290B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A2ED4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A2ED0[v2];
        v4 = dword_100A2ECC[v2];
        v5 = dword_100A2EC8[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A2ED8[v2 * 4]);
        v7 = sub_1001C180(
               1,
               *(&dword_1009B15C + dword_100A2ED4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A2ED4[v2]],
               *(_DWORD *)&off_100A2ED8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A2EC8: using guessed type int dword_100A2EC8[];
// 100A2ECC: using guessed type int dword_100A2ECC[];
// 100A2ED0: using guessed type int dword_100A2ED0[];
// 100A2ED4: using guessed type int dword_100A2ED4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029210) --------------------------------------------------------
char sub_10029210()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A3678[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A3674[v2];
        LODWORD(v3) = dword_100A3670[v2];
        HIDWORD(v4) = dword_100A366C[v2];
        LODWORD(v4) = dword_100A3668[v2];
        HIDWORD(v5) = dword_100A3664[v2];
        LODWORD(v5) = dword_100A3660[v2];
        v6 = sub_1001A860(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A367C[v2 * 4]);
        v7 = sub_1001C540(
               1,
               *(&dword_1009B15C + dword_100A3678[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A3678[v2]],
               *(_DWORD *)&off_100A367C[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A3660: using guessed type int dword_100A3660[];
// 100A3664: using guessed type int dword_100A3664[];
// 100A3668: using guessed type int dword_100A3668[];
// 100A366C: using guessed type int dword_100A366C[];
// 100A3670: using guessed type int dword_100A3670[];
// 100A3674: using guessed type int dword_100A3674[];
// 100A3678: using guessed type int dword_100A3678[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029380) --------------------------------------------------------
char sub_10029380()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A4284[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A4282[v2 * 4];
        v4 = byte_100A4281[v2 * 4];
        v5 = byte_100A4280[v2 * 4];
        v6 = sub_1001A860(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A4288)[v2 * 4]);
        v7 = sub_1001CA80(
               1,
               *(&dword_1009B15C + dword_100A4284[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A4284[v2]],
               (&off_100A4288)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4284: using guessed type int dword_100A4284[];
// 100A4288: using guessed type char *off_100A4288;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100294E0) --------------------------------------------------------
char sub_100294E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A471C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A4718[v2];
        v4 = dword_100A4714[v2];
        v5 = dword_100A4710[v2];
        v6 = sub_1001A860(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A4720)[v2 * 4]);
        v7 = sub_1001CE60(
               1,
               *(&dword_1009B15C + dword_100A471C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A471C[v2]],
               (&off_100A4720)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4710: using guessed type int dword_100A4710[];
// 100A4714: using guessed type int dword_100A4714[];
// 100A4718: using guessed type int dword_100A4718[];
// 100A471C: using guessed type int dword_100A471C[];
// 100A4720: using guessed type char *off_100A4720;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029640) --------------------------------------------------------
char sub_10029640()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A7DB8 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1001F290(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1001F290(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100561E1,
           "a",
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1001F290(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100561E1,
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1001F290(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1001ABC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029840) --------------------------------------------------------
char sub_10029840()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A4EB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A4EB0[v2];
        v4 = dword_100A4EAC[v2];
        v5 = dword_100A4EA8[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A4EB8[v2 * 4]);
        v7 = sub_1001D220(
               1,
               *(&dword_1009B15C + dword_100A4EB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A4EB4[v2]],
               *(_DWORD *)&off_100A4EB8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4EA8: using guessed type int dword_100A4EA8[];
// 100A4EAC: using guessed type int dword_100A4EAC[];
// 100A4EB0: using guessed type int dword_100A4EB0[];
// 100A4EB4: using guessed type int dword_100A4EB4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (100299A0) --------------------------------------------------------
char sub_100299A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5220[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A521C[v2 / 2];
        v4 = word_100A521A[v2 / 2];
        v5 = word_100A5218[v2 / 2];
        v6 = sub_1001A860(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A5224)[v2]);
        v7 = sub_1001D5C0(
               1,
               *(&dword_1009B15C + dword_100A5220[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A5220[v2 / 4]],
               (&off_100A5224)[v2]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5218: using guessed type __int16 word_100A5218[];
// 100A521A: using guessed type __int16 word_100A521A[];
// 100A521C: using guessed type __int16 word_100A521C[];
// 100A5220: using guessed type int dword_100A5220[];
// 100A5224: using guessed type char *off_100A5224;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029B00) --------------------------------------------------------
char sub_10029B00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A54E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A54E0[v2];
        v4 = dword_100A54DC[v2];
        v5 = dword_100A54D8[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A54E8[v2 * 4]);
        v7 = sub_1001D9C0(
               1,
               *(&dword_1009B15C + dword_100A54E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A54E4[v2]],
               *(_DWORD *)&off_100A54E8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A54D8: using guessed type int dword_100A54D8[];
// 100A54DC: using guessed type int dword_100A54DC[];
// 100A54E0: using guessed type int dword_100A54E0[];
// 100A54E4: using guessed type int dword_100A54E4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029C60) --------------------------------------------------------
char sub_10029C60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5860[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A585C[v2];
        LODWORD(v3) = dword_100A5858[v2];
        HIDWORD(v4) = dword_100A5854[v2];
        LODWORD(v4) = dword_100A5850[v2];
        HIDWORD(v5) = dword_100A584C[v2];
        LODWORD(v5) = dword_100A5848[v2];
        v6 = sub_1001A860(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A5864)[v2 * 4]);
        v7 = sub_1001DD60(
               1,
               *(&dword_1009B15C + dword_100A5860[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A5860[v2]],
               (&off_100A5864)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5848: using guessed type int dword_100A5848[];
// 100A584C: using guessed type int dword_100A584C[];
// 100A5850: using guessed type int dword_100A5850[];
// 100A5854: using guessed type int dword_100A5854[];
// 100A5858: using guessed type int dword_100A5858[];
// 100A585C: using guessed type int dword_100A585C[];
// 100A5860: using guessed type int dword_100A5860[];
// 100A5864: using guessed type char *off_100A5864;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029DD0) --------------------------------------------------------
char sub_10029DD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5DCC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A5DCA[v2 * 4];
        v4 = byte_100A5DC9[v2 * 4];
        v5 = byte_100A5DC8[v2 * 4];
        v6 = sub_1001A860(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               (&off_100A5DD0)[v2 * 4]);
        v7 = sub_1001E340(
               1,
               *(&dword_1009B15C + dword_100A5DCC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A5DCC[v2]],
               (&off_100A5DD0)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5DCC: using guessed type int dword_100A5DCC[];
// 100A5DD0: using guessed type char *off_100A5DD0;
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (10029F30) --------------------------------------------------------
char sub_10029F30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A7DB8 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5FE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A5FE0[v2];
        v4 = dword_100A5FDC[v2];
        v5 = dword_100A5FD8[v2];
        v6 = sub_1001A860(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * *(&dword_1009B15C + v0)],
               *(_DWORD *)&off_100A5FE8[v2 * 4]);
        v7 = sub_1001E730(
               1,
               *(&dword_1009B15C + dword_100A5FE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001A860(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A5FE4[v2]],
               *(_DWORD *)&off_100A5FE8[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5FD8: using guessed type int dword_100A5FD8[];
// 100A5FDC: using guessed type int dword_100A5FDC[];
// 100A5FE0: using guessed type int dword_100A5FE0[];
// 100A5FE4: using guessed type int dword_100A5FE4[];
// 101A7DB8: using guessed type char byte_101A7DB8;

//----- (1002A090) --------------------------------------------------------
char sub_1002A090()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_101A7DB9 )
  {
    sub_1001F290(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10019E00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1001B9C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10018860() )
      v1 = 3;
    sub_1001B9C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10018860();
    sub_1001B9C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10019E00(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1001B9C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002A630) --------------------------------------------------------
char sub_1002A630()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A7DB9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100A634C + v2) )
      {
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A6354[v2], 0x100u, &v13);
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100A634C + v2), 0x100u, &v14);
        sub_10025300(&v14, &v13);
      }
      if ( byte_100A6348[v2] )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_100A6350 + v2);
        v4 = *(char **)&off_100A6354[v2];
        v5 = sub_1001A860(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A6354[v2],
               *(void **)((char *)&off_100A6350 + v2));
        v12 = 1;
        v11 = sub_1001EEE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_100A6350 + v2);
        v7 = *(char **)&off_100A6354[v2];
        v8 = sub_1001A860(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A6354[v2],
               *(void **)((char *)&off_100A6350 + v2));
        v12 = 1;
        v11 = sub_1001EEE0(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A634C: using guessed type void *off_100A634C;
// 100A6350: using guessed type void *off_100A6350;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002A840) --------------------------------------------------------
char sub_1002A840()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A7DB9 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1001ABC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1001ABC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1001ABC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1001ABC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001ABC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002AA30) --------------------------------------------------------
char sub_1002AA30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100A639C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100A6399[v2 * 4];
        v4 = byte_100A6398[v2 * 4];
        v5 = sub_1001A860(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * dword_100A639C[v2]],
               (&off_100A63A0)[v2 * 4]);
        v6 = sub_1001AD00(0, dword_100A639C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1001A860(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100A639C[v2]],
               (&off_100A63A0)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100A639C: using guessed type int dword_100A639C[];
// 100A63A0: using guessed type char *off_100A63A0;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002ABA0) --------------------------------------------------------
char sub_1002ABA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100A6618[v2 / 2];
      v4 = dbl_100A6610[v2 / 2];
      v5 = dbl_100A6608[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A6620[v2]],
             (&off_100A6624)[v2 * 4]);
      v7 = sub_1001B0B0(0, dword_100A6620[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A6620[v2]],
             (&off_100A6624)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A6608: using guessed type double dbl_100A6608[];
// 100A6610: using guessed type double dbl_100A6610[];
// 100A6618: using guessed type double dbl_100A6618[];
// 100A6620: using guessed type int dword_100A6620[];
// 100A6624: using guessed type char *off_100A6624;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002AD10) --------------------------------------------------------
char sub_1002AD10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100A7230[v2];
      v4 = flt_100A722C[v2];
      v5 = flt_100A7228[v2];
      v6 = sub_1001A860(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A7234[v2]],
             *(_DWORD *)&off_100A7238[v2 * 4]);
      v7 = sub_1001B500(0, dword_100A7234[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A7234[v2]],
             *(_DWORD *)&off_100A7238[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A7228: using guessed type float flt_100A7228[];
// 100A722C: using guessed type float flt_100A722C[];
// 100A7230: using guessed type float flt_100A7230[];
// 100A7234: using guessed type int dword_100A7234[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002AE70) --------------------------------------------------------
char sub_1002AE70()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A7DB9 )
  {
    sub_1001F1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1002AE70,
      (int)sub_1002AE70,
      0);
    sub_1001F1E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1002AE70,
      0,
      0);
    result = sub_1001F1E0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1002AE70,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002AF60) --------------------------------------------------------
char sub_1002AF60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100A79C8[v2];
      v4 = dword_100A79C4[v2];
      v5 = dword_100A79C0[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A79CC[v2]],
             (&off_100A79D0)[v2 * 4]);
      v7 = sub_1001B9C0(0, dword_100A79CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A79CC[v2]],
             (&off_100A79D0)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A79C0: using guessed type int dword_100A79C0[];
// 100A79C4: using guessed type int dword_100A79C4[];
// 100A79C8: using guessed type int dword_100A79C8[];
// 100A79CC: using guessed type int dword_100A79CC[];
// 100A79D0: using guessed type char *off_100A79D0;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B0C0) --------------------------------------------------------
char sub_1002B0C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100A815C[v2 / 2];
      v4 = word_100A815A[v2 / 2];
      v5 = word_100A8158[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A8160[v2 / 4]],
             (&off_100A8164)[v2]);
      v7 = sub_1001BD80(
             0,
             dword_100A8160[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A8160[v2 / 4]],
             (&off_100A8164)[v2]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8158: using guessed type __int16 word_100A8158[];
// 100A815A: using guessed type __int16 word_100A815A[];
// 100A815C: using guessed type __int16 word_100A815C[];
// 100A8160: using guessed type int dword_100A8160[];
// 100A8164: using guessed type char *off_100A8164;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B220) --------------------------------------------------------
char sub_1002B220()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100A8770[v2];
      v4 = dword_100A876C[v2];
      v5 = dword_100A8768[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A8774[v2]],
             *(_DWORD *)&off_100A8778[v2 * 4]);
      v7 = sub_1001C180(0, dword_100A8774[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A8774[v2]],
             *(_DWORD *)&off_100A8778[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8768: using guessed type int dword_100A8768[];
// 100A876C: using guessed type int dword_100A876C[];
// 100A8770: using guessed type int dword_100A8770[];
// 100A8774: using guessed type int dword_100A8774[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B380) --------------------------------------------------------
char sub_1002B380()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100A8F14[v2];
      LODWORD(v3) = dword_100A8F10[v2];
      HIDWORD(v4) = dword_100A8F0C[v2];
      LODWORD(v4) = dword_100A8F08[v2];
      HIDWORD(v5) = dword_100A8F04[v2];
      LODWORD(v5) = dword_100A8F00[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A8F18[v2]],
             *(_DWORD *)&off_100A8F1C[v2 * 4]);
      v7 = sub_1001C540(0, dword_100A8F18[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A8F18[v2]],
             *(_DWORD *)&off_100A8F1C[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8F00: using guessed type int dword_100A8F00[];
// 100A8F04: using guessed type int dword_100A8F04[];
// 100A8F08: using guessed type int dword_100A8F08[];
// 100A8F0C: using guessed type int dword_100A8F0C[];
// 100A8F10: using guessed type int dword_100A8F10[];
// 100A8F14: using guessed type int dword_100A8F14[];
// 100A8F18: using guessed type int dword_100A8F18[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B4F0) --------------------------------------------------------
char sub_1002B4F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100A9B22[v2 * 4];
      v4 = byte_100A9B21[v2 * 4];
      v5 = byte_100A9B20[v2 * 4];
      v6 = sub_1001A860(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A9B24[v2]],
             (&off_100A9B28)[v2 * 4]);
      v7 = sub_1001CA80(0, dword_100A9B24[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A9B24[v2]],
             (&off_100A9B28)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9B24: using guessed type int dword_100A9B24[];
// 100A9B28: using guessed type char *off_100A9B28;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B650) --------------------------------------------------------
char sub_1002B650()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100A9FB8[v2];
      v4 = dword_100A9FB4[v2];
      v5 = dword_100A9FB0[v2];
      v6 = sub_1001A860(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100A9FBC[v2]],
             (&off_100A9FC0)[v2 * 4]);
      v7 = sub_1001CE60(0, dword_100A9FBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100A9FBC[v2]],
             (&off_100A9FC0)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9FB0: using guessed type int dword_100A9FB0[];
// 100A9FB4: using guessed type int dword_100A9FB4[];
// 100A9FB8: using guessed type int dword_100A9FB8[];
// 100A9FBC: using guessed type int dword_100A9FBC[];
// 100A9FC0: using guessed type char *off_100A9FC0;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B7B0) --------------------------------------------------------
char sub_1002B7B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A7DB9 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1001F290(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100561E1,
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1001F290(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1001F290(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1001F290(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001ABC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002B9B0) --------------------------------------------------------
char sub_1002B9B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100AA750[v2];
      v4 = dword_100AA74C[v2];
      v5 = dword_100AA748[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AA754[v2]],
             *(_DWORD *)&off_100AA758[v2 * 4]);
      v7 = sub_1001D220(0, dword_100AA754[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AA754[v2]],
             *(_DWORD *)&off_100AA758[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA748: using guessed type int dword_100AA748[];
// 100AA74C: using guessed type int dword_100AA74C[];
// 100AA750: using guessed type int dword_100AA750[];
// 100AA754: using guessed type int dword_100AA754[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002BB10) --------------------------------------------------------
char sub_1002BB10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100AAABC[v2 / 2];
      v4 = word_100AAABA[v2 / 2];
      v5 = word_100AAAB8[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AAAC0[v2 / 4]],
             (&off_100AAAC4)[v2]);
      v7 = sub_1001D5C0(
             0,
             dword_100AAAC0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AAAC0[v2 / 4]],
             (&off_100AAAC4)[v2]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AAAB8: using guessed type __int16 word_100AAAB8[];
// 100AAABA: using guessed type __int16 word_100AAABA[];
// 100AAABC: using guessed type __int16 word_100AAABC[];
// 100AAAC0: using guessed type int dword_100AAAC0[];
// 100AAAC4: using guessed type char *off_100AAAC4;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002BC70) --------------------------------------------------------
char sub_1002BC70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100AAD80[v2];
      v4 = dword_100AAD7C[v2];
      v5 = dword_100AAD78[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AAD84[v2]],
             *(_DWORD *)&off_100AAD88[v2 * 4]);
      v7 = sub_1001D9C0(0, dword_100AAD84[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AAD84[v2]],
             *(_DWORD *)&off_100AAD88[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AAD78: using guessed type int dword_100AAD78[];
// 100AAD7C: using guessed type int dword_100AAD7C[];
// 100AAD80: using guessed type int dword_100AAD80[];
// 100AAD84: using guessed type int dword_100AAD84[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002BDD0) --------------------------------------------------------
char sub_1002BDD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100AB0FC[v2];
      LODWORD(v3) = dword_100AB0F8[v2];
      HIDWORD(v4) = dword_100AB0F4[v2];
      LODWORD(v4) = dword_100AB0F0[v2];
      HIDWORD(v5) = dword_100AB0EC[v2];
      LODWORD(v5) = dword_100AB0E8[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AB100[v2]],
             (&off_100AB104)[v2 * 4]);
      v7 = sub_1001DD60(0, dword_100AB100[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AB100[v2]],
             (&off_100AB104)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB0E8: using guessed type int dword_100AB0E8[];
// 100AB0EC: using guessed type int dword_100AB0EC[];
// 100AB0F0: using guessed type int dword_100AB0F0[];
// 100AB0F4: using guessed type int dword_100AB0F4[];
// 100AB0F8: using guessed type int dword_100AB0F8[];
// 100AB0FC: using guessed type int dword_100AB0FC[];
// 100AB100: using guessed type int dword_100AB100[];
// 100AB104: using guessed type char *off_100AB104;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002BF40) --------------------------------------------------------
char sub_1002BF40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100AB66A[v2 * 4];
      v4 = byte_100AB669[v2 * 4];
      v5 = byte_100AB668[v2 * 4];
      v6 = sub_1001A860(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AB66C[v2]],
             (&off_100AB670)[v2 * 4]);
      v7 = sub_1001E340(0, dword_100AB66C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AB66C[v2]],
             (&off_100AB670)[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB66C: using guessed type int dword_100AB66C[];
// 100AB670: using guessed type char *off_100AB670;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C0A0) --------------------------------------------------------
char sub_1002C0A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100AB880[v2];
      v4 = dword_100AB87C[v2];
      v5 = dword_100AB878[v2];
      v6 = sub_1001A860(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AB884[v2]],
             *(_DWORD *)&off_100AB888[v2 * 4]);
      v7 = sub_1001E730(0, dword_100AB884[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AB884[v2]],
             *(_DWORD *)&off_100AB888[v2 * 4]);
      result = sub_1001ABC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB878: using guessed type int dword_100AB878[];
// 100AB87C: using guessed type int dword_100AB87C[];
// 100AB880: using guessed type int dword_100AB880[];
// 100AB884: using guessed type int dword_100AB884[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C200) --------------------------------------------------------
char sub_1002C200()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A7DB9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100ABBEC + v2) )
      {
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100ABBF4[v2], 0x100u, &v13);
        sub_1001A5C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100ABBEC + v2), 0x100u, &v14);
        sub_10025300(&v14, &v13);
      }
      if ( byte_100ABBE8[v2] )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_100ABBF0 + v2);
        v4 = *(char **)&off_100ABBF4[v2];
        v5 = sub_1001A860(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100ABBF4[v2],
               *(void **)((char *)&off_100ABBF0 + v2));
        v12 = 1;
        v11 = sub_1001EEE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_100ABBF0 + v2);
        v7 = *(char **)&off_100ABBF4[v2];
        v8 = sub_1001A860(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100ABBF4[v2],
               *(void **)((char *)&off_100ABBF0 + v2));
        v12 = 1;
        v11 = sub_1001EEE0(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100ABBEC: using guessed type void *off_100ABBEC;
// 100ABBF0: using guessed type void *off_100ABBF0;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C410) --------------------------------------------------------
char sub_1002C410()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A7DB9 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1001ABC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1001ABC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1001ABC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1001ABC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001ABC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C600) --------------------------------------------------------
char sub_1002C600()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      v0 = dword_100ABC3C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100ABC39[v2 * 4];
        v4 = byte_100ABC38[v2 * 4];
        v5 = sub_1001A860(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1009B140[4 * dword_100ABC3C[v2]],
               (&off_100ABC40)[v2 * 4]);
        v6 = sub_1001AD00(1, dword_100ABC3C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1001A860(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1009B140[4 * dword_100ABC3C[v2]],
               (&off_100ABC40)[v2 * 4]);
        LOBYTE(v0) = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019E00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100ABC3C: using guessed type int dword_100ABC3C[];
// 100ABC40: using guessed type char *off_100ABC40;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C770) --------------------------------------------------------
char sub_1002C770()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100ABEB8[v2 / 2];
      v4 = dbl_100ABEB0[v2 / 2];
      v5 = dbl_100ABEA8[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100ABEC0[v2]],
             (&off_100ABEC4)[v2 * 4]);
      v7 = sub_1001B0B0(1, dword_100ABEC0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100ABEC0[v2]],
             (&off_100ABEC4)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100ABEA8: using guessed type double dbl_100ABEA8[];
// 100ABEB0: using guessed type double dbl_100ABEB0[];
// 100ABEB8: using guessed type double dbl_100ABEB8[];
// 100ABEC0: using guessed type int dword_100ABEC0[];
// 100ABEC4: using guessed type char *off_100ABEC4;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002C8E0) --------------------------------------------------------
char sub_1002C8E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100ACAD0[v2];
      v4 = flt_100ACACC[v2];
      v5 = flt_100ACAC8[v2];
      v6 = sub_1001A860(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100ACAD4[v2]],
             *(_DWORD *)&off_100ACAD8[v2 * 4]);
      v7 = sub_1001B500(1, dword_100ACAD4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100ACAD4[v2]],
             *(_DWORD *)&off_100ACAD8[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100ACAC8: using guessed type float flt_100ACAC8[];
// 100ACACC: using guessed type float flt_100ACACC[];
// 100ACAD0: using guessed type float flt_100ACAD0[];
// 100ACAD4: using guessed type int dword_100ACAD4[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002CA40) --------------------------------------------------------
char sub_1002CA40()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A7DB9 )
  {
    sub_1001F1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1002CA40,
      (int)sub_1002CA40,
      0);
    sub_1001F1E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1002CA40,
      0,
      0);
    result = sub_1001F1E0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1002CA40,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002CB30) --------------------------------------------------------
char sub_1002CB30()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100AD268[v2];
      v4 = dword_100AD264[v2];
      v5 = dword_100AD260[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AD26C[v2]],
             (&off_100AD270)[v2 * 4]);
      v7 = sub_1001B9C0(1, dword_100AD26C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AD26C[v2]],
             (&off_100AD270)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AD260: using guessed type int dword_100AD260[];
// 100AD264: using guessed type int dword_100AD264[];
// 100AD268: using guessed type int dword_100AD268[];
// 100AD26C: using guessed type int dword_100AD26C[];
// 100AD270: using guessed type char *off_100AD270;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002CC90) --------------------------------------------------------
char sub_1002CC90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100AD9FC[v2 / 2];
      v4 = word_100AD9FA[v2 / 2];
      v5 = word_100AD9F8[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100ADA00[v2 / 4]],
             (&off_100ADA04)[v2]);
      v7 = sub_1001BD80(
             1,
             dword_100ADA00[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100ADA00[v2 / 4]],
             (&off_100ADA04)[v2]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AD9F8: using guessed type __int16 word_100AD9F8[];
// 100AD9FA: using guessed type __int16 word_100AD9FA[];
// 100AD9FC: using guessed type __int16 word_100AD9FC[];
// 100ADA00: using guessed type int dword_100ADA00[];
// 100ADA04: using guessed type char *off_100ADA04;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002CDF0) --------------------------------------------------------
char sub_1002CDF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100AE010[v2];
      v4 = dword_100AE00C[v2];
      v5 = dword_100AE008[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AE014[v2]],
             *(_DWORD *)&off_100AE018[v2 * 4]);
      v7 = sub_1001C180(1, dword_100AE014[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AE014[v2]],
             *(_DWORD *)&off_100AE018[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AE008: using guessed type int dword_100AE008[];
// 100AE00C: using guessed type int dword_100AE00C[];
// 100AE010: using guessed type int dword_100AE010[];
// 100AE014: using guessed type int dword_100AE014[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002CF50) --------------------------------------------------------
char sub_1002CF50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100AE7B4[v2];
      LODWORD(v3) = dword_100AE7B0[v2];
      HIDWORD(v4) = dword_100AE7AC[v2];
      LODWORD(v4) = dword_100AE7A8[v2];
      HIDWORD(v5) = dword_100AE7A4[v2];
      LODWORD(v5) = dword_100AE7A0[v2];
      v6 = sub_1001A860(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AE7B8[v2]],
             *(_DWORD *)&off_100AE7BC[v2 * 4]);
      v7 = sub_1001C540(1, dword_100AE7B8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AE7B8[v2]],
             *(_DWORD *)&off_100AE7BC[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AE7A0: using guessed type int dword_100AE7A0[];
// 100AE7A4: using guessed type int dword_100AE7A4[];
// 100AE7A8: using guessed type int dword_100AE7A8[];
// 100AE7AC: using guessed type int dword_100AE7AC[];
// 100AE7B0: using guessed type int dword_100AE7B0[];
// 100AE7B4: using guessed type int dword_100AE7B4[];
// 100AE7B8: using guessed type int dword_100AE7B8[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D0C0) --------------------------------------------------------
char sub_1002D0C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100AF3C2[v2 * 4];
      v4 = byte_100AF3C1[v2 * 4];
      v5 = byte_100AF3C0[v2 * 4];
      v6 = sub_1001A860(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AF3C4[v2]],
             (&off_100AF3C8)[v2 * 4]);
      v7 = sub_1001CA80(1, dword_100AF3C4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AF3C4[v2]],
             (&off_100AF3C8)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AF3C4: using guessed type int dword_100AF3C4[];
// 100AF3C8: using guessed type char *off_100AF3C8;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D220) --------------------------------------------------------
char sub_1002D220()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100AF858[v2];
      v4 = dword_100AF854[v2];
      v5 = dword_100AF850[v2];
      v6 = sub_1001A860(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AF85C[v2]],
             (&off_100AF860)[v2 * 4]);
      v7 = sub_1001CE60(1, dword_100AF85C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AF85C[v2]],
             (&off_100AF860)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AF850: using guessed type int dword_100AF850[];
// 100AF854: using guessed type int dword_100AF854[];
// 100AF858: using guessed type int dword_100AF858[];
// 100AF85C: using guessed type int dword_100AF85C[];
// 100AF860: using guessed type char *off_100AF860;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D380) --------------------------------------------------------
char sub_1002D380()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019E00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001A750(0);
  sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10019E00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A7DB9 )
  {
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1001F290(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100561E1,
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1001F290(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1001F290(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100561E1,
           0);
    sub_1001ABC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1001F290(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001ABC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D580) --------------------------------------------------------
char sub_1002D580()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100AFFF0[v2];
      v4 = dword_100AFFEC[v2];
      v5 = dword_100AFFE8[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100AFFF4[v2]],
             *(_DWORD *)&off_100AFFF8[v2 * 4]);
      v7 = sub_1001D220(1, dword_100AFFF4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100AFFF4[v2]],
             *(_DWORD *)&off_100AFFF8[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AFFE8: using guessed type int dword_100AFFE8[];
// 100AFFEC: using guessed type int dword_100AFFEC[];
// 100AFFF0: using guessed type int dword_100AFFF0[];
// 100AFFF4: using guessed type int dword_100AFFF4[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D6E0) --------------------------------------------------------
char sub_1002D6E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100B035C[v2 / 2];
      v4 = word_100B035A[v2 / 2];
      v5 = word_100B0358[v2 / 2];
      v6 = sub_1001A860(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100B0360[v2 / 4]],
             (&off_100B0364)[v2]);
      v7 = sub_1001D5C0(
             1,
             dword_100B0360[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100B0360[v2 / 4]],
             (&off_100B0364)[v2]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B0358: using guessed type __int16 word_100B0358[];
// 100B035A: using guessed type __int16 word_100B035A[];
// 100B035C: using guessed type __int16 word_100B035C[];
// 100B0360: using guessed type int dword_100B0360[];
// 100B0364: using guessed type char *off_100B0364;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D840) --------------------------------------------------------
char sub_1002D840()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100B0620[v2];
      v4 = dword_100B061C[v2];
      v5 = dword_100B0618[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100B0624[v2]],
             *(_DWORD *)&off_100B0628[v2 * 4]);
      v7 = sub_1001D9C0(1, dword_100B0624[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100B0624[v2]],
             *(_DWORD *)&off_100B0628[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B0618: using guessed type int dword_100B0618[];
// 100B061C: using guessed type int dword_100B061C[];
// 100B0620: using guessed type int dword_100B0620[];
// 100B0624: using guessed type int dword_100B0624[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002D9A0) --------------------------------------------------------
char sub_1002D9A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100B099C[v2];
      LODWORD(v3) = dword_100B0998[v2];
      HIDWORD(v4) = dword_100B0994[v2];
      LODWORD(v4) = dword_100B0990[v2];
      HIDWORD(v5) = dword_100B098C[v2];
      LODWORD(v5) = dword_100B0988[v2];
      v6 = sub_1001A860(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100B09A0[v2]],
             (&off_100B09A4)[v2 * 4]);
      v7 = sub_1001DD60(1, dword_100B09A0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100B09A0[v2]],
             (&off_100B09A4)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B0988: using guessed type int dword_100B0988[];
// 100B098C: using guessed type int dword_100B098C[];
// 100B0990: using guessed type int dword_100B0990[];
// 100B0994: using guessed type int dword_100B0994[];
// 100B0998: using guessed type int dword_100B0998[];
// 100B099C: using guessed type int dword_100B099C[];
// 100B09A0: using guessed type int dword_100B09A0[];
// 100B09A4: using guessed type char *off_100B09A4;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002DB10) --------------------------------------------------------
char sub_1002DB10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100B0F0A[v2 * 4];
      v4 = byte_100B0F09[v2 * 4];
      v5 = byte_100B0F08[v2 * 4];
      v6 = sub_1001A860(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100B0F0C[v2]],
             (&off_100B0F10)[v2 * 4]);
      v7 = sub_1001E340(1, dword_100B0F0C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100B0F0C[v2]],
             (&off_100B0F10)[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B0F0C: using guessed type int dword_100B0F0C[];
// 100B0F10: using guessed type char *off_100B0F10;
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002DC70) --------------------------------------------------------
char sub_1002DC70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A7DB9 )
  {
    sub_10019E00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001A750(0);
    sub_10019E00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10019E00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001A840(0);
    v2 = 0;
    do
    {
      sub_1001A770((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100B1120[v2];
      v4 = dword_100B111C[v2];
      v5 = dword_100B1118[v2];
      v6 = sub_1001A860(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1009B140[4 * dword_100B1124[v2]],
             *(_DWORD *)&off_100B1128[v2 * 4]);
      v7 = sub_1001E730(1, dword_100B1124[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001A860(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1009B140[4 * dword_100B1124[v2]],
             *(_DWORD *)&off_100B1128[v2 * 4]);
      result = sub_1001ABC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019E00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B1118: using guessed type int dword_100B1118[];
// 100B111C: using guessed type int dword_100B111C[];
// 100B1120: using guessed type int dword_100B1120[];
// 100B1124: using guessed type int dword_100B1124[];
// 101A7DB9: using guessed type char byte_101A7DB9;

//----- (1002DDD0) --------------------------------------------------------
char **sub_1002DDD0()
{
  return off_1009C82C;
}
// 1009C82C: using guessed type char *off_1009C82C[3];

//----- (1002DDE0) --------------------------------------------------------
int __cdecl sub_1002DDE0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1002DE00) --------------------------------------------------------
int (__cdecl *__usercall sub_1002DE00@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1002DE10) --------------------------------------------------------
int __usercall sub_1002DE10@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1002E040) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E040(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1002DE00(a1, (int)" ");
  sub_1002DE00(a1, a2);
  sub_1002DE00(a1, (int)&unk_100B537C);
  v3 = sub_1002DE10(a3, a1);
  sub_1002DE00(a1, v3);
  return sub_1002DE00(a1, (int)&unk_100B5378);
}

//----- (1002E090) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E090(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1002DE00(a1, (int)" ");
  sub_1002DE00(a1, a2);
  sub_1002DE00(a1, (int)&unk_100B5384);
  v3 = sub_1002DE10(a3, a1);
  sub_1002DE00(a1, v3);
  return sub_1002DE00(a1, (int)&unk_100B5380);
}

//----- (1002E0E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E0E0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1002DE00(a1, (int)&unk_100B5388);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1002DE10(a2, a1);
    result = sub_1002DE00(a1, v3);
  }
  return result;
}

//----- (1002E130) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E130(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100B5390;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1002DE00(a1, dword_100B52E4[(signed int)result]);
      sub_1002DE00(a1, (int)&unk_100B538C);
      sub_1002DE00(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100B5388;
    }
    result = sub_1002DE00(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1002DE00(a1, (int)&word_1008E03C);
  }
  return result;
}
// 1008E03C: using guessed type __int16 word_1008E03C;
// 100B52E4: using guessed type int dword_100B52E4[];

//----- (1002E1B0) --------------------------------------------------------
int __cdecl sub_1002E1B0(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1002DE00(a1, (int)&unk_100B5388);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1002DE00(a1, *((_DWORD *)&off_100B52E8 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1002DE00(a1, (int)&unk_100B5394);
  sub_1002DE00(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1002E230) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E230(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1002DE10(a2, a1);
    sub_1002DE00(a1, v3);
    result = sub_1002DE00(a1, (int)&word_1008E03C);
  }
  else
  {
    sub_1002DE00(a1, (int)a2);
    result = sub_1002DE00(a1, (int)&word_1008E03C);
  }
  return result;
}
// 1008E03C: using guessed type __int16 word_1008E03C;

//----- (1002E280) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E280(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1002E1B0(a1, a2);
  if ( a3 && *a3 )
    sub_1002E0E0(a1, a3);
  return sub_1002E130(a1);
}

//----- (1002E2C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E2C0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1002E280(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1002E320) --------------------------------------------------------
int __cdecl sub_1002E320(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100117D0(&a1, 1u, (int)&unk_100B6E08, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100B6E0C[2 * v1];
  }
  else
  {
    sub_10003C10("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100B6E0C: using guessed type int dword_100B6E0C[];

//----- (1002E370) --------------------------------------------------------
int __cdecl sub_1002E370(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1002E390) --------------------------------------------------------
char __cdecl sub_1002E390(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10015960((int)&v12);
}
// 1002E390: using guessed type char var_518[1300];

//----- (1002E460) --------------------------------------------------------
signed int __cdecl sub_1002E460(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_10053B6C;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 10053B6C: using guessed type int (__cdecl *off_10053B6C)(int);

//----- (1002E490) --------------------------------------------------------
char *__cdecl sub_1002E490(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = (char *)&unk_100561E1;
  else
    result = &aInset[56 * a1];
  return result;
}

//----- (1002E4C0) --------------------------------------------------------
signed int __usercall sub_1002E4C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100B87F8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100B7BF8[2 * (unsigned __int8)v68] ^ dword_100B7FF8[2 * BYTE1(v65)] ^ dword_100B83F8[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100B87F8[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100B87F8[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100B87F8[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100B87F8[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100B87F8[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100B87F8[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100B87F8[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100B87F8[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100B87F8[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100B8BF8[(unsigned __int8)v57] ^ dword_100B97F8[v58 >> 24] ^ dword_100B8FF8[BYTE1(v59)] ^ dword_100B93F8[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100B8BF8[(unsigned __int8)v59] ^ dword_100B93F8[(unsigned __int8)(v58 >> 16)] ^ dword_100B97F8[v57 >> 24] ^ dword_100B8FF8[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100B8BF8[(unsigned __int8)v60] ^ dword_100B8FF8[BYTE1(v58)] ^ dword_100B93F8[(unsigned __int8)(v57 >> 16)] ^ dword_100B97F8[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100B8BF8[(unsigned __int8)v58] ^ dword_100B8FF8[BYTE1(v57)] ^ dword_100B93F8[(unsigned __int8)(v59 >> 16)] ^ dword_100B97F8[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100B87F8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100B87F8[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100B87F8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100B87F8[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100B87F8[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100B7BF8[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100B7FF8[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100B83F8[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100B87F8[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100B8BF8: using guessed type int dword_100B8BF8[];
// 100B8FF8: using guessed type int dword_100B8FF8[];
// 100B93F8: using guessed type int dword_100B93F8[];
// 100B97F8: using guessed type int dword_100B97F8[];

//----- (1002F570) --------------------------------------------------------
int __usercall sub_1002F570@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_1002E4C0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1002F5D0) --------------------------------------------------------
signed int __usercall sub_1002F5D0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100B97F8[(unsigned __int8)v9] ^ dword_100B8BF8[BYTE1(v9)] ^ dword_100B8FF8[(unsigned __int8)(v9 >> 16)] ^ dword_100B93F8[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100B97F8[(unsigned __int8)v129] ^ dword_100B8BF8[BYTE1(v129)] ^ dword_100B8FF8[(unsigned __int8)(v129 >> 16)] ^ dword_100B93F8[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100B97F8[(unsigned __int8)v133] ^ dword_100B8BF8[BYTE1(v133)] ^ dword_100B8FF8[(unsigned __int8)(v133 >> 16)] ^ dword_100B93F8[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100B97F8[(unsigned __int8)v137] ^ dword_100B8BF8[BYTE1(v137)] ^ dword_100B8FF8[(unsigned __int8)(v137 >> 16)] ^ dword_100B93F8[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100B97F8[(unsigned __int8)v141] ^ dword_100B8BF8[BYTE1(v141)] ^ dword_100B8FF8[(unsigned __int8)(v141 >> 16)] ^ dword_100B93F8[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100B97F8[(unsigned __int8)v145] ^ dword_100B8BF8[BYTE1(v145)] ^ dword_100B8FF8[(unsigned __int8)(v145 >> 16)] ^ dword_100B93F8[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100B97F8[(unsigned __int8)v149] ^ dword_100B8BF8[BYTE1(v149)] ^ dword_100B8FF8[(unsigned __int8)(v149 >> 16)] ^ dword_100B93F8[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100B97F8[(unsigned __int8)v153] ^ dword_100B8BF8[BYTE1(v153)] ^ dword_100B8FF8[(unsigned __int8)(v153 >> 16)] ^ dword_100B93F8[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100B97F8[(unsigned __int8)v157] ^ dword_100B8BF8[BYTE1(v157)] ^ dword_100B8FF8[(unsigned __int8)(v157 >> 16)] ^ dword_100B93F8[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100B97F8[(unsigned __int8)v161] ^ dword_100B8BF8[BYTE1(v161)] ^ dword_100B8FF8[(unsigned __int8)(v161 >> 16)] ^ dword_100B93F8[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100B97F8[(unsigned __int8)v77] ^ dword_100B8BF8[BYTE1(v77)] ^ dword_100B8FF8[(unsigned __int8)(v77 >> 16)] ^ dword_100B93F8[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100B97F8[(unsigned __int8)v82] ^ dword_100B8BF8[BYTE1(v82)] ^ dword_100B8FF8[(unsigned __int8)(v82 >> 16)] ^ dword_100B93F8[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100B97F8[(unsigned __int8)v89] ^ dword_100B8BF8[BYTE1(v89)] ^ dword_100B8FF8[(unsigned __int8)(v89 >> 16)] ^ dword_100B93F8[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100B97F8[(unsigned __int8)v94] ^ dword_100B8BF8[BYTE1(v94)] ^ dword_100B8FF8[(unsigned __int8)(v94 >> 16)] ^ dword_100B93F8[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100B97F8[(unsigned __int8)v100] ^ dword_100B8BF8[BYTE1(v100)] ^ dword_100B8FF8[(unsigned __int8)(v100 >> 16)] ^ dword_100B93F8[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100B97F8[(unsigned __int8)v100] ^ dword_100B8BF8[BYTE1(v100)] ^ dword_100B8FF8[(unsigned __int8)(v100 >> 16)] ^ dword_100B93F8[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100B97F8[(unsigned __int8)v108] ^ dword_100B8BF8[BYTE1(v108)] ^ dword_100B8FF8[(unsigned __int8)(v108 >> 16)] ^ dword_100B93F8[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100B97F8[(unsigned __int8)v114] ^ dword_100B8BF8[BYTE1(v114)] ^ dword_100B8FF8[(unsigned __int8)(v114 >> 16)] ^ dword_100B93F8[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100B97F8[(unsigned __int8)v120] ^ dword_100B8BF8[BYTE1(v120)] ^ dword_100B8FF8[(unsigned __int8)(v120 >> 16)] ^ dword_100B93F8[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100B97F8[(unsigned __int8)v19] ^ dword_100B8BF8[BYTE1(v19)] ^ dword_100B8FF8[(unsigned __int8)(v19 >> 16)] ^ dword_100B93F8[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100B8BF8[(unsigned __int8)v23] ^ dword_100B8FF8[BYTE1(v23)] ^ dword_100B93F8[(unsigned __int8)(v23 >> 16)] ^ dword_100B97F8[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100B97F8[(unsigned __int8)v26] ^ dword_100B8BF8[BYTE1(v26)] ^ dword_100B8FF8[(unsigned __int8)(v26 >> 16)] ^ dword_100B93F8[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100B8BF8[(unsigned __int8)v31] ^ dword_100B8FF8[BYTE1(v31)] ^ dword_100B93F8[(unsigned __int8)(v31 >> 16)] ^ dword_100B97F8[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100B97F8[(unsigned __int8)v35] ^ dword_100B8BF8[BYTE1(v35)] ^ dword_100B8FF8[(unsigned __int8)(v35 >> 16)] ^ dword_100B93F8[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100B8BF8[(unsigned __int8)v41] ^ dword_100B8FF8[BYTE1(v41)] ^ dword_100B93F8[(unsigned __int8)(v41 >> 16)] ^ dword_100B97F8[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100B97F8[(unsigned __int8)v43] ^ dword_100B8BF8[BYTE1(v43)] ^ dword_100B8FF8[(unsigned __int8)(v43 >> 16)] ^ dword_100B93F8[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100B8BF8[(unsigned __int8)v47] ^ dword_100B8FF8[BYTE1(v47)] ^ dword_100B93F8[(unsigned __int8)(v47 >> 16)] ^ dword_100B97F8[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100B97F8[(unsigned __int8)v52] ^ dword_100B8BF8[BYTE1(v52)] ^ dword_100B8FF8[(unsigned __int8)(v52 >> 16)] ^ dword_100B93F8[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100B8BF8[(unsigned __int8)v58] ^ dword_100B8FF8[BYTE1(v58)] ^ dword_100B93F8[(unsigned __int8)(v58 >> 16)] ^ dword_100B97F8[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100B97F8[(unsigned __int8)v60] ^ dword_100B8BF8[BYTE1(v60)] ^ dword_100B8FF8[(unsigned __int8)(v60 >> 16)] ^ dword_100B93F8[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100B8BF8[(unsigned __int8)v66] ^ dword_100B8FF8[BYTE1(v66)] ^ dword_100B93F8[(unsigned __int8)(v66 >> 16)] ^ dword_100B97F8[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100B97F8[(unsigned __int8)v69] ^ dword_100B8BF8[BYTE1(v69)] ^ dword_100B8FF8[(unsigned __int8)(v69 >> 16)] ^ dword_100B93F8[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100B8BF8: using guessed type int dword_100B8BF8[];
// 100B8FF8: using guessed type int dword_100B8FF8[];
// 100B93F8: using guessed type int dword_100B93F8[];
// 100B97F8: using guessed type int dword_100B97F8[];

//----- (10030350) --------------------------------------------------------
void *__usercall sub_10030350@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10030370) --------------------------------------------------------
unsigned int __cdecl sub_10030370(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10003DB0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10003E00: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (100303D0) --------------------------------------------------------
int __usercall sub_100303D0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10030410) --------------------------------------------------------
int __usercall sub_10030410@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10031B30) --------------------------------------------------------
unsigned int __usercall sub_10031B30@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100B9C20[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100B9C30[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10030410(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10030410(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100B9C20: using guessed type int dword_100B9C20[];
// 100B9C30: using guessed type int dword_100B9C30[];

//----- (10031C30) --------------------------------------------------------
void *__usercall sub_10031C30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10030410(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10031CB0) --------------------------------------------------------
void *__usercall sub_10031CB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10031B30(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_100303D0(v3 + 64);
    result = sub_10031C30(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10031C30(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10031D50) --------------------------------------------------------
int __usercall sub_10031D50@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10031CB0(a1, 0, 0);
  sub_10031B30(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_100303D0(a1 + 64);
  sub_10031C30(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10031C30(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10031B30(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10031E10) --------------------------------------------------------
int __usercall sub_10031E10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_100303D0(a2 + 64);
    sub_10031C30(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10031C30(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10031E70) --------------------------------------------------------
int __usercall sub_10031E70@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10030410((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10031E70: using guessed type char var_40[64];

//----- (10031F30) --------------------------------------------------------
int __usercall sub_10031F30@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10031E70((char *)a1);
  return sub_10031E70(v8);
}

//----- (10031FF0) --------------------------------------------------------
char __cdecl sub_10031FF0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10031CB0(a3 + 296, a2, a1);
    sub_1002F570(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032040) --------------------------------------------------------
char __cdecl sub_10032040(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1002F570(a3, (int)a1, a2);
    sub_10031CB0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032090) --------------------------------------------------------
bool __cdecl sub_10032090(int a1, int a2)
{
  if ( a2 )
    sub_10031D50(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (100320C0) --------------------------------------------------------
int __usercall sub_100320C0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10030350(&v24);
  sub_10031E10(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10031CB0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10031CB0((int)&v23, v12, (char *)&v31);
          sub_10031D50((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 100320C0: using guessed type char var_14[16];

//----- (100322D0) --------------------------------------------------------
int __usercall sub_100322D0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10031F30(v2);
  v3 = 20;
  do
  {
    sub_10031E70((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10031F30(v2);
}

//----- (10032320) --------------------------------------------------------
char *__cdecl sub_10032320(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10031F30(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100323B0) --------------------------------------------------------
signed int __cdecl sub_100323B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_100320C0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1002F5D0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10030350((void *)(a6 + 296));
      sub_10031E10(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100323B0: using guessed type char var_40[8];
// 100323B0: using guessed type __int16 var_38[26];

//----- (100324E0) --------------------------------------------------------
bool __cdecl sub_100324E0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_100322D0(&v4, (int)sub_10030370);
  if ( v2 )
    sub_10032320(a2, (int)&v4);
  return v2;
}

//----- (10032560) --------------------------------------------------------
BOOL __usercall sub_10032560@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100BA438[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100BA338[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100BA238[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10032600) --------------------------------------------------------
int __usercall sub_10032600@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10032690) --------------------------------------------------------
unsigned int __fastcall sub_10032690(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100326B0) --------------------------------------------------------
int __usercall sub_100326B0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10032740) --------------------------------------------------------
int __usercall sub_10032740@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100BA438[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100BA438[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100B9C40[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100BA538[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100BA338[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100BA238[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100B9CC8[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100BA5B0[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100B9C40: using guessed type int dword_100B9C40[];
// 100B9CC8: using guessed type int dword_100B9CC8[];
// 100BA538: using guessed type int dword_100BA538[];
// 100BA5B0: using guessed type int dword_100BA5B0[];

//----- (10032BC0) --------------------------------------------------------
int __usercall sub_10032BC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100326B0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10032C70) --------------------------------------------------------
void *__usercall sub_10032C70@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10032CD0) --------------------------------------------------------
int __usercall sub_10032CD0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10032EA0) --------------------------------------------------------
signed int __usercall sub_10032EA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10032690(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10032F20) --------------------------------------------------------
_WORD *__fastcall sub_10032F20(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10032F90) --------------------------------------------------------
unsigned int __usercall sub_10032F90@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10033140) --------------------------------------------------------
unsigned int __usercall sub_10033140@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10033210) --------------------------------------------------------
int __usercall sub_10033210@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (100332C0) --------------------------------------------------------
int __usercall sub_100332C0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10033300) --------------------------------------------------------
unsigned int __usercall sub_10033300@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_100350D0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033360) --------------------------------------------------------
signed int __usercall sub_10033360@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10033440) --------------------------------------------------------
int __usercall sub_10033440@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (100339E0) --------------------------------------------------------
int __usercall sub_100339E0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10032600(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10032600(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10032600(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10033C20) --------------------------------------------------------
int __usercall sub_10033C20@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10032BC0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10032BC0(a1, a3, a4);
  }
  return result;
}

//----- (10033CC0) --------------------------------------------------------
signed int __usercall sub_10033CC0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10033210(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10033210(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10033210(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10032CD0(a1, a2);
  return sub_10032EA0(a1, v16, v5);
}

//----- (10033EA0) --------------------------------------------------------
unsigned int __usercall sub_10033EA0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10033300(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10033FE0) --------------------------------------------------------
int __usercall sub_10033FE0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100B9CB4[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10033440(a1, a1 + 2936, a2 - 1);
  return sub_10033440(v24, v24 + 5228, a3 - 1);
}

//----- (10034290) --------------------------------------------------------
signed int __cdecl sub_10034290(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_100332C0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_100332C0(v9, *(_WORD *)(a1 + 30));
      sub_100332C0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_100350D0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10032C70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100BA630 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_100339E0(v2);
    }
    else
    {
      sub_10033C20(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10032C70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_100332C0(v2, *(_WORD *)(a1 + 30));
    sub_100332C0(v13, *(_WORD *)(a1 + 28));
    sub_10032C70(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100BA630: using guessed type int (__cdecl *off_100BA630)(int, int);

//----- (10034550) --------------------------------------------------------
signed int __usercall sub_10034550@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10033360(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10033360(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10033CC0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B9CB4[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B9CB3[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B9CB2[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B9CB1[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10034620) --------------------------------------------------------
_WORD *__usercall sub_10034620@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10033CC0(a2, a2 + 5628);
  sub_10033CC0(v4, v4 + 5640);
  v8 = sub_10034550(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10033C20(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10032740(v4, (int)&unk_100B9D40, (int)&unk_100BA1C0);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10033FE0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10032740(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10032F20(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100326B0(v4);
  return result;
}

//----- (10034840) --------------------------------------------------------
signed int __cdecl sub_10034840(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10033EA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10032F90(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10033140(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10032560(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10032560(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10034620(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10032C70(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10034620(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10032C70(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10034B50) --------------------------------------------------------
signed int __cdecl sub_10034B50(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10033EA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10032F90(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10033140(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10032560(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10034620(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10032C70(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10032560(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10034620(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10032C70(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10032560(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10034620(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10032C70(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10034F60) --------------------------------------------------------
signed int __cdecl sub_10034F60(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10033EA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10034620(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10032C70(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10034620(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10032C70(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10034620(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10032C70(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100350D0) --------------------------------------------------------
int __cdecl sub_100350D0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (100351D0) --------------------------------------------------------
signed int __cdecl sub_100351D0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100351F0) --------------------------------------------------------
signed int __usercall sub_100351F0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 100351F0: using guessed type int var_78[14];
// 100351F0: using guessed type int var_3C[15];

//----- (10035690) --------------------------------------------------------
int (__cdecl *__usercall sub_10035690@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (100356E0) --------------------------------------------------------
int __usercall sub_100356E0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10035700) --------------------------------------------------------
signed int __cdecl sub_10035700(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100BA818[a1];
  v51 = dword_100BA818[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100BA818[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100BA818[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100BA818[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100BA818[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100BA818: using guessed type int dword_100BA818[];

//----- (10035AB0) --------------------------------------------------------
int __usercall sub_10035AB0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10035BF0) --------------------------------------------------------
signed int __usercall sub_10035BF0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_100351F0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10035C40) --------------------------------------------------------
signed int __usercall sub_10035C40@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_100351F0(a7, a6, a4, 257, (int)&unk_100BA8B0, (int)&unk_100BA930, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_100351F0(a8, &a6[a4], a5, 0, (int)&unk_100BA9B0, (int)&unk_100BAA28, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10035CE0) --------------------------------------------------------
int __usercall sub_10035CE0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100BAAA0;
  *a4 = &unk_100BBAA0;
  return 0;
}

//----- (10035D00) --------------------------------------------------------
signed int __cdecl sub_10035D00(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10035690(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10035D10) --------------------------------------------------------
int __usercall sub_10035D10@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10035700(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100BA818[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100BA818[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100BA818[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100BA818[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10035AB0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10035AB0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10035AB0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10035AB0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100BA818: using guessed type int dword_100BA818[];

//----- (100363B0) --------------------------------------------------------
int __usercall sub_100363B0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10035CE0(&v67, &v69, &v66, &v68);
          sub_100356E0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10035AB0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100BA860[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100BA860[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10035BF0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10035C40(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_100356E0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10035D10(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10035AB0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10035AB0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10035AB0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100BA818[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100BA818[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10035AB0(v7, v3, v58);
}
// 100BA818: using guessed type int dword_100BA818[];
// 100BA860: using guessed type int dword_100BA860[];

//----- (10036D90) --------------------------------------------------------
signed int __usercall sub_10036D90@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_100363B0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10035690((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (100370C0) --------------------------------------------------------
signed int __cdecl sub_100370C0(int a1, int a2)
{
  return sub_10036D90(a1, a2);
}

//----- (100370E0) --------------------------------------------------------
char __cdecl sub_100370E0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10014F90(2, 363, a1);
}

//----- (10037100) --------------------------------------------------------
char __cdecl sub_10037100(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_100040C0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10037250) --------------------------------------------------------
bool __thiscall sub_10037250(void *this)
{
  return (sub_10010DE0(this) & 0x8000) == 0x8000;
}

//----- (10037270) --------------------------------------------------------
char __cdecl sub_10037270(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10037100(a5);
      else
        result = sub_100370E0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10037100(&unk_101A7DC8);
      else
        v7 = sub_100370E0(&unk_101A7DC8);
      v8 = v7;
      memcpy(a5, (char *)&unk_101A7DC8 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10037100(&unk_101A7DC8);
      else
        v9 = sub_100370E0(&unk_101A7DC8);
      v10 = v9;
      memcpy(a5, (char *)&unk_101AACD0 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10037100(&unk_101A7DC8);
      else
        v11 = sub_100370E0(&unk_101A7DC8);
      v12 = v11;
      memcpy(a5, (char *)&unk_101AB1D0 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10037100(&unk_101A7DC8);
      else
        v13 = sub_100370E0(&unk_101A7DC8);
      v14 = v13;
      memcpy(a5, &unk_101AB278, a6);
      result = v14;
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10037410) --------------------------------------------------------
bool __cdecl sub_10037410(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_100117D0(&a2, 4u, (int)&dword_100BD8A0, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_100040C0((unsigned __int16)word_100BD8A4[a1 + 6 * v3], a3, (unsigned __int16)word_100BD8A8[6 * v3]) == 0;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100BD8A0: using guessed type int dword_100BD8A0;
// 100BD8A4: using guessed type __int16 word_100BD8A4[];
// 100BD8A8: using guessed type __int16 word_100BD8A8[];

//----- (100374A0) --------------------------------------------------------
bool __cdecl sub_100374A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10037540(a1);
  v6 = sub_100117D0(&a3, 1u, (int)&unk_100BD8C4, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_100117D0(&dword_100BD8C8[2 * v6], 4u, (int)&dword_100BD8A0, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100BD8A8[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10037410(v11, *(int *)((char *)&dword_100BD8A0 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100BD8A0: using guessed type int dword_100BD8A0;
// 100BD8A8: using guessed type __int16 word_100BD8A8[];

//----- (10037540) --------------------------------------------------------
char __cdecl sub_10037540(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (100375C0) --------------------------------------------------------
char __cdecl sub_100375C0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10024200(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_100040C0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10024220((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (10037730) --------------------------------------------------------
int __usercall sub_10037730@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_100375C0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 10037730: using guessed type int var_2C[10];

//----- (10037770) --------------------------------------------------------
int __usercall sub_10037770@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_100375C0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10037770: using guessed type int var_14[4];

//----- (100377B0) --------------------------------------------------------
signed int sub_100377B0()
{
  return sub_1004C930((int)&off_100BF768);
}
// 100BF768: using guessed type char *off_100BF768;

//----- (100377C0) --------------------------------------------------------
char __cdecl sub_100377C0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_100377B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101E29CC + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101E29CC + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101E29CC);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E29CC: using guessed type int dword_101E29CC;

//----- (10037820) --------------------------------------------------------
char __cdecl sub_10037820(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_100377B0() )
  {
    if ( (sub_10024240(a1)
       || *(_BYTE *)(dword_101E29CC + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101E29CC + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101E29CC + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 176))
      && *(_BYTE *)(dword_101E29CC + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101E29CC + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101E29CC + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101E29CC + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E29CC: using guessed type int dword_101E29CC;

//----- (10037940) --------------------------------------------------------
char __cdecl sub_10037940(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_100377B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101E29CC + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101E29CC + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101E29CC + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101E29CC + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101E29CC);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E29CC: using guessed type int dword_101E29CC;

//----- (100379C0) --------------------------------------------------------
char __cdecl sub_100379C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10037770(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10037940(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_10037730(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_100377C0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_100375C0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10037820(v6, a5);
        }
      }
      else
      {
        sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10037B70) --------------------------------------------------------
BOOL __cdecl sub_10037B70(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10037B80) --------------------------------------------------------
BOOL __usercall sub_10037B80@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10037B70(a1) && *v2 < 3u && a2 == 24;
}

//----- (10037BB0) --------------------------------------------------------
bool __cdecl sub_10037BB0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10037B70(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10017750((unsigned __int8)byte_100C0B60[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10014F90(1, (unsigned __int16)word_100C0B58[v6], &Tm.tm_mon) || sub_100171B0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_100244F0(a1, &v15) || v15 != dword_100C0B78[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10014F90(1, (unsigned __int16)word_100C0B5C[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100C0B58: using guessed type __int16 word_100C0B58[];
// 100C0B5C: using guessed type __int16 word_100C0B5C[];
// 100C0B78: using guessed type int dword_100C0B78[];

//----- (10037D60) --------------------------------------------------------
bool __cdecl sub_10037D60(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10037B70(a1) )
    result = sub_100040C0((unsigned __int16)word_100C0B62[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100C0B62: using guessed type __int16 word_100C0B62[];

//----- (10037DA0) --------------------------------------------------------
bool __cdecl sub_10037DA0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10024440(a1);
  if ( !(unsigned __int8)sub_10037B80(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10037BB0(v9, a3, *a4, (int)a5);
  if ( sub_10017750((unsigned __int8)byte_100C0B60[20 * v6], (bool *)&v8) && v8 && sub_10037D60(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10037DA0: using guessed type int var_20[7];

//----- (10037E90) --------------------------------------------------------
int __cdecl sub_10037E90(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100C190C[2 * sub_100117D0(&a1, 1u, (int)&unk_100C1908, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100C194C[2 * sub_100117D0(&a2, 1u, (int)&unk_100C1948, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100C197C[2 * sub_100117D0(&a2, 1u, (int)&unk_100C1978, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100C1924[2 * sub_100117D0(&a2, 1u, (int)&unk_100C1920, 8, 5, 5)];
  }
  return result;
}
// 100C190C: using guessed type int dword_100C190C[];
// 100C1924: using guessed type int dword_100C1924[];
// 100C194C: using guessed type int dword_100C194C[];
// 100C197C: using guessed type int dword_100C197C[];

//----- (10037F40) --------------------------------------------------------
bool __usercall sub_10037F40@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100C779F[44 * a1] - (unsigned __int8)byte_100C779A[44 * a1];
}

//----- (10037F70) --------------------------------------------------------
char __usercall sub_10037F70@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10037F40(a1, a4, a5) )
  {
    v6 = a3
       + sub_10037E90(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100C779A[44 * a1] - (unsigned __int8)byte_100C779F[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10037E90(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10038010) --------------------------------------------------------
char __cdecl sub_10038010(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100248F0(a1);
  sub_100040E0(v5, (int)&v7, 3684);
  return sub_10037F70(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10038090) --------------------------------------------------------
char __cdecl sub_10038090(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100248F0(a1);
  sub_100040E0(v5, (int)&v7, 3684);
  return sub_10037F70(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10038110) --------------------------------------------------------
char __cdecl sub_10038110(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100248F0(a1);
  sub_100040E0(v5, (int)&v7, 3684);
  return sub_10037F70(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10038190) --------------------------------------------------------
char __cdecl sub_10038190(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100248F0(a1);
  sub_100040E0(v5, (int)&v7, 3684);
  return sub_10037F70(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10038210) --------------------------------------------------------
char __cdecl sub_10038210(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100382B0) --------------------------------------------------------
int __cdecl sub_100382B0(char a1)
{
  return sub_100117D0(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (100382D0) --------------------------------------------------------
BOOL __cdecl sub_100382D0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1002E320(a1);
  return sub_10014F90(0, 604, a2) && sub_10014960(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10038330) --------------------------------------------------------
int __usercall sub_10038330@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_100382B0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100C1A34[2 * v1];
  return result;
}
// 100C1A34: using guessed type int dword_100C1A34[];

//----- (10038360) --------------------------------------------------------
BOOL __cdecl sub_10038360(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10038330(a1);
  return sub_100040C0(v2, a2, 16) == 0;
}

//----- (10038390) --------------------------------------------------------
int __cdecl sub_10038390(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10038360(a1, (int)a5);
  else
    result = sub_100382D0(a1, a5);
  return result;
}

//----- (100383C0) --------------------------------------------------------
char __cdecl sub_100383C0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10014FC0(1, 1947, a1, (int)&v3);
}

//----- (100383E0) --------------------------------------------------------
BOOL __cdecl sub_100383E0(int a1)
{
  return sub_100040C0(6792, a1, 284) == 0;
}

//----- (10038400) --------------------------------------------------------
char __cdecl sub_10038400(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_100383E0((int)a5);
  else
    result = sub_100383C0(a5);
  return result;
}

//----- (10038430) --------------------------------------------------------
bool __cdecl sub_10038430(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_100040C0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10038470) --------------------------------------------------------
signed int __usercall sub_10038470@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10038490) --------------------------------------------------------
bool __cdecl sub_10038490(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10038470(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10014960(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10014FC0(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10038430(a1, a2);
  }
  else
  {
    v9 = sub_100154C0(v4);
    v8 = 1708;
    sub_10014AC0(1, 0, &v8, 0, 8, 1);
    sub_10014C00(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100045F0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10004620: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10038580) --------------------------------------------------------
bool __cdecl sub_10038580(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10038430(a1, a5);
  else
    result = sub_10038490(a1, a5);
  return result;
}

//----- (100385B0) --------------------------------------------------------
char __cdecl sub_100385B0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_101ADB30, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_100241D0(a1, (int)byte_101ADB30);
    v3 = 4 * a2 - 64;
    v4 = byte_101ADB31[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101ADB30[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10038650) --------------------------------------------------------
bool __cdecl sub_10038650(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_101ADB30, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_100241D0(a1, (int)byte_101ADB30);
    v3 = (char *)&unk_101ADBD0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (100386D0) --------------------------------------------------------
char __cdecl sub_100386D0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101ADB30, 0, 0x890u);
  sub_100241D0(a1, (int)byte_101ADB30);
  if ( a2 > 0x10u )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_101ADEA0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101ADEA4[2 * a2];
    result = 1;
  }
  return result;
}
// 101ADEA0: using guessed type int dword_101ADEA0[];
// 101ADEA4: using guessed type int dword_101ADEA4[];

//----- (10038740) --------------------------------------------------------
char __cdecl sub_10038740(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10014F90(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10014F90(0, 572, a2);
    }
    else
    {
      sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10014F90(0, 226, a2);
  }
  return result;
}

//----- (100387C0) --------------------------------------------------------
char __cdecl sub_100387C0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_101ADB30, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10038740(a1, byte_101ADB30);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_101ADB31[v4];
    *(_BYTE *)a3 = byte_101ADB30[v4];
  }
  return result;
}

//----- (10038840) --------------------------------------------------------
char __cdecl sub_10038840(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_101ADB30, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10038740(a1, byte_101ADB30);
    v4 = (char *)&unk_101ADBD0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (100388C0) --------------------------------------------------------
char __cdecl sub_100388C0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101ADB30, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10038740(a1, byte_101ADB30);
    *(_DWORD *)a3 = dword_101ADEA0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101ADEA4[2 * a2];
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 101ADEA0: using guessed type int dword_101ADEA0[];
// 101ADEA4: using guessed type int dword_101ADEA4[];

//----- (10038930) --------------------------------------------------------
char __cdecl sub_10038930(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10039480(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_100386D0(v6, *a4, a5);
    else
      result = sub_100388C0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_100385B0(v6, *a4, a5);
    else
      result = sub_100387C0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10038650(v6, *a4, a5);
    else
      result = sub_10038840(v6, *a4, a5);
  }
  return result;
}

//----- (10038A40) --------------------------------------------------------
char __cdecl sub_10038A40(char a1, void *a2)
{
  return sub_10014F90(6, (unsigned __int16)word_100C2A6A[8 * (unsigned __int8)a1], a2);
}
// 100C2A6A: using guessed type __int16 word_100C2A6A[];

//----- (10038A60) --------------------------------------------------------
bool __cdecl sub_10038A60(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_100040C0(dword_100C2A70[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100C2A70: using guessed type int dword_100C2A70[];

//----- (10038AA0) --------------------------------------------------------
char __cdecl sub_10038AA0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100394C0(a1);
  if ( a2 )
    result = sub_10038A60(v6, (char *)a5);
  else
    result = sub_10038A40(v6, a5);
  return result;
}

//----- (10038AE0) --------------------------------------------------------
BOOL sub_10038AE0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10017690(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10038B40) --------------------------------------------------------
char __cdecl sub_10038B40(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10014F90(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10038AE0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10016F10((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10038C30) --------------------------------------------------------
BOOL __cdecl sub_10038C30(int a1, int a2)
{
  return sub_100040C0(6200, a2, 60) == 0;
}

//----- (10038C50) --------------------------------------------------------
char __cdecl sub_10038C50(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10038C30(a1, (int)a5);
  }
  else
  {
    result = sub_10038B40(a1, a5);
  }
  return result;
}

//----- (10038C90) --------------------------------------------------------
char __cdecl sub_10038C90(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10014F90(2, 284, &v6) || sub_100170B0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10038D40) --------------------------------------------------------
BOOL __cdecl sub_10038D40(int a1, int a2)
{
  return sub_100040C0(6169, a2, 40) == 0;
}

//----- (10038D60) --------------------------------------------------------
char __cdecl sub_10038D60(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10038D40(a1, a5);
  }
  else
  {
    result = sub_10038C90(a1, a5);
  }
  return result;
}

//----- (10038DA0) --------------------------------------------------------
char __cdecl sub_10038DA0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10038DE0) --------------------------------------------------------
__int16 __usercall sub_10038DE0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100C478C[a1];
}
// 100C478C: using guessed type __int16 word_100C478C[];

//----- (10038DF0) --------------------------------------------------------
char __cdecl sub_10038DF0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10038DE0(a1);
    if ( sub_10014FC0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10038EC0) --------------------------------------------------------
char __cdecl sub_10038EC0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10038DA0(a1);
  if ( a3 != 11 )
  {
    sub_10003C10("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10038DF0(v7, a5);
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10038F40) --------------------------------------------------------
char __cdecl sub_10038F40(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10003C10("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10014FC0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10014FC0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10017590((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_101AE3C8, (char *)&v6 + 1, 0x20u);
      byte_101AE3C0 = 1;
      byte_101AE3C1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_101AE3E8, (char *)&v6 + 1, 0x20u);
    byte_101AE3C1 = 1;
    byte_101AE3C2 = 1;
    return result;
  }
  return 0;
}
// 101AE3C0: using guessed type char byte_101AE3C0;
// 101AE3C1: using guessed type char byte_101AE3C1;
// 101AE3C2: using guessed type char byte_101AE3C2;

//----- (10039070) --------------------------------------------------------
char __cdecl sub_10039070(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10024180(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10003C10("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (100390F0) --------------------------------------------------------
bool __cdecl sub_100390F0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_101AE3C0 == 0;
    qmemcpy(a1, &unk_101AE3C8, 0x40u);
    result = !v1 && byte_101AE3C2;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 101AE3C0: using guessed type char byte_101AE3C0;
// 101AE3C2: using guessed type char byte_101AE3C2;

//----- (10039140) --------------------------------------------------------
char __cdecl sub_10039140(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10003C10("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_100157B0(15);
    v3 = 555;
  }
  else
  {
    result = sub_100157B0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_101AE3C1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10014AC0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10004620: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101AE3C1: using guessed type char byte_101AE3C1;

//----- (10039220) --------------------------------------------------------
__int16 __usercall sub_10039220@<ax>(unsigned __int8 a1@<al>)
{
  return word_100C4898[a1];
}
// 100C4898: using guessed type __int16 word_100C4898[];

//----- (10039230) --------------------------------------------------------
char __cdecl sub_10039230(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10039220(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10014AC0(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10014C00(1, v3, 0xFFFFFFF);
}

//----- (100392C0) --------------------------------------------------------
char __cdecl sub_100392C0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10003C10("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_101AE3C1 != 0 ? 25 : 11;
      sub_10039230(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10039230(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 101AE3C1: using guessed type char byte_101AE3C1;

//----- (10039380) --------------------------------------------------------
bool __cdecl sub_10039380(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10039070(a1, (int)a5);
    return 1;
  }
  if ( byte_101AE3C1 )
  {
    if ( sub_10038F40(a1, &v6, 1) )
    {
LABEL_14:
      byte_101AE3C3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_101AE3C3 >= 5u )
    {
      byte_101AE3C0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10038F40(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_101AE3C3 >= 5u )
    {
      byte_101AE3C2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10039070(a1, (int)&v6);
    sub_10039140(a1, (int)&v6);
  }
  sub_100392C0(a1, 11);
  return sub_100390F0(a5);
}
// 10004620: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101AE3C0: using guessed type char byte_101AE3C0;
// 101AE3C1: using guessed type char byte_101AE3C1;
// 101AE3C2: using guessed type char byte_101AE3C2;
// 101AE3C3: using guessed type char byte_101AE3C3;

//----- (10039480) --------------------------------------------------------
char __cdecl sub_10039480(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10003C10("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (100394C0) --------------------------------------------------------
char __cdecl sub_100394C0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003B6D3) --------------------------------------------------------
int __cdecl sub_1003B6D3(int a1, int a2, char a3)
{
  return vscan_fn(sub_1004310F, a2, 0, &a3);
}
// 1003B66B: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003CD7C) --------------------------------------------------------
signed int __cdecl sub_1003CD7C(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101AF7D0 )
  {
    *a1 = dword_101AF7D0;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AF7D0: using guessed type int dword_101AF7D0;

//----- (1003CDB3) --------------------------------------------------------
signed int __cdecl sub_1003CDB3(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101AF7D0 )
  {
    *a1 = dword_101AF7DC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AF7D0: using guessed type int dword_101AF7D0;
// 101AF7DC: using guessed type int dword_101AF7DC;

//----- (1003D9F9) --------------------------------------------------------
void sub_1003D9F9()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_101E42C0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_101E43C0 );
}
// 101E42C0: using guessed type int dword_101E42C0[];
// 101E43C0: using guessed type int dword_101E43C0;

//----- (1003DEA6) --------------------------------------------------------
int (*sub_1003DEA6())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100DC140;
  v1 = (int (**)(void))&unk_100DC140;
  if ( &unk_100DC140 < &unk_100DC140 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100DC140 );
  }
  return result;
}

//----- (1003DECA) --------------------------------------------------------
void __cdecl sub_1003DECA()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100DC148;
  if ( &unk_100DC148 < &unk_100DC148 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100DC148 );
  }
}

//----- (1003F95E) --------------------------------------------------------
int __cdecl sub_1003F95E(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF938 = a1;
  return result;
}
// 101AF938: using guessed type int dword_101AF938;

//----- (1003FA88) --------------------------------------------------------
int __cdecl sub_1003FA88(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1004817C() + 8 && (void **)v2 != sub_1004817C() + 16 || !sub_1004811E((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100DE228;
      else
        v9 = (_BYTE *)(dword_101E42C0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10047FFE((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10047FFE((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 100480DA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004310F) --------------------------------------------------------
int __cdecl sub_1004310F(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100DE228;
  }
  else
  {
    v6 = &dword_101E42C0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100DE228) : (v8 = &dword_101E42C0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_10049A3C(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_10049A3C(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_10049A3C(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_10049A3C(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_10049A3C(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100DE210[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_10049A3C(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_10049A3C(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_10049A3C(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_10049A3C(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1003D0B2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100430D4: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100430EA: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100DE210: using guessed type int (*off_100DE210[3])();
// 101E42C0: using guessed type int dword_101E42C0[];
// 1004310F: using guessed type char var_24[11];

//----- (100448B0) --------------------------------------------------------
int __cdecl sub_100448B0(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10048A99((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1004203B: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10044956) --------------------------------------------------------
int __cdecl sub_10044956(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10048FDB((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1004203B: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10044DC2) --------------------------------------------------------
void sub_10044DC2()
{
  dword_101E429C = 0;
}
// 101E429C: using guessed type int dword_101E429C;

//----- (10045352) --------------------------------------------------------
int sub_10045352()
{
  return _decode_pointer(dword_101AFE00);
}
// 1003D0B2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101AFE00: using guessed type int dword_101AFE00;

//----- (1004550F) --------------------------------------------------------
int __cdecl sub_1004550F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AFE0C = a1;
  return result;
}
// 101AFE0C: using guessed type int dword_101AFE0C;

//----- (10045519) --------------------------------------------------------
int __cdecl sub_10045519(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AFE18 = a1;
  return result;
}
// 101AFE18: using guessed type int dword_101AFE18;

//----- (10045523) --------------------------------------------------------
int __cdecl sub_10045523(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AFE1C = a1;
  return result;
}
// 101AFE1C: using guessed type int dword_101AFE1C;

//----- (10045602) --------------------------------------------------------
int __cdecl sub_10045602(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AFE20 = a1;
  return result;
}
// 101AFE20: using guessed type int dword_101AFE20;

//----- (100467C7) --------------------------------------------------------
int sub_100467C7()
{
  dword_101E42A8 = _get_sse2_info();
  return 0;
}
// 10046767: using guessed type int _get_sse2_info(void);
// 101E42A8: using guessed type int dword_101E42A8;

//----- (10046904) --------------------------------------------------------
#error "10046909: positive sp value has been found (funcsize=0)"

//----- (1004690F) --------------------------------------------------------
#error "10046914: positive sp value has been found (funcsize=0)"

//----- (1004691A) --------------------------------------------------------
#error "1004691F: positive sp value has been found (funcsize=0)"

//----- (10046920) --------------------------------------------------------
#error "10046925: positive sp value has been found (funcsize=0)"

//----- (10046926) --------------------------------------------------------
#error "1004692B: positive sp value has been found (funcsize=0)"

//----- (1004692C) --------------------------------------------------------
#error "10046931: positive sp value has been found (funcsize=0)"

//----- (10046932) --------------------------------------------------------
#error "1004694D: positive sp value has been found (funcsize=0)"

//----- (10046953) --------------------------------------------------------
#error "10046968: positive sp value has been found (funcsize=0)"

//----- (1004696E) --------------------------------------------------------
#error "10046989: positive sp value has been found (funcsize=0)"

//----- (1004698A) --------------------------------------------------------
#error "10046999: positive sp value has been found (funcsize=0)"

//----- (1004699A) --------------------------------------------------------
#error "100469AD: positive sp value has been found (funcsize=0)"

//----- (100469AE) --------------------------------------------------------
#error "100469BD: positive sp value has been found (funcsize=0)"

//----- (100469BE) --------------------------------------------------------
#error "100469DD: positive sp value has been found (funcsize=0)"

//----- (100469E3) --------------------------------------------------------
#error "100469FC: positive sp value has been found (funcsize=0)"

//----- (10046A02) --------------------------------------------------------
#error "10046A21: positive sp value has been found (funcsize=0)"

//----- (10046A22) --------------------------------------------------------
#error "10046A35: positive sp value has been found (funcsize=0)"

//----- (10046A36) --------------------------------------------------------
#error "10046A4D: positive sp value has been found (funcsize=0)"

//----- (10046A4E) --------------------------------------------------------
#error "10046A61: positive sp value has been found (funcsize=0)"

//----- (10046A62) --------------------------------------------------------
#error "10046A81: positive sp value has been found (funcsize=0)"

//----- (10046A87) --------------------------------------------------------
#error "10046AA0: positive sp value has been found (funcsize=0)"

//----- (10046AA6) --------------------------------------------------------
#error "10046AC5: positive sp value has been found (funcsize=0)"

//----- (10046AC6) --------------------------------------------------------
#error "10046AD9: positive sp value has been found (funcsize=0)"

//----- (10046ADA) --------------------------------------------------------
#error "10046AF1: positive sp value has been found (funcsize=0)"

//----- (10046AF2) --------------------------------------------------------
#error "10046B05: positive sp value has been found (funcsize=0)"

//----- (10046B06) --------------------------------------------------------
#error "10046B25: positive sp value has been found (funcsize=0)"

//----- (10046B2B) --------------------------------------------------------
#error "10046B44: positive sp value has been found (funcsize=0)"

//----- (10046B4A) --------------------------------------------------------
#error "10046B69: positive sp value has been found (funcsize=0)"

//----- (10046B6A) --------------------------------------------------------
#error "10046B7D: positive sp value has been found (funcsize=0)"

//----- (10046B7E) --------------------------------------------------------
#error "10046B95: positive sp value has been found (funcsize=0)"

//----- (10046B96) --------------------------------------------------------
#error "10046BA9: positive sp value has been found (funcsize=0)"

//----- (10046BAA) --------------------------------------------------------
#error "10046BC9: positive sp value has been found (funcsize=0)"

//----- (10046BCF) --------------------------------------------------------
#error "10046BE8: positive sp value has been found (funcsize=0)"

//----- (10046BEE) --------------------------------------------------------
#error "10046C0D: positive sp value has been found (funcsize=0)"

//----- (10046C0E) --------------------------------------------------------
#error "10046C21: positive sp value has been found (funcsize=0)"

//----- (10046C22) --------------------------------------------------------
#error "10046C39: positive sp value has been found (funcsize=0)"

//----- (10046C3A) --------------------------------------------------------
#error "10046C4D: positive sp value has been found (funcsize=0)"

//----- (10046C4E) --------------------------------------------------------
#error "10046C6D: positive sp value has been found (funcsize=0)"

//----- (10046C73) --------------------------------------------------------
#error "10046C8C: positive sp value has been found (funcsize=0)"

//----- (10046C92) --------------------------------------------------------
#error "10046CB1: positive sp value has been found (funcsize=0)"

//----- (10046CB2) --------------------------------------------------------
#error "10046CC5: positive sp value has been found (funcsize=0)"

//----- (10046CC6) --------------------------------------------------------
#error "10046CDD: positive sp value has been found (funcsize=0)"

//----- (10046CDE) --------------------------------------------------------
#error "10046CF1: positive sp value has been found (funcsize=0)"

//----- (10046CF2) --------------------------------------------------------
#error "10046D11: positive sp value has been found (funcsize=0)"

//----- (10046D17) --------------------------------------------------------
#error "10046D30: positive sp value has been found (funcsize=0)"

//----- (10046D36) --------------------------------------------------------
#error "10046D55: positive sp value has been found (funcsize=0)"

//----- (10046D56) --------------------------------------------------------
#error "10046D69: positive sp value has been found (funcsize=0)"

//----- (10046D6A) --------------------------------------------------------
#error "10046D81: positive sp value has been found (funcsize=0)"

//----- (10046D82) --------------------------------------------------------
#error "10046D95: positive sp value has been found (funcsize=0)"

//----- (10047840) --------------------------------------------------------
DWORD __cdecl sub_10047840(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1004B6B4(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_101E42C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1003A606: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (100479DC) --------------------------------------------------------
_WORD *__cdecl sub_100479DC(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_101E42C0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_101E42C0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10047840(a1, 0, 0, 2u);
  if ( sub_1004811E(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1003A606: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1003D2CE: using guessed type int _getptd(void);
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];
// 100479DC: using guessed type CHAR var_410[688];

//----- (10047FFE) --------------------------------------------------------
_WORD *__cdecl sub_10047FFE(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_101E42C0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_100479DC(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1004B7C5(a1);
  return v6;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004B725: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004811E) --------------------------------------------------------
int __cdecl sub_1004811E(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_101E42C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004817C) --------------------------------------------------------
void **sub_1004817C()
{
  return &off_100DED28;
}
// 100DED28: using guessed type void *off_100DED28;

//----- (10048182) --------------------------------------------------------
signed int sub_10048182()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101E4280;
  if ( !dword_101E4280 )
  {
    v0 = 512;
LABEL_5:
    dword_101E4280 = v0;
    goto LABEL_6;
  }
  if ( dword_101E4280 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101E3260 = v1;
  if ( v1 || (dword_101E4280 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101E3260 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100DED28;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&off_100DEFA8 )
        break;
      v1 = dword_101E3260;
    }
    v5 = 0;
    v6 = &unk_100DED38;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_101E42C0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100DED98 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1003D6C2: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100DED28: using guessed type void *off_100DED28;
// 100DEFA8: using guessed type wchar_t *off_100DEFA8;
// 101E4280: using guessed type int dword_101E4280;
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (10048A99) --------------------------------------------------------
signed int __cdecl sub_10048A99(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100DF0B8 - 1;
    v64 = v3;
    v65 = dword_100DF0B8 / 32;
    v9 = dword_100DF0B8 % 32;
    v10 = (int *)(&v60 + dword_100DF0B8 / 32);
    v66 = 31 - dword_100DF0B8 % 32;
    if ( (1 << (31 - dword_100DF0B8 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100DF0B4 - dword_100DF0B8 )
    {
      if ( v3 > dword_100DF0B4 )
      {
        if ( v3 < dword_100DF0B0 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100DF0C4 + v3;
          v50 = dword_100DF0BC / 32;
          v51 = dword_100DF0BC % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100DF0BC % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100DF0BC / 32;
          v44 = dword_100DF0BC % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100DF0BC % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100DF0C4 + dword_100DF0B0;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100DF0B4 - v64) / 32;
      v62 = v59;
      v18 = (dword_100DF0B4 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100DF0B8 - 1;
      v25 = dword_100DF0B8 / 32;
      v65 = dword_100DF0B8 / 32;
      v26 = (int *)(&v60 + dword_100DF0B8 / 32);
      v64 = 31 - dword_100DF0B8 % 32;
      if ( (1 << (31 - dword_100DF0B8 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100DF0B8 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100DF0BC + 1) / 32;
      v37 = (dword_100DF0BC + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100DF0BC));
  if ( dword_100DF0C0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100DF0C0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100DF0B0: using guessed type int dword_100DF0B0;
// 100DF0B4: using guessed type int dword_100DF0B4;
// 100DF0B8: using guessed type int dword_100DF0B8;
// 100DF0BC: using guessed type int dword_100DF0BC;
// 100DF0C0: using guessed type int dword_100DF0C0;
// 100DF0C4: using guessed type int dword_100DF0C4;

//----- (10048FDB) --------------------------------------------------------
signed int __cdecl sub_10048FDB(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100DF0D0 - 1;
    v64 = v3;
    v65 = dword_100DF0D0 / 32;
    v9 = dword_100DF0D0 % 32;
    v10 = (int *)(&v60 + dword_100DF0D0 / 32);
    v66 = 31 - dword_100DF0D0 % 32;
    if ( (1 << (31 - dword_100DF0D0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100DF0CC - dword_100DF0D0 )
    {
      if ( v3 > dword_100DF0CC )
      {
        if ( v3 < dword_100DF0C8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100DF0DC + v3;
          v50 = dword_100DF0D4 / 32;
          v51 = dword_100DF0D4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100DF0D4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100DF0D4 / 32;
          v44 = dword_100DF0D4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100DF0D4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100DF0DC + dword_100DF0C8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100DF0CC - v64) / 32;
      v62 = v59;
      v18 = (dword_100DF0CC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100DF0D0 - 1;
      v25 = dword_100DF0D0 / 32;
      v65 = dword_100DF0D0 / 32;
      v26 = (int *)(&v60 + dword_100DF0D0 / 32);
      v64 = 31 - dword_100DF0D0 % 32;
      if ( (1 << (31 - dword_100DF0D0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100DF0D0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100DF0D4 + 1) / 32;
      v37 = (dword_100DF0D4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100DF0D4));
  if ( dword_100DF0D8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100DF0D8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100DF0C8: using guessed type int dword_100DF0C8;
// 100DF0CC: using guessed type int dword_100DF0CC;
// 100DF0D0: using guessed type int dword_100DF0D0;
// 100DF0D4: using guessed type int dword_100DF0D4;
// 100DF0D8: using guessed type int dword_100DF0D8;
// 100DF0DC: using guessed type int dword_100DF0DC;

//----- (1004991C) --------------------------------------------------------
int __cdecl sub_1004991C(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100DE228;
    }
    else
    {
      v7 = &dword_101E42C0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100480DA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (10049A3C) --------------------------------------------------------
int __cdecl sub_10049A3C(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100DE228;
    }
    else
    {
      v2 = &dword_101E42C0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100DE228) : (v4 = &dword_101E42C0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100480DA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (10049C84) --------------------------------------------------------
int sub_10049C84()
{
  return 0;
}

//----- (1004B160) --------------------------------------------------------
int __cdecl sub_1004B160(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101AFE3C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101AFE3C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101AFE40 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101AFE44 = _encode_pointer(v7);
    if ( sub_1003CD7C(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_101AFE4C = _encode_pointer(v8);
      if ( dword_101AFE4C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_101AFE48 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_101AFE48 == v23
    || dword_101AFE4C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_101AFE48),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_101AFE4C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101AFE40 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101AFE40);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101AFE44 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101AFE44);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1003CDB3(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101AFE3C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1003D03B: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1003D0A9: using guessed type int _encoded_null(void);
// 1003D0B2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003F968: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AFE3C: using guessed type int dword_101AFE3C;
// 101AFE40: using guessed type int dword_101AFE40;
// 101AFE44: using guessed type int dword_101AFE44;
// 101AFE48: using guessed type int dword_101AFE48;
// 101AFE4C: using guessed type int dword_101AFE4C;

//----- (1004B633) --------------------------------------------------------
signed int __cdecl sub_1004B633(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_101E42C0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_101AF4A4 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 101AF4A4: using guessed type int dword_101AF4A4;
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004B6B4) --------------------------------------------------------
signed int __cdecl sub_1004B6B4(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_101E42C0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1003FA64: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004B7C5) --------------------------------------------------------
void __cdecl sub_1004B7C5(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_101E42C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004BAC6) --------------------------------------------------------
int sub_1004BAC6()
{
  return flsall(1);
}
// 1004B9EC: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1004C411) --------------------------------------------------------
signed int __cdecl sub_1004C411(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1004B6B4(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_101E42C0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_101E42C0[0] + 68) & 1)
    && (v1 = sub_1004B6B4(2), sub_1004B6B4(1) == v1)
    || (v2 = (void *)sub_1004B6B4(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1004B633(a1);
  *(_BYTE *)(dword_101E42C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003A606: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101E42C0: using guessed type int dword_101E42C0[];

//----- (1004C5B0) --------------------------------------------------------
int __cdecl sub_1004C5B0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1004CDB0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1004C610) --------------------------------------------------------
int __usercall sub_1004C610@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10004540(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10004560(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1004C5B0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10003DB0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10004380(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100044F0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_100042B0(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_100042B0(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10004360: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10004370: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10004440: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1004C910) --------------------------------------------------------
int __usercall sub_1004C910@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1004CDB0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1004C930) --------------------------------------------------------
signed int __cdecl sub_1004C930(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10003C10("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10004060(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10004030(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1004C910(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1004C610((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10004030(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1004CA00) --------------------------------------------------------
__int16 __cdecl sub_1004CA00(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1004E7AC: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004CA40) --------------------------------------------------------
__int16 __cdecl sub_1004CA40(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1004CA30: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1004CAE0) --------------------------------------------------------
int __cdecl sub_1004CAE0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1004E7D0: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1004CB30) --------------------------------------------------------
int __cdecl sub_1004CB30(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10039526: using guessed type int SYS_exit_krnl(void);
// 1003952C: using guessed type int SYS_enter_krnl(void);
// 1004E7D6: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1004CBA0) --------------------------------------------------------
int __cdecl sub_1004CBA0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100154C0(v1);
  a1 = v2;
  v3 = sub_100117D0(&a1, 4u, (int)&unk_100D9510, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D9514[2 * v3];
}
// 100D9514: using guessed type int dword_100D9514[];

//----- (1004CBE0) --------------------------------------------------------
int __cdecl sub_1004CBE0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100154C0(v1);
  a1 = v2;
  v3 = sub_100117D0(&a1, 4u, (int)&unk_100D9548, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D954C[2 * v3];
}
// 100D954C: using guessed type int dword_100D954C[];

//----- (1004CC20) --------------------------------------------------------
int __cdecl sub_1004CC20(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100154C0(v1);
  a1 = v2;
  v3 = sub_100117D0(&a1, 4u, (int)&unk_100D9580, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D9584[2 * v3];
}
// 100D9584: using guessed type int dword_100D9584[];

//----- (1004CC60) --------------------------------------------------------
int __cdecl sub_1004CC60(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100154C0(v1);
  a1 = v2;
  v3 = sub_100117D0(&a1, 4u, (int)&unk_100D95B8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D95BC[2 * v3];
}
// 100D95BC: using guessed type int dword_100D95BC[];

//----- (1004CCA0) --------------------------------------------------------
int __cdecl sub_1004CCA0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1004CBE0(a4);
    result = sub_100040C0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_100040C0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1004CBA0(a4);
      result = sub_100040C0(v6, a3, 6);
    }
  }
  return result;
}

//----- (1004CD10) --------------------------------------------------------
int __cdecl sub_1004CD10(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1004CC60(a3);
    result = sub_100040C0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10003F60(100);
      v5 = sub_1004CC60(a3);
      result = sub_100040C0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1004CC20(a3);
    result = sub_100040C0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10003F60(100);
      v7 = sub_1004CC20(a3);
      result = sub_100040C0(v7, a2, 8);
    }
  }
  return result;
}

//----- (1004CDC0) --------------------------------------------------------
double __cdecl sub_1004CDC0(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10016110() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_101E29EC + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_101E29EC + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_101E29EC + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 101E29EC: using guessed type int dword_101E29EC;

//----- (1004CE50) --------------------------------------------------------
void __cdecl sub_1004CE50(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_1004D440(a1, a2, a4);
  v4 = sqrt(sub_1004D500(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (1004CEB0) --------------------------------------------------------
int __cdecl sub_1004CEB0(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (1004D070) --------------------------------------------------------
void __cdecl sub_1004D070(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_1004E5B0(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_1004E650(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_1004E650(v29 * v37, v24);
    v20 = sub_1004E650(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_1004CEB0(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (1004D440) --------------------------------------------------------
void __cdecl sub_1004D440(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_1004E610(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_1004E5B0(v10) * v12;
}

//----- (1004D500) --------------------------------------------------------
double __cdecl sub_1004D500(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (1004D520) --------------------------------------------------------
int __cdecl sub_1004D520(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_10006B50(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100D96A0[0]);
    *(_WORD *)(a1 + 10) = byte_100D96A0[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_100D96A0[2] + v11 - byte_100D96A0[1] + 1;
    sub_10006C40(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100D96A0[3]);
    *(_WORD *)(a1 + 8) = byte_100D96A0[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_100D96A0[5] + v12 - byte_100D96A0[4] + 1;
    sub_10006DB0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100D96A0[6]);
    *(_WORD *)(a1 + 10) = byte_100D96A0[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_100D96A0[7] - (byte_100D96A0[8] + v11) - 1;
    sub_10006C40(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100D96A0[9]);
    *(_WORD *)(a1 + 8) = byte_100D96A0[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_100D96A0[10] - (byte_100D96A0[11] + v12) - 1;
    sub_10006DB0(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1004D780) --------------------------------------------------------
int __cdecl sub_1004D780(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 < 1u )
  {
    if ( !sub_10016110() || a1 )
      result = 0;
    else
      result = dword_101E29E4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E29E4: using guessed type int dword_101E29E4;

//----- (1004D7A0) --------------------------------------------------------
int __cdecl sub_1004D7A0(int a1, float a2, float a3, int a4, int a5)
{
  float v6; // [sp+1Ch] [bp-Ch]@2
  char v7; // [sp+20h] [bp-8h]@1

  sub_1004E5F0(a1, (int)&v7);
  if ( (_BYTE)a4 )
    v6 = 0.0;
  else
    sub_10010580(&v7, &v6);
  return sub_1004E2B0(a1, a2, a3, a4, a5, v6);
}
// 10010580: using guessed type _DWORD __cdecl sub_10010580(_DWORD, _DWORD);

//----- (1004D810) --------------------------------------------------------
char __cdecl sub_1004D810(unsigned __int8 a1, int a2, int a3)
{
  char result; // al@6

  if ( sub_10016110() )
  {
    if ( a1 >= *(_BYTE *)(dword_101E29E0 + 4)
      && (a1 == -1 || a1 < *(_BYTE *)(dword_101E29E0 + 5) || a1 > *(_BYTE *)(dword_101E29E0 + 3)) )
    {
      result = 0;
    }
    else
    {
      sub_100160F0();
      sub_100160C0(a2, dword_101E29E0 + 180 * (a1 + 4));
      sub_100160C0(a3, 180 * a1 + dword_101E29E0 + 728);
      sub_100160E0();
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E29E0: using guessed type int dword_101E29E0;

//----- (1004D890) --------------------------------------------------------
void __usercall sub_1004D890(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  float v3; // ST04_4@1
  float v4; // ST04_4@3

  v3 = *(float *)(a3 + 4) - *(float *)(a2 + 4);
  if ( sub_1004E5B0(v3) < 0.0 )
    *(float *)(a2 + 4) = *(float *)(a3 + 4);
  v4 = *(float *)(a3 + 4) - *(float *)(a1 + 4);
  if ( sub_1004E5B0(v4) > 0.0 )
    *(float *)(a1 + 4) = *(float *)(a3 + 4);
  if ( *(float *)a2 < (double)*(float *)a3 )
    *(float *)a2 = *(float *)a3;
  if ( *(float *)a1 > (double)*(float *)a3 )
    *(float *)a1 = *(float *)a3;
}

//----- (1004D910) --------------------------------------------------------
char __cdecl sub_1004D910(char a1, char a2, int a3, int a4)
{
  int v4; // eax@2
  int v5; // esi@2
  __int16 v6; // ax@2
  int v7; // edi@3
  int v8; // ecx@3
  int v9; // eax@3
  int v10; // esi@10
  int v11; // edi@10
  float v12; // ST30_4@10
  int v13; // eax@10
  int *v14; // esi@17
  __int16 v15; // ax@23
  char result; // al@25
  char v17; // [sp+1Ah] [bp-2Ah]@3
  char v18; // [sp+1Bh] [bp-29h]@1
  int v19; // [sp+1Ch] [bp-28h]@3
  float v20; // [sp+20h] [bp-24h]@10
  float *v21; // [sp+24h] [bp-20h]@8
  float v22; // [sp+24h] [bp-20h]@10
  int v23; // [sp+28h] [bp-1Ch]@2
  char v24; // [sp+30h] [bp-14h]@10
  int v25; // [sp+34h] [bp-10h]@11
  float v26; // [sp+3Ch] [bp-8h]@10
  float v27; // [sp+40h] [bp-4h]@10

  v18 = 0;
  if ( sub_1004E3B0(a1) )
  {
    v4 = sub_1004D780(a1);
    v5 = v4;
    v23 = v4;
    v6 = sub_1004E340(v4, a2);
    if ( v6 != -1 )
    {
      v7 = a3;
      v18 = 1;
      v17 = 1;
      v8 = 44 * v6;
      v9 = v8 + v5 + 324;
      *(_DWORD *)a3 = *(_DWORD *)(v8 + v5 + 360);
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(v8 + v5 + 364);
      *(_DWORD *)a4 = *(_DWORD *)(v8 + v5 + 360);
      *(_DWORD *)(a4 + 4) = *(_DWORD *)(v8 + v5 + 364);
      v19 = v8 + v5 + 324;
      if ( *(_BYTE *)v9 == a2 )
      {
        while ( ((*(_BYTE *)(v9 + 2) >> 1) & 3) != 2 && (*(_BYTE *)(v9 + 2) >> 1) & 3 )
        {
          v21 = (float *)(v9 + 36);
          sub_1004D890(a4, v7, v9 + 36);
          if ( v17 )
            sub_1004D890(a4, a3, 44 * *(_WORD *)(v19 + 10) + v23 + 360);
          v10 = v19;
          v11 = v19 + 24;
          sub_1004CE50((float *)(v19 + 24), (float *)(44 * *(_WORD *)(v19 + 10) + v23 + 360), (float *)&v24, (int)&v26);
          v20 = sub_1004E6C0(v26, v27);
          sub_1004CE50((float *)(v19 + 24), v21, (float *)&v24, (int)&v26);
          v12 = sub_1004E6C0(v26, v27);
          LOBYTE(v13) = (*(_WORD *)(v19 + 2) & 0xC00) == 2048;
          v22 = sub_1004E3C0(v20, v12, v13);
          if ( sub_1004E430(v20, v22, 0.0) )
          {
            sub_1004E200(v11, *(float *)(v19 + 32), 0.0, (int)&v25);
            sub_1004D890(a4, a3, (int)&v25);
            v10 = v19;
            v11 = v19 + 24;
          }
          if ( sub_1004E430(v20, v22, 1.5707964) )
          {
            sub_1004E200(v11, *(float *)(v10 + 32), 1.5707964, (int)&v25);
            sub_1004D890(a4, a3, (int)&v25);
            v10 = v19;
            v11 = v19 + 24;
          }
          if ( sub_1004E430(v20, v22, 3.1415927) )
          {
            sub_1004E200(v11, *(float *)(v10 + 32), 3.1415927, (int)&v25);
            sub_1004D890(a4, a3, (int)&v25);
            v10 = v19;
            v11 = v19 + 24;
          }
          if ( sub_1004E430(v20, v22, -1.5707964) )
          {
            sub_1004E200(v11, *(float *)(v10 + 32), -1.5707964, (int)&v25);
            v14 = &v25;
            goto LABEL_21;
          }
LABEL_23:
          v15 = *(_WORD *)(v10 + 8);
          if ( v15 == -1 )
            goto LABEL_25;
          v19 = 44 * v15 + v23 + 324;
          v17 = 0;
          if ( *(_BYTE *)v19 != a2 )
            goto LABEL_25;
          v9 = 44 * v15 + v23 + 324;
          v7 = a3;
        }
        sub_1004D890(a4, v7, v9 + 36);
        if ( (*(_BYTE *)(v19 + 2) & 6) == 4 && v17 )
        {
          v14 = (int *)(44 * *(_WORD *)(v19 + 10) + v23 + 360);
LABEL_21:
          sub_1004D890(a4, a3, (int)v14);
        }
        v10 = v19;
        goto LABEL_23;
      }
    }
LABEL_25:
    sub_1004E3A0(a1);
    result = v18;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004DC90) --------------------------------------------------------
void __usercall sub_1004DC90(int a1@<ebx>, int a2@<edi>, float a3, float a4)
{
  long double v4; // st7@1
  double v5; // st7@4
  double v6; // ST20_8@7
  double v7; // st7@7
  double v8; // st7@7
  long double v9; // st7@7
  signed int v10; // esi@7
  long double v11; // st7@7
  long double v12; // st7@7
  long double v13; // st7@8
  long double v14; // st4@8
  double v15; // st7@8
  long double v16; // st4@8
  double v17; // st5@10
  float v18; // ST20_4@10
  float v19; // [sp+18h] [bp-78h]@1
  double v20; // [sp+18h] [bp-78h]@7
  double v21; // [sp+20h] [bp-70h]@7
  double v22; // [sp+28h] [bp-68h]@8
  double v23; // [sp+30h] [bp-60h]@7
  double v24; // [sp+38h] [bp-58h]@8
  double v25; // [sp+40h] [bp-50h]@7
  double v26; // [sp+48h] [bp-48h]@7
  double v27; // [sp+50h] [bp-40h]@7
  double v28; // [sp+58h] [bp-38h]@7
  double v29; // [sp+60h] [bp-30h]@7
  double v30; // [sp+68h] [bp-28h]@7
  double v31; // [sp+70h] [bp-20h]@7
  double v32; // [sp+78h] [bp-18h]@8
  double v33; // [sp+80h] [bp-10h]@8
  double v34; // [sp+88h] [bp-8h]@7

  v19 = *(float *)a2;
  v4 = v19;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v4 > 1.570796251296997 )
  {
    v5 = 1.5707963;
    goto LABEL_6;
  }
  if ( v4 < -1.570796251296997 )
  {
    v5 = -1.5707963;
LABEL_6:
    v19 = v5;
    v4 = v19;
  }
  v6 = sin(v4) * 0.9966471893352525 / cos(v19);
  v27 = sin(a4);
  v7 = cos(a4);
  v23 = v7;
  v8 = sub_1004E650(v6, v7);
  v28 = v8 + v8;
  v25 = 1.0 / sqrt(v6 * v6 + 1.0);
  v26 = v6 * v25;
  v34 = v25 * v27;
  v30 = v34 * v34;
  v31 = 1.0 - v30;
  v9 = sqrt(v31 * 0.006739496742276474 + 1.0);
  v10 = 0;
  v11 = (v9 + 1.0 - 2.0) / (v9 + 1.0);
  v29 = (v11 * 0.375 * v11 - 1.0) * v11;
  v12 = a3 / 0.9966471893352525 / 6378137.0 / ((v11 * v11 * 0.25 + 1.0) / (1.0 - v11));
  v21 = v12;
  v20 = v12;
  do
  {
    v22 = sin(v12);
    v24 = cos(v20);
    v13 = cos(v20 + v28);
    v33 = v13;
    ++v10;
    v32 = v13 * v13 + v13 * v13 - 1.0;
    v14 = v29 * (((v32 * v24 + (v32 + v32 - 1.0) * (v22 * v22 * 4.0 - 3.0) * v13 * v29 / 6.0) * v29 * 0.25 - v13) * v22);
    v15 = v20;
    v20 = v14 + v21;
    v16 = v20 - v15;
    v12 = v20;
  }
  while ( fabs(v16) > 0.00000005 && v10 < 20 );
  *(float *)a1 = sub_1004E650(
                   v22 * v25 * v23 + v24 * v26,
                   sqrt((v24 * v25 * v23 - v22 * v26) * (v24 * v25 * v23 - v22 * v26) + v30) * 0.9966471893352525);
  v17 = v31 * ((4.0 - 3.0 * v31) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
  v18 = sub_1004E650(v22 * v27, v24 * v25 - v22 * v26 * v23)
      - 0.00335281066474748 * ((1.0 - v17) * (((v32 * v24 * v17 + v33) * v22 * v17 + v20) * v34))
      + *(float *)(a2 + 4);
  *(float *)(a1 + 4) = sub_1004E5B0(v18);
}

//----- (1004DF80) --------------------------------------------------------
void __usercall sub_1004DF80(int a1@<esi>)
{
  double v1; // st7@1
  float v2; // ST04_4@4
  double v3; // st6@4

  v1 = 1.570796370506287;
  while ( *(float *)a1 > v1 || *(float *)a1 < -1.570796370506287 )
  {
    v2 = *(float *)(a1 + 4) + 3.141592741012573;
    *(float *)(a1 + 4) = sub_1004E5B0(v2);
    v1 = 1.570796370506287;
    v3 = *(float *)a1;
    if ( v3 <= 1.570796370506287 )
      *(float *)a1 = -3.141592741012573 - v3;
    else
      *(float *)a1 = 3.141592741012573 - v3;
  }
}

//----- (1004DFF0) --------------------------------------------------------
void __cdecl sub_1004DFF0(int a1, float a2, float a3, int a4)
{
  double v4; // st5@4
  double v5; // st5@8
  double v6; // st6@10
  int v7; // ecx@13
  float v8; // edx@13
  double v9; // st7@14
  float i; // [sp+14h] [bp-24h]@16
  char v11; // [sp+18h] [bp-20h]@16
  float v12; // [sp+1Ch] [bp-1Ch]@16
  float v13; // [sp+20h] [bp-18h]@13
  float v14; // [sp+24h] [bp-14h]@8
  int v15; // [sp+28h] [bp-10h]@16
  float v16; // [sp+2Ch] [bp-Ch]@16
  int v17; // [sp+30h] [bp-8h]@13
  float v18; // [sp+34h] [bp-4h]@13

  if ( fabs(a2) < 0.0000009999999974752427 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a1;
    *(_DWORD *)(a4 + 4) = *(_DWORD *)(a1 + 4);
    return;
  }
  if ( fabs(*(float *)a1 - 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 3.1415925;
LABEL_7:
    a3 = v4;
    goto LABEL_8;
  }
  if ( fabs(*(float *)a1 + 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 0.0;
    goto LABEL_7;
  }
LABEL_8:
  v5 = a3;
  v14 = fabs(a3);
  if ( v14 < 0.000001 || 3.1415926535898 - v5 < 0.0000009999999974752427 )
  {
    v6 = v14;
  }
  else
  {
    v6 = v14;
    if ( v5 + 3.1415926535898 >= 0.0000009999999974752427 )
    {
      sub_1004DC90(a4, a1, a2, a3);
      return;
    }
  }
  v7 = *(_DWORD *)a1;
  v8 = *(float *)(a1 + 4);
  v14 = a2;
  v17 = v7;
  v13 = a3;
  v18 = v8;
  if ( v6 >= 0.000001 )
    v9 = -1.5707964;
  else
    v9 = 1.5707964;
  *(float *)&v15 = v9;
  v16 = v18;
  sub_1004D070((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  for ( i = a2 - v12; i > 0.0; i = i - v12 )
  {
    v14 = v13 + 3.141592741012573;
    v13 = sub_1004E5B0(v14);
    v14 = v16 + 3.141592741012573;
    v16 = sub_1004E5B0(v14);
    v14 = i;
    v17 = v15;
    *(float *)&v15 = -*(float *)&v15;
    v18 = v16;
    sub_1004D070((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  }
  sub_1004DC90(a4, (int)&v17, v14, v13);
}

//----- (1004E200) --------------------------------------------------------
void __cdecl sub_1004E200(int a1, float a2, float a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  double v7; // st7@2
  float v8; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v8 = cos(*(float *)a1);
  a2 = a2 / 6378137.0;
  sub_1004E610(a3, (int)&v9, (int)&a1);
  v5 = a4;
  v6 = a2;
  *(float *)a4 = *(float *)&a1 * a2 + *(float *)v4;
  LODWORD(a2) = LODWORD(v8) & 0x7FFFFFFF;
  if ( COERCE_FLOAT(LODWORD(v8) & 0x7FFFFFFF) <= 0.000001 )
    v7 = *(float *)(v4 + 4);
  else
    v7 = v6 * *(float *)&v9 / v8 + *(float *)(v4 + 4);
  *(float *)(v5 + 4) = v7;
  *(float *)(v5 + 4) = sub_1004E5B0(*(float *)(v5 + 4));
  sub_1004DF80(v5);
}

//----- (1004E2B0) --------------------------------------------------------
int __cdecl sub_1004E2B0(int a1, float a2, float a3, int a4, int a5, float a6)
{
  double v6; // st7@3
  char v8; // [sp+Ch] [bp-8h]@1
  int v9; // [sp+24h] [bp+10h]@5
  int v10; // [sp+24h] [bp+10h]@5

  sub_1004E5F0(a1, (int)&v8);
  if ( (_BYTE)a4 != 1 )
  {
    if ( (_BYTE)a4 )
      v6 = sub_1004CDC0(a4);
    else
      v6 = a6;
    *(float *)&v9 = v6;
    *(float *)&v10 = *(float *)&v9 + a3;
    a3 = sub_1004E5B0(*(float *)&v10);
  }
  sub_1004DFF0((int)&v8, a2, a3, (int)&v8);
  return sub_1004E630((int)&v8, a5);
}

//----- (1004E340) --------------------------------------------------------
signed int __cdecl sub_1004E340(int a1, char a2)
{
  signed int result; // eax@1
  int v3; // ecx@4

  result = *(_WORD *)(a1 + 14);
  if ( a2 == -1 )
  {
    result = -1;
  }
  else
  {
    for ( ; (_WORD)result != -1; result = *(_WORD *)(v3 + 332) )
    {
      v3 = a1 + 44 * (signed __int16)result;
      if ( *(_BYTE *)(v3 + 324) == a2 )
        break;
    }
  }
  return result;
}

//----- (1004E3A0) --------------------------------------------------------
bool __cdecl sub_1004E3A0(char a1)
{
  bool result; // al@2

  if ( a1 )
    result = 1;
  else
    result = sub_100160E0();
  return result;
}

//----- (1004E3B0) --------------------------------------------------------
bool __cdecl sub_1004E3B0(char a1)
{
  bool result; // al@2

  if ( a1 )
    result = 1;
  else
    result = sub_100160F0();
  return result;
}

//----- (1004E3C0) --------------------------------------------------------
double __cdecl sub_1004E3C0(float a1, float a2, int a3)
{
  float v4; // [sp+8h] [bp+8h]@1
  int v5; // [sp+Ch] [bp+Ch]@6

  v4 = a2 - a1;
  if ( (_BYTE)a3 )
  {
    if ( (LODWORD(v4) >> 31) & 1 )
      v4 = v4 + 6.283185482025146;
  }
  else if ( v4 > 0.0 )
  {
    v4 = v4 - 6.283185482025146;
  }
  *(float *)&v5 = v4 - 6.283185482025146 * (double)(signed int)(v4 / 6.283185482025146);
  return *(float *)&v5;
}

//----- (1004E430) --------------------------------------------------------
bool __cdecl sub_1004E430(float a1, float a2, float a3)
{
  __int16 v3; // fps@1
  bool v4; // c0@1
  char v5; // c2@1
  bool v6; // c3@1
  __int16 v7; // ax@1
  double v8; // st6@1
  bool result; // al@5
  float v10; // [sp+10h] [bp-4h]@1

  v4 = 0.0 < a2;
  v5 = 0;
  v6 = 0.0 == a2;
  HIBYTE(v7) = HIBYTE(v3);
  LOBYTE(v7) = (v4 || v6) != 0;
  v10 = sub_1004E3C0(a1, a3, v7);
  v8 = a2;
  if ( a2 > 0.0 && v10 < v8 )
    result = 1;
  else
    result = v8 < 0.0 && v8 < v10;
  return result;
}

//----- (1004E4B0) --------------------------------------------------------
double __cdecl sub_1004E4B0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (1004E510) --------------------------------------------------------
double __cdecl sub_1004E510(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (1004E590) --------------------------------------------------------
void __cdecl sub_1004E590(double a1)
{
  sub_1004E4B0(a1, 3.1415926535898);
}

//----- (1004E5B0) --------------------------------------------------------
double __cdecl sub_1004E5B0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_1004E510(a1, 3.1415927);
  return result;
}

//----- (1004E5F0) --------------------------------------------------------
int __cdecl sub_1004E5F0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (1004E610) --------------------------------------------------------
int __cdecl sub_1004E610(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (1004E630) --------------------------------------------------------
int __cdecl sub_1004E630(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (1004E650) --------------------------------------------------------
double __cdecl sub_1004E650(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_1004E590(result);
    }
  }
  return result;
}

//----- (1004E6C0) --------------------------------------------------------
double __cdecl sub_1004E6C0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_1004E5B0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (1004E750) --------------------------------------------------------
int __cdecl sub_1004E750(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (1004E780) --------------------------------------------------------
int __cdecl sub_1004E780(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

#error "There were 51 decompilation failure(s) on 1150 function(s)"
