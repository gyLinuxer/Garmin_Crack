/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

BOOL __cdecl sub_10001000(unsigned int a1, int a2, unsigned int a3, int a4);
char __cdecl sub_10001030(_DWORD *a1, int a2, int a3);
unsigned int __cdecl sub_10001060(int a1, int a2);
int __cdecl sub_10001080(int a1, int a2, char a3, int a4);
int __cdecl sub_100011D0(signed __int64 a1);
_DWORD __cdecl sub_100011F0(_DWORD); // weak
int __cdecl sub_10001200(int a1);
int __cdecl sub_10001240(int a1, unsigned __int16 a2);
signed int __cdecl sub_10001350(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_10001390(int a1, unsigned __int16 a2, _BYTE *a3, int a4);
signed int __cdecl sub_100013D0(_DWORD *a1, int a2, __int16 a3, __int16 a4, unsigned int a5, unsigned int a6, char a7, const char *a8, _BYTE *a9);
unsigned int __cdecl sub_10001500(_DWORD *a1, int a2, __int16 a3, __int16 a4, unsigned int a5, char a6, const char *a7, _BYTE *a8);
int __cdecl sub_10001540(int a1, int a2, char *a3, size_t a4);
_BYTE *__cdecl sub_100015E0(char a1, _BYTE *a2, int a3);
void *sub_10001610();
char __cdecl sub_10001620(int a1, int a2, void *a3, size_t a4);
char __cdecl sub_10001670(int a1, int a2, void *a3);
int __cdecl sub_100016B0(int a1, _DWORD *a2);
char *__cdecl sub_100016F0(int a1, _DWORD *a2);
_BYTE *__cdecl sub_10001740(int a1);
// int __usercall sub_10001800@<eax>(int a1@<edx>, int a2@<edi>);
// int __usercall sub_10001830@<eax>(int result@<eax>, int a2@<edx>);
char __fastcall sub_10001890(int a1, int a2);
_BYTE *__cdecl sub_100018D0(int a1, _BYTE *a2, int a3, char a4);
int __cdecl sub_100019A0(int a1, unsigned __int16 a2, char *a3, size_t a4);
signed int __cdecl sub_100019F0(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_10001B00(int a1, int a2, int a3);
int __cdecl sub_10001B80(int a1, int a2);
signed int __cdecl sub_10001D70(int a1, int a2, int a3);
// int __usercall sub_10001E30@<eax>(int a1@<esi>);
signed int __cdecl sub_10002130(int a1);
// int __usercall sub_10002170@<eax>(int a1@<esi>);
// int __usercall sub_10002230@<eax>(char a1@<al>, int a2@<edx>, unsigned __int16 a3@<bx>, int a4, __int16 a5);
signed int __cdecl sub_100022A0(int a1, int a2);
signed int __cdecl sub_10002300(int a1, int a2);
signed int __cdecl sub_10002360(int a1, int a2);
signed int __cdecl sub_10002470(int a1, int a2);
signed int __cdecl sub_10002530(int a1, int a2);
signed int __cdecl sub_100025F0(int a1, int a2);
signed int __cdecl sub_10002650(int a1, int a2);
signed int __cdecl sub_100026D0(int a1, int a2);
signed int __cdecl sub_10002740(int a1, int a2);
int __cdecl sub_100027B0(int a1, int a2);
int __cdecl sub_100027F0(int a1, int a2);
int __cdecl sub_10002870(int a1, int a2);
int __cdecl sub_100028C0(int a1, int a2);
int __cdecl sub_10002970(int a1, int a2);
int __cdecl sub_100029F0(int a1, int a2);
int __cdecl sub_10002A70(int a1, int a2);
int __cdecl sub_10002BD0(int a1, int a2);
int __cdecl sub_10002CD0(int a1, int a2);
int __cdecl sub_10002D80(int a1);
void *sub_10002DC0();
// void __usercall __noreturn sub_10002E20(int a1@<ecx>, int a2@<esi>, char a3);
int sub_10002E60();
signed int __cdecl sub_10002E70(int a1, const char *a2, _DWORD *a3);
int __cdecl sub_10002FE0(int a1, int a2);
int __cdecl sub_10003050(int, void *); // idb
int __cdecl sub_10003100(int a1, int a2);
int __cdecl sub_10003170(int a1, int a2);
int __cdecl sub_10003200(int a1, int a2);
signed int __cdecl sub_10003290(int a1, int a2);
int __cdecl sub_100033E0(int a1, int a2);
signed int __cdecl sub_10003550(int a1, int a2);
signed int __cdecl sub_10003770(int a1, const char *a2, __int16 a3, _WORD *a4);
// int __usercall sub_100038F0@<eax>(int a1@<eax>, unsigned __int16 a2@<cx>);
// int __usercall sub_10003940@<eax>(_BYTE *a1@<edx>, _WORD *a2@<ecx>, int a3@<ebx>, unsigned int a4, int a5, char a6, __int16 a7, int a8, unsigned __int16 a9, _BYTE *a10);
// signed int __usercall sub_10003D10@<eax>(unsigned __int16 a1@<dx>, int a2@<ecx>, int a3, int a4, int a5, signed __int64 a6, _WORD *a7);
// char __usercall sub_10003EC0@<al>(int a1@<eax>);
int __cdecl sub_10003FA0(int a1, int a2);
int __cdecl sub_10004180(int a1, __int16 a2);
signed int __cdecl sub_10004560(int a1);
// int __usercall sub_10004890@<eax>(int a1@<edx>, int a2, __int16 a3);
// bool __usercall sub_10004BC0@<al>(unsigned __int16 a1@<ax>, int a2@<ecx>);
signed int __cdecl sub_10004BE0(int a1);
// signed int __usercall sub_10004C10@<eax>(unsigned __int16 a1@<cx>, int a2@<esi>);
int __cdecl sub_10004C60(int a1, int a2);
signed int __cdecl sub_10004D80(int a1, int a2);
int __cdecl sub_10004E10(_DWORD *a1, int a2);
int __cdecl sub_10005250(int a1, int a2);
int __cdecl sub_100053B0(int a1, int a2);
signed int __cdecl sub_100054B0(int a1, unsigned int a2);
signed int __cdecl sub_10005730(int a1, int a2);
signed int __cdecl sub_10005780(int a1, int a2);
signed int __cdecl sub_10005860(int a1, int a2);
int __cdecl sub_100059A0(_DWORD *a1);
void __noreturn sub_10005CC0();
signed int __cdecl sub_10005D90(int a1, int a2);
_DWORD sub_10005F90(); // weak
// int __usercall sub_10005FB0@<eax>(int result@<eax>, int a2@<esi>);
// int __usercall sub_10006060@<eax>(int a1@<eax>, int a2@<edi>, int a3);
int __cdecl sub_10006120(void *, int); // idb
// _BYTE *__usercall sub_100062A0@<eax>(_BYTE *a1@<edx>, int a2, int a3);
// int __usercall sub_10006310@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>);
signed int __fastcall sub_10006340(int a1, char *a2);
int __fastcall sub_10006690(int a1, int a2);
// _BYTE *__usercall sub_100067B0@<eax>(int a1@<ebx>, _BYTE *a2, int a3);
_BYTE *__cdecl sub_100068F0(_BYTE *a1, int a2, int a3);
_BYTE *__cdecl sub_10006930(_BYTE *a1, int a2, int a3);
int __cdecl sub_10006980(int a1);
// int __usercall sub_100069B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100069F0@<eax>(int result@<eax>, int a2, int a3, int a4);
// int __usercall sub_10006A40@<eax>(int a1@<eax>, int a2);
void *__cdecl sub_10006ED0(int a1, void *a2, int a3);
void *__cdecl sub_10006F80(void *a1, int a2);
void *__cdecl sub_10007010(int a1, int a2, int a3);
char *__cdecl sub_10007060(int a1, char *a2, int a3, char *a4, int a5);
char sub_10007190();
char __cdecl sub_100071A0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_100072A0(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10007310(int a1, unsigned int a2);
int __cdecl sub_10007400(int a1, int a2, int a3);
int __cdecl sub_10007440(int *a1, unsigned int a2);
__int16 __cdecl sub_10007530(int a1, unsigned int a2);
int __cdecl sub_10007580(int *a1, unsigned int a2);
signed __int64 __cdecl sub_100075B0(int a1);
int __cdecl sub_100075F0(signed __int64 a1);
__int16 __cdecl sub_10007640(unsigned int *a1, _WORD *a2, _WORD *a3);
_DWORD *__cdecl sub_100076C0(unsigned int a1, unsigned int a2, _DWORD *a3);
int __cdecl sub_10007770(int a1, int a2, int a3);
char __cdecl sub_100077C0(_BYTE *a1);
int __cdecl sub_100077F0(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_10007840(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_100078B0(void *, size_t); // idb
int __cdecl sub_100078E0(char *, size_t, char *, va_list); // idb
// char __usercall sub_10007920@<al>(int a1@<ebx>, int a2, int a3, int a4, char a5);
int sub_10007A80(char *arg0, size_t arg4, char *arg8, ...);
char __cdecl sub_10007AB0(const char *a1, const char *a2, char a3);
int __cdecl sub_10007B00(const char *a1, _BYTE *a2, int a3);
int __stdcall sub_10007B40(_DWORD, _DWORD); // weak
int __cdecl sub_10007B70(int *a1);
// char __usercall sub_10007BA0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10007C50(const char *a1);
char __cdecl sub_10007C90(void *a1);
signed int __cdecl sub_10007CE0(unsigned int a1, int a2);
char **sub_10008080();
signed int sub_100080A0();
int sub_100080C0();
char __cdecl sub_100080D0(char *a1);
int __cdecl sub_10008100(int a1);
int sub_10008190();
char __thiscall sub_100081C0(void *this);
// char __usercall sub_10008230@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10008270@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10008310(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10008350(char a1, char a2, void *a3);
char __cdecl sub_100083B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100083F0(char a1, char a2, void *a3);
char __cdecl sub_10008420(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10008460(char a1, char a2, void *a3);
char __cdecl sub_100084A0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100084E0(char a1, char a2, void *a3);
char __cdecl sub_10008530(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10008570(char a1, char a2, void *a3);
char __cdecl sub_100085B0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100085F0(char a1, char a2, void *a3);
char __cdecl sub_10008630(char a1, void *a2);
char __cdecl sub_10008660(char a1, void *a2);
char __cdecl sub_10008690(char a1, void *a2);
char __cdecl sub_100086C0(char a1, void *a2);
char __cdecl sub_100086F0(char a1, void *a2);
char __cdecl sub_10008720(char a1, void *a2);
char __cdecl sub_10008750(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10008790(char a1, char a2, void *a3);
char __cdecl sub_100087E0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10008820(char a1, char a2, void *a3);
char __cdecl sub_10008850(char a1, void *a2);
char __cdecl sub_10008880(char a1, void *a2);
char __cdecl sub_100088B0(char a1, void *a2);
char __cdecl sub_100088E0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10008C80(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10008CF0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10008D50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10008DC0(char a1, _BYTE *a2);
char __thiscall sub_10008E00(void *this);
char __cdecl sub_10008E70(char a1, int a2);
char __cdecl sub_10008EA0(char a1, int a2);
char __cdecl sub_10008ED0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __thiscall sub_100090A0(void *this);
char __cdecl sub_10009130(int a1, char a2);
char __cdecl sub_100091F0(char a1);
char *__cdecl sub_10009220(char **a1);
int sub_10009270();
int __cdecl sub_100092B0(_BYTE *a1, int a2);
signed int __cdecl sub_10009320(_BYTE *a1, int a2);
// int __usercall sub_100093C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_100093F0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_100095C0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10009620@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_100096B0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10009700@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10009760@<eax>(int a1@<eax>);
// int __usercall sub_10009780@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_100097C0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10009850@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_100099A0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10009A40@<eax>(int result@<eax>);
char *__cdecl sub_10009A80(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10009C30@<eax>(int a1@<eax>);
// int __usercall sub_10009C60@<eax>(int a1@<esi>);
void __cdecl sub_10009C90(int (**a1)(void), char **a2, _DWORD *a3);
int sub_1000A100();
void *sub_1000A150();
char *sub_1000A1B0();
char sub_1000A1D0();
char __cdecl sub_1000A1E0(int a1, int a2, unsigned int a3);
// int *__usercall sub_1000A220@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_1000A270();
int __cdecl sub_1000A280(_DWORD *a1, int a2, int a3);
int __cdecl sub_1000A330(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1000A540@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1000A600(char a1);
int *__cdecl sub_1000A6A0(_BYTE *a1);
// int __usercall sub_1000A760@<eax>(int a1@<eax>);
// signed int __usercall sub_1000A8C0@<eax>(int a1@<esi>);
int __cdecl sub_1000A930(int, int); // weak
char **sub_1000AC10();
// int __usercall sub_1000AC20@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1000AD10(char *a1);
int sub_1000AF50();
int __cdecl sub_1000B030(int a1, int a2, char a3);
int __cdecl sub_1000B080(int a1);
int __cdecl sub_1000B090(void *); // idb
int __cdecl sub_1000B110(int a1, int a2);
signed int __cdecl sub_1000B140(int a1, int a2, int a3);
char __cdecl sub_1000B160(_DWORD *a1);
char __cdecl sub_1000B270(int a1, unsigned int a2);
bool __cdecl sub_1000B2A0(const void **a1, int a2);
bool __cdecl sub_1000B2D0(const void **a1, int a2);
bool __cdecl sub_1000B300(const void **a1, int a2);
bool __cdecl sub_1000B330(const void **a1, int a2);
bool __cdecl sub_1000B360(const void **a1, int a2);
bool __cdecl sub_1000B390(int a1, int a2);
bool __cdecl sub_1000B3D0(int a1, int a2);
bool __cdecl sub_1000B410(const void **a1, int a2);
bool __cdecl sub_1000B440(const void **a1, int a2);
char __cdecl sub_1000B470(int a1, unsigned int a2);
bool __cdecl sub_1000B4A0(const void **a1, int a2);
bool __cdecl sub_1000B4D0(const void **a1, int a2);
bool __cdecl sub_1000B500(const void **a1, int a2);
bool __cdecl sub_1000B530(const void **a1, int a2);
bool __cdecl sub_1000B560(const void **a1, int a2);
bool __cdecl sub_1000B590(const void **a1, int a2);
bool __cdecl sub_1000B5C0(const void **a1, int a2);
bool __cdecl sub_1000B5F0(const void **a1, int a2);
bool __cdecl sub_1000B620(const void **a1, int a2);
bool __cdecl sub_1000B650(const void **a1, int a2);
int __cdecl sub_1000B680(int a1, int a2, int a3);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1000B6F0(int a1, char a2);
int __cdecl sub_1000B710(int a1, int a2, int a3);
int __cdecl sub_1000B740(int a1, int a2, int a3, int a4);
int __cdecl sub_1000B770(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1000B7B0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000B7F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1000B840(int a1);
char __cdecl sub_1000B870(int a1);
char __cdecl sub_1000B880(int a1, int a2);
signed int __cdecl sub_1000BA00(int a1);
signed int __cdecl sub_1000BA40(int a1, int a2, int a3);
char __cdecl sub_1000BAE0(int a1);
char __cdecl sub_1000BB40(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1000BBB0(char *a1);
int __cdecl sub_1000BC50(int a1, int a2, int a3);
bool __cdecl sub_1000BCC0(int a1, unsigned int a2, int a3);
char __cdecl sub_1000BD50(int a1, int a2, char a3, char a4);
char __cdecl sub_1000BE00(int a1);
char __cdecl sub_1000BE10(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1000BE90(int a1, const char *a2))(const char *);
signed int __cdecl sub_1000BEE0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1000BF30(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1000C0B0();
const char *__cdecl sub_1000C0C0(unsigned int a1);
int __cdecl sub_1000C0E0(int a1, int a2, int a3, int a4);
int __cdecl sub_1000C190(int a1);
int __cdecl sub_1000C1B0(int a1);
char *sub_1000C1D0(char *a1, ...);
// char *__usercall sub_1000C210@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1000C230@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1000C410();
int sub_1000C430();
int __cdecl sub_1000C450(int a1, int a2);
int __cdecl sub_1000C4B0(int a1);
int __cdecl sub_1000C4C0(int a1, int a2);
int __cdecl sub_1000C520(int a1);
bool __cdecl sub_1000C530(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000C670(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000CA20(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1000CE70(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1000D330(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000D6F0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1000DAF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000DEB0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1000E3F0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1000E7D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000EB90(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000EF30(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1000F330(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000F6D0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1000FCB0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_100100A0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10010440();
// BOOL __usercall sub_10010470@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_100105E0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10010850(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10010B50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10010C00(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_10010C40(int a1, int a2);
char __cdecl sub_10010C80(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10011A30(int a1, int a2);
char **__cdecl sub_10011AB0(int a1);
int (**sub_10011AF0())();
int (__cdecl *__cdecl sub_10011B00(const char *a1))(const char *);
const char *sub_10011B20();
__int64 sub_10011B30();
const char *sub_10011B40();
// int __usercall sub_10011B50@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10011BA0(int a1, int a2);
int sub_10011BD0(); // weak
// int __usercall sub_10011CF0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10012070(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10012E90(int a1);
int sub_10012F00();
char __cdecl sub_10012F30(int a1);
int __cdecl sub_10012F50(int, char *); // idb
char __thiscall sub_10012FB0(void *this);
int __thiscall sub_10012FD0(void *this);
char sub_10012FF0();
int __cdecl sub_10013070(char a1);
// signed int __usercall sub_10013090@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10013130@<eax>(char a1@<al>);
// int __usercall sub_10013150@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10013170@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_100133B0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10013530(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10013690(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_100137D0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_100138B0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10013B30(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10013B60(char a1, int a2, void *a3);
char __cdecl sub_10013B90(char a1, int a2, void *a3, int a4);
char __cdecl sub_10013BC0(char a1);
int __cdecl sub_10013C00(char a1);
signed int __cdecl sub_10013C50(char a1, char a2);
int __cdecl sub_10013CB0(char a1);
signed int __cdecl sub_10013CF0(char a1, char a2, char a3);
int __cdecl sub_10013D60(char a1);
int __cdecl sub_10013DA0(char a1);
char __cdecl sub_10013DE0(char a1, int a2);
char __cdecl sub_10013E00(char a1, int a2);
char __cdecl sub_10013E30(char a1, int a2);
char __cdecl sub_10013E80(char a1, int a2);
char __cdecl sub_10013EB0(char a1, int a2);
char __cdecl sub_10013ED0(int a1);
char __cdecl sub_10013EF0(char a1);
char __cdecl sub_10013F30(char a1);
signed int __cdecl sub_10013FA0(char a1);
char __cdecl sub_10014020(char a1);
char __cdecl sub_10014090(char a1);
char __cdecl sub_10014140(int a1);
char __thiscall sub_10014240(void *this);
char __cdecl sub_10014250(char a1);
char sub_10014280();
BOOL __cdecl sub_10014320(int a1, int a2);
char __cdecl sub_10014340(int a1, char a2, int a3, int a4, int a5);
int __cdecl sub_10014380(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10014510(int a1);
char __cdecl sub_10014520(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10014560(const char *a1, int a2);
// char *__usercall sub_100145D0@<eax>(char *result@<eax>);
void __cdecl sub_10014600(char *a1);
void __cdecl sub_100146C0(char *a1, char *a2);
void *__cdecl sub_10014720(int a1);
int __cdecl sub_100148B0(int a1, int a2);
// char __usercall sub_100149F0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10014AC0(_DWORD *a1, char *a2);
BOOL __cdecl sub_10014BA0(unsigned int a1);
BOOL __cdecl sub_10014BC0(int a1);
_DWORD __cdecl sub_10014BE0(_DWORD); // weak
unsigned int __cdecl sub_10014BF0(int a1, char a2);
signed int __cdecl sub_10014C50(void *a1, int a2, unsigned int a3);
int __cdecl sub_10014C70(int a1, int a2, int a3);
char __cdecl sub_10014C90(const char *a1, const char *a2);
int __cdecl sub_10014DD0(int a1, int a2, unsigned int a3);
int sub_10014E50();
void __cdecl sub_10014E60(int a1);
int __cdecl sub_10014E90(int a1);
bool __cdecl sub_10014EB0(int a1);
void *__cdecl sub_10014EE0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10014F20@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10014F40@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10014F60(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10014F90(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10015070(int a1, int a2, int a3);
// void *__usercall sub_10015120@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100153A0(int a1, int a2);
char __cdecl sub_10015470(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_100154E0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10015840@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10015950(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10015AE0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10015C30@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10015D80(int a1, int a2);
signed int __cdecl sub_10015DC0(int a1, int a2);
bool __cdecl sub_10015E20(signed int a1);
int sub_10015E90();
char sub_100161B0();
char sub_100163D0();
char sub_100165D0();
char sub_10016750();
char sub_100168D0();
char sub_10016A40();
char sub_10016B40();
char sub_10016CA0();
char sub_10016E00();
char sub_10016F60();
char sub_100170D0();
char sub_10017230();
char sub_10017390();
char sub_100175B0();
char sub_10017710();
char sub_10017870();
char sub_100179D0();
char sub_10017B40();
char sub_10017CA0();
char sub_10017E00();
char sub_10018020();
char sub_10018220();
char sub_100183A0();
char sub_10018520();
char sub_10018690();
char sub_10018780();
char sub_100188E0();
char sub_10018A40();
char sub_10018BA0();
char sub_10018D10();
char sub_10018E70();
char sub_10018FD0();
char sub_100191D0();
char sub_10019330();
char sub_10019490();
char sub_100195F0();
char sub_10019760();
char sub_100198C0();
char sub_10019A20();
char sub_10019FC0();
char sub_1001A1D0();
char sub_1001A3C0();
char sub_1001A530();
char sub_1001A6A0();
char sub_1001A800();
char sub_1001A8F0();
char sub_1001AA50();
char sub_1001ABB0();
char sub_1001AD10();
char sub_1001AE80();
char sub_1001AFE0();
char sub_1001B140();
char sub_1001B340();
char sub_1001B4A0();
char sub_1001B600();
char sub_1001B760();
char sub_1001B8D0();
char sub_1001BA30();
char sub_1001BB90();
char sub_1001BDA0();
char sub_1001BF90();
char sub_1001C100();
char sub_1001C270();
char sub_1001C3D0();
char sub_1001C4C0();
char sub_1001C620();
char sub_1001C780();
char sub_1001C8E0();
char sub_1001CA50();
char sub_1001CBB0();
char sub_1001CD10();
char sub_1001CF10();
char sub_1001D070();
char sub_1001D1D0();
char sub_1001D330();
char sub_1001D4A0();
char sub_1001D600();
char **sub_1001D760();
int __cdecl sub_1001D770(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1001D790@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1001D7A0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1001D9D0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1001DA20(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1001DA70(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1001DAC0(int a1))(int);
int __cdecl sub_1001DB40(int a1, int a2);
int (__cdecl *__cdecl sub_1001DBC0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1001DC10(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1001DC50(int a1, int a2, int a3))(int);
signed int __cdecl sub_1001DCB0(_BYTE *a1, char a2, int a3);
int __cdecl sub_1001DD00(int, float, float, int, int); // idb
unsigned int __cdecl sub_1001DDF0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1001DE40(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1001DF00(void *a1, size_t a2, int a3);
int __cdecl sub_1001DF60(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1001DFB0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1001E050(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_1001E100(char *a1, char a2);
bool __cdecl sub_1001E170(int a1, void *a2);
char __cdecl sub_1001E230(int a1, bool *a2);
char __cdecl sub_1001E2F0(int a1, int a2);
signed int __fastcall sub_1001E410(unsigned __int8 a1);
char __cdecl sub_1001E420(unsigned __int8 a1);
__int16 __cdecl sub_1001E440(unsigned __int8 a1);
int __cdecl sub_1001E460(char a1);
int __cdecl sub_1001E480(int, void *); // idb
// int __usercall sub_1001E4E0@<eax>(char a1@<al>);
BOOL __cdecl sub_1001E510(char a1, int a2);
int __cdecl sub_1001E540(int, char, int, int, void *); // idb
char __cdecl sub_1001E570(void *a1);
BOOL __cdecl sub_1001E590(int a1);
char __cdecl sub_1001E5B0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1001E5E0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1001E670(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_1001E710(char a1, void *a2);
// signed int __usercall sub_1001E750@<eax>(char a1@<al>);
bool __cdecl sub_1001E770(char a1, void *a2);
bool __cdecl sub_1001E860(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1001E890(unsigned __int8 a1);
// BOOL __usercall sub_1001E8A0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1001E8D0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1001EA80(unsigned __int8 a1, int a2);
bool __cdecl sub_1001EAC0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char __cdecl sub_1001EBB0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1001EC50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001ECD0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001ED40(char a1, void *a2);
char __cdecl sub_1001EDC0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001EE40(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001EEC0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001EF30(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1001F040(char a1, void *a2);
bool __cdecl sub_1001F060(unsigned __int8 a1, char *a2);
char __cdecl sub_1001F0A0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1001F0E0();
char __cdecl sub_1001F140(int a1, char *a2);
BOOL __cdecl sub_1001F230(int a1, int a2);
char __cdecl sub_1001F250(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1001F290(int a1, int a2);
BOOL __cdecl sub_1001F340(int a1, int a2);
char __cdecl sub_1001F360(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1001F3A0(void *a1);
char __cdecl sub_1001F3C0(void *a1);
char __cdecl sub_1001F510(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1001F6B0(char a1);
// __int16 __usercall sub_1001F6F0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1001F700(unsigned __int8 a1, char *a2);
char __cdecl sub_1001F7D0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1001F850(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1001F960(char a1);
char __cdecl sub_1001F9B0(char a1, int a2);
// int __usercall sub_1001FB20@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1001FB60@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1001FBA0();
char __cdecl sub_1001FBB0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1001FC10(char a1, void *a2);
char __cdecl sub_1001FD30(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001FDB0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_1001FF60(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10020090(char a1, int a2);
bool __cdecl sub_10020110(void *a1);
char __cdecl sub_10020160(char a1, int a2);
// __int16 __usercall sub_10020240@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10020250(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_100202E0(unsigned __int8 a1, char a2);
bool __cdecl sub_100203A0(__int16 a1, char a2, int a3, int a4, void *a5);
unsigned int __cdecl sub_100204A0(char *a1);
int __cdecl sub_100204C0(_BYTE *a1);
int __cdecl sub_100204E0(unsigned __int8 *a1);
unsigned int __cdecl sub_10020500(int a1, int a2);
unsigned int __cdecl sub_10020830(int a1, int a2);
unsigned int __cdecl sub_10020C70(_BYTE *a1);
int __cdecl sub_10020C90(unsigned __int8 *a1);
int __cdecl sub_10020CB0(unsigned __int8 *a1);
int __cdecl sub_10020CD0(_BYTE *a1);
int __cdecl sub_10020CF0(int a1);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10020D40(unsigned __int8 *a1);
int __cdecl sub_10020D60(int a1);
unsigned int __cdecl sub_10020DF0(int a1);
signed int __cdecl sub_10020E10(int a1);
unsigned int __cdecl sub_10020E60(int a1);
int __cdecl sub_10020EC0(_BYTE *a1);
unsigned int __cdecl sub_10020EE0(_BYTE *a1);
int __cdecl sub_10020F00(unsigned __int8 *a1);
int __cdecl sub_10020F20(_BYTE *a1);
signed int __cdecl sub_10020F40(_BYTE *a1, int a2);
int __cdecl sub_10020F70(_BYTE *a1, int a2);
int __cdecl sub_10020FB0(int a1, int a2);
int __cdecl sub_10021040(unsigned __int8 *a1);
int __cdecl sub_10021060(int a1);
int __cdecl sub_10021090(unsigned __int8 *a1);
unsigned int __cdecl sub_100210B0(int a1);
int __cdecl sub_100210E0(int a1);
int __cdecl sub_100211D0(int a1);
signed int __cdecl sub_100212E0(_BYTE *a1, int a2);
signed int __cdecl sub_10021310(unsigned __int8 *a1, int a2);
int __cdecl sub_10021340(unsigned __int8 *a1);
int __cdecl sub_100213A0(int a1);
signed int __cdecl sub_100213B0(_BYTE *a1, int a2);
int __cdecl sub_100213E0(int a1, int a2);
unsigned int __cdecl sub_10021460(int a1);
unsigned int __cdecl sub_100214A0(int a1);
int __cdecl sub_100214F0(int a1);
int __cdecl sub_10021520(int a1);
unsigned int __cdecl sub_10021550(int a1);
unsigned int __cdecl sub_10021580(int a1);
unsigned int __cdecl sub_100215A0(int a1);
void __cdecl __noreturn sub_100215E0(int a1);
signed int __cdecl sub_10021750(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_100217B0@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10021880(int a1);
char __cdecl sub_10021890(char a1);
int __cdecl sub_10021910(unsigned __int8 *a1);
unsigned int __cdecl sub_10021930(void *a1);
unsigned int __cdecl sub_10021950(void *a1);
unsigned int __cdecl sub_10021970(void *a1);
unsigned int __cdecl sub_10021990(void *a1);
unsigned int __cdecl sub_100219B0(void *a1);
unsigned int __cdecl sub_100219D0(void *a1);
char __cdecl sub_10021A30(char a1);
char __cdecl sub_10021A60(char a1, void *a2);
int __cdecl sub_10021AE0(char a1, _DWORD *a2);
char __cdecl sub_10021B30(char a1);
char __cdecl sub_10021B70(char a1);
int __cdecl sub_10021B90(char a1, char a2);
// bool __usercall sub_10021C40@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10021C70@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10021D10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10021D90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10021E10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10021E90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10021F10(char a1);
int __cdecl sub_10021FB0(unsigned __int8 *a1, int a2);
bool __cdecl sub_10021FE0(void *a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl j_IOP_pvg_sk_get_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10022070(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_100220C0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_10022130(int a1);
char __cdecl sub_10022150(int a1, char *a2, size_t a3, char a4);
char __cdecl sub_100221C0(int a1, unsigned int a2);
int __cdecl sub_10022220(void *, int); // idb
char __cdecl sub_10022250(int a1, int a2);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10022300(unsigned int a1);
signed int __cdecl sub_10022340(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_10022380(int, void *); // idb
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100223C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10022440(unsigned int a1, void *a2, int a3);
int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10022490(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_rmdir(_DWORD); // weak
int __cdecl sub_10022530(int, void *, int, int, int); // idb
signed int __cdecl sub_10022640(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10022690(int a1, int a2);
__int64 __cdecl sub_100226B0(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_100226E0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10022710(int a1, int a2, int a3, char a4);
int __cdecl j_fil_vfs_set_iattr(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
char __cdecl sub_10022740(int a1);
int __cdecl sub_10022770(int, void *); // idb
signed int __cdecl sub_100227F0(unsigned int a1, int a2, int a3);
int __cdecl sub_10022810(int a1, int *a2, int *a3);
int __cdecl sub_10022870(int a1, int a2, int a3);
int __cdecl sub_10022890(int a1);
int sub_100228B0();
__int16 __cdecl sub_100228D0(int a1);
int sub_100228F0();
int __cdecl sub_10022910(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10022950(int a1, int a2, int a3, int a4);
int __cdecl sub_10022980(int a1);
int __cdecl sub_100229A0(int a1, int a2);
int __cdecl sub_100229D0(int a1, int a2);
int __cdecl sub_10022A00(int a1, int a2);
int __cdecl sub_10022A30(int a1);
int __cdecl sub_10022A50(int a1);
int __cdecl sub_10022A70(_BYTE *a1);
int __cdecl sub_10022AB0(int a1, int a2);
int __cdecl sub_10022AE0(int a1, int a2);
int __cdecl sub_10022B00(int a1, int a2, int a3);
char __cdecl sub_10022B20(int a1, int a2, int a3);
int __cdecl sub_10022B60(int a1, int a2, int a3);
int __cdecl sub_10022B90(int a1, int a2, int a3);
int __cdecl sub_10022BB0(int, void *, int, void *); // idb
int sub_10022C00(void); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl sub_10022C40(int a1);
int __cdecl sub_10022C80(int a1);
int __cdecl sub_10022CC0(int a1);
int __cdecl sub_10022D00(int a1);
int __cdecl sub_10022D40(int a1, int a2, int a3, int a4);
int __cdecl sub_10022DB0(int a1, int a2, int a3);
int __cdecl sub_10022E50(int a1, int a2);
// int __usercall sub_10022EB0@<eax>(const char **a1@<esi>);
// int __usercall sub_100231B0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100231D0(int a1);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_100232B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10023460@<eax>(int a1@<esi>);
int __cdecl sub_10023510(int a1, unsigned __int64 a2);
// int __usercall sub_100235C0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10023650(int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
int __cdecl sub_100237B0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_100237D0(unsigned int *a1, signed int a2, unsigned int a3);
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_wait_for_status(_DWORD); weak
// int FIL_vfs_close(void); weak
// int FIL_vfs_fstat(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl rand();
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl toupper(int);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int sprintf(char *, const char *, ...);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// char *__cdecl strchr(const char *, int);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_100250C2(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strstr(const char *, const char *);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// int __cdecl isleadbyte(int);
signed int __cdecl sub_10027974(_DWORD *a1);
signed int __cdecl sub_100279AB(_DWORD *a1);
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10027FCC();
int (*sub_10028479())(void);
void __cdecl sub_1002849D(); // idb
int __cdecl sub_10029555(int, FILE *); // idb
int __cdecl sub_1002A0EA(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1002A33A(FILE *, int, struct localeinfo_struct *, int); // idb
// int _get_sse2_info(void); weak
int sub_1002E828();
void sub_1002F19C();
int sub_1002F692();
int __cdecl sub_1002F84F(int a1);
int __cdecl sub_1002F859(int a1);
int __cdecl sub_1002F863(int a1);
int __cdecl sub_1002F942(int a1);
int __cdecl sub_100308BB(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10030961(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_10030D62(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_10030EFE(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10031520(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_10031640(signed int a1);
void **sub_1003169E();
signed int sub_100316A4();
// int __cdecl _fileno(FILE *);
int __cdecl sub_10031A95(FILE *); // idb
int __cdecl sub_10031BB5(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_10031DFD();
int __cdecl sub_100328C8(int a1, int a2, int a3);
signed int __cdecl sub_10032D9B(int a1, int a2);
signed int __cdecl sub_100332DD(int a1, int a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10034BD6(signed int a1);
signed int __cdecl sub_10034C57(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10034D68(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10035069();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10035DD8(signed int a1);
signed int __cdecl sub_10036050(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_100360B0(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_100360D0(unsigned int a1);
bool __cdecl sub_100360F0(int a1);
int __cdecl sub_100361C0(int a1);
int __cdecl sub_100361E0(int a1, int a2);
signed int __cdecl sub_10036220(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_100362E0(int a1);
// int __usercall sub_10036320@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_100363D0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_100365A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100365B0@<eax>(int result@<eax>);
// char __usercall sub_100365D0@<al>(int a1@<eax>);
// int __usercall sub_100365F0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10036630(int a1, int a2);
// int __usercall sub_10036650@<eax>(int a1@<esi>);
// signed int __usercall sub_10036690@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100368A0(int a1);
signed int __cdecl sub_10036B10(unsigned int a1, int a2, int a3);
// int __usercall sub_10036BB0@<eax>(int a1@<eax>);
// int __usercall sub_10036BD0@<eax>(int a1@<edi>, int a2);
// int __usercall sub_10036C00@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_10036CF0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10036D20@<eax>(int a1@<eax>);
signed int __cdecl sub_10036D50(unsigned int a1);
signed int __cdecl sub_10036DA0(int a1, int a2);
signed int __cdecl sub_10036F90(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10036FF0(unsigned int a1, int a2, int a3);
// signed int __usercall sub_10037180@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10038230@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10038290@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10039010@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10039030(int a1, unsigned int a2);
// int __usercall sub_10039090@<eax>(int result@<eax>);
// int __usercall sub_100390D0@<eax>(int result@<eax>);
// unsigned int __usercall sub_1003A7F0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1003A8F0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1003A970@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1003AA10@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1003AAD0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1003AB30@<eax>(char *a1@<edi>);
// int __usercall sub_1003ABF0@<eax>(int a1@<ebx>);
char __cdecl sub_1003ACB0(char *a1, size_t a2, int a3);
char __cdecl sub_1003AD00(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1003AD50(int a1, int a2);
// int __usercall sub_1003AD80@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1003AF90@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1003AFE0(int a1, int a2);
signed int __cdecl sub_1003B070(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1003B1A0(void *a1, int a2);
// BOOL __usercall sub_1003B220@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003B2C0@<eax>(int result@<eax>);
unsigned int __fastcall sub_1003B350(unsigned int a1, int a2);
// int __usercall sub_1003B370@<eax>(int result@<eax>);
// int __usercall sub_1003B400@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1003B880@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1003B930@<eax>(int a1@<edi>);
// int __usercall sub_1003B990@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1003BB60@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1003BBE0(int a1, int a2);
// unsigned int __usercall sub_1003BC50@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1003BE00@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1003BED0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1003BF80@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1003BFC0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1003C020@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1003C100@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003C6A0@<eax>(int a1@<eax>);
// int __usercall sub_1003C8E0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1003C980@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1003CB60@<eax>(int a1@<edi>);
// int __usercall sub_1003CCA0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1003CF50(int a1, int a2);
// signed int __usercall sub_1003D210@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1003D2E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1003D500(int a1, int a2);
signed int __cdecl sub_1003D810(int a1, int a2);
signed int __cdecl sub_1003DC20(int a1, int a2);
int __cdecl sub_1003DD90(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1003DE90(int a1);
// signed int __usercall sub_1003DEB0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1003E350@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1003E3A0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1003E3C0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1003E770@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1003E8B0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1003E900@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1003E9A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1003E9C0(int a1);
// int __usercall sub_1003E9D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1003F070@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1003FA50@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1003FD80(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

int dword_10040360[] = { 0 }; // weak
_UNKNOWN unk_10040364; // weak
_UNKNOWN unk_10040550; // weak
_UNKNOWN unk_100405E0; // weak
_UNKNOWN unk_100405EC; // weak
__int16 word_10040710[] = { 0 }; // weak
char *off_10040718 = "test"; // weak
_UNKNOWN unk_10040738; // weak
_UNKNOWN unk_1004073C; // weak
_UNKNOWN unk_100407E0; // weak
int dword_100407EC[] = { 839520428 }; // weak
_UNKNOWN unk_10040870; // weak
char byte_10040990[] = { '\x02' }; // weak
_UNKNOWN unk_100409DD; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_10041128; // weak
_UNKNOWN unk_10041168; // weak
char byte_100411A8[] = { '9' }; // weak
char byte_100411A9[] = { '1' }; // weak
char byte_100411AA[] = { ')' }; // weak
char byte_100411AB[] = { '!' }; // weak
char byte_100411E0[] = { '\x01' }; // weak
char byte_100411EF[] = { '\x1C' }; // weak
char byte_100411F0[] = { '\x0E' }; // weak
_UNKNOWN unk_10041220; // weak
char byte_10041420[] = { '\x10' }; // weak
int dword_10041440[] = { 128 }; // weak
int dword_10041444[] = { 64 }; // weak
int dword_10041448[] = { 32 }; // weak
int dword_1004144C[] = { 16 }; // weak
int dword_10041450[] = { 8 }; // weak
int dword_10041454[] = { 4 }; // weak
int dword_10041460[] = { 8 }; // weak
_UNKNOWN unk_10041470; // weak
_BYTE word_100414B6[58] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66,
  67,
  68,
  69,
  70,
  0,
  0,
  0,
  0,
  87,
  83,
  0,
  0,
  69,
  78,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char *off_10041DD8[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10041C48 }; // weak
_UNKNOWN unk_10041DEC; // weak
int (*off_10042460[4])() = { &sub_100080B0, &sub_100080A0, &sub_10008090, &sub_100080A0 }; // weak
_UNKNOWN unk_10044508; // weak
char *off_100446AC[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100446C0 }; // weak
char *off_10044850 = "true"; // weak
char byte_10044854[] = { '\x01' }; // weak
char *off_100448B8 = "failure listener"; // weak
_UNKNOWN unk_10045060; // weak
char *off_10045270[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10045278[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10045280[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1004529C[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100452A8[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100452B0[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_10045568; // weak
_UNKNOWN unk_100455AC; // weak
char *off_10045970 = "printf_listener"; // weak
__int16 word_100465A4 = 2573; // weak
int (*off_10046660[2])() = { &sub_1001D760, &sub_10008080 }; // weak
char *off_10046710 = "gate_listener"; // weak
int dword_10049F6C[] = { 88 }; // weak
__int16 word_1004A41C[] = { 836 }; // weak
char *off_1004A43C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1004A450 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1004A464 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1004A478 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1004A48C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1004A4A0 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_1004C150; // weak
int dword_1004C154[] = { 0 }; // weak
_UNKNOWN unk_1004C4D0; // weak
_UNKNOWN unk_1004C4E8; // weak
_UNKNOWN unk_1004C530; // weak
int dword_1004C534[] = { 6767 }; // weak
_UNKNOWN unk_1004C540; // weak
_UNKNOWN unk_1004C558; // weak
_UNKNOWN unk_1004C570; // weak
int dword_1004C574[] = { 6769 }; // weak
_UNKNOWN unk_1004C588; // weak
int dword_1004C58C[] = { 6093 }; // weak
_UNKNOWN unk_1004EC20; // weak
_UNKNOWN unk_1004EC44; // weak
_UNKNOWN unk_1004EDE8; // weak
char off_1004FA18[] = { '\\', 'R', '\x04', '\x10' }; // idb
int dword_1004FA34 = 1; // idb
char byte_1004FA50[] = { '\x01' }; // weak
char *off_1004FA54[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_1004FA58[2] = { "2", "fail_normal_1" }; // weak
char off_1004FA5C[8] = { '\0', '', '\x04', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1004FAE0[] = { '\0' }; // weak
char byte_1004FAE1[] = { '\0' }; // weak
int dword_1004FAE4[] = { 0 }; // weak
char *off_1004FAE8 = "0, 0, 0"; // weak
double dbl_1004FD50[] = {  0.0 }; // weak
double dbl_1004FD58[] = {  0.0 }; // weak
double dbl_1004FD60[] = {  0.0 }; // weak
int dword_1004FD68[] = { 0 }; // weak
char off_1004FD6C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10050970[] = {  0.0 }; // weak
float flt_10050974[] = {  0.0 }; // weak
float flt_10050978[] = {  0.0 }; // weak
int dword_1005097C[] = { 0 }; // weak
char *off_10050980 = "0, 0, 0"; // weak
char *off_10051104[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_10065D60
}; // weak
int dword_10051118[] = { 0 }; // weak
int dword_1005111C[] = { 0 }; // weak
int dword_10051120[] = { 0 }; // weak
int dword_10051124[] = { 0 }; // weak
char off_10051128[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100518B0[] = { 0 }; // weak
__int16 word_100518B2[] = { 0 }; // weak
__int16 word_100518B4[] = { 0 }; // weak
int dword_100518B8[] = { 0 }; // weak
char off_100518BC[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10051EC0[] = { 0 }; // weak
int dword_10051EC4[] = { 0 }; // weak
int dword_10051EC8[] = { 0 }; // weak
int dword_10051ECC[] = { 0 }; // weak
char *off_10051ED0 = "0, 0, 0"; // weak
int dword_10052658[] = { 0 }; // weak
int dword_1005265C[] = { 0 }; // weak
int dword_10052660[] = { 0 }; // weak
int dword_10052664[] = { 0 }; // weak
int dword_10052668[] = { 0 }; // weak
int dword_1005266C[] = { 0 }; // weak
int dword_10052670[] = { 0 }; // weak
char off_10052674[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10053278[] = { '\0' }; // weak
char byte_10053279[] = { '\0' }; // weak
char byte_1005327A[] = { '\0' }; // weak
int dword_1005327C[] = { 0 }; // weak
char *off_10053280 = "0, 0, 0"; // weak
int dword_10053708[] = { 0 }; // weak
int dword_1005370C[] = { 0 }; // weak
int dword_10053710[] = { 0 }; // weak
int dword_10053714[] = { 0 }; // weak
char off_10053718[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10053EA0[] = { 0 }; // weak
int dword_10053EA4[] = { 0 }; // weak
int dword_10053EA8[] = { 0 }; // weak
int dword_10053EAC[] = { 0 }; // weak
char *off_10053EB0 = "0, 0, 0"; // weak
__int16 word_10054210[] = { 0 }; // weak
__int16 word_10054212[] = { 0 }; // weak
__int16 word_10054214[] = { 0 }; // weak
int dword_10054218[] = { 0 }; // weak
char off_1005421C[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100544D0[] = { 0 }; // weak
int dword_100544D4[] = { 0 }; // weak
int dword_100544D8[] = { 0 }; // weak
int dword_100544DC[] = { 0 }; // weak
char *off_100544E0 = "0, 0, 0"; // weak
int dword_10054840[] = { 0 }; // weak
int dword_10054844[] = { 0 }; // weak
int dword_10054848[] = { 0 }; // weak
int dword_1005484C[] = { 0 }; // weak
int dword_10054850[] = { 0 }; // weak
int dword_10054854[] = { 0 }; // weak
int dword_10054858[] = { 0 }; // weak
char off_1005485C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10054DC0[] = { '\0' }; // weak
char byte_10054DC1[] = { '\0' }; // weak
char byte_10054DC2[] = { '\0' }; // weak
int dword_10054DC4[] = { 0 }; // weak
char *off_10054DC8 = "0, 0, 0"; // weak
int dword_10054FD0[] = { 0 }; // weak
int dword_10054FD4[] = { 0 }; // weak
int dword_10054FD8[] = { 0 }; // weak
int dword_10054FDC[] = { 0 }; // weak
char *off_10054FE0 = "0, 0, 0"; // weak
char byte_10055340[] = { '\x01' }; // weak
char *off_10055344[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_10055348[2] = { "2", "fail_robust_1" }; // weak
char off_1005534C[8] = { 'x', '', '\x04', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100553D0[] = { '\0' }; // weak
char byte_100553D1[] = { '\0' }; // weak
int dword_100553D4[] = { 0 }; // weak
char *off_100553D8 = "0, 0, 0"; // weak
double dbl_10055640[] = {  0.0 }; // weak
double dbl_10055648[] = {  0.0 }; // weak
double dbl_10055650[] = {  0.0 }; // weak
int dword_10055658[] = { 0 }; // weak
char off_1005565C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10056260[] = {  0.0 }; // weak
float flt_10056264[] = {  0.0 }; // weak
float flt_10056268[] = {  0.0 }; // weak
int dword_1005626C[] = { 0 }; // weak
char *off_10056270 = "0, 0, 0"; // weak
int dword_100569F8[] = { 0 }; // weak
int dword_100569FC[] = { 0 }; // weak
int dword_10056A00[] = { 0 }; // weak
int dword_10056A04[] = { 0 }; // weak
char off_10056A08[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10057190[] = { 0 }; // weak
__int16 word_10057192[] = { 0 }; // weak
__int16 word_10057194[] = { 0 }; // weak
int dword_10057198[] = { 0 }; // weak
char off_1005719C[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100577A0[] = { 0 }; // weak
int dword_100577A4[] = { 0 }; // weak
int dword_100577A8[] = { 0 }; // weak
int dword_100577AC[] = { 0 }; // weak
char *off_100577B0 = "0, 0, 0"; // weak
int dword_10057F38[] = { 0 }; // weak
int dword_10057F3C[] = { 0 }; // weak
int dword_10057F40[] = { 0 }; // weak
int dword_10057F44[] = { 0 }; // weak
int dword_10057F48[] = { 0 }; // weak
int dword_10057F4C[] = { 0 }; // weak
int dword_10057F50[] = { 0 }; // weak
char off_10057F54[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10058B58[] = { '\0' }; // weak
char byte_10058B59[] = { '\0' }; // weak
char byte_10058B5A[] = { '\0' }; // weak
int dword_10058B5C[] = { 0 }; // weak
char *off_10058B60 = "0, 0, 0"; // weak
int dword_10058FE8[] = { 0 }; // weak
int dword_10058FEC[] = { 0 }; // weak
int dword_10058FF0[] = { 0 }; // weak
int dword_10058FF4[] = { 0 }; // weak
char off_10058FF8[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10059780[] = { 0 }; // weak
int dword_10059784[] = { 0 }; // weak
int dword_10059788[] = { 0 }; // weak
int dword_1005978C[] = { 0 }; // weak
char *off_10059790 = "0, 0, 0"; // weak
__int16 word_10059AF0[] = { 0 }; // weak
__int16 word_10059AF2[] = { 0 }; // weak
__int16 word_10059AF4[] = { 0 }; // weak
int dword_10059AF8[] = { 0 }; // weak
char off_10059AFC[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10059DB0[] = { 0 }; // weak
int dword_10059DB4[] = { 0 }; // weak
int dword_10059DB8[] = { 0 }; // weak
int dword_10059DBC[] = { 0 }; // weak
char *off_10059DC0 = "0, 0, 0"; // weak
int dword_1005A120[] = { 0 }; // weak
int dword_1005A124[] = { 0 }; // weak
int dword_1005A128[] = { 0 }; // weak
int dword_1005A12C[] = { 0 }; // weak
int dword_1005A130[] = { 0 }; // weak
int dword_1005A134[] = { 0 }; // weak
int dword_1005A138[] = { 0 }; // weak
char off_1005A13C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1005A6A0[] = { '\0' }; // weak
char byte_1005A6A1[] = { '\0' }; // weak
char byte_1005A6A2[] = { '\0' }; // weak
int dword_1005A6A4[] = { 0 }; // weak
char *off_1005A6A8 = "0, 0, 0"; // weak
int dword_1005A8B0[] = { 0 }; // weak
int dword_1005A8B4[] = { 0 }; // weak
int dword_1005A8B8[] = { 0 }; // weak
int dword_1005A8BC[] = { 0 }; // weak
char *off_1005A8C0 = "0, 0, 0"; // weak
char byte_1005AC20[] = { '\x01' }; // weak
char *off_1005AC24[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_1005AC28[2] = { "1", "pass_normal_1" }; // weak
char off_1005AC2C[8] = { '', '', '\x04', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1005AC70[] = { '\0' }; // weak
char byte_1005AC71[] = { '\0' }; // weak
int dword_1005AC74[] = { 0 }; // weak
char *off_1005AC78 = "0, 0, 0"; // weak
double dbl_1005AEE0[] = {  0.0 }; // weak
double dbl_1005AEE8[] = {  0.0 }; // weak
double dbl_1005AEF0[] = {  0.0 }; // weak
int dword_1005AEF8[] = { 0 }; // weak
char off_1005AEFC[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1005BB00[] = {  0.0 }; // weak
float flt_1005BB04[] = {  0.0 }; // weak
float flt_1005BB08[] = {  0.0 }; // weak
int dword_1005BB0C[] = { 0 }; // weak
char *off_1005BB10 = "0, 0, 0"; // weak
int dword_1005C298[] = { 0 }; // weak
int dword_1005C29C[] = { 0 }; // weak
int dword_1005C2A0[] = { 0 }; // weak
int dword_1005C2A4[] = { 0 }; // weak
char off_1005C2A8[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1005CA30[] = { 0 }; // weak
__int16 word_1005CA32[] = { 0 }; // weak
__int16 word_1005CA34[] = { 0 }; // weak
int dword_1005CA38[] = { 0 }; // weak
char off_1005CA3C[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1005D040[] = { 0 }; // weak
int dword_1005D044[] = { 0 }; // weak
int dword_1005D048[] = { 0 }; // weak
int dword_1005D04C[] = { 0 }; // weak
char *off_1005D050 = "0, 0, 0"; // weak
int dword_1005D7D8[] = { 0 }; // weak
int dword_1005D7DC[] = { 0 }; // weak
int dword_1005D7E0[] = { 0 }; // weak
int dword_1005D7E4[] = { 0 }; // weak
int dword_1005D7E8[] = { 0 }; // weak
int dword_1005D7EC[] = { 0 }; // weak
int dword_1005D7F0[] = { 0 }; // weak
char off_1005D7F4[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1005E3F8[] = { '\0' }; // weak
char byte_1005E3F9[] = { '\0' }; // weak
char byte_1005E3FA[] = { '\0' }; // weak
int dword_1005E3FC[] = { 0 }; // weak
char *off_1005E400 = "0, 0, 0"; // weak
int dword_1005E888[] = { 0 }; // weak
int dword_1005E88C[] = { 0 }; // weak
int dword_1005E890[] = { 0 }; // weak
int dword_1005E894[] = { 0 }; // weak
char off_1005E898[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1005F020[] = { 0 }; // weak
int dword_1005F024[] = { 0 }; // weak
int dword_1005F028[] = { 0 }; // weak
int dword_1005F02C[] = { 0 }; // weak
char *off_1005F030 = "0, 0, 0"; // weak
__int16 word_1005F390[] = { 0 }; // weak
__int16 word_1005F392[] = { 0 }; // weak
__int16 word_1005F394[] = { 0 }; // weak
int dword_1005F398[] = { 0 }; // weak
char off_1005F39C[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1005F650[] = { 0 }; // weak
int dword_1005F654[] = { 0 }; // weak
int dword_1005F658[] = { 0 }; // weak
int dword_1005F65C[] = { 0 }; // weak
char *off_1005F660 = "0, 0, 0"; // weak
int dword_1005F9C0[] = { 0 }; // weak
int dword_1005F9C4[] = { 0 }; // weak
int dword_1005F9C8[] = { 0 }; // weak
int dword_1005F9CC[] = { 0 }; // weak
int dword_1005F9D0[] = { 0 }; // weak
int dword_1005F9D4[] = { 0 }; // weak
int dword_1005F9D8[] = { 0 }; // weak
char off_1005F9DC[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1005FF40[] = { '\0' }; // weak
char byte_1005FF41[] = { '\0' }; // weak
char byte_1005FF42[] = { '\0' }; // weak
int dword_1005FF44[] = { 0 }; // weak
char *off_1005FF48 = "0, 0, 0"; // weak
int dword_10060150[] = { 0 }; // weak
int dword_10060154[] = { 0 }; // weak
int dword_10060158[] = { 0 }; // weak
int dword_1006015C[] = { 0 }; // weak
char *off_10060160 = "0, 0, 0"; // weak
char byte_100604C0[] = { '\x01' }; // weak
char *off_100604C4[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100604C8[2] = { "1", "pass_robust_1" }; // weak
char off_100604CC[8] = { '', '', '\x04', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10060510[] = { '\0' }; // weak
char byte_10060511[] = { '\0' }; // weak
int dword_10060514[] = { 0 }; // weak
char *off_10060518 = "0, 0, 0"; // weak
double dbl_10060780[] = {  0.0 }; // weak
double dbl_10060788[] = {  0.0 }; // weak
double dbl_10060790[] = {  0.0 }; // weak
int dword_10060798[] = { 0 }; // weak
char off_1006079C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100613A0[] = {  0.0 }; // weak
float flt_100613A4[] = {  0.0 }; // weak
float flt_100613A8[] = {  0.0 }; // weak
int dword_100613AC[] = { 0 }; // weak
char *off_100613B0 = "0, 0, 0"; // weak
int dword_10061B38[] = { 0 }; // weak
int dword_10061B3C[] = { 0 }; // weak
int dword_10061B40[] = { 0 }; // weak
int dword_10061B44[] = { 0 }; // weak
char off_10061B48[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100622D0[] = { 0 }; // weak
__int16 word_100622D2[] = { 0 }; // weak
__int16 word_100622D4[] = { 0 }; // weak
int dword_100622D8[] = { 0 }; // weak
char off_100622DC[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100628E0[] = { 0 }; // weak
int dword_100628E4[] = { 0 }; // weak
int dword_100628E8[] = { 0 }; // weak
int dword_100628EC[] = { 0 }; // weak
char *off_100628F0 = "0, 0, 0"; // weak
int dword_10063078[] = { 0 }; // weak
int dword_1006307C[] = { 0 }; // weak
int dword_10063080[] = { 0 }; // weak
int dword_10063084[] = { 0 }; // weak
int dword_10063088[] = { 0 }; // weak
int dword_1006308C[] = { 0 }; // weak
int dword_10063090[] = { 0 }; // weak
char off_10063094[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10063C98[] = { '\0' }; // weak
char byte_10063C99[] = { '\0' }; // weak
char byte_10063C9A[] = { '\0' }; // weak
int dword_10063C9C[] = { 0 }; // weak
char *off_10063CA0 = "0, 0, 0"; // weak
int dword_10064128[] = { 0 }; // weak
int dword_1006412C[] = { 0 }; // weak
int dword_10064130[] = { 0 }; // weak
int dword_10064134[] = { 0 }; // weak
char off_10064138[20] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100648C0[] = { 0 }; // weak
int dword_100648C4[] = { 0 }; // weak
int dword_100648C8[] = { 0 }; // weak
int dword_100648CC[] = { 0 }; // weak
char *off_100648D0 = "0, 0, 0"; // weak
__int16 word_10064C30[] = { 0 }; // weak
__int16 word_10064C32[] = { 0 }; // weak
__int16 word_10064C34[] = { 0 }; // weak
int dword_10064C38[] = { 0 }; // weak
char off_10064C3C[16] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10064EF0[] = { 0 }; // weak
int dword_10064EF4[] = { 0 }; // weak
int dword_10064EF8[] = { 0 }; // weak
int dword_10064EFC[] = { 0 }; // weak
char *off_10064F00 = "0, 0, 0"; // weak
int dword_10065260[] = { 0 }; // weak
int dword_10065264[] = { 0 }; // weak
int dword_10065268[] = { 0 }; // weak
int dword_1006526C[] = { 0 }; // weak
int dword_10065270[] = { 0 }; // weak
int dword_10065274[] = { 0 }; // weak
int dword_10065278[] = { 0 }; // weak
char off_1006527C[32] =
{
  'h',
  '',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100657E0[] = { '\0' }; // weak
char byte_100657E1[] = { '\0' }; // weak
char byte_100657E2[] = { '\0' }; // weak
int dword_100657E4[] = { 0 }; // weak
char *off_100657E8 = "0, 0, 0"; // weak
int dword_100659F0[] = { 0 }; // weak
int dword_100659F4[] = { 0 }; // weak
int dword_100659F8[] = { 0 }; // weak
int dword_100659FC[] = { 0 }; // weak
char *off_10065A00 = "0, 0, 0"; // weak
_UNKNOWN unk_100669E0; // weak
int dword_10069BBC[] = { 0 }; // weak
_UNKNOWN off_10069BC0; // weak
_UNKNOWN unk_10069C50; // weak
_UNKNOWN unk_10069C54; // weak
_UNKNOWN unk_10069C58; // weak
_UNKNOWN unk_10069C5C; // weak
_UNKNOWN unk_10069C60; // weak
_UNKNOWN unk_10069C64; // weak
_UNKNOWN unk_10069C68; // weak
_UNKNOWN unk_10069C6C; // weak
int (__cdecl *off_10084080[3])(char) = { &sub_10014020, &sub_10013F30, &sub_10013EF0 }; // weak
_UNKNOWN unk_10084640; // weak
int dword_10084644[] = { 1312 }; // weak
__int16 word_100848F8[] = { 43 }; // weak
char byte_100848FC[] = { '\x06' }; // weak
_UNKNOWN unk_10084D20; // weak
int dword_10084D24[] = { 6829 }; // weak
int dword_10085B98 = 64; // weak
__int16 word_10085B9C[] = { 6782 }; // weak
__int16 word_10085BA0[] = { 128 }; // weak
_UNKNOWN unk_10085BBC; // weak
_DWORD dword_10085BC0[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_10086FD0[] = { 1565 }; // weak
__int16 word_10086FD4[] = { 534 }; // weak
char byte_10086FD8[] = { '\x04' }; // weak
__int16 word_10086FDA[] = { 6512 }; // weak
int dword_10086FF0[] = { 118000 }; // weak
__int16 word_10087B1A[] = { 233 }; // weak
int dword_10087B20[] = { 6201 }; // weak
__int16 word_1008A6D0[] = { 114 }; // weak
_UNKNOWN unk_1008AF08; // weak
int dword_1008AF0C[] = { 6006 }; // weak
char *off_1008BDB8 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_1008BED8[] = { 551 }; // weak
_UNKNOWN unk_1008FB48; // weak
char byte_1008FB49[] = { '\0' }; // weak
_UNKNOWN unk_10091FD0; // weak
int dword_10091FD4[] = { 0 }; // weak
_UNKNOWN unk_10091FE8; // weak
int dword_10091FEC[] = { 0 }; // weak
_UNKNOWN unk_10092010; // weak
int dword_10092014[] = { 0 }; // weak
_UNKNOWN unk_10092040; // weak
int dword_10092044[] = { 0 }; // weak
char byte_10096702[] = { '\x04' }; // weak
char byte_10096707[] = { '\a' }; // weak
_UNKNOWN unk_100A0378; // weak
int dword_100A037C[] = { 3535 }; // weak
_UNKNOWN unk_100A03B0; // weak
int dword_100A03B4[] = { 6813 }; // weak
_UNKNOWN unk_100A03E8; // weak
int dword_100A03EC[] = { 9036 }; // weak
_UNKNOWN unk_100A0420; // weak
int dword_100A0424[] = { 6763 }; // weak
int dword_100A3E38[] = { 0 }; // weak
_UNKNOWN unk_100AD668; // weak
_WORD dword_100AD6B8[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100ADAB8[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100ADEB8[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100AE2B8[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100AE6B8[] = { 99 }; // weak
int dword_100AEAB8[] = { 25344 }; // weak
int dword_100AEEB8[] = { 6488064 }; // weak
int dword_100AF2B8[] = { 1660944384 }; // weak
int dword_100AF6E0[] = { 128 }; // weak
int dword_100AF6F0[] = { 0 }; // weak
int dword_100AF700[] = { 0 }; // weak
char byte_100AF771[] = { '\0' }; // weak
char byte_100AF772[] = { '\0' }; // weak
char byte_100AF773[] = { '\0' }; // weak
char byte_100AF774[] = { '\x10' }; // weak
int dword_100AF788[] = { 0 }; // weak
_UNKNOWN unk_100AF800; // weak
_UNKNOWN unk_100AFC80; // weak
char byte_100AFCF8[] = { '\0' }; // weak
char byte_100AFDF8[] = { '\0' }; // weak
char byte_100AFEF8[] = { '\0' }; // weak
int dword_100AFFF8[] = { 0 }; // weak
int dword_100B0070[] = { 0 }; // weak
int (__cdecl *off_100B00F0)(int, int) = &sub_1003DC20; // weak
int dword_100B02D8[] = { 0 }; // weak
int dword_100B0320[] = { 16 }; // weak
_UNKNOWN unk_100B0370; // weak
_UNKNOWN unk_100B03F0; // weak
_UNKNOWN unk_100B0470; // weak
_UNKNOWN unk_100B04E8; // weak
_UNKNOWN unk_100B0560; // weak
_UNKNOWN unk_100B1560; // weak
_UNKNOWN unk_100B1730; // weak
_UNKNOWN unk_100B1738; // weak
_UNKNOWN unk_100B3878; // weak
int (*off_100B3964[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
void *off_100B3E70 = &unk_1019D1E0; // weak
_UNKNOWN unk_100B3E80; // weak
_UNKNOWN unk_100B3EE0; // weak
int dword_100B40F0 = 9876; // weak
int dword_100B42EC = 1024; // weak
int dword_100B42F0 = 4294966273; // weak
int dword_100B42F4 = 53; // weak
int dword_100B42F8 = 11; // weak
int dword_100B42FC = 64; // weak
int dword_100B4300 = 1023; // weak
int dword_100B4304 = 128; // weak
int dword_100B4308 = 4294967169; // weak
int dword_100B430C = 24; // weak
int dword_100B4310 = 8; // weak
int dword_100B4314 = 32; // weak
int dword_100B4318 = 127; // weak
int dword_100B4760[] = { 0 }; // weak
int dword_100BC67C; // weak
_UNKNOWN unk_100C4598; // weak
int dword_100C4658[]; // weak
int dword_100CC574; // weak
int dword_100D4490; // weak
int dword_100DC3AC; // weak
int dword_100E42C8; // weak
int dword_100EC1E4; // weak
char byte_100F4100; // weak
char byte_100F4101; // weak
int dword_100F4104[]; // weak
int dword_100F4118; // weak
int dword_100F411C; // weak
int dword_100F4120; // weak
int dword_100F4124; // weak
_UNKNOWN unk_100F4148; // weak
_UNKNOWN unk_100F414C; // weak
int dword_100F4150; // weak
int dword_100F4158; // weak
_UNKNOWN unk_100F4160; // weak
int dword_100F56A0; // weak
char byte_100F56A8[]; // weak
char byte_100F56AC[]; // weak
char byte_100F56AD[]; // weak
int dword_100F56B4[]; // weak
int dword_100F56BC[]; // weak
int dword_100F56F0; // weak
_UNKNOWN unk_100F56F8; // weak
char byte_100F59D0[]; // weak
char byte_100F59D1[]; // weak
_UNKNOWN unk_100F6C38; // weak
int dword_100F85E8[]; // weak
int dword_100F85EC; // weak
int dword_100F85F0; // weak
int dword_100F85F4; // weak
int dword_100F85F8; // weak
int dword_100F85FC[]; // weak
int dword_100F8600; // weak
int dword_100F8604; // weak
int dword_100F8608; // weak
int dword_100F860C; // weak
_UNKNOWN unk_100F8610; // weak
char byte_100F8728; // idb
char byte_100F8828[254]; // idb
char byte_100F8926[]; // weak
char byte_100F8927[]; // weak
char byte_100F8D28[2800]; // idb
char byte_100F9818[1022]; // idb
char byte_100F9C16[]; // weak
char byte_100F9C17[]; // weak
char byte_100F9C18[1022]; // idb
char byte_100FA016[]; // weak
char byte_100FA017[]; // weak
char byte_100FA018[1022]; // idb
char byte_100FA416[]; // weak
char byte_100FA417[]; // weak
int dword_100FD418[]; // weak
int dword_100FD42C[]; // weak
char byte_100FD440[2800]; // idb
char byte_100FDF30[2800]; // idb
char byte_100FEA20[2800]; // idb
int dword_100FF510[]; // weak
int dword_100FF524[]; // weak
char byte_100FF538[2796]; // idb
char byte_10100024[]; // weak
char byte_10100028[559]; // idb
char byte_10100257[]; // weak
int dword_10100B18[]; // weak
int dword_10100B2C[]; // weak
char byte_10100B40[2800]; // idb
int dword_10101630; // weak
_UNKNOWN unk_10101638; // weak
_UNKNOWN unk_10102190; // weak
int dword_10164244; // weak
int dword_10164248; // weak
int dword_10164258; // weak
int dword_1016425C; // weak
int dword_10164268; // weak
int dword_1016426C; // weak
int dword_10164278; // weak
char byte_10164280[]; // weak
char byte_101642D0[]; // weak
char byte_1016B620; // weak
char byte_1016B621; // weak
char byte_10177890[]; // weak
char byte_10177891[]; // weak
_UNKNOWN unk_10177930; // weak
int dword_10177C00[]; // weak
int dword_10177C04[]; // weak
_UNKNOWN unk_10178120; // weak
_UNKNOWN unk_1017B028; // weak
_UNKNOWN unk_1017B528; // weak
_UNKNOWN unk_1017B5D0; // weak
char byte_1017B5F0; // weak
char byte_1017B5F1; // weak
char byte_1017B5F2; // weak
char byte_1017B5F3; // weak
_UNKNOWN unk_1017B5F8; // weak
_UNKNOWN unk_1017B618; // weak
_DWORD dword_10181F38[16]; // idb
int dword_10181F78[]; // weak
int dword_10181FB8; // weak
int dword_10181FC0[]; // weak
int dword_1018F00C; // weak
int dword_1018F398; // weak
int dword_1018F3A4; // weak
int dword_1018F4F0; // weak
int dword_1018F970; // weak
int dword_1018F97C; // weak
int dword_1018F988; // weak
int dword_1018F98C; // weak
int dword_1018F990; // weak
int dword_1018FA60; // weak
int dword_1018FA64; // weak
int dword_1018FA68; // weak
int dword_1018FA6C; // weak
int dword_1018FA70; // weak
int dword_1019D1CC; // weak
int dword_1019D1D4; // weak
void *dword_1019D1D8; // idb
int dword_1019E1E0; // weak
int dword_1019E1FC; // weak
UINT uNumber; // idb
int dword_1019E220[]; // weak
int dword_1019E320; // weak
int dword_1019E338; // weak


//----- (10001000) --------------------------------------------------------
BOOL __cdecl sub_10001000(unsigned int a1, int a2, unsigned int a3, int a4)
{
  return !a4 || a3 >= a1 && a4 >= 0 && a2 + a1 >= a4 + a3;
}

//----- (10001030) --------------------------------------------------------
char __cdecl sub_10001030(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax@1

  v3 = a1;
  *v3 |= 1u;
  if ( !a3 )
    LOBYTE(v3) = sub_100072A0("..\\lib\\acl\\iop\\iop_net_cifs.c", 310, 0, 0);
  return (unsigned int)v3;
}

//----- (10001060) --------------------------------------------------------
unsigned int __cdecl sub_10001060(int a1, int a2)
{
  return (a1 - a2) / 0x7F1Cu;
}

//----- (10001080) --------------------------------------------------------
int __cdecl sub_10001080(int a1, int a2, char a3, int a4)
{
  int v4; // eax@3
  int v5; // eax@3
  signed int v6; // edx@3
  signed int v7; // ecx@3
  unsigned int v8; // eax@3
  int v9; // edi@6
  int v10; // ebp@6
  int v11; // eax@6
  int v12; // eax@7
  int v13; // ebx@9

  *(_DWORD *)a1 = 2;
  if ( a3 )
    *(_DWORD *)a1 = 6;
  *(_WORD *)(a1 + 4) = 28672;
  memset((void *)(a1 + 6), 0, 0x7006u);
  v4 = rand();
  *(_BYTE *)(a1 + 28736) = v4;
  *(_BYTE *)(a1 + 28737) = v4 >> 1;
  *(_BYTE *)(a1 + 28738) = v4 >> 2;
  *(_BYTE *)(a1 + 28739) = v4 >> 3;
  v5 = rand();
  *(_BYTE *)(a1 + 28740) = v5 >> 4;
  v6 = v5;
  v7 = v5;
  *(_BYTE *)(a1 + 28743) = v5 >> 7;
  v8 = *(_DWORD *)(a1 + 28732);
  *(_BYTE *)(a1 + 28741) = v6 >> 5;
  *(_BYTE *)(a1 + 28742) = v7 >> 6;
  if ( v8 < 0xFFFFFFC2 && v8 )
    j_IOP_pvg_sk_close(v8, *(_DWORD *)(a1 + 28696));
  *(_DWORD *)(a1 + 28744) = *(_DWORD *)(a2 + 20);
  *(_BYTE *)(a1 + 28748) = *(_BYTE *)(a2 + 24);
  *(_DWORD *)(a1 + 28716) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 28720) = *(_DWORD *)(a2 + 8);
  v9 = a1 + 28716;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 16);
  v10 = a1 + 28700;
  *(_DWORD *)v10 = 0;
  *(_DWORD *)(v10 + 4) = 0;
  *(_DWORD *)(v10 + 8) = 0;
  *(_DWORD *)(v10 + 12) = 0;
  v11 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
  *(_DWORD *)(a1 + 28732) = v11;
  if ( a3 )
    v12 = j_IOP_pvg_sk_accept(v11, a1 + 28716, a4);
  else
    v12 = j_IOP_pvg_sk_connect(v11, a4);
  v13 = v12;
  j_IOP_pvg_sk_get_addr(*(_DWORD *)(a1 + 28732), a1 + 28700, a1 + 28716);
  return v13;
}
// 10022020: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10022030: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10022040: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10022050: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10022060: using guessed type int __cdecl j_IOP_pvg_sk_get_addr(_DWORD, _DWORD, _DWORD);

//----- (100011D0) --------------------------------------------------------
int __cdecl sub_100011D0(signed __int64 a1)
{
  return sub_100075F0(a1);
}

//----- (10001200) --------------------------------------------------------
int __cdecl sub_10001200(int a1)
{
  int result; // eax@1
  unsigned int v2; // ecx@1
  _BYTE *v3; // edx@1

  result = -1073741823;
  v2 = 0;
  v3 = &unk_10040364;
  while ( *((_DWORD *)v3 - 2) != a1 || !(*v3 & 1) )
  {
    ++v2;
    v3 += 16;
    if ( v2 >= 0xF )
      return result;
  }
  return dword_10040360[4 * v2];
}
// 10040360: using guessed type int dword_10040360[];

//----- (10001240) --------------------------------------------------------
int __cdecl sub_10001240(int a1, unsigned __int16 a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  signed int v4; // ebx@1
  unsigned int v5; // ecx@8
  unsigned int v6; // ecx@14
  unsigned int v7; // ecx@20
  unsigned int v8; // ecx@26

  result = 0;
  v3 = a2;
  v4 = 4;
  do
  {
    if ( v3 >= 0x14 )
      v3 = 0;
    if ( *(_DWORD *)(188 * v3 + a1 + 28888) == a1
      && *(_WORD *)(188 * v3 + a1 + 28754) == a2
      && *(_BYTE *)(188 * v3 + a1 + 28752) & 1 )
    {
      result = 188 * v3 + a1 + 28752;
    }
    v5 = v3 + 1;
    if ( v5 >= 0x14 )
      v5 = 0;
    if ( *(_DWORD *)(188 * v5 + a1 + 28888) == a1
      && *(_WORD *)(188 * v5 + a1 + 28754) == a2
      && *(_BYTE *)(188 * v5 + a1 + 28752) & 1 )
    {
      result = 188 * v5 + a1 + 28752;
    }
    v6 = v5 + 1;
    if ( v6 >= 0x14 )
      v6 = 0;
    if ( *(_DWORD *)(188 * v6 + a1 + 28888) == a1
      && *(_WORD *)(188 * v6 + a1 + 28754) == a2
      && *(_BYTE *)(188 * v6 + a1 + 28752) & 1 )
    {
      result = 188 * v6 + a1 + 28752;
    }
    v7 = v6 + 1;
    if ( v7 >= 0x14 )
      v7 = 0;
    if ( *(_DWORD *)(188 * v7 + a1 + 28888) == a1
      && *(_WORD *)(188 * v7 + a1 + 28754) == a2
      && *(_BYTE *)(188 * v7 + a1 + 28752) & 1 )
    {
      result = 188 * v7 + a1 + 28752;
    }
    v8 = v7 + 1;
    if ( v8 >= 0x14 )
      v8 = 0;
    if ( *(_DWORD *)(188 * v8 + a1 + 28888) == a1 && *(_WORD *)(188 * v8 + a1 + 28754) == a2 )
    {
      if ( *(_BYTE *)(188 * v8 + a1 + 28752) & 1 )
        result = 188 * v8 + a1 + 28752;
    }
    v3 = v8 + 1;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10001350) --------------------------------------------------------
signed int __cdecl sub_10001350(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax@1
  signed int result; // eax@4

  v3 = sub_10001240(a1, a2);
  if ( v3 && (*(_WORD *)(v3 + 180) == a3 || a3 == -2) )
    result = *(_DWORD *)(v3 + 184);
  else
    result = -6;
  return result;
}

//----- (10001390) --------------------------------------------------------
int __cdecl sub_10001390(int a1, unsigned __int16 a2, _BYTE *a3, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  bool v6; // zf@1
  int result; // eax@1

  v4 = sub_10001240(a1, a2);
  v5 = v4;
  v6 = v4 == 0;
  result = -6;
  *a3 = 0;
  if ( !v6 )
  {
    if ( *(_BYTE *)v5 & 4 )
      result = sub_100077F0((int)a3, (_BYTE *)(v5 + 140), a4);
  }
  return result;
}

//----- (100013D0) --------------------------------------------------------
signed int __cdecl sub_100013D0(_DWORD *a1, int a2, __int16 a3, __int16 a4, unsigned int a5, unsigned int a6, char a7, const char *a8, _BYTE *a9)
{
  int v9; // ebx@1
  int v10; // eax@1
  unsigned __int16 v11; // di@4
  signed int result; // eax@12
  unsigned __int16 v13; // ax@13
  int v14; // esi@18

  v9 = (int)(a1 + 7188);
  v10 = *a1 & 4;
  if ( v10 && (a5 >= 0xFFFFFFC2 || !a5) )
    return -15;
  v11 = a6;
  if ( !v10 )
    goto LABEL_25;
  if ( a6 != -2 )
    return -15;
  if ( !v10 )
  {
LABEL_25:
    if ( a5 < 0xFFFFFFC2 && a5 || !v10 && a6 > 0xFFFF )
      return -15;
  }
  if ( strlen(a8) >= 0x80 )
    return -15;
  v13 = 0;
  while ( *(_BYTE *)(188 * v13 + v9) )
  {
    if ( ++v13 >= 0x14u )
      return -23;
  }
  if ( v13 >= 0x14u )
    return -23;
  v14 = v9 + 188 * v13;
  if ( a6 == -2 )
    v11 = v13;
  *(_DWORD *)(v14 + 184) = a5;
  *(_DWORD *)(v14 + 136) = a1;
  *(_BYTE *)v14 = a7 | 1;
  *(_DWORD *)(v14 + 132) = a2;
  *(_WORD *)(v14 + 182) = a3;
  *(_WORD *)(v14 + 180) = a4;
  *(_WORD *)(v14 + 2) = v11;
  sub_100077F0(v14 + 4, a8, 128);
  if ( a9 )
  {
    sub_100077F0(v14 + 140, a9, 40);
    result = v14;
  }
  else
  {
    *(_BYTE *)(v14 + 140) = 0;
    result = v14;
  }
  return result;
}

//----- (10001500) --------------------------------------------------------
unsigned int __cdecl sub_10001500(_DWORD *a1, int a2, __int16 a3, __int16 a4, unsigned int a5, char a6, const char *a7, _BYTE *a8)
{
  unsigned int result; // eax@1

  result = sub_100013D0(a1, a2, a3, a4, a5, 0xFFFFFFFE, a6, a7, a8);
  if ( result < 0xFFFFFFC2 )
  {
    if ( result )
      result = *(_WORD *)(result + 2);
  }
  return result;
}

//----- (10001540) --------------------------------------------------------
int __cdecl sub_10001540(int a1, int a2, char *a3, size_t a4)
{
  char *v4; // ebx@3
  int v5; // eax@3
  int v6; // edi@5
  int i; // eax@5
  int j; // esi@9

  if ( a2 && *(_BYTE *)a2 )
  {
    v4 = a3;
    v5 = sub_10007A80(a3, a4, "%s%c%s", a1, 47, a2);
  }
  else
  {
    v4 = a3;
    v5 = sub_100077F0((int)a3, (_BYTE *)a1, a4);
  }
  v6 = v5;
  for ( i = 0; i < v6; ++i )
  {
    if ( v4[i] == 92 )
      v4[i] = 47;
  }
  for ( j = 0; j < v6; ++j )
  {
    if ( v4[j] == 47 && v4[j + 1] == 47 )
    {
      memcpy(&v4[j], &v4[j + 1], v6-- - j);
      --j;
    }
  }
  return v6;
}

//----- (100015E0) --------------------------------------------------------
_BYTE *__cdecl sub_100015E0(char a1, _BYTE *a2, int a3)
{
  int v3; // edx@1
  _BYTE *v4; // esi@1
  _BYTE *v5; // ecx@2

  v3 = a3;
  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    do
    {
      if ( a1 == *v5 )
        v4 = v5;
      v5 += 16;
      --v3;
    }
    while ( v3 );
  }
  return v4;
}

//----- (10001610) --------------------------------------------------------
void *sub_10001610()
{
  sub_10002E60();
  return sub_10002DC0();
}

//----- (10001620) --------------------------------------------------------
char __cdecl sub_10001620(int a1, int a2, void *a3, size_t a4)
{
  unsigned __int16 v4; // ax@1
  unsigned __int16 v5; // bx@1
  void *v6; // ecx@1
  char result; // al@1
  __int16 v8; // bx@2

  HIBYTE(v4) = *(_BYTE *)(a1 + 1);
  LOBYTE(v4) = *(_BYTE *)a1;
  v5 = v4;
  v6 = (void *)(v4 + a1 + 2);
  result = 0;
  if ( (unsigned int)v6 + a4 > a2 )
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 1) = 0;
  }
  else
  {
    memcpy_0(v6, a3, a4);
    v8 = a4 + v5;
    *(_BYTE *)a1 = v8;
    *(_BYTE *)(a1 + 1) = HIBYTE(v8);
    result = 1;
  }
  return result;
}

//----- (10001670) --------------------------------------------------------
char __cdecl sub_10001670(int a1, int a2, void *a3)
{
  return sub_10001620(a1, a2, a3, strlen((const char *)a3) + 1);
}

//----- (100016B0) --------------------------------------------------------
int __cdecl sub_100016B0(int a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // ecx@1
  char i; // dl@4

  result = 0;
  v3 = 0;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 == 92 && *(_BYTE *)(a1 + 1) == 92 )
    {
      result = a1 + 2;
      for ( i = *(_BYTE *)(a1 + 2); i; i = *(_BYTE *)(v3++ + result + 1) )
      {
        if ( i == 92 )
          break;
      }
    }
  }
  if ( a2 )
    *a2 = v3;
  return result;
}

//----- (100016F0) --------------------------------------------------------
char *__cdecl sub_100016F0(int a1, _DWORD *a2)
{
  int v2; // ecx@0
  char *v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  char i; // al@3
  int v8; // [sp+0h] [bp-4h]@1

  v8 = v2;
  v3 = 0;
  v4 = 0;
  v5 = sub_100016B0(a1, &v8);
  if ( v5 )
  {
    if ( *(_BYTE *)(v8 + v5) == 92 )
    {
      v3 = (char *)(v8 + v5 + 1);
      for ( i = *v3; i; i = v3[v4++ + 1] )
      {
        if ( i == 92 )
          break;
      }
    }
  }
  if ( a2 )
    *a2 = v4;
  return v3;
}

//----- (10001740) --------------------------------------------------------
_BYTE *__cdecl sub_10001740(int a1)
{
  int v1; // ecx@0
  unsigned int v2; // edi@1
  int v3; // ebx@1
  char v4; // al@2
  char v6; // [sp+10h] [bp-1Ch]@1
  char v7; // [sp+11h] [bp-1Bh]@1
  char v8; // [sp+12h] [bp-1Ah]@1
  char v9; // [sp+13h] [bp-19h]@1
  char v10; // [sp+14h] [bp-18h]@1
  char v11; // [sp+15h] [bp-17h]@1
  char v12; // [sp+16h] [bp-16h]@1
  char v13; // [sp+17h] [bp-15h]@1
  int v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  int v16; // [sp+20h] [bp-Ch]@1
  __int16 v17; // [sp+24h] [bp-8h]@1

  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v2 = 0;
  v6 = 75;
  v7 = 71;
  v8 = 83;
  v9 = 33;
  v10 = 64;
  v11 = 35;
  v12 = 36;
  v13 = 37;
  v3 = v1 - (_DWORD)&v14;
  do
  {
    v4 = toupper(*((_BYTE *)&v14 + v2 + v3));
    *((_BYTE *)&v14 + v2) = v4;
    if ( !v4 )
      break;
    ++v2;
  }
  while ( v2 < 0xE );
  sub_10006930(&v6, (int)&v14, a1);
  return sub_10006930(&v6, (int)&v15 + 3, a1 + 8);
}

//----- (10001800) --------------------------------------------------------
int __usercall sub_10001800@<eax>(int a1@<edx>, int a2@<edi>)
{
  int v2; // ecx@1
  int v3; // esi@1

  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(a1 + 20);
  *(_WORD *)v2 = 0;
  *(_BYTE *)(v2 + 2) = 0;
  *(_DWORD *)(v3 + 5) = a2;
  if ( a2 && !(a2 & 0xC0000000) )
    *(_WORD *)(v3 + 10) &= 0xBFFFu;
  *(_DWORD *)(a1 + 40) = 3;
  return 0;
}

//----- (10001830) --------------------------------------------------------
int __usercall sub_10001830@<eax>(int result@<eax>, int a2@<edx>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)result = 1112364031;
  *(_BYTE *)(result + 4) = *(_BYTE *)(a2 + 4);
  *(_DWORD *)(result + 5) = 0;
  *(_BYTE *)(result + 9) = -128;
  *(_WORD *)(result + 10) = 16385;
  *(_WORD *)(result + 24) = *(_WORD *)(a2 + 24);
  *(_WORD *)(result + 26) = *(_WORD *)(a2 + 26);
  *(_WORD *)(result + 28) = *(_WORD *)(a2 + 28);
  *(_WORD *)(result + 30) = *(_WORD *)(a2 + 30);
  return result;
}

//----- (10001890) --------------------------------------------------------
char __fastcall sub_10001890(int a1, int a2)
{
  unsigned __int16 v2; // ax@1
  unsigned int v3; // ecx@1
  char result; // al@1

  LOBYTE(v2) = 0;
  HIBYTE(v2) = *(_DWORD *)a2 >> 16;
  v3 = v2 | ((*(_DWORD *)a2 >> 24) | ((*(_DWORD *)a2 & 0xFFFFFF00) << 8)) & 0xFFFFFF;
  result = 1;
  if ( v3 < 0x20 || *(_DWORD *)(a2 + 4) != 1112364031 || (signed int)v3 > 28672 )
    result = 0;
  return result;
}

//----- (100018D0) --------------------------------------------------------
_BYTE *__cdecl sub_100018D0(int a1, _BYTE *a2, int a3, char a4)
{
  int v4; // eax@2
  int v6; // [sp+8h] [bp-94h]@1
  int v7; // [sp+Ch] [bp-90h]@1
  int v8; // [sp+10h] [bp-8Ch]@1
  int v9; // [sp+14h] [bp-88h]@1
  int v10; // [sp+18h] [bp-84h]@1
  char v11; // [sp+1Ch] [bp-80h]@1
  char v12; // [sp+20h] [bp-7Ch]@2

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( a4 )
  {
    v4 = sub_10007770((int)&v12, a1, 120);
    sub_10007010((int)&v12, 2 * v4 - 2, (int)&v6);
  }
  else
  {
    sub_10001740((int)&v6);
  }
  sub_10006930(a2, (int)&v6, a3);
  sub_10006930(a2, (int)&v7 + 3, a3 + 8);
  return sub_10006930(a2, (int)&v9 + 2, a3 + 16);
}

//----- (100019A0) --------------------------------------------------------
int __cdecl sub_100019A0(int a1, unsigned __int16 a2, char *a3, size_t a4)
{
  int v4; // eax@1
  int result; // eax@2

  v4 = sub_10001240(a1, a2);
  *a3 = 0;
  if ( v4 )
    result = sub_10001540(*(_DWORD *)(*(_DWORD *)(v4 + 132) + 4), v4 + 4, a3, a4);
  else
    result = -6;
  return result;
}

//----- (100019F0) --------------------------------------------------------
signed int __cdecl sub_100019F0(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax@1
  _BYTE *v4; // esi@1
  unsigned int v5; // eax@4
  signed int v6; // ebx@6
  unsigned int v7; // eax@9
  int v8; // ecx@9
  signed int result; // eax@12
  char v10; // [sp+Ch] [bp-84h]@7

  v3 = sub_10001240(a1, a2);
  v4 = (_BYTE *)v3;
  if ( v3 && (*(_WORD *)(v3 + 180) == a3 || a3 == -2) )
  {
    v5 = *(_DWORD *)(v3 + 184);
    if ( v5 < 0xFFFFFFC2 && v5 )
    {
      v6 = sub_10022300(v5);
      if ( *v4 & 8 )
      {
        sub_100019A0(a1, a2, &v10, 0x80u);
        v6 |= j_FIL_vfs_delete(&v10);
      }
    }
    else
    {
      v6 = 0;
    }
    v7 = 0;
    v8 = a1 + 28752;
    while ( v4 != (_BYTE *)v8 )
    {
      ++v7;
      v8 += 188;
      if ( v7 >= 0x14 )
        goto LABEL_12;
    }
    memset((void *)(188 * v7 + a1 + 28752), 0, 0xBCu);
LABEL_12:
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}
// 10022360: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10001B00) --------------------------------------------------------
int __cdecl sub_10001B00(int a1, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp+14h] [bp+4h]@1

  v3 = a1;
  v4 = 0;
  v7 = 0;
  v5 = v3 + 28884;
  do
  {
    if ( *(_BYTE *)(v5 - 132) & 1
      && *(_DWORD *)(v5 + 4) == v3
      && (!a2 || *(_DWORD *)v5 == a2)
      && (a3 == -2 || *(_WORD *)(v5 + 48) == a3)
      && !sub_100019F0(v3, v4, a3) )
    {
      ++v7;
    }
    ++v4;
    v5 += 188;
  }
  while ( v4 < 0x14 );
  return v7;
}

//----- (10001B80) --------------------------------------------------------
int __cdecl sub_10001B80(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // edx@1
  unsigned __int16 v4; // cx@4
  int v5; // eax@4
  int v6; // eax@7
  int v7; // edi@7
  int v8; // ST0C_4@9
  int result; // eax@10
  unsigned int v10; // ecx@13
  int v11; // edx@13
  unsigned int *v12; // ebp@13
  unsigned int v13; // eax@13
  int v14; // ecx@13
  bool v15; // zf@15
  unsigned int v16; // edi@20
  int v17; // edx@20
  __int16 v18; // [sp+10h] [bp-34h]@9
  unsigned int v19; // [sp+48h] [bp+4h]@13

  v2 = a1;
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 > 0x7006 )
    LOWORD(v3) = 28678;
  *(_WORD *)(a1 + 6) = v3;
  if ( (unsigned __int16)v3 < 4u )
  {
    v5 = 4;
  }
  else
  {
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *(_DWORD *)(a1 + 8) >> 16;
    v5 = (v4 | ((*(_DWORD *)(a1 + 8) >> 24) | ((*(_DWORD *)(a1 + 8) & 0xFFFFFF00) << 8)) & 0xFFFFFF)
       - (unsigned __int16)v3
       + 4;
    if ( v5 + (unsigned int)(unsigned __int16)v3 > 0x7004 )
      v5 = 0;
  }
  v6 = sub_10022070(*(_DWORD *)(a1 + 28732), (unsigned __int16)v3 + a1 + 8, v5, 0, a2);
  v7 = v6;
  if ( v6 < 0 )
  {
    if ( v6 == -57 || (v8 = *(_DWORD *)(a1 + 28732), v18 = 0, j_IOP_pvg_sk_status(v8, &v18), v18 & 0x44) )
    {
      result = -1;
    }
    else
    {
      sub_10001030((_DWORD *)a1, (int)"sk recv err", 1);
      result = -16;
    }
    return result;
  }
  if ( *(_BYTE *)a1 & 2 )
  {
    j_IOP_pvg_sk_get_addr(*(_DWORD *)(a1 + 28732), a1 + 28700, 0);
    *(_DWORD *)a1 &= 0xFFFFFFFD;
  }
  *(_WORD *)(a1 + 6) += v7;
  v10 = *(_DWORD *)(a1 + 8);
  v11 = *(_WORD *)(a1 + 6);
  v12 = (unsigned int *)(a1 + 8);
  v19 = v10;
  v13 = (v10 >> 24) | ((*(_DWORD *)(v2 + 8) & 0xFFFFFF00) << 8);
  v14 = 0;
  BYTE1(v14) = BYTE2(v19);
  result = ((unsigned __int16)v14 | v13 & 0xFFFFFF) - v11 + 4;
  if ( v11 == v7 && v7 )
  {
    v15 = result == 0;
    if ( result <= 0 )
      goto LABEL_18;
    result = sub_10001B80(v2, a2);
  }
  v15 = result == 0;
LABEL_18:
  if ( v15 )
  {
    if ( sub_10001890(v14, v2 + 8) )
    {
      v16 = *v12 >> 24;
      v17 = (*v12 >> 8) & 0xFF00;
      result = 0;
      if ( 28672 - (v17 | (v16 | ((*v12 & 0xFFFFFF00) << 8)) & 0xFFFFFF) > 2 )
        *(_WORD *)((v17 | (v16 | ((*v12 & 0xFFFFFF00) << 8)) & 0xFFFFFF) + v2 + 12) = 0;
    }
    else if ( *v12 == 133 && *(_BYTE *)v2 & 4 )
    {
      *(_WORD *)(v2 + 6) = 0;
      result = -3;
    }
    else
    {
      *(_WORD *)(v2 + 6) = 0;
      result = -15;
    }
  }
  return result;
}
// 10022060: using guessed type int __cdecl j_IOP_pvg_sk_get_addr(_DWORD, _DWORD, _DWORD);
// 10022120: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10001D70) --------------------------------------------------------
signed int __cdecl sub_10001D70(int a1, int a2, int a3)
{
  int v3; // ecx@0
  _WORD *v4; // edi@1
  int v5; // edx@1
  unsigned int v6; // esi@1
  unsigned __int16 v7; // ax@1
  int v8; // esi@1
  signed int result; // eax@2
  int v10; // eax@3
  int v11; // esi@9
  unsigned int v12; // [sp+10h] [bp+8h]@1

  v4 = (_WORD *)a2;
  v5 = a2 + 8;
  v6 = *(_DWORD *)(a2 + 8) & 0xFFFFFF00;
  v12 = *(_DWORD *)(a2 + 8);
  LOBYTE(v7) = 0;
  HIBYTE(v7) = BYTE2(v12);
  v8 = (v7 | ((v12 >> 24) | (v6 << 8)) & 0xFFFFFF) + 4;
  if ( sub_10001890(v3, v5) )
  {
    v10 = sub_100220C0(*(_DWORD *)(a1 + 28732), (int)v4 + *v4 + 8, v8, 2, a3);
    if ( v10 >= 0 )
    {
      *v4 += v10;
      v11 = v8 - v10;
      if ( v11 > 0 )
      {
        sub_10001030((_DWORD *)a1, (int)"sk send unable to tx all bytes", 1);
        sub_100072A0("..\\lib\\acl\\iop\\iop_net_cifs.c", 1921, 0, 0);
      }
      result = v11;
    }
    else
    {
      if ( v10 == -53 || v10 == -51 || v10 == -54 )
        sub_10001030((_DWORD *)a1, (int)"sk send err", 1);
      result = -1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10001E30) --------------------------------------------------------
int __usercall sub_10001E30@<eax>(int a1@<esi>)
{
  unsigned __int16 v1; // dx@1
  char v2; // bl@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@2
  _BYTE *v5; // eax@7
  int v6; // ecx@7
  __int16 v7; // dx@7
  int v8; // ebx@7
  int v9; // edx@7
  _BYTE *v10; // eax@7
  char v11; // cl@9
  int v12; // edi@15
  int v13; // ecx@23
  bool v14; // sf@32
  unsigned __int8 v15; // of@32
  int v16; // ST18_4@40
  char v18; // [sp+Bh] [bp-7055h]@1
  char v19; // [sp+Ch] [bp-7054h]@4
  int v20; // [sp+10h] [bp-7050h]@6
  signed __int16 v21; // [sp+14h] [bp-704Ch]@4
  int *v22; // [sp+18h] [bp-7048h]@7
  int v23; // [sp+1Ch] [bp-7044h]@1
  int v24; // [sp+20h] [bp-7040h]@1
  _BYTE *v25; // [sp+24h] [bp-703Ch]@7
  int v26; // [sp+28h] [bp-7038h]@7
  _BYTE *v27; // [sp+2Ch] [bp-7034h]@7
  __int16 v28; // [sp+30h] [bp-7030h]@7
  int *v29; // [sp+34h] [bp-702Ch]@1
  int *v30; // [sp+38h] [bp-7028h]@7
  unsigned int v31; // [sp+3Ch] [bp-7024h]@7
  int v32; // [sp+40h] [bp-7020h]@6
  int v33; // [sp+44h] [bp-701Ch]@4
  int v34; // [sp+48h] [bp-7018h]@7
  int v35; // [sp+4Ch] [bp-7014h]@4
  __int16 v36; // [sp+50h] [bp-7010h]@1
  unsigned int v37; // [sp+54h] [bp-700Ch]@2
  unsigned int v38; // [sp+58h] [bp-7008h]@40
  int v39; // [sp+5Ch] [bp-7004h]@1

  v29 = &v39;
  LOBYTE(v1) = 0;
  HIBYTE(v1) = *(_DWORD *)(a1 + 8) >> 16;
  v2 = (*(_DWORD *)a1 >> 2) & 1;
  v3 = v1 | ((*(_DWORD *)(a1 + 8) >> 24) | ((*(_DWORD *)(a1 + 8) & 0xFFFFFF00) << 8)) & 0xFFFFFF;
  v24 = a1 + 12;
  v18 = v2;
  v23 = v3;
  v36 = 0;
  if ( v2 )
  {
    v37 = 32;
    sub_10001830((int)&v39, a1 + 12);
    v4 = 32;
  }
  else
  {
    v4 = 0;
    v37 = 0;
    v39 = 0;
  }
  v19 = *(_BYTE *)(a1 + 16);
  v21 = 32;
  v35 = -1;
  v33 = 0;
  if ( !v2 )
    *(_WORD *)(a1 + 32536) = *(_WORD *)(a1 + 42);
  v20 = 0;
  v32 = 0;
  do
  {
    v5 = (_BYTE *)((unsigned __int16)v21 + v24);
    v25 = v5;
    v27 = &v5[2 * *v5 + 3];
    v6 = (int)&v5[2 * *v5];
    HIBYTE(v7) = *(_BYTE *)(v6 + 2);
    v8 = 0;
    LOBYTE(v7) = *(_BYTE *)(v6 + 1);
    v28 = v7;
    v9 = (unsigned __int16)v7 + 2 * *v5 + 3;
    v31 = *(_WORD *)(a1 + 4) - v4;
    v30 = (int *)((char *)&v39 + v4);
    v26 = v9;
    v34 = 0;
    *(_WORD *)v30 = 0;
    *((_BYTE *)v30 + 2) = 0;
    v10 = sub_100015E0(v19, *(_BYTE **)(a1 + 28684), *(_BYTE *)(a1 + 28688));
    v19 = -1;
    v22 = 0;
    if ( v10 && v10[1] & 1 )
    {
      v11 = v18;
      v8 = (int)v25;
      if ( v18 )
        v22 = v30;
    }
    else
    {
      v11 = v18;
    }
    if ( v23 < v26 + (unsigned __int16)v21 )
    {
LABEL_15:
      sub_100072A0("..\\lib\\acl\\iop\\iop_net_cifs.c", 2592, 0, 0);
      sub_10001030((_DWORD *)a1, (int)"rxed unexpected svr or client response", 0);
      v12 = -1073741823;
LABEL_21:
      if ( v18 )
      {
LABEL_22:
        sub_10001800((int)&v24, v12);
        goto LABEL_23;
      }
      goto LABEL_23;
    }
    if ( v11 )
    {
      if ( *(_BYTE *)(a1 + 21) & 0x80 )
        goto LABEL_15;
    }
    else if ( !(*(_BYTE *)(a1 + 21) & 0x80) )
    {
      goto LABEL_15;
    }
    if ( v10 )
    {
      v12 = (*((int (__cdecl **)(_DWORD, _DWORD))v10 + 2))(a1, &v24);
      if ( !v12 )
        goto LABEL_23;
      goto LABEL_21;
    }
    v12 = -1073741822;
    if ( v11 )
      goto LABEL_22;
    sub_10001030((_DWORD *)a1, (int)"rxed unsupported client response cmd", 0);
LABEL_23:
    v13 = v34;
    v4 = v37;
    if ( v34 > 0 )
    {
      v4 = v34 + v37;
      v37 += v34;
    }
    if ( v8 )
    {
      if ( v12 )
      {
        v19 = -1;
        v21 = 0;
      }
      else
      {
        v19 = *(_BYTE *)(v8 + 1);
        v21 = *(_WORD *)(v8 + 3);
      }
    }
    if ( v22 && !v12 )
    {
      *((_BYTE *)v22 + 1) = *(_BYTE *)(v8 + 1);
      *(_WORD *)((char *)v22 + 3) = v37;
      *((_BYTE *)v22 + 2) = 0;
      v4 = v37;
      v13 = v34;
    }
    ++v32;
    v15 = __OFSUB__(v20, 1000);
    v14 = v20++ - 1000 < 0;
    if ( !(v14 ^ v15) )
      break;
    if ( v13 < 0 )
      return v12;
  }
  while ( v19 != -1 && !v12 && v4 < *(_WORD *)(a1 + 4) );
  if ( v13 > 0 && v4 && v4 < *(_WORD *)(a1 + 4) )
  {
    v38 = ((v4 & 0xFF00 | (v4 << 16)) << 8) | (((v4 >> 16) | v4 & 0xFF0000) >> 8);
    v16 = *(_DWORD *)(a1 + 28696);
    v36 = 0;
    sub_10001D70(a1, (int)&v36, v16);
  }
  return v12;
}

//----- (10002130) --------------------------------------------------------
signed int __cdecl sub_10002130(int a1)
{
  signed int result; // eax@3
  int v2; // edi@4

  if ( !(*(_BYTE *)a1 & 1) || *(_DWORD *)(a1 + 28684) )
  {
    v2 = sub_10001B80(a1, *(_DWORD *)(a1 + 28692));
    if ( !v2 )
    {
      sub_10001E30(a1);
      *(_WORD *)(a1 + 6) = 0;
    }
    result = v2;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10002170) --------------------------------------------------------
int __usercall sub_10002170@<eax>(int a1@<esi>)
{
  unsigned int v1; // edi@1

  v1 = sub_10001060(a1, (int)dword_100B4760);
  *(_DWORD *)(a1 + 32512) = 0;
  *(_DWORD *)(a1 + 32516) = 0;
  *(_DWORD *)(a1 + 32520) = 0;
  *(_DWORD *)(a1 + 32524) = 0;
  *(_DWORD *)(a1 + 32528) = 0;
  *(_DWORD *)(a1 + 32532) = 0;
  *(_DWORD *)(a1 + 32536) = 0;
  *(_WORD *)(a1 + 32514) = 0;
  *(_WORD *)(a1 + 32516) = 0;
  *(_WORD *)(a1 + 32518) = 0;
  *(_WORD *)(a1 + 32520) = 0;
  *(_WORD *)(a1 + 32536) = -1;
  *(_DWORD *)(a1 + 32524) = sub_100228F0() - 2000;
  *(_DWORD *)(a1 + 28684) = &unk_10040550;
  *(_BYTE *)(a1 + 28688) = 9;
  *(_DWORD *)(a1 + 28692) = 120000;
  *(_DWORD *)(a1 + 28696) = 1000;
  return sub_10001080(a1, (int)&unk_100407E0 + 28 * v1, 0, 0);
}
// 100B4760: using guessed type int dword_100B4760[];

//----- (10002230) --------------------------------------------------------
int __usercall sub_10002230@<eax>(char a1@<al>, int a2@<edx>, unsigned __int16 a3@<bx>, int a4, __int16 a5)
{
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // ecx@7
  int v9; // ecx@11
  bool v10; // zf@11
  int result; // eax@11

  v5 = *(_DWORD *)(a4 + 32528);
  v6 = 0;
  if ( v5 )
  {
    if ( *(_DWORD *)(v5 + 20) == a3 && *(_WORD *)(v5 + 16) == a5 && *(_DWORD *)(v5 + 12) > a2 )
    {
      v7 = *(_DWORD *)(v5 + 4 * a2);
      if ( *(_BYTE *)(v7 + 2) == a1 )
        v6 = v7;
    }
  }
  v8 = *(_DWORD *)(a4 + 32532);
  if ( !v8
    || *(_DWORD *)(v8 + 20) != a3
    || *(_WORD *)(v8 + 16) != a5
    || *(_DWORD *)(v8 + 12) <= a2
    || (v9 = *(_DWORD *)(v8 + 4 * a2), v10 = *(_BYTE *)(v9 + 2) == a1, result = v9, !v10) )
  {
    result = v6;
  }
  return result;
}

//----- (100022A0) --------------------------------------------------------
signed int __cdecl sub_100022A0(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int v4; // eax@1
  signed int result; // eax@2
  signed int v6; // esi@3

  v2 = *(_DWORD *)a2;
  v3 = -1073741811;
  v4 = sub_10002230(4, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( v4 )
  {
    v6 = *(_DWORD *)(v2 + 5);
    if ( v6 )
    {
      *(_DWORD *)(v4 + 4) = v6;
      result = v6;
    }
    else
    {
      if ( !**(_BYTE **)(a2 + 4) )
        v3 = 0;
      *(_DWORD *)(v4 + 4) = v3;
      result = v3;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (10002300) --------------------------------------------------------
signed int __cdecl sub_10002300(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int v4; // eax@1
  signed int result; // eax@2
  signed int v6; // esi@3

  v2 = *(_DWORD *)a2;
  v3 = -1073741811;
  v4 = sub_10002230(6, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( v4 )
  {
    v6 = *(_DWORD *)(v2 + 5);
    if ( v6 )
    {
      *(_DWORD *)(v4 + 4) = v6;
      result = v6;
    }
    else
    {
      if ( !**(_BYTE **)(a2 + 4) )
        v3 = 0;
      *(_DWORD *)(v4 + 4) = v3;
      result = v3;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (10002360) --------------------------------------------------------
signed int __cdecl sub_10002360(int a1, int a2)
{
  int v2; // edi@1
  int v3; // ebp@1
  unsigned __int16 v4; // bx@1
  unsigned int v5; // esi@1
  __int16 v6; // ST0C_2@1
  signed int result; // eax@2
  unsigned int v8; // eax@8
  signed int v9; // ebp@14
  int v10; // [sp+10h] [bp-4h]@1
  unsigned int v11; // [sp+1Ch] [bp+8h]@1

  v2 = a2;
  v3 = *(_DWORD *)a2;
  v4 = *(_WORD *)(*(_DWORD *)a2 + 30);
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_WORD *)(*(_DWORD *)a2 + 26);
  v11 = *(_DWORD *)(a2 + 12);
  v10 = sub_10002230(114, *(_DWORD *)(v2 + 32), v4, a1, v6);
  if ( v10 )
  {
    result = *(_DWORD *)(v3 + 5);
    if ( result )
    {
      *(_DWORD *)(v10 + 4) = result;
    }
    else if ( *(_BYTE *)v5 != 17
           || *(_BYTE *)(v5 + 34) != 8
           || *(_WORD *)(v5 + 1)
           || (v8 = *(_DWORD *)(v5 + 8), v8 > *(_WORD *)(a1 + 4))
           || *(_WORD *)(v5 + 4) < 1u
           || *(_WORD *)(v5 + 6) < 1u
           || (*(_DWORD *)(v5 + 20) & 0x250) != 592
           || v8 < 0x100
           || !sub_10001000(v5, *(_DWORD *)(v2 + 8), v11, 8) )
    {
      *(_DWORD *)(v10 + 4) = -253;
      result = -253;
    }
    else
    {
      v9 = *(_DWORD *)(v3 + 5);
      *(_WORD *)(a1 + 4) = *(_WORD *)(v5 + 8);
      *(_DWORD *)(a1 + 28736) = *(_DWORD *)v11;
      *(_DWORD *)(a1 + 28740) = *(_DWORD *)(v11 + 4);
      *(_DWORD *)(v10 + 4) = v9;
      result = v9;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (10002470) --------------------------------------------------------
signed int __cdecl sub_10002470(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  int v4; // edi@1
  signed int result; // eax@2
  const char *v6; // ST1C_4@9
  char v7; // [sp+18h] [bp+8h]@7

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)a2;
  v4 = sub_10002230(-94, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( !v4 )
    return -254;
  result = *(_DWORD *)(v3 + 5);
  if ( result && (*(_BYTE *)(v2 + 1) == -1 || !*(_BYTE *)v2) )
    goto LABEL_11;
  if ( *(_BYTE *)v2 != 34 )
  {
    result = -1073741811;
LABEL_11:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  *(_WORD *)(v4 + 36) = *(_WORD *)(v2 + 6);
  v7 = 0;
  if ( *(_BYTE *)(v2 + 68) )
    v7 = 2;
  v6 = *(const char **)(v4 + 32);
  *(_WORD *)(v4 + 36) = *(_WORD *)(v2 + 6);
  *(_DWORD *)(v4 + 40) = sub_100013D0(
                           (_DWORD *)a1,
                           *(_DWORD *)(a1 + 28744),
                           *(_WORD *)(v3 + 26),
                           *(_WORD *)(v3 + 28),
                           0,
                           *(_WORD *)(v2 + 6),
                           v7,
                           v6,
                           0);
  result = 0;
  *(_DWORD *)(v4 + 4) = 0;
  return result;
}

//----- (10002530) --------------------------------------------------------
signed int __cdecl sub_10002530(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1
  int v5; // ebx@1
  signed int result; // eax@2
  signed int v7; // ebp@3
  void *v8; // ST04_4@10
  void *v9; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v9 = (void *)(*(_DWORD *)a2 + *(_WORD *)(v3 + 13));
  v4 = *(_WORD *)(v3 + 11) | (*(_WORD *)(v3 + 15) << 16);
  v5 = sub_10002230(46, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( v5 )
  {
    v7 = *(_DWORD *)(v2 + 5);
    if ( !v7 || *(_BYTE *)(v3 + 1) != -1 && *(_BYTE *)v3 )
    {
      if ( *(_BYTE *)v3 == 12
        && sub_10001000(v3, *(_DWORD *)(a2 + 8), (unsigned int)v9, v4)
        && v4 <= *(_DWORD *)(v5 + 20) )
      {
        v8 = *(void **)(v5 + 24);
        *(_DWORD *)(v5 + 28) = v4;
        memcpy_0(v8, v9, v4);
        result = 0;
        *(_DWORD *)(v5 + 4) = 0;
      }
      else
      {
        result = -253;
        *(_DWORD *)(v5 + 4) = -253;
      }
    }
    else
    {
      result = v7;
      *(_DWORD *)(v5 + 4) = v7;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (100025F0) --------------------------------------------------------
signed int __cdecl sub_100025F0(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int v4; // eax@1
  signed int result; // eax@2
  signed int v6; // esi@3

  v2 = *(_DWORD *)a2;
  v3 = -1073741811;
  v4 = sub_10002230(1, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( v4 )
  {
    v6 = *(_DWORD *)(v2 + 5);
    if ( v6 )
    {
      *(_DWORD *)(v4 + 4) = v6;
      result = v6;
    }
    else
    {
      if ( !**(_BYTE **)(a2 + 4) )
        v3 = 0;
      *(_DWORD *)(v4 + 4) = v3;
      result = v3;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (10002650) --------------------------------------------------------
signed int __cdecl sub_10002650(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  signed int v4; // edi@1
  int v5; // eax@1
  signed int result; // eax@2
  signed int v7; // ecx@3

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)a2;
  v4 = -1073741811;
  v5 = sub_10002230(115, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( v5 )
  {
    v7 = *(_DWORD *)(v3 + 5);
    if ( !v7 || *(_BYTE *)(v2 + 1) != -1 && *(_BYTE *)v2 )
    {
      if ( *(_BYTE *)v2 == 3 )
      {
        *(_WORD *)(v5 + 16) = *(_WORD *)(v3 + 28);
        v4 = 0;
      }
      *(_DWORD *)(v5 + 4) = v4;
      result = v4;
    }
    else
    {
      *(_DWORD *)(v5 + 4) = v7;
      result = v7;
    }
  }
  else
  {
    result = -254;
  }
  return result;
}

//----- (100026D0) --------------------------------------------------------
signed int __cdecl sub_100026D0(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // ecx@1
  signed int result; // eax@2

  v2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = sub_10002230(117, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( !v4 )
    return -254;
  result = *(_DWORD *)(v2 + 5);
  if ( !result || *(_BYTE *)(v3 + 1) != -1 && *(_BYTE *)v3 )
  {
    if ( *(_BYTE *)v3 == 3 )
    {
      *(_WORD *)(v4 + 12) = *(_WORD *)(v2 + 24);
      result = 0;
      *(_DWORD *)(v4 + 4) = 0;
      return result;
    }
    result = -253;
  }
  *(_DWORD *)(v4 + 4) = result;
  return result;
}

//----- (10002740) --------------------------------------------------------
signed int __cdecl sub_10002740(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // ecx@1
  signed int result; // eax@2

  v2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = sub_10002230(47, *(_DWORD *)(a2 + 32), *(_WORD *)(*(_DWORD *)a2 + 30), a1, *(_WORD *)(*(_DWORD *)a2 + 26));
  if ( !v4 )
    return -254;
  result = *(_DWORD *)(v2 + 5);
  if ( !result || *(_BYTE *)(v3 + 1) != -1 && *(_BYTE *)v3 )
  {
    if ( *(_BYTE *)v3 == 6 )
    {
      *(_WORD *)(v4 + 28) = *(_WORD *)(v3 + 5);
      result = 0;
      *(_DWORD *)(v4 + 4) = 0;
      return result;
    }
    result = -253;
  }
  *(_DWORD *)(v4 + 4) = result;
  return result;
}

//----- (100027B0) --------------------------------------------------------
int __cdecl sub_100027B0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ecx@1
  unsigned __int16 v5; // dx@1

  v2 = *(_DWORD *)(a2 + 24);
  v3 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v2 = 3;
  *(_WORD *)(v2 + 1) = *(_WORD *)(v3 + 8);
  *(_BYTE *)(v2 + 7) = 0;
  *(_BYTE *)(v2 + 8) = 0;
  v4 = 2 * *(_BYTE *)v2;
  HIBYTE(v5) = *(_BYTE *)(v4 + v2 + 2);
  LOBYTE(v5) = *(_BYTE *)(v4 + v2 + 1);
  *(_DWORD *)(a2 + 40) = v5 + v4 + 3;
  return 0;
}

//----- (100027F0) --------------------------------------------------------
int __cdecl sub_100027F0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // eax@1
  int v6; // eax@1
  unsigned __int16 v7; // cx@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v3 = 1;
  *(_WORD *)(v3 + 1) = *(_WORD *)(v4 + 8);
  LOBYTE(a2) = 4;
  v5 = v3 + 2 * *(_BYTE *)v3 + 1;
  *(_BYTE *)v5 = 0;
  *(_BYTE *)(v5 + 1) = 0;
  sub_10001620(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &a2, 1u);
  sub_10001670(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), *(void **)(v4 + 12));
  v6 = 2 * *(_BYTE *)v3;
  HIBYTE(v7) = *(_BYTE *)(v6 + v3 + 2);
  LOBYTE(v7) = *(_BYTE *)(v6 + v3 + 1);
  *(_DWORD *)(v2 + 40) = v7 + v6 + 3;
  return 0;
}

//----- (10002870) --------------------------------------------------------
int __cdecl sub_10002870(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  unsigned __int16 v4; // cx@1

  v2 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)v2 = 0;
  *(_BYTE *)(v2 + 1) = 0;
  *(_BYTE *)(v2 + 2) = 0;
  sub_10001620(v2 + 2 * *(_BYTE *)v2 + 1, *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28), &unk_100405E0, 0xCu);
  v3 = 2 * *(_BYTE *)v2;
  HIBYTE(v4) = *(_BYTE *)(v3 + v2 + 2);
  LOBYTE(v4) = *(_BYTE *)(v3 + v2 + 1);
  *(_DWORD *)(a2 + 40) = v4 + v3 + 3;
  return 0;
}

//----- (100028C0) --------------------------------------------------------
int __cdecl sub_100028C0(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char *v4; // ecx@1
  __int16 v5; // bp@1
  char v6; // bl@2
  int v7; // eax@3
  unsigned __int16 v8; // cx@3

  v2 = *(_DWORD *)(a2 + 24);
  v3 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v2 = 24;
  *(_BYTE *)(v2 + 5) = 0;
  v4 = *(char **)(v3 + 32);
  v5 = (_WORD)v4 + 1;
  do
    v6 = *v4++;
  while ( v6 );
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_WORD *)(v2 + 6) = (_WORD)v4 - v5 + 1;
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(v2 + 32) = 7;
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v3 + 24);
  *(_DWORD *)(v2 + 40) = *(_DWORD *)(v3 + 28);
  *(_BYTE *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 44) = 2;
  *(_BYTE *)(v2 + 49) = 0;
  *(_BYTE *)(v2 + 50) = 0;
  sub_10001670(v2 + 2 * *(_BYTE *)v2 + 1, *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28), *(void **)(v3 + 32));
  v7 = 2 * *(_BYTE *)v2;
  HIBYTE(v8) = *(_BYTE *)(v7 + v2 + 2);
  LOBYTE(v8) = *(_BYTE *)(v7 + v2 + 1);
  *(_DWORD *)(a2 + 40) = v8 + v7 + 3;
  return 0;
}

//----- (10002970) --------------------------------------------------------
int __cdecl sub_10002970(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  int v5; // eax@3
  unsigned __int16 v6; // cx@3

  v2 = *(_DWORD *)(a2 + 24);
  v3 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v2 = 12;
  v4 = *(_DWORD *)(a2 + 28) - 27;
  if ( v4 >= *(_DWORD *)(v3 + 20) )
    v4 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(v3 + 20) = v4;
  *(_BYTE *)v2 = 12;
  *(_WORD *)(v2 + 5) = *(_WORD *)(v3 + 8);
  *(_DWORD *)(v2 + 7) = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v2 + 21) = *(_QWORD *)(v3 + 12) >> 32;
  *(_WORD *)(v2 + 11) = *(_WORD *)(v3 + 20);
  *(_DWORD *)(v2 + 15) = *(_WORD *)(v3 + 22);
  *(_WORD *)(v2 + 13) = 0;
  *(_WORD *)(v2 + 19) = 0;
  *(_BYTE *)(v2 + 25) = 0;
  *(_BYTE *)(v2 + 26) = 0;
  v5 = 2 * *(_BYTE *)v2;
  HIBYTE(v6) = *(_BYTE *)(v5 + v2 + 2);
  LOBYTE(v6) = *(_BYTE *)(v5 + v2 + 1);
  *(_DWORD *)(a2 + 40) = v6 + v5 + 3;
  return 0;
}

//----- (100029F0) --------------------------------------------------------
int __cdecl sub_100029F0(int a1, int a2)
{
  int v2; // edi@1
  _BYTE *v3; // esi@1
  int v4; // ebx@1
  int v5; // eax@1
  int v6; // eax@1
  unsigned __int16 v7; // cx@1

  v2 = a2;
  v3 = *(_BYTE **)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 36);
  *v3 = 0;
  LOBYTE(a2) = 4;
  v5 = (int)&v3[2 * *v3 + 1];
  *(_BYTE *)v5 = 0;
  *(_BYTE *)(v5 + 1) = 0;
  sub_10001620((int)&v3[2 * *v3 + 1], *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &a2, 1u);
  sub_10001670((int)&v3[2 * *v3 + 1], *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), *(void **)(v4 + 8));
  v6 = 2 * *v3;
  HIBYTE(v7) = v3[v6 + 2];
  LOBYTE(v7) = v3[v6 + 1];
  *(_DWORD *)(v2 + 40) = v7 + v6 + 3;
  return 0;
}

//----- (10002A70) --------------------------------------------------------
int __cdecl sub_10002A70(int a1, int a2)
{
  int v2; // edi@1
  int v3; // ebp@1
  int v4; // esi@1
  void *v5; // ST50_4@1
  int v6; // eax@1
  int v7; // eax@1
  unsigned __int16 v8; // dx@1
  char v10; // [sp+14h] [bp-1Ch]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 36);
  v4 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)v4 = 13;
  *(_WORD *)(v4 + 5) = *(_WORD *)(a1 + 4);
  *(_WORD *)(v4 + 7) = 2;
  *(_WORD *)(v4 + 9) = 0;
  *(_DWORD *)(v4 + 11) = 0;
  *(_WORD *)(v4 + 15) = 24;
  *(_WORD *)(v4 + 17) = 24;
  *(_DWORD *)(v4 + 19) = 0;
  *(_DWORD *)(v4 + 23) = 592;
  v5 = *(void **)(v3 + 8);
  sub_100018D0(*(_DWORD *)(v3 + 12), (_BYTE *)(a1 + 28736), (int)&v10, 0);
  v6 = v4 + 2 * *(_BYTE *)v4 + 1;
  *(_BYTE *)v6 = 0;
  *(_BYTE *)(v6 + 1) = 0;
  sub_10001620(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &v10, 0x18u);
  sub_100018D0(*(_DWORD *)(v3 + 12), (_BYTE *)(a1 + 28736), (int)&v10, 1);
  sub_10001620(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &v10, 0x18u);
  sub_10001670(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), v5);
  sub_10001670(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), "grm_aviation");
  sub_10001670(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), "Garmin Aviation 1.0");
  sub_10001670(v4 + 2 * *(_BYTE *)v4 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), "Garmin LM 1.0");
  v7 = 2 * *(_BYTE *)v4;
  HIBYTE(v8) = *(_BYTE *)(v7 + v4 + 2);
  LOBYTE(v8) = *(_BYTE *)(v7 + v4 + 1);
  *(_DWORD *)(a2 + 40) = v8 + v7 + 3;
  return 0;
}

//----- (10002BD0) --------------------------------------------------------
int __cdecl sub_10002BD0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // eax@1
  int v6; // eax@1
  unsigned __int16 v7; // cx@1
  char v9; // [sp+Ch] [bp-84h]@1
  char v10; // [sp+Dh] [bp-83h]@1
  char v11; // [sp+Eh] [bp-82h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v3 = 4;
  *(_WORD *)(v3 + 5) = 0;
  *(_WORD *)(v3 + 7) = 0;
  v9 = 92;
  v10 = 92;
  sub_10022150(a1 + 28720, &v11, 0x7Eu, 0);
  sub_10007B00(&v9, "\\", 128);
  sub_10007B00(&v9, *(_BYTE **)(v4 + 8), 128);
  v5 = v3 + 2 * *(_BYTE *)v3 + 1;
  *(_BYTE *)v5 = 0;
  *(_BYTE *)(v5 + 1) = 0;
  sub_10001670(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &v9);
  sub_10001670(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(v2 + 24) + *(_DWORD *)(v2 + 28), &unk_100405EC);
  v6 = 2 * *(_BYTE *)v3;
  HIBYTE(v7) = *(_BYTE *)(v6 + v3 + 2);
  LOBYTE(v7) = *(_BYTE *)(v6 + v3 + 1);
  *(_DWORD *)(a2 + 40) = v7 + v6 + 3;
  return 0;
}

//----- (10002CD0) --------------------------------------------------------
int __cdecl sub_10002CD0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  int v4; // edi@1
  unsigned int v5; // eax@1
  int v6; // eax@3
  unsigned __int16 v7; // cx@3

  v2 = *(_DWORD *)(a2 + 20);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 36);
  *(_BYTE *)v3 = 14;
  v5 = *(_DWORD *)(a2 + 28) - 31;
  if ( v5 >= *(_DWORD *)(v4 + 20) )
    v5 = *(_DWORD *)(v4 + 20);
  *(_DWORD *)(v4 + 20) = v5;
  *(_BYTE *)v3 = 14;
  *(_WORD *)(v3 + 5) = *(_WORD *)(v4 + 8);
  *(_DWORD *)(v3 + 7) = *(_DWORD *)(v4 + 12);
  *(_DWORD *)(v3 + 25) = *(_QWORD *)(v4 + 12) >> 32;
  *(_DWORD *)(v3 + 11) = 0;
  *(_WORD *)(v3 + 15) = 0;
  *(_WORD *)(v3 + 17) = 0;
  *(_WORD *)(v3 + 19) = 0;
  *(_WORD *)(v3 + 21) = *(_WORD *)(v4 + 20);
  *(_WORD *)(v3 + 23) = v3 - v2 + 31;
  *(_BYTE *)(v3 + 29) = 0;
  *(_BYTE *)(v3 + 30) = 0;
  sub_10001620(
    v3 + 2 * *(_BYTE *)v3 + 1,
    *(_DWORD *)(a2 + 28) + *(_DWORD *)(a2 + 24),
    *(void **)(v4 + 24),
    *(_DWORD *)(v4 + 20));
  v6 = 2 * *(_BYTE *)v3;
  HIBYTE(v7) = *(_BYTE *)(v6 + v3 + 2);
  LOBYTE(v7) = *(_BYTE *)(v6 + v3 + 1);
  *(_DWORD *)(a2 + 40) = v7 + v6 + 3;
  return 0;
}

//----- (10002D80) --------------------------------------------------------
int __cdecl sub_10002D80(int a1)
{
  int result; // eax@1
  int *v2; // esi@1

  result = a1;
  v2 = &dword_100B4760[8135 * a1];
  if ( dword_100407EC[7 * a1] )
  {
    if ( *(_BYTE *)v2 & 1 )
      result = sub_10002170((int)v2);
  }
  return result;
}
// 100407EC: using guessed type int dword_100407EC[];
// 100B4760: using guessed type int dword_100B4760[];

//----- (10002DC0) --------------------------------------------------------
void *sub_10002DC0()
{
  void *result; // eax@1
  int v1; // ebx@1
  int *v2; // esi@1
  int *v3; // edi@1

  result = memset(dword_100B4760, 0, 0xFE38u);
  dword_100B4760[0] |= 1u;
  dword_100BC67C |= 1u;
  v1 = 0;
  v2 = dword_100B4760;
  v3 = dword_100407EC;
  do
  {
    if ( !*v3 )
      break;
    result = (void *)sub_10002170((int)v2);
    v3 += 7;
    ++v1;
    v2 += 8135;
  }
  while ( (signed int)v3 < (signed int)"_DIS" );
  return result;
}
// 100407EC: using guessed type int dword_100407EC[];
// 100B4760: using guessed type int dword_100B4760[];
// 100BC67C: using guessed type int dword_100BC67C;

//----- (10002E20) --------------------------------------------------------
void __usercall __noreturn sub_10002E20(int a1@<ecx>, int a2@<esi>, char a3)
{
  int v3; // esi@2

  sub_10007B40(a2, a1);
  sub_10001610();
  while ( 1 )
  {
    sub_10022A70(&a3);
    v3 = 0;
    do
      sub_10002D80(v3++);
    while ( v3 < 2 );
  }
}
// 10007B40: using guessed type int __stdcall sub_10007B40(_DWORD, _DWORD);

//----- (10002E60) --------------------------------------------------------
int sub_10002E60()
{
  return sub_100229D0(51, 16);
}

//----- (10002E70) --------------------------------------------------------
signed int __cdecl sub_10002E70(int a1, const char *a2, _DWORD *a3)
{
  __int16 *v3; // ecx@0
  signed int result; // eax@1
  int *v5; // edi@1
  _DWORD *v6; // ecx@3
  unsigned int v7; // eax@3
  char *v8; // edx@3
  int v9; // esi@7
  int v10; // eax@8
  _BYTE *v11; // ecx@8
  _BYTE *v12; // edx@8
  int v13; // eax@10
  _BYTE *v14; // ecx@10
  _BYTE *v15; // edx@10
  _BYTE *v16; // ecx@12
  _BYTE *v17; // edx@12
  signed int v18; // eax@14
  __int16 v19; // cx@21
  int v20; // [sp+10h] [bp-24h]@1
  __int16 *v21; // [sp+14h] [bp-20h]@1
  char v22; // [sp+18h] [bp-1Ch]@3

  v21 = v3;
  result = -1073741724;
  *v3 = -1;
  v20 = 0;
  v5 = (int *)&off_10040718;
  while ( strcmp((const char *)*(v5 - 1), a2) )
  {
LABEL_19:
    ++v20;
    v5 += 3;
    if ( (signed int)v5 >= (signed int)&unk_1004073C )
      return result;
  }
  sub_100018D0(*v5, (_BYTE *)(a1 + 28736), (int)&v22, 1);
  v6 = a3;
  v7 = 24;
  v8 = &v22;
  do
  {
    if ( *(_DWORD *)v8 != *v6 )
      goto LABEL_7;
    v7 -= 4;
    ++v6;
    v8 += 4;
  }
  while ( v7 >= 4 );
  if ( !v7 )
  {
LABEL_16:
    v18 = 0;
    goto LABEL_17;
  }
LABEL_7:
  v9 = (unsigned __int8)*v8 - *(_BYTE *)v6;
  if ( (unsigned __int8)*v8 == *(_BYTE *)v6 )
  {
    v10 = v7 - 1;
    v11 = (char *)v6 + 1;
    v12 = v8 + 1;
    if ( !v10 )
      goto LABEL_16;
    v9 = *v12 - *v11;
    if ( *v12 == *v11 )
    {
      v13 = v10 - 1;
      v14 = v11 + 1;
      v15 = v12 + 1;
      if ( !v13 )
        goto LABEL_16;
      v9 = *v15 - *v14;
      if ( *v15 == *v14 )
      {
        v16 = v14 + 1;
        v17 = v15 + 1;
        if ( v13 == 1 )
          goto LABEL_16;
        v9 = *v17 - *v16;
        if ( *v17 == *v16 )
          goto LABEL_16;
      }
    }
  }
  v18 = 1;
  if ( v9 <= 0 )
    v18 = -1;
LABEL_17:
  if ( v18 )
  {
    result = -1073741718;
    goto LABEL_19;
  }
  v19 = word_10040710[6 * v20];
  *v21 = v19;
  *(_BYTE *)((unsigned __int16)v19 + a1 + 32532) = 1;
  return 0;
}
// 10040710: using guessed type __int16 word_10040710[];
// 10040718: using guessed type char *off_10040718;

//----- (10002FE0) --------------------------------------------------------
int __cdecl sub_10002FE0(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@1
  int v6; // eax@3

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 24);
  result = -1073741811;
  if ( *(_BYTE *)v2 == 3 && !*(_WORD *)(a2 + 16) )
  {
    v6 = sub_100019F0(a1, *(_WORD *)(v2 + 1), *(_WORD *)(*(_DWORD *)a2 + 28));
    if ( v6 )
      result = sub_10001200(v6);
    else
      result = 0;
  }
  *(_DWORD *)(v3 + 5) = result;
  *(_WORD *)v4 = 0;
  *(_BYTE *)(v4 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return result;
}

//----- (10003050) --------------------------------------------------------
int __cdecl sub_10003050(int a1, void *a2)
{
  void *v2; // edi@1
  int v3; // eax@1
  int v4; // esi@1
  unsigned int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edx@5
  int v8; // eax@5
  unsigned __int16 v9; // cx@5
  int result; // eax@5
  void *v11; // [sp+18h] [bp+8h]@1

  v2 = a2;
  v3 = *((_DWORD *)a2 + 1);
  v4 = *((_DWORD *)a2 + 6);
  *(_BYTE *)v4 = 1;
  v5 = *((_DWORD *)a2 + 3);
  v6 = *((_WORD *)a2 + 8);
  v11 = (void *)*((_DWORD *)a2 + 3);
  if ( *(_BYTE *)v3 == 1
    && *(_WORD *)(v3 + 1) == 1
    && sub_10001000(*((_DWORD *)v2 + 1), *((_DWORD *)v2 + 2), v5, v6)
    && v6 < *((_DWORD *)v2 + 7) - 2 * *(_BYTE *)v4 - 3 )
  {
    *(_WORD *)(v4 + 1) = 1;
    memcpy_0((void *)(v4 + 5), v11, v6);
    v7 = *(_BYTE *)v4;
    *(_BYTE *)(v4 + 2 * v7 + 1) = v6;
    *(_BYTE *)(v4 + 2 * v7 + 2) = BYTE1(v6);
    v8 = 2 * *(_BYTE *)v4;
    HIBYTE(v9) = *(_BYTE *)(v8 + v4 + 2);
    LOBYTE(v9) = *(_BYTE *)(v8 + v4 + 1);
    *((_DWORD *)v2 + 10) = v9 + v8 + 3;
    result = 0;
  }
  else
  {
    *((_DWORD *)v2 + 10) = 0;
    result = -1073741811;
  }
  return result;
}

//----- (10003100) --------------------------------------------------------
int __cdecl sub_10003100(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@1
  int v6; // eax@3

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 24);
  result = -1073741811;
  if ( *(_BYTE *)v2 == 1 && !*(_WORD *)(a2 + 16) )
  {
    v6 = sub_100019F0(a1, *(_WORD *)(v2 + 1), *(_WORD *)(*(_DWORD *)a2 + 28));
    if ( v6 )
      result = sub_10001200(v6);
    else
      result = 0;
  }
  *(_DWORD *)(v3 + 5) = result;
  *(_WORD *)v4 = 0;
  *(_BYTE *)(v4 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return result;
}

//----- (10003170) --------------------------------------------------------
int __cdecl sub_10003170(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // eax@6
  unsigned __int16 v7; // cx@6
  int result; // eax@6

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)a2;
  *(_BYTE *)v3 = 0;
  if ( *(_BYTE *)v2 == 1 )
  {
    v5 = sub_10001350(a1, *(_WORD *)(v2 + 1), *(_WORD *)(v4 + 28));
    if ( (unsigned int)v5 < 0xFFFFFFC2 && v5 || *(_WORD *)(v2 + 1) == -1 )
    {
      j_FIL_vfs_sync_all();
LABEL_6:
      *(_BYTE *)v3 = 0;
      *(_BYTE *)(v3 + 1) = 0;
      *(_BYTE *)(v3 + 2) = 0;
      v6 = 2 * *(_BYTE *)v3;
      HIBYTE(v7) = *(_BYTE *)(v6 + v3 + 2);
      LOBYTE(v7) = *(_BYTE *)(v6 + v3 + 1);
      *(_DWORD *)(a2 + 40) = v7 + v6 + 3;
      return 0;
    }
    if ( v5 >= 0 )
      goto LABEL_6;
    result = sub_10001200(v5);
    *(_DWORD *)(a2 + 40) = 0;
  }
  else
  {
    *(_DWORD *)(a2 + 40) = 0;
    result = -1073741811;
  }
  return result;
}
// 100226D0: using guessed type int j_FIL_vfs_sync_all(void);

//----- (10003200) --------------------------------------------------------
int __cdecl sub_10003200(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@2
  int result; // eax@5
  int v7; // eax@6
  unsigned __int16 v8; // cx@6

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)a2;
  *(_BYTE *)v3 = 2;
  if ( *(_BYTE *)v2 == 8 )
  {
    v5 = sub_10001350(a1, *(_WORD *)(v2 + 5), *(_WORD *)(v4 + 28));
    if ( (unsigned int)v5 < 0xFFFFFFC2 && v5 || v5 >= 0 )
    {
      *(_DWORD *)v3 = 0;
      *(_BYTE *)(v3 + 4) = 0;
      *(_BYTE *)v3 = 2;
      *(_BYTE *)(v3 + 5) = 0;
      *(_BYTE *)(v3 + 6) = 0;
      v7 = 2 * *(_BYTE *)v3;
      HIBYTE(v8) = *(_BYTE *)(v7 + v3 + 2);
      LOBYTE(v8) = *(_BYTE *)(v7 + v3 + 1);
      *(_DWORD *)(a2 + 40) = v8 + v7 + 3;
      result = 0;
    }
    else
    {
      result = sub_10001200(v5);
      *(_DWORD *)(a2 + 40) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 40) = 0;
    result = -1073741811;
  }
  return result;
}

//----- (10003290) --------------------------------------------------------
signed int __cdecl sub_10003290(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // ebp@1
  char v6; // dl@2
  int v7; // edx@10
  int v8; // eax@10
  int v9; // eax@10
  unsigned __int16 v10; // cx@10
  int v11; // ecx@10
  signed int result; // eax@10
  signed __int16 v13; // [sp+10h] [bp-10h]@1
  int v14; // [sp+14h] [bp-Ch]@10
  int v15; // [sp+18h] [bp-8h]@10

  v2 = *(_WORD *)(a2 + 16);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = 0;
  v5 = 0;
  v13 = -1;
  if ( v2 <= 0 )
  {
LABEL_11:
    result = -1073741811;
    v11 = 0;
  }
  else
  {
    do
    {
      v6 = *(_BYTE *)(*(_DWORD *)(a2 + 12) + v5);
      if ( v6 == byte_10040990[v4] )
      {
        if ( v6 == 2 )
          ++v13;
        if ( ++v4 == 12 )
          goto LABEL_10;
      }
      else
      {
        v4 = 0;
      }
      ++v5;
    }
    while ( v5 < v2 );
    if ( v4 != 12 )
      goto LABEL_11;
LABEL_10:
    *(_WORD *)(v3 + 1) = v13;
    *(_BYTE *)v3 = 17;
    *(_WORD *)(v3 + 6) = 1;
    *(_BYTE *)(v3 + 3) = 3;
    *(_WORD *)(v3 + 4) = 3;
    *(_DWORD *)(v3 + 8) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v3 + 12) = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v3 + 20) = 592;
    *(_DWORD *)(v3 + 24) = -717324288;
    *(_DWORD *)(v3 + 28) = 27111902;
    *(_BYTE *)(v3 + 34) = 8;
    *(_DWORD *)(v3 + 16) = 0;
    *(_WORD *)(v3 + 32) = 0;
    v7 = *(_DWORD *)(a1 + 28736);
    v15 = *(_DWORD *)(a1 + 28740);
    v14 = v7;
    v8 = v3 + 2 * *(_BYTE *)v3 + 1;
    *(_BYTE *)v8 = 0;
    *(_BYTE *)(v8 + 1) = 0;
    sub_10001620(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28), &v14, 8u);
    sub_10001670(v3 + 2 * *(_BYTE *)v3 + 1, *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 28), "grm_aviation");
    v9 = 2 * *(_BYTE *)v3;
    HIBYTE(v10) = *(_BYTE *)(v9 + v3 + 2);
    LOBYTE(v10) = *(_BYTE *)(v9 + v3 + 1);
    v11 = v10 + v9 + 3;
    result = 0;
  }
  *(_DWORD *)(a2 + 40) = v11;
  return result;
}

//----- (100033E0) --------------------------------------------------------
int __cdecl sub_100033E0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // ecx@1
  char v7; // al@1
  unsigned int v8; // ebx@7
  int v9; // eax@9
  _BYTE *v10; // eax@11
  int result; // eax@16
  int v12; // ecx@18
  int v13; // eax@18
  unsigned __int16 v14; // dx@18
  int v15; // [sp+10h] [bp-8h]@5
  int v16; // [sp+14h] [bp-4h]@5
  int v17; // [sp+20h] [bp+8h]@1
  unsigned int v18; // [sp+20h] [bp+8h]@9

  v2 = a2;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)v5 = 12;
  v6 = *(_WORD *)(a2 + 16);
  v17 = v3;
  v7 = *(_BYTE *)v4;
  if ( (*(_BYTE *)v4 == 12 || v7 == 10) && !v6 )
  {
    if ( v7 == 10 )
    {
      v15 = *(_DWORD *)(v4 + 7);
      v16 = 0;
    }
    else
    {
      v15 = *(_DWORD *)(v4 + 7);
      v16 = *(_DWORD *)(v4 + 21);
    }
    v8 = *(_DWORD *)(v2 + 28) - 27;
    if ( v8 >= *(_WORD *)(v4 + 11) )
      v8 = *(_WORD *)(v4 + 11);
    v9 = sub_10001350(a1, *(_WORD *)(v4 + 5), *(_WORD *)(v17 + 28));
    v18 = v9;
    if ( (unsigned int)v9 < 0xFFFFFFC2 )
    {
      if ( !v9 )
      {
LABEL_18:
        *(_DWORD *)v5 = 0;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)(v5 + 8) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_DWORD *)(v5 + 16) = 0;
        *(_DWORD *)(v5 + 20) = 0;
        *(_BYTE *)(v5 + 24) = 0;
        *(_BYTE *)v5 = 12;
        *(_BYTE *)(v5 + 25) = 0;
        *(_BYTE *)(v5 + 26) = 0;
        v12 = *(_BYTE *)v5;
        *(_WORD *)(v5 + 11) = v9;
        *(_WORD *)(v5 + 13) = 59;
        *(_WORD *)(v5 + 5) = -1;
        *(_BYTE *)(v5 + 2 * v12 + 1) = v9;
        *(_BYTE *)(v5 + 2 * v12 + 2) = BYTE1(v9);
        v13 = 2 * *(_BYTE *)v5;
        HIBYTE(v14) = *(_BYTE *)(v13 + v5 + 2);
        LOBYTE(v14) = *(_BYTE *)(v13 + v5 + 1);
        *(_DWORD *)(v2 + 40) = v14 + v13 + 3;
        return 0;
      }
      v10 = (_BYTE *)sub_10001240(a1, *(_WORD *)(v4 + 5));
      if ( (unsigned int)v10 >= 0xFFFFFFC2 || !v10 || *v10 & 2 )
      {
        v9 = -48;
        goto LABEL_16;
      }
      v9 = sub_10022490(v18, (void *)(v5 + 27), v8, v15, v16);
    }
    if ( v9 < 0 )
    {
LABEL_16:
      result = sub_10001200(v9);
      *(_DWORD *)(v2 + 40) = 0;
      return result;
    }
    goto LABEL_18;
  }
  *(_DWORD *)(v2 + 40) = 0;
  return -1073741811;
}

//----- (10003550) --------------------------------------------------------
signed int __cdecl sub_10003550(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // eax@1
  const char *v6; // ebp@1
  int v7; // edi@1
  unsigned int v8; // kr00_4@1
  unsigned __int16 v9; // ax@3
  unsigned __int16 v10; // cx@9
  _DWORD *v11; // ecx@11
  int v12; // eax@16
  int v13; // eax@16
  unsigned __int16 v14; // dx@16
  signed int result; // eax@17
  signed int v16; // [sp+10h] [bp-14h]@1
  int v17; // [sp+14h] [bp-10h]@1
  _DWORD *v18; // [sp+1Ch] [bp-8h]@1
  int v19; // [sp+20h] [bp-4h]@1
  unsigned int v20; // [sp+2Ch] [bp+8h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(a2 + 12);
  v19 = *(_DWORD *)(a2 + 20);
  v5 = *(_WORD *)(v3 + 15);
  v6 = (const char *)(v4 + v5 + *(_WORD *)(v3 + 17));
  v20 = v5 + v4;
  v7 = *(_DWORD *)(v2 + 24);
  v17 = 0;
  v18 = (_DWORD *)v4;
  v8 = strlen(v6);
  v16 = -1073741811;
  if ( *(_BYTE *)v3 == 13 && *(_WORD *)(v3 + 5) >= 0x100u )
  {
    v9 = *(_WORD *)(v3 + 15);
    if ( (v9 == 24 || v9 == 1)
      && sub_10001000(v3, *(_DWORD *)(v2 + 8), v4, v9)
      && sub_10001000(*(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), v20, *(_WORD *)(v3 + 17))
      && sub_10001000(*(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), (unsigned int)v6, strlen(v6) + 1)
      && sub_10001000(*(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), (unsigned int)&v6[v8 + 1], strlen(&v6[v8 + 1]) + 1) )
    {
      v10 = *(_WORD *)(v3 + 5);
      if ( *(_WORD *)(a1 + 4) > v10 )
        *(_WORD *)(a1 + 4) = v10;
      v11 = v18;
      if ( *(_WORD *)(v3 + 17) )
        v11 = (_DWORD *)v20;
      *(_BYTE *)v7 = 3;
      *(_WORD *)(v7 + 5) = 0;
      v16 = sub_10002E70(a1, v6, v11);
      *(_WORD *)(v19 + 28) = v20;
      if ( v16 )
        v16 = -1073741715;
      else
        *(_DWORD *)(v2 + 44) = (unsigned __int16)v20;
      v12 = v7 + 2 * *(_BYTE *)v7 + 1;
      *(_BYTE *)v12 = 0;
      *(_BYTE *)(v12 + 1) = 0;
      sub_10001620(v7 + 2 * *(_BYTE *)v7 + 1, *(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 24), "Garmin Aviation 1.0", 0x14u);
      sub_10001620(v7 + 2 * *(_BYTE *)v7 + 1, *(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 24), "Garmin LM 1.0", 0xEu);
      sub_10001670(v7 + 2 * *(_BYTE *)v7 + 1, *(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 24), "grm_aviation");
      v13 = 2 * *(_BYTE *)v7;
      HIBYTE(v14) = *(_BYTE *)(v13 + v7 + 2);
      LOBYTE(v14) = *(_BYTE *)(v13 + v7 + 1);
      v17 = v14 + v13 + 3;
    }
  }
  result = v16;
  *(_DWORD *)(v2 + 40) = v17;
  return result;
}

//----- (10003770) --------------------------------------------------------
signed int __cdecl sub_10003770(int a1, const char *a2, __int16 a3, _WORD *a4)
{
  int v4; // edi@1
  unsigned int v5; // eax@1
  signed int v6; // ebx@1
  int v7; // ebp@2
  int v8; // esi@3
  _BYTE *v9; // eax@3
  int v10; // esi@3
  int v11; // edx@6
  int v12; // eax@6
  _WORD *v13; // ecx@7
  unsigned int v14; // eax@15
  _DWORD *v15; // ecx@15
  signed int result; // eax@21
  __int16 v17; // [sp+10h] [bp-8h]@1
  signed int v18; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v18 = -1073741620;
  v17 = 0;
  v5 = strlen(a2);
  v6 = 0;
  if ( !*(_BYTE *)(a1 + 28748) )
    goto LABEL_23;
  v7 = v5 + 1;
  while ( 1 )
  {
    v8 = *(_DWORD *)(a1 + 28744);
    v9 = *(_BYTE **)(v8 + v4);
    v10 = v4 + v8;
    if ( !sub_10007840(a2, v9, v7) )
      break;
    ++v6;
    v4 += 16;
    if ( v6 >= *(_BYTE *)(a1 + 28748) )
      goto LABEL_23;
  }
  v11 = *(_BYTE *)(v10 + 12);
  v12 = 0;
  if ( v11 > 0 )
  {
    v13 = *(_WORD **)(v10 + 8);
    while ( *v13 != a3 )
    {
      ++v12;
      ++v13;
      if ( v12 >= v11 )
        goto LABEL_12;
    }
    v17 = v6 - 4096;
  }
LABEL_12:
  if ( v12 >= v11 )
  {
    v10 = 0;
    v18 = -1073741790;
  }
  if ( v17 )
  {
    v14 = 0;
    v15 = (_DWORD *)(a1 + 32512);
    while ( *v15 )
    {
      ++v14;
      ++v15;
      if ( v14 >= 5 )
      {
        v17 = 0;
        v18 = -1073741801;
        goto LABEL_23;
      }
    }
    *(_DWORD *)(a1 + 4 * v14 + 32512) = v10;
    if ( v14 < 5 )
    {
      *a4 = v17;
      return 0;
    }
    v17 = 0;
    v18 = -1073741801;
    goto LABEL_23;
  }
  if ( v18 )
  {
LABEL_23:
    sub_10007840(a2, "IPC$", 5);
    result = v18;
    *a4 = v17;
    return result;
  }
  *a4 = 0;
  return 0;
}

//----- (100038F0) --------------------------------------------------------
int __usercall sub_100038F0@<eax>(int a1@<eax>, unsigned __int16 a2@<cx>)
{
  int v2; // esi@1
  int v3; // edx@1
  int v4; // ecx@1
  int result; // eax@1
  int v6; // ecx@2
  unsigned int v7; // edx@2
  _DWORD *v8; // esi@2

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 28748);
  v4 = a2 - 61440;
  result = 0;
  if ( v4 < v3 )
  {
    v6 = *(_DWORD *)(v2 + 28744) + 16 * v4;
    v7 = 0;
    result = v6;
    v8 = (_DWORD *)(v2 + 32512);
    while ( v6 != *v8 )
    {
      ++v7;
      ++v8;
      if ( v7 >= 5 )
        return 0;
    }
    if ( v7 >= 5 )
      result = 0;
  }
  return result;
}

//----- (10003940) --------------------------------------------------------
int __usercall sub_10003940@<eax>(_BYTE *a1@<edx>, _WORD *a2@<ecx>, int a3@<ebx>, unsigned int a4, int a5, char a6, __int16 a7, int a8, unsigned __int16 a9, _BYTE *a10)
{
  unsigned int v10; // ebp@1
  _BYTE *v11; // edi@1
  int v12; // esi@1
  int v13; // eax@10
  int v14; // ebp@11
  unsigned int v15; // eax@11
  int v16; // edx@11
  int v17; // ecx@11
  unsigned int v18; // eax@16
  char *v19; // eax@23
  char v20; // cl@24
  size_t v21; // ebp@25
  int v22; // edi@25
  int v23; // edx@28
  int v24; // edx@28
  int v25; // eax@28
  int v26; // edx@28
  int v27; // eax@32
  int result; // eax@38
  char v29; // [sp+Fh] [bp-1E5h]@8
  int v30; // [sp+10h] [bp-1E4h]@10
  char v31; // [sp+17h] [bp-1DDh]@1
  int v32; // [sp+18h] [bp-1DCh]@0
  int *v33; // [sp+1Ch] [bp-1D8h]@9
  signed int v34; // [sp+20h] [bp-1D4h]@1
  _WORD *v35; // [sp+24h] [bp-1D0h]@1
  int v36; // [sp+28h] [bp-1CCh]@1
  char v37; // [sp+34h] [bp-1C0h]@25
  int v38; // [sp+40h] [bp-1B4h]@28
  int v39; // [sp+44h] [bp-1B0h]@28
  int v40; // [sp+48h] [bp-1ACh]@28
  int v41; // [sp+4Ch] [bp-1A8h]@28
  int v42; // [sp+50h] [bp-1A4h]@28
  int v43; // [sp+54h] [bp-1A0h]@28
  int v44; // [sp+58h] [bp-19Ch]@28
  int v45; // [sp+5Ch] [bp-198h]@28
  int v46; // [sp+70h] [bp-184h]@9
  int v47; // [sp+74h] [bp-180h]@10
  int v48; // [sp+78h] [bp-17Ch]@10
  int v49; // [sp+7Ch] [bp-178h]@10
  int v50; // [sp+80h] [bp-174h]@10
  int v51; // [sp+84h] [bp-170h]@10
  int v52; // [sp+88h] [bp-16Ch]@10
  char v53; // [sp+170h] [bp-84h]@25

  v10 = a4;
  v11 = a1;
  v34 = a4;
  v36 = (int)a1;
  v35 = a2;
  *a10 = 1;
  v12 = a3 + 8;
  v31 = sub_100077C0(a1);
  if ( a7 == 260 )
  {
    v32 = 94;
  }
  else if ( a7 == 257 )
  {
    v32 = 64;
  }
  else
  {
    v34 = -15;
    v10 = -15;
  }
  *(_WORD *)(a3 + 2) = 1;
  if ( v10 < 0xFFFFFFC2 && v10 )
  {
    v29 = 0;
LABEL_9:
    v33 = &v46;
    if ( v31 )
    {
      v14 = *v35;
      v15 = (a8 - v14) / (unsigned int)(v32 + 128);
      v16 = *(_WORD *)a3;
      v17 = a9 - v16;
      if ( v15 >= v17 )
        v15 = a9 - v16;
      if ( v15 )
      {
        v30 = sub_10022530(v34, &v46, 256, v36, v15);
      }
      else
      {
        v30 = -1;
        if ( a8 - v14 <= v32 || v17 <= 0 )
          goto LABEL_43;
        v18 = a8 - v14 - v32 + 28;
        if ( v18 > 0x100 )
          v18 = 256;
        v30 = sub_10022530(v34, &v46, v18, v36, 1);
        if ( v30 < 0 )
LABEL_43:
          *(_WORD *)(a3 + 2) = *(_WORD *)a3 == 0;
      }
      v13 = v30;
    }
    else
    {
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v13 = sub_100077F0((int)&v52, v11, 228) + 27;
      v30 = v13;
      LOWORD(v47) = v13;
      v29 = 1;
    }
    if ( v13 > 0 )
    {
      while ( 1 )
      {
        v19 = (char *)(v33 + 6);
        do
          v20 = *v19++;
        while ( v20 );
        v21 = v19 - ((char *)v33 + 25) + 1;
        v22 = v32 + v21;
        sub_10007A80(&v53, 0x80u, "%s%c%s", a5, 47, v33 + 6);
        if ( !sub_10022770((int)&v53, &v37) )
        {
          if ( *(_WORD *)a3 >= a9 || a8 < v22 + *v35 )
          {
            *(_WORD *)(a3 + 2) = 0;
            v29 = 1;
          }
          else
          {
            *v35 += v22;
            ++*(_WORD *)a3;
            *(_DWORD *)v12 = v22;
            *(_DWORD *)(v12 + 4) = *v33;
            *(_DWORD *)(v12 + 8) = sub_100011F0(v42);
            *(_DWORD *)(v12 + 12) = v23;
            *(_DWORD *)(v12 + 16) = sub_100011F0(v40);
            *(_DWORD *)(v12 + 20) = v24;
            v25 = sub_100011F0(v41);
            *(_DWORD *)(v12 + 24) = v25;
            *(_DWORD *)(v12 + 28) = v26;
            *(_DWORD *)(v12 + 32) = v25;
            *(_DWORD *)(v12 + 36) = v26;
            *(_DWORD *)(v12 + 40) = v38;
            *(_DWORD *)(v12 + 44) = v39;
            *(_DWORD *)(v12 + 48) = v44 * v43;
            *(_DWORD *)(v12 + 52) = 0;
            *(_DWORD *)(v12 + 56) = v45;
            *(_DWORD *)(v12 + 60) = v21;
            if ( a7 == 260 )
            {
              *(_DWORD *)(v12 + 64) = 0;
              *(_BYTE *)(v12 + 68) = 0;
              *(_BYTE *)(v12 + 69) = 0;
              *(_DWORD *)(v12 + 70) = 0;
              *(_DWORD *)(v12 + 74) = 0;
              *(_DWORD *)(v12 + 78) = 0;
              *(_DWORD *)(v12 + 82) = 0;
              *(_DWORD *)(v12 + 86) = 0;
              *(_DWORD *)(v12 + 90) = 0;
            }
            memcpy_0((void *)(v12 + v32), v33 + 6, v21);
            v12 += *(_DWORD *)v12;
          }
        }
        v27 = *((_WORD *)v33 + 2);
        v30 -= v27;
        v33 = (int *)((char *)v33 + v27);
        if ( v29 )
          break;
        if ( v30 <= 0 )
        {
          v11 = (_BYTE *)v36;
          goto LABEL_9;
        }
      }
    }
    if ( *(_WORD *)(a3 + 2) && a6 & 2 || a6 & 1 )
    {
      *a10 = 1;
      result = 0;
    }
    else
    {
      *a10 = 0;
      result = 0;
    }
  }
  else
  {
    result = sub_10001200(v10);
  }
  return result;
}
// 100011F0: using guessed type _DWORD __cdecl sub_100011F0(_DWORD);

//----- (10003D10) --------------------------------------------------------
signed int __usercall sub_10003D10@<eax>(unsigned __int16 a1@<dx>, int a2@<ecx>, int a3, int a4, int a5, signed __int64 a6, _WORD *a7)
{
  unsigned __int16 v7; // di@1
  unsigned int v8; // ebx@1
  _BYTE *v9; // eax@1
  __int64 v10; // rax@8
  unsigned int v11; // edi@8
  unsigned int v12; // esi@8
  int v13; // eax@11
  int v14; // eax@13
  int v15; // eax@15
  signed int result; // eax@19
  int v17; // [sp+14h] [bp-208h]@1
  char v18; // [sp+18h] [bp-204h]@10

  v7 = a1;
  v17 = a2;
  v8 = sub_10001350(a3, a1, *(_WORD *)(a4 + 28));
  v9 = (_BYTE *)sub_10001240(a3, v7);
  *a7 = 0;
  if ( a6 > 0x7FFFFFFF || (unsigned int)a5 > 0xFFFF )
  {
    result = -1073741811;
  }
  else if ( (unsigned int)v9 >= 0xFFFFFFC2 || !v9 || *v9 & 2 )
  {
    result = sub_10001200(-48);
  }
  else
  {
    if ( v8 < 0xFFFFFFC2 && v8 )
    {
      v10 = sub_100226B0(v8);
      v11 = HIDWORD(v10);
      v12 = v10;
      if ( a6 > v10 && SHIDWORD(v10) >= 0 )
      {
        memset(&v18, 0, 0x200u);
        do
        {
          v13 = a6 - v12;
          if ( (unsigned int)a6 - v12 > 0x200 )
            v13 = 512;
          v14 = sub_10022710(v8, (int)&v18, v13, v12);
          if ( v14 <= 0 )
            break;
          v11 = (v14 + __PAIR__(v11, v12)) >> 32;
          v12 += v14;
        }
        while ( a6 > (signed __int64)__PAIR__(v11, v12) );
      }
      v15 = sub_10022710(v8, v17, a5, a6);
      if ( v15 < 0 )
        return sub_10001200(v15);
      if ( v15 <= a5 )
        *a7 = v15;
    }
    else
    {
      v15 = v8;
    }
    if ( v15 < 0 )
      return sub_10001200(v15);
    result = 0;
  }
  return result;
}

//----- (10003EC0) --------------------------------------------------------
char __usercall sub_10003EC0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned int v2; // ebx@1
  unsigned int v3; // edi@1
  char result; // al@1
  unsigned int v5; // esi@5

  v1 = a1;
  v2 = sub_10001060(a1, (int)dword_100C4658);
  sub_10001B00(v1, 0, -2);
  *(_DWORD *)(v1 + 32512) = 0;
  *(_DWORD *)(v1 + 32516) = 0;
  *(_DWORD *)(v1 + 32520) = 0;
  *(_DWORD *)(v1 + 32524) = 0;
  *(_DWORD *)(v1 + 32528) = 0;
  *(_WORD *)(v1 + 32532) = 0;
  *(_BYTE *)(v1 + 32534) = 0;
  v3 = *(_DWORD *)(v1 + 28732);
  *(_DWORD *)(v1 + 28684) = &unk_10040870;
  *(_BYTE *)(v1 + 28688) = 18;
  *(_DWORD *)(v1 + 28692) = 0;
  *(_DWORD *)(v1 + 28696) = 30000;
  result = sub_10001080(v1, (int)&unk_10040738 + 28 * v2, 1, 0);
  if ( v3 != *(_DWORD *)(v1 + 28732) )
  {
    if ( v3 < 0xFFFFFFC2 && v3 )
      result = sub_10022250((int)&unk_100C4598, v3);
    v5 = *(_DWORD *)(v1 + 28732);
    if ( v5 < 0xFFFFFFC2 )
    {
      if ( v5 )
        result = sub_100221C0((int)&unk_100C4598, v5);
    }
  }
  return result;
}
// 100C4658: using guessed type int dword_100C4658[];

//----- (10003FA0) --------------------------------------------------------
int __cdecl sub_10003FA0(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // eax@1
  unsigned int v8; // edx@1
  __int16 v9; // dx@3
  int v10; // eax@3
  signed int v11; // eax@7
  unsigned __int16 v12; // cx@7
  __int16 v13; // dx@7
  unsigned __int16 v14; // ST14_2@7
  __int16 v15; // ax@7
  __int16 v16; // cx@7
  __int16 v17; // ax@8
  int v18; // ecx@8
  __int16 v19; // dx@8
  int v20; // eax@8
  int v21; // ebx@8
  char v23; // [sp+13h] [bp-C1h]@1
  int v24; // [sp+14h] [bp-C0h]@1
  int v25; // [sp+18h] [bp-BCh]@7
  int v26; // [sp+1Ch] [bp-B8h]@1
  unsigned int v27; // [sp+20h] [bp-B4h]@7
  int v28; // [sp+24h] [bp-B0h]@1
  char v29; // [sp+28h] [bp-ACh]@7
  char v30; // [sp+50h] [bp-84h]@7

  v2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)v4 = 10;
  v24 = v2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)a2 + *(_WORD *)(v5 + 21);
  v7 = *(_DWORD *)(a2 + 28);
  v28 = v3;
  v8 = *(_WORD *)(v5 + 7);
  v23 = 1;
  v26 = v7 - 31;
  if ( v7 - 31 >= v8 )
    v26 = v8;
  v9 = *(_WORD *)(v6 + 4);
  v10 = -1073741811;
  if ( v9 != 260 && v9 != 257
    || *(_WORD *)(v5 + 5) < 8u
    || *(_WORD *)(v6 + 2) <= 1u
    || (*(_DWORD *)v4 = 0,
        *(_DWORD *)(v4 + 4) = 0,
        *(_DWORD *)(v4 + 8) = 0,
        *(_DWORD *)(v4 + 12) = 0,
        *(_DWORD *)(v4 + 16) = 0,
        *(_BYTE *)(v4 + 20) = 0,
        *(_WORD *)(v4 + 13) = 0,
        *(_BYTE *)v4 = 10,
        *(_WORD *)(v4 + 7) = 8,
        *(_WORD *)(v4 + 9) = 55,
        *(_WORD *)(v4 + 15) = 63,
        *(_DWORD *)(v4 + 23) = 0,
        *(_DWORD *)(v4 + 27) = 0,
        v11 = sub_10001350(a1, *(_WORD *)v6, *(_WORD *)(v24 + 28)),
        v12 = *(_WORD *)v6,
        v27 = v11,
        sub_100019A0(a1, v12, &v30, 0x80u),
        sub_10001390(a1, *(_WORD *)v6, &v29, 40),
        v13 = *(_WORD *)(v6 + 4),
        v14 = *(_WORD *)(v6 + 2),
        v15 = *(_WORD *)(v6 + 10),
        v25 = *(_WORD *)(v4 + 13),
        v10 = sub_10003940(&v29, &v25, v4 + 23, v27, (int)&v30, v15, v13, v26, v14, &v23),
        v16 = v25,
        *(_WORD *)(v4 + 13) = v25,
        v10) )
  {
    *(_DWORD *)(v28 + 5) = v10;
    *(_WORD *)v4 = 0;
    v21 = 3;
    *(_BYTE *)(v4 + 2) = 0;
  }
  else
  {
    v17 = v16 + *(_WORD *)(v4 + 7);
    v18 = *(_BYTE *)v4;
    *(_BYTE *)(v4 + 2 * v18 + 1) = v17;
    *(_BYTE *)(v4 + 2 * v18 + 2) = HIBYTE(v17);
    v19 = *(_WORD *)(v4 + 13);
    *(_WORD *)(v4 + 1) = *(_WORD *)(v4 + 7);
    v20 = 2 * *(_BYTE *)v4;
    *(_WORD *)(v4 + 3) = v19;
    BYTE1(v18) = *(_BYTE *)(v20 + v4 + 2);
    LOBYTE(v18) = *(_BYTE *)(v20 + v4 + 1);
    v21 = (unsigned __int16)v18 + v20 + 3;
  }
  if ( v23 )
    sub_100019F0(a1, *(_WORD *)v6, *(_WORD *)(v24 + 28));
  return v21;
}

//----- (10004180) --------------------------------------------------------
int __cdecl sub_10004180(int a1, __int16 a2)
{
  _DWORD *v2; // ecx@0
  _DWORD *v3; // edi@1
  int v4; // ecx@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // ebp@1
  int v8; // ebx@1
  int v9; // eax@1
  unsigned __int16 v10; // di@4
  unsigned int v11; // ebp@17
  int v12; // eax@19
  int v13; // eax@23
  int result; // eax@24
  int v15; // edx@28
  int v16; // edx@28
  int v17; // eax@28
  int v18; // edx@28
  const char *v19; // ebx@28
  int v20; // edx@36
  int v21; // edx@36
  int v22; // eax@36
  int v23; // edx@36
  __int16 v24; // ax@37
  int v25; // ecx@37
  __int16 v26; // dx@37
  int v27; // eax@37
  int v28; // [sp+10h] [bp-D0h]@1
  int v29; // [sp+18h] [bp-C8h]@1
  int v30; // [sp+1Ch] [bp-C4h]@1
  char v31; // [sp+20h] [bp-C0h]@19
  int v32; // [sp+2Ch] [bp-B4h]@26
  int v33; // [sp+30h] [bp-B0h]@26
  int v34; // [sp+34h] [bp-ACh]@28
  int v35; // [sp+38h] [bp-A8h]@28
  int v36; // [sp+3Ch] [bp-A4h]@28
  int v37; // [sp+40h] [bp-A0h]@26
  int v38; // [sp+44h] [bp-9Ch]@26
  int v39; // [sp+48h] [bp-98h]@26
  char v40; // [sp+5Ch] [bp-84h]@3

  v3 = v2;
  v4 = *v2;
  v5 = v3[5];
  v6 = v3[6];
  *(_BYTE *)v6 = 10;
  v7 = v3[1];
  v8 = *v3 + *(_WORD *)(v7 + 21);
  v29 = v4;
  v30 = v5;
  v9 = sub_100038F0(a1, *(_WORD *)(v4 + 24));
  v28 = v3[7] - 59;
  if ( v28 >= (unsigned int)*(_WORD *)(v7 + 7) )
    v28 = *(_WORD *)(v7 + 7);
  v40 = 0;
  if ( a2 == 7 )
    v10 = *(_WORD *)(v8 + 2);
  else
    v10 = *(_WORD *)v8;
  if ( *(_BYTE *)v7 != 15
    || *(_WORD *)(v7 + 23)
    || v10 != 258 && v10 != 259 && v10 != 4 && v10 != 265 && v10 != 263 && v10 != 257
    || !v9
    || v28 < 4 )
  {
    v13 = -1073741811;
    goto LABEL_24;
  }
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  *(_BYTE *)(v6 + 20) = 0;
  *(_BYTE *)v6 = 10;
  *(_WORD *)(v6 + 7) = 0;
  *(_WORD *)(v6 + 9) = 0;
  *(_WORD *)(v6 + 13) = 0;
  *(_WORD *)(v6 + 15) = 55;
  *(_DWORD *)(v6 + 23) = 0;
  *(_DWORD *)(v6 + 27) = 0;
  *(_DWORD *)(v6 + 31) = 0;
  *(_DWORD *)(v6 + 35) = 0;
  *(_DWORD *)(v6 + 39) = 0;
  *(_DWORD *)(v6 + 43) = 0;
  *(_DWORD *)(v6 + 47) = 0;
  *(_DWORD *)(v6 + 51) = 0;
  *(_DWORD *)(v6 + 55) = 0;
  if ( a2 == 7 )
  {
    v11 = sub_10001350(a1, *(_WORD *)v8, *(_WORD *)(v29 + 28));
    sub_100019A0(a1, *(_WORD *)v8, &v40, 0x80u);
    if ( v11 < 0xFFFFFFC2 && v11 )
      v12 = sub_10022380(v11, &v31);
    else
      v12 = v11;
  }
  else
  {
    sub_10001540(*(_DWORD *)(v9 + 4), v8 + 6, &v40, 0x80u);
    v12 = sub_10022770((int)&v40, &v31);
  }
  if ( v12 )
  {
    v13 = sub_10001200(v12);
    if ( v13 )
    {
LABEL_24:
      *(_DWORD *)(v30 + 5) = v13;
      *(_WORD *)v6 = 0;
      result = 3;
      *(_BYTE *)(v6 + 2) = 0;
      return result;
    }
    result = 0;
  }
  else
  {
    switch ( v10 )
    {
      case 0x102u:
        *(_DWORD *)(v6 + 23) = v37 * v38;
        *(_DWORD *)(v6 + 27) = 0;
        *(_DWORD *)(v6 + 31) = v32;
        *(_DWORD *)(v6 + 35) = v33;
        *(_DWORD *)(v6 + 39) = 1;
        *(_BYTE *)(v6 + 43) = 0;
        *(_BYTE *)(v6 + 44) = (v39 & 0x10) == 16;
        *(_WORD *)(v6 + 13) = 22;
        break;
      case 0x107u:
        *(_DWORD *)(v6 + 23) = sub_100011F0(v36);
        *(_DWORD *)(v6 + 27) = v15;
        *(_DWORD *)(v6 + 31) = sub_100011F0(v34);
        *(_DWORD *)(v6 + 35) = v16;
        v17 = sub_100011F0(v35);
        *(_DWORD *)(v6 + 39) = v17;
        *(_DWORD *)(v6 + 43) = v18;
        *(_DWORD *)(v6 + 51) = v18;
        *(_DWORD *)(v6 + 47) = v17;
        *(_DWORD *)(v6 + 55) = v39 & 0x7FFF;
        *(_DWORD *)(v6 + 59) = 0;
        *(_DWORD *)(v6 + 63) = v37 * v38;
        *(_DWORD *)(v6 + 67) = 0;
        *(_DWORD *)(v6 + 71) = v32;
        *(_DWORD *)(v6 + 75) = v33;
        *(_DWORD *)(v6 + 79) = 1;
        *(_BYTE *)(v6 + 83) = 0;
        v19 = (const char *)(v8 + 6);
        *(_BYTE *)(v6 + 84) = (v39 & 0x10) == 16;
        *(_WORD *)(v6 + 85) = 0;
        *(_DWORD *)(v6 + 87) = 0;
        *(_DWORD *)(v6 + 91) = strlen(v19) + 1;
        if ( sub_100077F0(v6 + 95, v19, v28 - 72) < 0 )
          *(_DWORD *)(v6 + 91) = 0;
        *(_WORD *)(v6 + 13) = *(_WORD *)(v6 + 91) + 72;
        break;
      case 0x103u:
        *(_DWORD *)(v6 + 23) = 4;
        *(_WORD *)(v6 + 13) = 4;
        break;
      default:
        if ( v10 != 265 )
        {
          if ( v10 == 4 )
          {
            *(_WORD *)(v6 + 7) = 2;
            *(_WORD *)(v6 + 9) = 55;
            *(_WORD *)(v6 + 13) = 8;
            *(_WORD *)(v6 + 15) = 57;
            *(_WORD *)(v6 + 23) = 0;
            *(_DWORD *)(v6 + 25) = 0;
          }
          else
          {
            *(_DWORD *)(v6 + 23) = sub_100011F0(v36);
            *(_DWORD *)(v6 + 27) = v20;
            *(_DWORD *)(v6 + 31) = sub_100011F0(v34);
            *(_DWORD *)(v6 + 35) = v21;
            v22 = sub_100011F0(v35);
            *(_DWORD *)(v6 + 39) = v22;
            *(_DWORD *)(v6 + 43) = v23;
            *(_DWORD *)(v6 + 47) = v22;
            *(_DWORD *)(v6 + 51) = v23;
            *(_DWORD *)(v6 + 55) = v39;
            *(_WORD *)(v6 + 13) = 36;
          }
        }
        break;
    }
    v24 = *(_WORD *)(v6 + 13);
    v25 = v6 + 2 * *(_BYTE *)v6 + 1;
    *(_WORD *)(v6 + 7) = 0;
    *(_BYTE *)v25 = v24;
    *(_BYTE *)(v25 + 1) = HIBYTE(v24);
    v26 = *(_WORD *)(v6 + 13);
    *(_WORD *)(v6 + 1) = *(_WORD *)(v6 + 7);
    v27 = 2 * *(_BYTE *)v6;
    *(_WORD *)(v6 + 3) = v26;
    BYTE1(v25) = *(_BYTE *)(v27 + v6 + 2);
    LOBYTE(v25) = *(_BYTE *)(v27 + v6 + 1);
    result = (unsigned __int16)v25 + v27 + 3;
  }
  return result;
}
// 100011F0: using guessed type _DWORD __cdecl sub_100011F0(_DWORD);

//----- (10004560) --------------------------------------------------------
signed int __cdecl sub_10004560(int a1)
{
  _DWORD *v1; // ecx@0
  _DWORD *v2; // edi@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // esi@1
  int v6; // ebx@1
  __int16 *v7; // ebp@1
  int v8; // eax@1
  signed int v9; // ecx@1
  unsigned int v10; // edi@1
  __int16 v11; // dx@3
  int v12; // edi@3
  signed int v13; // ebx@3
  int v14; // eax@9
  __int16 v15; // ax@11
  unsigned int v16; // eax@14
  unsigned int v17; // edi@14
  int v18; // ebx@16
  int v19; // eax@19
  int v20; // eax@20
  unsigned int v21; // eax@21
  unsigned int v22; // edi@21
  __int16 v23; // ax@30
  int v24; // ecx@30
  int v25; // eax@30
  unsigned __int16 v26; // dx@30
  signed int result; // eax@33
  int v28; // [sp+10h] [bp-110h]@10
  int v29; // [sp+14h] [bp-10Ch]@1
  int v30; // [sp+18h] [bp-108h]@24
  int v31; // [sp+1Ch] [bp-104h]@28
  int v32; // [sp+20h] [bp-100h]@27
  int v33; // [sp+24h] [bp-FCh]@28
  int v34; // [sp+28h] [bp-F8h]@27
  int v35; // [sp+2Ch] [bp-F4h]@28
  int v36; // [sp+30h] [bp-F0h]@17
  char v37; // [sp+52h] [bp-CEh]@17
  char v38; // [sp+60h] [bp-C0h]@9
  char v39; // [sp+8Ch] [bp-94h]@20
  char v40; // [sp+90h] [bp-90h]@20
  char v41; // [sp+9Ch] [bp-84h]@9

  v2 = v1;
  v3 = *v1;
  v4 = v2[5];
  v5 = v2[6];
  *(_BYTE *)v5 = 10;
  v6 = v2[1];
  v7 = (__int16 *)(*v2 + *(_WORD *)(v6 + 21));
  v29 = v4;
  v8 = sub_100038F0(a1, *(_WORD *)(v3 + 24));
  v9 = *(_WORD *)(v6 + 7);
  v10 = v2[7] - 35;
  if ( v10 < v9 )
    v9 = v10;
  v11 = *v7;
  v12 = 0;
  v13 = -1073741811;
  if ( *v7 != 1 && v11 != 261 && v11 != 259 && v11 != 258 || !v8 || v9 <= 100 )
    goto LABEL_33;
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_BYTE *)(v5 + 20) = 0;
  *(_BYTE *)v5 = 10;
  *(_WORD *)(v5 + 15) = 55;
  *(_WORD *)(v5 + 7) = 0;
  *(_WORD *)(v5 + 9) = 0;
  *(_WORD *)(v5 + 13) = 0;
  *(_DWORD *)(v5 + 23) = 0;
  *(_DWORD *)(v5 + 27) = 0;
  *(_DWORD *)(v5 + 31) = 0;
  *(_DWORD *)(v5 + 35) = 0;
  *(_WORD *)(v5 + 39) = 0;
  sub_10001540(*(_DWORD *)(v8 + 4), (int)&unk_100409DD, &v41, 0x80u);
  v14 = sub_10022770((int)&v41, &v38);
  if ( v14 )
  {
    v28 = sub_10001200(v14);
    goto LABEL_31;
  }
  v15 = *v7;
  v28 = 0;
  if ( *v7 == 1 || v15 == 259 )
  {
    v21 = j_FIL_vfs_open(&v41, 260, 0);
    v22 = v21;
    if ( v21 < 0xFFFFFFC2 && v21 )
    {
      v18 = j_FIL_vfs_ioctl(v21, 104, &v30, 24);
      sub_10022300(v22);
    }
    else
    {
      v18 = v21;
    }
    if ( v18 >= 0 )
    {
      if ( *v7 == 1 )
      {
        *(_DWORD *)(v5 + 23) = 0;
        *(_DWORD *)(v5 + 27) = v34;
        *(_DWORD *)(v5 + 31) = v30;
        *(_DWORD *)(v5 + 35) = v32;
        *(_WORD *)(v5 + 13) = 18;
      }
      else
      {
        *(_DWORD *)(v5 + 23) = v30;
        *(_DWORD *)(v5 + 27) = v31;
        *(_DWORD *)(v5 + 31) = v32;
        *(_DWORD *)(v5 + 35) = v33;
        *(_DWORD *)(v5 + 39) = v34;
        *(_DWORD *)(v5 + 43) = v35;
        *(_WORD *)(v5 + 13) = 24;
      }
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if ( v15 != 258 )
  {
    *(_DWORD *)(v5 + 23) = v39 & 1 | 2;
    *(_DWORD *)(v5 + 27) = 40;
    *(_WORD *)(v29 + 10) |= 0x8000u;
    v20 = 2 * sub_10007770(v5 + 35, (int)&v40, 10);
    *(_DWORD *)(v5 + 31) = v20;
    *(_WORD *)(v5 + 13) = v20 + 12;
    goto LABEL_30;
  }
  v16 = j_FIL_vfs_open(&v41, 260, 0);
  v17 = v16;
  if ( v16 < 0xFFFFFFC2 && v16 )
  {
    v37 = 0;
    v18 = j_FIL_vfs_ioctl(v16, 102, &v36, 48);
    sub_10022300(v17);
  }
  else
  {
    v18 = v16;
  }
  if ( v18 < 0 )
  {
LABEL_29:
    v28 = sub_10001200(v18);
    goto LABEL_30;
  }
  *(_DWORD *)(v5 + 23) = -717324288;
  *(_DWORD *)(v5 + 27) = 27111902;
  *(_DWORD *)(v5 + 31) = v36;
  *(_WORD *)(v29 + 10) |= 0x8000u;
  v19 = 2 * sub_10007770(v5 + 41, (int)&v37, 12);
  *(_DWORD *)(v5 + 35) = v19;
  *(_WORD *)(v5 + 13) = v19 + 18;
LABEL_30:
  v23 = *(_WORD *)(v5 + 13);
  v24 = v5 + 2 * *(_BYTE *)v5 + 1;
  *(_BYTE *)v24 = v23;
  *(_BYTE *)(v24 + 1) = HIBYTE(v23);
  LOWORD(v24) = *(_WORD *)(v5 + 7);
  *(_WORD *)(v5 + 3) = *(_WORD *)(v5 + 13);
  v25 = 2 * *(_BYTE *)v5;
  *(_WORD *)(v5 + 1) = v24;
  HIBYTE(v26) = *(_BYTE *)(v25 + v5 + 2);
  LOBYTE(v26) = *(_BYTE *)(v25 + v5 + 1);
  v12 = v26 + v25 + 3;
LABEL_31:
  if ( v28 )
  {
    v13 = v28;
LABEL_33:
    *(_DWORD *)(v29 + 5) = v13;
    *(_WORD *)v5 = 0;
    result = 3;
    *(_BYTE *)(v5 + 2) = 0;
    return result;
  }
  return v12;
}
// 100223B0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10004890) --------------------------------------------------------
int __usercall sub_10004890@<eax>(int a1@<edx>, int a2, __int16 a3)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ebp@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // edx@1
  unsigned __int16 v10; // cx@2
  unsigned int v11; // ebx@23
  int v12; // ebp@29
  int *v13; // ebx@35
  int v14; // eax@35
  int *v15; // ecx@36
  int result; // eax@49
  int v17; // eax@52
  __int16 v18; // dx@52
  int v19; // eax@52
  unsigned __int16 v20; // cx@52
  int v21; // [sp+10h] [bp-9Ch]@1
  int v22; // [sp+10h] [bp-9Ch]@23
  int v23; // [sp+14h] [bp-98h]@1
  unsigned __int16 v24; // [sp+18h] [bp-94h]@2
  int v25; // [sp+1Ch] [bp-90h]@1
  int v26; // [sp+20h] [bp-8Ch]@35
  int v27; // [sp+24h] [bp-88h]@35
  char v28; // [sp+28h] [bp-84h]@23

  v3 = *(_DWORD *)a2;
  v25 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 24);
  *(_BYTE *)v4 = 10;
  v5 = *(_DWORD *)(a2 + 4);
  v21 = v3;
  v6 = *(_DWORD *)a2 + *(_WORD *)(v5 + 21);
  v7 = *(_DWORD *)a2 + *(_WORD *)(v5 + 25);
  v23 = a1;
  v8 = sub_100038F0(a1, *(_WORD *)(v3 + 24));
  v9 = -1073741811;
  if ( a3 == 6 )
  {
    v10 = *(_WORD *)v6;
    v24 = *(_WORD *)v6;
  }
  else
  {
    v10 = *(_WORD *)(v6 + 2);
    v24 = *(_WORD *)(v6 + 2);
  }
  if ( *(_BYTE *)v5 != 15 )
    goto LABEL_49;
  switch ( v10 )
  {
    case 0x101u:
      if ( *(_WORD *)(v5 + 23) < 4u )
        goto LABEL_49;
      break;
    case 0x102u:
      if ( *(_WORD *)(v5 + 23) < 1u )
        goto LABEL_49;
      break;
    case 0x103u:
      if ( *(_WORD *)(v5 + 23) < 4u
        || *(_DWORD *)(v7 + 4) >= 0 && (*(_DWORD *)(v7 + 4) > 0 || *(_DWORD *)v7 >= 0x7FFFFFFFu) )
      {
        goto LABEL_49;
      }
      break;
    default:
      if ( v10 != 260 || *(_WORD *)(v5 + 23) < 4u || *(_QWORD *)v7 >= 0x7FFFFFFFi64 )
        goto LABEL_49;
      break;
  }
  if ( !v8 || *(_WORD *)(v5 + 5) < 2u )
    goto LABEL_49;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_BYTE *)(v4 + 20) = 0;
  *(_BYTE *)v4 = 10;
  *(_WORD *)(v4 + 7) = 0;
  *(_WORD *)(v4 + 9) = 55;
  *(_WORD *)(v4 + 13) = 0;
  *(_WORD *)(v4 + 15) = 0;
  *(_WORD *)(v4 + 23) = 0;
  if ( a3 == 6 )
  {
    sub_10001540(*(_DWORD *)(v8 + 4), v6 + 6, &v28, 0x80u);
    v11 = j_FIL_vfs_open(&v28, 2, 0);
    v22 = v11;
  }
  else
  {
    v22 = sub_10001350(v23, *(_WORD *)v6, *(_WORD *)(v21 + 28));
    sub_100019A0(v23, *(_WORD *)v6, &v28, 0x80u);
    v11 = v22;
  }
  if ( v11 < 0xFFFFFFC2 && v11 )
  {
    if ( v24 == 258 )
    {
      if ( *(_BYTE *)v7 )
        v12 = j_FIL_vfs_delete(&v28);
      else
        v12 = v25;
      goto LABEL_45;
    }
    if ( v24 == 260 || v24 == 259 )
    {
      v12 = sub_100226E0(v11, *(_DWORD *)v7, (unsigned __int64)*(_DWORD *)v7 >> 32);
      goto LABEL_45;
    }
    if ( *(_DWORD *)(v7 + 32) & 0x27 )
    {
      v12 = sub_10022690((int)&v28, *(_DWORD *)(v7 + 32) & 0x27);
      if ( v12 )
        goto LABEL_45;
    }
    else
    {
      v12 = 0;
    }
    v13 = &v27;
    v26 = sub_100011D0(*(_QWORD *)(v7 + 8));
    v14 = sub_100011D0(*(_QWORD *)(v7 + 16));
    v27 = v14;
    if ( v26 )
      v15 = &v26;
    else
      v15 = 0;
    if ( !v14 )
      v13 = 0;
    if ( v15 || v13 )
      v12 = sub_10022810(v22, v15, v13);
    v11 = v22;
  }
  else
  {
    v12 = v11;
  }
LABEL_45:
  if ( a3 == 6 )
    sub_10022340(v11);
  if ( v12 )
  {
    v9 = sub_10001200(v12);
    if ( v9 )
    {
LABEL_49:
      *(_DWORD *)(v25 + 5) = v9;
      *(_WORD *)v4 = 0;
      result = 3;
      *(_BYTE *)(v4 + 2) = 0;
      return result;
    }
    result = 0;
  }
  else
  {
    *(_WORD *)(v4 + 23) = 0;
    v17 = v4 + 2 * *(_BYTE *)v4 + 1;
    *(_WORD *)(v4 + 7) = 2;
    *(_BYTE *)v17 = 2;
    *(_BYTE *)(v17 + 1) = 0;
    v18 = *(_WORD *)(v4 + 7);
    v19 = 2 * *(_BYTE *)v4;
    *(_WORD *)(v4 + 3) = *(_WORD *)(v4 + 13);
    *(_WORD *)(v4 + 1) = v18;
    HIBYTE(v20) = *(_BYTE *)(v19 + v4 + 2);
    LOBYTE(v20) = *(_BYTE *)(v19 + v4 + 1);
    result = v20 + v19 + 3;
  }
  return result;
}
// 10022360: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10004BC0) --------------------------------------------------------
bool __usercall sub_10004BC0@<al>(unsigned __int16 a1@<ax>, int a2@<ecx>)
{
  return a1 <= 3u && *(_BYTE *)(a1 + a2 + 32532);
}

//----- (10004BE0) --------------------------------------------------------
signed int __cdecl sub_10004BE0(int a1)
{
  int *v1; // esi@1

  v1 = &dword_100C4658[8135 * a1];
  if ( *(_BYTE *)v1 & 1 )
    sub_10003EC0((int)&dword_100C4658[8135 * a1]);
  return sub_10002130((int)v1);
}
// 100C4658: using guessed type int dword_100C4658[];

//----- (10004C10) --------------------------------------------------------
signed int __usercall sub_10004C10@<eax>(unsigned __int16 a1@<cx>, int a2@<esi>)
{
  int v2; // eax@1
  int v3; // edi@1
  unsigned int v4; // eax@2
  _DWORD *v5; // ecx@2
  signed int result; // eax@5

  v2 = sub_100038F0(a2, a1);
  v3 = v2;
  if ( v2 )
  {
    sub_10001B00(a2, v2, -2);
    v4 = 0;
    v5 = (_DWORD *)(a2 + 32512);
    while ( v3 != *v5 )
    {
      ++v4;
      ++v5;
      if ( v4 >= 5 )
        return 0;
    }
    *(_DWORD *)(a2 + 4 * v4 + 32512) = 0;
    result = 0;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (10004C60) --------------------------------------------------------
int __cdecl sub_10004C60(int a1, int a2)
{
  char *v2; // ecx@1
  char v3; // bl@1
  unsigned int v4; // edi@1
  int v5; // ebp@1
  int v6; // eax@1
  int v7; // eax@7
  int v8; // eax@10
  int v10; // [sp+10h] [bp-90h]@1
  int v11; // [sp+14h] [bp-8Ch]@1
  int v12; // [sp+18h] [bp-88h]@1
  char v13; // [sp+1Ch] [bp-84h]@8

  v10 = *(_DWORD *)(a2 + 20);
  v2 = *(char **)(a2 + 4);
  v3 = *v2;
  v11 = *(_DWORD *)(a2 + 24);
  v4 = (unsigned int)&v2[2 * (unsigned __int8)*v2 + 3];
  v5 = -1073741811;
  v6 = sub_100038F0(a1, *(_WORD *)(*(_DWORD *)a2 + 24));
  v12 = v6;
  if ( v3 == 1 )
  {
    if ( *(_WORD *)(a2 + 16) )
    {
      if ( v6 )
      {
        if ( *(_BYTE *)v4 == 4 && *(_BYTE *)(v4 + 1) == 92 )
        {
          if ( *(_BYTE *)(v4 + 2) )
          {
            v7 = sub_100078B0((void *)v4, *(_WORD *)(a2 + 16));
            if ( sub_10001000(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), v4, v7 + 1) )
            {
              if ( sub_10001540(*(_DWORD *)(v12 + 4), v4 + 1, &v13, 0x80u) > 0 && !sub_100077C0((_BYTE *)(v4 + 1)) )
              {
                v8 = j_FIL_vfs_delete(&v13);
                v5 = sub_10001200(v8);
              }
            }
          }
        }
      }
    }
  }
  *(_DWORD *)(v10 + 5) = v5;
  *(_WORD *)v11 = 0;
  *(_BYTE *)(v11 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return v5;
}
// 10022360: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10004D80) --------------------------------------------------------
signed int __cdecl sub_10004D80(int a1, int a2)
{
  _BYTE *v2; // eax@1
  int v3; // esi@1
  int v4; // ebp@1
  int v5; // edx@1
  int v6; // edx@3
  int v7; // eax@3
  unsigned __int16 v8; // cx@3
  signed int result; // eax@3

  v2 = *(_BYTE **)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)a2;
  v5 = 0;
  *(_BYTE *)v3 = 2;
  if ( *v2 == 2 && sub_10004BC0(*(_WORD *)(v4 + 28), a1) )
  {
    *(_DWORD *)v3 = 0;
    *(_BYTE *)(v3 + 4) = 0;
    *(_BYTE *)v3 = 2;
    sub_10001B00(a1, v5, *(_WORD *)(v4 + 28));
    *(_BYTE *)(*(_WORD *)(v4 + 28) + a1 + 32532) = 0;
    v6 = *(_BYTE *)v3;
    *(_BYTE *)(v3 + 2 * v6 + 1) = 0;
    *(_BYTE *)(v3 + 2 * v6 + 2) = 0;
    v7 = 2 * *(_BYTE *)v3;
    HIBYTE(v8) = *(_BYTE *)(v7 + v3 + 2);
    LOBYTE(v8) = *(_BYTE *)(v7 + v3 + 1);
    *(_DWORD *)(a2 + 40) = v8 + v7 + 3;
    result = 0;
  }
  else
  {
    *(_DWORD *)(a2 + 40) = v5;
    result = -1073741811;
  }
  return result;
}

//----- (10004E10) --------------------------------------------------------
int __cdecl sub_10004E10(_DWORD *a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  unsigned int v6; // edx@4
  int v7; // ecx@11
  signed int v8; // ebx@13
  unsigned int v9; // eax@35
  int v10; // ebx@43
  unsigned int v11; // eax@43
  int v12; // eax@53
  int v13; // ecx@53
  int v14; // eax@57
  int v15; // edx@67
  int v16; // edx@67
  int v17; // eax@67
  int v18; // edx@67
  int v19; // edx@67
  int v20; // eax@67
  bool v21; // al@67
  bool v22; // zf@67
  int v23; // eax@73
  int v24; // ecx@75
  unsigned __int16 v25; // dx@75
  int result; // eax@77
  int v27; // [sp+10h] [bp-E0h]@1
  int v28; // [sp+10h] [bp-E0h]@30
  signed int v29; // [sp+14h] [bp-DCh]@1
  char v30; // [sp+14h] [bp-DCh]@69
  const char *v31; // [sp+18h] [bp-D8h]@1
  int v32; // [sp+20h] [bp-D0h]@1
  int v33; // [sp+24h] [bp-CCh]@1
  int v34; // [sp+28h] [bp-C8h]@1
  char v35; // [sp+30h] [bp-C0h]@61
  int v36; // [sp+3Ch] [bp-B4h]@67
  int v37; // [sp+40h] [bp-B0h]@67
  int v38; // [sp+44h] [bp-ACh]@67
  int v39; // [sp+48h] [bp-A8h]@67
  int v40; // [sp+4Ch] [bp-A4h]@67
  int v41; // [sp+50h] [bp-A0h]@67
  int v42; // [sp+54h] [bp-9Ch]@67
  int v43; // [sp+58h] [bp-98h]@67
  char v44; // [sp+6Ch] [bp-84h]@10

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 24);
  v4 = 0;
  v32 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 4);
  v33 = 0;
  v27 = -1073741811;
  v31 = *(const char **)(a2 + 12);
  v29 = 0;
  v34 = sub_100038F0((int)a1, *(_WORD *)(*(_DWORD *)a2 + 24));
  if ( *(_BYTE *)v5 != 24
    || *(_DWORD *)(v5 + 12)
    || !*(_DWORD *)(v5 + 36)
    || !sub_10004BC0(*(_WORD *)(v32 + 28), (int)a1)
    || v6 > 5
    || (*(_BYTE *)(v5 + 40) & 0x41) == 65
    || !sub_10001000(v5, *(_DWORD *)(a2 + 8), (unsigned int)v31, *(_WORD *)(v5 + 6))
    || v31[*(_WORD *)(v5 + 6)]
    || !v34
    || sub_10001540(*(_DWORD *)(v34 + 4), (int)v31, &v44, 0x80u) <= 0 )
  {
    goto LABEL_77;
  }
  v7 = *(_DWORD *)(v5 + 16);
  if ( (*(_DWORD *)(v5 + 16) & 3) == 2 )
  {
    v8 = 2;
  }
  else if ( (*(_DWORD *)(v5 + 16) & 3) == 3 )
  {
    v8 = 6;
  }
  else
  {
    v8 = 4;
  }
  if ( v7 < 0 )
    v8 |= 4u;
  if ( v7 & 0x40000000 )
    v8 |= 2u;
  if ( v7 & 0x100000 )
    v8 |= 0x80u;
  if ( *(_DWORD *)(v5 + 36) == 2 )
  {
    v8 |= 0x18u;
  }
  else if ( *(_DWORD *)(v5 + 36) == 3 || *(_DWORD *)(v5 + 36) == 5 )
  {
    v8 |= 8u;
  }
  if ( !(*(_BYTE *)(v5 + 40) & 1)
    || (v8 |= 0x100u, !(v8 & 8))
    || ((v8 &= 0xFFFFFFE7, !(v8 & 2)) ? (v28 = j_FIL_vfs_mkdir(&v44, 0)) : (v28 = -34),
        *(_DWORD *)(v5 + 36) != 2 && v28 == -11 || !v28) )
  {
    v9 = j_FIL_vfs_open(&v44, v8 & 0xFFFFFFF7, 0);
    v4 = v9;
    v29 = 1;
    if ( (v9 >= 0xFFFFFFC2 || !v9) && v8 & 8 )
    {
      v4 = j_FIL_vfs_open(&v44, v8, 0);
      v29 = 2;
    }
    if ( (v4 >= 0xFFFFFFC2 || !v4) && v4 == -18 )
    {
      if ( *(_BYTE *)(v5 + 40) & 0x40 )
        goto LABEL_62;
      v10 = v8 | 0x100;
      v11 = j_FIL_vfs_open(&v44, v10, 0);
      v4 = v11;
      if ( (v11 >= 0xFFFFFFC2 || !v11) && v10 & 2 )
        v4 = -34;
      v29 = 1;
    }
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( (v29 == 2 || v29 == 1 && *(_BYTE *)(v5 + 40) & 0x40)
        && (v12 = *(_DWORD *)(v5 + 24), v13 = *(_DWORD *)(v5 + 20), v12 >= 0)
        && (v12 > 0 || v13) )
      {
        sub_10022870(v4, v13, *(_DWORD *)(v5 + 24));
      }
      else
      {
        v14 = *(_DWORD *)(v5 + 36);
        if ( v14 == 4 || v14 == 5 )
        {
          sub_10022870(v4, *(_DWORD *)(v5 + 20), *(_DWORD *)(v5 + 24));
          v29 = 3;
        }
      }
      if ( v4 )
      {
        v28 = sub_10022380(v4, &v35);
        goto LABEL_63;
      }
    }
LABEL_62:
    v28 = v4;
  }
LABEL_63:
  if ( v28 >= 0 )
  {
    memset((void *)v3, 0, 0x45u);
    *(_BYTE *)v3 = 34;
    *(_BYTE *)(v3 + 69) = 0;
    *(_BYTE *)(v3 + 70) = 0;
    *(_DWORD *)(v3 + 8) = v29;
    *(_BYTE *)(v3 + 5) = 0;
    if ( *(_BYTE *)(v5 + 8) & 4 )
      *(_BYTE *)(v3 + 5) = 1;
    *(_DWORD *)(v3 + 12) = sub_100011F0(v40);
    *(_DWORD *)(v3 + 16) = v15;
    *(_DWORD *)(v3 + 20) = sub_100011F0(v38);
    *(_DWORD *)(v3 + 24) = v16;
    v17 = sub_100011F0(v39);
    *(_DWORD *)(v3 + 32) = v18;
    *(_DWORD *)(v3 + 28) = v17;
    v19 = v17;
    v20 = *(_DWORD *)(v3 + 32);
    *(_DWORD *)(v3 + 36) = v19;
    *(_DWORD *)(v3 + 40) = v20;
    *(_DWORD *)(v3 + 44) = v43;
    *(_DWORD *)(v3 + 48) = v41 * v42;
    *(_DWORD *)(v3 + 52) = 0;
    *(_DWORD *)(v3 + 56) = v36;
    *(_DWORD *)(v3 + 60) = v37;
    v21 = (v43 & 0x10) == 16;
    v22 = *(_DWORD *)(v3 + 44) == 0;
    *(_BYTE *)(v3 + 68) = v21;
    if ( v22 )
      *(_DWORD *)(v3 + 44) = 128;
    v30 = 0;
    if ( v21 )
      v30 = 2;
    if ( *(_DWORD *)(v5 + 40) & 0x1000 )
      v30 |= 8u;
    v23 = sub_10001500(a1, v34, *(_WORD *)(v32 + 26), *(_WORD *)(v32 + 28), v4, v30, v31, 0);
    if ( v23 >= 0 )
    {
      v24 = 2 * *(_BYTE *)v3;
      HIBYTE(v25) = *(_BYTE *)(v24 + v3 + 2);
      v27 = 0;
      LOBYTE(v25) = *(_BYTE *)(v24 + v3 + 1);
      *(_WORD *)(v3 + 6) = v23;
      v33 = v25 + v24 + 3;
    }
    else
    {
      *(_WORD *)(v3 + 6) = -1;
      v27 = sub_10001200(v23);
    }
  }
  else
  {
    sub_10022340(v4);
    v27 = sub_10001200(v28);
  }
  v2 = a2;
LABEL_77:
  result = v27;
  *(_DWORD *)(v2 + 40) = v33;
  return result;
}
// 100011F0: using guessed type _DWORD __cdecl sub_100011F0(_DWORD);
// 10022410: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005250) --------------------------------------------------------
int __cdecl sub_10005250(int a1, int a2)
{
  const char *v2; // edi@1
  const char *v3; // ebx@1
  int v4; // eax@1
  _BYTE *v5; // ebp@1
  int v6; // eax@9
  int v8; // [sp+10h] [bp-114h]@1
  int v9; // [sp+14h] [bp-110h]@1
  int v10; // [sp+18h] [bp-10Ch]@1
  int v11; // [sp+1Ch] [bp-108h]@1
  char v12; // [sp+20h] [bp-104h]@8
  char v13; // [sp+A0h] [bp-84h]@7

  v2 = *(const char **)(a2 + 12);
  v9 = *(_DWORD *)(a2 + 20);
  v10 = *(_DWORD *)(a2 + 24);
  v8 = -1073741811;
  v3 = &v2[strlen(v2) + 1];
  v4 = sub_100038F0(a1, *(_WORD *)(*(_DWORD *)a2 + 24));
  v5 = *(_BYTE **)(a2 + 4);
  v11 = v4;
  if ( *v5 == 1
    && *(_WORD *)(a2 + 16)
    && v4
    && *v2 == 4
    && *v3 == 4
    && sub_10001000((unsigned int)v5, *(_DWORD *)(a2 + 8), (unsigned int)v3, strlen(v3) + 1)
    && sub_10001540(*(_DWORD *)(v11 + 4), (int)(v2 + 1), &v13, 0x80u) > 0
    && sub_10001540(*(_DWORD *)(v11 + 4), (int)(v3 + 1), &v12, 0x80u) > 0 )
  {
    v6 = j_FIL_vfs_rename(&v13, &v12);
    v8 = sub_10001200(v6);
  }
  *(_DWORD *)(v9 + 5) = v8;
  *(_WORD *)v10 = 0;
  *(_BYTE *)(v10 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return v8;
}
// 10022510: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100053B0) --------------------------------------------------------
int __cdecl sub_100053B0(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@1
  int v4; // ebx@1
  int v5; // eax@1
  int v6; // eax@8
  int v8; // [sp+10h] [bp-90h]@1
  int v9; // [sp+14h] [bp-8Ch]@1
  char v10; // [sp+1Ch] [bp-84h]@7

  v2 = *(_DWORD *)(a2 + 24);
  v9 = *(_DWORD *)(a2 + 20);
  v3 = *(_DWORD *)(a2 + 12);
  v4 = -1073741811;
  v5 = sub_100038F0(a1, *(_WORD *)(*(_DWORD *)a2 + 24));
  v8 = v5;
  if ( *(_WORD *)(a2 + 16)
    && v5
    && *(_BYTE *)v3 == 4
    && *(_BYTE *)(v3 + 1) == 92
    && *(_BYTE *)(v3 + 2)
    && sub_10001000(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), v3, strlen((const char *)v3) + 1)
    && sub_10001540(*(_DWORD *)(v8 + 4), v3 + 1, &v10, 0x80u) > 0 )
  {
    v6 = j_FIL_vfs_rmdir(&v10);
    v4 = sub_10001200(v6);
  }
  *(_DWORD *)(v9 + 5) = v4;
  *(_WORD *)v2 = 0;
  *(_BYTE *)(v2 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return v4;
}
// 10022520: using guessed type int __cdecl j_FIL_vfs_rmdir(_DWORD);

//----- (100054B0) --------------------------------------------------------
signed int __cdecl sub_100054B0(int a1, unsigned int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  char *v6; // eax@1
  char v7; // dl@2
  bool v8; // zf@3
  _DWORD *v10; // esi@15
  unsigned int v11; // eax@15
  const char *v12; // edx@15
  int v13; // ebp@19
  int v14; // eax@20
  _BYTE *v15; // edx@20
  _BYTE *v16; // esi@20
  int v17; // eax@22
  _BYTE *v18; // edx@22
  _BYTE *v19; // esi@22
  _BYTE *v20; // edx@24
  _BYTE *v21; // esi@24
  int v22; // edx@25
  signed int v23; // eax@26
  int v24; // eax@30
  signed int v25; // ecx@33
  int v26; // eax@38
  unsigned __int16 v27; // cx@38
  signed int v28; // [sp+10h] [bp-14h]@1
  char *v29; // [sp+14h] [bp-10h]@5
  int v30; // [sp+18h] [bp-Ch]@3
  int v31; // [sp+1Ch] [bp-8h]@1
  int v32; // [sp+20h] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(a2 + 12) + *(_WORD *)(v3 + 7);
  v5 = *(_DWORD *)(a2 + 24);
  v32 = *(_DWORD *)(a2 + 20);
  v6 = (char *)(*(_DWORD *)(a2 + 12) + *(_WORD *)(v3 + 7));
  v31 = 0;
  v28 = -1073741811;
  do
    v7 = *v6++;
  while ( v7 );
  v8 = *(_DWORD *)(a2 + 44) == -1;
  v30 = (int)(&v6[v4] - v4);
  a2 = *(_WORD *)(*(_DWORD *)a2 + 28);
  if ( !v8 )
    a2 = *(_WORD *)(v2 + 44);
  v29 = 0;
  if ( sub_10001000(v3, *(_DWORD *)(v2 + 8), v4, strlen((const char *)v4) + 1) )
    v29 = sub_100016F0(v4, 0);
  if ( !sub_10004BC0(a2, a1) )
  {
    *(_DWORD *)(v2 + 40) = 0;
    return 5963778;
  }
  if ( *(_BYTE *)v3 == 4
    && !(*(_BYTE *)(v3 + 5) & 1)
    && *(_WORD *)(v3 + 7) <= 1u
    && *(_BYTE *)v4 == 92
    && *(_BYTE *)(v4 + 1) == 92
    && v29 )
  {
    v10 = (_DWORD *)v30;
    v11 = 6;
    v12 = "?????";
    do
    {
      if ( *v10 != *(_DWORD *)v12 )
        goto LABEL_19;
      v11 -= 4;
      v12 += 4;
      ++v10;
    }
    while ( v11 >= 4 );
    if ( v11 )
    {
LABEL_19:
      v13 = *(_BYTE *)v10 - *v12;
      if ( *(_BYTE *)v10 != *v12
        || (v14 = v11 - 1, v15 = v12 + 1, v16 = (char *)v10 + 1, v14)
        && ((v13 = *v16 - *v15, *v16 != *v15)
         || (v17 = v14 - 1, v18 = v15 + 1, v19 = v16 + 1, v17)
         && ((v13 = *v19 - *v18, *v19 != *v18)
          || (v20 = v18 + 1, v21 = v19 + 1, v17 != 1) && (v22 = *v20, v13 = *v21 - v22, *v21 != v22))) )
      {
        v23 = 1;
        if ( v13 <= 0 )
          v23 = -1;
LABEL_29:
        if ( !v23 )
          goto LABEL_42;
        v24 = *(_BYTE *)v30 - 65;
        if ( *(_BYTE *)v30 != 65
          || (v24 = *(_BYTE *)(v30 + 1) - 58, *(_BYTE *)(v30 + 1) != 58)
          || (v24 = *(_BYTE *)(v30 + 2)) != 0 )
        {
          v25 = 1;
          if ( v24 <= 0 )
            v25 = -1;
        }
        else
        {
          v25 = 0;
        }
        if ( !v25 )
        {
LABEL_42:
          v28 = sub_10003770(a1, v29, a2, &a2);
          if ( !v28 )
          {
            *(_WORD *)(v32 + 24) = a2;
            *(_BYTE *)v5 = 3;
            *(_WORD *)(v5 + 5) = 0;
            *(_BYTE *)(v5 + 7) = 0;
            *(_BYTE *)(v5 + 8) = 0;
            sub_10001620(v5 + 2 * *(_BYTE *)v5 + 1, *(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 24), "A:", 3u);
            sub_10001620(v5 + 2 * *(_BYTE *)v5 + 1, *(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 24), "garmin_fs", 0xAu);
            v26 = 2 * *(_BYTE *)v5;
            HIBYTE(v27) = *(_BYTE *)(v26 + v5 + 2);
            v28 = 0;
            LOBYTE(v27) = *(_BYTE *)(v26 + v5 + 1);
            v31 = v27 + v26 + 3;
          }
        }
        goto LABEL_39;
      }
    }
    v23 = 0;
    goto LABEL_29;
  }
LABEL_39:
  *(_DWORD *)(v2 + 40) = v31;
  return v28;
}

//----- (10005730) --------------------------------------------------------
signed int __cdecl sub_10005730(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // ebx@1
  signed int result; // eax@1

  v2 = *(_DWORD *)(a2 + 20);
  v3 = *(_DWORD *)(a2 + 24);
  result = -1073741811;
  if ( !**(_BYTE **)(a2 + 4) && !*(_WORD *)(a2 + 16) )
    result = sub_10004C10(*(_WORD *)(*(_DWORD *)a2 + 24), a1);
  *(_DWORD *)(v2 + 5) = result;
  *(_WORD *)v3 = 0;
  *(_BYTE *)(v3 + 2) = 0;
  *(_DWORD *)(a2 + 40) = 3;
  return result;
}

//----- (10005780) --------------------------------------------------------
signed int __cdecl sub_10005780(int a1, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // ebx@1
  int v4; // esi@1
  unsigned int v5; // edi@1
  bool v6; // zf@1
  unsigned __int16 v7; // ax@2
  int v8; // eax@7
  unsigned __int16 v9; // dx@7
  signed int result; // eax@8
  int v11; // [sp+10h] [bp-8h]@1
  signed int v12; // [sp+14h] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_BYTE *)v5 == 5;
  v11 = 0;
  a2 = *(_DWORD *)a2;
  v12 = -1073741811;
  if ( v6 )
  {
    v7 = *(_WORD *)(v5 + 3);
    if ( *(_WORD *)(v2 + 16) >= v7 && *(_BYTE *)v3 == 1 && *(_WORD *)(v3 + 1) == v7 )
    {
      if ( sub_10001000(v5, *(_DWORD *)(v2 + 8), v3, v7 + 3) )
      {
        *(_DWORD *)v4 = 0;
        *(_BYTE *)(v4 + 4) = 0;
        v12 = sub_10003D10(*(_WORD *)(v5 + 1), v3 + 3, a1, a2, *(_WORD *)(v3 + 1), *(_DWORD *)(v5 + 5), &a2);
        *(_WORD *)(v4 + 1) = a2;
        if ( !v12 )
        {
          *(_BYTE *)v4 = 1;
          *(_BYTE *)(v4 + 3) = 0;
          *(_BYTE *)(v4 + 4) = 0;
          v8 = 2 * *(_BYTE *)v4;
          HIBYTE(v9) = *(_BYTE *)(v8 + v4 + 2);
          LOBYTE(v9) = *(_BYTE *)(v8 + v4 + 1);
          v11 = v9 + v8 + 3;
        }
      }
    }
  }
  result = v12;
  *(_DWORD *)(v2 + 40) = v11;
  return result;
}

//----- (10005860) --------------------------------------------------------
signed int __cdecl sub_10005860(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // edx@1
  unsigned int v4; // esi@1
  int v5; // ecx@1
  int v6; // ebp@1
  unsigned int v7; // eax@1
  int v8; // edi@1
  unsigned int v9; // ecx@6
  unsigned int v10; // edx@6
  int v11; // eax@9
  int v12; // eax@11
  unsigned __int16 v13; // cx@11
  int v15; // [sp+10h] [bp-Ch]@1
  signed int v16; // [sp+14h] [bp-8h]@1

  v2 = a2;
  v3 = *(_WORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_WORD *)(v4 + 21);
  v6 = *(_DWORD *)a2 + *(_WORD *)(v4 + 23);
  a2 = *(_DWORD *)a2;
  v7 = v5 | (*(_WORD *)(v4 + 19) << 16);
  v8 = *(_DWORD *)(v2 + 24);
  v15 = 0;
  v16 = -1073741811;
  if ( (*(_BYTE *)v4 == 14 || *(_BYTE *)v4 == 12) && v3 >= v7 && sub_10001000(v4, *(_DWORD *)(v2 + 8), v6, v7) )
  {
    if ( *(_BYTE *)v4 == 12 )
    {
      v9 = *(_DWORD *)(v4 + 7);
      v10 = 0;
    }
    else
    {
      v9 = *(_DWORD *)(v4 + 7);
      v10 = *(_DWORD *)(v4 + 25);
    }
    *(_DWORD *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_WORD *)(v8 + 12) = 0;
    *(_BYTE *)(v8 + 14) = 0;
    v16 = sub_10003D10(*(_WORD *)(v4 + 5), v6, a1, a2, *(_WORD *)(v4 + 21), __PAIR__(v10, v9), &a2);
    *(_WORD *)(v8 + 5) = a2;
    if ( !v16 )
    {
      v11 = v8 + 2 * *(_BYTE *)v8 + 1;
      *(_BYTE *)v11 = 0;
      *(_BYTE *)(v11 + 1) = 0;
      if ( *(_WORD *)(v8 + 5) != *(_WORD *)(v4 + 21) )
        sub_100072A0("..\\lib\\acl\\iop\\iop_net_cifs_svr.c", 3059, 0, 0);
      *(_BYTE *)v8 = 6;
      *(_BYTE *)(v8 + 13) = 0;
      *(_BYTE *)(v8 + 14) = 0;
      v12 = 2 * *(_BYTE *)v8;
      HIBYTE(v13) = *(_BYTE *)(v12 + v8 + 2);
      LOBYTE(v13) = *(_BYTE *)(v12 + v8 + 1);
      v15 = v13 + v12 + 3;
    }
  }
  *(_DWORD *)(v2 + 40) = v15;
  return v16;
}

//----- (100059A0) --------------------------------------------------------
int __cdecl sub_100059A0(_DWORD *a1)
{
  int *v1; // ecx@0
  int *v2; // edi@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ebx@1
  int v8; // edx@1
  unsigned int v9; // eax@1
  unsigned int v10; // edi@1
  const char *v11; // ebp@1
  __int16 v12; // ax@3
  int v13; // edi@3
  int v14; // edx@6
  int v15; // eax@9
  signed int v16; // edi@16
  signed int i; // eax@16
  char v18; // dl@17
  char v19; // cl@20
  char v20; // cl@24
  unsigned int v21; // eax@28
  unsigned __int16 v22; // ST14_2@28
  __int16 v23; // ST0C_2@28
  char v24; // ST08_1@28
  bool v25; // zf@28
  int v26; // eax@30
  int v27; // ecx@35
  __int16 v28; // ax@35
  __int16 v29; // dx@35
  int v30; // eax@35
  int result; // eax@35
  char v32; // [sp+13h] [bp-A5h]@1
  int v33; // [sp+14h] [bp-A4h]@1
  _DWORD *v34; // [sp+18h] [bp-A0h]@1
  int v35; // [sp+1Ch] [bp-9Ch]@1
  int v36; // [sp+20h] [bp-98h]@1
  unsigned int v37; // [sp+24h] [bp-94h]@28
  int v38; // [sp+28h] [bp-90h]@1
  int v39; // [sp+2Ch] [bp-8Ch]@1
  int v40; // [sp+30h] [bp-88h]@1
  char v41; // [sp+34h] [bp-84h]@9
  char v42; // [sp+35h] [bp-83h]@14
  char v43; // [sp+36h] [bp-82h]@14

  v2 = v1;
  v3 = *v1;
  v4 = v2[5];
  v5 = v2[6];
  *(_BYTE *)v5 = 10;
  v39 = v4;
  v6 = v2[1];
  v7 = *v2 + *(_WORD *)(v6 + 21);
  v36 = v3;
  LOWORD(v3) = *(_WORD *)(v3 + 24);
  v34 = a1;
  v32 = 1;
  v33 = v6;
  v38 = v7;
  v8 = sub_100038F0((int)a1, v3);
  v9 = *(_WORD *)(v33 + 7);
  v10 = v2[7] - 33;
  v40 = v8;
  v11 = (const char *)(v7 + 12);
  v35 = v10;
  if ( v10 >= v9 )
    v35 = v9;
  v12 = *(_WORD *)(v7 + 6);
  v13 = -1073741811;
  if ( (v12 == 260 || v12 == 257)
    && v8
    && sub_10004BC0(*(_WORD *)(v36 + 28), (int)v34)
    && *(_WORD *)(v33 + 5) == 10
    && *(_WORD *)(v7 + 2) > 1u )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_BYTE *)(v5 + 20) = 0;
    *(_BYTE *)v5 = 10;
    *(_WORD *)(v5 + 7) = 10;
    *(_WORD *)(v5 + 9) = 55;
    *(_WORD *)(v5 + 15) = 65;
    *(_WORD *)(v5 + 13) = 0;
    *(_DWORD *)(v5 + 23) = 0;
    *(_DWORD *)(v5 + 27) = 0;
    *(_WORD *)(v5 + 31) = 0;
    *(_WORD *)(v5 + 27) = 1;
    *(_WORD *)(v5 + 23) = -1;
    v15 = sub_10001540(*(_DWORD *)(v14 + 4), v7 + 12, &v41, 0x7Fu) - 1;
    if ( v15 >= 0 )
    {
      while ( *(&v41 + v15) != 47 )
      {
        if ( --v15 < 0 )
          goto LABEL_16;
      }
      if ( v15 )
      {
        *(&v41 + v15) = 0;
        v11 = &v42 + v15;
      }
      else
      {
        memcpy(&v42, &v41, strlen(&v41));
        v42 = 0;
        v11 = &v43;
      }
    }
LABEL_16:
    v16 = strlen(v11);
    for ( i = 0; i < v16; ++i )
    {
      v18 = v11[i];
      if ( v18 == 62 )
      {
        v11[i] = 63;
      }
      else if ( v18 != 60 || (v19 = v11[i + 1], v19 != 46) && v19 != 34 )
      {
        if ( v18 == 34 )
        {
          v20 = v11[i + 1];
          if ( v20 == 63 || v20 == 42 )
            v11[i] = 46;
        }
      }
      else
      {
        v11[i] = 42;
      }
    }
    v21 = j_FIL_vfs_open(&v41, 260, 0);
    v33 = *(_WORD *)(v5 + 13);
    v22 = *(_WORD *)(v38 + 2);
    v23 = *(_WORD *)(v38 + 6);
    v24 = *(_WORD *)(v38 + 4);
    v37 = v21;
    v13 = sub_10003940(v11, &v33, v5 + 25, v21, (int)&v41, v24, v23, v35, v22, &v32);
    v25 = v32 == 0;
    *(_WORD *)(v5 + 13) = v33;
    if ( !v25 || v13 )
    {
      sub_10022340(v37);
    }
    else
    {
      v26 = sub_10001500(
              v34,
              v40,
              *(_WORD *)(v36 + 26),
              *(_WORD *)(v36 + 28),
              v37,
              6,
              &v41 + strlen(*(const char **)(v40 + 4)),
              v11);
      if ( v26 >= 0 )
      {
        *(_WORD *)(v5 + 23) = v26;
LABEL_35:
        v27 = *(_BYTE *)v5;
        v28 = *(_WORD *)(v5 + 7) + *(_WORD *)(v5 + 13);
        *(_BYTE *)(v5 + 2 * v27 + 1) = v28;
        *(_BYTE *)(v5 + 2 * v27 + 2) = HIBYTE(v28);
        v29 = *(_WORD *)(v5 + 13);
        *(_WORD *)(v5 + 1) = *(_WORD *)(v5 + 7);
        v30 = 2 * *(_BYTE *)v5;
        *(_WORD *)(v5 + 3) = v29;
        BYTE1(v27) = *(_BYTE *)(v30 + v5 + 2);
        LOBYTE(v27) = *(_BYTE *)(v30 + v5 + 1);
        return (unsigned __int16)v27 + v30 + 3;
      }
      *(_WORD *)(v5 + 23) = -1;
      v13 = sub_10001200(v26);
    }
    if ( !v13 )
      goto LABEL_35;
  }
  *(_DWORD *)(v39 + 5) = v13;
  *(_WORD *)v5 = 0;
  result = 3;
  *(_BYTE *)(v5 + 2) = 0;
  return result;
}
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005CC0) --------------------------------------------------------
void __noreturn sub_10005CC0()
{
  unsigned int v0; // edi@1
  int v1; // esi@2
  int v2; // eax@5
  char v3; // [sp+Ch] [bp-E8h]@5
  char v4; // [sp+10h] [bp-E4h]@1

  sub_10007C90(&v4);
  v0 = sub_100228F0();
  memset(dword_100C4658, 0, 0x2FAA8u);
  dword_100C4658[0] |= 1u;
  dword_100CC574 |= 1u;
  dword_100D4490 |= 1u;
  dword_100DC3AC |= 1u;
  dword_100E42C8 |= 1u;
  dword_100EC1E4 |= 1u;
  sub_10022220(&unk_100C4598, 1000);
  while ( 1 )
  {
    sub_10022130((int)&unk_100C4598);
    v1 = 0;
    do
      sub_10004BE0(v1++);
    while ( v1 < 6 );
    if ( sub_100228F0() > v0 )
    {
      v0 = sub_100228F0() + 1000;
      v2 = sub_100228B0();
      sub_10022910((int)&v3, 5, v2, 4);
    }
    sub_10007B70((int *)&v4);
  }
}
// 100C4658: using guessed type int dword_100C4658[];
// 100CC574: using guessed type int dword_100CC574;
// 100D4490: using guessed type int dword_100D4490;
// 100DC3AC: using guessed type int dword_100DC3AC;
// 100E42C8: using guessed type int dword_100E42C8;
// 100EC1E4: using guessed type int dword_100EC1E4;

//----- (10005D90) --------------------------------------------------------
signed int __cdecl sub_10005D90(int a1, int a2)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  int v4; // ecx@1
  unsigned __int8 v5; // al@1
  unsigned __int16 v6; // ax@3
  __int16 v7; // dx@4
  int v8; // ebx@14
  signed int result; // eax@14
  int v10; // ebx@15
  signed int v11; // ebx@16
  int v12; // ebx@17
  int v13; // ebx@18
  signed int v14; // [sp+10h] [bp-8h]@1
  __int16 v15; // [sp+14h] [bp-4h]@1
  int v16; // [sp+20h] [bp+8h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_WORD *)(a2 + 16);
  v16 = *(_DWORD *)a2;
  v5 = *(_BYTE *)(v3 + 27);
  v15 = *(_WORD *)(v3 + 29);
  v14 = -1073741811;
  if ( *(_BYTE *)v3 == v5 + 14
    && v5 == 1
    && (v6 = *(_WORD *)(v3 + 19), *(_WORD *)(v3 + 1) == v6)
    && (v7 = *(_WORD *)(v3 + 23), *(_WORD *)(v3 + 3) == v7)
    && !*(_WORD *)(v3 + 11)
    && *(_WORD *)(v3 + 21) >= 0x3Du
    && (*(_WORD *)(v3 + 25) >= (unsigned int)v6 + 61 || !v7)
    && sub_10001000(v3, *(_DWORD *)(v2 + 8), *(_DWORD *)(v2 + 12), v4)
    && *(_WORD *)(v16 + 24) - 61440 < *(_BYTE *)(a1 + 28748)
    && sub_10001000(*(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), v16 + *(_WORD *)(v3 + 25), *(_WORD *)(v3 + 23))
    && sub_10001000(*(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), v16 + *(_WORD *)(v3 + 21), *(_WORD *)(v3 + 19)) )
  {
    switch ( v15 )
    {
      case 1:
        v8 = sub_100059A0((_DWORD *)a1);
        result = 0;
        *(_DWORD *)(v2 + 40) = v8;
        break;
      case 2:
        v10 = sub_10003FA0(a1, v2);
        result = 0;
        *(_DWORD *)(v2 + 40) = v10;
        break;
      case 3:
        v11 = sub_10004560(a1);
        result = 0;
        *(_DWORD *)(v2 + 40) = v11;
        break;
      case 5:
      case 7:
        v12 = sub_10004180(a1, v15);
        result = 0;
        *(_DWORD *)(v2 + 40) = v12;
        break;
      case 6:
      case 8:
        v13 = sub_10004890(a1, v2, v15);
        result = 0;
        *(_DWORD *)(v2 + 40) = v13;
        break;
      default:
        v14 = -1073741822;
        goto LABEL_20;
    }
  }
  else
  {
LABEL_20:
    result = v14;
    *(_DWORD *)(v2 + 40) = 0;
  }
  return result;
}

//----- (10005F90) --------------------------------------------------------
#error "10005F9A: call analysis failed (funcsize=7)"

//----- (10005FB0) --------------------------------------------------------
int __usercall sub_10005FB0@<eax>(int result@<eax>, int a2@<esi>)
{
  *(_BYTE *)result = *(_BYTE *)a2 >> 1;
  *(_BYTE *)(result + 1) = (*(_BYTE *)(a2 + 1) >> 2) | ((*(_BYTE *)a2 & 1) << 6);
  *(_BYTE *)(result + 2) = (*(_BYTE *)(a2 + 2) >> 3) | 32 * (*(_BYTE *)(a2 + 1) & 3);
  *(_BYTE *)(result + 3) = (*(_BYTE *)(a2 + 3) >> 4) | 16 * (*(_BYTE *)(a2 + 2) & 7);
  *(_BYTE *)(result + 4) = (*(_BYTE *)(a2 + 4) >> 5) | 8 * (*(_BYTE *)(a2 + 3) & 0xF);
  *(_BYTE *)(result + 5) = (*(_BYTE *)(a2 + 5) >> 6) | 4 * (*(_BYTE *)(a2 + 4) & 0x1F);
  *(_BYTE *)(result + 6) = (*(_BYTE *)(a2 + 6) >> 7) | 2 * (*(_BYTE *)(a2 + 5) & 0x3F);
  *(_BYTE *)(result + 7) = *(_BYTE *)(a2 + 6) & 0x7F;
  *(_BYTE *)result *= 2;
  *(_BYTE *)(result + 1) *= 2;
  *(_BYTE *)(result + 2) *= 2;
  *(_BYTE *)(result + 3) *= 2;
  *(_BYTE *)(result + 4) *= 2;
  *(_BYTE *)(result + 5) *= 2;
  *(_BYTE *)(result + 6) *= 2;
  *(_BYTE *)(result + 7) *= 2;
  return result;
}

//----- (10006060) --------------------------------------------------------
int __usercall sub_10006060@<eax>(int a1@<eax>, int a2@<edi>, int a3)
{
  unsigned int v3; // ecx@1
  char v4; // bl@1
  int v5; // edx@1
  int v6; // eax@1
  int v7; // esi@1
  char v8; // bl@1
  int v9; // esi@1
  char v10; // bl@1
  int v11; // esi@1
  unsigned __int8 v12; // bl@1
  int v13; // ebp@1

  v3 = __ROR4__(a3, 1);
  v4 = *(_BYTE *)(a1 + 1);
  v5 = (*(_BYTE *)a1 ^ (v3 >> 26)) & 0x3F;
  v6 = a1 + 1;
  v7 = *(_DWORD *)(a2 + 4 * v5);
  LOBYTE(v5) = v4 ^ (v3 >> 22);
  v8 = *(_BYTE *)(v6 + 1);
  v9 = *(_DWORD *)(a2 + 4 * (v5 & 0x3F) + 256) | v7;
  ++v6;
  LOBYTE(v5) = v8 ^ (v3 >> 18);
  v10 = *(_BYTE *)(v6 + 1);
  v11 = *(_DWORD *)(a2 + 4 * (v5 & 0x3F) + 512) | v9;
  ++v6;
  LOBYTE(v5) = v10 ^ (v3 >> 14);
  v12 = *(_BYTE *)(v6++ + 1);
  v13 = __ROL4__(a3, 1);
  return *(_DWORD *)(a2 + 4 * ((*(_BYTE *)(v6 + 1) ^ (unsigned __int8)(v3 >> 6)) & 0x3F) + 1280) | *(_DWORD *)(a2 + 4 * ((v12 ^ (unsigned __int8)(v3 >> 10)) & 0x3F) + 1024) | *(_DWORD *)(a2 + 4 * (v5 & 0x3F) + 768) | v11 | *(_DWORD *)(a2 + 4 * ((*(_BYTE *)(v6 + 2) ^ (unsigned __int8)(v3 >> 2)) & 0x3F) + 1536) | *(_DWORD *)(a2 + 4 * ((*(_BYTE *)(v6 + 3) ^ (unsigned __int8)v13) & 0x3F) + 1792);
}

//----- (10006120) --------------------------------------------------------
int __cdecl sub_10006120(void *a1, int a2)
{
  int v2; // ebx@1
  signed int v3; // edi@1
  signed int v4; // edx@2
  int result; // eax@3
  char *v6; // esi@9
  _BYTE *v7; // [sp+10h] [bp-8h]@3
  int v8; // [sp+14h] [bp-4h]@1

  memset(a1, 0, 0x800u);
  v2 = 0;
  v8 = 0;
  v3 = 0;
  do
  {
    v4 = 0;
    do
    {
      v7 = (_BYTE *)(a2 + 3);
      result = 1;
      do
      {
        if ( (*(_BYTE *)(result + a2 - 1) - 1) >> 2 == v2 && v4 & dword_10041460[(*(_BYTE *)(result + a2 - 1) - 1) & 3] )
        {
          *((_BYTE *)a1 + 8 * (v3 + v4) + ((result - 1) >> 3)) |= LOBYTE(dword_10041440[(result - 1) & 7]);
          v2 = v8;
        }
        if ( (*(_BYTE *)(result + a2) - 1) >> 2 == v2 && v4 & dword_10041460[(*(_BYTE *)(result + a2) - 1) & 3] )
        {
          v6 = (char *)a1 + 8 * (v3 + v4) + (result >> 3);
          *v6 |= LOBYTE(dword_10041440[result & 7]);
        }
        if ( (*(v7 - 1) - 1) >> 2 == v2 && v4 & dword_10041460[(*(v7 - 1) - 1) & 3] )
        {
          *((_BYTE *)a1 + 8 * (v3 + v4) + ((result + 1) >> 3)) |= LOBYTE(dword_10041440[(result + 1) & 7]);
          v2 = v8;
        }
        if ( (*v7 - 1) >> 2 == v2 )
        {
          if ( v4 & dword_10041460[(*v7 - 1) & 3] )
          {
            *((_BYTE *)a1 + 8 * (v3 + v4) + ((result + 2) >> 3)) |= LOBYTE(dword_10041440[(result + 2) & 7]);
            v2 = v8;
          }
        }
        v7 += 4;
        result += 4;
      }
      while ( result - 1 < 64 );
      ++v4;
    }
    while ( v4 < 16 );
    ++v2;
    v3 += 16;
    v8 = v2;
  }
  while ( v3 < 256 );
  return result;
}
// 10041440: using guessed type int dword_10041440[];
// 10041460: using guessed type int dword_10041460[];

//----- (100062A0) --------------------------------------------------------
_BYTE *__usercall sub_100062A0@<eax>(_BYTE *a1@<edx>, int a2, int a3)
{
  _BYTE *v3; // ecx@1
  int v4; // ebx@1
  signed int v5; // edi@1
  _BYTE *v6; // esi@3
  _BYTE *result; // eax@3
  signed int v8; // ebp@3
  char v9; // bl@4

  v3 = (_BYTE *)a3;
  v4 = a2;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = (_BYTE *)(v4 + 8 * (v5 + ((unsigned int)*a1 >> 4)));
    result = (_BYTE *)(v4 + 8 * (v5 + (*a1 & 0xF)) + 128);
    v8 = 8;
    do
    {
      v9 = *result++ | *v6;
      *v3 |= v9;
      ++v6;
      ++v3;
      --v8;
    }
    while ( v8 );
    v5 += 32;
    ++a1;
    if ( v5 >= 256 )
      break;
    v4 = a2;
    v3 = (_BYTE *)a3;
  }
  return result;
}

//----- (10006310) --------------------------------------------------------
int __usercall sub_10006310@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>)
{
  bool v4; // zf@1
  int v5; // eax@1
  int result; // eax@2

  v4 = (a1 & 1) == 0;
  v5 = a3 + 8 * a1;
  if ( v4 )
  {
    result = sub_10006060(v5, a2, *(_DWORD *)(a4 + 4));
    *(_DWORD *)a4 ^= result;
  }
  else
  {
    result = sub_10006060(v5, a2, *(_DWORD *)a4);
    *(_DWORD *)(a4 + 4) ^= result;
  }
  return result;
}

//----- (10006340) --------------------------------------------------------
signed int __fastcall sub_10006340(int a1, char *a2)
{
  char *v2; // ebx@1
  int v3; // esi@1
  signed int v4; // eax@1
  signed int v5; // edi@3
  signed int v6; // eax@4
  int v7; // ecx@4
  int v8; // esi@5
  int v9; // esi@7
  int v10; // esi@9
  int v11; // esi@11
  unsigned int v12; // ecx@14
  unsigned int v13; // ebp@14
  unsigned int v14; // esi@14
  char *v15; // eax@16
  char *v16; // eax@18
  char *v17; // eax@20
  char *v18; // eax@22
  char *v19; // eax@24
  char *v20; // eax@26
  signed int result; // eax@27
  char *v22; // [sp+10h] [bp-84h]@1
  signed int v23; // [sp+14h] [bp-80h]@9
  unsigned int v24; // [sp+14h] [bp-80h]@14
  unsigned int v25; // [sp+18h] [bp-7Ch]@14
  unsigned int v26; // [sp+1Ch] [bp-78h]@14
  char v27; // [sp+20h] [bp-74h]@7
  char v28; // [sp+21h] [bp-73h]@9
  char v29; // [sp+22h] [bp-72h]@11
  char v30[53]; // [sp+23h] [bp-71h]@13
  char v31; // [sp+58h] [bp-3Ch]@2
  char v32; // [sp+59h] [bp-3Bh]@2
  char v33; // [sp+5Ah] [bp-3Ah]@2
  char v34[53]; // [sp+5Bh] [bp-39h]@2

  v2 = a2;
  v3 = a1;
  v22 = a2;
  memset(a2, 0, 0x80u);
  v4 = 0;
  do
  {
    *(&v31 + v4) = (*(_BYTE *)((((unsigned __int8)byte_100411A8[v4] - 1) >> 3) + v3) & dword_10041440[((unsigned __int8)byte_100411A8[v4] - 1) & 7]) != 0;
    *(&v32 + v4) = (*(_BYTE *)((((unsigned __int8)byte_100411A9[v4] - 1) >> 3) + v3) & dword_10041440[((unsigned __int8)byte_100411A9[v4] - 1) & 7]) != 0;
    *(&v33 + v4) = (*(_BYTE *)((((unsigned __int8)byte_100411AA[v4] - 1) >> 3) + v3) & dword_10041440[((unsigned __int8)byte_100411AA[v4] - 1) & 7]) != 0;
    v34[v4] = (*(_BYTE *)((((unsigned __int8)byte_100411AB[v4] - 1) >> 3) + v3) & dword_10041440[((unsigned __int8)byte_100411AB[v4]
                                                                                                - 1) & 7]) != 0;
    v4 += 4;
  }
  while ( v4 < 56 );
  v5 = 0;
  do
  {
    v6 = 0;
    v7 = (unsigned __int8)byte_100411E0[v5] - 26;
    do
    {
      v8 = v7 + 26;
      if ( v7 + 26 >= (v6 >= 28 ? 56 : 28) )
        v8 = v7 - 2;
      *(&v27 + v6) = *(&v31 + v8);
      v9 = v7 + 27;
      if ( v7 + 27 >= (v6 >= 27 ? 56 : 28) )
        v9 = v7 - 1;
      *(&v28 + v6) = *(&v31 + v9);
      v23 = v6;
      v10 = v7 + 28;
      if ( v7 + 28 >= (v6 + 2 >= 28 ? 56 : 28) )
        v10 = v7;
      *(&v29 + v6) = *(&v31 + v10);
      v11 = v7 + 29;
      if ( v7 + 29 >= (v6 >= 25 ? 56 : 28) )
        v11 = v7 + 1;
      v30[v6] = *(&v31 + v11);
      v6 += 4;
      v7 += 4;
    }
    while ( v23 + 4 < 56 );
    v12 = 0;
    v24 = 5;
    v25 = 4;
    v26 = 3;
    v13 = 2;
    v14 = 1;
    do
    {
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411EF[v14] + 3) )
      {
        v15 = &v2[8 * v5] + v12 / 6;
        v2 = v22;
        *v15 |= dword_10041440[v12 % 6] >> 2;
      }
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411F0[v14] + 3) )
      {
        v16 = &v2[8 * v5] + v14 / 6;
        v2 = v22;
        *v16 |= dword_10041444[v12 - 6 * (v14 / 6)] >> 2;
      }
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411F0[v13] + 3) )
      {
        v17 = &v2[8 * v5] + v13 / 6;
        v2 = v22;
        *v17 |= dword_10041448[v12 - 6 * (v13 / 6)] >> 2;
      }
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411F0[v26] + 3) )
      {
        v18 = &v2[8 * v5] + v26 / 6;
        v2 = v22;
        *v18 |= dword_1004144C[v12 - 6 * (v26 / 6)] >> 2;
      }
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411F0[v25] + 3) )
      {
        v19 = &v2[8 * v5] + v25 / 6;
        v2 = v22;
        *v19 |= dword_10041450[v12 - 6 * (v25 / 6)] >> 2;
      }
      if ( *((_BYTE *)&v26 + (unsigned __int8)byte_100411F0[v24] + 3) )
      {
        v20 = &v2[8 * v5] + v24 / 6;
        v2 = v22;
        *v20 |= dword_10041454[v12 - 6 * (v24 / 6)] >> 2;
      }
      result = 6;
      v26 += 6;
      v25 += 6;
      v24 += 6;
      v14 += 6;
      v12 += 6;
      v13 += 6;
    }
    while ( (signed int)v14 < 49 );
    ++v5;
  }
  while ( v5 < 16 );
  return result;
}
// 10041440: using guessed type int dword_10041440[];
// 10041444: using guessed type int dword_10041444[];
// 10041448: using guessed type int dword_10041448[];
// 1004144C: using guessed type int dword_1004144C[];
// 10041450: using guessed type int dword_10041450[];
// 10041454: using guessed type int dword_10041454[];
// 10006340: using guessed type char var_39[53];
// 10006340: using guessed type char var_71[53];

//----- (10006690) --------------------------------------------------------
int __fastcall sub_10006690(int a1, int a2)
{
  signed int v2; // ecx@1
  signed int v3; // eax@2
  char *v4; // edi@7
  int result; // eax@7
  void *v6; // ebp@7
  signed int v7; // esi@8
  char v8; // al@9
  signed int v9; // edx@9
  signed int *v10; // [sp+10h] [bp-28h]@8
  char v11; // [sp+14h] [bp-24h]@4
  char v12; // [sp+15h] [bp-23h]@7

  v2 = 0;
  do
  {
    v3 = 0;
    do
    {
      if ( (unsigned __int8)byte_10041420[v3] - 1 == v2 )
      {
        *(&v11 + v2) = v3;
        v3 = 32;
      }
      ++v3;
    }
    while ( v3 < 32 );
    ++v2;
  }
  while ( v2 < 32 );
  v4 = &v12;
  result = a2;
  v6 = &unk_10041220;
  do
  {
    v7 = 0;
    v10 = (signed int *)result;
    do
    {
      v8 = *((_BYTE *)v6 + (v7 & 0x20 | 16 * (v7 & 1) | (v7 >> 1) & 0xF));
      v9 = 0;
      if ( v8 & 8 )
        v9 = 1 << (31 - *(v4 - 1));
      if ( v8 & 4 )
        v9 |= 1 << (31 - *v4);
      if ( v8 & 2 )
        v9 |= 1 << (31 - v4[1]);
      if ( v8 & 1 )
        v9 |= 1 << (31 - v4[2]);
      *v10 = v9;
      ++v7;
      result = (int)(v10 + 1);
      ++v10;
    }
    while ( v7 < 64 );
    v6 = (char *)v6 + 64;
    v4 += 4;
  }
  while ( (signed int)v6 < (signed int)byte_10041420 );
  return result;
}

//----- (100067B0) --------------------------------------------------------
_BYTE *__usercall sub_100067B0@<eax>(int a1@<ebx>, _BYTE *a2, int a3)
{
  int v3; // edi@1
  unsigned int v4; // eax@3
  unsigned int v6; // [sp+8h] [bp-808h]@1
  int v7; // [sp+Ch] [bp-804h]@1
  char v8; // [sp+10h] [bp-800h]@1

  sub_10006120(&v8, (int)&unk_10041128);
  sub_100062A0(a2, (int)&v8, (int)&v6);
  v6 = (((v6 << 16) | v6 & 0xFF00) << 8) | (((v6 >> 16) | v6 & 0xFF0000) >> 8);
  v7 = (((v7 << 16) | v7 & 0xFF00) << 8) | ((((unsigned int)v7 >> 16) | v7 & 0xFF0000) >> 8);
  sub_10006690(v7, (int)&v8);
  v3 = 0;
  do
    sub_10006310(v3++, (int)&v8, a1, (int)&v6);
  while ( v3 < 16 );
  v4 = v6;
  v6 = (((v7 << 16) | v7 & 0xFF00) << 8) | ((((unsigned int)v7 >> 16) | v7 & 0xFF0000) >> 8);
  v7 = (((v4 << 16) | v4 & 0xFF00) << 8) | (((v4 >> 16) | v4 & 0xFF0000) >> 8);
  sub_10006120(&v8, (int)&unk_10041168);
  return sub_100062A0(&v6, (int)&v8, a3);
}

//----- (100068F0) --------------------------------------------------------
_BYTE *__cdecl sub_100068F0(_BYTE *a1, int a2, int a3)
{
  char v4; // [sp+4h] [bp-80h]@1

  sub_10006340(a2, &v4);
  return sub_100067B0((int)&v4, a1, a3);
}

//----- (10006930) --------------------------------------------------------
_BYTE *__cdecl sub_10006930(_BYTE *a1, int a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+Ch] [bp-Ch]@1

  v3 = sub_10005FB0((int)&v5, a2);
  return sub_100068F0(a1, v3, a3);
}

//----- (10006980) --------------------------------------------------------
int __cdecl sub_10006980(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)a1 = 1732584193;
  *(_DWORD *)(a1 + 4) = -271733879;
  *(_DWORD *)(a1 + 8) = -1732584194;
  *(_DWORD *)(a1 + 12) = 271733878;
  return result;
}

//----- (100069B0) --------------------------------------------------------
int __usercall sub_100069B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@2
  unsigned int v4; // ecx@2
  int v5; // edi@3
  unsigned __int16 v6; // dx@3

  if ( a3 )
  {
    result += 2;
    v3 = a2;
    v4 = ((unsigned int)(a3 - 1) >> 2) + 1;
    do
    {
      v5 = *(_BYTE *)(result - 1);
      HIBYTE(v6) = *(_BYTE *)(result + 1);
      v3 += 4;
      result += 4;
      LOBYTE(v6) = *(_BYTE *)(result - 4);
      --v4;
      *(_DWORD *)(v3 - 4) = *(_BYTE *)(result - 6) | ((v5 | (v6 << 8)) << 8);
    }
    while ( v4 );
  }
  return result;
}

//----- (100069F0) --------------------------------------------------------
int __usercall sub_100069F0@<eax>(int result@<eax>, int a2, int a3, int a4)
{
  int v4; // ecx@2
  unsigned int v5; // esi@2

  if ( a4 )
  {
    v4 = a2 + 1;
    result = a3 + 2;
    v5 = ((unsigned int)(a4 - 1) >> 2) + 1;
    do
    {
      *(_BYTE *)(v4 - 1) = *(_BYTE *)(result - 2);
      *(_BYTE *)v4 = *(_BYTE *)(result - 1);
      *(_BYTE *)(v4 + 1) = *(_BYTE *)result;
      *(_BYTE *)(v4 + 2) = *(_BYTE *)(result + 1);
      result += 4;
      v4 += 4;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (10006A40) --------------------------------------------------------
int __usercall sub_10006A40@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // eax@1
  int v12; // ecx@1
  int v13; // edx@1
  int v14; // esi@1
  int v15; // edi@1
  int v16; // ebx@1
  int v17; // ecx@1
  int v18; // edx@1
  int v19; // esi@1
  int v20; // eax@1
  int v21; // edi@1
  int v22; // edx@1
  int v23; // esi@1
  int v24; // eax@1
  int v25; // edi@1
  int v26; // edx@1
  int v27; // esi@1
  int v28; // eax@1
  int v29; // edi@1
  int v30; // edx@1
  int v31; // esi@1
  int v32; // eax@1
  int v33; // edi@1
  int v34; // edx@1
  int v35; // esi@1
  int v36; // eax@1
  int v37; // edi@1
  int v38; // edx@1
  int v39; // esi@1
  int v40; // eax@1
  int v41; // edi@1
  int v42; // ecx@1
  int v43; // esi@1
  int v44; // ebx@1
  int v45; // edx@1
  int v46; // eax@1
  int v47; // esi@1
  int v48; // edi@1
  int v49; // edx@1
  int v50; // eax@1
  int v51; // ecx@1
  int v52; // esi@1
  int v53; // edi@1
  int v54; // edx@1
  int result; // eax@1
  int v56; // [sp+18h] [bp-40h]@1
  int v57; // [sp+1Ch] [bp-3Ch]@1
  int v58; // [sp+20h] [bp-38h]@1
  int v59; // [sp+24h] [bp-34h]@1
  int v60; // [sp+28h] [bp-30h]@1
  int v61; // [sp+2Ch] [bp-2Ch]@1
  int v62; // [sp+30h] [bp-28h]@1
  int v63; // [sp+34h] [bp-24h]@1
  int v64; // [sp+38h] [bp-20h]@1
  int v65; // [sp+3Ch] [bp-1Ch]@1
  int v66; // [sp+40h] [bp-18h]@1
  int v67; // [sp+44h] [bp-14h]@1
  int v68; // [sp+48h] [bp-10h]@1
  int v69; // [sp+4Ch] [bp-Ch]@1
  int v70; // [sp+50h] [bp-8h]@1
  int v71; // [sp+54h] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(a2 + 4);
  sub_100069B0(a1, (int)&v56, 64);
  v6 = __ROL4__(v56 + *(_DWORD *)a2 + (v5 & v4 | v3 & ~v5), 3);
  v7 = __ROL4__(v3 + v57 + (v6 & v5 | v4 & ~v6), 7);
  v8 = __ROL4__(v4 + v58 + (v6 & v7 | v5 & ~v7), 11);
  v9 = __ROR4__(v5 + v59 + (v8 & v7 | v6 & ~v8), 13);
  v10 = __ROL4__(v6 + v60 + (v9 & v8 | v7 & ~v9), 3);
  v11 = __ROL4__(v7 + v61 + (v10 & v9 | v8 & ~v10), 7);
  v12 = __ROL4__(v8 + v62 + (v10 & v11 | v9 & ~v11), 11);
  v13 = __ROR4__(v9 + v63 + (v12 & v11 | v10 & ~v12), 13);
  v14 = __ROL4__(v10 + v64 + (v13 & v12 | v11 & ~v13), 3);
  v15 = __ROL4__(v11 + v65 + (v14 & v13 | v12 & ~v14), 7);
  v16 = __ROL4__(v12 + v66 + (v14 & v15 | v13 & ~v15), 11);
  v17 = __ROR4__(v13 + v67 + (v16 & v15 | v14 & ~v16), 13);
  v18 = __ROL4__(v14 + v68 + (v17 & v16 | v15 & ~v17), 3);
  v19 = __ROL4__(v15 + v69 + (v18 & v17 | v16 & ~v18), 7);
  v20 = __ROL4__(v16 + v70 + (v18 & v19 | v17 & ~v19), 11);
  v21 = __ROR4__(v17 + v71 + (v20 & v19 | v18 & ~v20), 13);
  v22 = __ROL4__(v56 + (v21 & v20 | v19 & (v21 | v20)) + v18 + 1518500249, 3);
  v23 = __ROL4__(v60 + (v22 & v21 | v20 & (v22 | v21)) + v19 + 1518500249, 5);
  v24 = __ROL4__(v64 + (v22 & v21 | v23 & (v22 | v21)) + v20 + 1518500249, 9);
  v25 = __ROL4__(v68 + (v22 & v24 | v23 & (v22 | v24)) + v21 + 1518500249, 13);
  v26 = __ROL4__(v57 + (v25 & v24 | v23 & (v25 | v24)) + v22 + 1518500249, 3);
  v27 = __ROL4__(v61 + (v26 & v25 | v24 & (v26 | v25)) + v23 + 1518500249, 5);
  v28 = __ROL4__(v65 + (v26 & v25 | v27 & (v26 | v25)) + v24 + 1518500249, 9);
  v29 = __ROL4__(v69 + (v26 & v28 | v27 & (v26 | v28)) + v25 + 1518500249, 13);
  v30 = __ROL4__(v58 + (v29 & v28 | v27 & (v29 | v28)) + v26 + 1518500249, 3);
  v31 = __ROL4__(v62 + (v30 & v29 | v28 & (v30 | v29)) + v27 + 1518500249, 5);
  v32 = __ROL4__(v66 + (v30 & v29 | v31 & (v30 | v29)) + v28 + 1518500249, 9);
  v33 = __ROL4__(v70 + (v30 & v32 | v31 & (v30 | v32)) + v29 + 1518500249, 13);
  v34 = __ROL4__(v59 + (v33 & v32 | v31 & (v33 | v32)) + v30 + 1518500249, 3);
  v35 = __ROL4__(v63 + (v34 & v33 | v32 & (v34 | v33)) + v31 + 1518500249, 5);
  v36 = __ROL4__(v67 + (v34 & v33 | v35 & (v34 | v33)) + v32 + 1518500249, 9);
  v37 = __ROL4__(v71 + (v34 & v36 | v35 & (v34 | v36)) + v33 + 1518500249, 13);
  v38 = __ROL4__(v56 + (v37 ^ v36 ^ v35) + v34 + 1859775393, 3);
  v39 = __ROL4__(v64 + (v38 ^ v37 ^ v36) + v35 + 1859775393, 9);
  v40 = __ROL4__(v60 + (v38 ^ v37 ^ v39) + v36 + 1859775393, 11);
  v41 = __ROL4__(v68 + (v38 ^ v40 ^ v39) + v37 + 1859775393, 15);
  v42 = __ROL4__(v58 + (v41 ^ v40 ^ v39) + v38 + 1859775393, 3);
  v43 = __ROL4__(v66 + (v42 ^ v41 ^ v40) + v39 + 1859775393, 9);
  v44 = __ROL4__(v62 + (v42 ^ v41 ^ v43) + v40 + 1859775393, 11);
  v45 = __ROL4__(v70 + (v42 ^ v44 ^ v43) + v41 + 1859775393, 15);
  v46 = __ROL4__(v57 + (v45 ^ v44 ^ v43) + v42 + 1859775393, 3);
  v47 = __ROL4__(v65 + (v46 ^ v45 ^ v44) + v43 + 1859775393, 9);
  v48 = __ROL4__(v61 + (v46 ^ v45 ^ v47) + v44 + 1859775393, 11);
  v49 = __ROL4__(v69 + (v46 ^ v48 ^ v47) + v45 + 1859775393, 15);
  v50 = __ROL4__(v59 + (v49 ^ v48 ^ v47) + v46 + 1859775393, 3);
  v51 = __ROL4__(v67 + (v50 ^ v49 ^ v48) + v47 + 1859775393, 9);
  v52 = v63 + (v50 ^ v49 ^ v51) + v48 + 1859775393;
  *(_DWORD *)v2 += v50;
  v52 = __ROL4__(v52, 11);
  v53 = v71 + (v50 ^ v52 ^ v51);
  *(_DWORD *)(v2 + 8) += v52;
  v54 = __ROL4__(v53 + v49 + 1859775393, 15);
  result = v51 + *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v2 + 4) += v54;
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (10006ED0) --------------------------------------------------------
void *__cdecl sub_10006ED0(int a1, void *a2, int a3)
{
  unsigned int v3; // ecx@1
  int v4; // eax@1
  int v5; // ebx@3
  int v6; // ebp@4
  unsigned int i; // ebx@4

  v3 = *(_DWORD *)(a1 + 16) + 8 * a3;
  v4 = (*(_DWORD *)(a1 + 16) >> 3) & 0x3F;
  *(_DWORD *)(a1 + 16) = v3;
  if ( v3 < 8 * a3 )
    ++*(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) += (unsigned int)a3 >> 29;
  v5 = 64 - v4;
  if ( a3 < (unsigned int)(64 - v4) )
  {
    v6 = 0;
  }
  else
  {
    memcpy_0((void *)(v4 + a1 + 24), a2, 64 - v4);
    sub_10006A40(a1 + 24, a1);
    v6 = v5;
    for ( i = v5 + 63; i < a3; v6 += 64 )
    {
      sub_10006A40((int)a2 + i - 63, a1);
      i += 64;
    }
    v4 = 0;
  }
  return memcpy_0((void *)(v4 + a1 + 24), (char *)a2 + v6, a3 - v6);
}

//----- (10006F80) --------------------------------------------------------
void *__cdecl sub_10006F80(void *a1, int a2)
{
  unsigned int v2; // eax@1
  signed int v3; // ecx@1
  void *v4; // eax@3
  char v6; // [sp+Ch] [bp-Ch]@1

  sub_100069F0((int)&v6, (int)&v6, (int)a1 + 16, 8);
  v2 = (*((_DWORD *)a1 + 4) >> 3) & 0x3F;
  v3 = 56;
  if ( v2 >= 0x38 )
    v3 = 120;
  sub_10006ED0((int)a1, &unk_10041470, v3 - v2);
  v4 = sub_10006ED0((int)a1, &v6, 8);
  sub_100069F0((int)v4, a2, (int)a1, 16);
  return memset(a1, 0, 0x58u);
}

//----- (10007010) --------------------------------------------------------
void *__cdecl sub_10007010(int a1, int a2, int a3)
{
  void *v3; // edx@1
  int v5; // [sp+4h] [bp-5Ch]@1

  sub_10006980((int)&v5);
  sub_10006ED0((int)&v5, v3, a2);
  return sub_10006F80(&v5, a3);
}

//----- (10007060) --------------------------------------------------------
char *__cdecl sub_10007060(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_100228B0();
  *(_DWORD *)(a5 + 596) = sub_100228F0();
  sub_10022910((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_100077F0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_100080D0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10007190) --------------------------------------------------------
char sub_10007190()
{
  char result; // al@1

  result = 0;
  byte_100F4100 = 0;
  byte_100F4101 = 0;
  return result;
}
// 100F4100: using guessed type char byte_100F4100;
// 100F4101: using guessed type char byte_100F4101;

//----- (100071A0) --------------------------------------------------------
char __cdecl sub_100071A0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10007060(-5, a1, a2, a4, a5);
  else
    sub_10007060(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_10007B00((const char *)(a5 + 485), " DBGA", 100);
  sub_10022910((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100F4100 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100F4101 )
LABEL_15:
      result = sub_10022950(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10022C20: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100F4100: using guessed type char byte_100F4100;
// 100F4101: using guessed type char byte_100F4101;

//----- (100072A0) --------------------------------------------------------
char __cdecl sub_100072A0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_100071A0(a1, a2, a3, a4, (int)&v5);
}

//----- (10007310) --------------------------------------------------------
int __cdecl sub_10007310(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100414B6[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100414B6[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10007400) --------------------------------------------------------
int __cdecl sub_10007400(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( (a3 - a2) % 4 )
    result = -1;
  else
    result = a1 + 126230400 * ((a3 - a2) / 4);
  return result;
}

//----- (10007440) --------------------------------------------------------
int __cdecl sub_10007440(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_100414B6[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10007530) --------------------------------------------------------
__int16 __cdecl sub_10007530(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10007580) --------------------------------------------------------
int __cdecl sub_10007580(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (100075B0) --------------------------------------------------------
signed __int64 __cdecl sub_100075B0(int a1)
{
  signed __int64 v1; // kr00_8@1

  v1 = (unsigned int)(sub_10007400(a1, 1970, 1990) - 86400) - 1240428288i64;
  return 10000000 * __PAIR__(HIDWORD(v1) + 2, (unsigned int)v1);
}

//----- (100075F0) --------------------------------------------------------
int __cdecl sub_100075F0(signed __int64 a1)
{
  int result; // eax@2

  if ( a1 >= 116444736000000000i64 )
    result = sub_10007400((a1 - 116444736000000000i64) / 10000000, 1990, 1970) + 86400;
  else
    result = 0;
  return result;
}

//----- (10007640) --------------------------------------------------------
__int16 __cdecl sub_10007640(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10007530((int)&v5, *a1);
  sub_10007310((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (100076C0) --------------------------------------------------------
_DWORD *__cdecl sub_100076C0(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v3; // ecx@0
  unsigned int v4; // ecx@1
  _DWORD *result; // eax@1
  bool v6; // zf@2
  unsigned int v7; // [sp+0h] [bp-4h]@1

  v7 = v3;
  v4 = a2;
  result = (_DWORD *)a1;
  if ( (_WORD)a2 )
    v6 = (_WORD)a2 == -1;
  else
    v6 = (_WORD)a1 == 0;
  if ( v6 || (_WORD)a1 == -1 )
  {
    *a3 = -1;
  }
  else
  {
    BYTE3(a2) = 2 * (a2 & 0x1F);
    BYTE2(a2) = (v4 >> 5) & 0x3F;
    LOWORD(a2) = (unsigned __int16)v4 >> 11;
    HIWORD(v7) = ((unsigned __int16)a1 >> 9) + 1980;
    BYTE1(v7) = a1 & 0x1F;
    LOBYTE(v7) = (a1 >> 5) & 0xF;
    sub_10007580((int *)&a2, a2);
    sub_10007440((int *)&v7, v7);
    result = a3;
    *a3 = a2 + v7;
  }
  return result;
}

//----- (10007770) --------------------------------------------------------
int __cdecl sub_10007770(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // ecx@1
  _BYTE *v5; // edx@2
  int result; // eax@5

  v3 = 0;
  v4 = 0;
  if ( a3 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = (_BYTE *)(a1 + 1);
    do
    {
      *(v5 - 1) = *(_BYTE *)(v4 + a2);
      *v5 = 0;
      ++v3;
      v5 += 2;
      if ( !*(_BYTE *)(v4 + a2) )
        break;
      ++v4;
    }
    while ( v4 < a3 );
    result = v3;
  }
  return result;
}

//----- (100077C0) --------------------------------------------------------
char __cdecl sub_100077C0(_BYTE *a1)
{
  _BYTE *v1; // edx@1
  char v2; // cl@1
  char result; // al@1

  v1 = a1;
  v2 = *a1;
  result = 0;
  if ( *a1 )
  {
    while ( v2 != 42 && v2 != 63 )
    {
      v2 = (v1++)[1];
      if ( !v2 )
        return result;
    }
    result = 1;
  }
  return result;
}

//----- (100077F0) --------------------------------------------------------
int __cdecl sub_100077F0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10007840) --------------------------------------------------------
signed int __cdecl sub_10007840(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (100078B0) --------------------------------------------------------
int __cdecl sub_100078B0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (100078E0) --------------------------------------------------------
int __cdecl sub_100078E0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10007920) --------------------------------------------------------
char __usercall sub_10007920@<al>(int a1@<ebx>, int a2, int a3, int a4, char a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ecx@4
  int v10; // ebp@16
  int v11; // eax@20
  char v13; // [sp+Fh] [bp-5h]@1

  v5 = 0;
  v6 = 0;
  v13 = 0;
  if ( a2 <= 0 )
  {
LABEL_28:
    v9 = a3;
    goto LABEL_29;
  }
  while ( v5 < a4 )
  {
    if ( a5 & 1 )
    {
      v9 = a3;
      v8 = *(_BYTE *)(v5 + a3);
      v7 = *(_BYTE *)(v6 + a1);
    }
    else
    {
      v7 = tolower(*(_BYTE *)(v6 + a1));
      v8 = tolower(*(_BYTE *)(v5 + a3));
      v9 = a3;
    }
    if ( v7 == v8 )
    {
      ++v5;
    }
    else
    {
      if ( a5 & 2 && (v8 == 63 || v8 == 42) )
        goto LABEL_34;
      if ( v8 == 63 )
        goto LABEL_12;
      if ( v8 == 42 )
      {
        ++v5;
        v13 = 1;
        if ( v5 >= a4 )
          return 1;
        if ( a5 & 1 )
          v10 = *(_BYTE *)(v5 + v9);
        else
          v10 = tolower(*(_BYTE *)(v5 + v9));
        if ( v6 >= a2 )
          goto LABEL_27;
        while ( 1 )
        {
          v11 = a5 & 1 ? *(_BYTE *)(v6 + a1) : tolower(*(_BYTE *)(v6 + a1));
          if ( v11 == v10 )
            break;
          if ( ++v6 >= a2 )
            goto LABEL_27;
        }
LABEL_12:
        ++v5;
        goto LABEL_27;
      }
      if ( v13 != 1 )
        goto LABEL_34;
      v5 = 0;
    }
LABEL_27:
    if ( ++v6 >= a2 )
      goto LABEL_28;
  }
  v9 = a3;
LABEL_34:
  if ( v6 < a2 )
    return 0;
LABEL_29:
  if ( v5 < a4 )
  {
    while ( *(_BYTE *)(v5 + v9) == 42 )
    {
      if ( ++v5 >= a4 )
        return 1;
    }
    if ( v5 < a4 )
      return 0;
  }
  return 1;
}

//----- (10007A80) --------------------------------------------------------
int sub_10007A80(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_100078E0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (10007AB0) --------------------------------------------------------
char __cdecl sub_10007AB0(const char *a1, const char *a2, char a3)
{
  return sub_10007920((int)a1, strlen(a1), (int)a2, strlen(a2), a3);
}

//----- (10007B00) --------------------------------------------------------
int __cdecl sub_10007B00(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_100077F0((int)&a1[v3], a2, a3 - v3);
}

//----- (10007B40) --------------------------------------------------------
#error "10007B45: call analysis failed (funcsize=28)"

//----- (10007B70) --------------------------------------------------------
int __cdecl sub_10007B70(int *a1)
{
  int result; // eax@1

  result = sub_1000B110((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_100228F0();
    result = sub_1000AF50();
  }
  return result;
}

//----- (10007BA0) --------------------------------------------------------
char __usercall sub_10007BA0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_100229A0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1000C1D0("%i %i\r\n", 13, v2);
    sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10022980(*(_DWORD *)(a1 + 4));
    v6 = sub_1000C1D0("%i %i\r\n", 14, v5);
    sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_10041DEC, (int)v6);
    result = 1;
  }
  else
  {
    sub_100072A0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10007C50) --------------------------------------------------------
int __cdecl sub_10007C50(const char *a1)
{
  int result; // eax@1

  result = sub_10009270();
  if ( a1 )
    result = sub_1000B140(dword_100F4104[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 100F4104: using guessed type int dword_100F4104[];

//----- (10007C90) --------------------------------------------------------
char __cdecl sub_10007C90(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1000B090((char *)a1 + 4);
  v1 = sub_10011AF0();
  sub_1000B030((int)v1, 0, 0);
  dword_100F4104[sub_10009270()] = (int)a1;
  v2 = sub_10011AB0((int)sub_10007C50);
  return sub_1000B160(v2);
}
// 100F4104: using guessed type int dword_100F4104[];

//----- (10007CE0) --------------------------------------------------------
signed int __cdecl sub_10007CE0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_100228F0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10022A50(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_100228F0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10022A70(&v23);
          }
          while ( sub_100228F0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100228D0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10022910((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1000C1D0("The %s task is loaded.", &v24);
            sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1000C1D0("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1000C1D0("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1000C1D0(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10022890(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1000C1D0("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1000C1D0("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1000B770(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1000B770(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10022950(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10011AB0((int)sub_10007C50);
        sub_1000B840((int)v15);
        v16 = sub_10012E90((int)sub_10007C50);
        sub_1000B840((int)v16);
        v17 = sub_10012E90((int)sub_10007C50);
        sub_1000B160(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10011AB0((int)sub_10007C50);
        sub_1000B840((int)v18);
        v19 = sub_10012E90((int)sub_10007C50);
        sub_1000B840((int)v19);
        v20 = sub_10011AB0((int)sub_10007C50);
        sub_1000B160(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10007BA0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10008080) --------------------------------------------------------
char **sub_10008080()
{
  return off_10041DD8;
}
// 10041DD8: using guessed type char *off_10041DD8[3];

//----- (100080A0) --------------------------------------------------------
signed int sub_100080A0()
{
  return 1000;
}

//----- (100080C0) --------------------------------------------------------
int sub_100080C0()
{
  return sub_10008100((int)off_10042460);
}
// 10042460: using guessed type int (*off_10042460[4])();

//----- (100080D0) --------------------------------------------------------
char __cdecl sub_100080D0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10012F50(13, (char *)&v3 + 3);
  sub_10012F50(12, a1);
  return BYTE3(v3);
}

//----- (10008100) --------------------------------------------------------
int __cdecl sub_10008100(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100F4118 = *(_DWORD *)a1;
  dword_100F411C = *(_DWORD *)(a1 + 4);
  dword_100F4120 = *(_DWORD *)(a1 + 8);
  dword_100F4124 = *(_DWORD *)(a1 + 12);
  dword_1019D1D4 = (int)&dword_100F4118;
  return result;
}
// 100F4118: using guessed type int dword_100F4118;
// 100F411C: using guessed type int dword_100F411C;
// 100F4120: using guessed type int dword_100F4120;
// 100F4124: using guessed type int dword_100F4124;
// 1019D1D4: using guessed type int dword_1019D1D4;

//----- (10008190) --------------------------------------------------------
int sub_10008190()
{
  int result; // eax@1

  sub_10022B60(6361, (int)&unk_100F4148, 4);
  result = sub_10022B60(6362, (int)&unk_100F414C, 4);
  dword_100F4150 = 1379255385;
  return result;
}
// 100F4150: using guessed type int dword_100F4150;

//----- (100081C0) --------------------------------------------------------
char __thiscall sub_100081C0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_100F4158 = sub_10012FB0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_100F4160, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_100F4160;
  do
  {
    result = sub_10013E00(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 100F4158: using guessed type int dword_100F4158;

//----- (10008230) --------------------------------------------------------
char __usercall sub_10008230@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10013B30(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10013B30(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10008270) --------------------------------------------------------
void *__usercall sub_10008270@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_100F4158 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10022AE0(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_100F4160 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10013E00(a1, (int)&unk_100F4160 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_100F4160 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_100F4158 != 1379255385 )
    result = (void *)sub_10022AB0(v4, 86);
  return result;
}
// 100F4158: using guessed type int dword_100F4158;

//----- (10008310) --------------------------------------------------------
char __cdecl sub_10008310(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10008230(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10008350) --------------------------------------------------------
bool __cdecl sub_10008350(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10008270(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (100083B0) --------------------------------------------------------
char __cdecl sub_100083B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10008230(a2, 1, a3, a1);
  return result;
}

//----- (100083F0) --------------------------------------------------------
char __cdecl sub_100083F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10008270(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10008420) --------------------------------------------------------
char __cdecl sub_10008420(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10008230(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10008460) --------------------------------------------------------
char __cdecl sub_10008460(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10008270(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (100084A0) --------------------------------------------------------
char __cdecl sub_100084A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10008230(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (100084E0) --------------------------------------------------------
bool __cdecl sub_100084E0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10008270(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10008530) --------------------------------------------------------
char __cdecl sub_10008530(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10008230(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10008570) --------------------------------------------------------
bool __cdecl sub_10008570(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10008270(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (100085B0) --------------------------------------------------------
char __cdecl sub_100085B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10008230(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (100085F0) --------------------------------------------------------
bool __cdecl sub_100085F0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10008270(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10008630) --------------------------------------------------------
char __cdecl sub_10008630(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10008230(1229, 1, a2, a1);
  return result;
}

//----- (10008660) --------------------------------------------------------
char __cdecl sub_10008660(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10008270(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10008690) --------------------------------------------------------
char __cdecl sub_10008690(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10008230(1212, 16, a2, a1);
  return result;
}

//----- (100086C0) --------------------------------------------------------
char __cdecl sub_100086C0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10008270(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100086F0) --------------------------------------------------------
char __cdecl sub_100086F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10008230(2400, 65, a2, a1);
  return result;
}

//----- (10008720) --------------------------------------------------------
char __cdecl sub_10008720(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10008270(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10008750) --------------------------------------------------------
char __cdecl sub_10008750(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10008230(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10008790) --------------------------------------------------------
char __cdecl sub_10008790(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_100072A0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10008270(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (100087E0) --------------------------------------------------------
char __cdecl sub_100087E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10008230(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10008820) --------------------------------------------------------
char __cdecl sub_10008820(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10008270(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10008850) --------------------------------------------------------
char __cdecl sub_10008850(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10008230(22, 1, a2, a1);
  return result;
}

//----- (10008880) --------------------------------------------------------
char __cdecl sub_10008880(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10008230(832, 4, a2, a1);
  return result;
}

//----- (100088B0) --------------------------------------------------------
char __cdecl sub_100088B0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10008270(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (100088E0) --------------------------------------------------------
char __cdecl sub_100088E0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10013BC0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10008790(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10008750(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10008820(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_100087E0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10008350(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10008310(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10008570(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10008530(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_100085F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100085B0(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_100083F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100083B0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10008460(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10008420(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10008850(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_100086C0(v6, a5);
        else
          result = sub_10008690(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_100084E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100084A0(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10008720(v6, a5);
        else
          result = sub_100086F0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10008660(v6, a5);
        else
          result = sub_10008630(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100088B0(v6, a5);
        else
          result = sub_10008880(v6, a5);
        break;
      default:
        sub_100072A0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10022C30: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10008C80) --------------------------------------------------------
bool __cdecl sub_10008C80(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_100F56A0 != 1379255385 )
    {
      sub_10013DE0(a1, (int)&byte_100F56A8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_100F56AD[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_100F56AC[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 100F56A0: using guessed type int dword_100F56A0;

//----- (10008CF0) --------------------------------------------------------
bool __cdecl sub_10008CF0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_100F56A0 != 1379255385 )
      sub_10013DE0(a1, (int)&byte_100F56A8[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_100F56BC[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100F56A0: using guessed type int dword_100F56A0;
// 100F56BC: using guessed type int dword_100F56BC[];

//----- (10008D50) --------------------------------------------------------
bool __cdecl sub_10008D50(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_100F56A0 != 1379255385 )
    {
      sub_10013DE0(a1, (int)&byte_100F56A8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_100F56B4[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 100F56A0: using guessed type int dword_100F56A0;
// 100F56B4: using guessed type int dword_100F56B4[];

//----- (10008DC0) --------------------------------------------------------
char __cdecl sub_10008DC0(char a1, _BYTE *a2)
{
  if ( dword_100F56A0 != 1379255385 )
    sub_10013DE0(a1, (int)&byte_100F56A8[24 * (unsigned __int8)a1]);
  *a2 = byte_100F56A8[24 * (unsigned __int8)a1];
  return 1;
}
// 100F56A0: using guessed type int dword_100F56A0;

//----- (10008E00) --------------------------------------------------------
char __thiscall sub_10008E00(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_100F56A0 = sub_10012FB0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_100F56A8, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_100F56A8;
  do
  {
    result = sub_10013DE0(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 100F56A0: using guessed type int dword_100F56A0;

//----- (10008E70) --------------------------------------------------------
char __cdecl sub_10008E70(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10013FA0(a1);
  v3 = sub_10022D40(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10008EA0) --------------------------------------------------------
char __cdecl sub_10008EA0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10013FA0(a1);
  v3 = sub_10022DB0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10008ED0) --------------------------------------------------------
char __cdecl sub_10008ED0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10014090(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10008D50(v7, *a4, (int)a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10008C80(v7, *a4, (int)a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10008CF0(v7, *a4, (int)a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10008DC0(v7, a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10008EA0(v7, (int)a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10008E70(v7, (int)a5);
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100090A0) --------------------------------------------------------
char __thiscall sub_100090A0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_100F56F0 = sub_10012FB0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_100F56F8, 0, 0x1540u);
  memset(&unk_100F6C38, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_100F56F8;
  do
  {
    sub_10013E00(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_100F6C38 );
  v3 = 0;
  v4 = &unk_100F6C38;
  do
  {
    result = sub_10013E80(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)dword_100F85E8 );
  return result;
}
// 100F56F0: using guessed type int dword_100F56F0;
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (10009130) --------------------------------------------------------
char __cdecl sub_10009130(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_100F56F0 != 1379255385;
  v7 = 0;
  v8 = dword_100F56F0 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10022AE0(86, 10);
      memset((char *)&unk_100F56F8 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10013E00(a1, (int)&unk_100F56F8 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_100F59D0[v6] == a2 || byte_100F59D1[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10022AB0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100F56F0: using guessed type int dword_100F56F0;

//----- (100091F0) --------------------------------------------------------
char __cdecl sub_100091F0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10009130(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10009220) --------------------------------------------------------
char *__cdecl sub_10009220(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_100409DD;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10009270) --------------------------------------------------------
int sub_10009270()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_100228B0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_100F85FC[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_100F85FC[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 100F85FC: using guessed type int dword_100F85FC[];

//----- (100092B0) --------------------------------------------------------
int __cdecl sub_100092B0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10009320) --------------------------------------------------------
signed int __cdecl sub_10009320(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100093C0) --------------------------------------------------------
int __usercall sub_100093C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10009320(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100093F0) --------------------------------------------------------
signed int __usercall sub_100093F0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10009320((_BYTE *)a3, (int)(&off_10044850)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_10044854[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_100250C2(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_100250C2(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_100250C2(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 10044850: using guessed type char *off_10044850;

//----- (100095C0) --------------------------------------------------------
char *__usercall sub_100095C0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10009620) --------------------------------------------------------
int __usercall sub_10009620@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10009320((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100096B0) --------------------------------------------------------
int __usercall sub_100096B0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_100093C0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10009700) --------------------------------------------------------
char **__usercall sub_10009700@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10009220(v6);
      if ( !sub_10009320((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10009760) --------------------------------------------------------
const char *__usercall sub_10009760@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10009780) --------------------------------------------------------
int __usercall sub_10009780@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_100F85E8[sub_10009270()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (100097C0) --------------------------------------------------------
int __usercall sub_100097C0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_100093F0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10009850) --------------------------------------------------------
int __usercall sub_10009850@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (100099A0) --------------------------------------------------------
int __usercall sub_100099A0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1000B6F0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_1000A280(v3, v6, 0);
        v7 = -*v3;
        sub_1000B6F0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1000B6F0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_10044508);
      sub_10014510(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_10044508);
      sub_1000B6F0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10009A40) --------------------------------------------------------
int __usercall sub_10009A40@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10009A80) --------------------------------------------------------
char *__cdecl sub_10009A80(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_100095C0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_100095C0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_100095C0(result, v5, (int)&v20);
      v10 = (const char *)&unk_100409DD;
    }
    LOBYTE(v9) = 0;
    sub_100095C0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_100095C0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_100095C0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_100095C0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1000B680(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10009A80: using guessed type int var_61C[6];

//----- (10009C30) --------------------------------------------------------
int __usercall sub_10009C30@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10009220((char **)a1);
  result = sub_1000B710(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_10044508);
  return result;
}

//----- (10009C60) --------------------------------------------------------
int __usercall sub_10009C60@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_10044508);
  v2 = (unsigned int)sub_10009220((char **)a1);
  return sub_1000B6F0(10, v2);
}

//----- (10009C90) --------------------------------------------------------
void __cdecl sub_10009C90(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10009220(v5);
            v7 = sub_10009220((char **)v3);
            if ( !sub_100092B0(v7, (int)v6) )
            {
              v8 = sub_10009220((char **)v3);
              sub_1000B7B0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10009220((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10009220((char **)v3);
        sub_1000B7B0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10009760(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1000C1D0("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10009220((char **)v3);
            sub_1000B7F0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_100092B0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10009760(v18);
                  v25 = sub_1000C1D0("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10009220((char **)v3);
                  sub_1000B7F0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10009220((char **)v3);
                  sub_1000B7F0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10009220((char **)v3);
              sub_1000B7F0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10009220((char **)v3);
              sub_1000B7F0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10009220((char **)v3);
              sub_1000B7F0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10009C90(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10009220((char **)v3);
            sub_1000B7F0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10009220((char **)v3);
            sub_1000B7F0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10009220((char **)v3);
          sub_1000B7F0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10009220((char **)v3);
        sub_1000B7F0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10009220(a2);
      sub_1000B7B0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (1000A100) --------------------------------------------------------
int sub_1000A100()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_100F85E8[sub_10009270()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10009C90(i, 0, &v2);
  }
  return v2;
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000A150) --------------------------------------------------------
void *sub_1000A150()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_100F85E8[0] = 0;
  dword_100F85EC = 0;
  dword_100F85F0 = 0;
  dword_100F85F4 = 0;
  dword_100F85F8 = 0;
  result = &unk_100F8610;
  dword_100F85FC[0] = -1;
  dword_100F8600 = -1;
  dword_100F8604 = -1;
  dword_100F8608 = -1;
  dword_100F860C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10009A40((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 100F85E8: using guessed type int dword_100F85E8[];
// 100F85EC: using guessed type int dword_100F85EC;
// 100F85F0: using guessed type int dword_100F85F0;
// 100F85F4: using guessed type int dword_100F85F4;
// 100F85F8: using guessed type int dword_100F85F8;
// 100F85FC: using guessed type int dword_100F85FC[];
// 100F8600: using guessed type int dword_100F8600;
// 100F8604: using guessed type int dword_100F8604;
// 100F8608: using guessed type int dword_100F8608;
// 100F860C: using guessed type int dword_100F860C;

//----- (1000A1B0) --------------------------------------------------------
char *sub_1000A1B0()
{
  return (char *)&unk_100F8610 + 56 * sub_10009270();
}

//----- (1000A1D0) --------------------------------------------------------
char sub_1000A1D0()
{
  return sub_1000A1B0()[33];
}

//----- (1000A1E0) --------------------------------------------------------
char __cdecl sub_1000A1E0(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_1000A1B0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1000B270(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (1000A220) --------------------------------------------------------
int *__usercall sub_1000A220@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_1000A1B0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10009320((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (1000A270) --------------------------------------------------------
char **sub_1000A270()
{
  return &off_100448B8;
}
// 100448B8: using guessed type char *off_100448B8;

//----- (1000A280) --------------------------------------------------------
int __cdecl sub_1000A280(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10010440();
  v3 = sub_1000A1B0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_1000A100();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10009C30(a2);
    if ( a3 )
    {
      v7 = sub_100099A0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_100099A0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10009C60(a2);
        return v7;
      }
    }
    sub_10009C60(a2);
    result = v7;
  }
  return result;
}

//----- (1000A330) --------------------------------------------------------
int __cdecl sub_1000A330(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_100095C0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_100095C0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_100095C0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1000B680(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_100095C0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_100095C0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_100095C0(v14, "group-begin", (int)&v29);
          sub_1000B680(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10009220(v15);
          sub_1000A330(v16[2], v16[3], v16[4], v17, a4);
          sub_10009220(v16);
          v18 = sub_10009A80((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_100095C0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_100095C0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_100095C0(v20, "group-end", (int)&v29);
          result = sub_1000B680(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_100095C0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_100095C0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_100095C0(v21, a4, (int)&v28);
          v23 = (const char *)&unk_100409DD;
        }
        LOBYTE(v22) = 0;
        v24 = sub_100095C0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_100095C0(v24, *(const char **)v5, (int)&v30);
        result = sub_1000B680(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 1000A330: using guessed type int var_414[4];

//----- (1000A540) --------------------------------------------------------
char *__usercall sub_1000A540@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_100095C0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_100095C0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1000B680(2, (int)v11, 2);
  if ( a6 )
  {
    sub_1000A330(a3, (int)a4, a5, a2, 0);
    result = sub_10009A80(a3, a4, a5, 0);
  }
  return result;
}
// 1000A540: using guessed type int var_20C[2];

//----- (1000A600) --------------------------------------------------------
char *__cdecl sub_1000A600(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_100F85E8[sub_10009270()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10009220((char **)v2);
    sub_1000A540("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_1000A1B0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1000A540(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000A6A0) --------------------------------------------------------
int *__cdecl sub_1000A6A0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_100F85E8[sub_10009270()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10009220(v2);
      if ( !sub_10009320(a1, (int)v4) )
      {
        v5 = sub_10009220(v3);
        sub_1000A540("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_1000A1B0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10009320(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1000A540(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000A760) --------------------------------------------------------
int __usercall sub_1000A760@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10009780(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_1000A280((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10009780(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_1000A280((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10009C30(v5);
        sub_100099A0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10009C60(v8);
          v10 = sub_10009780(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1000A8C0) --------------------------------------------------------
signed int __usercall sub_1000A8C0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_100F85E8[sub_10009270()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_1000A280((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000A930) --------------------------------------------------------
int __cdecl sub_1000A930(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_1000A1B0();
  switch ( a1 )
  {
    case 9:
      sub_1000B6F0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10009320((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10009320(v6, (int)"-q") )
            {
              sub_1000A6A0(v6);
              v9 = sub_1000A100();
              sub_1000B6F0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1000A600(0);
              v8 = sub_1000A100();
              sub_1000B6F0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1000A600(1);
            v7 = sub_1000A100();
            sub_1000B6F0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1000B770(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1000B6F0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1000A600(0);
        v4 = sub_1000A100();
        sub_1000B6F0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1000B6F0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_100F85E8[sub_10009270()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1000A930 )
              v12(2, (int)&unk_10044508);
          }
        }
      }
      sub_10010440();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1000B6F0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_100F85E8[sub_10009270()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1000B770(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1000A760((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1000B770(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1000A8C0((int)v3);
    case 14:
      exit(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1000B770(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1000A930 )
          v15(3, (int)&unk_10044508);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1000A930: using guessed type int __cdecl sub_1000A930(int, int);
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000AC10) --------------------------------------------------------
char **sub_1000AC10()
{
  return off_100446AC;
}
// 100446AC: using guessed type char *off_100446AC[3];

//----- (1000AC20) --------------------------------------------------------
int __usercall sub_1000AC20@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_100096B0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_100097C0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1000AC10();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1000AD10) --------------------------------------------------------
int __cdecl sub_1000AD10(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_1000A1B0();
  *a1 = 0;
  v4 = sub_1000C1D0("Processing command '%s'", v2);
  sub_1000B770(3, (int)&unk_10045060, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10009850(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1000A760((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1000A8C0((int)v3);
    v11 = 0;
    v6 = sub_10009270();
    v7 = sub_10009700((int (**)(void))dword_100F85E8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10009620((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10009620((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1000A280(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1000A280(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1000AC20(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_1000A220(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1000AC20(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1000AC10();
        result = sub_1000AC20(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 100F85E8: using guessed type int dword_100F85E8[];
// 1000AD10: using guessed type char var_2D4[720];

//----- (1000AF50) --------------------------------------------------------
int sub_1000AF50()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1000AD10(&v4);
  if ( !sub_1000A1B0()[32] )
    sub_1000B6F0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1000C1D0("%s %i, %s", "Command status:", v0, &v4);
    sub_1000B770(3, (int)&unk_10045060, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1000C1D0("%s %i", "Command status:", v0);
    sub_1000B770(3, (int)&unk_10045060, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1000B030) --------------------------------------------------------
int __cdecl sub_1000B030(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_100F85E8[sub_10009270()] = a1;
  sub_1000A1B0()[32] = a3;
  sub_10010440();
  sub_10014720(a2);
  v3 = sub_1000A270();
  sub_1000B160(v3);
  return sub_1000AF50();
}
// 100F85E8: using guessed type int dword_100F85E8[];

//----- (1000B080) --------------------------------------------------------
int __cdecl sub_1000B080(int a1)
{
  return a1 + 9;
}

//----- (1000B090) --------------------------------------------------------
int __cdecl sub_1000B090(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_100228B0();
  memset(a1, 0, 0xDCu);
  sub_10007A80((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1000B080(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_100148B0((int)a1, (int)v3);
}

//----- (1000B110) --------------------------------------------------------
int __cdecl sub_1000B110(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10014AC0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1000B140) --------------------------------------------------------
signed int __cdecl sub_1000B140(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_100220C0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_100228F0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_100228F0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_100148B0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1000B160) --------------------------------------------------------
char __cdecl sub_1000B160(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_1000A1B0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10014560("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1000AF50() )
          v7 = 0;
      }
      v5 = sub_10014560("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1000AF50() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1000B270) --------------------------------------------------------
char __cdecl sub_1000B270(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1000B2A0) --------------------------------------------------------
bool __cdecl sub_1000B2A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1000B2D0) --------------------------------------------------------
bool __cdecl sub_1000B2D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1000B300) --------------------------------------------------------
bool __cdecl sub_1000B300(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1000B330) --------------------------------------------------------
bool __cdecl sub_1000B330(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1000B360) --------------------------------------------------------
bool __cdecl sub_1000B360(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1000B390) --------------------------------------------------------
bool __cdecl sub_1000B390(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1000B3D0) --------------------------------------------------------
bool __cdecl sub_1000B3D0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1000B410) --------------------------------------------------------
bool __cdecl sub_1000B410(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1000B440) --------------------------------------------------------
bool __cdecl sub_1000B440(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1000B470) --------------------------------------------------------
char __cdecl sub_1000B470(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1000B4A0) --------------------------------------------------------
bool __cdecl sub_1000B4A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1000B4D0) --------------------------------------------------------
bool __cdecl sub_1000B4D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1000B500) --------------------------------------------------------
bool __cdecl sub_1000B500(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1000B530) --------------------------------------------------------
bool __cdecl sub_1000B530(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1000B560) --------------------------------------------------------
bool __cdecl sub_1000B560(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_10045060, 9u);
}

//----- (1000B590) --------------------------------------------------------
bool __cdecl sub_1000B590(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1000B5C0) --------------------------------------------------------
bool __cdecl sub_1000B5C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1000B5F0) --------------------------------------------------------
bool __cdecl sub_1000B5F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1000B620) --------------------------------------------------------
bool __cdecl sub_1000B620(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1000B650) --------------------------------------------------------
bool __cdecl sub_1000B650(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1000B680) --------------------------------------------------------
int __cdecl sub_1000B680(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_1000A1B0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1000B6F0) --------------------------------------------------------
int __cdecl sub_1000B6F0(int a1, char a2)
{
  return sub_1000B680(a1, (int)&a2, 1);
}

//----- (1000B710) --------------------------------------------------------
int __cdecl sub_1000B710(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1000B680(a1, (int)&v4, 2);
}

//----- (1000B740) --------------------------------------------------------
int __cdecl sub_1000B740(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1000B680(a1, (int)&v5, 3);
}

//----- (1000B770) --------------------------------------------------------
int __cdecl sub_1000B770(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1000B680(a1, (int)&v6, 4);
}

//----- (1000B7B0) --------------------------------------------------------
int __cdecl sub_1000B7B0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1000B680(a1, (int)&v7, 5);
}

//----- (1000B7F0) --------------------------------------------------------
int __cdecl sub_1000B7F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1000B680(a1, (int)&v8, 6);
}

//----- (1000B840) --------------------------------------------------------
char __cdecl sub_1000B840(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_1000A1B0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1000B870) --------------------------------------------------------
char __cdecl sub_1000B870(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1000B880) --------------------------------------------------------
char __cdecl sub_1000B880(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_100409DD;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10014BE0(v16) )
        sub_10014BC0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10014BF0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10014BE0: using guessed type _DWORD __cdecl sub_10014BE0(_DWORD);
// 1000B880: using guessed type char var_104[255];

//----- (1000BA00) --------------------------------------------------------
signed int __cdecl sub_1000BA00(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1000BA40) --------------------------------------------------------
signed int __cdecl sub_1000BA40(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1000BAE0) --------------------------------------------------------
char __cdecl sub_1000BAE0(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1000BB40) --------------------------------------------------------
char __cdecl sub_1000BB40(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10014BA0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1000BBB0) --------------------------------------------------------
char *__cdecl sub_1000BBB0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_100F8728, v1, v2);
  *(&byte_100F8728 + v2) = 0;
  return &byte_100F8728;
}

//----- (1000BC50) --------------------------------------------------------
int __cdecl sub_1000BC50(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000BCC0) --------------------------------------------------------
bool __cdecl sub_1000BCC0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_100250C2(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_100250C2(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1000BD50) --------------------------------------------------------
char __cdecl sub_1000BD50(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1000BE00) --------------------------------------------------------
char __cdecl sub_1000BE00(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1000BE10) --------------------------------------------------------
char __cdecl sub_1000BE10(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10014BA0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1000BE90) --------------------------------------------------------
int (__cdecl *__cdecl sub_1000BE90(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10014C70((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1000BEE0) --------------------------------------------------------
signed int __cdecl sub_1000BEE0(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1000BE10(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000BF30) --------------------------------------------------------
char *__cdecl sub_1000BF30(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10014560("CFG_ActDir", (int)&unk_100409DD);
      v10 = sub_10014560("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10014560("CFG_ExpDir", (int)&unk_100409DD);
      v10 = sub_10014560("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10014560("CFG_ActDir", (int)&unk_100409DD);
      break;
    case 4:
      v10 = sub_10014560("CFG_ExpDir", (int)&unk_100409DD);
      break;
    default:
      v10 = (char *)&unk_100409DD;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_100409DD;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1000BF30: using guessed type char var_104[256];

//----- (1000C0B0) --------------------------------------------------------
int sub_1000C0B0()
{
  return dword_100FD418[sub_10009270()];
}
// 100FD418: using guessed type int dword_100FD418[];

//----- (1000C0C0) --------------------------------------------------------
const char *__cdecl sub_1000C0C0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1004529C[a1];
  return result;
}
// 1004529C: using guessed type char *off_1004529C[7];

//----- (1000C0E0) --------------------------------------------------------
int __cdecl sub_1000C0E0(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1000B7B0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1000C190) --------------------------------------------------------
int __cdecl sub_1000C190(int a1)
{
  int result; // eax@1

  result = sub_10009270();
  dword_100FF524[result] = a1;
  return result;
}
// 100FF524: using guessed type int dword_100FF524[];

//----- (1000C1B0) --------------------------------------------------------
int __cdecl sub_1000C1B0(int a1)
{
  int result; // eax@1

  result = sub_10009270();
  dword_100FD418[result] = a1;
  return result;
}
// 100FD418: using guessed type int dword_100FD418[];

//----- (1000C1D0) --------------------------------------------------------
char *sub_1000C1D0(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10009270() << 8;
  _vsnprintf(&byte_100F8828[v1], 0x100u, a1, va);
  result = &byte_100F8828[v1];
  byte_100F8926[v1] = 42;
  byte_100F8927[v1] = 0;
  return result;
}

//----- (1000C210) --------------------------------------------------------
char *__usercall sub_1000C210@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100452B0[a1 & 1];
  else
    result = off_100452A8[a2];
  return result;
}
// 100452A8: using guessed type char *off_100452A8[4];
// 100452B0: using guessed type char *off_100452B0[2];

//----- (1000C230) --------------------------------------------------------
char __usercall sub_1000C230@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10009270();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1000C0B0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_10100B18[v6];
      v12 = dword_10100B2C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_100FD42C[v6];
      v12 = dword_100FF510[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 100FD42C: using guessed type int dword_100FD42C[];
// 100FF510: using guessed type int dword_100FF510[];
// 10100B18: using guessed type int dword_10100B18[];
// 10100B2C: using guessed type int dword_10100B2C[];

//----- (1000C410) --------------------------------------------------------
int sub_1000C410()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1000C430) --------------------------------------------------------
int sub_1000C430()
{
  return nullsub_1(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1000C450) --------------------------------------------------------
int __cdecl sub_1000C450(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10009270();
  dword_100FF510[result] = a1;
  if ( a2 >= 0 )
  {
    dword_100FD42C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1000C1D0(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1000B770(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_100FD42C[result] = 8;
  }
  return result;
}
// 100FD42C: using guessed type int dword_100FD42C[];
// 100FF510: using guessed type int dword_100FF510[];

//----- (1000C4B0) --------------------------------------------------------
int __cdecl sub_1000C4B0(int a1)
{
  return sub_1000C450(0, a1);
}

//----- (1000C4C0) --------------------------------------------------------
int __cdecl sub_1000C4C0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10009270();
  dword_10100B2C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10100B18[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1000C1D0(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1000B770(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_10100B18[result] = 8;
  }
  return result;
}
// 10100B18: using guessed type int dword_10100B18[];
// 10100B2C: using guessed type int dword_10100B2C[];

//----- (1000C520) --------------------------------------------------------
int __cdecl sub_1000C520(int a1)
{
  return sub_1000C4C0(0, a1);
}

//----- (1000C530) --------------------------------------------------------
bool __cdecl sub_1000C530(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_1000A1D0() )
    v8 = v8 == 0;
  v9 = off_10045280[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_10045270[v8 != 0];
  v19 = off_10045278[a1];
  v18 = v10;
  v21 = sub_1000C210(0, a6);
  v22 = sub_1000C210(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10014E50();
  sub_1000B680(7, (int)&v14, v11);
  sub_10014E60(v12);
  return v8;
}
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000C670) --------------------------------------------------------
bool __cdecl sub_1000C670(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10009270();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v16 = v16 == 0;
  sub_1000C230((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_100F9818[v11], 0x400u, &v30, a6);
  byte_100F9C16[v11] = 42;
  byte_100F9C17[v11] = 0;
  v17 = sub_1000C230((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v11], 0x400u, &v30, a7);
  byte_100FA016[v11] = 42;
  byte_100FA017[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_100FA018[v11];
    byte_100FA018[v11] = 0;
  }
  else
  {
    v17 = sub_1000C230((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_100FA018[v11];
    _snprintf(&byte_100FA018[v11], 0x400u, &v30, 0);
    byte_100FA416[v11] = 42;
    byte_100FA417[v11] = 0;
  }
  v19 = off_10045280[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_100F9818[v11];
  v27 = &byte_100F9C18[v11];
  v13 = off_10045278[a1];
  v23 = off_10045270[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10014E50();
  sub_1000B680(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v14);
  return v16;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000CA20) --------------------------------------------------------
bool __cdecl sub_1000CA20(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10009270();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v20 = v20 == 0;
  sub_1000C230((int)&v34, (char *)&unk_10045568, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_100F9818[v12], 0x400u, &v34);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v21 = sub_1000C230((int)&v34, (char *)&unk_10045568, 3, 0xCu, a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v34, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v13 = &byte_100FA018[v12];
    v21 = sub_1000C230((int)&v34, (char *)&unk_10045568, 3, 0xCu, v10);
    _snprintf(&byte_100FA018[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v23 = off_10045280[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_100F9818[v12];
  v32 = v13;
  v17 = off_10045278[a1];
  v27 = off_10045270[v20 != 0];
  v28 = v17;
  v31 = &byte_100F9C18[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10014E50();
  sub_1000B680(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v18);
  return v20;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000CE70) --------------------------------------------------------
bool __cdecl sub_1000CE70(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10009270();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v25 = v25 == 0;
  sub_1000C230((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_100F9818[v20], 0x400u, &v40);
  byte_100F9C16[v20] = 42;
  byte_100F9C17[v20] = 0;
  v26 = sub_1000C230((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_100F9C18[v20], 0x400u, &v40, a7);
  byte_100FA016[v20] = 42;
  byte_100FA017[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_100FA018[v20];
    byte_100FA018[v20] = 0;
  }
  else
  {
    v21 = &byte_100FA018[v20];
    v26 = sub_1000C230((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_100FA018[v20], 0x400u, &v40, v28);
    byte_100FA416[v20] = 42;
    byte_100FA417[v20] = 0;
  }
  v29 = off_10045280[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_100F9818[v20];
  v37 = &byte_100F9C18[v20];
  v38 = v21;
  v22 = off_10045270[v25 != 0];
  v34 = off_10045278[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10014E50();
  sub_1000B680(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v23);
  return v25;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000D330) --------------------------------------------------------
bool __cdecl sub_1000D330(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_100455AC;
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000D6F0) --------------------------------------------------------
bool __cdecl sub_1000D6F0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v13 = &byte_100FA018[v12];
    v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F9818[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045278[a1];
  v24 = off_10045270[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000DAF0) --------------------------------------------------------
bool __cdecl sub_1000DAF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000DEB0) --------------------------------------------------------
bool __cdecl sub_1000DEB0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10009270();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_1000A1D0() )
        v18 = v18 == 0;
      sub_1000C230((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_100F9818[3072 * v21], 0x400u, &v33, a6);
      byte_100F9C16[v13] = 42;
      byte_100F9C17[v13] = 0;
      v19 = sub_1000C230((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_100F9C18[3072 * v21], 0x400u, &v33, a7);
      byte_100FA016[v13] = 42;
      byte_100FA017[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_100FA018[v13];
        byte_100FA018[v13] = 0;
      }
      else
      {
        v19 = sub_1000C230((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_100FA018[v13];
        _snprintf(&byte_100FA018[v13], 0x400u, &v33, a8);
        byte_100FA416[v13] = 42;
        byte_100FA417[v13] = 0;
      }
      v22 = off_10045280[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_100F9818[3072 * v21];
      v30 = &byte_100F9C18[3072 * v21];
      v15 = off_10045278[a1];
      v26 = off_10045270[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10014E50();
      sub_1000B680(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1000B770(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10014E60(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000E3F0) --------------------------------------------------------
bool __cdecl sub_1000E3F0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v13 = &byte_100FA018[v12];
    v18 = sub_1000C230((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F9818[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045278[a1];
  v24 = off_10045270[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000E7D0) --------------------------------------------------------
bool __cdecl sub_1000E7D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000EB90) --------------------------------------------------------
bool __cdecl sub_1000EB90(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000EF30) --------------------------------------------------------
bool __cdecl sub_1000EF30(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v13 = &byte_100FA018[v12];
    v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F9818[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045278[a1];
  v24 = off_10045270[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000F330) --------------------------------------------------------
bool __cdecl sub_1000F330(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000F6D0) --------------------------------------------------------
bool __cdecl sub_1000F6D0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10009270();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_1000A1D0() )
        v19 = v19 == 0;
      sub_1000C230((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_100F9818[3072 * v22];
      _snprintf(&byte_100F9818[3072 * v22], 0x400u, &v35, a6);
      byte_100F9C16[v13] = 42;
      byte_100F9C17[v13] = 0;
      v20 = sub_1000C230((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_100F9C18[3072 * v22];
      _snprintf(&byte_100F9C18[v13], 0x400u, &v35, a7);
      byte_100FA016[v13] = 42;
      byte_100FA017[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_100FA018[v13];
        byte_100FA018[v13] = 0;
      }
      else
      {
        v20 = sub_1000C230((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_100FA018[v13];
        _snprintf(&byte_100FA018[v13], 0x400u, &v35, a8);
        byte_100FA416[v13] = 42;
        byte_100FA417[v13] = 0;
      }
      v24 = off_10045280[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_10045278[a1];
      v28 = off_10045270[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10014E50();
      sub_1000B680(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1000B770(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10014E60(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (1000FCB0) --------------------------------------------------------
bool __cdecl sub_1000FCB0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v13 = &byte_100FA018[v12];
    v18 = sub_1000C230((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F9818[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_100F9C18[v12];
  v29 = v13;
  v14 = off_10045278[a1];
  v24 = off_10045270[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (100100A0) --------------------------------------------------------
bool __cdecl sub_100100A0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10009270();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1000A1D0() )
    v17 = v17 == 0;
  sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F9818[v12], 0x400u, &v31, a6);
  byte_100F9C16[v12] = 42;
  byte_100F9C17[v12] = 0;
  v18 = sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F9C18[v12], 0x400u, &v31, a7);
  byte_100FA016[v12] = 42;
  byte_100FA017[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100FA018[v12];
    byte_100FA018[v12] = 0;
  }
  else
  {
    v18 = sub_1000C230((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100FA018[v12];
    _snprintf(&byte_100FA018[v12], 0x400u, &v31, a8);
    byte_100FA416[v12] = 42;
    byte_100FA417[v12] = 0;
  }
  v20 = off_10045280[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_10045270[v17 != 0];
  v25 = off_10045278[a1];
  v24 = v14;
  v27 = &byte_100F9818[v12];
  v28 = &byte_100F9C18[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10014E50();
  sub_1000B680(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1000B770(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10014E60(v15);
  return v17;
}
// 10007C40: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (10010440) --------------------------------------------------------
int sub_10010440()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10009270();
  sub_1000C190(1);
  sub_1000C520(-1);
  result = sub_1000C4B0(-1);
  dword_100FD418[v0] = 0;
  return result;
}
// 100FD418: using guessed type int dword_100FD418[];

//----- (10010470) --------------------------------------------------------
BOOL __usercall sub_10010470@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10009270();
  sub_10014E90((int)&v13);
  sub_10014E90((int)&v14);
  sub_10014E90((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10015AE0((int (__cdecl *)(unsigned int))sub_1000C410, v7, (int)&v13) )
  {
    if ( sub_10015AE0((int (__cdecl *)(unsigned int))sub_1000C410, a2, (int)&v14) )
    {
      v9 = sub_10015950(
             dword_100FF524[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1000C410,
             (void (__cdecl *)(_DWORD))sub_1000C430,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10015D80((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10014F60((void (__cdecl *)(_DWORD))sub_1000C430, (int)&v12);
  sub_10014F60((void (__cdecl *)(_DWORD))sub_1000C430, (int)&v13);
  sub_10014F60((void (__cdecl *)(_DWORD))sub_1000C430, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 100FF524: using guessed type int dword_100FF524[];

//----- (100105E0) --------------------------------------------------------
bool __usercall sub_100105E0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10009270();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_1000A1D0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1000EB90(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_1000A1D0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_100F9818[3072 * v24], 0x400u, "%s", v9);
  byte_100F9C16[v15] = 42;
  byte_100F9C17[v15] = 0;
  _snprintf(&byte_100F9C18[3072 * v24], 0x400u, "%s", v22);
  v16 = off_10045280[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_100FA016[v15] = 42;
  v17 = off_10045270[v14 != 0];
  v18 = off_10045278[a3];
  byte_100FA017[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_100F9818[3072 * v24];
  v34 = &byte_100F9C18[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10014E50();
  sub_1000B680(7, (int)&v26, v19);
  sub_10014E60(v20);
  return v14;
}
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];

//----- (10010850) --------------------------------------------------------
char __cdecl sub_10010850(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10009270();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_100FF524[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_10100B40[v10];
  sub_1000BF30(a3, 1, a6, 0x230u, &byte_10100B40[v10]);
  v27 = &byte_100FD440[v10];
  sub_1000BF30(a3, 2, a7, 0x230u, &byte_100FD440[v10]);
  v24 = &byte_100FEA20[v10];
  sub_1000BF30(a3, 3, a6, 0x230u, &byte_100FEA20[v10]);
  v26 = &byte_100FF538[v10];
  sub_1000BF30(a3, 4, a7, 0x230u, &byte_100FF538[v10]);
  _snprintf(&byte_10100028[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_10100028[v10];
  byte_10100257[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1000BF30(a3, 0, v25, 560 - (v11 - &byte_10100028[v10 + 1]), &byte_10100028[v10] + v11 - &byte_10100028[v10 + 1]);
  v13 = &byte_10100028[v10];
  byte_10100257[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_10100024[v10] + v13 - &byte_10100028[v10 + 1]) = 0;
  sub_1000BF30(a3, 1, (int)&byte_10100028[v10], 0x230u, &byte_100F8D28[v10]);
  sub_1000BF30(a3, 1, (int)&byte_10100028[v10], 0x230u, &byte_100FDF30[v10]);
  v15 = sub_10010470(v22, v27, v21, a2 == 1, (int)&byte_100F8D28[v10], (const char **)&v22);
  if ( sub_1000A1D0() )
    v15 = v15 == 0;
  v30 = off_10045280[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_10045278[a1];
  v34 = off_10045270[v15 != 0];
  v17 = dword_100FF524[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10014E50();
  sub_1000B680(7, (int)&v30, v18);
  sub_10014E60(v19);
  return v15;
}
// 10045270: using guessed type char *off_10045270[18];
// 10045278: using guessed type char *off_10045278[16];
// 10045280: using guessed type char *off_10045280[14];
// 100FF524: using guessed type int dword_100FF524[];

//----- (10010B50) --------------------------------------------------------
bool __cdecl sub_10010B50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1000D330(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10010C00) --------------------------------------------------------
bool __cdecl sub_10010C00(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_100105E0(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10010C40) --------------------------------------------------------
const char *__cdecl sub_10010C40(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (10010C80) --------------------------------------------------------
char __cdecl sub_10010C80(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10009270();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_10101638 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1000BEE0((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1000BA00((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1000BEE0((int)v6, 0);
      return v5;
    case 4:
      sub_1000B880((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1000BBB0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1000B870((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1000B270((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_10010C40((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1000BE90((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        if ( v48 )
          sub_1000BE90((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        if ( v48 )
          sub_1000BE90((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1000BE90((int)v6, v55);
              if ( v48 )
                sub_1000BE90((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1000BE90((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1000BE90((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1000BE90((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1000BAE0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1000B590((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1000B650((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1000B4A0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_100409DD;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_100409DD;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_100409DD;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_100409DD;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_100409DD;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_100409DD;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_100409DD;
          v10 = sub_1000B560((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_100409DD;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1000B2A0((const void **)a2, a3) )
      {
        dword_10101630 = 2;
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90((int)v6, "   Command Format:\r\n");
        sub_1000BE90(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1000BE90(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1000BE90(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1000BE90(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1000BE90((int)v6, "                                         strings depending upon the command\r\n");
        sub_1000BE90((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1000BE90(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1000BE90(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90((int)v6, "   Notes:\r\n");
        sub_1000BE90((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1000BE90(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1000BE90(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1000BE90((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1000BE90(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1000BE90((int)v6, "       without a test suite name.\r\n");
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90((int)v6, "   Examples:\r\n");
        sub_1000BE90(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1000BE90((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1000BE90(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1000BE90(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1000BE90(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1000BE90(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1000BE90(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1000BE90(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1000BE90((int)v6, (const char *)&word_100465A4);
        sub_1000BE90((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1000BE90(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1000B330((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, (const char *)&word_100465A4);
        return v5;
      }
      if ( sub_1000B300((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_10101630,
          &unk_100409DD,
          &v58,
          6 - dword_10101630,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
        return v5;
      }
      if ( sub_1000B360((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1000B390((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_10101630 += 2;
          return v5;
        }
        if ( sub_1000B3D0((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_10101630 < 2 )
            dword_10101630 = 0;
          else
            dword_10101630 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_10101630,
          &unk_100409DD,
          a2[2],
          6 - dword_10101630,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
        return v5;
      }
      if ( sub_1000B2D0((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_10101630,
          &unk_100409DD,
          a2[3],
          6 - dword_10101630,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1000B440((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
      }
      else if ( sub_1000B410((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_10010C40((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_10010C40((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1000BE90((int)v6, v55);
      }
      LOBYTE(v5) = sub_1000BB40((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1000BE10((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BE90((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100465A4: using guessed type __int16 word_100465A4;
// 10101630: using guessed type int dword_10101630;
// 10010C80: using guessed type char var_304[508];

//----- (10011A30) --------------------------------------------------------
signed int __cdecl sub_10011A30(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_10101638 + 580 * sub_10009270();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1000BA40(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10011AB0) --------------------------------------------------------
char **__cdecl sub_10011AB0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_10101638 + 580 * sub_10009270();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1000BC50((int)v1, a1, (int)".txt");
  return &off_10045970;
}
// 10045970: using guessed type char *off_10045970;

//----- (10011AF0) --------------------------------------------------------
int (**sub_10011AF0())()
{
  return off_10046660;
}
// 10046660: using guessed type int (*off_10046660[2])();

//----- (10011B00) --------------------------------------------------------
int (__cdecl *__cdecl sub_10011B00(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10009270();
  return sub_1000BE90((int)&unk_10102190 + 1812 * v1, a1);
}

//----- (10011B20) --------------------------------------------------------
const char *sub_10011B20()
{
  return "See version control for test execution date";
}

//----- (10011B30) --------------------------------------------------------
__int64 sub_10011B30()
{
  return 0i64;
}

//----- (10011B40) --------------------------------------------------------
const char *sub_10011B40()
{
  return "Not Available";
}

//----- (10011B50) --------------------------------------------------------
int __usercall sub_10011B50@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10011BA0) --------------------------------------------------------
signed int __cdecl sub_10011BA0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10009270();
  return sub_1000BA40(a1, a2, (int)&unk_10102190 + 1812 * v2);
}

//----- (10011CF0) --------------------------------------------------------
int __usercall sub_10011CF0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1001D770((int)&a2[151 * (*a2 + 1)], (int)sub_10011B00, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10011B30();
  v4 = sub_10014560("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1001DBC0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10014560("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1001DBC0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1001DBC0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1001DB40((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1001D9D0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10014560("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10009320(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1001DB40((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1001DB40((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1000BBB0(v3);
  sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1001DAC0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10014520(i, &v15, &v16); ++i )
  {
    sub_1001DB40((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1001DC10((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1001DAC0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1001DAC0((int)&a2[151 * (*a2 + 1)]);
  sub_1001DB40((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1001D9D0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10011CF0: using guessed type char var_103[253];

//----- (10012070) --------------------------------------------------------
char __cdecl sub_10012070(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10009270();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_10102190 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1000B5F0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10011B50(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1001DB40(v8, (int)"Req");
            sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1000B5C0(a2, a3) )
      {
        if ( sub_1000BD50((int)v5, 3, 1, 0) )
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1001DAC0(v12);
          sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1001D9D0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000B500(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1001DC10(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1000B620(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1001DC10(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000B590(a2, a3) )
      {
        if ( sub_1000BD50((int)v5, 3, 1, 0) )
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000BCC0((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1000B530(a2, a3) )
      {
        sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1001D9D0(v13, (int)"success", (unsigned __int8 *)"0");
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1001D9D0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000BD50((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1000B4D0(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1000BE00((int)v5) )
            sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1001DC10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1000BD50((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1000B880((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10011CF0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1000B870((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1001DC10(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1001DC10(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1001DC10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1000BE00((int)v5) )
        sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1000B470((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1001DA70((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1001DC10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1000B270((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1001DA20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1001DA20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1001DA20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_100409DD;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1001DB40(v19, (int)"Expected");
          sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1000BD50((int)v5, 8, 1, 0) )
        sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1000BAE0((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1000BB40((int)v5, (void (__cdecl *)(int))sub_10011BD0);
      return v4;
    case 0:
    case 11:
      sub_1000BEE0((int)v5, (void (__cdecl *)(int))sub_10011BD0);
      goto LABEL_139;
    case 1:
      sub_1000BA00((int)v5);
      goto LABEL_139;
    case 12:
      sub_1000BE10((int)v5, (void (__cdecl *)(int))sub_10011BD0);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1001DB40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1001D9D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1000BD50((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1001DAC0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10011BD0: using guessed type int sub_10011BD0();
// 10012070: using guessed type char var_104[255];

//----- (10012E90) --------------------------------------------------------
char **__cdecl sub_10012E90(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_10102190 + 1812 * sub_10009270();
  *((_DWORD *)v1 + 146) = 0;
  sub_1000BC50((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1001D770(v2, (int)sub_10011B00, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_10046710;
}
// 10046710: using guessed type char *off_10046710;

//----- (10012F00) --------------------------------------------------------
int sub_10012F00()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10022BB0(3012, &v2, 4, &v1);
  return v2;
}

//----- (10012F30) --------------------------------------------------------
char __cdecl sub_10012F30(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100238FE: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10012F50) --------------------------------------------------------
int __cdecl sub_10012F50(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_100072A0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_100072A0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023904: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10012FB0) --------------------------------------------------------
char __thiscall sub_10012FB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10012F50(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10012FD0) --------------------------------------------------------
int __thiscall sub_10012FD0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10012F50(46, (char *)&v2);
  return (int)v2;
}

//----- (10012FF0) --------------------------------------------------------
char sub_10012FF0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10022B60(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10012FF0: using guessed type int var_1C[7];

//----- (10013070) --------------------------------------------------------
int __cdecl sub_10013070(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1004A41C[a1];
  return result;
}
// 1004A41C: using guessed type __int16 word_1004A41C[];

//----- (10013090) --------------------------------------------------------
signed int __usercall sub_10013090@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100231D0((int)&off_1004A43C);
      break;
    case 0:
      result = sub_100231D0((int)&off_1004A450);
      break;
    case 1:
      result = sub_100231D0((int)&off_1004A464);
      break;
    case 2:
      result = sub_100231D0((int)&off_1004A48C);
      break;
    case 3:
      result = sub_100231D0((int)&off_1004A478);
      break;
    case 5:
      result = sub_100231D0((int)&off_1004A4A0);
      break;
    default:
      result = sub_100231D0(a2);
      break;
  }
  return result;
}
// 1004A43C: using guessed type char *off_1004A43C;
// 1004A450: using guessed type char *off_1004A450;
// 1004A464: using guessed type char *off_1004A464;
// 1004A478: using guessed type char *off_1004A478;
// 1004A48C: using guessed type char *off_1004A48C;
// 1004A4A0: using guessed type char *off_1004A4A0;

//----- (10013130) --------------------------------------------------------
int __usercall sub_10013130@<eax>(char a1@<al>)
{
  return sub_10022980(dword_10049F6C[a1]);
}
// 10049F6C: using guessed type int dword_10049F6C[];

//----- (10013150) --------------------------------------------------------
int __usercall sub_10013150@<eax>(char a1@<al>)
{
  return sub_100229A0(dword_10049F6C[a1], 10);
}
// 10049F6C: using guessed type int dword_10049F6C[];

//----- (10013170) --------------------------------------------------------
signed __int16 __usercall sub_10013170@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10013090(a1, a1) )
        {
          sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1016425C + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10013090(a1, a1) )
      {
        result = *(_WORD *)(dword_10164268 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10012F30(15000) )
        goto LABEL_6;
      sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013090(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_10164244 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013090(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1016426C + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013090(a1, a1) )
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_10164258 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10013090(a1, a1) )
        {
          result = *(_WORD *)(dword_10164248 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 10164244: using guessed type int dword_10164244;
// 10164248: using guessed type int dword_10164248;
// 10164258: using guessed type int dword_10164258;
// 1016425C: using guessed type int dword_1016425C;
// 10164268: using guessed type int dword_10164268;
// 1016426C: using guessed type int dword_1016426C;

//----- (100133B0) --------------------------------------------------------
char __cdecl sub_100133B0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10013170(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10013090(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1016425C + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10013090(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10164268 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10013090(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10164244 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10013090(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1016426C + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10013090(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10164258 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10013090(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10164248 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 10164244: using guessed type int dword_10164244;
// 10164248: using guessed type int dword_10164248;
// 10164258: using guessed type int dword_10164258;
// 1016425C: using guessed type int dword_1016425C;
// 10164268: using guessed type int dword_10164268;
// 1016426C: using guessed type int dword_1016426C;

//----- (10013530) --------------------------------------------------------
char __cdecl sub_10013530(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10013170(a1, a2);
  if ( v3 != -1 && !sub_10013150(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1016425C + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10164268 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10164244 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1016426C + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10164258 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10013090(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_10164248 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10013130(a1);
        return 1;
      default:
LABEL_17:
        sub_10013130(a1);
        break;
    }
  }
  return 0;
}
// 10164244: using guessed type int dword_10164244;
// 10164248: using guessed type int dword_10164248;
// 10164258: using guessed type int dword_10164258;
// 1016425C: using guessed type int dword_1016425C;
// 10164268: using guessed type int dword_10164268;
// 1016426C: using guessed type int dword_1016426C;

//----- (10013690) --------------------------------------------------------
char __cdecl sub_10013690(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10013090(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10013170(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_100133B0(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_100228F0();
      v13 = 0;
      LOBYTE(v7) = sub_1001E2F0(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (100137D0) --------------------------------------------------------
char __cdecl sub_100137D0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10013170(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1001E2F0(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (100138B0) --------------------------------------------------------
char __cdecl sub_100138B0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_100228F0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10013170(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1016425C + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1016425C + 210116;
          v12 = dword_1016425C + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_10164268 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_10164268 + 257156;
          v12 = dword_10164268 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_10164244 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_10164244 + 321708;
          v12 = dword_10164244 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1016426C + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1016426C + 326220;
          v12 = dword_1016426C + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_10164258 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_10164258 + 18832;
          v12 = dword_10164258 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10013090(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_10164248 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_10164248 + 1596;
          v12 = dword_10164248 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10013150(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10013130(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10164244: using guessed type int dword_10164244;
// 10164248: using guessed type int dword_10164248;
// 10164258: using guessed type int dword_10164258;
// 1016425C: using guessed type int dword_1016425C;
// 10164268: using guessed type int dword_10164268;
// 1016426C: using guessed type int dword_1016426C;

//----- (10013B30) --------------------------------------------------------
char __cdecl sub_10013B30(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_100138B0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10013B60) --------------------------------------------------------
char __cdecl sub_10013B60(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_100138B0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10013B90) --------------------------------------------------------
char __cdecl sub_10013B90(char a1, int a2, void *a3, int a4)
{
  return sub_100138B0(a1, a2, 0, 0, a3, a4);
}

//----- (10013BC0) --------------------------------------------------------
char __cdecl sub_10013BC0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10013C00) --------------------------------------------------------
int __cdecl sub_10013C00(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014380(&a1, 1u, (int)&unk_1004C150, 8, 67, 0);
  if ( v1 )
  {
    result = dword_1004C154[2 * v1];
  }
  else
  {
    sub_100072A0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 1004C154: using guessed type int dword_1004C154[];

//----- (10013C50) --------------------------------------------------------
signed int __cdecl sub_10013C50(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1004C4D0;
    v6 = &unk_1004C4D0;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_1004C4E8;
    v6 = &unk_1004C4E8;
    v5 = &a1;
  }
  v3 = sub_10014380(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10013CB0) --------------------------------------------------------
int __cdecl sub_10013CB0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014380(&a1, 1u, (int)&unk_1004C530, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1004C534[2 * v1];
  return result;
}
// 1004C534: using guessed type int dword_1004C534[];

//----- (10013CF0) --------------------------------------------------------
signed int __cdecl sub_10013CF0(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_1004C540;
    v7 = &unk_1004C540;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_1004C558;
    v7 = &unk_1004C558;
    v6 = &a1;
  }
  v4 = sub_10014380(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10013D60) --------------------------------------------------------
int __cdecl sub_10013D60(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014380(&a1, 1u, (int)&unk_1004C570, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1004C574[2 * v1];
  return result;
}
// 1004C574: using guessed type int dword_1004C574[];

//----- (10013DA0) --------------------------------------------------------
int __cdecl sub_10013DA0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014380(&a1, 1u, (int)&unk_1004C588, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1004C58C[2 * v1];
  return result;
}
// 1004C58C: using guessed type int dword_1004C58C[];

//----- (10013DE0) --------------------------------------------------------
char __cdecl sub_10013DE0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013C50(a1, 11);
  return sub_10022B20(v2, a2, 24);
}

//----- (10013E00) --------------------------------------------------------
char __cdecl sub_10013E00(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013CB0(a1);
  return sub_10022B20(v2, a2, 2720);
}

//----- (10013E30) --------------------------------------------------------
char __cdecl sub_10013E30(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10013CF0(a1, 11, 1);
  sub_10022B20(v2, a2, 36);
  v3 = sub_10013CF0(a1, 11, 0);
  return sub_10022B20(v3, a2 + 36, 32);
}

//----- (10013E80) --------------------------------------------------------
char __cdecl sub_10013E80(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013D60(a1);
  return sub_10022B20(v2, a2, 2192);
}

//----- (10013EB0) --------------------------------------------------------
char __cdecl sub_10013EB0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013DA0(a1);
  return sub_10022B20(v2, a2, 60);
}

//----- (10013ED0) --------------------------------------------------------
char __cdecl sub_10013ED0(int a1)
{
  return sub_10022B20(6453, a1, 5);
}

//----- (10013EF0) --------------------------------------------------------
char __cdecl sub_10013EF0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10013F30) --------------------------------------------------------
char __cdecl sub_10013F30(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_100072A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10013FA0) --------------------------------------------------------
signed int __cdecl sub_10013FA0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_100072A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10014020) --------------------------------------------------------
char __cdecl sub_10014020(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_100072A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10014090) --------------------------------------------------------
char __cdecl sub_10014090(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_100072A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10014140) --------------------------------------------------------
char __cdecl sub_10014140(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_100072A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10014240) --------------------------------------------------------
char __thiscall sub_10014240(void *this)
{
  int v1; // eax@1

  v1 = sub_10012FD0(this);
  return sub_10014140(v1);
}

//----- (10014250) --------------------------------------------------------
char __cdecl sub_10014250(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100091F0(11);
  }
  else
  {
    result = sub_100091F0(5);
  }
  return result;
}

//----- (10014280) --------------------------------------------------------
char sub_10014280()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10013B60(1, 1309, &v1) )
    sub_100215E0((int)&v1);
  return 0;
}

//----- (10014320) --------------------------------------------------------
BOOL __cdecl sub_10014320(int a1, int a2)
{
  return sub_10022B00(6455, a2, 252) == 0;
}

//----- (10014340) --------------------------------------------------------
char __cdecl sub_10014340(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10014320(a1, a5);
  }
  else
  {
    result = sub_10014280();
  }
  return result;
}

//----- (10014380) --------------------------------------------------------
int __cdecl sub_10014380(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10014510) --------------------------------------------------------
int __cdecl sub_10014510(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10014520) --------------------------------------------------------
char __cdecl sub_10014520(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10164280[592 * a1]) || byte_101642D0[v3]) )
  {
    *a2 = &byte_10164280[v3];
    *a3 = &byte_101642D0[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10014560) --------------------------------------------------------
char *__cdecl sub_10014560(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10164280;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_101642D0[592 * v2];
}

//----- (100145D0) --------------------------------------------------------
char *__usercall sub_100145D0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10014600) --------------------------------------------------------
void __cdecl sub_10014600(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10014560(v2 + 3, (int)&unk_100409DD);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10014600(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (100146C0) --------------------------------------------------------
void __cdecl sub_100146C0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10164278 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10164278;
    v4 = (char *)(&byte_10164280[592 * dword_10164278] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_101642D0[v3];
    v8 = (char *)(&byte_101642D0[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10014600(v7);
    ++dword_10164278;
  }
}
// 10164278: using guessed type int dword_10164278;

//----- (10014720) --------------------------------------------------------
void *__cdecl sub_10014720(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10164280, 0, 0x73A0u);
  dword_10164278 = 0;
  if ( a1 )
  {
    v2 = sub_10014BF0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10014DD0((int)&v11, 512, v2) )
      {
        do
        {
          sub_100145D0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_100146C0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_100146C0(&v11, v4 + 1);
          }
        }
        while ( sub_10014DD0((int)&v11, 512, v3) );
      }
      result = (void *)sub_10014BA0(v3);
    }
    else
    {
      result = (void *)sub_1000B7F0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10164278: using guessed type int dword_10164278;

//----- (100148B0) --------------------------------------------------------
int __cdecl sub_100148B0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10022020: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10022030: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10022040: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10022050: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10022110: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (100149F0) --------------------------------------------------------
char __usercall sub_100149F0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10014AC0) --------------------------------------------------------
signed int __cdecl sub_10014AC0(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10022070(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_100149F0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_100148B0(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10022120: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10014BA0) --------------------------------------------------------
BOOL __cdecl sub_10014BA0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10022300(a1) == 0;
}
// 100222F0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10014BC0) --------------------------------------------------------
BOOL __cdecl sub_10014BC0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 10022360: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10014BF0) --------------------------------------------------------
unsigned int __cdecl sub_10014BF0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10014C50) --------------------------------------------------------
signed int __cdecl sub_10014C50(void *a1, int a2, unsigned int a3)
{
  return sub_10022440(a3, a1, a2);
}

//----- (10014C70) --------------------------------------------------------
int __cdecl sub_10014C70(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10022700: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10014C90) --------------------------------------------------------
char __cdecl sub_10014C90(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10014BF0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10014BF0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10014C50(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10014C70((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10014C50(&v8, 512, v3);
        }
        v2 = i;
        sub_10014BA0(v4);
      }
      sub_10014BA0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10014DD0) --------------------------------------------------------
int __cdecl sub_10014DD0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10014C50(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10014E50) --------------------------------------------------------
int sub_10014E50()
{
  return 0;
}

//----- (10014E60) --------------------------------------------------------
void __cdecl sub_10014E60(int a1)
{
  if ( a1 > 0 )
    exit(14);
}

//----- (10014E90) --------------------------------------------------------
int __cdecl sub_10014E90(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10014EB0) --------------------------------------------------------
bool __cdecl sub_10014EB0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10014EE0) --------------------------------------------------------
void *__cdecl sub_10014EE0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10014F20) --------------------------------------------------------
unsigned int __usercall sub_10014F20@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10014F40) --------------------------------------------------------
int __usercall sub_10014F40@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10014F60) --------------------------------------------------------
char __cdecl sub_10014F60(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10014EB0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10014E90(a2);
  }
  return result;
}

//----- (10014F90) --------------------------------------------------------
signed int __cdecl sub_10014F90(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10014F20(v5, v7, v9);
          v11 = (_BYTE *)sub_10014F20(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10014F20(a4, v7, v9);
            sub_10014F40(v16, (int)&unk_1004EC44);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10015070) --------------------------------------------------------
void __cdecl sub_10015070(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10014F20((int)v3, v4, v6);
          v8 = sub_10014F20(a2, v4, v6);
          v9 = sub_10014F20(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10015120) --------------------------------------------------------
void *__usercall sub_10015120@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10014F20(a1, v31, v4);
      v6 = sub_10014F20(a2, 0, 0);
      sub_10014F40(v5, v6);
      v7 = sub_10014F20(a1, v33, v4);
      v8 = sub_10014F20(a2, *(_DWORD *)a2 - 1, 0);
      sub_10014F40(v7, v8);
      v9 = sub_10014F20(a1, v31, v34 - v4 - 1);
      v10 = sub_10014F20(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10014F40(v9, v10);
      v11 = sub_10014F20(a1, v33, v34 - v4 - 1);
      v12 = sub_10014F20(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10014F40(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10014F20(a2, 0, 1);
    v16 = (void *)sub_10014F20(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10014F20(a1, a3 + i, v18);
      v20 = sub_10014F20(a2, i, 0);
      sub_10014F40(v19, v20);
      v21 = sub_10014F20(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10014F20(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10014F40(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10014F20(a2, i, 1);
    v25 = (void *)sub_10014F20(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10014F20(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10014F20(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100153A0) --------------------------------------------------------
void __cdecl sub_100153A0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10014F20(a1, v2, v4);
          v6 = sub_10014F20(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10015470) --------------------------------------------------------
char __cdecl sub_10015470(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10014EB0(a1);
  if ( result )
  {
    result = sub_10014EB0(a4);
    if ( result )
    {
      sub_10014F60(a3, a4);
      sub_10014EE0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (100154E0) --------------------------------------------------------
int __usercall sub_100154E0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10014EE0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10015120((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10014F20((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10014F20(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10014F60((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10015470(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10015840) --------------------------------------------------------
int __usercall sub_10015840@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10014EE0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10015070(v8, a3, (int)&v16);
  sub_10014EE0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_100154E0(9u, v7, (int)&v16, (int)&unk_1004EC20, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10014F20((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10014F20(a6, v9, v11);
            sub_10014F40(v13, (int)&unk_1004EC44);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10014F60(a5, (int)&v15);
  sub_10014F60(a5, (int)&v16);
  return v10;
}

//----- (10015950) --------------------------------------------------------
int __cdecl sub_10015950(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10014EE0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100153A0(a3, a8);
  if ( a1 )
    result = sub_10015840(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10014F90((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10015AE0) --------------------------------------------------------
char __cdecl sub_10015AE0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10014BF0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10014C50(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10014C50(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10014EE0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10014C50(v6, v7, v12) == v7 && (!v9 || sub_10014C50(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10014BA0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015C30) --------------------------------------------------------
char __usercall sub_10015C30@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10014BF0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10014C70((int)&v14, 14, v9) == 14 && sub_10014C70((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10014C70(v12, v6, v10) == v6 && (!v7 || sub_10014C70((int)&unk_1004EDE8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10014BA0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10014BA0(v10);
  }
  return v30;
}

//----- (10015D80) --------------------------------------------------------
char __cdecl sub_10015D80(int a1, int a2)
{
  char result; // al@2

  if ( sub_10014EB0(a1) )
    result = sub_10015C30(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10015DC0) --------------------------------------------------------
signed int __cdecl sub_10015DC0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_1016B621 = 1;
    byte_1016B620 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1016B620 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1016B621 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;
// 1016B621: using guessed type char byte_1016B621;

//----- (10015E20) --------------------------------------------------------
bool __cdecl sub_10015E20(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1000B740(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100669E0, (int)"failing_subroutine( depth-1 )");
    sub_10015E20(a1 - 1);
    exit(14);
  }
  return sub_10010C00(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10015E90) --------------------------------------------------------
int sub_10015E90()
{
  const char *v0; // eax@1

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_1016B620 )
  {
    sub_10010C00(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1000B740(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10015E20(1);
    exit(14);
  }
  return sub_1000B770(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 1016B620: using guessed type char byte_1016B620;

//----- (100161B0) --------------------------------------------------------
char sub_100161B0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016B620 )
  {
    v2 = 0;
    do
    {
      if ( off_1004FA54[v2] )
      {
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1004FA5C[v2 * 4], 0x100u, &v11);
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1004FA54[v2], 0x100u, &v12);
        sub_10014C90(&v12, &v11);
      }
      if ( byte_1004FA50[v2 * 4] )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_1004FA58[v2];
        v4 = *(char **)&off_1004FA5C[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1004FA5C[v2 * 4],
               off_1004FA58[v2]);
        v6 = sub_10010850(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000C530(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_1004FA58[v2];
        v8 = *(char **)&off_1004FA5C[v2 * 4];
        v9 = sub_1000C1D0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1004FA5C[v2 * 4],
               off_1004FA58[v2]);
        v10 = sub_10010850(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000C530(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1004FA54: using guessed type char *off_1004FA54[3];
// 1004FA58: using guessed type char *off_1004FA58[2];
// 1016B620: using guessed type char byte_1016B620;

//----- (100163D0) --------------------------------------------------------
char sub_100163D0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016B620 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1000C530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1000C530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1000C530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1000C530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000C530(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (100165D0) --------------------------------------------------------
char sub_100165D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1004FAE4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_1004FAE1[v2 * 4];
        v4 = byte_1004FAE0[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + dword_1004FAE4[v2])],
               (&off_1004FAE8)[v2 * 4]);
        v6 = sub_1000C670(
               0,
               *(&dword_1004FA34 + dword_1004FAE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000C1D0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1004FAE4[v2]],
               (&off_1004FAE8)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1004FAE4: using guessed type int dword_1004FAE4[];
// 1004FAE8: using guessed type char *off_1004FAE8;
// 1016B620: using guessed type char byte_1016B620;

//----- (10016750) --------------------------------------------------------
char sub_10016750()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1004FD68[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1004FD60[v2 / 8];
        v4 = dbl_1004FD58[v2 / 8];
        v5 = dbl_1004FD50[v2 / 8];
        v6 = sub_1000C1D0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1004FD6C[v2]);
        v7 = sub_1000CA20(
               0,
               *(&dword_1004FA34 + dword_1004FD68[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1004FD68[v2 / 4]],
               *(_DWORD *)&off_1004FD6C[v2]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1004FD50: using guessed type double dbl_1004FD50[];
// 1004FD58: using guessed type double dbl_1004FD58[];
// 1004FD60: using guessed type double dbl_1004FD60[];
// 1004FD68: using guessed type int dword_1004FD68[];
// 1016B620: using guessed type char byte_1016B620;

//----- (100168D0) --------------------------------------------------------
char sub_100168D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005097C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10050978[v2];
        v4 = flt_10050974[v2];
        v5 = flt_10050970[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10050980)[v2 * 4]);
        v7 = sub_1000CE70(
               0,
               *(&dword_1004FA34 + dword_1005097C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005097C[v2]],
               (&off_10050980)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10050970: using guessed type float flt_10050970[];
// 10050974: using guessed type float flt_10050974[];
// 10050978: using guessed type float flt_10050978[];
// 1005097C: using guessed type int dword_1005097C[];
// 10050980: using guessed type char *off_10050980;
// 1016B620: using guessed type char byte_1016B620;

//----- (10016A40) --------------------------------------------------------
char sub_10016A40()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016B620 )
  {
    sub_10010B50(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10016A40,
      (int)sub_10016A40,
      (int)"This test is expected to fail");
    sub_10010B50(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10016A40,
      0,
      (int)"This test is expected to fail");
    result = sub_10010B50(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10016A40,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (10016B40) --------------------------------------------------------
char sub_10016B40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10051124[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10051120[v2];
        v4 = dword_1005111C[v2];
        v5 = dword_10051118[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10051128[v2 * 4]);
        v7 = sub_1000D330(
               0,
               *(&dword_1004FA34 + dword_10051124[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10051124[v2]],
               *(_DWORD *)&off_10051128[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10051118: using guessed type int dword_10051118[];
// 1005111C: using guessed type int dword_1005111C[];
// 10051120: using guessed type int dword_10051120[];
// 10051124: using guessed type int dword_10051124[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10016CA0) --------------------------------------------------------
char sub_10016CA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_100518B8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100518B4[v2 / 2];
        v4 = word_100518B2[v2 / 2];
        v5 = word_100518B0[v2 / 2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_100518BC[v2]);
        v7 = sub_1000D6F0(
               0,
               *(&dword_1004FA34 + dword_100518B8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_100518B8[v2 / 4]],
               *(_DWORD *)&off_100518BC[v2]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100518B0: using guessed type __int16 word_100518B0[];
// 100518B2: using guessed type __int16 word_100518B2[];
// 100518B4: using guessed type __int16 word_100518B4[];
// 100518B8: using guessed type int dword_100518B8[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10016E00) --------------------------------------------------------
char sub_10016E00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10051ECC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10051EC8[v2];
        v4 = dword_10051EC4[v2];
        v5 = dword_10051EC0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10051ED0)[v2 * 4]);
        v7 = sub_1000DAF0(
               0,
               *(&dword_1004FA34 + dword_10051ECC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10051ECC[v2]],
               (&off_10051ED0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10051EC0: using guessed type int dword_10051EC0[];
// 10051EC4: using guessed type int dword_10051EC4[];
// 10051EC8: using guessed type int dword_10051EC8[];
// 10051ECC: using guessed type int dword_10051ECC[];
// 10051ED0: using guessed type char *off_10051ED0;
// 1016B620: using guessed type char byte_1016B620;

//----- (10016F60) --------------------------------------------------------
char sub_10016F60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10052670[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1005266C[v2];
        LODWORD(v3) = dword_10052668[v2];
        HIDWORD(v4) = dword_10052664[v2];
        LODWORD(v4) = dword_10052660[v2];
        HIDWORD(v5) = dword_1005265C[v2];
        LODWORD(v5) = dword_10052658[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10052674[v2 * 4]);
        v7 = sub_1000DEB0(
               0,
               *(&dword_1004FA34 + dword_10052670[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10052670[v2]],
               *(_DWORD *)&off_10052674[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10052658: using guessed type int dword_10052658[];
// 1005265C: using guessed type int dword_1005265C[];
// 10052660: using guessed type int dword_10052660[];
// 10052664: using guessed type int dword_10052664[];
// 10052668: using guessed type int dword_10052668[];
// 1005266C: using guessed type int dword_1005266C[];
// 10052670: using guessed type int dword_10052670[];
// 1016B620: using guessed type char byte_1016B620;

//----- (100170D0) --------------------------------------------------------
char sub_100170D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005327C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1005327A[v2 * 4];
        v4 = byte_10053279[v2 * 4];
        v5 = byte_10053278[v2 * 4];
        v6 = sub_1000C1D0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10053280)[v2 * 4]);
        v7 = sub_1000E3F0(
               0,
               *(&dword_1004FA34 + dword_1005327C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005327C[v2]],
               (&off_10053280)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1005327C: using guessed type int dword_1005327C[];
// 10053280: using guessed type char *off_10053280;
// 1016B620: using guessed type char byte_1016B620;

//----- (10017230) --------------------------------------------------------
char sub_10017230()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10053714[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10053710[v2];
        v4 = dword_1005370C[v2];
        v5 = dword_10053708[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10053718[v2 * 4]);
        v7 = sub_1000E7D0(
               0,
               *(&dword_1004FA34 + dword_10053714[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10053714[v2]],
               *(_DWORD *)&off_10053718[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10053708: using guessed type int dword_10053708[];
// 1005370C: using guessed type int dword_1005370C[];
// 10053710: using guessed type int dword_10053710[];
// 10053714: using guessed type int dword_10053714[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10017390) --------------------------------------------------------
char sub_10017390()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016B620 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10010C00(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100409DD,
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10010C00(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100409DD,
           "a",
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10010C00(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100409DD,
           (const char *)&unk_100409DD,
           (int)"This test is expected to fail");
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10010C00(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1000C530(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (100175B0) --------------------------------------------------------
char sub_100175B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10053EAC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10053EA8[v2];
        v4 = dword_10053EA4[v2];
        v5 = dword_10053EA0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10053EB0)[v2 * 4]);
        v7 = sub_1000EB90(
               0,
               *(&dword_1004FA34 + dword_10053EAC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10053EAC[v2]],
               (&off_10053EB0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10053EA0: using guessed type int dword_10053EA0[];
// 10053EA4: using guessed type int dword_10053EA4[];
// 10053EA8: using guessed type int dword_10053EA8[];
// 10053EAC: using guessed type int dword_10053EAC[];
// 10053EB0: using guessed type char *off_10053EB0;
// 1016B620: using guessed type char byte_1016B620;

//----- (10017710) --------------------------------------------------------
char sub_10017710()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10054218[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10054214[v2 / 2];
        v4 = word_10054212[v2 / 2];
        v5 = word_10054210[v2 / 2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1005421C[v2]);
        v7 = sub_1000EF30(
               0,
               *(&dword_1004FA34 + dword_10054218[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10054218[v2 / 4]],
               *(_DWORD *)&off_1005421C[v2]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10054210: using guessed type __int16 word_10054210[];
// 10054212: using guessed type __int16 word_10054212[];
// 10054214: using guessed type __int16 word_10054214[];
// 10054218: using guessed type int dword_10054218[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10017870) --------------------------------------------------------
char sub_10017870()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_100544DC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100544D8[v2];
        v4 = dword_100544D4[v2];
        v5 = dword_100544D0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_100544E0)[v2 * 4]);
        v7 = sub_1000F330(
               0,
               *(&dword_1004FA34 + dword_100544DC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_100544DC[v2]],
               (&off_100544E0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100544D0: using guessed type int dword_100544D0[];
// 100544D4: using guessed type int dword_100544D4[];
// 100544D8: using guessed type int dword_100544D8[];
// 100544DC: using guessed type int dword_100544DC[];
// 100544E0: using guessed type char *off_100544E0;
// 1016B620: using guessed type char byte_1016B620;

//----- (100179D0) --------------------------------------------------------
char sub_100179D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10054858[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10054854[v2];
        LODWORD(v3) = dword_10054850[v2];
        HIDWORD(v4) = dword_1005484C[v2];
        LODWORD(v4) = dword_10054848[v2];
        HIDWORD(v5) = dword_10054844[v2];
        LODWORD(v5) = dword_10054840[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1005485C[v2 * 4]);
        v7 = sub_1000F6D0(
               0,
               *(&dword_1004FA34 + dword_10054858[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10054858[v2]],
               *(_DWORD *)&off_1005485C[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10054840: using guessed type int dword_10054840[];
// 10054844: using guessed type int dword_10054844[];
// 10054848: using guessed type int dword_10054848[];
// 1005484C: using guessed type int dword_1005484C[];
// 10054850: using guessed type int dword_10054850[];
// 10054854: using guessed type int dword_10054854[];
// 10054858: using guessed type int dword_10054858[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10017B40) --------------------------------------------------------
char sub_10017B40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10054DC4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10054DC2[v2 * 4];
        v4 = byte_10054DC1[v2 * 4];
        v5 = byte_10054DC0[v2 * 4];
        v6 = sub_1000C1D0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10054DC8)[v2 * 4]);
        v7 = sub_1000FCB0(
               0,
               *(&dword_1004FA34 + dword_10054DC4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10054DC4[v2]],
               (&off_10054DC8)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10054DC4: using guessed type int dword_10054DC4[];
// 10054DC8: using guessed type char *off_10054DC8;
// 1016B620: using guessed type char byte_1016B620;

//----- (10017CA0) --------------------------------------------------------
char sub_10017CA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10054FDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10054FD8[v2];
        v4 = dword_10054FD4[v2];
        v5 = dword_10054FD0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10054FE0)[v2 * 4]);
        v7 = sub_100100A0(
               0,
               *(&dword_1004FA34 + dword_10054FDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10054FDC[v2]],
               (&off_10054FE0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10054FD0: using guessed type int dword_10054FD0[];
// 10054FD4: using guessed type int dword_10054FD4[];
// 10054FD8: using guessed type int dword_10054FD8[];
// 10054FDC: using guessed type int dword_10054FDC[];
// 10054FE0: using guessed type char *off_10054FE0;
// 1016B620: using guessed type char byte_1016B620;

//----- (10017E00) --------------------------------------------------------
char sub_10017E00()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016B620 )
  {
    v2 = 0;
    do
    {
      if ( off_10055344[v2] )
      {
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1005534C[v2 * 4], 0x100u, &v11);
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10055344[v2], 0x100u, &v12);
        sub_10014C90(&v12, &v11);
      }
      if ( byte_10055340[v2 * 4] )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_10055348[v2];
        v4 = *(char **)&off_1005534C[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1005534C[v2 * 4],
               off_10055348[v2]);
        v6 = sub_10010850(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000C530(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_10055348[v2];
        v8 = *(char **)&off_1005534C[v2 * 4];
        v9 = sub_1000C1D0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1005534C[v2 * 4],
               off_10055348[v2]);
        v10 = sub_10010850(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000C530(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10055344: using guessed type char *off_10055344[3];
// 10055348: using guessed type char *off_10055348[2];
// 1016B620: using guessed type char byte_1016B620;

//----- (10018020) --------------------------------------------------------
char sub_10018020()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_1016B620 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1000C530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1000C530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1000C530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1000C530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000C530(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (10018220) --------------------------------------------------------
char sub_10018220()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_100553D4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100553D1[v2 * 4];
        v4 = byte_100553D0[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + dword_100553D4[v2])],
               (&off_100553D8)[v2 * 4]);
        v6 = sub_1000C670(
               1,
               *(&dword_1004FA34 + dword_100553D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000C1D0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_100553D4[v2]],
               (&off_100553D8)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100553D4: using guessed type int dword_100553D4[];
// 100553D8: using guessed type char *off_100553D8;
// 1016B620: using guessed type char byte_1016B620;

//----- (100183A0) --------------------------------------------------------
char sub_100183A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10055658[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10055650[v2 / 8];
        v4 = dbl_10055648[v2 / 8];
        v5 = dbl_10055640[v2 / 8];
        v6 = sub_1000C1D0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1005565C[v2]);
        v7 = sub_1000CA20(
               1,
               *(&dword_1004FA34 + dword_10055658[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10055658[v2 / 4]],
               *(_DWORD *)&off_1005565C[v2]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10055640: using guessed type double dbl_10055640[];
// 10055648: using guessed type double dbl_10055648[];
// 10055650: using guessed type double dbl_10055650[];
// 10055658: using guessed type int dword_10055658[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10018520) --------------------------------------------------------
char sub_10018520()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005626C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10056268[v2];
        v4 = flt_10056264[v2];
        v5 = flt_10056260[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10056270)[v2 * 4]);
        v7 = sub_1000CE70(
               1,
               *(&dword_1004FA34 + dword_1005626C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005626C[v2]],
               (&off_10056270)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10056260: using guessed type float flt_10056260[];
// 10056264: using guessed type float flt_10056264[];
// 10056268: using guessed type float flt_10056268[];
// 1005626C: using guessed type int dword_1005626C[];
// 10056270: using guessed type char *off_10056270;
// 1016B620: using guessed type char byte_1016B620;

//----- (10018690) --------------------------------------------------------
char sub_10018690()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016B620 )
  {
    sub_10010B50(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10018690,
      (int)sub_10018690,
      0);
    sub_10010B50(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10018690,
      0,
      0);
    result = sub_10010B50(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10018690,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (10018780) --------------------------------------------------------
char sub_10018780()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10056A04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10056A00[v2];
        v4 = dword_100569FC[v2];
        v5 = dword_100569F8[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10056A08[v2 * 4]);
        v7 = sub_1000D330(
               1,
               *(&dword_1004FA34 + dword_10056A04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10056A04[v2]],
               *(_DWORD *)&off_10056A08[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100569F8: using guessed type int dword_100569F8[];
// 100569FC: using guessed type int dword_100569FC[];
// 10056A00: using guessed type int dword_10056A00[];
// 10056A04: using guessed type int dword_10056A04[];
// 1016B620: using guessed type char byte_1016B620;

//----- (100188E0) --------------------------------------------------------
char sub_100188E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10057198[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10057194[v2 / 2];
        v4 = word_10057192[v2 / 2];
        v5 = word_10057190[v2 / 2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1005719C[v2]);
        v7 = sub_1000D6F0(
               1,
               *(&dword_1004FA34 + dword_10057198[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10057198[v2 / 4]],
               *(_DWORD *)&off_1005719C[v2]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10057190: using guessed type __int16 word_10057190[];
// 10057192: using guessed type __int16 word_10057192[];
// 10057194: using guessed type __int16 word_10057194[];
// 10057198: using guessed type int dword_10057198[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10018A40) --------------------------------------------------------
char sub_10018A40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_100577AC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100577A8[v2];
        v4 = dword_100577A4[v2];
        v5 = dword_100577A0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_100577B0)[v2 * 4]);
        v7 = sub_1000DAF0(
               1,
               *(&dword_1004FA34 + dword_100577AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_100577AC[v2]],
               (&off_100577B0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100577A0: using guessed type int dword_100577A0[];
// 100577A4: using guessed type int dword_100577A4[];
// 100577A8: using guessed type int dword_100577A8[];
// 100577AC: using guessed type int dword_100577AC[];
// 100577B0: using guessed type char *off_100577B0;
// 1016B620: using guessed type char byte_1016B620;

//----- (10018BA0) --------------------------------------------------------
char sub_10018BA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10057F50[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10057F4C[v2];
        LODWORD(v3) = dword_10057F48[v2];
        HIDWORD(v4) = dword_10057F44[v2];
        LODWORD(v4) = dword_10057F40[v2];
        HIDWORD(v5) = dword_10057F3C[v2];
        LODWORD(v5) = dword_10057F38[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10057F54[v2 * 4]);
        v7 = sub_1000DEB0(
               1,
               *(&dword_1004FA34 + dword_10057F50[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10057F50[v2]],
               *(_DWORD *)&off_10057F54[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10057F38: using guessed type int dword_10057F38[];
// 10057F3C: using guessed type int dword_10057F3C[];
// 10057F40: using guessed type int dword_10057F40[];
// 10057F44: using guessed type int dword_10057F44[];
// 10057F48: using guessed type int dword_10057F48[];
// 10057F4C: using guessed type int dword_10057F4C[];
// 10057F50: using guessed type int dword_10057F50[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10018D10) --------------------------------------------------------
char sub_10018D10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10058B5C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10058B5A[v2 * 4];
        v4 = byte_10058B59[v2 * 4];
        v5 = byte_10058B58[v2 * 4];
        v6 = sub_1000C1D0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10058B60)[v2 * 4]);
        v7 = sub_1000E3F0(
               1,
               *(&dword_1004FA34 + dword_10058B5C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10058B5C[v2]],
               (&off_10058B60)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10058B5C: using guessed type int dword_10058B5C[];
// 10058B60: using guessed type char *off_10058B60;
// 1016B620: using guessed type char byte_1016B620;

//----- (10018E70) --------------------------------------------------------
char sub_10018E70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10058FF4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10058FF0[v2];
        v4 = dword_10058FEC[v2];
        v5 = dword_10058FE8[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10058FF8[v2 * 4]);
        v7 = sub_1000E7D0(
               1,
               *(&dword_1004FA34 + dword_10058FF4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10058FF4[v2]],
               *(_DWORD *)&off_10058FF8[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10058FE8: using guessed type int dword_10058FE8[];
// 10058FEC: using guessed type int dword_10058FEC[];
// 10058FF0: using guessed type int dword_10058FF0[];
// 10058FF4: using guessed type int dword_10058FF4[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10018FD0) --------------------------------------------------------
char sub_10018FD0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016B620 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10010C00(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10010C00(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_100409DD,
           "a",
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10010C00(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100409DD,
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10010C00(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1000C530(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016B620: using guessed type char byte_1016B620;

//----- (100191D0) --------------------------------------------------------
char sub_100191D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005978C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10059788[v2];
        v4 = dword_10059784[v2];
        v5 = dword_10059780[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10059790)[v2 * 4]);
        v7 = sub_1000EB90(
               1,
               *(&dword_1004FA34 + dword_1005978C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005978C[v2]],
               (&off_10059790)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10059780: using guessed type int dword_10059780[];
// 10059784: using guessed type int dword_10059784[];
// 10059788: using guessed type int dword_10059788[];
// 1005978C: using guessed type int dword_1005978C[];
// 10059790: using guessed type char *off_10059790;
// 1016B620: using guessed type char byte_1016B620;

//----- (10019330) --------------------------------------------------------
char sub_10019330()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10059AF8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10059AF4[v2 / 2];
        v4 = word_10059AF2[v2 / 2];
        v5 = word_10059AF0[v2 / 2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_10059AFC[v2]);
        v7 = sub_1000EF30(
               1,
               *(&dword_1004FA34 + dword_10059AF8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10059AF8[v2 / 4]],
               *(_DWORD *)&off_10059AFC[v2]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10059AF0: using guessed type __int16 word_10059AF0[];
// 10059AF2: using guessed type __int16 word_10059AF2[];
// 10059AF4: using guessed type __int16 word_10059AF4[];
// 10059AF8: using guessed type int dword_10059AF8[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10019490) --------------------------------------------------------
char sub_10019490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10059DBC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10059DB8[v2];
        v4 = dword_10059DB4[v2];
        v5 = dword_10059DB0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_10059DC0)[v2 * 4]);
        v7 = sub_1000F330(
               1,
               *(&dword_1004FA34 + dword_10059DBC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10059DBC[v2]],
               (&off_10059DC0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10059DB0: using guessed type int dword_10059DB0[];
// 10059DB4: using guessed type int dword_10059DB4[];
// 10059DB8: using guessed type int dword_10059DB8[];
// 10059DBC: using guessed type int dword_10059DBC[];
// 10059DC0: using guessed type char *off_10059DC0;
// 1016B620: using guessed type char byte_1016B620;

//----- (100195F0) --------------------------------------------------------
char sub_100195F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005A138[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1005A134[v2];
        LODWORD(v3) = dword_1005A130[v2];
        HIDWORD(v4) = dword_1005A12C[v2];
        LODWORD(v4) = dword_1005A128[v2];
        HIDWORD(v5) = dword_1005A124[v2];
        LODWORD(v5) = dword_1005A120[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               *(_DWORD *)&off_1005A13C[v2 * 4]);
        v7 = sub_1000F6D0(
               1,
               *(&dword_1004FA34 + dword_1005A138[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005A138[v2]],
               *(_DWORD *)&off_1005A13C[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1005A120: using guessed type int dword_1005A120[];
// 1005A124: using guessed type int dword_1005A124[];
// 1005A128: using guessed type int dword_1005A128[];
// 1005A12C: using guessed type int dword_1005A12C[];
// 1005A130: using guessed type int dword_1005A130[];
// 1005A134: using guessed type int dword_1005A134[];
// 1005A138: using guessed type int dword_1005A138[];
// 1016B620: using guessed type char byte_1016B620;

//----- (10019760) --------------------------------------------------------
char sub_10019760()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005A6A4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1005A6A2[v2 * 4];
        v4 = byte_1005A6A1[v2 * 4];
        v5 = byte_1005A6A0[v2 * 4];
        v6 = sub_1000C1D0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_1005A6A8)[v2 * 4]);
        v7 = sub_1000FCB0(
               1,
               *(&dword_1004FA34 + dword_1005A6A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005A6A4[v2]],
               (&off_1005A6A8)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1005A6A4: using guessed type int dword_1005A6A4[];
// 1005A6A8: using guessed type char *off_1005A6A8;
// 1016B620: using guessed type char byte_1016B620;

//----- (100198C0) --------------------------------------------------------
char sub_100198C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016B620 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005A8BC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1005A8B8[v2];
        v4 = dword_1005A8B4[v2];
        v5 = dword_1005A8B0[v2];
        v6 = sub_1000C1D0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * *(&dword_1004FA34 + v0)],
               (&off_1005A8C0)[v2 * 4]);
        v7 = sub_100100A0(
               1,
               *(&dword_1004FA34 + dword_1005A8BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C1D0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005A8BC[v2]],
               (&off_1005A8C0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1005A8B0: using guessed type int dword_1005A8B0[];
// 1005A8B4: using guessed type int dword_1005A8B4[];
// 1005A8B8: using guessed type int dword_1005A8B8[];
// 1005A8BC: using guessed type int dword_1005A8BC[];
// 1005A8C0: using guessed type char *off_1005A8C0;
// 1016B620: using guessed type char byte_1016B620;

//----- (10019A20) --------------------------------------------------------
char sub_10019A20()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_1016B621 )
  {
    sub_10010C00(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1000B770(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1000D330(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_1000A1D0() )
      v1 = 3;
    sub_1000D330(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_1000A1D0();
    sub_1000D330(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1000B770(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1000D330(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (10019FC0) --------------------------------------------------------
char sub_10019FC0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016B621 )
  {
    v2 = 0;
    do
    {
      if ( off_1005AC24[v2] )
      {
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1005AC2C[v2 * 4], 0x100u, &v13);
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1005AC24[v2], 0x100u, &v14);
        sub_10014C90(&v14, &v13);
      }
      if ( byte_1005AC20[v2 * 4] )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_1005AC28[v2];
        v4 = *(char **)&off_1005AC2C[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1005AC2C[v2 * 4],
               off_1005AC28[v2]);
        v12 = 1;
        v11 = sub_10010850(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_1005AC28[v2];
        v7 = *(char **)&off_1005AC2C[v2 * 4];
        v8 = sub_1000C1D0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1005AC2C[v2 * 4],
               off_1005AC28[v2]);
        v12 = 1;
        v11 = sub_10010850(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005AC24: using guessed type char *off_1005AC24[3];
// 1005AC28: using guessed type char *off_1005AC28[2];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A1D0) --------------------------------------------------------
char sub_1001A1D0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016B621 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1000C530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1000C530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1000C530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1000C530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000C530(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A3C0) --------------------------------------------------------
char sub_1001A3C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_1005AC74[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_1005AC71[v2 * 4];
        v4 = byte_1005AC70[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * dword_1005AC74[v2]],
               (&off_1005AC78)[v2 * 4]);
        v6 = sub_1000C670(0, dword_1005AC74[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1000C1D0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_1005AC74[v2]],
               (&off_1005AC78)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1005AC74: using guessed type int dword_1005AC74[];
// 1005AC78: using guessed type char *off_1005AC78;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A530) --------------------------------------------------------
char sub_1001A530()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_1005AEF0[v2 / 2];
      v4 = dbl_1005AEE8[v2 / 2];
      v5 = dbl_1005AEE0[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005AEF8[v2]],
             *(_DWORD *)&off_1005AEFC[v2 * 4]);
      v7 = sub_1000CA20(0, dword_1005AEF8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005AEF8[v2]],
             *(_DWORD *)&off_1005AEFC[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005AEE0: using guessed type double dbl_1005AEE0[];
// 1005AEE8: using guessed type double dbl_1005AEE8[];
// 1005AEF0: using guessed type double dbl_1005AEF0[];
// 1005AEF8: using guessed type int dword_1005AEF8[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A6A0) --------------------------------------------------------
char sub_1001A6A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_1005BB08[v2];
      v4 = flt_1005BB04[v2];
      v5 = flt_1005BB00[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005BB0C[v2]],
             (&off_1005BB10)[v2 * 4]);
      v7 = sub_1000CE70(0, dword_1005BB0C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005BB0C[v2]],
             (&off_1005BB10)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005BB00: using guessed type float flt_1005BB00[];
// 1005BB04: using guessed type float flt_1005BB04[];
// 1005BB08: using guessed type float flt_1005BB08[];
// 1005BB0C: using guessed type int dword_1005BB0C[];
// 1005BB10: using guessed type char *off_1005BB10;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A800) --------------------------------------------------------
char sub_1001A800()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016B621 )
  {
    sub_10010B50(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1001A800,
      (int)sub_1001A800,
      0);
    sub_10010B50(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1001A800,
      0,
      0);
    result = sub_10010B50(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001A800,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001A8F0) --------------------------------------------------------
char sub_1001A8F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_1005C2A0[v2];
      v4 = dword_1005C29C[v2];
      v5 = dword_1005C298[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005C2A4[v2]],
             *(_DWORD *)&off_1005C2A8[v2 * 4]);
      v7 = sub_1000D330(0, dword_1005C2A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005C2A4[v2]],
             *(_DWORD *)&off_1005C2A8[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005C298: using guessed type int dword_1005C298[];
// 1005C29C: using guessed type int dword_1005C29C[];
// 1005C2A0: using guessed type int dword_1005C2A0[];
// 1005C2A4: using guessed type int dword_1005C2A4[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001AA50) --------------------------------------------------------
char sub_1001AA50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_1005CA34[v2 / 2];
      v4 = word_1005CA32[v2 / 2];
      v5 = word_1005CA30[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005CA38[v2 / 4]],
             *(_DWORD *)&off_1005CA3C[v2]);
      v7 = sub_1000D6F0(
             0,
             dword_1005CA38[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005CA38[v2 / 4]],
             *(_DWORD *)&off_1005CA3C[v2]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005CA30: using guessed type __int16 word_1005CA30[];
// 1005CA32: using guessed type __int16 word_1005CA32[];
// 1005CA34: using guessed type __int16 word_1005CA34[];
// 1005CA38: using guessed type int dword_1005CA38[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001ABB0) --------------------------------------------------------
char sub_1001ABB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_1005D048[v2];
      v4 = dword_1005D044[v2];
      v5 = dword_1005D040[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005D04C[v2]],
             (&off_1005D050)[v2 * 4]);
      v7 = sub_1000DAF0(0, dword_1005D04C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005D04C[v2]],
             (&off_1005D050)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005D040: using guessed type int dword_1005D040[];
// 1005D044: using guessed type int dword_1005D044[];
// 1005D048: using guessed type int dword_1005D048[];
// 1005D04C: using guessed type int dword_1005D04C[];
// 1005D050: using guessed type char *off_1005D050;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001AD10) --------------------------------------------------------
char sub_1001AD10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_1005D7EC[v2];
      LODWORD(v3) = dword_1005D7E8[v2];
      HIDWORD(v4) = dword_1005D7E4[v2];
      LODWORD(v4) = dword_1005D7E0[v2];
      HIDWORD(v5) = dword_1005D7DC[v2];
      LODWORD(v5) = dword_1005D7D8[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005D7F0[v2]],
             *(_DWORD *)&off_1005D7F4[v2 * 4]);
      v7 = sub_1000DEB0(0, dword_1005D7F0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005D7F0[v2]],
             *(_DWORD *)&off_1005D7F4[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005D7D8: using guessed type int dword_1005D7D8[];
// 1005D7DC: using guessed type int dword_1005D7DC[];
// 1005D7E0: using guessed type int dword_1005D7E0[];
// 1005D7E4: using guessed type int dword_1005D7E4[];
// 1005D7E8: using guessed type int dword_1005D7E8[];
// 1005D7EC: using guessed type int dword_1005D7EC[];
// 1005D7F0: using guessed type int dword_1005D7F0[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001AE80) --------------------------------------------------------
char sub_1001AE80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_1005E3FA[v2 * 4];
      v4 = byte_1005E3F9[v2 * 4];
      v5 = byte_1005E3F8[v2 * 4];
      v6 = sub_1000C1D0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005E3FC[v2]],
             (&off_1005E400)[v2 * 4]);
      v7 = sub_1000E3F0(0, dword_1005E3FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005E3FC[v2]],
             (&off_1005E400)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005E3FC: using guessed type int dword_1005E3FC[];
// 1005E400: using guessed type char *off_1005E400;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001AFE0) --------------------------------------------------------
char sub_1001AFE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_1005E890[v2];
      v4 = dword_1005E88C[v2];
      v5 = dword_1005E888[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005E894[v2]],
             *(_DWORD *)&off_1005E898[v2 * 4]);
      v7 = sub_1000E7D0(0, dword_1005E894[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005E894[v2]],
             *(_DWORD *)&off_1005E898[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005E888: using guessed type int dword_1005E888[];
// 1005E88C: using guessed type int dword_1005E88C[];
// 1005E890: using guessed type int dword_1005E890[];
// 1005E894: using guessed type int dword_1005E894[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B140) --------------------------------------------------------
char sub_1001B140()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016B621 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10010C00(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100409DD,
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10010C00(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10010C00(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10010C00(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000C530(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B340) --------------------------------------------------------
char sub_1001B340()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_1005F028[v2];
      v4 = dword_1005F024[v2];
      v5 = dword_1005F020[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F02C[v2]],
             (&off_1005F030)[v2 * 4]);
      v7 = sub_1000EB90(0, dword_1005F02C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F02C[v2]],
             (&off_1005F030)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005F020: using guessed type int dword_1005F020[];
// 1005F024: using guessed type int dword_1005F024[];
// 1005F028: using guessed type int dword_1005F028[];
// 1005F02C: using guessed type int dword_1005F02C[];
// 1005F030: using guessed type char *off_1005F030;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B4A0) --------------------------------------------------------
char sub_1001B4A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1005F394[v2 / 2];
      v4 = word_1005F392[v2 / 2];
      v5 = word_1005F390[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F398[v2 / 4]],
             *(_DWORD *)&off_1005F39C[v2]);
      v7 = sub_1000EF30(
             0,
             dword_1005F398[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F398[v2 / 4]],
             *(_DWORD *)&off_1005F39C[v2]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005F390: using guessed type __int16 word_1005F390[];
// 1005F392: using guessed type __int16 word_1005F392[];
// 1005F394: using guessed type __int16 word_1005F394[];
// 1005F398: using guessed type int dword_1005F398[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B600) --------------------------------------------------------
char sub_1001B600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_1005F658[v2];
      v4 = dword_1005F654[v2];
      v5 = dword_1005F650[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F65C[v2]],
             (&off_1005F660)[v2 * 4]);
      v7 = sub_1000F330(0, dword_1005F65C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F65C[v2]],
             (&off_1005F660)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005F650: using guessed type int dword_1005F650[];
// 1005F654: using guessed type int dword_1005F654[];
// 1005F658: using guessed type int dword_1005F658[];
// 1005F65C: using guessed type int dword_1005F65C[];
// 1005F660: using guessed type char *off_1005F660;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B760) --------------------------------------------------------
char sub_1001B760()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_1005F9D4[v2];
      LODWORD(v3) = dword_1005F9D0[v2];
      HIDWORD(v4) = dword_1005F9CC[v2];
      LODWORD(v4) = dword_1005F9C8[v2];
      HIDWORD(v5) = dword_1005F9C4[v2];
      LODWORD(v5) = dword_1005F9C0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F9D8[v2]],
             *(_DWORD *)&off_1005F9DC[v2 * 4]);
      v7 = sub_1000F6D0(0, dword_1005F9D8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005F9D8[v2]],
             *(_DWORD *)&off_1005F9DC[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005F9C0: using guessed type int dword_1005F9C0[];
// 1005F9C4: using guessed type int dword_1005F9C4[];
// 1005F9C8: using guessed type int dword_1005F9C8[];
// 1005F9CC: using guessed type int dword_1005F9CC[];
// 1005F9D0: using guessed type int dword_1005F9D0[];
// 1005F9D4: using guessed type int dword_1005F9D4[];
// 1005F9D8: using guessed type int dword_1005F9D8[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001B8D0) --------------------------------------------------------
char sub_1001B8D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_1005FF42[v2 * 4];
      v4 = byte_1005FF41[v2 * 4];
      v5 = byte_1005FF40[v2 * 4];
      v6 = sub_1000C1D0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1005FF44[v2]],
             (&off_1005FF48)[v2 * 4]);
      v7 = sub_1000FCB0(0, dword_1005FF44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1005FF44[v2]],
             (&off_1005FF48)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1005FF44: using guessed type int dword_1005FF44[];
// 1005FF48: using guessed type char *off_1005FF48;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001BA30) --------------------------------------------------------
char sub_1001BA30()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_10060158[v2];
      v4 = dword_10060154[v2];
      v5 = dword_10060150[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_1006015C[v2]],
             (&off_10060160)[v2 * 4]);
      v7 = sub_100100A0(0, dword_1006015C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_1006015C[v2]],
             (&off_10060160)[v2 * 4]);
      result = sub_1000C530(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10060150: using guessed type int dword_10060150[];
// 10060154: using guessed type int dword_10060154[];
// 10060158: using guessed type int dword_10060158[];
// 1006015C: using guessed type int dword_1006015C[];
// 10060160: using guessed type char *off_10060160;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001BB90) --------------------------------------------------------
char sub_1001BB90()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016B621 )
  {
    v2 = 0;
    do
    {
      if ( off_100604C4[v2] )
      {
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100604CC[v2 * 4], 0x100u, &v13);
        sub_1000BF30((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100604C4[v2], 0x100u, &v14);
        sub_10014C90(&v14, &v13);
      }
      if ( byte_100604C0[v2 * 4] )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100604C8[v2];
        v4 = *(char **)&off_100604CC[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100604CC[v2 * 4],
               off_100604C8[v2]);
        v12 = 1;
        v11 = sub_10010850(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100604C8[v2];
        v7 = *(char **)&off_100604CC[v2 * 4];
        v8 = sub_1000C1D0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100604CC[v2 * 4],
               off_100604C8[v2]);
        v12 = 1;
        v11 = sub_10010850(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100604C4: using guessed type char *off_100604C4[3];
// 100604C8: using guessed type char *off_100604C8[2];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001BDA0) --------------------------------------------------------
char sub_1001BDA0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016B621 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1000C530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1000C530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1000C530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1000C530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000C530(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001BF90) --------------------------------------------------------
char sub_1001BF90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      v0 = dword_10060514[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_10060511[v2 * 4];
        v4 = byte_10060510[v2 * 4];
        v5 = sub_1000C1D0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1004FA18[4 * dword_10060514[v2]],
               (&off_10060518)[v2 * 4]);
        v6 = sub_1000C670(1, dword_10060514[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1000C1D0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1004FA18[4 * dword_10060514[v2]],
               (&off_10060518)[v2 * 4]);
        LOBYTE(v0) = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B770(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10060514: using guessed type int dword_10060514[];
// 10060518: using guessed type char *off_10060518;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C100) --------------------------------------------------------
char sub_1001C100()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_10060790[v2 / 2];
      v4 = dbl_10060788[v2 / 2];
      v5 = dbl_10060780[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10060798[v2]],
             *(_DWORD *)&off_1006079C[v2 * 4]);
      v7 = sub_1000CA20(1, dword_10060798[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10060798[v2]],
             *(_DWORD *)&off_1006079C[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10060780: using guessed type double dbl_10060780[];
// 10060788: using guessed type double dbl_10060788[];
// 10060790: using guessed type double dbl_10060790[];
// 10060798: using guessed type int dword_10060798[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C270) --------------------------------------------------------
char sub_1001C270()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100613A8[v2];
      v4 = flt_100613A4[v2];
      v5 = flt_100613A0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100613AC[v2]],
             (&off_100613B0)[v2 * 4]);
      v7 = sub_1000CE70(1, dword_100613AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100613AC[v2]],
             (&off_100613B0)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100613A0: using guessed type float flt_100613A0[];
// 100613A4: using guessed type float flt_100613A4[];
// 100613A8: using guessed type float flt_100613A8[];
// 100613AC: using guessed type int dword_100613AC[];
// 100613B0: using guessed type char *off_100613B0;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C3D0) --------------------------------------------------------
char sub_1001C3D0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016B621 )
  {
    sub_10010B50(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1001C3D0,
      (int)sub_1001C3D0,
      0);
    sub_10010B50(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1001C3D0,
      0,
      0);
    result = sub_10010B50(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001C3D0,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C4C0) --------------------------------------------------------
char sub_1001C4C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_10061B40[v2];
      v4 = dword_10061B3C[v2];
      v5 = dword_10061B38[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10061B44[v2]],
             *(_DWORD *)&off_10061B48[v2 * 4]);
      v7 = sub_1000D330(1, dword_10061B44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10061B44[v2]],
             *(_DWORD *)&off_10061B48[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10061B38: using guessed type int dword_10061B38[];
// 10061B3C: using guessed type int dword_10061B3C[];
// 10061B40: using guessed type int dword_10061B40[];
// 10061B44: using guessed type int dword_10061B44[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C620) --------------------------------------------------------
char sub_1001C620()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100622D4[v2 / 2];
      v4 = word_100622D2[v2 / 2];
      v5 = word_100622D0[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100622D8[v2 / 4]],
             *(_DWORD *)&off_100622DC[v2]);
      v7 = sub_1000D6F0(
             1,
             dword_100622D8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100622D8[v2 / 4]],
             *(_DWORD *)&off_100622DC[v2]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100622D0: using guessed type __int16 word_100622D0[];
// 100622D2: using guessed type __int16 word_100622D2[];
// 100622D4: using guessed type __int16 word_100622D4[];
// 100622D8: using guessed type int dword_100622D8[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C780) --------------------------------------------------------
char sub_1001C780()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100628E8[v2];
      v4 = dword_100628E4[v2];
      v5 = dword_100628E0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100628EC[v2]],
             (&off_100628F0)[v2 * 4]);
      v7 = sub_1000DAF0(1, dword_100628EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100628EC[v2]],
             (&off_100628F0)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100628E0: using guessed type int dword_100628E0[];
// 100628E4: using guessed type int dword_100628E4[];
// 100628E8: using guessed type int dword_100628E8[];
// 100628EC: using guessed type int dword_100628EC[];
// 100628F0: using guessed type char *off_100628F0;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001C8E0) --------------------------------------------------------
char sub_1001C8E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_1006308C[v2];
      LODWORD(v3) = dword_10063088[v2];
      HIDWORD(v4) = dword_10063084[v2];
      LODWORD(v4) = dword_10063080[v2];
      HIDWORD(v5) = dword_1006307C[v2];
      LODWORD(v5) = dword_10063078[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10063090[v2]],
             *(_DWORD *)&off_10063094[v2 * 4]);
      v7 = sub_1000DEB0(1, dword_10063090[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10063090[v2]],
             *(_DWORD *)&off_10063094[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10063078: using guessed type int dword_10063078[];
// 1006307C: using guessed type int dword_1006307C[];
// 10063080: using guessed type int dword_10063080[];
// 10063084: using guessed type int dword_10063084[];
// 10063088: using guessed type int dword_10063088[];
// 1006308C: using guessed type int dword_1006308C[];
// 10063090: using guessed type int dword_10063090[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001CA50) --------------------------------------------------------
char sub_1001CA50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_10063C9A[v2 * 4];
      v4 = byte_10063C99[v2 * 4];
      v5 = byte_10063C98[v2 * 4];
      v6 = sub_1000C1D0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10063C9C[v2]],
             (&off_10063CA0)[v2 * 4]);
      v7 = sub_1000E3F0(1, dword_10063C9C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10063C9C[v2]],
             (&off_10063CA0)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10063C9C: using guessed type int dword_10063C9C[];
// 10063CA0: using guessed type char *off_10063CA0;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001CBB0) --------------------------------------------------------
char sub_1001CBB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_10064130[v2];
      v4 = dword_1006412C[v2];
      v5 = dword_10064128[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10064134[v2]],
             *(_DWORD *)&off_10064138[v2 * 4]);
      v7 = sub_1000E7D0(1, dword_10064134[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10064134[v2]],
             *(_DWORD *)&off_10064138[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10064128: using guessed type int dword_10064128[];
// 1006412C: using guessed type int dword_1006412C[];
// 10064130: using guessed type int dword_10064130[];
// 10064134: using guessed type int dword_10064134[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001CD10) --------------------------------------------------------
char sub_1001CD10()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B770(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000C0C0(0);
  sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1000B770(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016B621 )
  {
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10010C00(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_100409DD,
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10010C00(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10010C00(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_100409DD,
           0);
    sub_1000C530(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10010C00(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000C530(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016B621: using guessed type char byte_1016B621;

//----- (1001CF10) --------------------------------------------------------
char sub_1001CF10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100648C8[v2];
      v4 = dword_100648C4[v2];
      v5 = dword_100648C0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100648CC[v2]],
             (&off_100648D0)[v2 * 4]);
      v7 = sub_1000EB90(1, dword_100648CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100648CC[v2]],
             (&off_100648D0)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100648C0: using guessed type int dword_100648C0[];
// 100648C4: using guessed type int dword_100648C4[];
// 100648C8: using guessed type int dword_100648C8[];
// 100648CC: using guessed type int dword_100648CC[];
// 100648D0: using guessed type char *off_100648D0;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D070) --------------------------------------------------------
char sub_1001D070()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_10064C34[v2 / 2];
      v4 = word_10064C32[v2 / 2];
      v5 = word_10064C30[v2 / 2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10064C38[v2 / 4]],
             *(_DWORD *)&off_10064C3C[v2]);
      v7 = sub_1000EF30(
             1,
             dword_10064C38[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10064C38[v2 / 4]],
             *(_DWORD *)&off_10064C3C[v2]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10064C30: using guessed type __int16 word_10064C30[];
// 10064C32: using guessed type __int16 word_10064C32[];
// 10064C34: using guessed type __int16 word_10064C34[];
// 10064C38: using guessed type int dword_10064C38[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D1D0) --------------------------------------------------------
char sub_1001D1D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_10064EF8[v2];
      v4 = dword_10064EF4[v2];
      v5 = dword_10064EF0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10064EFC[v2]],
             (&off_10064F00)[v2 * 4]);
      v7 = sub_1000F330(1, dword_10064EFC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10064EFC[v2]],
             (&off_10064F00)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10064EF0: using guessed type int dword_10064EF0[];
// 10064EF4: using guessed type int dword_10064EF4[];
// 10064EF8: using guessed type int dword_10064EF8[];
// 10064EFC: using guessed type int dword_10064EFC[];
// 10064F00: using guessed type char *off_10064F00;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D330) --------------------------------------------------------
char sub_1001D330()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_10065274[v2];
      LODWORD(v3) = dword_10065270[v2];
      HIDWORD(v4) = dword_1006526C[v2];
      LODWORD(v4) = dword_10065268[v2];
      HIDWORD(v5) = dword_10065264[v2];
      LODWORD(v5) = dword_10065260[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_10065278[v2]],
             *(_DWORD *)&off_1006527C[v2 * 4]);
      v7 = sub_1000F6D0(1, dword_10065278[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_10065278[v2]],
             *(_DWORD *)&off_1006527C[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10065260: using guessed type int dword_10065260[];
// 10065264: using guessed type int dword_10065264[];
// 10065268: using guessed type int dword_10065268[];
// 1006526C: using guessed type int dword_1006526C[];
// 10065270: using guessed type int dword_10065270[];
// 10065274: using guessed type int dword_10065274[];
// 10065278: using guessed type int dword_10065278[];
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D4A0) --------------------------------------------------------
char sub_1001D4A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100657E2[v2 * 4];
      v4 = byte_100657E1[v2 * 4];
      v5 = byte_100657E0[v2 * 4];
      v6 = sub_1000C1D0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100657E4[v2]],
             (&off_100657E8)[v2 * 4]);
      v7 = sub_1000FCB0(1, dword_100657E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100657E4[v2]],
             (&off_100657E8)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100657E4: using guessed type int dword_100657E4[];
// 100657E8: using guessed type char *off_100657E8;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D600) --------------------------------------------------------
char sub_1001D600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016B621 )
  {
    sub_1000B770(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000C0C0(0);
    sub_1000B770(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1000B770(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C1B0(0);
    v2 = 0;
    do
    {
      sub_1000C0E0((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100659F8[v2];
      v4 = dword_100659F4[v2];
      v5 = dword_100659F0[v2];
      v6 = sub_1000C1D0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1004FA18[4 * dword_100659FC[v2]],
             (&off_10065A00)[v2 * 4]);
      v7 = sub_100100A0(1, dword_100659FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C1D0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1004FA18[4 * dword_100659FC[v2]],
             (&off_10065A00)[v2 * 4]);
      result = sub_1000C530(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B770(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100659F0: using guessed type int dword_100659F0[];
// 100659F4: using guessed type int dword_100659F4[];
// 100659F8: using guessed type int dword_100659F8[];
// 100659FC: using guessed type int dword_100659FC[];
// 10065A00: using guessed type char *off_10065A00;
// 1016B621: using guessed type char byte_1016B621;

//----- (1001D760) --------------------------------------------------------
char **sub_1001D760()
{
  return off_10051104;
}
// 10051104: using guessed type char *off_10051104[3];

//----- (1001D770) --------------------------------------------------------
int __cdecl sub_1001D770(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1001D790) --------------------------------------------------------
int (__cdecl *__usercall sub_1001D790@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1001D7A0) --------------------------------------------------------
int __usercall sub_1001D7A0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1001D9D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001D9D0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1001D790(a1, (int)" ");
  sub_1001D790(a1, a2);
  sub_1001D790(a1, (int)&unk_10069C54);
  v3 = sub_1001D7A0(a3, a1);
  sub_1001D790(a1, v3);
  return sub_1001D790(a1, (int)&unk_10069C50);
}

//----- (1001DA20) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DA20(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1001D790(a1, (int)" ");
  sub_1001D790(a1, a2);
  sub_1001D790(a1, (int)&unk_10069C5C);
  v3 = sub_1001D7A0(a3, a1);
  sub_1001D790(a1, v3);
  return sub_1001D790(a1, (int)&unk_10069C58);
}

//----- (1001DA70) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DA70(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1001D790(a1, (int)&unk_10069C60);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1001D7A0(a2, a1);
    result = sub_1001D790(a1, v3);
  }
  return result;
}

//----- (1001DAC0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DAC0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_10069C68;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1001D790(a1, dword_10069BBC[(signed int)result]);
      sub_1001D790(a1, (int)&unk_10069C64);
      sub_1001D790(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_10069C60;
    }
    result = sub_1001D790(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1001D790(a1, (int)&word_100465A4);
  }
  return result;
}
// 100465A4: using guessed type __int16 word_100465A4;
// 10069BBC: using guessed type int dword_10069BBC[];

//----- (1001DB40) --------------------------------------------------------
int __cdecl sub_1001DB40(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1001D790(a1, (int)&unk_10069C60);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1001D790(a1, *((_DWORD *)&off_10069BC0 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1001D790(a1, (int)&unk_10069C6C);
  sub_1001D790(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1001DBC0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DBC0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1001D7A0(a2, a1);
    sub_1001D790(a1, v3);
    result = sub_1001D790(a1, (int)&word_100465A4);
  }
  else
  {
    sub_1001D790(a1, (int)a2);
    result = sub_1001D790(a1, (int)&word_100465A4);
  }
  return result;
}
// 100465A4: using guessed type __int16 word_100465A4;

//----- (1001DC10) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DC10(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1001DB40(a1, a2);
  if ( a3 && *a3 )
    sub_1001DA70(a1, a3);
  return sub_1001DAC0(a1);
}

//----- (1001DC50) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001DC50(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1001DC10(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1001DCB0) --------------------------------------------------------
signed int __cdecl sub_1001DCB0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1001DD00) --------------------------------------------------------
int __cdecl sub_1001DD00(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001DDF0) --------------------------------------------------------
unsigned int __cdecl sub_1001DDF0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001DE40) --------------------------------------------------------
unsigned int __cdecl sub_1001DE40(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001DF00) --------------------------------------------------------
unsigned int __cdecl sub_1001DF00(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_100078B0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1001DF60) --------------------------------------------------------
int __cdecl sub_1001DF60(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001DFB0) --------------------------------------------------------
int __cdecl sub_1001DFB0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001E050) --------------------------------------------------------
int __cdecl sub_1001E050(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001E100) --------------------------------------------------------
int __cdecl sub_1001E100(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 100232A0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1001E170) --------------------------------------------------------
bool __cdecl sub_1001E170(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10014240(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_10084080[(unsigned __int8)v4](v3) )
    {
      sub_1001E100((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_1001E440(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10013070(2) )
    result = 0;
  else
    result = sub_10013B60(2, v5, a2) == 1 && !sub_100219D0(a2);
  return result;
}
// 10084080: using guessed type int (__cdecl *off_10084080[3])(char);

//----- (1001E230) --------------------------------------------------------
char __cdecl sub_1001E230(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1001E170(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_1001E420(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1001E2F0) --------------------------------------------------------
char __cdecl sub_1001E2F0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10014380((_DWORD *)a2, 2u, (int)&unk_10084640, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_10084644[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10022A00(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_100228B0();
        sub_10007A80(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_100072A0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 10084644: using guessed type int dword_10084644[];

//----- (1001E410) --------------------------------------------------------
signed int __fastcall sub_1001E410(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (1001E420) --------------------------------------------------------
char __cdecl sub_1001E420(unsigned __int8 a1)
{
  return byte_100848FC[6 * sub_1001E410(a1)];
}

//----- (1001E440) --------------------------------------------------------
__int16 __cdecl sub_1001E440(unsigned __int8 a1)
{
  return word_100848F8[3 * sub_1001E410(a1)];
}
// 100848F8: using guessed type __int16 word_100848F8[];

//----- (1001E460) --------------------------------------------------------
int __cdecl sub_1001E460(char a1)
{
  return sub_10014380(&a1, 1u, (int)&unk_10084D20, 8, 2, 2);
}

//----- (1001E480) --------------------------------------------------------
BOOL __cdecl sub_1001E480(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10013C00(a1);
  return sub_10013B60(0, 604, a2) && sub_10013530(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1001E4E0) --------------------------------------------------------
int __usercall sub_1001E4E0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1001E460(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_10084D24[2 * v1];
  return result;
}
// 10084D24: using guessed type int dword_10084D24[];

//----- (1001E510) --------------------------------------------------------
BOOL __cdecl sub_1001E510(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1001E4E0(a1);
  return sub_10022B00(v2, a2, 16) == 0;
}

//----- (1001E540) --------------------------------------------------------
int __cdecl sub_1001E540(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1001E510(a1, (int)a5);
  else
    result = sub_1001E480(a1, a5);
  return result;
}

//----- (1001E570) --------------------------------------------------------
char __cdecl sub_1001E570(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10013B90(1, 1947, a1, (int)&v3);
}

//----- (1001E590) --------------------------------------------------------
BOOL __cdecl sub_1001E590(int a1)
{
  return sub_10022B00(6792, a1, 284) == 0;
}

//----- (1001E5B0) --------------------------------------------------------
char __cdecl sub_1001E5B0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1001E590((int)a5);
  else
    result = sub_1001E570(a5);
  return result;
}

//----- (1001E5E0) --------------------------------------------------------
bool __cdecl sub_1001E5E0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10014380(&a2, 4u, (int)&dword_10085B98, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10022B00((unsigned __int16)word_10085B9C[a1 + 6 * v3], a3, (unsigned __int16)word_10085BA0[6 * v3]) == 0;
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 10085B98: using guessed type int dword_10085B98;
// 10085B9C: using guessed type __int16 word_10085B9C[];
// 10085BA0: using guessed type __int16 word_10085BA0[];

//----- (1001E670) --------------------------------------------------------
bool __cdecl sub_1001E670(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10021890(a1);
  v6 = sub_10014380(&a3, 1u, (int)&unk_10085BBC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10014380(&dword_10085BC0[2 * v6], 4u, (int)&dword_10085B98, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_10085BA0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1001E5E0(v11, *(int *)((char *)&dword_10085B98 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10085B98: using guessed type int dword_10085B98;
// 10085BA0: using guessed type __int16 word_10085BA0[];

//----- (1001E710) --------------------------------------------------------
bool __cdecl sub_1001E710(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10022B00((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1001E750) --------------------------------------------------------
signed int __usercall sub_1001E750@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1001E770) --------------------------------------------------------
bool __cdecl sub_1001E770(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1001E750(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10013530(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10013B90(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1001E710(a1, a2);
  }
  else
  {
    v9 = sub_10012FD0(v4);
    v8 = 1708;
    sub_10013690(1, 0, &v8, 0, 8, 1);
    sub_100137D0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10022C10: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10022C30: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1001E860) --------------------------------------------------------
bool __cdecl sub_1001E860(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1001E710(a1, a5);
  else
    result = sub_1001E770(a1, a5);
  return result;
}

//----- (1001E890) --------------------------------------------------------
BOOL __cdecl sub_1001E890(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1001E8A0) --------------------------------------------------------
BOOL __usercall sub_1001E8A0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1001E890(a1) && *v2 < 3u && a2 == 24;
}

//----- (1001E8D0) --------------------------------------------------------
bool __cdecl sub_1001E8D0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1001E890(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1001E230((unsigned __int8)byte_10086FD8[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10013B60(1, (unsigned __int16)word_10086FD0[v6], &Tm.tm_mon) || sub_100214A0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10021AE0(a1, &v15) || v15 != dword_10086FF0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10013B60(1, (unsigned __int16)word_10086FD4[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 10086FD0: using guessed type __int16 word_10086FD0[];
// 10086FD4: using guessed type __int16 word_10086FD4[];
// 10086FF0: using guessed type int dword_10086FF0[];

//----- (1001EA80) --------------------------------------------------------
bool __cdecl sub_1001EA80(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1001E890(a1) )
    result = sub_10022B00((unsigned __int16)word_10086FDA[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 10086FDA: using guessed type __int16 word_10086FDA[];

//----- (1001EAC0) --------------------------------------------------------
bool __cdecl sub_1001EAC0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10021A30(a1);
  if ( !(unsigned __int8)sub_1001E8A0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1001E8D0(v9, a3, *a4, (int)a5);
  if ( sub_1001E230((unsigned __int8)byte_10086FD8[20 * v6], (bool *)&v8) && v8 && sub_1001EA80(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1001EAC0: using guessed type int var_20[7];

//----- (1001EBB0) --------------------------------------------------------
char __cdecl sub_1001EBB0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_10177890, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10013E80(a1, (int)byte_10177890);
    v3 = 4 * a2 - 64;
    v4 = byte_10177891[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10177890[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1001EC50) --------------------------------------------------------
bool __cdecl sub_1001EC50(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_10177890, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10013E80(a1, (int)byte_10177890);
    v3 = (char *)&unk_10177930 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1001ECD0) --------------------------------------------------------
char __cdecl sub_1001ECD0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10177890, 0, 0x890u);
  sub_10013E80(a1, (int)byte_10177890);
  if ( a2 > 0x10u )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_10177C00[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10177C04[2 * a2];
    result = 1;
  }
  return result;
}
// 10177C00: using guessed type int dword_10177C00[];
// 10177C04: using guessed type int dword_10177C04[];

//----- (1001ED40) --------------------------------------------------------
char __cdecl sub_1001ED40(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10013B60(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10013B60(0, 572, a2);
    }
    else
    {
      sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10013B60(0, 226, a2);
  }
  return result;
}

//----- (1001EDC0) --------------------------------------------------------
char __cdecl sub_1001EDC0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_10177890, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1001ED40(a1, byte_10177890);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_10177891[v4];
    *(_BYTE *)a3 = byte_10177890[v4];
  }
  return result;
}

//----- (1001EE40) --------------------------------------------------------
char __cdecl sub_1001EE40(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_10177890, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1001ED40(a1, byte_10177890);
    v4 = (char *)&unk_10177930 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1001EEC0) --------------------------------------------------------
char __cdecl sub_1001EEC0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10177890, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1001ED40(a1, byte_10177890);
    *(_DWORD *)a3 = dword_10177C00[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10177C04[2 * a2];
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 10177C00: using guessed type int dword_10177C00[];
// 10177C04: using guessed type int dword_10177C04[];

//----- (1001EF30) --------------------------------------------------------
char __cdecl sub_1001EF30(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10021B30(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1001ECD0(v6, *a4, a5);
    else
      result = sub_1001EEC0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1001EBB0(v6, *a4, a5);
    else
      result = sub_1001EDC0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1001EC50(v6, *a4, a5);
    else
      result = sub_1001EE40(v6, *a4, a5);
  }
  return result;
}

//----- (1001F040) --------------------------------------------------------
char __cdecl sub_1001F040(char a1, void *a2)
{
  return sub_10013B60(6, (unsigned __int16)word_10087B1A[8 * (unsigned __int8)a1], a2);
}
// 10087B1A: using guessed type __int16 word_10087B1A[];

//----- (1001F060) --------------------------------------------------------
bool __cdecl sub_1001F060(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10022B00(dword_10087B20[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 10087B20: using guessed type int dword_10087B20[];

//----- (1001F0A0) --------------------------------------------------------
char __cdecl sub_1001F0A0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10021B70(a1);
  if ( a2 )
    result = sub_1001F060(v6, (char *)a5);
  else
    result = sub_1001F040(v6, a5);
  return result;
}

//----- (1001F0E0) --------------------------------------------------------
BOOL sub_1001F0E0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1001E170(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1001F140) --------------------------------------------------------
char __cdecl sub_1001F140(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10013B60(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1001F0E0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_100211D0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1001F230) --------------------------------------------------------
BOOL __cdecl sub_1001F230(int a1, int a2)
{
  return sub_10022B00(6200, a2, 60) == 0;
}

//----- (1001F250) --------------------------------------------------------
char __cdecl sub_1001F250(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1001F230(a1, (int)a5);
  }
  else
  {
    result = sub_1001F140(a1, a5);
  }
  return result;
}

//----- (1001F290) --------------------------------------------------------
char __cdecl sub_1001F290(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10013B60(2, 284, &v6) || sub_100213A0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1001F340) --------------------------------------------------------
BOOL __cdecl sub_1001F340(int a1, int a2)
{
  return sub_10022B00(6169, a2, 40) == 0;
}

//----- (1001F360) --------------------------------------------------------
char __cdecl sub_1001F360(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1001F340(a1, a5);
  }
  else
  {
    result = sub_1001F290(a1, a5);
  }
  return result;
}

//----- (1001F3A0) --------------------------------------------------------
char __cdecl sub_1001F3A0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10013B60(2, 363, a1);
}

//----- (1001F3C0) --------------------------------------------------------
char __cdecl sub_1001F3C0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10022B00(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1001F510) --------------------------------------------------------
char __cdecl sub_1001F510(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1001F3C0(a5);
      else
        result = sub_1001F3A0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1001F3C0(&unk_10178120);
      else
        v7 = sub_1001F3A0(&unk_10178120);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_10178120 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1001F3C0(&unk_10178120);
      else
        v9 = sub_1001F3A0(&unk_10178120);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_1017B028 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1001F3C0(&unk_10178120);
      else
        v11 = sub_1001F3A0(&unk_10178120);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_1017B528 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1001F3C0(&unk_10178120);
      else
        v13 = sub_1001F3A0(&unk_10178120);
      v14 = v13;
      memcpy_0(a5, &unk_1017B5D0, a6);
      result = v14;
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001F6B0) --------------------------------------------------------
char __cdecl sub_1001F6B0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1001F6F0) --------------------------------------------------------
__int16 __usercall sub_1001F6F0@<ax>(unsigned __int8 a1@<al>)
{
  return word_1008A6D0[a1];
}
// 1008A6D0: using guessed type __int16 word_1008A6D0[];

//----- (1001F700) --------------------------------------------------------
char __cdecl sub_1001F700(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1001F6F0(a1);
    if ( sub_10013B90(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1001F7D0) --------------------------------------------------------
char __cdecl sub_1001F7D0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1001F6B0(a1);
  if ( a3 != 11 )
  {
    sub_100072A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1001F700(v7, a5);
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1001F850) --------------------------------------------------------
char __cdecl sub_1001F850(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10021F10(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10021D10(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10021D90(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10021E10(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10021E90(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1001F960) --------------------------------------------------------
int __cdecl sub_1001F960(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014380(&a1, 1u, (int)&unk_1008AF08, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_1008AF0C[2 * v1];
  }
  return result;
}
// 1008AF0C: using guessed type int dword_1008AF0C[];

//----- (1001F9B0) --------------------------------------------------------
char __cdecl sub_1001F9B0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10013EB0(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10022B00(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10013ED0((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1001FB20) --------------------------------------------------------
int __usercall sub_1001FB20@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1001F9B0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1001FB20: using guessed type int var_2C[10];

//----- (1001FB60) --------------------------------------------------------
int __usercall sub_1001FB60@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1001F9B0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1001FB60: using guessed type int var_14[4];

//----- (1001FBA0) --------------------------------------------------------
signed int sub_1001FBA0()
{
  return sub_100231D0((int)&off_1008BDB8);
}
// 1008BDB8: using guessed type char *off_1008BDB8;

//----- (1001FBB0) --------------------------------------------------------
char __cdecl sub_1001FBB0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1001FBA0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1019D1CC);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1019D1CC: using guessed type int dword_1019D1CC;

//----- (1001FC10) --------------------------------------------------------
char __cdecl sub_1001FC10(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1001FBA0() )
  {
    if ( (sub_10014250(a1)
       || *(_BYTE *)(dword_1019D1CC + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1019D1CC + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1019D1CC + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 176))
      && *(_BYTE *)(dword_1019D1CC + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1019D1CC + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1019D1CC + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1019D1CC + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1019D1CC: using guessed type int dword_1019D1CC;

//----- (1001FD30) --------------------------------------------------------
char __cdecl sub_1001FD30(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1001FBA0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1019D1CC + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1019D1CC);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1019D1CC: using guessed type int dword_1019D1CC;

//----- (1001FDB0) --------------------------------------------------------
char __cdecl sub_1001FDB0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1001FB60(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1001FD30(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1001FB20(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1001FBB0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1001F9B0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1001FC10(v6, a5);
        }
      }
      else
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001FF60) --------------------------------------------------------
char __cdecl sub_1001FF60(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_100072A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10013B90(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10013B90(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10021880((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1017B5F8, (char *)&v6 + 1, 0x20u);
      byte_1017B5F0 = 1;
      byte_1017B5F1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1017B618, (char *)&v6 + 1, 0x20u);
    byte_1017B5F1 = 1;
    byte_1017B5F2 = 1;
    return result;
  }
  return 0;
}
// 1017B5F0: using guessed type char byte_1017B5F0;
// 1017B5F1: using guessed type char byte_1017B5F1;
// 1017B5F2: using guessed type char byte_1017B5F2;

//----- (10020090) --------------------------------------------------------
char __cdecl sub_10020090(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10013E30(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_100072A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10020110) --------------------------------------------------------
bool __cdecl sub_10020110(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1017B5F0 == 0;
    qmemcpy(a1, &unk_1017B5F8, 0x40u);
    result = !v1 && byte_1017B5F2;
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1017B5F0: using guessed type char byte_1017B5F0;
// 1017B5F2: using guessed type char byte_1017B5F2;

//----- (10020160) --------------------------------------------------------
char __cdecl sub_10020160(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_100072A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_100091F0(15);
    v3 = 555;
  }
  else
  {
    result = sub_100091F0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1017B5F1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10013690(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10022C30: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1017B5F1: using guessed type char byte_1017B5F1;

//----- (10020240) --------------------------------------------------------
__int16 __usercall sub_10020240@<ax>(unsigned __int8 a1@<al>)
{
  return word_1008BED8[a1];
}
// 1008BED8: using guessed type __int16 word_1008BED8[];

//----- (10020250) --------------------------------------------------------
char __cdecl sub_10020250(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10020240(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10013690(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_100137D0(1, v3, 0xFFFFFFF);
}

//----- (100202E0) --------------------------------------------------------
char __cdecl sub_100202E0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_100072A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1017B5F1 != 0 ? 25 : 11;
      sub_10020250(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10020250(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1017B5F1: using guessed type char byte_1017B5F1;

//----- (100203A0) --------------------------------------------------------
bool __cdecl sub_100203A0(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10020090(a1, (int)a5);
    return 1;
  }
  if ( byte_1017B5F1 )
  {
    if ( sub_1001FF60(a1, &v6, 1) )
    {
LABEL_14:
      byte_1017B5F3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1017B5F3 >= 5u )
    {
      byte_1017B5F0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1001FF60(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1017B5F3 >= 5u )
    {
      byte_1017B5F2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10020090(a1, (int)&v6);
    sub_10020160(a1, (int)&v6);
  }
  sub_100202E0(a1, 11);
  return sub_10020110(a5);
}
// 10022C30: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1017B5F0: using guessed type char byte_1017B5F0;
// 1017B5F1: using guessed type char byte_1017B5F1;
// 1017B5F2: using guessed type char byte_1017B5F2;
// 1017B5F3: using guessed type char byte_1017B5F3;

//----- (100204A0) --------------------------------------------------------
unsigned int __cdecl sub_100204A0(char *a1)
{
  return sub_1001DDF0(a1, -100, 100, 0, 0);
}

//----- (100204C0) --------------------------------------------------------
int __cdecl sub_100204C0(_BYTE *a1)
{
  return sub_1001E050(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100204E0) --------------------------------------------------------
int __cdecl sub_100204E0(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 1u, 1u, 0);
}

//----- (10020500) --------------------------------------------------------
unsigned int __cdecl sub_10020500(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001DCB0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1001DF60((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1001DCB0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DF60((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DF60((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10020830) --------------------------------------------------------
unsigned int __cdecl sub_10020830(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001DCB0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DCB0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DDF0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10020C70) --------------------------------------------------------
unsigned int __cdecl sub_10020C70(_BYTE *a1)
{
  return sub_1001DE40(a1, -1, 5, -1, 0);
}

//----- (10020C90) --------------------------------------------------------
int __cdecl sub_10020C90(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 5u, 0, 0);
}

//----- (10020CB0) --------------------------------------------------------
int __cdecl sub_10020CB0(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 4u, 2u, 0);
}

//----- (10020CD0) --------------------------------------------------------
int __cdecl sub_10020CD0(_BYTE *a1)
{
  return sub_1001E050(a1, 0, 2u, 0, 0);
}

//----- (10020CF0) --------------------------------------------------------
int __cdecl sub_10020CF0(int a1)
{
  return sub_1001DD00(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10020D40) --------------------------------------------------------
int __cdecl sub_10020D40(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10020CF0((int)(a1 + 4));
  if ( !result )
    result = sub_10020CB0(a1);
  return result;
}

//----- (10020D60) --------------------------------------------------------
int __cdecl sub_10020D60(int a1)
{
  int result; // eax@1

  result = sub_10020C90((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10020C90((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10020C90((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10021910((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1001DCB0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1001DCB0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1001DCB0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1001DCB0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10020DF0) --------------------------------------------------------
unsigned int __cdecl sub_10020DF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020C70((_BYTE *)a1);
  if ( !result )
    result = sub_10020C70((_BYTE *)(a1 + 4));
  return result;
}

//----- (10020E10) --------------------------------------------------------
signed int __cdecl sub_10020E10(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DCB0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1001DCB0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10020E60) --------------------------------------------------------
unsigned int __cdecl sub_10020E60(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020C70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10020C70((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10020C70((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10020C70((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1001DCB0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10020EC0) --------------------------------------------------------
int __cdecl sub_10020EC0(_BYTE *a1)
{
  return sub_1001E050(a1, 0, 0x20u, 2u, 0);
}

//----- (10020EE0) --------------------------------------------------------
unsigned int __cdecl sub_10020EE0(_BYTE *a1)
{
  return sub_1001DE40(a1, -1, 4, -1, 0);
}

//----- (10020F00) --------------------------------------------------------
int __cdecl sub_10020F00(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 9u, 0, 0);
}

//----- (10020F20) --------------------------------------------------------
int __cdecl sub_10020F20(_BYTE *a1)
{
  return sub_1001E050(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10020F40) --------------------------------------------------------
signed int __cdecl sub_10020F40(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E050(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10020F70) --------------------------------------------------------
int __cdecl sub_10020F70(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001DFB0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020FB0) --------------------------------------------------------
int __cdecl sub_10020FB0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10020F40((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10020F70((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020F70((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10021FB0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020F70((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10021040) --------------------------------------------------------
int __cdecl sub_10021040(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 2u, 0, 0);
}

//----- (10021060) --------------------------------------------------------
int __cdecl sub_10021060(int a1)
{
  int result; // eax@1

  result = sub_1001DF60((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1001DF60((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10021090) --------------------------------------------------------
int __cdecl sub_10021090(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 3u, 1u, 0);
}

//----- (100210B0) --------------------------------------------------------
unsigned int __cdecl sub_100210B0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001DE40((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1001DE40((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (100210E0) --------------------------------------------------------
int __cdecl sub_100210E0(int a1)
{
  int result; // eax@1

  result = sub_1001DD00(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1001DD00(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1001DD00(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1001DD00(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1001DD00(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (100211D0) --------------------------------------------------------
int __cdecl sub_100211D0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DCB0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1001DF60((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_100210B0(a1 + 36);
        if ( !result )
        {
          result = sub_1001DD00(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_100210E0(a1 + 8);
            if ( !result )
            {
              result = sub_100210B0(a1 + 28);
              if ( !result )
              {
                result = sub_1001DFB0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10021040((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10021060(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1001DCB0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10021090((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (100212E0) --------------------------------------------------------
signed int __cdecl sub_100212E0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001DFB0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10021310) --------------------------------------------------------
signed int __cdecl sub_10021310(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001DF60(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10021340) --------------------------------------------------------
int __cdecl sub_10021340(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 0x64u, 0x64u, 0);
}

//----- (100213A0) --------------------------------------------------------
int __cdecl sub_100213A0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DCB0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10021340((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (100213B0) --------------------------------------------------------
signed int __cdecl sub_100213B0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E050(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100213E0) --------------------------------------------------------
int __cdecl sub_100213E0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1001DF60((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1001DF60((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10021460) --------------------------------------------------------
unsigned int __cdecl sub_10021460(int a1)
{
  unsigned int result; // eax@1

  result = sub_100204A0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100204A0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100204A0((char *)a1);
      if ( !result )
        result = sub_100204A0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (100214A0) --------------------------------------------------------
unsigned int __cdecl sub_100214A0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10021460(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10021040((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100204E0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (100214F0) --------------------------------------------------------
int __cdecl sub_100214F0(int a1)
{
  int result; // eax@1

  result = sub_100204C0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1001DFB0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10021520) --------------------------------------------------------
int __cdecl sub_10021520(int a1)
{
  int result; // eax@1

  result = sub_10020CD0((_BYTE *)a1);
  if ( !result )
    result = sub_10020F20((_BYTE *)(a1 + 4));
  return result;
}

//----- (10021550) --------------------------------------------------------
unsigned int __cdecl sub_10021550(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020C70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10020C70((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10020EE0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10021580) --------------------------------------------------------
unsigned int __cdecl sub_10021580(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020C70((_BYTE *)a1);
  if ( !result )
    result = sub_10020F00((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (100215A0) --------------------------------------------------------
unsigned int __cdecl sub_100215A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020C70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1001DF60((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10020EE0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (100215E0) --------------------------------------------------------
void __cdecl __noreturn sub_100215E0(int a1)
{
  exit_0(a1 + 4);
}

//----- (10021750) --------------------------------------------------------
signed int __cdecl sub_10021750(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10021310((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_100212E0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10021310((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (100217B0) --------------------------------------------------------
signed int __usercall sub_100217B0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10021750(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1001DF60((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1001DCB0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10020830(v2 + 5, a2);
    else
      result = sub_10020500(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100213B0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10021880) --------------------------------------------------------
signed int __cdecl sub_10021880(int a1)
{
  return sub_100217B0(a1, 0);
}

//----- (10021890) --------------------------------------------------------
char __cdecl sub_10021890(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10021910) --------------------------------------------------------
int __cdecl sub_10021910(unsigned __int8 *a1)
{
  return sub_1001DF60(a1, 0, 0, 0, 0);
}

//----- (10021930) --------------------------------------------------------
unsigned int __cdecl sub_10021930(void *a1)
{
  return sub_1001DF00(a1, 0x20u, 0);
}

//----- (10021950) --------------------------------------------------------
unsigned int __cdecl sub_10021950(void *a1)
{
  return sub_1001DF00(a1, 0x1Cu, 0);
}

//----- (10021970) --------------------------------------------------------
unsigned int __cdecl sub_10021970(void *a1)
{
  return sub_1001DF00(a1, 0x10u, 0);
}

//----- (10021990) --------------------------------------------------------
unsigned int __cdecl sub_10021990(void *a1)
{
  return sub_1001DF00(a1, 0xCu, 0);
}

//----- (100219B0) --------------------------------------------------------
unsigned int __cdecl sub_100219B0(void *a1)
{
  return sub_1001DF00(a1, 8u, 0);
}

//----- (100219D0) --------------------------------------------------------
unsigned int __cdecl sub_100219D0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10021930((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10021950((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10021970(a1);
      if ( !result )
      {
        result = sub_10021990((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10021990((char *)a1 + 24);
          if ( !result )
            result = sub_100219B0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10021A30) --------------------------------------------------------
char __cdecl sub_10021A30(char a1)
{
  return byte_1008FB49[2 * (unsigned __int8)sub_10014380(&a1, 1u, (int)&unk_1008FB48, 2, 4, 3)];
}

//----- (10021A60) --------------------------------------------------------
char __cdecl sub_10021A60(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10013B60(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_100072A0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10021FE0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10013B60(1, 538, a2);
  }
  if ( !v4 || sub_100214F0((int)v3) )
    return 0;
  return 1;
}

//----- (10021AE0) --------------------------------------------------------
int __cdecl sub_10021AE0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10021A60(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10021B30) --------------------------------------------------------
char __cdecl sub_10021B30(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10021B70) --------------------------------------------------------
char __cdecl sub_10021B70(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10021B90) --------------------------------------------------------
int __cdecl sub_10021B90(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_10091FD4[2 * sub_10014380(&a1, 1u, (int)&unk_10091FD0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_10092014[2 * sub_10014380(&a2, 1u, (int)&unk_10092010, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_10092044[2 * sub_10014380(&a2, 1u, (int)&unk_10092040, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_10091FEC[2 * sub_10014380(&a2, 1u, (int)&unk_10091FE8, 8, 5, 5)];
  }
  return result;
}
// 10091FD4: using guessed type int dword_10091FD4[];
// 10091FEC: using guessed type int dword_10091FEC[];
// 10092014: using guessed type int dword_10092014[];
// 10092044: using guessed type int dword_10092044[];

//----- (10021C40) --------------------------------------------------------
bool __usercall sub_10021C40@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_10096707[44 * a1] - (unsigned __int8)byte_10096702[44 * a1];
}

//----- (10021C70) --------------------------------------------------------
char __usercall sub_10021C70@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10021C40(a1, a4, a5) )
  {
    v6 = a3
       + sub_10021B90(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_10096702[44 * a1] - (unsigned __int8)byte_10096707[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10021B90(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10021D10) --------------------------------------------------------
char __cdecl sub_10021D10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1001F960(a1);
  sub_10022B20(v5, (int)&v7, 3684);
  return sub_10021C70(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10021D90) --------------------------------------------------------
char __cdecl sub_10021D90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1001F960(a1);
  sub_10022B20(v5, (int)&v7, 3684);
  return sub_10021C70(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10021E10) --------------------------------------------------------
char __cdecl sub_10021E10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1001F960(a1);
  sub_10022B20(v5, (int)&v7, 3684);
  return sub_10021C70(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10021E90) --------------------------------------------------------
char __cdecl sub_10021E90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1001F960(a1);
  sub_10022B20(v5, (int)&v7, 3684);
  return sub_10021C70(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10021F10) --------------------------------------------------------
char __cdecl sub_10021F10(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_100072A0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021FB0) --------------------------------------------------------
int __cdecl sub_10021FB0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001DF60(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021FE0) --------------------------------------------------------
bool __cdecl sub_10021FE0(void *a1)
{
  char v1; // cl@1

  v1 = sub_10013B60(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_100214F0((int)a1);
}

//----- (10022070) --------------------------------------------------------
int __cdecl sub_10022070(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023928: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (100220C0) --------------------------------------------------------
int __cdecl sub_100220C0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 1002392E: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10022130) --------------------------------------------------------
int __cdecl sub_10022130(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = IOP_pvg_sk_wait_for_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023940: using guessed type int __cdecl IOP_pvg_sk_wait_for_status(_DWORD);

//----- (10022150) --------------------------------------------------------
char __cdecl sub_10022150(int a1, char *a2, size_t a3, char a4)
{
  char result; // al@1
  char *v5; // eax@4

  result = 0;
  if ( a1 && *(_BYTE *)a1 == 4 )
  {
    if ( !a2 )
      return result;
    v5 = "%3u.%3u.%3u.%3u";
    if ( !(a4 & 1) )
      v5 = "%u.%u.%u.%u";
    if ( sub_10007A80(a2, a3, v5, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 5), *(_BYTE *)(a1 + 6), *(_BYTE *)(a1 + 7)) > 0 )
      return 1;
    result = 0;
  }
  if ( a2 )
  {
    if ( (signed int)a3 > 0 )
      *a2 = 0;
  }
  return result;
}

//----- (100221C0) --------------------------------------------------------
char __cdecl sub_100221C0(int a1, unsigned int a2)
{
  unsigned __int8 v2; // cl@3

  if ( a2 >= 0xFFFFFFC2 || !a2 )
    return 0;
  v2 = *(_BYTE *)(a1 + 60);
  if ( v2 >= 0xFu )
  {
    *(_BYTE *)(a1 + 60) = 15;
    return 0;
  }
  *(_WORD *)(a1 + 2 * v2 + 62) = 1;
  *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 60) + 92) = 68;
  *(_DWORD *)(a1 + 4 * *(_BYTE *)(a1 + 60)) = a2;
  *(_DWORD *)(a1 + 4 * (*(_BYTE *)(a1 + 60))++ + 124) = 0;
  return 1;
}

//----- (10022220) --------------------------------------------------------
int __cdecl sub_10022220(void *a1, int a2)
{
  int result; // eax@1

  memset(a1, 0, 0xBCu);
  result = a2;
  *((_DWORD *)a1 + 46) = a2;
  return result;
}

//----- (10022250) --------------------------------------------------------
char __cdecl sub_10022250(int a1, int a2)
{
  char result; // al@1
  signed int v3; // edi@1
  const void *v4; // ebx@2
  int v5; // ebp@2

  result = 0;
  v3 = 0;
  if ( *(_BYTE *)(a1 + 60) )
  {
    v4 = (const void *)(a1 + 128);
    v5 = a1 + 62;
    do
    {
      if ( *((_DWORD *)v4 - 32) == a2 )
      {
        memcpy((char *)v4 - 128, (char *)v4 - 124, 4 * (--*(_BYTE *)(a1 + 60) - v3));
        memcpy((void *)v5, (const void *)(v5 + 2), 2 * (*(_BYTE *)(a1 + 60) - v3));
        memcpy((void *)(v5 + 30), (const void *)(v5 + 32), 2 * (*(_BYTE *)(a1 + 60) - v3));
        memcpy((char *)v4 - 4, v4, 4 * (*(_BYTE *)(a1 + 60) - v3));
        result = 1;
      }
      ++v3;
      v5 += 2;
      v4 = (char *)v4 + 4;
    }
    while ( v3 < *(_BYTE *)(a1 + 60) );
  }
  return result;
}

//----- (10022300) --------------------------------------------------------
signed int __cdecl sub_10022300(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100360D0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_1003DE90(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_10181FB8 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_10181FC0[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_10181FB8 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_100232B0(
      v2,
      *(_DWORD *)(dword_10181FC0[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10022300(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 1002394C: using guessed type int FIL_vfs_close(void);
// 10181FB8: using guessed type int dword_10181FB8;
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (10022340) --------------------------------------------------------
signed int __cdecl sub_10022340(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_10022300(a1);
  else
    result = -6;
  return result;
}

//----- (10022380) --------------------------------------------------------
int __cdecl sub_10022380(int a1, void *a2)
{
  int result; // eax@5
  unsigned int v3; // edi@4
  int v4; // ebx@7
  int v5; // eax@7

  if ( (unsigned int)a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
  {
    v3 = sub_100360D0(a1);
    memset(a2, 0, 0x3Cu);
    if ( v3 )
    {
      sub_100077F0((int)a2 + 48, &unk_100AD668, 10);
      *((_DWORD *)a2 + 3) = *(_DWORD *)(v3 + 44);
      *((_DWORD *)a2 + 4) = 0;
      *((_DWORD *)a2 + 8) = 1;
      *((_DWORD *)a2 + 9) = *(_DWORD *)(v3 + 40);
      sub_100076C0(*(_WORD *)(v3 + 34), *(_WORD *)(v3 + 32), (_DWORD *)a2 + 6);
      v4 = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 5) = v4;
      *((_DWORD *)a2 + 7) = v4;
      v5 = *(_DWORD *)(v3 + 58);
      *((_DWORD *)a2 + 10) = v5;
      *((_DWORD *)a2 + 1) = (v5 & 0x10) != 0 ? 4096 : 0x2000;
      result = 0;
    }
    else
    {
      result = -6;
    }
  }
  else
  {
    result = FIL_vfs_fstat();
  }
  return result;
}
// 1002395E: using guessed type int FIL_vfs_fstat(void);

//----- (100223C0) --------------------------------------------------------
int __cdecl sub_100223C0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1002396A: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022440) --------------------------------------------------------
signed int __cdecl sub_10022440(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100360D0(a1);
    return sub_10036F90(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_100227F0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10023650(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10023982: using guessed type int FIL_vfs_read(void);

//----- (10022490) --------------------------------------------------------
signed int __cdecl sub_10022490(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10036050(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10023650(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1002398E: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022530) --------------------------------------------------------
int __cdecl sub_10022530(int a1, void *a2, int a3, int a4, int a5)
{
  char *v5; // esi@1
  int v6; // edi@1
  int result; // eax@5
  char *v8; // edi@6
  char *v9; // ebp@6
  unsigned __int16 v10; // bx@7
  bool v11; // zf@9
  int v12; // [sp+10h] [bp-5Ch]@1
  int v13; // [sp+14h] [bp-58h]@1
  int v14; // [sp+18h] [bp-54h]@6
  char v15; // [sp+1Ch] [bp-50h]@1
  char v16; // [sp+2Ch] [bp-40h]@1
  char v17; // [sp+58h] [bp-14h]@2

  v5 = (char *)a2;
  v6 = a1;
  v13 = 0;
  v12 = 0;
  v15 = 0;
  if ( !sub_10022380(a1, &v16) )
    v15 = v17 & 1;
  while ( a5 )
  {
    result = j_FIL_vfs_read_dir_cnt(v6, v5, a3, a5);
    if ( result <= 0 )
      return result;
    v14 = result;
    v8 = v5;
    v9 = v5;
    do
    {
      v10 = *((_WORD *)v8 + 2);
      if ( sub_10007AB0(v8 + 24, (const char *)a4, v15) )
      {
        --a5;
        memcpy(v9, v8, v10);
        v12 += v10;
        ++v13;
        v9 += v10;
        v5 = (char *)a2;
      }
      v8 += v10;
      v11 = v14 == v10;
      v14 -= v10;
    }
    while ( v14 >= 0 && !v11 );
    if ( v13 )
      break;
    v6 = a1;
  }
  return v12;
}
// 10022480: using guessed type int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022640) --------------------------------------------------------
signed int __cdecl sub_10022640(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_100360B0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 100239A0: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022690) --------------------------------------------------------
signed int __cdecl sub_10022690(int a1, int a2)
{
  signed int result; // eax@3

  if ( a2 & 0xFFFFFFD8 && a2 & 0x27 )
    result = -34;
  else
    result = 0;
  return result;
}

//----- (100226B0) --------------------------------------------------------
__int64 __cdecl sub_100226B0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 100239A6: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100226E0) --------------------------------------------------------
int __cdecl sub_100226E0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 100239B2: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (10022710) --------------------------------------------------------
int __cdecl sub_10022710(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 100239BE: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022740) --------------------------------------------------------
char __cdecl sub_10022740(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10022300(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10022770) --------------------------------------------------------
int __cdecl sub_10022770(int a1, void *a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@1
  int result; // eax@7
  int v5; // edi@8

  memset(a2, 0, 0x3Cu);
  v2 = j_FIL_vfs_open(a1, 516, 0);
  v3 = v2;
  if ( (v2 >= 0xFFFFFFC2 || !v2) && v2 == -18 )
    v3 = j_FIL_vfs_open(a1, 772, 0);
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    v5 = sub_10022380(v3, a2);
    sub_10022340(v3);
    result = v5;
  }
  else
  {
    sub_10022340(v3);
    result = v3;
  }
  return result;
}
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100227F0) --------------------------------------------------------
signed int __cdecl sub_100227F0(unsigned int a1, int a2, int a3)
{
  return sub_10022640(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10022810) --------------------------------------------------------
int __cdecl sub_10022810(int a1, int *a2, int *a3)
{
  int v3; // eax@2
  int v4; // ecx@4
  int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@1
  int v12; // [sp+18h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( a2 )
  {
    v3 = *a2;
    LOWORD(v12) = v12 | 0x90;
    v6 = v3;
  }
  if ( a3 )
  {
    v4 = *a3;
    LOWORD(v12) = v12 | 0x120;
    v7 = v4;
  }
  return j_fil_vfs_set_iattr(a1 & 0xFFFFFFFC, &v6, v6, v7, v8, v9, v10, v11);
}
// 10022730: using guessed type int __cdecl j_fil_vfs_set_iattr(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022870) --------------------------------------------------------
int __cdecl sub_10022870(int a1, int a2, int a3)
{
  return sub_100226E0(a1, a2, a3);
}

//----- (10022890) --------------------------------------------------------
int __cdecl sub_10022890(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239CA: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (100228B0) --------------------------------------------------------
int sub_100228B0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239D0: using guessed type int TSK_pvg_get_id(void);

//----- (100228D0) --------------------------------------------------------
__int16 __cdecl sub_100228D0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239D6: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (100228F0) --------------------------------------------------------
int sub_100228F0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239DC: using guessed type int TSK_pvg_get_timer(void);

//----- (10022910) --------------------------------------------------------
int __cdecl sub_10022910(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239E2: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022950) --------------------------------------------------------
int __cdecl sub_10022950(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239EE: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022980) --------------------------------------------------------
int __cdecl sub_10022980(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239F4: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (100229A0) --------------------------------------------------------
int __cdecl sub_100229A0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 100239FA: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (100229D0) --------------------------------------------------------
int __cdecl sub_100229D0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023A00: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10022A00) --------------------------------------------------------
int __cdecl sub_10022A00(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023A06: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10022A30) --------------------------------------------------------
int __cdecl sub_10022A30(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023A0C: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10022A50) --------------------------------------------------------
int __cdecl sub_10022A50(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023A12: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10022A70) --------------------------------------------------------
int __cdecl sub_10022A70(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_100228B0();
    sub_10022910((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 100238F2: using guessed type int SYS_exit_krnl(void);
// 100238F8: using guessed type int SYS_enter_krnl(void);
// 10023A18: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10022AB0) --------------------------------------------------------
int __cdecl sub_10022AB0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10022980(a2);
  return result;
}
// 10041104: using guessed type void *tsk_app_hdr_ptr;

//----- (10022AE0) --------------------------------------------------------
int __cdecl sub_10022AE0(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_100229A0(a1, a2);
  return result;
}
// 10041104: using guessed type void *tsk_app_hdr_ptr;

//----- (10022B00) --------------------------------------------------------
int __cdecl sub_10022B00(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10023A1E: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022B20) --------------------------------------------------------
char __cdecl sub_10022B20(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10022B00(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_100072A0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10022B60) --------------------------------------------------------
int __cdecl sub_10022B60(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10022B00(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10022B90) --------------------------------------------------------
int __cdecl sub_10022B90(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10023A24: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022BB0) --------------------------------------------------------
int __cdecl sub_10022BB0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10022B00(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_10022B90(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10022C40) --------------------------------------------------------
int __cdecl sub_10022C40(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10012FD0(v1);
  a1 = v2;
  v3 = sub_10014380(&a1, 4u, (int)&unk_100A0378, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A037C[2 * v3];
}
// 100A037C: using guessed type int dword_100A037C[];

//----- (10022C80) --------------------------------------------------------
int __cdecl sub_10022C80(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10012FD0(v1);
  a1 = v2;
  v3 = sub_10014380(&a1, 4u, (int)&unk_100A03B0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A03B4[2 * v3];
}
// 100A03B4: using guessed type int dword_100A03B4[];

//----- (10022CC0) --------------------------------------------------------
int __cdecl sub_10022CC0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10012FD0(v1);
  a1 = v2;
  v3 = sub_10014380(&a1, 4u, (int)&unk_100A03E8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A03EC[2 * v3];
}
// 100A03EC: using guessed type int dword_100A03EC[];

//----- (10022D00) --------------------------------------------------------
int __cdecl sub_10022D00(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10012FD0(v1);
  a1 = v2;
  v3 = sub_10014380(&a1, 4u, (int)&unk_100A0420, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A0424[2 * v3];
}
// 100A0424: using guessed type int dword_100A0424[];

//----- (10022D40) --------------------------------------------------------
int __cdecl sub_10022D40(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10022C80(a4);
    result = sub_10022B00(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10022B00(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10022C40(a4);
      result = sub_10022B00(v6, a3, 6);
    }
  }
  return result;
}

//----- (10022DB0) --------------------------------------------------------
int __cdecl sub_10022DB0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10022D00(a3);
    result = sub_10022B00(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10022A50(100);
      v5 = sub_10022D00(a3);
      result = sub_10022B00(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10022CC0(a3);
    result = sub_10022B00(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10022A50(100);
      v7 = sub_10022CC0(a3);
      result = sub_10022B00(v7, a2, 8);
    }
  }
  return result;
}

//----- (10022E50) --------------------------------------------------------
int __cdecl sub_10022E50(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 100237A0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10022EB0) --------------------------------------------------------
int __usercall sub_10022EB0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100227F0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10022870(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10022E50((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_100228F0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10022440(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_10022710(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10022300(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10022300(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10022420: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10022430: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10022510: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100231B0) --------------------------------------------------------
int __usercall sub_100231B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 100237A0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100231D0) --------------------------------------------------------
signed int __cdecl sub_100231D0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_100072A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10022AE0(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10022AB0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100231B0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10022EB0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10022AB0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100232B0) --------------------------------------------------------
unsigned int __cdecl sub_100232B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10181FC0[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10181F78[a1];
  dword_10181F78[a1] = a3 + v9;
  dword_10181F38[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10181F38[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10181F78: using guessed type int dword_10181F78[];
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (10023460) --------------------------------------------------------
int __usercall sub_10023460@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10181FC0[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10181FC0[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (10023510) --------------------------------------------------------
int __cdecl sub_10023510(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10023460(a1);
  v3 = &dword_10181FC0[a1];
  v4 = sub_10022490(
         *(_DWORD *)dword_10181FC0[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10181FC0[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10181F78[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10181F78: using guessed type int dword_10181F78[];
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (100235C0) --------------------------------------------------------
int __usercall sub_100235C0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10181FC0[a1];
  v3 = (int *)(dword_10181F78[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10181FC0[a1] + 32)) % *(_WORD *)(dword_10181FC0[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10023510(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10181F78: using guessed type int dword_10181F78[];
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (10023650) --------------------------------------------------------
unsigned int __cdecl sub_10023650(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10181FB8 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10181FC0[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10181FB8 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_100229A0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10181FC0[v6] + 28);
        v12 = sub_100235C0(v6, (unsigned int)v7 & *(_DWORD *)(dword_10181FC0[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10181FC0[v6] + 4) != 138 )
        sub_10022980(*(_DWORD *)(dword_10181FC0[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10181FC0[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10022980(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10181FB8: using guessed type int dword_10181FB8;
// 10181FC0: using guessed type int dword_10181FC0[];

//----- (100237B0) --------------------------------------------------------
int __cdecl sub_100237B0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100A3E38[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100A3E38: using guessed type int dword_100A3E38[];

//----- (100237D0) --------------------------------------------------------
unsigned int __cdecl sub_100237D0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100A3E38[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100A3E38[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100A3E38[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100A3E38[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100A3E38[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100A3E38[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100A3E38[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100A3E38[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100A3E38[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100A3E38[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100A3E38: using guessed type int dword_100A3E38[];

//----- (100250C2) --------------------------------------------------------
int __cdecl sub_100250C2(int a1, int a2, char a3)
{
  return vscan_fn(sub_1002A33A, a2, 0, &a3);
}
// 1002505A: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10027974) --------------------------------------------------------
signed int __cdecl sub_10027974(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1018F398 )
  {
    *a1 = dword_1018F398;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1018F398: using guessed type int dword_1018F398;

//----- (100279AB) --------------------------------------------------------
signed int __cdecl sub_100279AB(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1018F398 )
  {
    *a1 = dword_1018F3A4;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1018F398: using guessed type int dword_1018F398;
// 1018F3A4: using guessed type int dword_1018F3A4;

//----- (10027FCC) --------------------------------------------------------
void sub_10027FCC()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_1019E220;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_1019E320 );
}
// 1019E220: using guessed type int dword_1019E220[];
// 1019E320: using guessed type int dword_1019E320;

//----- (10028479) --------------------------------------------------------
int (*sub_10028479())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100B1730;
  v1 = (int (**)(void))&unk_100B1730;
  if ( &unk_100B1730 < &unk_100B1730 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100B1730 );
  }
  return result;
}

//----- (1002849D) --------------------------------------------------------
void __cdecl sub_1002849D()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100B1738;
  if ( &unk_100B1738 < &unk_100B1738 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100B1738 );
  }
}

//----- (10029555) --------------------------------------------------------
int __cdecl sub_10029555(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1003169E() + 8 && (void **)v2 != sub_1003169E() + 16 || !sub_10031640((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100B3878;
      else
        v9 = (_BYTE *)(dword_1019E220[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10031520((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10031520((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 100315FC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (1002A0EA) --------------------------------------------------------
int __cdecl sub_1002A0EA(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1018F4F0 = a1;
  return result;
}
// 1018F4F0: using guessed type int dword_1018F4F0;

//----- (1002A33A) --------------------------------------------------------
int __cdecl sub_1002A33A(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100B3878;
  }
  else
  {
    v6 = &dword_1019E220[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100B3878) : (v8 = &dword_1019E220[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_10031BB5(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_10031BB5(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_10031BB5(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_10031BB5(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_10031BB5(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100B3964[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_10031BB5(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_10031BB5(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_10031BB5(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_10031BB5(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10026164: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1002A2FF: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 1002A315: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100B3964: using guessed type int (*off_100B3964[3])();
// 1019E220: using guessed type int dword_1019E220[];
// 1002A33A: using guessed type char var_24[11];

//----- (1002D414) --------------------------------------------------------
#error "1002D419: positive sp value has been found (funcsize=0)"

//----- (1002D41F) --------------------------------------------------------
#error "1002D424: positive sp value has been found (funcsize=0)"

//----- (1002D42A) --------------------------------------------------------
#error "1002D42F: positive sp value has been found (funcsize=0)"

//----- (1002D430) --------------------------------------------------------
#error "1002D435: positive sp value has been found (funcsize=0)"

//----- (1002D436) --------------------------------------------------------
#error "1002D43B: positive sp value has been found (funcsize=0)"

//----- (1002D43C) --------------------------------------------------------
#error "1002D441: positive sp value has been found (funcsize=0)"

//----- (1002D442) --------------------------------------------------------
#error "1002D45D: positive sp value has been found (funcsize=0)"

//----- (1002D463) --------------------------------------------------------
#error "1002D478: positive sp value has been found (funcsize=0)"

//----- (1002D47E) --------------------------------------------------------
#error "1002D499: positive sp value has been found (funcsize=0)"

//----- (1002D49A) --------------------------------------------------------
#error "1002D4A9: positive sp value has been found (funcsize=0)"

//----- (1002D4AA) --------------------------------------------------------
#error "1002D4BD: positive sp value has been found (funcsize=0)"

//----- (1002D4BE) --------------------------------------------------------
#error "1002D4CD: positive sp value has been found (funcsize=0)"

//----- (1002D4CE) --------------------------------------------------------
#error "1002D4ED: positive sp value has been found (funcsize=0)"

//----- (1002D4F3) --------------------------------------------------------
#error "1002D50C: positive sp value has been found (funcsize=0)"

//----- (1002D512) --------------------------------------------------------
#error "1002D531: positive sp value has been found (funcsize=0)"

//----- (1002D532) --------------------------------------------------------
#error "1002D545: positive sp value has been found (funcsize=0)"

//----- (1002D546) --------------------------------------------------------
#error "1002D55D: positive sp value has been found (funcsize=0)"

//----- (1002D55E) --------------------------------------------------------
#error "1002D571: positive sp value has been found (funcsize=0)"

//----- (1002D572) --------------------------------------------------------
#error "1002D591: positive sp value has been found (funcsize=0)"

//----- (1002D597) --------------------------------------------------------
#error "1002D5B0: positive sp value has been found (funcsize=0)"

//----- (1002D5B6) --------------------------------------------------------
#error "1002D5D5: positive sp value has been found (funcsize=0)"

//----- (1002D5D6) --------------------------------------------------------
#error "1002D5E9: positive sp value has been found (funcsize=0)"

//----- (1002D5EA) --------------------------------------------------------
#error "1002D601: positive sp value has been found (funcsize=0)"

//----- (1002D602) --------------------------------------------------------
#error "1002D615: positive sp value has been found (funcsize=0)"

//----- (1002D616) --------------------------------------------------------
#error "1002D635: positive sp value has been found (funcsize=0)"

//----- (1002D63B) --------------------------------------------------------
#error "1002D654: positive sp value has been found (funcsize=0)"

//----- (1002D65A) --------------------------------------------------------
#error "1002D679: positive sp value has been found (funcsize=0)"

//----- (1002D67A) --------------------------------------------------------
#error "1002D68D: positive sp value has been found (funcsize=0)"

//----- (1002D68E) --------------------------------------------------------
#error "1002D6A5: positive sp value has been found (funcsize=0)"

//----- (1002D6A6) --------------------------------------------------------
#error "1002D6B9: positive sp value has been found (funcsize=0)"

//----- (1002D6BA) --------------------------------------------------------
#error "1002D6D9: positive sp value has been found (funcsize=0)"

//----- (1002D6DF) --------------------------------------------------------
#error "1002D6F8: positive sp value has been found (funcsize=0)"

//----- (1002D6FE) --------------------------------------------------------
#error "1002D71D: positive sp value has been found (funcsize=0)"

//----- (1002D71E) --------------------------------------------------------
#error "1002D731: positive sp value has been found (funcsize=0)"

//----- (1002D732) --------------------------------------------------------
#error "1002D749: positive sp value has been found (funcsize=0)"

//----- (1002D74A) --------------------------------------------------------
#error "1002D75D: positive sp value has been found (funcsize=0)"

//----- (1002D75E) --------------------------------------------------------
#error "1002D77D: positive sp value has been found (funcsize=0)"

//----- (1002D783) --------------------------------------------------------
#error "1002D79C: positive sp value has been found (funcsize=0)"

//----- (1002D7A2) --------------------------------------------------------
#error "1002D7C1: positive sp value has been found (funcsize=0)"

//----- (1002D7C2) --------------------------------------------------------
#error "1002D7D5: positive sp value has been found (funcsize=0)"

//----- (1002D7D6) --------------------------------------------------------
#error "1002D7ED: positive sp value has been found (funcsize=0)"

//----- (1002D7EE) --------------------------------------------------------
#error "1002D801: positive sp value has been found (funcsize=0)"

//----- (1002D802) --------------------------------------------------------
#error "1002D821: positive sp value has been found (funcsize=0)"

//----- (1002D827) --------------------------------------------------------
#error "1002D840: positive sp value has been found (funcsize=0)"

//----- (1002D846) --------------------------------------------------------
#error "1002D865: positive sp value has been found (funcsize=0)"

//----- (1002D866) --------------------------------------------------------
#error "1002D879: positive sp value has been found (funcsize=0)"

//----- (1002D87A) --------------------------------------------------------
#error "1002D891: positive sp value has been found (funcsize=0)"

//----- (1002D892) --------------------------------------------------------
#error "1002D8A5: positive sp value has been found (funcsize=0)"

//----- (1002E828) --------------------------------------------------------
int sub_1002E828()
{
  dword_1019E338 = _get_sse2_info();
  return 0;
}
// 1002E7C8: using guessed type int _get_sse2_info(void);
// 1019E338: using guessed type int dword_1019E338;

//----- (1002F19C) --------------------------------------------------------
void sub_1002F19C()
{
  dword_1019E1FC = 0;
}
// 1019E1FC: using guessed type int dword_1019E1FC;

//----- (1002F692) --------------------------------------------------------
int sub_1002F692()
{
  return _decode_pointer(dword_1018F970);
}
// 10026164: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1018F970: using guessed type int dword_1018F970;

//----- (1002F84F) --------------------------------------------------------
int __cdecl sub_1002F84F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1018F97C = a1;
  return result;
}
// 1018F97C: using guessed type int dword_1018F97C;

//----- (1002F859) --------------------------------------------------------
int __cdecl sub_1002F859(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1018F988 = a1;
  return result;
}
// 1018F988: using guessed type int dword_1018F988;

//----- (1002F863) --------------------------------------------------------
int __cdecl sub_1002F863(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1018F98C = a1;
  return result;
}
// 1018F98C: using guessed type int dword_1018F98C;

//----- (1002F942) --------------------------------------------------------
int __cdecl sub_1002F942(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1018F990 = a1;
  return result;
}
// 1018F990: using guessed type int dword_1018F990;

//----- (100308BB) --------------------------------------------------------
int __cdecl sub_100308BB(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10032D9B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003381F: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030961) --------------------------------------------------------
int __cdecl sub_10030961(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100332DD((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003381F: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030D62) --------------------------------------------------------
DWORD __cdecl sub_10030D62(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10034C57(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_1019E220[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10025C7C: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10030EFE) --------------------------------------------------------
_WORD *__cdecl sub_10030EFE(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_1019E220[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_1019E220[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10030D62(a1, 0, 0, 2u);
  if ( sub_10031640(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10025C7C: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10026380: using guessed type int _getptd(void);
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1019E220: using guessed type int dword_1019E220[];
// 10030EFE: using guessed type CHAR var_410[688];

//----- (10031520) --------------------------------------------------------
_WORD *__cdecl sub_10031520(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_1019E220[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_10030EFE(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10034D68(a1);
  return v6;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10034CC8: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10031640) --------------------------------------------------------
int __cdecl sub_10031640(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_1019E220[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (1003169E) --------------------------------------------------------
void **sub_1003169E()
{
  return &off_100B3E70;
}
// 100B3E70: using guessed type void *off_100B3E70;

//----- (100316A4) --------------------------------------------------------
signed int sub_100316A4()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_1019E1E0;
  if ( !dword_1019E1E0 )
  {
    v0 = 512;
LABEL_5:
    dword_1019E1E0 = v0;
    goto LABEL_6;
  }
  if ( dword_1019E1E0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_1019D1D8 = v1;
  if ( v1 || (dword_1019E1E0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_1019D1D8 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100B3E70;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_100B40F0 )
        break;
      v1 = dword_1019D1D8;
    }
    v5 = 0;
    v6 = &unk_100B3E80;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_1019E220[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100B3EE0 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10027C95: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100B3E70: using guessed type void *off_100B3E70;
// 100B40F0: using guessed type int dword_100B40F0;
// 1019E1E0: using guessed type int dword_1019E1E0;
// 1019E220: using guessed type int dword_1019E220[];

//----- (10031A95) --------------------------------------------------------
int __cdecl sub_10031A95(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100B3878;
    }
    else
    {
      v7 = &dword_1019E220[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100315FC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10031BB5) --------------------------------------------------------
int __cdecl sub_10031BB5(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100B3878;
    }
    else
    {
      v2 = &dword_1019E220[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100B3878) : (v4 = &dword_1019E220[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100315FC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10031DFD) --------------------------------------------------------
int sub_10031DFD()
{
  return 0;
}

//----- (100328C8) --------------------------------------------------------
int __cdecl sub_100328C8(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1018FA60 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1018FA60 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_1018FA64 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1018FA68 = _encode_pointer(v7);
    if ( sub_10027974(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1018FA70 = _encode_pointer(v8);
      if ( dword_1018FA70 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1018FA6C = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1018FA6C == v23
    || dword_1018FA70 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1018FA6C),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1018FA70),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_1018FA64 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1018FA64);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1018FA68 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1018FA68);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100279AB(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1018FA60);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 100260ED: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1002615B: using guessed type int _encoded_null(void);
// 10026164: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1002A0F4: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1018FA60: using guessed type int dword_1018FA60;
// 1018FA64: using guessed type int dword_1018FA64;
// 1018FA68: using guessed type int dword_1018FA68;
// 1018FA6C: using guessed type int dword_1018FA6C;
// 1018FA70: using guessed type int dword_1018FA70;

//----- (10032D9B) --------------------------------------------------------
signed int __cdecl sub_10032D9B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100B42F4 - 1;
    v64 = v3;
    v65 = dword_100B42F4 / 32;
    v9 = dword_100B42F4 % 32;
    v10 = (int *)(&v60 + dword_100B42F4 / 32);
    v66 = 31 - dword_100B42F4 % 32;
    if ( (1 << (31 - dword_100B42F4 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100B42F0 - dword_100B42F4 )
    {
      if ( v3 > dword_100B42F0 )
      {
        if ( v3 < dword_100B42EC )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100B4300 + v3;
          v50 = dword_100B42F8 / 32;
          v51 = dword_100B42F8 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100B42F8 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100B42F8 / 32;
          v44 = dword_100B42F8 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100B42F8 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100B4300 + dword_100B42EC;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100B42F0 - v64) / 32;
      v62 = v59;
      v18 = (dword_100B42F0 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100B42F4 - 1;
      v25 = dword_100B42F4 / 32;
      v65 = dword_100B42F4 / 32;
      v26 = (int *)(&v60 + dword_100B42F4 / 32);
      v64 = 31 - dword_100B42F4 % 32;
      if ( (1 << (31 - dword_100B42F4 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100B42F4 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100B42F8 + 1) / 32;
      v37 = (dword_100B42F8 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100B42F8));
  if ( dword_100B42FC == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100B42FC == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100B42EC: using guessed type int dword_100B42EC;
// 100B42F0: using guessed type int dword_100B42F0;
// 100B42F4: using guessed type int dword_100B42F4;
// 100B42F8: using guessed type int dword_100B42F8;
// 100B42FC: using guessed type int dword_100B42FC;
// 100B4300: using guessed type int dword_100B4300;

//----- (100332DD) --------------------------------------------------------
signed int __cdecl sub_100332DD(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100B430C - 1;
    v64 = v3;
    v65 = dword_100B430C / 32;
    v9 = dword_100B430C % 32;
    v10 = (int *)(&v60 + dword_100B430C / 32);
    v66 = 31 - dword_100B430C % 32;
    if ( (1 << (31 - dword_100B430C % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100B4308 - dword_100B430C )
    {
      if ( v3 > dword_100B4308 )
      {
        if ( v3 < dword_100B4304 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100B4318 + v3;
          v50 = dword_100B4310 / 32;
          v51 = dword_100B4310 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100B4310 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100B4310 / 32;
          v44 = dword_100B4310 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100B4310 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100B4318 + dword_100B4304;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100B4308 - v64) / 32;
      v62 = v59;
      v18 = (dword_100B4308 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100B430C - 1;
      v25 = dword_100B430C / 32;
      v65 = dword_100B430C / 32;
      v26 = (int *)(&v60 + dword_100B430C / 32);
      v64 = 31 - dword_100B430C % 32;
      if ( (1 << (31 - dword_100B430C % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100B430C % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100B4310 + 1) / 32;
      v37 = (dword_100B4310 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100B4310));
  if ( dword_100B4314 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100B4314 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100B4304: using guessed type int dword_100B4304;
// 100B4308: using guessed type int dword_100B4308;
// 100B430C: using guessed type int dword_100B430C;
// 100B4310: using guessed type int dword_100B4310;
// 100B4314: using guessed type int dword_100B4314;
// 100B4318: using guessed type int dword_100B4318;

//----- (10034BD6) --------------------------------------------------------
signed int __cdecl sub_10034BD6(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_1019E220[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1018F00C == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1018F00C: using guessed type int dword_1018F00C;
// 1019E220: using guessed type int dword_1019E220[];

//----- (10034C57) --------------------------------------------------------
signed int __cdecl sub_10034C57(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_1019E220[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1002A1F0: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10034D68) --------------------------------------------------------
void __cdecl sub_10034D68(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_1019E220[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 1019E220: using guessed type int dword_1019E220[];

//----- (10035069) --------------------------------------------------------
int sub_10035069()
{
  return flsall(1);
}
// 10034F8F: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (10035DD8) --------------------------------------------------------
signed int __cdecl sub_10035DD8(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10034C57(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_1019E220[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_1019E220[0] + 68) & 1)
    && (v1 = sub_10034C57(2), sub_10034C57(1) == v1)
    || (v2 = (void *)sub_10034C57(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10034BD6(a1);
  *(_BYTE *)(dword_1019E220[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10025C7C: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1019E220: using guessed type int dword_1019E220[];

//----- (10036050) --------------------------------------------------------
signed int __cdecl sub_10036050(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_100360D0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10036FF0(v4, a4, 0) == a4 )
      result = sub_10036F90(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100360B0) --------------------------------------------------------
signed int __cdecl sub_100360B0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_100360D0(a1);
  return sub_10036FF0(v3, a2, a3);
}

//----- (100360D0) --------------------------------------------------------
unsigned int __cdecl sub_100360D0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (100360F0) --------------------------------------------------------
bool __cdecl sub_100360F0(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (100361C0) --------------------------------------------------------
int __cdecl sub_100361C0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (100361E0) --------------------------------------------------------
int __cdecl sub_100361E0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_100361C0(a1 + 20);
  return result;
}

//----- (10036220) --------------------------------------------------------
signed int __cdecl sub_10036220(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10022490(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10022490(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (100362E0) --------------------------------------------------------
int __cdecl sub_100362E0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10036320) --------------------------------------------------------
int __usercall sub_10036320@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1003AD50(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_100226B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100226E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10022700: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100363D0) --------------------------------------------------------
signed int __usercall sub_100363D0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_10022710(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1003B1A0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10036220(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10022490(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10022490(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1003B070(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_10022710(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_10022710(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (100365A0) --------------------------------------------------------
char __usercall sub_100365A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1003AD00(a2, a3, a1 + 212);
}

//----- (100365B0) --------------------------------------------------------
int __usercall sub_100365B0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10036320(result + 148, result);
  return result;
}

//----- (100365D0) --------------------------------------------------------
char __usercall sub_100365D0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100365F0) --------------------------------------------------------
int __usercall sub_100365F0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_100237B0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_100237B0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10036630) --------------------------------------------------------
int __fastcall sub_10036630(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10036650) --------------------------------------------------------
int __usercall sub_10036650@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100227F0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100226E0(v4, v3, 0);
}
// 10022700: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10036690) --------------------------------------------------------
signed int __usercall sub_10036690@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10036630(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_100237D0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_100365A0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1003CF50(a2 + 28, 4);
      else
        v22 = sub_1003CF50(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_100365A0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10022700: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100368A0) --------------------------------------------------------
int __cdecl sub_100368A0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100365B0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_100080D0(&v23);
    sub_10007640((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_100361E0(v1, (int)&v24);
  v13 = sub_100226B0(v31);
  if ( v3 == v31 )
  {
    result = sub_100223C0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100227F0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100223C0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100227F0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_100361C0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10036650(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_100226B0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10022700: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10036B10) --------------------------------------------------------
signed int __cdecl sub_10036B10(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100227F0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10036690(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10036BB0) --------------------------------------------------------
int __usercall sub_10036BB0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100365D0(a1);
  *v3 ^= v2;
  return sub_100365F0(v1, *v3);
}

//----- (10036BD0) --------------------------------------------------------
int __usercall sub_10036BD0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10036BB0(a2);
  return result;
}

//----- (10036C00) --------------------------------------------------------
int __usercall sub_10036C00@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100365F0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10022490(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10036CF0) --------------------------------------------------------
char __usercall sub_10036CF0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1003ACB0(a1, a2, a3 + 212);
  else
    result = sub_10036BD0(a2, a3 + 148);
  return result;
}

//----- (10036D20) --------------------------------------------------------
signed int __usercall sub_10036D20@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_100363D0(v3, v1);
  else
    result = sub_10036C00(v3, v1);
  return result;
}

//----- (10036D50) --------------------------------------------------------
signed int __cdecl sub_10036D50(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_100362E0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1003E9C0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10036D20(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10036DA0) --------------------------------------------------------
signed int __cdecl sub_10036DA0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10022490(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10036CF0(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10022490(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1003AD50(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10036630(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1003FD80(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_100237D0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_100237D0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10036F90) --------------------------------------------------------
signed int __cdecl sub_10036F90(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10036DA0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_100360F0(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10036FF0) --------------------------------------------------------
signed int __cdecl sub_10036FF0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10036D50(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_100362E0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10036D50(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10036F90(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10037180) --------------------------------------------------------
signed int __usercall sub_10037180@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100AE2B8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100AD6B8[2 * (unsigned __int8)v68] ^ dword_100ADAB8[2 * BYTE1(v65)] ^ dword_100ADEB8[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100AE2B8[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100AE2B8[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100AE2B8[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100AE2B8[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100AE2B8[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100AE2B8[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100AE2B8[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100AE2B8[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100AE2B8[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100AE6B8[(unsigned __int8)v57] ^ dword_100AF2B8[v58 >> 24] ^ dword_100AEAB8[BYTE1(v59)] ^ dword_100AEEB8[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100AE6B8[(unsigned __int8)v59] ^ dword_100AEEB8[(unsigned __int8)(v58 >> 16)] ^ dword_100AF2B8[v57 >> 24] ^ dword_100AEAB8[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100AE6B8[(unsigned __int8)v60] ^ dword_100AEAB8[BYTE1(v58)] ^ dword_100AEEB8[(unsigned __int8)(v57 >> 16)] ^ dword_100AF2B8[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100AE6B8[(unsigned __int8)v58] ^ dword_100AEAB8[BYTE1(v57)] ^ dword_100AEEB8[(unsigned __int8)(v59 >> 16)] ^ dword_100AF2B8[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100AE2B8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100AE2B8[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100AE2B8[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100AE2B8[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100AE2B8[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100AD6B8[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100ADAB8[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100ADEB8[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100AE2B8[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100AE6B8: using guessed type int dword_100AE6B8[];
// 100AEAB8: using guessed type int dword_100AEAB8[];
// 100AEEB8: using guessed type int dword_100AEEB8[];
// 100AF2B8: using guessed type int dword_100AF2B8[];

//----- (10038230) --------------------------------------------------------
int __usercall sub_10038230@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10037180(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10038290) --------------------------------------------------------
signed int __usercall sub_10038290@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100AF2B8[(unsigned __int8)v9] ^ dword_100AE6B8[BYTE1(v9)] ^ dword_100AEAB8[(unsigned __int8)(v9 >> 16)] ^ dword_100AEEB8[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100AF2B8[(unsigned __int8)v129] ^ dword_100AE6B8[BYTE1(v129)] ^ dword_100AEAB8[(unsigned __int8)(v129 >> 16)] ^ dword_100AEEB8[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100AF2B8[(unsigned __int8)v133] ^ dword_100AE6B8[BYTE1(v133)] ^ dword_100AEAB8[(unsigned __int8)(v133 >> 16)] ^ dword_100AEEB8[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100AF2B8[(unsigned __int8)v137] ^ dword_100AE6B8[BYTE1(v137)] ^ dword_100AEAB8[(unsigned __int8)(v137 >> 16)] ^ dword_100AEEB8[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100AF2B8[(unsigned __int8)v141] ^ dword_100AE6B8[BYTE1(v141)] ^ dword_100AEAB8[(unsigned __int8)(v141 >> 16)] ^ dword_100AEEB8[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100AF2B8[(unsigned __int8)v145] ^ dword_100AE6B8[BYTE1(v145)] ^ dword_100AEAB8[(unsigned __int8)(v145 >> 16)] ^ dword_100AEEB8[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100AF2B8[(unsigned __int8)v149] ^ dword_100AE6B8[BYTE1(v149)] ^ dword_100AEAB8[(unsigned __int8)(v149 >> 16)] ^ dword_100AEEB8[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100AF2B8[(unsigned __int8)v153] ^ dword_100AE6B8[BYTE1(v153)] ^ dword_100AEAB8[(unsigned __int8)(v153 >> 16)] ^ dword_100AEEB8[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100AF2B8[(unsigned __int8)v157] ^ dword_100AE6B8[BYTE1(v157)] ^ dword_100AEAB8[(unsigned __int8)(v157 >> 16)] ^ dword_100AEEB8[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100AF2B8[(unsigned __int8)v161] ^ dword_100AE6B8[BYTE1(v161)] ^ dword_100AEAB8[(unsigned __int8)(v161 >> 16)] ^ dword_100AEEB8[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100AF2B8[(unsigned __int8)v77] ^ dword_100AE6B8[BYTE1(v77)] ^ dword_100AEAB8[(unsigned __int8)(v77 >> 16)] ^ dword_100AEEB8[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100AF2B8[(unsigned __int8)v82] ^ dword_100AE6B8[BYTE1(v82)] ^ dword_100AEAB8[(unsigned __int8)(v82 >> 16)] ^ dword_100AEEB8[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100AF2B8[(unsigned __int8)v89] ^ dword_100AE6B8[BYTE1(v89)] ^ dword_100AEAB8[(unsigned __int8)(v89 >> 16)] ^ dword_100AEEB8[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100AF2B8[(unsigned __int8)v94] ^ dword_100AE6B8[BYTE1(v94)] ^ dword_100AEAB8[(unsigned __int8)(v94 >> 16)] ^ dword_100AEEB8[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100AF2B8[(unsigned __int8)v100] ^ dword_100AE6B8[BYTE1(v100)] ^ dword_100AEAB8[(unsigned __int8)(v100 >> 16)] ^ dword_100AEEB8[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100AF2B8[(unsigned __int8)v100] ^ dword_100AE6B8[BYTE1(v100)] ^ dword_100AEAB8[(unsigned __int8)(v100 >> 16)] ^ dword_100AEEB8[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100AF2B8[(unsigned __int8)v108] ^ dword_100AE6B8[BYTE1(v108)] ^ dword_100AEAB8[(unsigned __int8)(v108 >> 16)] ^ dword_100AEEB8[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100AF2B8[(unsigned __int8)v114] ^ dword_100AE6B8[BYTE1(v114)] ^ dword_100AEAB8[(unsigned __int8)(v114 >> 16)] ^ dword_100AEEB8[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100AF2B8[(unsigned __int8)v120] ^ dword_100AE6B8[BYTE1(v120)] ^ dword_100AEAB8[(unsigned __int8)(v120 >> 16)] ^ dword_100AEEB8[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100AF2B8[(unsigned __int8)v19] ^ dword_100AE6B8[BYTE1(v19)] ^ dword_100AEAB8[(unsigned __int8)(v19 >> 16)] ^ dword_100AEEB8[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100AE6B8[(unsigned __int8)v23] ^ dword_100AEAB8[BYTE1(v23)] ^ dword_100AEEB8[(unsigned __int8)(v23 >> 16)] ^ dword_100AF2B8[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100AF2B8[(unsigned __int8)v26] ^ dword_100AE6B8[BYTE1(v26)] ^ dword_100AEAB8[(unsigned __int8)(v26 >> 16)] ^ dword_100AEEB8[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100AE6B8[(unsigned __int8)v31] ^ dword_100AEAB8[BYTE1(v31)] ^ dword_100AEEB8[(unsigned __int8)(v31 >> 16)] ^ dword_100AF2B8[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100AF2B8[(unsigned __int8)v35] ^ dword_100AE6B8[BYTE1(v35)] ^ dword_100AEAB8[(unsigned __int8)(v35 >> 16)] ^ dword_100AEEB8[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100AE6B8[(unsigned __int8)v41] ^ dword_100AEAB8[BYTE1(v41)] ^ dword_100AEEB8[(unsigned __int8)(v41 >> 16)] ^ dword_100AF2B8[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100AF2B8[(unsigned __int8)v43] ^ dword_100AE6B8[BYTE1(v43)] ^ dword_100AEAB8[(unsigned __int8)(v43 >> 16)] ^ dword_100AEEB8[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100AE6B8[(unsigned __int8)v47] ^ dword_100AEAB8[BYTE1(v47)] ^ dword_100AEEB8[(unsigned __int8)(v47 >> 16)] ^ dword_100AF2B8[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100AF2B8[(unsigned __int8)v52] ^ dword_100AE6B8[BYTE1(v52)] ^ dword_100AEAB8[(unsigned __int8)(v52 >> 16)] ^ dword_100AEEB8[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100AE6B8[(unsigned __int8)v58] ^ dword_100AEAB8[BYTE1(v58)] ^ dword_100AEEB8[(unsigned __int8)(v58 >> 16)] ^ dword_100AF2B8[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100AF2B8[(unsigned __int8)v60] ^ dword_100AE6B8[BYTE1(v60)] ^ dword_100AEAB8[(unsigned __int8)(v60 >> 16)] ^ dword_100AEEB8[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100AE6B8[(unsigned __int8)v66] ^ dword_100AEAB8[BYTE1(v66)] ^ dword_100AEEB8[(unsigned __int8)(v66 >> 16)] ^ dword_100AF2B8[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100AF2B8[(unsigned __int8)v69] ^ dword_100AE6B8[BYTE1(v69)] ^ dword_100AEAB8[(unsigned __int8)(v69 >> 16)] ^ dword_100AEEB8[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100AE6B8: using guessed type int dword_100AE6B8[];
// 100AEAB8: using guessed type int dword_100AEAB8[];
// 100AEEB8: using guessed type int dword_100AEEB8[];
// 100AF2B8: using guessed type int dword_100AF2B8[];

//----- (10039010) --------------------------------------------------------
void *__usercall sub_10039010@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10039030) --------------------------------------------------------
unsigned int __cdecl sub_10039030(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_100228F0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10022940: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10039090) --------------------------------------------------------
int __usercall sub_10039090@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100390D0) --------------------------------------------------------
int __usercall sub_100390D0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1003A7F0) --------------------------------------------------------
unsigned int __usercall sub_1003A7F0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100AF6E0[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100AF6F0[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100390D0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100390D0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100AF6E0: using guessed type int dword_100AF6E0[];
// 100AF6F0: using guessed type int dword_100AF6F0[];

//----- (1003A8F0) --------------------------------------------------------
void *__usercall sub_1003A8F0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100390D0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1003A970) --------------------------------------------------------
void *__usercall sub_1003A970@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1003A7F0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10039090(v3 + 64);
    result = sub_1003A8F0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1003A8F0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1003AA10) --------------------------------------------------------
int __usercall sub_1003AA10@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1003A970(a1, 0, 0);
  sub_1003A7F0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10039090(a1 + 64);
  sub_1003A8F0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1003A8F0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1003A7F0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (1003AAD0) --------------------------------------------------------
int __usercall sub_1003AAD0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10039090(a2 + 64);
    sub_1003A8F0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1003A8F0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1003AB30) --------------------------------------------------------
int __usercall sub_1003AB30@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_100390D0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1003AB30: using guessed type char var_40[64];

//----- (1003ABF0) --------------------------------------------------------
int __usercall sub_1003ABF0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1003AB30((char *)a1);
  return sub_1003AB30(v8);
}

//----- (1003ACB0) --------------------------------------------------------
char __cdecl sub_1003ACB0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1003A970(a3 + 296, a2, a1);
    sub_10038230(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003AD00) --------------------------------------------------------
char __cdecl sub_1003AD00(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10038230(a3, (int)a1, a2);
    sub_1003A970(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003AD50) --------------------------------------------------------
bool __cdecl sub_1003AD50(int a1, int a2)
{
  if ( a2 )
    sub_1003AA10(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1003AD80) --------------------------------------------------------
int __usercall sub_1003AD80@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10039010(&v24);
  sub_1003AAD0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1003A970((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1003A970((int)&v23, v12, (char *)&v31);
          sub_1003AA10((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1003AD80: using guessed type char var_14[16];

//----- (1003AF90) --------------------------------------------------------
int __usercall sub_1003AF90@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_1003ABF0(v2);
  v3 = 20;
  do
  {
    sub_1003AB30((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_1003ABF0(v2);
}

//----- (1003AFE0) --------------------------------------------------------
char *__cdecl sub_1003AFE0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1003ABF0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1003B070) --------------------------------------------------------
signed int __cdecl sub_1003B070(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1003AD80(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10038290(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10039010((void *)(a6 + 296));
      sub_1003AAD0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1003B070: using guessed type char var_40[8];
// 1003B070: using guessed type __int16 var_38[26];

//----- (1003B1A0) --------------------------------------------------------
bool __cdecl sub_1003B1A0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1003AF90(&v4, (int)sub_10039030);
  if ( v2 )
    sub_1003AFE0(a2, (int)&v4);
  return v2;
}

//----- (1003B220) --------------------------------------------------------
BOOL __usercall sub_1003B220@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100AFEF8[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100AFDF8[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100AFCF8[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1003B2C0) --------------------------------------------------------
int __usercall sub_1003B2C0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1003B350) --------------------------------------------------------
unsigned int __fastcall sub_1003B350(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1003B370) --------------------------------------------------------
int __usercall sub_1003B370@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1003B400) --------------------------------------------------------
int __usercall sub_1003B400@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100AFEF8[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100AFEF8[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100AF700[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100AFFF8[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100AFDF8[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100AFCF8[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100AF788[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100B0070[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100AF700: using guessed type int dword_100AF700[];
// 100AF788: using guessed type int dword_100AF788[];
// 100AFFF8: using guessed type int dword_100AFFF8[];
// 100B0070: using guessed type int dword_100B0070[];

//----- (1003B880) --------------------------------------------------------
int __usercall sub_1003B880@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1003B370(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1003B930) --------------------------------------------------------
void *__usercall sub_1003B930@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1003B990) --------------------------------------------------------
int __usercall sub_1003B990@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1003BB60) --------------------------------------------------------
signed int __usercall sub_1003BB60@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1003B350(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1003BBE0) --------------------------------------------------------
_WORD *__fastcall sub_1003BBE0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1003BC50) --------------------------------------------------------
unsigned int __usercall sub_1003BC50@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1003BE00) --------------------------------------------------------
unsigned int __usercall sub_1003BE00@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1003BED0) --------------------------------------------------------
int __usercall sub_1003BED0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1003BF80) --------------------------------------------------------
int __usercall sub_1003BF80@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1003BFC0) --------------------------------------------------------
unsigned int __usercall sub_1003BFC0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1003DD90(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003C020) --------------------------------------------------------
signed int __usercall sub_1003C020@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1003C100) --------------------------------------------------------
int __usercall sub_1003C100@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1003C6A0) --------------------------------------------------------
int __usercall sub_1003C6A0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1003B2C0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1003B2C0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1003B2C0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1003C8E0) --------------------------------------------------------
int __usercall sub_1003C8E0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1003B880(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1003B880(a1, a3, a4);
  }
  return result;
}

//----- (1003C980) --------------------------------------------------------
signed int __usercall sub_1003C980@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1003BED0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1003BED0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1003BED0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1003B990(a1, a2);
  return sub_1003BB60(a1, v16, v5);
}

//----- (1003CB60) --------------------------------------------------------
unsigned int __usercall sub_1003CB60@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1003BFC0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1003CCA0) --------------------------------------------------------
int __usercall sub_1003CCA0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100AF774[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1003C100(a1, a1 + 2936, a2 - 1);
  return sub_1003C100(v24, v24 + 5228, a3 - 1);
}

//----- (1003CF50) --------------------------------------------------------
signed int __cdecl sub_1003CF50(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1003BF80(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1003BF80(v9, *(_WORD *)(a1 + 30));
      sub_1003BF80(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1003DD90(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1003B930(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100B00F0 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1003C6A0(v2);
    }
    else
    {
      sub_1003C8E0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1003B930(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1003BF80(v2, *(_WORD *)(a1 + 30));
    sub_1003BF80(v13, *(_WORD *)(a1 + 28));
    sub_1003B930(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100B00F0: using guessed type int (__cdecl *off_100B00F0)(int, int);

//----- (1003D210) --------------------------------------------------------
signed int __usercall sub_1003D210@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1003C020(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1003C020(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1003C980(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100AF774[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100AF773[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100AF772[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100AF771[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1003D2E0) --------------------------------------------------------
_WORD *__usercall sub_1003D2E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1003C980(a2, a2 + 5628);
  sub_1003C980(v4, v4 + 5640);
  v8 = sub_1003D210(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1003C8E0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1003B400(v4, (int)&unk_100AF800, (int)&unk_100AFC80);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1003CCA0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1003B400(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1003BBE0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1003B370(v4);
  return result;
}

//----- (1003D500) --------------------------------------------------------
signed int __cdecl sub_1003D500(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1003CB60(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1003BC50(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1003BE00(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1003B220(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1003B220(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1003D2E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1003B930(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1003D2E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003B930(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1003D810) --------------------------------------------------------
signed int __cdecl sub_1003D810(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1003CB60(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1003BC50(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1003BE00(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1003B220(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1003D2E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1003B930(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1003B220(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1003D2E0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1003B930(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1003B220(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1003D2E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003B930(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1003DC20) --------------------------------------------------------
signed int __cdecl sub_1003DC20(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1003CB60(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1003D2E0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1003B930(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1003D2E0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1003B930(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1003D2E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003B930(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1003DD90) --------------------------------------------------------
int __cdecl sub_1003DD90(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1003DE90) --------------------------------------------------------
signed int __cdecl sub_1003DE90(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1003DEB0) --------------------------------------------------------
signed int __usercall sub_1003DEB0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1003DEB0: using guessed type int var_78[14];
// 1003DEB0: using guessed type int var_3C[15];

//----- (1003E350) --------------------------------------------------------
int (__cdecl *__usercall sub_1003E350@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1003E3A0) --------------------------------------------------------
int __usercall sub_1003E3A0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1003E3C0) --------------------------------------------------------
signed int __cdecl sub_1003E3C0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100B02D8[a1];
  v51 = dword_100B02D8[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100B02D8[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100B02D8[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100B02D8[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100B02D8[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100B02D8: using guessed type int dword_100B02D8[];

//----- (1003E770) --------------------------------------------------------
int __usercall sub_1003E770@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1003E8B0) --------------------------------------------------------
signed int __usercall sub_1003E8B0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1003DEB0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1003E900) --------------------------------------------------------
signed int __usercall sub_1003E900@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1003DEB0(a7, a6, a4, 257, (int)&unk_100B0370, (int)&unk_100B03F0, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1003DEB0(a8, &a6[a4], a5, 0, (int)&unk_100B0470, (int)&unk_100B04E8, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003E9A0) --------------------------------------------------------
int __usercall sub_1003E9A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100B0560;
  *a4 = &unk_100B1560;
  return 0;
}

//----- (1003E9C0) --------------------------------------------------------
signed int __cdecl sub_1003E9C0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1003E350(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1003E9D0) --------------------------------------------------------
int __usercall sub_1003E9D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1003E3C0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100B02D8[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100B02D8[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100B02D8[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100B02D8[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1003E770(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1003E770(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1003E770(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1003E770(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100B02D8: using guessed type int dword_100B02D8[];

//----- (1003F070) --------------------------------------------------------
int __usercall sub_1003F070@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1003E9A0(&v67, &v69, &v66, &v68);
          sub_1003E3A0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1003E770(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100B0320[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100B0320[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1003E8B0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1003E900(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1003E3A0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1003E9D0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1003E770(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1003E770(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1003E770(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100B02D8[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100B02D8[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1003E770(v7, v3, v58);
}
// 100B02D8: using guessed type int dword_100B02D8[];
// 100B0320: using guessed type int dword_100B0320[];

//----- (1003FA50) --------------------------------------------------------
signed int __usercall sub_1003FA50@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1003F070(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1003E350((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1003FD80) --------------------------------------------------------
signed int __cdecl sub_1003FD80(int a1, int a2)
{
  return sub_1003FA50(a1, a2);
}

#error "There were 50 decompilation failure(s) on 873 function(s)"
