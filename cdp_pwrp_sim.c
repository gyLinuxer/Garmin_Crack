/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_10001000();
// int __usercall sub_10001050@<eax>(int result@<eax>, int a2@<ecx>);
bool __cdecl sub_10001080(void *a1);
// int __usercall sub_10001270@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_10001290(int a1, int a2, int a3);
char __thiscall sub_100012E0(int this);
char __cdecl sub_10001350(char a1, int a2);
int __cdecl sub_100013D0(int a1, unsigned int a2);
int __cdecl sub_10001410(_BYTE *a1);
char sub_100014B0();
char __cdecl sub_10001530(int a1, unsigned int a2, int a3);
// int __usercall sub_10001600@<eax>(int a1@<eax>);
// unsigned int __usercall sub_10001650@<eax>(unsigned int a1@<esi>, _DWORD *a2);
// int __usercall sub_10001670@<eax>(char a1@<al>, int a2@<esi>);
// int __usercall sub_100016B0@<eax>(int a1@<esi>, int a2, int a3);
// unsigned int __usercall sub_100016E0@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_100016F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_10001790@<eax>(unsigned __int8 a1@<al>, unsigned int a2@<ecx>, int a3@<edi>, int a4);
// char __usercall sub_100018F0@<al>(int a1@<eax>, unsigned int a2@<esi>);
_BYTE *__cdecl sub_10001930(char *a1);
// int __usercall sub_100019B0@<eax>(_BYTE *a1@<eax>);
int __cdecl sub_100019F0(int a1);
int __cdecl sub_10001A10(int, void *, size_t); // idb
int __cdecl sub_10001B40(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_10001BA0(int a1);
int __cdecl sub_10001BD0(int *a1);
bool __cdecl sub_10001BF0(char a1);
void __cdecl sub_10001C00(int a1, int a2);
int __cdecl sub_10001C20(int a1, int a2);
int __cdecl sub_10001C50(int a1, unsigned int a2);
int __cdecl sub_10001D00(int a1);
int __cdecl sub_10001D10(int a1);
// void *__usercall sub_10001D40@<eax>(int a1@<esi>);
// int __usercall sub_10001D60@<eax>(int a1@<eax>, int a2@<edi>);
int __cdecl sub_10001D90(int a1, unsigned int a2);
void *__cdecl sub_10001E00(char a1);
char __cdecl sub_10001E40(int a1);
_DWORD *__cdecl sub_10001EB0(int a1);
_BYTE *sub_10001EF0();
// int __usercall sub_10001F50@<eax>(int a1@<eax>, _BYTE *a2@<ecx>);
int __cdecl sub_10001F90(int a1, unsigned int a2);
void *__cdecl sub_10001FB0(int a1);
void *__cdecl sub_10002010(int a1);
bool __cdecl sub_10002070(int a1);
bool __cdecl sub_100020B0(int a1);
bool __cdecl sub_10002110(char a1);
bool __cdecl sub_10002130(_DWORD *a1);
bool __cdecl sub_10002150(int a1);
int __cdecl sub_10002170(int a1);
bool __cdecl sub_100021B0(int a1);
// bool __usercall sub_100021D0@<al>(int a1@<eax>);
// bool __usercall sub_100021F0@<al>(int a1@<eax>);
char __cdecl sub_10002210(int a1);
// bool __usercall sub_10002260@<al>(int a1@<eax>);
bool __thiscall sub_100022E0(void *this);
// char __usercall sub_10002320@<al>(int a1@<eax>);
bool __cdecl sub_10002360(char a1);
char __cdecl sub_100023C0(int a1);
bool __cdecl sub_10002470(int a1, int a2);
// int __usercall sub_10002490@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10002540(int a1, int a2);
char __cdecl sub_10002570(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100026B0(int a1, char *a2);
unsigned int sub_10002740();
int __cdecl sub_10002790(int a1, int a2);
int __cdecl sub_100027B0(int a1);
int __cdecl sub_100027E0(int a1, int a2);
int __cdecl sub_10002800(int a1, char *a2, int a3, int a4);
char __cdecl sub_10002890(int a1, int a2, int a3);
char __cdecl sub_10002900(int a1, int a2, int a3);
int sub_10002970();
_DWORD *__cdecl sub_10002990(int a1);
unsigned int __cdecl sub_100029B0(int a1, int a2, int a3);
// void __usercall sub_10002A20(int a1@<esi>);
// int __usercall sub_10002A60@<eax>(int a1@<esi>);
// void __usercall sub_10002B40(int a1@<esi>, int a2);
// int __usercall sub_10002C10@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10002DD0(int this);
signed int __cdecl sub_10002DF0(int a1, int a2);
char __cdecl sub_10002F40(int a1, int a2, __int16 a3);
char __cdecl sub_10002F70(int a1, int a2, __int16 a3);
char __cdecl sub_10002FA0(int a1);
// int __usercall sub_100032D0@<eax>(int a1@<eax>);
// void __usercall __noreturn sub_10003360(char *a1@<edi>);
int __cdecl sub_10003590(int a1, int a2);
char __cdecl sub_100035B0(int a1, unsigned int a2);
char sub_100035F0();
char __thiscall sub_10003610(int this);
// void *__usercall sub_10003780@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_10003930(int a1);
int __cdecl sub_10003950(int a1, int a2);
int __cdecl sub_100039D0(int a1, __int16 a2, __int16 a3);
__int16 __cdecl sub_10003A10(unsigned __int8 a1);
char __cdecl sub_10003A30(int (__cdecl *a1)(int));
char __cdecl sub_10003A70(int (__cdecl *a1)(int));
char __cdecl sub_10003A90(int a1, __int16 *a2, _BYTE *a3);
// char __usercall sub_10003B10@<al>(int a1@<ecx>, int a2@<edi>, int a3);
_WORD *__cdecl sub_10003C70(int a1);
_WORD *__cdecl sub_10003CE0(int a1, int a2, _WORD *a3, _WORD *a4, _WORD *a5, _BYTE *a6, unsigned __int8 a7, char a8);
// int __usercall sub_10003E90@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, bool *a9, char a10);
// int __usercall sub_10004010@<eax>(int a1@<esi>);
// void __usercall sub_10004060(unsigned int a1@<edi>);
// int __usercall sub_10004220@<eax>(int result@<eax>, int a2@<ecx>, int a3);
// _WORD *__usercall sub_10004250@<eax>(bool *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11, float a12, float a13, float a14, float a15);
// int __usercall sub_10004370@<eax>(int a1@<edx>, unsigned __int16 a2@<cx>, int a3@<ebx>, unsigned __int16 a4, int a5);
char __cdecl sub_100043F0(int a1, int a2, unsigned __int16 a3);
// signed int __usercall sub_100044A0@<eax>(int a1@<eax>);
// int __usercall sub_10004580@<eax>(int a1@<eax>);
// char __usercall sub_100046A0@<al>(int a1@<eax>);
void __cdecl sub_10004890(unsigned int a1);
// char __usercall sub_10004940@<al>(int a1@<esi>);
// int __usercall sub_10004A00@<eax>(int a1@<esi>);
int __cdecl sub_10004AA0(int a1);
int sub_10004B90(); // weak
// bool __usercall sub_10004C50@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
// int __usercall sub_10004CC0@<eax>(int a1@<eax>);
// char __usercall sub_10004FA0@<al>(int a1@<esi>);
signed int __cdecl sub_10005010(int a1);
// char __usercall sub_10005170@<al>(int a1@<eax>);
// char __usercall sub_10005280@<al>(int a1@<esi>);
char __cdecl sub_100052B0(int a1);
// char __usercall sub_100056C0@<al>(int a1@<esi>);
bool sub_10005720();
char __cdecl sub_10005770(int a1);
// char __usercall sub_10005A10@<al>(int a1@<eax>);
char __cdecl sub_10005BD0(int a1);
char __cdecl sub_10005FF0(int a1);
char __cdecl sub_100062A0(int a1);
char __cdecl sub_100064F0(int a1);
void __cdecl sub_100069D0(int a1);
// signed int __usercall sub_10006EB0@<eax>(int a1@<ebx>);
// char __usercall sub_100074A0@<al>(int a1@<esi>);
char __cdecl sub_100077A0(int a1);
BOOL __thiscall sub_10007890(void *this);
char sub_100078D0();
void sub_100079B0();
void sub_100079C0();
char __cdecl sub_100079D0(char a1);
char __cdecl sub_10007A30(void *a1);
_DWORD sub_10007B80(); // weak
int __cdecl sub_10007B90(char, void *, size_t, int); // idb
int __cdecl nullsub_1(_DWORD, _DWORD);
void __cdecl sub_10007C10(int a1);
char sub_10007CB0();
// char __usercall sub_10007CC0@<al>(int a1@<edi>, int a2);
char sub_10007CE0();
void __cdecl sub_10007CF0(unsigned int a1);
int __thiscall sub_10007D10(void *this);
_DWORD sub_10007D30(); // weak
// _WORD *__usercall sub_10007D80@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5);
// __int16 __usercall sub_10007DC0@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4);
// char __usercall sub_10007EF0@<al>(__int16 a1@<ax>, int a2@<esi>, int a3, void *a4);
int __cdecl sub_10007F50(int a1, int a2, int a3, int **a4, int a5);
BOOL __cdecl sub_10008150(int a1);
// char __usercall sub_10008180@<al>(int a1@<edx>, int **a2@<ecx>, int a3, int a4, _WORD *a5, char a6);
// char __usercall sub_100084F0@<al>(_WORD *a1@<eax>, int a2@<ecx>, int a3, int **a4, int a5);
char __cdecl sub_10008660(int a1, int a2, _WORD *a3, int *a4, _WORD *a5);
// char __usercall sub_10008B90@<al>(int a1@<eax>, char *a2@<ecx>);
char __cdecl sub_10008BF0(int a1, int a2, int a3, int a4, int a5);
int sub_100090F0();
int sub_100091E0();
int sub_10009330();
int sub_10009470();
char __cdecl sub_100096A0(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10009840@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5);
char __cdecl sub_100098F0(unsigned int a1, int a2, int *a3, int a4, int a5);
char __cdecl sub_10009B40(int a1, int a2, int a3, int *a4, _WORD *a5);
char __cdecl sub_10009BE0(__int16 a1, char *a2, __int16 a3, int a4);
signed int __cdecl sub_10009D10(char *a1, char *a2);
int __cdecl sub_10009E50(unsigned int a1);
int sub_10009E70();
bool __cdecl sub_10009F90(int a1);
int sub_10009FB0();
char __cdecl sub_10009FD0(int a1, unsigned __int8 a2);
BOOL __cdecl sub_1000A000(char a1);
// signed int __usercall sub_1000A030@<eax>(int a1@<eax>);
// signed int __usercall sub_1000A120@<eax>(int a1@<eax>);
int sub_1000A210();
// BOOL __usercall sub_1000A2C0@<eax>(char a1@<al>);
// BOOL __usercall sub_1000A2E0@<eax>(char a1@<al>);
char __cdecl sub_1000A310(int a1);
int __cdecl sub_1000A330(int a1, char a2);
char sub_1000A350();
int __cdecl sub_1000A900(int a1);
char __thiscall sub_1000A940(void *this);
char sub_1000A950();
char sub_1000AC60();
char __cdecl sub_1000AC80(int a1);
int __cdecl sub_1000ACA0(int a1);
int sub_1000ACE0(); // weak
int sub_1000AD20();
int sub_1000AEF0();
int __cdecl sub_1000B010(char *); // idb
char __cdecl sub_1000B0A0(const char *a1);
int sub_1000B260(void); // weak
char __cdecl sub_1000B270(const char *a1);
int __cdecl sub_1000B350(char a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 *a4, unsigned __int16 *a5);
// int __usercall sub_1000B5D0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_1000B690(int a1, int a2, int a3);
int __cdecl sub_1000B760(unsigned __int8 a1);
char __cdecl sub_1000B820(int a1, int a2, int a3, int a4, _WORD *a5);
void __cdecl sub_1000BE60(int a1, int (__cdecl *a2)(int));
// unsigned int __usercall sub_1000BEB0@<eax>(unsigned int result@<eax>);
// int __usercall sub_1000BEF0@<eax>(int result@<eax>);
void __cdecl sub_1000BF20(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_1000C2D0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
signed int __cdecl sub_1000C2F0(int a1);
int __cdecl sub_1000C310(unsigned int a1, _DWORD *a2, void *a3, int a4, int a5);
signed int __cdecl sub_1000C350(unsigned int a1, void *a2, void *a3);
signed int __cdecl sub_1000C3B0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1000C900(unsigned int a1, _DWORD *a2, int a3, signed int a4);
signed int __cdecl sub_1000CA00(unsigned int a1, int *a2, int a3, char a4);
void sub_1000CAB0();
_BYTE *__cdecl sub_1000CAC0(_BYTE *a1, const char *a2, _BYTE *a3, signed int a4);
char *__cdecl sub_1000CB40(unsigned __int8 a1);
signed int sub_1000CC00();
int sub_1000CC20();
int sub_1000CC80();
char *sub_1000CCF0();
int __cdecl sub_1000CDC0(const void *a1);
int sub_1000CE70();
int __cdecl sub_1000CF10(_BYTE *a1, _BYTE *a2);
int sub_1000CF40();
int __fastcall sub_1000CF50(unsigned __int8 a1);
int __fastcall sub_1000CF70(unsigned __int8 a1);
void *__cdecl sub_1000CF90(char a1, void *a2);
int __cdecl sub_1000D060(int a1);
char sub_1000D220();
signed int __cdecl sub_1000D380(unsigned int a1);
bool __cdecl sub_1000D3A0(unsigned int a1, _DWORD *a2);
signed int __cdecl sub_1000D3E0(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_1000D440(unsigned int a1, int a2, int a3);
void __cdecl sub_1000D460(const char *a1, char a2, char a3);
char __cdecl sub_1000D4B0(const char *a1, const char *a2);
int __cdecl sub_1000D560(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_1000D5B0(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1000D620(void *, size_t); // idb
int __cdecl sub_1000D650(int, char *, int); // idb
int __cdecl sub_1000D6B0(char *, size_t, char *, va_list); // idb
int sub_1000D6F0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1000D720(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1000D760(int a1, int a2);
char *__cdecl sub_1000D780(int a1, char *a2, int a3, char *a4, int a5);
char sub_1000D8B0();
char __cdecl sub_1000D8C0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_1000D9C0(char *a1, int a2, char a3, char *a4);
char __cdecl sub_1000DA30(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// int __usercall sub_1000DA50@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_1000DAA0(int a1, int a2, int a3, int a4, _WORD *a5);
// int __usercall sub_1000DB20@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_1000DFF0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000E020(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000E2A0(int a1, int a2, int *a3, int a4, int a5);
_DWORD *__cdecl sub_1000E310(_DWORD *a1);
int __cdecl sub_1000E320(int *a1, int a2);
_DWORD *__cdecl sub_1000E350(_DWORD *a1, int a2);
char __cdecl sub_1000E360(int a1, int a2, int a3);
char __cdecl sub_1000E390(int a1, _WORD *a2, int a3);
bool __cdecl sub_1000E3C0(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_1000E410(int a1, char *a2);
int __cdecl sub_1000E470(int a1, int a2, char *a3, int a4);
char __cdecl sub_1000E4E0(int a1, char *a2, int a3);
int __cdecl sub_1000E590(int a1);
BOOL __thiscall sub_1000E610(void *this);
char __thiscall sub_1000E630(void *this);
int sub_1000E660();
char __cdecl sub_1000E690(int a1);
int __cdecl sub_1000E6B0(int, char *); // idb
char __thiscall sub_1000E710(void *this);
char __thiscall sub_1000E730(void *this);
char __thiscall sub_1000E750(void *this);
char __thiscall sub_1000E770(void *this);
char sub_1000E790();
int __cdecl sub_1000E7B0(char a1);
int __cdecl sub_1000E7C0(char a1);
char __cdecl sub_1000E7D0(char a1);
char __cdecl sub_1000E810(char a1);
signed int __cdecl sub_1000E880(char a1);
char __cdecl sub_1000E900(char a1);
char __cdecl sub_1000E970(char a1);
char __cdecl sub_1000EA20(int a1);
char __thiscall sub_1000EB20(void *this);
int __cdecl sub_1000EB30(int *a1);
// char __usercall sub_1000EB60@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1000EC00(const char *a1);
char __cdecl sub_1000EC40(void *a1);
signed int __cdecl sub_1000EC90(unsigned int a1, int a2);
char **sub_1000F030();
int __cdecl sub_1000F040(_DWORD); // weak
int j_nullsub_1(void); // weak
int __cdecl sub_1000F060(int a1);
int sub_1000F070(void); // weak
signed int __cdecl sub_1000F0A0(int (__cdecl *a1)(int));
char *__cdecl sub_1000F0D0(unsigned __int8 a1);
int __cdecl sub_1000F100(int, float, float, float, float, int); // idb
int __cdecl sub_1000F200(unsigned int a1, int a2);
int __cdecl sub_1000F360(int a1, int a2);
int __cdecl sub_1000F470(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1000F5B0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_1000F5F0(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4);
void __cdecl sub_1000F740(int a1, int a2, int a3);
// int __usercall sub_1000F760@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_1000F840(int a1, int a2, int a3);
int __cdecl sub_1000F860(int a1, int a2, int a3);
unsigned int __cdecl sub_1000F8D0(unsigned int a1);
int __cdecl sub_1000F8F0(int a1);
bool __cdecl sub_1000F900(int a1);
int __cdecl sub_1000F9D0(int a1);
int __cdecl sub_1000F9F0(int a1, int a2);
bool __cdecl sub_1000FA30(int a1);
signed int __cdecl sub_1000FA90(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_1000FB50(int a1, int a2, int a3);
int __cdecl sub_1000FC00(int a1);
signed int __cdecl sub_1000FC20(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_1000FC80@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_1000FD90@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_1000FE40@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10010010@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10010020@<eax>(int result@<eax>);
// char __usercall sub_10010040@<al>(int a1@<eax>);
// int __usercall sub_10010060@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_100100A0(unsigned int a1);
int __fastcall sub_10010250(int a1, int a2);
// int __usercall sub_10010270@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10010280@<eax>(int a1@<esi>);
// signed int __usercall sub_100102C0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100104D0(void *); // idb
int __cdecl sub_10010530(int, int, void *, int); // idb
signed int __cdecl sub_10010630(int a1);
signed int __cdecl sub_10010650(int a1, unsigned __int64 a2);
signed int __cdecl sub_10010850(int a1, int a2);
int __cdecl sub_10010870(int a1);
int __cdecl sub_10010AE0(void *, int, char); // idb
signed int __cdecl sub_10010BB0(unsigned int a1, int a2, int a3);
// int __usercall sub_10010C50@<eax>(int a1@<eax>);
// int __usercall sub_10010C70@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10010CA0@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10010D10(int, char *, int); // idb
// void __cdecl __noreturn exit(int);
signed int __cdecl sub_10010E80(int a1);
// char __usercall sub_10010EE0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10010F10@<eax>(int a1@<eax>);
// BOOL __usercall sub_10010F40@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_10010F80(unsigned int a1);
signed int __cdecl sub_10010FD0(int a1, int a2);
// bool __usercall sub_100111C0@<al>(int a1@<eax>);
int __cdecl sub_100111F0(int, int, char, void *, int); // idb
signed int __cdecl sub_10011300(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10011360(unsigned int a1, int a2, int a3);
int __cdecl sub_100114F0(int a1, char *a2, int a3, void *a4, int a5);
int __cdecl sub_10011730(char *, char *); // idb
// void *__usercall sub_10011770@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_100117C0();
char __cdecl sub_100135C0(char *a1);
char __cdecl sub_100135F0(int a1);
char __cdecl sub_10013640(_WORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10013710(_BYTE *a1);
char __cdecl sub_10013740(_BYTE *a1);
char __cdecl sub_10013980(_BYTE *a1, _BYTE *a2);
char __cdecl sub_100139D0(_BYTE *a1, _BYTE *a2);
int sub_10013A20();
__int16 sub_10013AF0();
// int __usercall sub_10013B50@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_10013BD0();
int (__cdecl *(*sub_10013D90())[2])(int, int);
signed int __cdecl sub_10013EC0(signed int a1);
char __cdecl sub_10013F00(int a1);
int __cdecl sub_10013F80(int a1, int a2);
BOOL __cdecl sub_10013FA0(unsigned int a1);
char __thiscall sub_10014010(void *this);
void __cdecl sub_10014030(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_10014060(int a1);
signed int sub_10014080();
void __cdecl sub_100140B0(_BYTE *a1);
char __cdecl sub_100140D0(int a1, size_t a2, void *a3);
int __cdecl sub_10014110(int a1);
char __fastcall sub_10014130(int *a1);
char sub_10014350();
int __cdecl sub_10014370(int a1, int a2);
void sub_10014380();
int __cdecl sub_10014390(char a1);
signed int sub_100143B0();
// signed int __usercall sub_10014400@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_100144A0@<eax>(char a1@<al>);
// int __usercall sub_100144C0@<eax>(char a1@<al>);
// signed __int16 __usercall sub_100144E0@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10014720(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_100148A0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10014A00(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10014B40(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10014C20(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10014EA0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10014ED0(char a1, int a2, void *a3);
char __cdecl sub_10014F00(char a1, int a2, void *a3, int a4);
signed int sub_10014F40();
int sub_10014F60();
int sub_10014F70();
char __thiscall sub_10014FC0(void *this);
int __thiscall sub_10014FF0(void *this);
unsigned int __cdecl sub_10015060(int a1, int a2, size_t a3, int a4, int a5);
int sub_100151C0(); // weak
unsigned int __cdecl sub_100151E0(int a1, int a2, size_t a3, int a4);
bool __cdecl sub_10015210(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10015250(unsigned __int16 a1);
int __cdecl sub_10015280(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int sub_10015410();
unsigned int __cdecl sub_10015440(char *a1);
int __cdecl sub_10015460(unsigned __int8 *a1);
int __cdecl sub_10015480(_BYTE *a1);
int __cdecl sub_100154A0(unsigned __int8 *a1);
unsigned int __cdecl sub_100154C0(int a1, int a2);
unsigned int __cdecl sub_100157F0(int a1, int a2);
unsigned int __cdecl sub_10015C30(_BYTE *a1);
int __cdecl sub_10015C50(unsigned __int8 *a1);
int __cdecl sub_10015C70(unsigned __int8 *a1);
int __cdecl sub_10015C90(_BYTE *a1);
int __cdecl sub_10015CB0(int a1);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10015D00(unsigned __int8 *a1);
int __cdecl sub_10015D20(int a1);
unsigned int __cdecl sub_10015DB0(int a1);
signed int __cdecl sub_10015DD0(int a1);
unsigned int __cdecl sub_10015E20(int a1);
int __cdecl sub_10015E80(_BYTE *a1);
unsigned int __cdecl sub_10015EA0(_BYTE *a1);
int __cdecl sub_10015EC0(unsigned __int8 *a1);
int __cdecl sub_10015EE0(_BYTE *a1);
signed int __cdecl sub_10015F00(_BYTE *a1, int a2);
int __cdecl sub_10015F30(_BYTE *a1, int a2);
int __cdecl sub_10015F70(int a1, int a2);
int __cdecl sub_10016000(int a1);
int __cdecl sub_10016030(unsigned __int8 *a1);
unsigned int __cdecl sub_10016050(int a1);
int __cdecl sub_10016080(int a1);
int __cdecl sub_10016170(int a1);
signed int __cdecl sub_10016280(unsigned __int8 *a1, int a2);
signed int __cdecl sub_100162B0(_BYTE *a1, int a2);
int __cdecl sub_100162E0(unsigned __int8 *a1);
int __cdecl sub_10016340(int a1);
signed int __cdecl sub_10016350(_BYTE *a1, int a2);
int __cdecl sub_10016380(int a1, int a2);
unsigned int __cdecl sub_10016400(int a1);
unsigned int __cdecl sub_10016440(int a1);
int __cdecl sub_10016490(int a1);
int __cdecl sub_100164C0(int a1);
unsigned int __cdecl sub_100164F0(int a1);
unsigned int __cdecl sub_10016520(int a1);
unsigned int __cdecl sub_10016540(int a1);
void __cdecl __noreturn sub_10016580(int a1);
signed int __cdecl sub_100166F0(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10016750@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10016820(int a1);
char __cdecl sub_10016830(char a1);
int __cdecl sub_10016870(char *a1, char a2);
bool __cdecl sub_100168E0(int a1, void *a2);
char __cdecl sub_100169A0(int a1, bool *a2);
char __thiscall sub_10016A60(void *this);
char __cdecl sub_10016AF0(int a1, char a2);
char __cdecl sub_10016BB0(char a1);
int __cdecl sub_10016BE0(int a1, unsigned int a2);
__int16 __cdecl sub_10016CD0(int a1, unsigned int a2);
__int16 __cdecl sub_10016D20(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10016DA0(int *a1, int a2);
int __cdecl sub_10016DC0(int a1);
int __cdecl sub_10016E00(unsigned __int16 a1);
char *__cdecl sub_10016E20(unsigned __int16 a1);
signed int __fastcall sub_10016E60(unsigned __int8 a1);
char __cdecl sub_10016E70(unsigned __int8 a1);
__int16 __cdecl sub_10016E90(unsigned __int8 a1);
char *__cdecl sub_10016EB0(char **a1);
int sub_10016F00();
int __cdecl sub_10016F40(_BYTE *a1, int a2);
signed int __cdecl sub_10016FB0(_BYTE *a1, int a2);
// int __usercall sub_10017050@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10017080@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10017250@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_100172B0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10017340@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10017390@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_100173F0@<eax>(int a1@<eax>);
// int __usercall sub_10017410@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10017450@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_100174E0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10017630@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_100176D0@<eax>(int result@<eax>);
char *__cdecl sub_10017710(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_100178C0@<eax>(int a1@<eax>);
// int __usercall sub_100178F0@<eax>(int a1@<esi>);
void __cdecl sub_10017920(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10017D90();
void *sub_10017DE0();
char *sub_10017E40();
char sub_10017E60();
char __cdecl sub_10017E70(int a1, int a2, unsigned int a3);
// int *__usercall sub_10017EB0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10017F00();
int __cdecl sub_10017F10(_DWORD *a1, int a2, int a3);
int __cdecl sub_10017FC0(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_100181D0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10018290(char a1);
int *__cdecl sub_10018330(_BYTE *a1);
// int __usercall sub_100183F0@<eax>(int a1@<eax>);
// signed int __usercall sub_10018550@<eax>(int a1@<esi>);
int __cdecl sub_100185C0(int, int); // weak
char **sub_100188A0();
// int __usercall sub_100188B0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_100189A0(char *a1);
int sub_10018BE0();
int __cdecl sub_10018CC0(int a1, int a2, char a3);
int __cdecl sub_10018D10(int a1);
int __cdecl sub_10018D20(void *); // idb
int __cdecl sub_10018DA0(int a1, int a2);
signed int __cdecl sub_10018DD0(int a1, int a2, int a3);
char __cdecl sub_10018DF0(_DWORD *a1);
char __cdecl sub_10018F00(int a1, unsigned int a2);
bool __cdecl sub_10018F30(const void **a1, int a2);
bool __cdecl sub_10018F60(const void **a1, int a2);
bool __cdecl sub_10018F90(const void **a1, int a2);
bool __cdecl sub_10018FC0(const void **a1, int a2);
bool __cdecl sub_10018FF0(const void **a1, int a2);
bool __cdecl sub_10019020(int a1, int a2);
bool __cdecl sub_10019060(int a1, int a2);
bool __cdecl sub_100190A0(const void **a1, int a2);
bool __cdecl sub_100190D0(const void **a1, int a2);
char __cdecl sub_10019100(int a1, unsigned int a2);
bool __cdecl sub_10019130(const void **a1, int a2);
bool __cdecl sub_10019160(const void **a1, int a2);
bool __cdecl sub_10019190(const void **a1, int a2);
bool __cdecl sub_100191C0(const void **a1, int a2);
bool __cdecl sub_100191F0(const void **a1, int a2);
bool __cdecl sub_10019220(const void **a1, int a2);
bool __cdecl sub_10019250(const void **a1, int a2);
bool __cdecl sub_10019280(const void **a1, int a2);
bool __cdecl sub_100192B0(const void **a1, int a2);
bool __cdecl sub_100192E0(const void **a1, int a2);
int __cdecl sub_10019310(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10019380(int a1, char a2);
int __cdecl sub_100193A0(int a1, int a2, int a3);
int __cdecl sub_100193D0(int a1, int a2, int a3, int a4);
int __cdecl sub_10019400(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10019440(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10019480(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_100194D0(int a1);
char __cdecl sub_10019500(int a1);
char __cdecl sub_10019510(int a1, int a2);
signed int __cdecl sub_10019690(int a1);
signed int __cdecl sub_100196D0(int a1, int a2, int a3);
char __cdecl sub_10019770(int a1);
char __cdecl sub_100197D0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10019840(char *a1);
int __cdecl sub_100198E0(int a1, int a2, int a3);
bool __cdecl sub_10019950(int a1, unsigned int a2, int a3);
char __cdecl sub_100199E0(int a1, int a2, char a3, char a4);
char __cdecl sub_10019A90(int a1);
char __cdecl sub_10019AA0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_10019B20(int a1, const char *a2))(const char *);
signed int __cdecl sub_10019B70(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10019BC0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_10019D40();
const char *__cdecl sub_10019D50(unsigned int a1);
int __cdecl sub_10019D70(int a1, int a2, int a3, int a4);
int __cdecl sub_10019E20(int a1);
int __cdecl sub_10019E40(int a1);
char *sub_10019E60(char *a1, ...);
// char *__usercall sub_10019EA0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_10019EC0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1001A0A0();
int sub_1001A0C0();
int __cdecl sub_1001A0E0(int a1, int a2);
int __cdecl sub_1001A140(int a1);
int __cdecl sub_1001A150(int a1, int a2);
int __cdecl sub_1001A1B0(int a1);
bool __cdecl sub_1001A1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001A300(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001A6B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1001AB00(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1001AFC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001B380(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1001B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001BB40(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1001C080(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1001C460(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001C820(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001CBC0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1001CFC0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001D360(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1001D940(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1001DD30(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1001E0D0();
// BOOL __usercall sub_1001E100@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1001E270@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1001E4E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1001E7E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1001E890(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1001E8D0(int a1, int a2);
char __cdecl sub_1001E910(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1001F6C0(int a1, int a2);
char **__cdecl sub_1001F740(int a1);
int (**sub_1001F780())();
int (__cdecl *__cdecl sub_1001F790(const char *a1))(const char *);
const char *sub_1001F7B0();
__int64 sub_1001F7C0();
const char *sub_1001F7D0();
// int __usercall sub_1001F7E0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1001F830(int a1, int a2);
int sub_1001F860(); // weak
// int __usercall sub_1001F980@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_1001FD00(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10020B20(int a1);
char __thiscall sub_10020B90(void *this);
// char __usercall sub_10020C00@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10020C40@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10020CE0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10020D20(char a1, char a2, void *a3);
char __cdecl sub_10020D80(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10020DC0(char a1, char a2, void *a3);
char __cdecl sub_10020DF0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10020E30(char a1, char a2, void *a3);
char __cdecl sub_10020E70(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10020EB0(char a1, char a2, void *a3);
char __cdecl sub_10020F00(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10020F40(char a1, char a2, void *a3);
char __cdecl sub_10020F80(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10020FC0(char a1, char a2, void *a3);
char __cdecl sub_10021000(char a1, void *a2);
char __cdecl sub_10021030(char a1, void *a2);
char __cdecl sub_10021060(char a1, void *a2);
char __cdecl sub_10021090(char a1, void *a2);
char __cdecl sub_100210C0(char a1, void *a2);
char __cdecl sub_100210F0(char a1, void *a2);
char __cdecl sub_10021120(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10021160(char a1, char a2, void *a3);
char __cdecl sub_100211B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100211F0(char a1, char a2, void *a3);
char __cdecl sub_10021220(char a1, void *a2);
char __cdecl sub_10021250(char a1, void *a2);
char __cdecl sub_10021280(char a1, void *a2);
char __cdecl sub_100212B0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10021650(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100216C0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10021720(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10021790(char a1, _BYTE *a2);
char __thiscall sub_100217D0(void *this);
char __cdecl sub_10021840(char a1, int a2);
char __cdecl sub_10021870(char a1, int a2);
char __cdecl sub_100218A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
// signed int __usercall sub_10021A70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10022B20@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10022B80@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10023900@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10023920(int a1, unsigned int a2);
// int __usercall sub_10023980@<eax>(int result@<eax>);
// int __usercall sub_100239C0@<eax>(int result@<eax>);
// unsigned int __usercall sub_100250E0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_100251E0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10025260@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10025300@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_100253C0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10025420@<eax>(char *a1@<edi>);
// int __usercall sub_100254E0@<eax>(int a1@<ebx>);
char __cdecl sub_100255A0(char *a1, size_t a2, int a3);
char __cdecl sub_100255F0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10025640(int a1, int a2);
// int __usercall sub_10025670@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10025880@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_100258D0(int a1, int a2);
signed int __cdecl sub_10025960(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10025A90(void *a1, int a2);
// BOOL __usercall sub_10025B10@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10025BB0@<eax>(int result@<eax>);
unsigned int __fastcall sub_10025C40(unsigned int a1, int a2);
// int __usercall sub_10025C60@<eax>(int result@<eax>);
// int __usercall sub_10025CF0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10026170@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10026220@<eax>(int a1@<edi>);
// int __usercall sub_10026280@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10026450@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_100264D0(int a1, int a2);
// signed int __usercall sub_10026540@<eax>(int a1@<esi>);
// unsigned int __usercall sub_10026600@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_100267B0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10026880@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10026930@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10026970@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_100269D0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10026AB0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_10027050(int a1, int a2);
signed int __cdecl sub_100270B0(int a1);
// int __usercall sub_10027140@<eax>(int a1@<eax>);
// int __usercall sub_10027380@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10027420@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10027600@<eax>(int a1@<edi>);
// int __usercall sub_10027740@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_100279F0(int a1, int a2);
signed int __cdecl sub_10027CB0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_10027E60@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10027F30@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10028150(int a1, int a2);
signed int __cdecl sub_10028460(int a1, int a2);
signed int __cdecl sub_10028870(int a1, int a2);
int __cdecl sub_100289E0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10028AE0(int a1);
// signed int __usercall sub_10028B00@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10028FA0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10028FF0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10029010(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100293C0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10029500@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10029550@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_100295F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10029610(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10029700(int a1);
// int __usercall sub_10029710@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10029DB0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1002A790@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1002AAC0(int a1, int a2);
char __cdecl sub_1002AAE0(int a1, int a2);
char __cdecl sub_1002AB30(int a1, int a2);
char __cdecl sub_1002ABE0(int a1, int a2);
char __cdecl sub_1002AC40(int a1, int a2);
char __cdecl sub_1002AD10(char a1, void *a2);
unsigned __int8 __cdecl sub_1002AD60(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_1002ADA0(char a1, _DWORD *a2);
char __cdecl sub_1002ADE0(char a1);
char __cdecl sub_1002AE10(char a1, void *a2);
int __cdecl sub_1002AE90(char a1, _DWORD *a2);
void __cdecl sub_1002AEE0(char a1, char a2);
char *__cdecl sub_1002AF50(char *a1);
char __thiscall sub_1002B040(void *this);
// _DWORD *__usercall sub_1002B060@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_1002B090(); // weak
int sub_1002B0F0(); // weak
char __cdecl sub_1002B140(int a1, int a2);
_DWORD *sub_1002B240();
signed int __cdecl sub_1002B2D0(_BYTE *a1, char a2, int a3);
int __cdecl sub_1002B320(int, float, float, int, int); // idb
unsigned int __cdecl sub_1002B410(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1002B460(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1002B520(void *a1, size_t a2, int a3);
int __cdecl sub_1002B580(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1002B5D0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1002B670(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_1002B720(int a1, int a2);
char __cdecl sub_1002B840(int a1);
char sub_1002B850();
char __cdecl sub_1002B8D0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1002B9E0(char a1);
bool __cdecl sub_1002BA30(void *a1);
char __cdecl sub_1002BA70(char a1);
char __cdecl sub_1002BAA0(char a1);
int __cdecl sub_1002BAD0(unsigned __int8 *a1);
unsigned int __cdecl sub_1002BAF0(void *a1);
unsigned int __cdecl sub_1002BB10(void *a1);
unsigned int __cdecl sub_1002BB30(void *a1);
unsigned int __cdecl sub_1002BB50(void *a1);
unsigned int __cdecl sub_1002BB70(void *a1);
unsigned int __cdecl sub_1002BB90(void *a1);
int __cdecl sub_1002BBF0(unsigned __int8 *a1, int a2);
signed int __cdecl sub_1002BC20(char a1, char a2);
int __cdecl sub_1002BC80(char a1);
signed int __cdecl sub_1002BCC0(char a1, char a2, char a3);
int __cdecl sub_1002BD30(char a1);
int __cdecl sub_1002BD70(char a1);
char __cdecl sub_1002BDB0(char a1, int a2);
char __cdecl sub_1002BDD0(char a1, int a2);
char __cdecl sub_1002BE00(char a1, int a2);
char __cdecl sub_1002BE50(char a1, int a2);
char __cdecl sub_1002BE80(char a1, int a2);
char __cdecl sub_1002BEA0(int a1);
char __cdecl sub_1002BEC0(char a1);
char sub_1002BEF0();
BOOL __cdecl sub_1002BF90(int a1, int a2);
char __cdecl sub_1002BFB0(int a1, char a2, int a3, int a4, int a5);
int __cdecl sub_1002BFF0(int a1);
char __cdecl sub_1002C000(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1002C040(const char *a1, int a2);
// char *__usercall sub_1002C0B0@<eax>(char *result@<eax>);
void __cdecl sub_1002C0E0(char *a1);
void __cdecl sub_1002C1A0(char *a1, char *a2);
void *__cdecl sub_1002C200(int a1);
int __cdecl sub_1002C390(int a1, int a2);
// char __usercall sub_1002C4D0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1002C5A0(_DWORD *a1, char *a2);
BOOL __cdecl sub_1002C680(unsigned int a1);
BOOL __cdecl sub_1002C6A0(int a1);
_DWORD __cdecl sub_1002C6C0(_DWORD); // weak
unsigned int __cdecl sub_1002C6D0(int a1, char a2);
signed int __cdecl sub_1002C730(void *a1, int a2, unsigned int a3);
int __cdecl sub_1002C750(int a1, int a2, int a3);
char __cdecl sub_1002C770(const char *a1, const char *a2);
int __cdecl sub_1002C8B0(int a1, int a2, unsigned int a3);
int sub_1002C930();
void __cdecl sub_1002C940(int a1);
int __cdecl sub_1002C970(int a1);
bool __cdecl sub_1002C990(int a1);
void *__cdecl sub_1002C9C0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1002CA00@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1002CA20@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1002CA40(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1002CA70(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1002CB50(int a1, int a2, int a3);
// void *__usercall sub_1002CC00@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_1002CE80(int a1, int a2);
char __cdecl sub_1002CF50(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_1002CFC0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_1002D320@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_1002D430(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_1002D5C0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_1002D710@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_1002D860(int a1, int a2);
signed int __cdecl sub_1002D8A0(int a1, int a2);
bool __cdecl sub_1002D900(signed int a1);
int sub_1002D970();
char sub_1002DC90();
char sub_1002DEB0();
char sub_1002E0B0();
char sub_1002E230();
char sub_1002E3B0();
char sub_1002E520();
char sub_1002E620();
char sub_1002E780();
char sub_1002E8E0();
char sub_1002EA40();
char sub_1002EBB0();
char sub_1002ED10();
char sub_1002EE70();
char sub_1002F090();
char sub_1002F1F0();
char sub_1002F350();
char sub_1002F4B0();
char sub_1002F620();
char sub_1002F780();
char sub_1002F8E0();
char sub_1002FB00();
char sub_1002FD00();
char sub_1002FE80();
char sub_10030000();
char sub_10030170();
char sub_10030260();
char sub_100303C0();
char sub_10030520();
char sub_10030680();
char sub_100307F0();
char sub_10030950();
char sub_10030AB0();
char sub_10030CB0();
char sub_10030E10();
char sub_10030F70();
char sub_100310D0();
char sub_10031240();
char sub_100313A0();
char sub_10031500();
char sub_10031AA0();
char sub_10031CB0();
char sub_10031EA0();
char sub_10032010();
char sub_10032180();
char sub_100322E0();
char sub_100323D0();
char sub_10032530();
char sub_10032690();
char sub_100327F0();
char sub_10032960();
char sub_10032AC0();
char sub_10032C20();
char sub_10032E20();
char sub_10032F80();
char sub_100330E0();
char sub_10033240();
char sub_100333B0();
char sub_10033510();
char sub_10033670();
char sub_10033880();
char sub_10033A70();
char sub_10033BE0();
char sub_10033D50();
char sub_10033EB0();
char sub_10033FA0();
char sub_10034100();
char sub_10034260();
char sub_100343C0();
char sub_10034530();
char sub_10034690();
char sub_100347F0();
char sub_100349F0();
char sub_10034B50();
char sub_10034CB0();
char sub_10034E10();
char sub_10034F80();
char sub_100350E0();
char **sub_10035240();
int __cdecl sub_10035250(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10035270@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10035280@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_100354B0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10035500(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10035550(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_100355A0(int a1))(int);
int __cdecl sub_10035620(int a1, int a2);
int (__cdecl *__cdecl sub_100356A0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_100356F0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10035730(int a1, int a2, int a3))(int);
int __cdecl sub_10035790(char a1);
BOOL __cdecl sub_100357E0(unsigned __int8 a1);
// BOOL __usercall sub_100357F0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10035820(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_100359D0(unsigned __int8 a1, int a2);
bool __cdecl sub_10035A10(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_10035B00(int a1, int a2);
char __cdecl sub_10035B20(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
int __cdecl sub_10035BF0(char a1, char a2);
// bool __usercall sub_10035CA0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10035CD0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10035D70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10035DF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10035E70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10035EF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10035F70(char a1);
bool __cdecl sub_10036010(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_100360A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_10036140(char a1);
char __cdecl sub_100361C0(char a1, int a2);
// int __usercall sub_10036330@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10036370@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_100363B0();
char __cdecl sub_100363C0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10036420(char a1, void *a2);
char __cdecl sub_10036540(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100365C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_10036770(char a1);
int __cdecl sub_10036790(int, void *); // idb
// int __usercall sub_100367F0@<eax>(char a1@<al>);
BOOL __cdecl sub_10036820(char a1, int a2);
int __cdecl sub_10036850(int, char, int, int, void *); // idb
char __cdecl sub_10036880(void *a1);
BOOL __cdecl sub_100368A0(int a1);
char __cdecl sub_100368C0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_100368F0(char a1, void *a2);
// signed int __usercall sub_10036930@<eax>(char a1@<al>);
bool __cdecl sub_10036950(char a1, void *a2);
bool __cdecl sub_10036A40(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10036A70(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10036B10(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10036B90(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10036C00(char a1, void *a2);
char __cdecl sub_10036C80(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10036D00(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10036D80(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10036DF0(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10036F00(char a1, void *a2);
bool __cdecl sub_10036F20(unsigned __int8 a1, char *a2);
char __cdecl sub_10036F60(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10036FA0();
char __cdecl sub_10037000(int a1, char *a2);
BOOL __cdecl sub_100370F0(int a1, int a2);
char __cdecl sub_10037110(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10037150(int a1, int a2);
BOOL __cdecl sub_10037200(int a1, int a2);
char __cdecl sub_10037220(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10037260(void *a1);
char __cdecl sub_10037280(void *a1);
char __cdecl sub_100373D0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10037570(char a1);
// __int16 __usercall sub_100375B0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_100375C0(unsigned __int8 a1, char *a2);
char __cdecl sub_10037690(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10037710(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10037840(char a1, int a2);
bool __cdecl sub_100378C0(void *a1);
char __cdecl sub_10037910(char a1, int a2);
// __int16 __usercall sub_100379F0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10037A00(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10037A90(unsigned __int8 a1, char a2);
bool __cdecl sub_10037B50(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10037C50(char a1);
char __cdecl sub_10037C90(char a1);
// int TXT_get_static_string(void); weak
__int16 __cdecl sub_10037CB0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_10037CF0(int a1, _DWORD *a2, _BYTE *a3);
__int16 __cdecl sub_10037D50(int a1, _DWORD *a2);
int __cdecl sub_10037D70(int, float); // idb
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD); // weak
int __cdecl sub_10037DB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_clear(_DWORD); // weak
int __cdecl sub_10037E20(float, float, float, float); // idb
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_depth_func(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl sub_10037E80(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int j_gdi_pvg_end(void); // weak
int j_gdi_pvg_flush(void); // weak
int __cdecl sub_10037F00(float, float, float, float, float, float); // idb
int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD); // weak
int sub_10037F50();
int __cdecl sub_10037F60(float); // idb
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10037FB0(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_matrix(void); // weak
int j_gdi_pvg_push_matrix(void); // weak
int __cdecl sub_10038010(float, float, float, float); // idb
int __cdecl sub_10038040(float, float, float); // idb
int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10038080(float, float); // idb
int __cdecl sub_100380A0(int, int, float); // idb
int __cdecl sub_100380C0(int a1, char a2, char a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10);
int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10038140(float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_10038180(float, float); // idb
int __cdecl sub_100381A0(float, float, float); // idb
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100381E0(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10038220();
int __cdecl sub_10038270(int a1);
int __cdecl sub_10038280(int a1);
int __cdecl sub_10038290(int a1);
int __cdecl sub_100382A0(int a1);
int sub_100382C0();
int __cdecl sub_100382E0(int a1, int a2);
__int16 __cdecl sub_10038310(int a1);
int sub_10038330();
int __cdecl sub_10038350(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10038390(int a1, int a2, int a3, int a4);
int __cdecl sub_100383C0(int a1);
int __cdecl sub_100383E0(int a1);
int __cdecl sub_10038400(int a1, int a2);
int __cdecl sub_10038430(int a1, int a2);
int __cdecl sub_10038460(int a1, int a2, int a3, int a4);
int __cdecl sub_10038490(int a1, int a2);
int __cdecl sub_100384C0(int a1);
int __cdecl sub_100384E0(int a1);
char __cdecl sub_10038500(int a1, int a2);
int __cdecl sub_10038570(_BYTE *a1);
int sub_100385B0();
int __cdecl sub_100385D0(int a1, int a2);
int __cdecl sub_10038600(int a1, int a2);
int __cdecl sub_10038620(int a1);
int __cdecl sub_10038660(int a1, int a2, int a3);
char __cdecl sub_10038680(int a1, int a2, int a3);
int __cdecl sub_100386C0(int, void *, int, void *); // idb
int __cdecl sub_10038700(int a1, int a2, int a3);
int __cdecl sub_10038730(int a1, int a2, int a3);
int __cdecl sub_10038750(int a1, int a2, int a3);
int __cdecl sub_100387B0(int a1, int a2, int a3);
int __cdecl sub_100387F0(int, void *, int, void *); // idb
int __cdecl sub_10038840(unsigned int a1);
void sub_10038860();
signed int __fastcall sub_10038870(char *a1);
// char __usercall sub_100388C0@<al>(int a1@<eax>, char *a2@<ecx>, unsigned int a3);
// int __usercall sub_10038990@<eax>(unsigned int a1@<eax>);
int __cdecl sub_100389A0(int, int, char *); // idb
// int __usercall sub_10038A90@<eax>(_BYTE *a1@<eax>, signed int a2@<ecx>, signed int a3, int a4, int a5, _BYTE *a6);
_BYTE *__cdecl sub_10038B70(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
double __cdecl sub_10038C80(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_10038E20(int a1, int a2, float a3);
unsigned int __cdecl sub_10038E80(char *a1);
char __cdecl sub_10038EF0(char *a1);
bool __cdecl sub_100390D0(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10039310(char *a1);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10039360(unsigned int a1);
signed int __cdecl sub_100393A0(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100393F0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10039460(unsigned int a1, void *a2, int a3);
int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100394B0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10039540(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10039590(int a1);
int __cdecl sub_100395B0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100395E0(int a1, int a2, int a3, char a4);
char __cdecl sub_10039600(int a1);
char __cdecl sub_10039630(int a1);
int __cdecl sub_10039660(unsigned int a1, unsigned int a2);
int __cdecl sub_100396B0(int a1, int a2, int a3);
signed int __cdecl sub_100396D0(unsigned int a1, int a2, int a3);
int __cdecl sub_100396F0(int a1, int a2, int a3);
int __cdecl sub_10039710(int a1, unsigned int a2);
void __cdecl sub_10039740(int a1, _BYTE *a2);
int __cdecl sub_10039770(int a1, int a2);
int __cdecl sub_10039790(int a1, int a2);
// int __usercall sub_100397F0@<eax>(const char **a1@<esi>);
// int __usercall sub_10039AF0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_10039B10(int a1);
int sub_10039BE0(void); // weak
int __cdecl j_SYS_pvg_actvte_pilot_prof(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_10039C00(int a1, int a2, unsigned int a3);
int __cdecl j_HWM_pvg_get_rgb(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
unsigned int __cdecl sub_10039CD0(int a1, unsigned int a2);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10039D50(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10039DA0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_10039E10(int a1);
int __cdecl sub_10039E50(int a1);
int __cdecl sub_10039E90(int a1);
int __cdecl sub_10039ED0(int a1);
int __cdecl sub_10039F10(int a1, int a2, int a3, int a4);
int __cdecl sub_10039F80(int a1, int a2, int a3);
int sub_1003A020(void); // weak
signed int sub_1003A040();
int __cdecl sub_1003A050(unsigned int a1);
unsigned int __cdecl sub_1003A0B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1003A260@<eax>(int a1@<esi>);
int __cdecl sub_1003A310(int a1, unsigned __int64 a2);
// int __usercall sub_1003A3C0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_1003A450(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_1003A5A0(__int16 a1, _BYTE *a2);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
_WORD *__cdecl sub_1003A5E0(int a1);
int __cdecl sub_1003A640(int a1, int a2, char a3);
int __cdecl sub_1003A730(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_1003A840(char, void *, size_t, int); // idb
// int __usercall sub_1003A870@<eax>(int a1@<esi>);
int __cdecl sub_1003A8B0(_WORD *a1, _DWORD *a2);
int __cdecl sub_1003A910(char, void *, size_t, int, size_t, int, size_t, int, size_t, int, int, int, size_t); // idb
int __cdecl sub_1003AC20(int, void *); // idb
int __cdecl sub_1003AC60(int a1, _DWORD *a2);
char __cdecl sub_1003AC80(_DWORD *a1, _WORD *a2, _DWORD *a3);
char sub_1003ACE0();
void *sub_1003ADA0();
void __cdecl sub_1003ADD0(int a1, signed int a2, signed int a3);
signed int sub_1003AE20();
int __cdecl sub_1003AF60(int a1, int a2, int a3);
double __cdecl sub_1003AF90(int a1, int a2);
double __cdecl sub_1003AFC0(int a1);
int __cdecl sub_1003B000(float, int, int); // idb
int __cdecl sub_1003B030(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1003B050(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_1003B180(float a1, float a2);
double __cdecl sub_1003B220(float a1, float a2);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_alpha_func(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_frustum(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_scalef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_image_2d(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex3f(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// int sprintf(char *, const char *, ...);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int __cdecl rand();
// char *__cdecl strchr(const char *, int);
// char *__cdecl strrchr(const char *, int);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003D432(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_1003ED7E(int, FILE *); // idb
int __cdecl sub_1003F913(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10040015(_DWORD *a1);
signed int __cdecl sub_1004004C(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10040C92();
int (*sub_1004113F())(void);
void __cdecl sub_10041163(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_100450CF(FILE *, int, struct localeinfo_struct *, int); // idb
void sub_10047A9B();
// int _get_sse2_info(void); weak
int sub_10047B53();
int __cdecl sub_10047B60(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10047C06(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_10048115(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_100482B1(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_100488D3(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_100489F3(signed int a1);
void **sub_10048A51();
signed int sub_10048A57();
// int __cdecl _fileno(FILE *);
int sub_10049392();
int __cdecl sub_1004954F(int a1);
int __cdecl sub_10049559(int a1);
int __cdecl sub_10049563(int a1);
int __cdecl sub_10049642(int a1);
signed int __cdecl sub_1004AD19(int a1, int a2);
signed int __cdecl sub_1004B25B(int a1, int a2);
int __cdecl sub_1004BD75(FILE *); // idb
int __cdecl sub_1004BE95(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_1004C0DD();
signed int __cdecl sub_1004D5B9(signed int a1);
signed int __cdecl sub_1004D63A(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1004D74B(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1004DA4C();
int __cdecl sub_1004DA55(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1004E861(signed int a1);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_100294C0; // weak
int dword_1004F32C = 1953393967; // weak
__int16 word_1004F3E0 = 47; // weak
int dword_1004FF38[] = { 7 }; // weak
int (__cdecl *off_1004FF3C)(int, int, int, int, int) = &sub_10009B40; // weak
int dword_1004FF40[] = { 16 }; // weak
_UNKNOWN unk_10050570; // weak
_UNKNOWN unk_10050590; // weak
_UNKNOWN unk_10051D94; // weak
_UNKNOWN unk_10052360; // weak
_UNKNOWN unk_10052374; // weak
_UNKNOWN unk_1005239C; // weak
_UNKNOWN unk_10052406; // weak
char asc_100529DC[4] = "   "; // weak
_UNKNOWN unk_10052A30; // weak
_UNKNOWN unk_10052A50; // weak
_UNKNOWN unk_10052A70; // weak
_UNKNOWN unk_10052A78; // weak
_UNKNOWN unk_10052A80; // weak
_UNKNOWN unk_10052A88; // weak
_UNKNOWN unk_10052C5C; // weak
_UNKNOWN unk_10052C68; // weak
_UNKNOWN unk_10052CBC; // weak
_UNKNOWN unk_10052CE8; // weak
_UNKNOWN unk_10052D3C; // weak
_UNKNOWN unk_10052D58; // weak
_UNKNOWN unk_10052D98; // weak
_UNKNOWN unk_10052DB0; // weak
_UNKNOWN unk_10052DC8; // weak
_UNKNOWN unk_10052F30; // weak
_UNKNOWN unk_10052FD4; // weak
_UNKNOWN unk_10052FEC; // weak
_UNKNOWN unk_10053008; // weak
_UNKNOWN unk_100530A0; // weak
_UNKNOWN unk_100531D4; // weak
_UNKNOWN unk_100531F4; // weak
_UNKNOWN unk_10053208; // weak
_UNKNOWN unk_1005321C; // weak
_UNKNOWN unk_10053224; // weak
_UNKNOWN unk_10053234; // weak
_UNKNOWN unk_1005323C; // weak
_UNKNOWN unk_10053244; // weak
_UNKNOWN unk_10053254; // weak
_UNKNOWN unk_1005325C; // weak
_UNKNOWN unk_10053264; // weak
char word_10053650[] = { ' ', '\0' }; // idb
_UNKNOWN unk_1005377D; // weak
void *off_10054F84 = &unk_103F9618; // weak
char byte_10055A34[] = { '\0' }; // weak
int (__cdecl *off_10055A40)(int) = &sub_100077A0; // weak
char byte_10055A44[] = { '\0' }; // weak
char aPowerUpPage[14] = "POWER-UP PAGE"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_100593D6; // weak
_UNKNOWN unk_10059900; // weak
char aDefaultProfi_0[16] = "DEFAULT PROFILE"; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_100630D4; // weak
_UNKNOWN unk_100630DC; // weak
_UNKNOWN unk_100630E4; // weak
_UNKNOWN unk_100630EC; // weak
_UNKNOWN unk_10063198; // weak
void *off_1006319C = &unk_1006310C; // weak
char *off_10064358[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100641C8 }; // weak
_UNKNOWN unk_1006436C; // weak
char byte_100654D8[] = { '\0' }; // weak
_UNKNOWN unk_100661F0; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_1006A0C0 = "006-D0170-"; // weak
int (__cdecl *(*off_1006A0C4)[2])(int, int) = &off_1008F7F8; // weak
int (__cdecl *off_1006B7A8)(int, size_t, void *) = &sub_100140D0; // weak
int dword_1006C9C4[] = { 88 }; // weak
__int16 word_1006CE74[] = { 836 }; // weak
char *off_1006CE94 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1006CEA8 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1006CEBC = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1006CED0 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1006CEE4 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1006CEF8 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int (*off_1006D4D8[4])() = { &sub_10014F50, &sub_10014F40, &sub_10014F30, &sub_10014F40 }; // weak
int dword_1006EA98 = 1391376; // weak
int (__cdecl *off_10072458[3])(char) = { &sub_1000E900, &sub_1000E810, &sub_1000E7D0 }; // weak
_UNKNOWN unk_100870E8; // weak
char *off_10087F84 = "Cannot send message. Data radio failed."; // weak
_UNKNOWN unk_10087FA0; // weak
__int16 word_10087FA8[] = { 43 }; // weak
char byte_10087FAC[] = { '\x06' }; // weak
_UNKNOWN unk_100885B0; // weak
char *off_10088754[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_10088768 }; // weak
char *off_100888F8 = "true"; // weak
char byte_100888FC[] = { '\x01' }; // weak
char *off_10088960 = "failure listener"; // weak
_UNKNOWN unk_10089100; // weak
char *off_10089300[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_10089308[3] = { "normal", "robust", "EQ" }; // weak
char *off_10089310 = "EQ"; // weak
char *off_1008932C[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10089338[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_10089340[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100895F8; // weak
_UNKNOWN unk_1008963C; // weak
char *off_100899F8 = "printf_listener"; // weak
__int16 word_1008A62C = 2573; // weak
int (*off_1008A6E8[2])() = { &sub_10035240, &sub_1000F030 }; // weak
char *off_1008A798 = "gate_listener"; // weak
_WORD dword_1008B848[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_1008BC48[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_1008C048[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_1008C448[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_1008C848[] = { 99 }; // weak
int dword_1008CC48[] = { 25344 }; // weak
int dword_1008D048[] = { 6488064 }; // weak
int dword_1008D448[] = { 1660944384 }; // weak
int dword_1008D870[] = { 128 }; // weak
int dword_1008D880[] = { 0 }; // weak
int dword_1008D890[] = { 0 }; // weak
char byte_1008D901[] = { '\0' }; // weak
char byte_1008D902[] = { '\0' }; // weak
char byte_1008D903[] = { '\0' }; // weak
char byte_1008D904[] = { '\x10' }; // weak
int dword_1008D918[] = { 0 }; // weak
_UNKNOWN unk_1008D990; // weak
_UNKNOWN unk_1008DE10; // weak
char byte_1008DE88[] = { '\0' }; // weak
char byte_1008DF88[] = { '\0' }; // weak
char byte_1008E088[] = { '\0' }; // weak
int dword_1008E188[] = { 0 }; // weak
int dword_1008E200[] = { 0 }; // weak
__int16 word_1008E278[] = { 0 }; // weak
__int16 word_1008E27A[] = { 0 }; // weak
__int16 word_1008E27C[] = { 0 }; // weak
__int16 word_1008E27E[] = { 0 }; // weak
int (__cdecl *off_1008E280)(int, int) = &sub_10028870; // weak
void *off_1008E42C = &unk_1008D990; // weak
void *off_1008E440 = &unk_1008DE10; // weak
_UNKNOWN unk_1008E454; // weak
int dword_1008E468[] = { 0 }; // weak
int dword_1008E4B0[] = { 16 }; // weak
_UNKNOWN unk_1008E500; // weak
_UNKNOWN unk_1008E580; // weak
_UNKNOWN unk_1008E600; // weak
_UNKNOWN unk_1008E678; // weak
_UNKNOWN unk_1008E6F0; // weak
_UNKNOWN unk_1008F6F0; // weak
int (__cdecl *off_1008F7F8[2])(int, int) = { &sub_1002ABE0, &sub_1002AC40 }; // weak
int dword_1008F800[] = { 1600085855 }; // weak
_UNKNOWN unk_100906C0; // weak
char byte_100906C1[] = { '\0' }; // weak
_UNKNOWN unk_10091500; // weak
int dword_10091504[] = { 1312 }; // weak
_UNKNOWN unk_10093250; // weak
int dword_10093254[] = { 6006 }; // weak
_UNKNOWN unk_10096D20; // weak
_UNKNOWN unk_10096D38; // weak
_UNKNOWN unk_10096D80; // weak
int dword_10096D84[] = { 6767 }; // weak
_UNKNOWN unk_10096D90; // weak
_UNKNOWN unk_10096DA8; // weak
_UNKNOWN unk_10096DC0; // weak
int dword_10096DC4[] = { 6769 }; // weak
_UNKNOWN unk_10096DD8; // weak
int dword_10096DDC[] = { 6093 }; // weak
_UNKNOWN unk_10098BE0; // weak
_UNKNOWN unk_10098C04; // weak
_UNKNOWN unk_10098DA8; // weak
char off_100999D8[] = { '', '', '\b', '\x10' }; // idb
int dword_100999F4 = 1; // idb
char byte_10099A10[] = { '\x01' }; // weak
char *off_10099A14[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_10099A18[2] = { "2", "fail_normal_1" }; // weak
char off_10099A1C[8] = { '', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10099AA0[] = { '\0' }; // weak
char byte_10099AA1[] = { '\0' }; // weak
int dword_10099AA4[] = { 0 }; // weak
char *off_10099AA8 = "0, 0, 0"; // weak
double dbl_10099D10[] = {  0.0 }; // weak
double dbl_10099D18[] = {  0.0 }; // weak
double dbl_10099D20[] = {  0.0 }; // weak
int dword_10099D28[] = { 0 }; // weak
char off_10099D2C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1009A930[] = {  0.0 }; // weak
float flt_1009A934[] = {  0.0 }; // weak
float flt_1009A938[] = {  0.0 }; // weak
int dword_1009A93C[] = { 0 }; // weak
char *off_1009A940 = "0, 0, 0"; // weak
char *off_1009B0C4[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100AFD20
}; // weak
int dword_1009B0D8[] = { 0 }; // weak
int dword_1009B0DC[] = { 0 }; // weak
int dword_1009B0E0[] = { 0 }; // weak
int dword_1009B0E4[] = { 0 }; // weak
char off_1009B0E8[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1009B870[] = { 0 }; // weak
__int16 word_1009B872[] = { 0 }; // weak
__int16 word_1009B874[] = { 0 }; // weak
int dword_1009B878[] = { 0 }; // weak
char off_1009B87C[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009BE80[] = { 0 }; // weak
int dword_1009BE84[] = { 0 }; // weak
int dword_1009BE88[] = { 0 }; // weak
int dword_1009BE8C[] = { 0 }; // weak
char *off_1009BE90 = "0, 0, 0"; // weak
int dword_1009C618[] = { 0 }; // weak
int dword_1009C61C[] = { 0 }; // weak
int dword_1009C620[] = { 0 }; // weak
int dword_1009C624[] = { 0 }; // weak
int dword_1009C628[] = { 0 }; // weak
int dword_1009C62C[] = { 0 }; // weak
int dword_1009C630[] = { 0 }; // weak
char off_1009C634[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1009D238[] = { '\0' }; // weak
char byte_1009D239[] = { '\0' }; // weak
char byte_1009D23A[] = { '\0' }; // weak
int dword_1009D23C[] = { 0 }; // weak
char *off_1009D240 = "0, 0, 0"; // weak
int dword_1009D6C8[] = { 0 }; // weak
int dword_1009D6CC[] = { 0 }; // weak
int dword_1009D6D0[] = { 0 }; // weak
int dword_1009D6D4[] = { 0 }; // weak
char off_1009D6D8[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009DE60[] = { 0 }; // weak
int dword_1009DE64[] = { 0 }; // weak
int dword_1009DE68[] = { 0 }; // weak
int dword_1009DE6C[] = { 0 }; // weak
char *off_1009DE70 = "0, 0, 0"; // weak
__int16 word_1009E1D0[] = { 0 }; // weak
__int16 word_1009E1D2[] = { 0 }; // weak
__int16 word_1009E1D4[] = { 0 }; // weak
int dword_1009E1D8[] = { 0 }; // weak
char off_1009E1DC[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009E490[] = { 0 }; // weak
int dword_1009E494[] = { 0 }; // weak
int dword_1009E498[] = { 0 }; // weak
int dword_1009E49C[] = { 0 }; // weak
char *off_1009E4A0 = "0, 0, 0"; // weak
int dword_1009E800[] = { 0 }; // weak
int dword_1009E804[] = { 0 }; // weak
int dword_1009E808[] = { 0 }; // weak
int dword_1009E80C[] = { 0 }; // weak
int dword_1009E810[] = { 0 }; // weak
int dword_1009E814[] = { 0 }; // weak
int dword_1009E818[] = { 0 }; // weak
char off_1009E81C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1009ED80[] = { '\0' }; // weak
char byte_1009ED81[] = { '\0' }; // weak
char byte_1009ED82[] = { '\0' }; // weak
int dword_1009ED84[] = { 0 }; // weak
char *off_1009ED88 = "0, 0, 0"; // weak
int dword_1009EF90[] = { 0 }; // weak
int dword_1009EF94[] = { 0 }; // weak
int dword_1009EF98[] = { 0 }; // weak
int dword_1009EF9C[] = { 0 }; // weak
char *off_1009EFA0 = "0, 0, 0"; // weak
char byte_1009F300[] = { '\x01' }; // weak
char *off_1009F304[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_1009F308[2] = { "2", "fail_robust_1" }; // weak
char off_1009F30C[8] = { '8', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1009F390[] = { '\0' }; // weak
char byte_1009F391[] = { '\0' }; // weak
int dword_1009F394[] = { 0 }; // weak
char *off_1009F398 = "0, 0, 0"; // weak
double dbl_1009F600[] = {  0.0 }; // weak
double dbl_1009F608[] = {  0.0 }; // weak
double dbl_1009F610[] = {  0.0 }; // weak
int dword_1009F618[] = { 0 }; // weak
char off_1009F61C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100A0220[] = {  0.0 }; // weak
float flt_100A0224[] = {  0.0 }; // weak
float flt_100A0228[] = {  0.0 }; // weak
int dword_100A022C[] = { 0 }; // weak
char *off_100A0230 = "0, 0, 0"; // weak
int dword_100A09B8[] = { 0 }; // weak
int dword_100A09BC[] = { 0 }; // weak
int dword_100A09C0[] = { 0 }; // weak
int dword_100A09C4[] = { 0 }; // weak
char off_100A09C8[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A1150[] = { 0 }; // weak
__int16 word_100A1152[] = { 0 }; // weak
__int16 word_100A1154[] = { 0 }; // weak
int dword_100A1158[] = { 0 }; // weak
char off_100A115C[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A1760[] = { 0 }; // weak
int dword_100A1764[] = { 0 }; // weak
int dword_100A1768[] = { 0 }; // weak
int dword_100A176C[] = { 0 }; // weak
char *off_100A1770 = "0, 0, 0"; // weak
int dword_100A1EF8[] = { 0 }; // weak
int dword_100A1EFC[] = { 0 }; // weak
int dword_100A1F00[] = { 0 }; // weak
int dword_100A1F04[] = { 0 }; // weak
int dword_100A1F08[] = { 0 }; // weak
int dword_100A1F0C[] = { 0 }; // weak
int dword_100A1F10[] = { 0 }; // weak
char off_100A1F14[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A2B18[] = { '\0' }; // weak
char byte_100A2B19[] = { '\0' }; // weak
char byte_100A2B1A[] = { '\0' }; // weak
int dword_100A2B1C[] = { 0 }; // weak
char *off_100A2B20 = "0, 0, 0"; // weak
int dword_100A2FA8[] = { 0 }; // weak
int dword_100A2FAC[] = { 0 }; // weak
int dword_100A2FB0[] = { 0 }; // weak
int dword_100A2FB4[] = { 0 }; // weak
char off_100A2FB8[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A3740[] = { 0 }; // weak
int dword_100A3744[] = { 0 }; // weak
int dword_100A3748[] = { 0 }; // weak
int dword_100A374C[] = { 0 }; // weak
char *off_100A3750 = "0, 0, 0"; // weak
__int16 word_100A3AB0[] = { 0 }; // weak
__int16 word_100A3AB2[] = { 0 }; // weak
__int16 word_100A3AB4[] = { 0 }; // weak
int dword_100A3AB8[] = { 0 }; // weak
char off_100A3ABC[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A3D70[] = { 0 }; // weak
int dword_100A3D74[] = { 0 }; // weak
int dword_100A3D78[] = { 0 }; // weak
int dword_100A3D7C[] = { 0 }; // weak
char *off_100A3D80 = "0, 0, 0"; // weak
int dword_100A40E0[] = { 0 }; // weak
int dword_100A40E4[] = { 0 }; // weak
int dword_100A40E8[] = { 0 }; // weak
int dword_100A40EC[] = { 0 }; // weak
int dword_100A40F0[] = { 0 }; // weak
int dword_100A40F4[] = { 0 }; // weak
int dword_100A40F8[] = { 0 }; // weak
char off_100A40FC[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A4660[] = { '\0' }; // weak
char byte_100A4661[] = { '\0' }; // weak
char byte_100A4662[] = { '\0' }; // weak
int dword_100A4664[] = { 0 }; // weak
char *off_100A4668 = "0, 0, 0"; // weak
int dword_100A4870[] = { 0 }; // weak
int dword_100A4874[] = { 0 }; // weak
int dword_100A4878[] = { 0 }; // weak
int dword_100A487C[] = { 0 }; // weak
char *off_100A4880 = "0, 0, 0"; // weak
char byte_100A4BE0[] = { '\x01' }; // weak
char *off_100A4BE4[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100A4BE8[2] = { "1", "pass_normal_1" }; // weak
char off_100A4BEC[8] = { '', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A4C30[] = { '\0' }; // weak
char byte_100A4C31[] = { '\0' }; // weak
int dword_100A4C34[] = { 0 }; // weak
char *off_100A4C38 = "0, 0, 0"; // weak
double dbl_100A4EA0[] = {  0.0 }; // weak
double dbl_100A4EA8[] = {  0.0 }; // weak
double dbl_100A4EB0[] = {  0.0 }; // weak
int dword_100A4EB8[] = { 0 }; // weak
char off_100A4EBC[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100A5AC0[] = {  0.0 }; // weak
float flt_100A5AC4[] = {  0.0 }; // weak
float flt_100A5AC8[] = {  0.0 }; // weak
int dword_100A5ACC[] = { 0 }; // weak
char *off_100A5AD0 = "0, 0, 0"; // weak
int dword_100A6258[] = { 0 }; // weak
int dword_100A625C[] = { 0 }; // weak
int dword_100A6260[] = { 0 }; // weak
int dword_100A6264[] = { 0 }; // weak
char off_100A6268[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A69F0[] = { 0 }; // weak
__int16 word_100A69F2[] = { 0 }; // weak
__int16 word_100A69F4[] = { 0 }; // weak
int dword_100A69F8[] = { 0 }; // weak
char off_100A69FC[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A7000[] = { 0 }; // weak
int dword_100A7004[] = { 0 }; // weak
int dword_100A7008[] = { 0 }; // weak
int dword_100A700C[] = { 0 }; // weak
char *off_100A7010 = "0, 0, 0"; // weak
int dword_100A7798[] = { 0 }; // weak
int dword_100A779C[] = { 0 }; // weak
int dword_100A77A0[] = { 0 }; // weak
int dword_100A77A4[] = { 0 }; // weak
int dword_100A77A8[] = { 0 }; // weak
int dword_100A77AC[] = { 0 }; // weak
int dword_100A77B0[] = { 0 }; // weak
char off_100A77B4[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A83B8[] = { '\0' }; // weak
char byte_100A83B9[] = { '\0' }; // weak
char byte_100A83BA[] = { '\0' }; // weak
int dword_100A83BC[] = { 0 }; // weak
char *off_100A83C0 = "0, 0, 0"; // weak
int dword_100A8848[] = { 0 }; // weak
int dword_100A884C[] = { 0 }; // weak
int dword_100A8850[] = { 0 }; // weak
int dword_100A8854[] = { 0 }; // weak
char off_100A8858[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A8FE0[] = { 0 }; // weak
int dword_100A8FE4[] = { 0 }; // weak
int dword_100A8FE8[] = { 0 }; // weak
int dword_100A8FEC[] = { 0 }; // weak
char *off_100A8FF0 = "0, 0, 0"; // weak
__int16 word_100A9350[] = { 0 }; // weak
__int16 word_100A9352[] = { 0 }; // weak
__int16 word_100A9354[] = { 0 }; // weak
int dword_100A9358[] = { 0 }; // weak
char off_100A935C[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A9610[] = { 0 }; // weak
int dword_100A9614[] = { 0 }; // weak
int dword_100A9618[] = { 0 }; // weak
int dword_100A961C[] = { 0 }; // weak
char *off_100A9620 = "0, 0, 0"; // weak
int dword_100A9980[] = { 0 }; // weak
int dword_100A9984[] = { 0 }; // weak
int dword_100A9988[] = { 0 }; // weak
int dword_100A998C[] = { 0 }; // weak
int dword_100A9990[] = { 0 }; // weak
int dword_100A9994[] = { 0 }; // weak
int dword_100A9998[] = { 0 }; // weak
char off_100A999C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A9F00[] = { '\0' }; // weak
char byte_100A9F01[] = { '\0' }; // weak
char byte_100A9F02[] = { '\0' }; // weak
int dword_100A9F04[] = { 0 }; // weak
char *off_100A9F08 = "0, 0, 0"; // weak
int dword_100AA110[] = { 0 }; // weak
int dword_100AA114[] = { 0 }; // weak
int dword_100AA118[] = { 0 }; // weak
int dword_100AA11C[] = { 0 }; // weak
char *off_100AA120 = "0, 0, 0"; // weak
char byte_100AA480[] = { '\x01' }; // weak
char *off_100AA484[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100AA488[2] = { "1", "pass_robust_1" }; // weak
char off_100AA48C[8] = { 'X', '', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100AA4D0[] = { '\0' }; // weak
char byte_100AA4D1[] = { '\0' }; // weak
int dword_100AA4D4[] = { 0 }; // weak
char *off_100AA4D8 = "0, 0, 0"; // weak
double dbl_100AA740[] = {  0.0 }; // weak
double dbl_100AA748[] = {  0.0 }; // weak
double dbl_100AA750[] = {  0.0 }; // weak
int dword_100AA758[] = { 0 }; // weak
char off_100AA75C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100AB360[] = {  0.0 }; // weak
float flt_100AB364[] = {  0.0 }; // weak
float flt_100AB368[] = {  0.0 }; // weak
int dword_100AB36C[] = { 0 }; // weak
char *off_100AB370 = "0, 0, 0"; // weak
int dword_100ABAF8[] = { 0 }; // weak
int dword_100ABAFC[] = { 0 }; // weak
int dword_100ABB00[] = { 0 }; // weak
int dword_100ABB04[] = { 0 }; // weak
char off_100ABB08[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100AC290[] = { 0 }; // weak
__int16 word_100AC292[] = { 0 }; // weak
__int16 word_100AC294[] = { 0 }; // weak
int dword_100AC298[] = { 0 }; // weak
char off_100AC29C[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AC8A0[] = { 0 }; // weak
int dword_100AC8A4[] = { 0 }; // weak
int dword_100AC8A8[] = { 0 }; // weak
int dword_100AC8AC[] = { 0 }; // weak
char *off_100AC8B0 = "0, 0, 0"; // weak
int dword_100AD038[] = { 0 }; // weak
int dword_100AD03C[] = { 0 }; // weak
int dword_100AD040[] = { 0 }; // weak
int dword_100AD044[] = { 0 }; // weak
int dword_100AD048[] = { 0 }; // weak
int dword_100AD04C[] = { 0 }; // weak
int dword_100AD050[] = { 0 }; // weak
char off_100AD054[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100ADC58[] = { '\0' }; // weak
char byte_100ADC59[] = { '\0' }; // weak
char byte_100ADC5A[] = { '\0' }; // weak
int dword_100ADC5C[] = { 0 }; // weak
char *off_100ADC60 = "0, 0, 0"; // weak
int dword_100AE0E8[] = { 0 }; // weak
int dword_100AE0EC[] = { 0 }; // weak
int dword_100AE0F0[] = { 0 }; // weak
int dword_100AE0F4[] = { 0 }; // weak
char off_100AE0F8[20] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AE880[] = { 0 }; // weak
int dword_100AE884[] = { 0 }; // weak
int dword_100AE888[] = { 0 }; // weak
int dword_100AE88C[] = { 0 }; // weak
char *off_100AE890 = "0, 0, 0"; // weak
__int16 word_100AEBF0[] = { 0 }; // weak
__int16 word_100AEBF2[] = { 0 }; // weak
__int16 word_100AEBF4[] = { 0 }; // weak
int dword_100AEBF8[] = { 0 }; // weak
char off_100AEBFC[16] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AEEB0[] = { 0 }; // weak
int dword_100AEEB4[] = { 0 }; // weak
int dword_100AEEB8[] = { 0 }; // weak
int dword_100AEEBC[] = { 0 }; // weak
char *off_100AEEC0 = "0, 0, 0"; // weak
int dword_100AF220[] = { 0 }; // weak
int dword_100AF224[] = { 0 }; // weak
int dword_100AF228[] = { 0 }; // weak
int dword_100AF22C[] = { 0 }; // weak
int dword_100AF230[] = { 0 }; // weak
int dword_100AF234[] = { 0 }; // weak
int dword_100AF238[] = { 0 }; // weak
char off_100AF23C[32] =
{
  '(',
  '',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AF7A0[] = { '\0' }; // weak
char byte_100AF7A1[] = { '\0' }; // weak
char byte_100AF7A2[] = { '\0' }; // weak
int dword_100AF7A4[] = { 0 }; // weak
char *off_100AF7A8 = "0, 0, 0"; // weak
int dword_100AF9B0[] = { 0 }; // weak
int dword_100AF9B4[] = { 0 }; // weak
int dword_100AF9B8[] = { 0 }; // weak
int dword_100AF9BC[] = { 0 }; // weak
char *off_100AF9C0 = "0, 0, 0"; // weak
_UNKNOWN unk_100B09A0; // weak
int dword_100B3B7C[] = { 0 }; // weak
_UNKNOWN off_100B3B80; // weak
_UNKNOWN unk_100B3C10; // weak
_UNKNOWN unk_100B3C14; // weak
_UNKNOWN unk_100B3C18; // weak
_UNKNOWN unk_100B3C1C; // weak
_UNKNOWN unk_100B3C20; // weak
_UNKNOWN unk_100B3C24; // weak
_UNKNOWN unk_100B3C28; // weak
_UNKNOWN unk_100B3C2C; // weak
_UNKNOWN unk_100B56A0; // weak
int dword_100B56A4[] = { 0 }; // weak
__int16 word_100B67B0[] = { 1565 }; // weak
__int16 word_100B67B4[] = { 534 }; // weak
char byte_100B67B8[] = { '\x04' }; // weak
__int16 word_100B67BA[] = { 6512 }; // weak
int dword_100B67D0[] = { 118000 }; // weak
_UNKNOWN unk_100B8048; // weak
int dword_100B804C[] = { 0 }; // weak
_UNKNOWN unk_100B8060; // weak
int dword_100B8064[] = { 0 }; // weak
_UNKNOWN unk_100B8088; // weak
int dword_100B808C[] = { 0 }; // weak
_UNKNOWN unk_100B80B8; // weak
int dword_100B80BC[] = { 0 }; // weak
int dword_100BBB40 = 64; // weak
__int16 word_100BBB44[] = { 6782 }; // weak
__int16 word_100BBB48[] = { 128 }; // weak
_UNKNOWN unk_100BBB64; // weak
_DWORD dword_100BBB68[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_100BDA08 = "/shr_mem/iop_gtx_intf.shr"; // weak
int dword_100BDA4C[] = { 6829 }; // weak
__int16 word_100BEA82[] = { 233 }; // weak
int dword_100BEA88[] = { 6201 }; // weak
__int16 word_100C1638[] = { 114 }; // weak
__int16 word_100C1748[] = { 551 }; // weak
char byte_100C44D2[] = { '\x04' }; // weak
char byte_100C44D7[] = { '\a' }; // weak
_UNKNOWN unk_100CB030; // weak
_UNKNOWN unk_100CB034; // weak
_UNKNOWN unk_100CB038; // weak
_UNKNOWN unk_100CBB68; // weak
int dword_100CBB6C[] = { 3535 }; // weak
_UNKNOWN unk_100CBBA0; // weak
int dword_100CBBA4[] = { 6813 }; // weak
_UNKNOWN unk_100CBBD8; // weak
int dword_100CBBDC[] = { 9036 }; // weak
_UNKNOWN unk_100CBC10; // weak
int dword_100CBC14[] = { 6763 }; // weak
int dword_100CD810[] = { 6103 }; // weak
int dword_100CD814[] = { 8000 }; // weak
char *off_100CDE80 = "/shr_mem/cdp_mngr_intf.shr"; // weak
char *off_100CE8A0[3] = { "04T1", "04B1", "04A1" }; // weak
int dword_100CEE60[] = { 0 }; // weak
_UNKNOWN unk_100DD490; // weak
_UNKNOWN unk_100DD498; // weak
int (*off_100DF29C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100DF2F0; // weak
void *off_100DFCD0 = &unk_1077AEE0; // weak
_UNKNOWN unk_100DFCE0; // weak
_UNKNOWN unk_100DFD40; // weak
int dword_100DFF50 = 2; // weak
int dword_100E0120 = 1024; // weak
int dword_100E0124 = 4294966273; // weak
int dword_100E0128 = 53; // weak
int dword_100E012C = 11; // weak
int dword_100E0130 = 64; // weak
int dword_100E0134 = 1023; // weak
int dword_100E0138 = 128; // weak
int dword_100E013C = 4294967169; // weak
int dword_100E0140 = 24; // weak
int dword_100E0144 = 8; // weak
int dword_100E0148 = 32; // weak
int dword_100E014C = 127; // weak
_UNKNOWN unk_100E0780; // weak
_UNKNOWN unk_100E0800; // weak
__int16 word_100E0880 = 0; // weak
int dword_100E0882 = 0; // weak
int dword_100E0886 = 0; // weak
int dword_100E088A = 0; // weak
char byte_100E088E = '\0'; // weak
_UNKNOWN unk_100E0890; // weak
int dword_100E08A0 = 0; // weak
_UNKNOWN unk_100E85C0; // weak
char byte_100E85C4; // weak
int dword_100E85C8; // weak
_UNKNOWN unk_100E85D0; // weak
char byte_100E86A0; // weak
char byte_100E86A8; // idb
int dword_100E96A8; // weak
char byte_100E96B0[]; // weak
char byte_100E96B2; // weak
__int16 word_100E96B4[]; // weak
int dword_100E96B8; // weak
int dword_100E96BC; // weak
__int16 word_100E96C0[]; // weak
_UNKNOWN unk_100E96C8; // weak
char byte_100E975E; // weak
_UNKNOWN unk_100E9760; // weak
int dword_100E9A40; // weak
int dword_100E9A44; // weak
_UNKNOWN unk_100E9A48; // weak
void *dword_100E9E48; // idb
_UNKNOWN unk_100E9E50; // weak
_UNKNOWN unk_100EDE50; // weak
_UNKNOWN unk_100EDED0; // weak
_UNKNOWN unk_10325476; // weak
_UNKNOWN unk_103EDED0; // weak
_UNKNOWN unk_103F9618; // weak
_UNKNOWN unk_103F9620; // weak
int dword_104F96A0; // weak
float flt_104F96A4; // weak
int dword_104F96A8; // weak
_UNKNOWN unk_104F96B8; // weak
_UNKNOWN unk_104F96BC; // weak
int dword_104F97D0; // weak
int dword_104F97D4; // weak
int dword_104F97D8; // weak
char byte_104F97DC; // weak
char byte_104F97DD; // weak
int dword_104F97E0; // weak
int dword_104F97E4; // weak
_UNKNOWN unk_104F97E8; // weak
_UNKNOWN unk_10624DD3; // weak
int dword_10670878; // weak
void *dword_1067087C; // idb
int dword_10670880; // weak
int dword_10670884; // weak
int dword_10670888[]; // weak
int dword_1067088C[]; // weak
int dword_10670890; // weak
char *dword_1067089C; // idb
void (__cdecl *dword_1067C330[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_1067C350; // weak
__int16 word_10681544; // weak
__int16 word_10681548; // weak
__int16 word_1068154C; // weak
int dword_10681550; // weak
char byte_10694208; // weak
char byte_10694209; // weak
int dword_1069420C[]; // weak
int dword_10694220; // weak
_UNKNOWN unk_10694228; // weak
_UNKNOWN unk_10694229; // weak
_UNKNOWN unk_1069423F; // weak
_UNKNOWN unk_10694240; // weak
_UNKNOWN unk_10694241; // weak
_UNKNOWN unk_10694242; // weak
_UNKNOWN unk_10694244; // weak
_UNKNOWN unk_10694248; // weak
_UNKNOWN unk_1069424C; // weak
_UNKNOWN unk_1069426C; // weak
_UNKNOWN unk_1069428C; // weak
_UNKNOWN unk_106942AC; // weak
_UNKNOWN unk_106942CC; // weak
_UNKNOWN unk_106942EC; // weak
_UNKNOWN unk_1069430C; // weak
_UNKNOWN unk_1069432C; // weak
_UNKNOWN unk_1069434C; // weak
_UNKNOWN unk_1069436C; // weak
_UNKNOWN unk_1069438C; // weak
_UNKNOWN unk_106943AC; // weak
_UNKNOWN unk_106943CC; // weak
_UNKNOWN unk_106943EC; // weak
_UNKNOWN unk_1069440C; // weak
_UNKNOWN unk_1069442C; // weak
_UNKNOWN unk_1069444C; // weak
_UNKNOWN unk_1069446C; // weak
_UNKNOWN unk_1069448C; // weak
_UNKNOWN unk_106944AC; // weak
_UNKNOWN unk_106944CC; // weak
_UNKNOWN unk_106944EC; // weak
_UNKNOWN unk_1069450C; // weak
_UNKNOWN unk_1069452C; // weak
_UNKNOWN unk_1069454C; // weak
_UNKNOWN unk_1069456C; // weak
_UNKNOWN unk_1069458C; // weak
_UNKNOWN unk_106945AC; // weak
_UNKNOWN unk_106945CC; // weak
_UNKNOWN unk_106945D0; // weak
_UNKNOWN unk_106945D4; // weak
_UNKNOWN unk_106945D8; // weak
_UNKNOWN unk_106945DC; // weak
_UNKNOWN unk_106945E0; // weak
_UNKNOWN unk_106945E4; // weak
_UNKNOWN unk_10694604; // weak
_UNKNOWN unk_10694624; // weak
_UNKNOWN unk_10694644; // weak
_UNKNOWN unk_10694664; // weak
_UNKNOWN unk_10694684; // weak
_UNKNOWN unk_106946A4; // weak
_UNKNOWN unk_106946C4; // weak
_UNKNOWN unk_106946E4; // weak
_UNKNOWN unk_106946E5; // weak
_UNKNOWN unk_106946E6; // weak
_UNKNOWN unk_10694738; // weak
_UNKNOWN unk_10694758; // weak
_UNKNOWN unk_10694778; // weak
_UNKNOWN unk_1069477C; // weak
_UNKNOWN unk_10694780; // weak
_UNKNOWN unk_10694784; // weak
_UNKNOWN unk_106947A4; // weak
_UNKNOWN unk_106947C4; // weak
_UNKNOWN unk_106947E4; // weak
_UNKNOWN unk_10694804; // weak
_UNKNOWN unk_10694824; // weak
_UNKNOWN unk_10694844; // weak
_UNKNOWN unk_10694864; // weak
_UNKNOWN unk_10694884; // weak
_UNKNOWN unk_106948A4; // weak
_UNKNOWN unk_106948EC; // weak
_UNKNOWN unk_10694934; // weak
_UNKNOWN unk_1069497C; // weak
_UNKNOWN unk_106949C4; // weak
_UNKNOWN unk_10694A0C; // weak
_UNKNOWN unk_10694A54; // weak
_UNKNOWN unk_10694A9C; // weak
_UNKNOWN unk_10694AE4; // weak
_UNKNOWN unk_10694B2C; // weak
_UNKNOWN unk_10694B74; // weak
_UNKNOWN unk_10694BBC; // weak
_UNKNOWN unk_10694C04; // weak
_UNKNOWN unk_10694C4C; // weak
_UNKNOWN unk_10694C94; // weak
_UNKNOWN unk_10694CDC; // weak
_UNKNOWN unk_10694D24; // weak
_UNKNOWN unk_10694D6C; // weak
_UNKNOWN unk_10694DB4; // weak
_UNKNOWN unk_10694DFC; // weak
_UNKNOWN unk_10694E44; // weak
_UNKNOWN unk_10694E8C; // weak
_UNKNOWN unk_10694ED4; // weak
_UNKNOWN unk_10694F1C; // weak
_UNKNOWN unk_10694F64; // weak
_UNKNOWN unk_10694FAC; // weak
_UNKNOWN unk_10694FF4; // weak
_UNKNOWN unk_1069503C; // weak
_UNKNOWN unk_10695084; // weak
_UNKNOWN unk_106950CC; // weak
_UNKNOWN unk_10695114; // weak
_UNKNOWN unk_1069512C; // weak
_UNKNOWN unk_1069514C; // weak
_UNKNOWN unk_1069516C; // weak
_UNKNOWN unk_10695170; // weak
_UNKNOWN unk_10695214; // weak
_UNKNOWN unk_106952B8; // weak
_UNKNOWN unk_1069535C; // weak
_UNKNOWN unk_10695400; // weak
_UNKNOWN unk_106954A4; // weak
_UNKNOWN unk_10695548; // weak
_UNKNOWN unk_106955EC; // weak
_UNKNOWN unk_10695690; // weak
_UNKNOWN unk_10695734; // weak
_UNKNOWN unk_106957D8; // weak
_UNKNOWN unk_1069587C; // weak
_UNKNOWN unk_10695920; // weak
_UNKNOWN unk_106959C4; // weak
_UNKNOWN unk_10695A68; // weak
_UNKNOWN unk_10695B0C; // weak
_UNKNOWN unk_10695BB0; // weak
_UNKNOWN unk_10695C54; // weak
_UNKNOWN unk_10695CF8; // weak
_UNKNOWN unk_10695D9C; // weak
_UNKNOWN unk_10695E40; // weak
_UNKNOWN unk_10695EE4; // weak
_UNKNOWN unk_10695F88; // weak
_UNKNOWN unk_1069602C; // weak
_UNKNOWN unk_106960D0; // weak
_UNKNOWN unk_10696174; // weak
_UNKNOWN unk_10696218; // weak
_UNKNOWN unk_106962BC; // weak
_UNKNOWN unk_10696360; // weak
_UNKNOWN unk_10696404; // weak
_UNKNOWN unk_106964A8; // weak
_UNKNOWN unk_1069654C; // weak
_UNKNOWN unk_106965F0; // weak
_UNKNOWN unk_10696694; // weak
_UNKNOWN unk_10696738; // weak
_UNKNOWN unk_106967DC; // weak
_UNKNOWN unk_10696880; // weak
_UNKNOWN unk_10696924; // weak
_UNKNOWN unk_106969C8; // weak
_UNKNOWN unk_10696A6C; // weak
_UNKNOWN unk_10696B10; // weak
_UNKNOWN unk_10696BB4; // weak
_UNKNOWN unk_10696C58; // weak
_UNKNOWN unk_10696CFC; // weak
_UNKNOWN unk_10696DA0; // weak
_UNKNOWN unk_10696E44; // weak
_UNKNOWN unk_10696EE8; // weak
_UNKNOWN unk_10696F8C; // weak
_UNKNOWN unk_10697030; // weak
_UNKNOWN unk_106970D4; // weak
_UNKNOWN unk_10697178; // weak
_UNKNOWN unk_1069721C; // weak
_UNKNOWN unk_106972C0; // weak
_UNKNOWN unk_10697364; // weak
_UNKNOWN unk_10697408; // weak
_UNKNOWN unk_106974AC; // weak
_UNKNOWN unk_10697550; // weak
_UNKNOWN unk_106975F4; // weak
_UNKNOWN unk_10697698; // weak
_UNKNOWN unk_1069773C; // weak
_UNKNOWN unk_106977E0; // weak
_UNKNOWN unk_10697884; // weak
_UNKNOWN unk_10697928; // weak
_UNKNOWN unk_106979CC; // weak
_UNKNOWN unk_10697A70; // weak
_UNKNOWN unk_10697B14; // weak
_UNKNOWN unk_10697BB8; // weak
_UNKNOWN unk_10697C5C; // weak
_UNKNOWN unk_10697D00; // weak
_UNKNOWN unk_10697DA4; // weak
_UNKNOWN unk_10697E48; // weak
_UNKNOWN unk_10697EEC; // weak
_UNKNOWN unk_10697F90; // weak
_UNKNOWN unk_10698034; // weak
_UNKNOWN unk_106980D8; // weak
_UNKNOWN unk_1069817C; // weak
_UNKNOWN unk_10698220; // weak
_UNKNOWN unk_106982C4; // weak
_UNKNOWN unk_10698368; // weak
_UNKNOWN unk_1069840C; // weak
_UNKNOWN unk_106984B0; // weak
_UNKNOWN unk_10698554; // weak
_UNKNOWN unk_106985F8; // weak
_UNKNOWN unk_1069869C; // weak
_UNKNOWN unk_10698740; // weak
_UNKNOWN unk_106987E4; // weak
_UNKNOWN unk_10698888; // weak
_UNKNOWN unk_1069892C; // weak
_UNKNOWN unk_106989D0; // weak
_UNKNOWN unk_10698A74; // weak
_UNKNOWN unk_10698B18; // weak
_UNKNOWN unk_10698BBC; // weak
_UNKNOWN unk_10698C60; // weak
_UNKNOWN unk_10698D04; // weak
_UNKNOWN unk_10698DA8; // weak
_UNKNOWN unk_10698E4C; // weak
_UNKNOWN unk_10698EF0; // weak
_UNKNOWN unk_10698F94; // weak
_UNKNOWN unk_10699038; // weak
_UNKNOWN unk_106990DC; // weak
_UNKNOWN unk_10699180; // weak
_UNKNOWN unk_106991A0; // weak
_UNKNOWN unk_106991C0; // weak
_UNKNOWN unk_106991E0; // weak
_UNKNOWN unk_10699200; // weak
_UNKNOWN unk_10699228; // weak
_UNKNOWN unk_10699244; // weak
_UNKNOWN unk_10699260; // weak
_UNKNOWN unk_1069927C; // weak
_UNKNOWN unk_10699298; // weak
_UNKNOWN unk_106992B4; // weak
_UNKNOWN unk_106992D0; // weak
_UNKNOWN unk_106992EC; // weak
_UNKNOWN unk_10699308; // weak
_UNKNOWN unk_10699324; // weak
_UNKNOWN unk_10699340; // weak
_UNKNOWN unk_1069935C; // weak
_UNKNOWN unk_10699378; // weak
_UNKNOWN unk_10699394; // weak
_UNKNOWN unk_106993B0; // weak
_UNKNOWN unk_106993CC; // weak
_UNKNOWN unk_106993E8; // weak
_UNKNOWN unk_10699404; // weak
_UNKNOWN unk_10699420; // weak
_UNKNOWN unk_1069943C; // weak
_UNKNOWN unk_10699458; // weak
_UNKNOWN unk_10699474; // weak
_UNKNOWN unk_10699490; // weak
_UNKNOWN unk_106994AC; // weak
_UNKNOWN unk_106994C8; // weak
_UNKNOWN unk_106994E4; // weak
_UNKNOWN unk_10699500; // weak
_UNKNOWN unk_1069951C; // weak
_UNKNOWN unk_10699538; // weak
_UNKNOWN unk_10699554; // weak
_UNKNOWN unk_10699570; // weak
_UNKNOWN unk_1069958C; // weak
_UNKNOWN unk_106995A8; // weak
_UNKNOWN unk_106995C4; // weak
_UNKNOWN unk_106995E0; // weak
_UNKNOWN unk_106995FC; // weak
_UNKNOWN unk_10699618; // weak
_UNKNOWN unk_10699634; // weak
_UNKNOWN unk_10699650; // weak
_UNKNOWN unk_1069966C; // weak
_UNKNOWN unk_10699688; // weak
_UNKNOWN unk_106996A4; // weak
_UNKNOWN unk_106996C0; // weak
_UNKNOWN unk_106996DC; // weak
_UNKNOWN unk_106996F8; // weak
_UNKNOWN unk_10699714; // weak
_UNKNOWN unk_10699730; // weak
_UNKNOWN unk_1069974C; // weak
_UNKNOWN unk_10699768; // weak
_UNKNOWN unk_10699784; // weak
_UNKNOWN unk_106997A0; // weak
_UNKNOWN unk_106997BC; // weak
_UNKNOWN unk_106997D8; // weak
_UNKNOWN unk_106997F4; // weak
_UNKNOWN unk_10699810; // weak
_UNKNOWN unk_1069982C; // weak
_UNKNOWN unk_10699848; // weak
_UNKNOWN unk_10699864; // weak
_UNKNOWN unk_10699880; // weak
_UNKNOWN unk_1069989C; // weak
_UNKNOWN unk_106998B8; // weak
_UNKNOWN unk_106998D4; // weak
_UNKNOWN unk_106998F0; // weak
_UNKNOWN unk_1069990C; // weak
_UNKNOWN unk_10699928; // weak
_UNKNOWN unk_10699944; // weak
_UNKNOWN unk_10699960; // weak
_UNKNOWN unk_1069997C; // weak
_UNKNOWN unk_10699998; // weak
_UNKNOWN unk_106999B4; // weak
_UNKNOWN unk_106999D0; // weak
_UNKNOWN unk_106999EC; // weak
_UNKNOWN unk_10699A08; // weak
_UNKNOWN unk_10699A24; // weak
_UNKNOWN unk_10699A40; // weak
_UNKNOWN unk_10699A5C; // weak
_UNKNOWN unk_10699A78; // weak
_UNKNOWN unk_10699A94; // weak
_UNKNOWN unk_10699AB0; // weak
_UNKNOWN unk_10699ACC; // weak
_UNKNOWN unk_10699AE8; // weak
_UNKNOWN unk_10699B04; // weak
_UNKNOWN unk_10699B20; // weak
_UNKNOWN unk_10699B3C; // weak
_UNKNOWN unk_10699B58; // weak
_UNKNOWN unk_10699B74; // weak
_UNKNOWN unk_10699B90; // weak
_UNKNOWN unk_10699BAC; // weak
_UNKNOWN unk_10699BC8; // weak
_UNKNOWN unk_10699BE4; // weak
_UNKNOWN unk_10699C00; // weak
_UNKNOWN unk_10699C1C; // weak
_UNKNOWN unk_10699C38; // weak
_UNKNOWN unk_10699C54; // weak
_UNKNOWN unk_10699C70; // weak
_UNKNOWN unk_10699C8C; // weak
_UNKNOWN unk_10699CA8; // weak
_UNKNOWN unk_10699CC4; // weak
_UNKNOWN unk_10699CE0; // weak
_UNKNOWN unk_10699CFC; // weak
_UNKNOWN unk_10699D18; // weak
_UNKNOWN unk_10699D1C; // weak
_UNKNOWN unk_10699D20; // weak
_UNKNOWN unk_10699D24; // weak
_UNKNOWN unk_10699D28; // weak
_UNKNOWN unk_10699D2C; // weak
_UNKNOWN unk_10699D30; // weak
_UNKNOWN unk_10699D34; // weak
_UNKNOWN unk_10699D38; // weak
_UNKNOWN unk_10699D3C; // weak
_UNKNOWN unk_10699D40; // weak
_UNKNOWN unk_10699D44; // weak
_UNKNOWN unk_10699D48; // weak
_UNKNOWN unk_10699D4C; // weak
_UNKNOWN unk_10699D50; // weak
_UNKNOWN unk_10699D54; // weak
_UNKNOWN unk_10699D58; // weak
_UNKNOWN unk_10699D5C; // weak
_UNKNOWN unk_10699D60; // weak
_UNKNOWN unk_10699E44; // weak
_UNKNOWN unk_1069B004; // weak
_UNKNOWN unk_1069B008; // weak
_UNKNOWN unk_1069B030; // weak
_UNKNOWN unk_1069B058; // weak
_UNKNOWN unk_1069B098; // weak
_UNKNOWN unk_1069B118; // weak
_UNKNOWN unk_1069B11C; // weak
_UNKNOWN unk_1069B120; // weak
_UNKNOWN unk_1069B122; // weak
_UNKNOWN unk_1069B124; // weak
_UNKNOWN unk_1069B125; // weak
_UNKNOWN unk_1069B126; // weak
_UNKNOWN unk_1069B128; // weak
_UNKNOWN unk_1069B18C; // weak
_UNKNOWN unk_1069B194; // weak
_UNKNOWN unk_1069B19C; // weak
_UNKNOWN unk_1069B1A4; // weak
_UNKNOWN unk_1069B1AC; // weak
_UNKNOWN unk_1069B1B4; // weak
_UNKNOWN unk_1069B1BC; // weak
_UNKNOWN unk_1069B1C4; // weak
_UNKNOWN unk_1069B1CC; // weak
_UNKNOWN unk_1069B1D4; // weak
_UNKNOWN unk_1069B1DC; // weak
_UNKNOWN unk_1069B1E4; // weak
_UNKNOWN unk_1069B1EC; // weak
_UNKNOWN unk_1069B1F4; // weak
_UNKNOWN unk_1069B1FC; // weak
_UNKNOWN unk_1069B204; // weak
_UNKNOWN unk_1069B20C; // weak
_UNKNOWN unk_1069B214; // weak
_UNKNOWN unk_1069B21C; // weak
_UNKNOWN unk_1069B224; // weak
_UNKNOWN unk_1069B22C; // weak
_UNKNOWN unk_1069B234; // weak
_UNKNOWN unk_1069B23C; // weak
_UNKNOWN unk_1069B244; // weak
_UNKNOWN unk_1069B24C; // weak
_UNKNOWN unk_1069B254; // weak
_UNKNOWN unk_1069B25C; // weak
_UNKNOWN unk_1069B264; // weak
_UNKNOWN unk_1069B26C; // weak
_UNKNOWN unk_1069B274; // weak
_UNKNOWN unk_1069B27C; // weak
_UNKNOWN unk_1069B284; // weak
_UNKNOWN unk_1069B28C; // weak
_UNKNOWN unk_1069B294; // weak
_UNKNOWN unk_1069B29C; // weak
_UNKNOWN unk_1069B2A4; // weak
_UNKNOWN unk_1069B2AC; // weak
_UNKNOWN unk_1069B2B4; // weak
_UNKNOWN unk_1069B2BC; // weak
_UNKNOWN unk_1069B2C4; // weak
_UNKNOWN unk_1069B4AC; // weak
_UNKNOWN unk_1069B4BC; // weak
_UNKNOWN unk_1069B4CC; // weak
_UNKNOWN unk_1069B4DC; // weak
_UNKNOWN unk_1069B4DD; // weak
_UNKNOWN unk_1069B4DE; // weak
_UNKNOWN unk_1069B4E0; // weak
_UNKNOWN unk_1069B4E4; // weak
_UNKNOWN unk_1069B58C; // weak
_UNKNOWN unk_1069B590; // weak
_UNKNOWN unk_1069B594; // weak
_UNKNOWN unk_1069B5E4; // weak
_UNKNOWN unk_1069B5E8; // weak
_UNKNOWN unk_1069B5EC; // weak
_UNKNOWN unk_1069B6DC; // weak
_UNKNOWN unk_1069B7CC; // weak
_UNKNOWN unk_1069B7D0; // weak
_UNKNOWN unk_1069B7D8; // weak
_UNKNOWN unk_1069B7E0; // weak
_UNKNOWN unk_1069B7E8; // weak
_UNKNOWN unk_1069B7F0; // weak
_UNKNOWN unk_1069B7F8; // weak
_UNKNOWN unk_1069B800; // weak
_UNKNOWN unk_1069B808; // weak
_UNKNOWN unk_1069B810; // weak
_UNKNOWN unk_1069B818; // weak
_UNKNOWN unk_1069B820; // weak
_UNKNOWN unk_1069B828; // weak
_UNKNOWN unk_1069B82C; // weak
_UNKNOWN unk_1069B830; // weak
_UNKNOWN unk_1069B834; // weak
_UNKNOWN unk_1069B888; // weak
_UNKNOWN unk_1069B8DC; // weak
_UNKNOWN unk_1069B8E4; // weak
_UNKNOWN unk_1069B8E8; // weak
_UNKNOWN unk_1069B8EC; // weak
_UNKNOWN unk_1069B8F0; // weak
_UNKNOWN unk_1069B8F4; // weak
_UNKNOWN unk_1069BAFC; // weak
_UNKNOWN unk_1069BC5C; // weak
_UNKNOWN unk_1069BC74; // weak
_UNKNOWN unk_1069BC8C; // weak
_UNKNOWN unk_1069BC96; // weak
_UNKNOWN unk_1069BC98; // weak
_UNKNOWN unk_1069BCA8; // weak
_UNKNOWN unk_1069BCAC; // weak
_UNKNOWN unk_1069BCB0; // weak
_UNKNOWN unk_1069BCB4; // weak
_UNKNOWN unk_1069BCB5; // weak
_UNKNOWN unk_1069BCB8; // weak
_UNKNOWN unk_1069BD08; // weak
_UNKNOWN unk_1069BD0C; // weak
_UNKNOWN unk_1069BD0D; // weak
_UNKNOWN unk_1069BD0E; // weak
_UNKNOWN unk_1069BD0F; // weak
_UNKNOWN unk_1069BD23; // weak
_UNKNOWN unk_1069BD24; // weak
_UNKNOWN unk_1069BD25; // weak
_UNKNOWN unk_1069BD26; // weak
_UNKNOWN unk_1069BD28; // weak
_UNKNOWN unk_1069BDC8; // weak
_UNKNOWN unk_1069BE18; // weak
_UNKNOWN unk_1069BE1C; // weak
_UNKNOWN unk_1069BE20; // weak
_UNKNOWN unk_1069BE24; // weak
_UNKNOWN unk_1069BE28; // weak
_UNKNOWN unk_1069BE2C; // weak
_UNKNOWN unk_1069BE30; // weak
_UNKNOWN unk_1069BE34; // weak
_UNKNOWN unk_1069BE38; // weak
_UNKNOWN unk_1069BE3C; // weak
_UNKNOWN unk_1069BE40; // weak
_UNKNOWN unk_1069BE44; // weak
_UNKNOWN unk_1069BE48; // weak
_UNKNOWN unk_1069BF88; // weak
_UNKNOWN unk_1069BF94; // weak
_UNKNOWN unk_1069BFDC; // weak
_UNKNOWN unk_1069BFDD; // weak
_UNKNOWN unk_1069C008; // weak
_UNKNOWN unk_1069C038; // weak
_UNKNOWN unk_1069C060; // weak
_UNKNOWN unk_1069C064; // weak
_UNKNOWN unk_1069C068; // weak
_UNKNOWN unk_1069C06C; // weak
_UNKNOWN unk_1069C09C; // weak
_UNKNOWN unk_1069C09D; // weak
_UNKNOWN unk_1069C09E; // weak
_UNKNOWN unk_1069C0A0; // weak
_UNKNOWN unk_1069C0A4; // weak
_UNKNOWN unk_1069C0A8; // weak
_UNKNOWN unk_1069C0AC; // weak
_UNKNOWN unk_1069C0B0; // weak
_UNKNOWN unk_1069C0B4; // weak
_UNKNOWN unk_1069C0B8; // weak
_UNKNOWN unk_1069C0BC; // weak
_UNKNOWN unk_1069C0C0; // weak
_UNKNOWN unk_1069C0C4; // weak
_UNKNOWN unk_1069C424; // weak
_UNKNOWN unk_1069C428; // weak
_UNKNOWN unk_1069C432; // weak
_UNKNOWN unk_1069C43C; // weak
int dword_1069DBF8; // weak
int dword_1069DBFC; // weak
int dword_1069DC00; // weak
int dword_1069DC04; // weak
char byte_1069DC08; // weak
int dword_1069DC0C; // weak
int dword_1069DC10; // weak
int dword_1069DC14; // weak
int dword_1069DC18; // weak
int dword_1069DC1C; // weak
int dword_1069DC20; // weak
int dword_1069DC24; // weak
int dword_1069DC28; // weak
int dword_1069DC2C; // weak
int dword_1069DC30; // weak
int dword_1069DC34; // weak
int dword_1069DC38; // weak
int dword_1069DC3C; // weak
_UNKNOWN unk_1069DCC8; // weak
_UNKNOWN unk_1069DCCC; // weak
int dword_1069DCD0; // weak
int dword_1069DCE0; // weak
_UNKNOWN unk_1069DCE8; // weak
char byte_1069DFC0[]; // weak
char byte_1069DFC1[]; // weak
_UNKNOWN unk_1069F228; // weak
int dword_106A0BD8; // weak
int dword_106A0BDC; // weak
int dword_106A0BE0; // weak
int dword_106A0BE4; // weak
int dword_106A0BE8[]; // weak
int dword_106A0BEC; // weak
int dword_106A0BF0; // weak
int dword_106A0BF4; // weak
int dword_106A0BF8; // weak
int dword_106A0BFC[]; // weak
int dword_106A0C00; // weak
int dword_106A0C04; // weak
int dword_106A0C08; // weak
int dword_106A0C0C; // weak
_UNKNOWN unk_106A0C10; // weak
char byte_106A0D28; // idb
char byte_106A0E28[254]; // idb
char byte_106A0F26[]; // weak
char byte_106A0F27[]; // weak
char byte_106A1328[2800]; // idb
char byte_106A1E18[1022]; // idb
char byte_106A2216[]; // weak
char byte_106A2217[]; // weak
char byte_106A2218[1022]; // idb
char byte_106A2616[]; // weak
char byte_106A2617[]; // weak
char byte_106A2618[1022]; // idb
char byte_106A2A16[]; // weak
char byte_106A2A17[]; // weak
int dword_106A5A18[]; // weak
int dword_106A5A2C[]; // weak
char byte_106A5A40[2800]; // idb
char byte_106A6530[2800]; // idb
char byte_106A7020[2800]; // idb
int dword_106A7B10[]; // weak
int dword_106A7B24[]; // weak
char byte_106A7B38[2796]; // idb
char byte_106A8624[]; // weak
char byte_106A8628[559]; // idb
char byte_106A8857[]; // weak
int dword_106A9118[]; // weak
int dword_106A912C[]; // weak
char byte_106A9140[2800]; // idb
int dword_106A9C30; // weak
_UNKNOWN unk_106A9C38; // weak
_UNKNOWN unk_106AA790; // weak
int dword_106ACAF8; // weak
_UNKNOWN unk_106ACB00; // weak
int dword_106AE040; // weak
char byte_106AE048[]; // weak
char byte_106AE04C[]; // weak
char byte_106AE04D[]; // weak
int dword_106AE054[]; // weak
int dword_106AE05C[]; // weak
_UNKNOWN unk_106AE090; // weak
_UNKNOWN unk_106AE098; // weak
_UNKNOWN unk_106AE0A0; // weak
int dword_1070DDF0; // weak
char byte_1070DDF8[]; // weak
char byte_1070DE48[]; // weak
char byte_10715198; // weak
char byte_10715199; // weak
char byte_10717A40[]; // weak
char byte_10717A41[]; // weak
_UNKNOWN unk_10717AE0; // weak
int dword_10717DB0[]; // weak
int dword_10717DB4[]; // weak
_UNKNOWN unk_107182D0; // weak
_UNKNOWN unk_1071B1D8; // weak
_UNKNOWN unk_1071B6D8; // weak
_UNKNOWN unk_1071B780; // weak
char byte_1071B7A0; // weak
char byte_1071B7A1; // weak
char byte_1071B7A2; // weak
char byte_1071B7A3; // weak
_UNKNOWN unk_1071B7A8; // weak
_UNKNOWN unk_1071B7C8; // weak
int dword_1071C9A8; // weak
int dword_1071C9AC; // weak
int dword_1071C9B0; // weak
int dword_1071C9B4; // weak
int dword_1071C9B8; // weak
int dword_1071C9BC; // weak
_UNKNOWN unk_107221C0; // weak
void *dword_10722240; // idb
_UNKNOWN unk_10722248; // weak
_UNKNOWN unk_10722528; // weak
_UNKNOWN unk_1072DC70; // weak
int dword_1073B054; // weak
_DWORD dword_1073B058[16]; // idb
int dword_1073B098[]; // weak
int dword_1073B0D8; // weak
int dword_1073B0E0[]; // weak
_UNKNOWN unk_1073B124; // weak
char byte_1073B150; // weak
_UNKNOWN unk_1073B158; // weak
int dword_1073B160; // weak
int dword_1073B164; // weak
int dword_1073B168; // weak
int dword_1073B16C; // weak
int dword_1073B178; // weak
_UNKNOWN unk_1073B188; // weak
char byte_1073E388; // weak
_UNKNOWN unk_1073E398; // weak
_UNKNOWN unk_1073E3C4; // weak
_UNKNOWN unk_10745444; // weak
int dword_10745494; // weak
_UNKNOWN unk_10745498; // weak
_UNKNOWN unk_107454C4; // weak
int dword_107470E4; // weak
int dword_107470E8; // weak
int dword_107470EC; // weak
int dword_107470F0; // weak
int dword_107470F4; // weak
int dword_107470F8; // weak
int dword_107470FC; // weak
int dword_10747100; // weak
int dword_10747104; // weak
int dword_10747108; // weak
int dword_1074710C; // weak
int dword_10747110; // weak
int dword_10747114; // weak
int dword_10747118; // weak
int dword_1074711C; // weak
int dword_10747120; // weak
int dword_1074713C; // weak
int dword_10747464; // weak
int dword_1074746C; // weak
int dword_10747478; // weak
int dword_10747AA0; // weak
int dword_10747AAC; // weak
int dword_10747AB8; // weak
int dword_10747ABC; // weak
int dword_10747AC0; // weak
int dword_10747ADC; // weak
int dword_10747AE0; // weak
int dword_10747AE4; // weak
int dword_10747AE8; // weak
int dword_10747AEC; // weak
int dword_10747D90; // weak
int dword_10747D94; // weak
int dword_10747D98; // weak
char byte_10747D9C; // weak
char byte_10747D9D; // weak
char byte_10747D9E; // weak
int dword_10747DA0; // weak
_UNKNOWN unk_10747DA4; // weak
char byte_10779DC0; // weak
char byte_10779DC1; // weak
char byte_10779DC2; // weak
char byte_10779DC4; // weak
char byte_10779DCB; // weak
__int16 word_10779DCE; // weak
__int16 word_10779DD0; // weak
__int16 word_10779DD4; // weak
int dword_10779DD8; // weak
int dword_10779DDC; // weak
int dword_10779DF4; // weak
int dword_10779E00; // weak
int dword_10779E08; // weak
char byte_10779F48; // weak
int dword_10779F9C; // weak
char byte_10779FA0; // weak
int dword_10779FC0[]; // weak
_BYTE dword_10779FC4[136]; // idb
int dword_1077A050; // weak
int dword_1077A428; // weak
_UNKNOWN unk_1077A42C; // weak
char byte_1077A440[425]; // idb
_UNKNOWN unk_1077A5E9; // weak
int dword_1077A5EC; // weak
int dword_1077A5F0; // weak
char byte_1077A5F4; // weak
int dword_1077A5F8; // weak
char byte_1077A5FC; // weak
int dword_1077A600; // weak
char byte_1077A604; // weak
int dword_1077A608; // weak
int dword_1077A60C; // weak
char byte_1077A614[]; // weak
int dword_1077A618; // weak
char byte_1077A624; // weak
int dword_1077A640[]; // weak
__int16 word_1077A644[]; // weak
int dword_1077A648[]; // weak
int dword_1077A64C; // weak
int dword_1077A650; // weak
int dword_1077A654; // weak
int dword_1077A658; // weak
__int16 word_1077A65C; // weak
int dword_1077A660; // weak
int dword_1077A6A8; // weak
int dword_1077A708; // weak
int dword_1077A738; // weak
int dword_1077A780; // weak
int dword_1077A828; // weak
int dword_1077A834; // weak
int dword_1077A844; // weak
__int16 word_1077A848; // weak
int dword_1077A850; // weak
__int16 word_1077A854; // weak
int dword_1077A85C; // weak
int dword_1077A964; // weak
int dword_1077A970; // weak
__int16 word_1077A974; // weak
int dword_1077A9DC; // weak
__int16 word_1077A9E0; // weak
_UNKNOWN unk_1077AD48; // weak
_UNKNOWN unk_1077AD49; // weak
_UNKNOWN unk_1077AD4A; // weak
__int16 word_1077AD60[]; // weak
__int16 word_1077ADEE; // weak
char byte_1077AE8C; // weak
char byte_1077AE8D; // weak
int dword_1077AE90; // weak
char byte_1077AE94; // weak
int dword_1077AE98; // weak
char byte_1077AE9C; // weak
__int16 word_1077AE9E; // weak
__int16 word_1077AEA0; // weak
char byte_1077AEA2; // weak
__int16 word_1077AEA4; // weak
char byte_1077AEA6; // weak
void *dword_1077AEC0; // idb
int dword_1077BEE0; // weak
int dword_1077BEE4; // weak
UINT uNumber; // idb
int dword_1077BF00[]; // weak
int dword_1077C000; // weak
int dword_1077C018; // weak


//----- (10001000) --------------------------------------------------------
int sub_10001000()
{
  int result; // eax@1

  memset(&unk_100E0780, 0, 0x80u);
  memset(&unk_100E0800, 0, 0x80u);
  result = 0;
  word_100E0880 = 5;
  dword_100E0882 = 0;
  dword_100E0886 = 0;
  dword_100E088A = 0;
  byte_100E088E = 0;
  return result;
}
// 100E0880: using guessed type __int16 word_100E0880;
// 100E0882: using guessed type int dword_100E0882;
// 100E0886: using guessed type int dword_100E0886;
// 100E088A: using guessed type int dword_100E088A;
// 100E088E: using guessed type char byte_100E088E;

//----- (10001050) --------------------------------------------------------
int __usercall sub_10001050@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( *(_WORD *)(a2 + 2) < 0x7C6u )
  {
    *(_BYTE *)(result + 1) = 1;
    *(_BYTE *)result = 1;
    *(_WORD *)(result + 2) = 1990;
  }
  else
  {
    *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
    *(_BYTE *)result = *(_BYTE *)a2;
    *(_WORD *)(result + 2) = *(_WORD *)(a2 + 2);
  }
  return result;
}

//----- (10001080) --------------------------------------------------------
bool __cdecl sub_10001080(void *a1)
{
  char v1; // cl@4
  char v2; // al@4
  __int16 v3; // dx@4
  int v4; // ecx@4
  int v5; // edx@4
  bool result; // al@6
  int v7; // [sp+4h] [bp-10Ch]@1
  int v8; // [sp+8h] [bp-108h]@1
  char v9; // [sp+Ch] [bp-104h]@4
  char v10; // [sp+10h] [bp-100h]@4
  char v11; // [sp+14h] [bp-FCh]@4
  char v12; // [sp+18h] [bp-F8h]@4
  char v13; // [sp+1Ch] [bp-F4h]@4
  unsigned __int8 v14; // [sp+20h] [bp-F0h]@4
  char v15; // [sp+21h] [bp-EFh]@4
  char v16; // [sp+22h] [bp-EEh]@4
  __int16 v17; // [sp+23h] [bp-EDh]@4
  __int16 v18; // [sp+25h] [bp-EBh]@4
  char v19; // [sp+27h] [bp-E9h]@4
  char v20; // [sp+33h] [bp-DDh]@4
  char v21; // [sp+51h] [bp-BFh]@4
  char v22; // [sp+6Ah] [bp-A6h]@4
  int v23; // [sp+9Ch] [bp-74h]@4
  char v24; // [sp+A0h] [bp-70h]@4
  int v25; // [sp+FEh] [bp-12h]@4
  int v26; // [sp+102h] [bp-Eh]@4
  int v27; // [sp+106h] [bp-Ah]@4

  memset(a1, 0, 0xD8u);
  memset(&v8, 0, 0x102u);
  result = 0;
  if ( !sub_10037D50(48, &v7) && v7 - 258 > 0 && !sub_10037CB0(48, v7 - 258, 258, (int)&v8) )
  {
    *(_DWORD *)a1 = v8;
    strncpy((char *)a1 + 4, &v9, 4u);
    sub_10001050((int)a1 + 10, (int)&v10);
    sub_10001050((int)a1 + 14, (int)&v11);
    sub_10001050((int)a1 + 18, (int)&v12);
    sub_10001050((int)a1 + 22, (int)&v13);
    v1 = v16;
    v2 = v15;
    *((_WORD *)a1 + 13) = v14;
    v3 = v17;
    *((_BYTE *)a1 + 29) = v1;
    *((_WORD *)a1 + 15) = v3;
    *((_BYTE *)a1 + 28) = v2;
    *((_WORD *)a1 + 16) = v18;
    strncpy((char *)a1 + 34, &v19, 0xCu);
    strncpy((char *)a1 + 47, &v20, 0x1Eu);
    strncpy((char *)a1 + 78, &v21, 0x19u);
    strncpy((char *)a1 + 104, &v22, 0x32u);
    *((_DWORD *)a1 + 39) = v23;
    strncpy((char *)a1 + 160, &v24, 0x28u);
    v4 = v26;
    v5 = v27;
    *((_DWORD *)a1 + 51) = v25;
    *((_DWORD *)a1 + 52) = v4;
    *((_DWORD *)a1 + 53) = v5;
    if ( strncmp(&v19, "006-D1430", 9u) <= 0 && v23 == v7 - v25 - 8 )
      result = 1;
  }
  return result;
}

//----- (10001270) --------------------------------------------------------
int __usercall sub_10001270@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(result + 84) = a2;
  *(_DWORD *)(result + 4) = -122944301;
  *(_DWORD *)(result + 60) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(_DWORD *)(result + 68) = 0;
  *(_DWORD *)(result + 72) = 0;
  *(_DWORD *)(result + 76) = 0;
  *(_DWORD *)(result + 80) = 0;
  return result;
}

//----- (10001290) --------------------------------------------------------
int __cdecl sub_10001290(int a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@1
  signed int v5; // esi@1

  v3 = a1;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 4) = -122944301;
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 28) = 0;
  result = a1 + 32;
  v5 = 32;
  do
  {
    result = sub_10001270(result, v3) + 96;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (100012E0) --------------------------------------------------------
char __thiscall sub_100012E0(int this)
{
  int v1; // edx@1
  int v2; // esi@1
  char result; // al@6
  int v4; // eax@7

  v1 = *(_DWORD *)(this + 40);
  v2 = *(_DWORD *)(this + 32);
  if ( !v2 && !*(_DWORD *)(this + 36) )
  {
    if ( *(_DWORD *)(v1 + 56) == this )
      *(_DWORD *)(v1 + 56) = 0;
    if ( *(_DWORD *)(v1 + 52) == this )
    {
      *(_DWORD *)(v1 + 52) = 0;
      return 1;
    }
    return 1;
  }
  v4 = *(_DWORD *)(this + 36);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 36) = v4;
    if ( v4 )
      *(_DWORD *)(v4 + 32) = v2;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    return 1;
  }
  if ( *(_DWORD *)(v1 + 52) == this )
  {
    *(_DWORD *)(v1 + 52) = v4;
    *(_DWORD *)(v4 + 32) = 0;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    result = 1;
  }
  else
  {
    *(_DWORD *)(v1 + 56) = v4;
    *(_DWORD *)(v4 + 32) = 0;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    result = 1;
  }
  return result;
}

//----- (10001350) --------------------------------------------------------
char __cdecl sub_10001350(char a1, int a2)
{
  int v2; // edi@3
  char result; // al@5
  int v4; // eax@6
  int v5; // eax@9

  if ( a2 && *(_DWORD *)(a2 + 40) )
  {
    sub_10002070(a2);
    sub_10002210(a2);
    v2 = *(_DWORD *)(a2 + 40);
    sub_100012E0(a2);
    if ( a1 == 1 )
    {
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(v2 + 52);
      v5 = *(_DWORD *)(v2 + 52);
      if ( v5 )
        *(_DWORD *)(v5 + 32) = a2;
      *(_DWORD *)(v2 + 52) = a2;
      *(_BYTE *)(a2 + 9) = 1;
      result = 1;
    }
    else if ( a1 == 2 )
    {
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(v2 + 56);
      v4 = *(_DWORD *)(v2 + 56);
      if ( v4 )
        *(_DWORD *)(v4 + 32) = a2;
      *(_DWORD *)(v2 + 56) = a2;
      *(_BYTE *)(a2 + 9) = 0;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100013D0) --------------------------------------------------------
int __cdecl sub_100013D0(int a1, unsigned int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( a2 && (sub_10002130(0), (v3 = sub_10001BA0(a1)) != 0) )
    result = sub_10001F90(v3, a2);
  else
    result = 0;
  return result;
}

//----- (10001410) --------------------------------------------------------
int __cdecl sub_10001410(_BYTE *a1)
{
  unsigned int v1; // ebx@1
  char *v2; // ebp@1
  int result; // eax@2
  char *v4; // ecx@4
  char v5; // dl@6
  int v6; // esi@7
  int v7; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v7 = 0;
  v2 = (char *)sub_10001E00(2);
  if ( v2 )
  {
    do
    {
      if ( v2[3200 * v1 + 24] )
      {
        v4 = &v2[3200 * v1 + 3156];
        if ( &v2[3200 * v1 + 24] != (char *)-3132 )
        {
          if ( a1 )
          {
            v5 = *v4;
            if ( *v4 == *a1 )
            {
              v6 = a1 - v4;
              while ( v5 )
              {
                v5 = (v4++)[1];
                if ( v5 != v4[v6] )
                  goto LABEL_12;
              }
              v7 = (int)&v2[3200 * v1 + 24];
              v1 = 10;
            }
          }
        }
      }
LABEL_12:
      ++v1;
    }
    while ( v1 < 0xA );
    result = v7;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\bam\\bam_main.c", 379, 1, 0);
    result = 0;
  }
  return result;
}

//----- (100014B0) --------------------------------------------------------
char sub_100014B0()
{
  char *v0; // eax@1
  int v1; // ebx@1
  char result; // al@2
  unsigned int v3; // esi@3
  int v4; // edi@3

  v0 = (char *)sub_10001E00(1);
  v1 = (int)v0;
  if ( v0 )
  {
    v3 = 0;
    v4 = (int)(v0 + 24);
    do
    {
      result = sub_10001290(v4, v1, v3++);
      v4 += 3200;
    }
    while ( v3 < 0xA );
  }
  else
  {
    result = sub_1000D9C0("..\\lib\\acl\\bam\\bam_main.c", 716, 1, 0);
  }
  return result;
}

//----- (10001530) --------------------------------------------------------
char __cdecl sub_10001530(int a1, unsigned int a2, int a3)
{
  char result; // al@2
  int v4; // eax@5
  int v5; // edi@5
  int v6; // esi@7
  unsigned int v7; // ecx@7
  int v8; // eax@7
  unsigned int v9; // eax@11
  bool v10; // zf@18
  unsigned int v11; // eax@18

  if ( a3 )
  {
    if ( a2 )
    {
      v4 = sub_10002170(a1);
      v5 = v4;
      if ( v4 )
      {
        v6 = v4 + 32;
        v7 = 0;
        v8 = v4 + 32;
        while ( !*(_BYTE *)v8 || *(_DWORD *)(v8 + 24) != a2 )
        {
          ++v7;
          v8 += 96;
          if ( v7 >= 0x20 )
          {
            v9 = 0;
            while ( *(_BYTE *)v6 )
            {
              ++v9;
              v6 += 96;
              if ( v9 >= 0x20 )
              {
                ++*(_DWORD *)(v5 + 3124);
                goto LABEL_15;
              }
            }
            *(_BYTE *)v6 = 1;
            *(_DWORD *)(v6 + 84) = v5;
            v10 = sub_10001BF0(a2) == 0;
            v11 = a2;
            if ( v10 )
              v11 = (a2 & 0xFFFFFFF8) + 8;
            *(_DWORD *)(v6 + 20) = v11;
            *(_DWORD *)(v6 + 24) = a2;
            *(_DWORD *)(v6 + 28) = a3;
            *(_DWORD *)(v6 + 60) = a3;
            ++*(_DWORD *)(v5 + 28);
            ++*(_DWORD *)(v5 + 3104);
            return 1;
          }
        }
        if ( *(_BYTE *)(v5 + 3197) )
        {
          *(_DWORD *)(v8 + 28) += a3;
          *(_DWORD *)(v8 + 60) += a3;
          result = 1;
        }
        else
        {
LABEL_15:
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10001600) --------------------------------------------------------
int __usercall sub_10001600@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  void *v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  char v5; // bl@1
  _DWORD *v6; // edx@1

  v1 = a1;
  v2 = sub_10001E00(2);
  v3 = 0;
  v4 = ~v1;
  v5 = 0;
  v6 = (char *)v2 + 32024;
  do
  {
    if ( v5 )
      goto LABEL_8;
    if ( *v6 )
    {
      ++v3;
      ++v6;
    }
    else
    {
      v5 = 1;
    }
  }
  while ( v3 < 5 );
  if ( v5 )
  {
LABEL_8:
    *((_DWORD *)v2 + v3 + 8006) = v4;
    return v4;
  }
  return 0;
}

//----- (10001650) --------------------------------------------------------
unsigned int __usercall sub_10001650@<eax>(unsigned int a1@<esi>, _DWORD *a2)
{
  bool v2; // zf@1
  unsigned int result; // eax@1
  char v4; // [sp+0h] [bp-4h]@0

  v2 = sub_10001BF0(v4) == 0;
  result = a1;
  if ( v2 )
  {
    result = (a1 & 0xFFFFFFF8) + 8;
    *a2 = result - a1;
  }
  return result;
}

//----- (10001670) --------------------------------------------------------
int __usercall sub_10001670@<eax>(char a1@<al>, int a2@<esi>)
{
  signed int v2; // ecx@1
  signed int v3; // edx@1

  v2 = 0;
  v3 = 0;
  if ( a1 == 3 || a1 == 1 )
    v2 = 48;
  if ( a1 == 3 || a1 == 2 )
    v2 += *(_DWORD *)(a2 + 20) + 24;
  if ( a1 == 3 )
    v3 = 8;
  return v3 + v2 * *(_DWORD *)(a2 + 28);
}

//----- (100016B0) --------------------------------------------------------
int __usercall sub_100016B0@<eax>(int a1@<esi>, int a2, int a3)
{
  int result; // eax@1

  memset((void *)a1, 0, 0x30u);
  result = a2;
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = -122944301;
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  return result;
}

//----- (100016E0) --------------------------------------------------------
unsigned int __usercall sub_100016E0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  unsigned int result; // eax@1

  *(_DWORD *)a2 = a1;
  result = a1 ^ 0xAD8CCC84;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (100016F0) --------------------------------------------------------
int __usercall sub_100016F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // edi@1
  int v4; // ecx@1
  int v5; // ecx@1
  int result; // eax@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v3 = *(_DWORD *)(a1 + 20);
  v9 = 0;
  v10 = 0;
  *(_DWORD *)(a3 + 4) = -122944301;
  *(_DWORD *)(a3 + 40) = a1;
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 84);
  v3 += 24;
  *(_DWORD *)(a3 + 12) = a2;
  v4 = *(_DWORD *)(a1 + 44) + a2 * v3;
  *(_DWORD *)(a3 + 20) = v3;
  *(_DWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 24) = v4 + 16;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 20);
  sub_10001B40(a3, &v7, &v8);
  *(_DWORD *)v7 = -168364040;
  *(_DWORD *)(v7 + 4) = -235736076;
  *(_DWORD *)v8 = -168364040;
  *(_DWORD *)(v8 + 4) = -235736076;
  sub_100016E0(a3, (int)&v9);
  sub_10001C20(v5, a3);
  result = v3;
  *(_BYTE *)(a3 + 8) = 1;
  return result;
}

//----- (10001790) --------------------------------------------------------
int __usercall sub_10001790@<eax>(unsigned __int8 a1@<al>, unsigned int a2@<ecx>, int a3@<edi>, int a4)
{
  unsigned int v4; // ebp@1
  int v5; // ebx@1
  int v6; // eax@1
  unsigned int v7; // esi@1
  int v8; // eax@3
  bool v9; // sf@3
  unsigned __int8 v10; // of@3
  int v11; // eax@4
  int v12; // esi@4
  unsigned int v14; // eax@15
  void *v15; // ebp@15
  int v16; // eax@15
  int v17; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1 - 1;
  v7 = a2;
  v17 = 0;
  if ( !v6 )
  {
    if ( *(_DWORD *)(a3 + 36) )
      sub_1000D9C0("..\\lib\\acl\\bam\\bam_setup.c", 1502, 1, 0);
    if ( *(_DWORD *)(a3 + 52) )
      sub_1000D9C0("..\\lib\\acl\\bam\\bam_setup.c", 1503, 1, 0);
    if ( *(_DWORD *)(a3 + 56) )
      sub_1000D9C0("..\\lib\\acl\\bam\\bam_setup.c", 1504, 1, 0);
    if ( !*(_DWORD *)(a3 + 84) || *(_BYTE *)(a3 + 8) )
    {
      sub_1000D9C0("..\\lib\\acl\\bam\\bam_setup.c", 1509, 1, 0);
    }
    else
    {
      *(_DWORD *)(a3 + 52) = 0;
      *(_DWORD *)(a3 + 56) = 0;
      v14 = sub_10001650(v7, &v17);
      v15 = (void *)v14;
      *(_DWORD *)(a3 + 36) = v14;
      v16 = sub_10001670(1, a3);
      v5 = v16 + v17;
      v10 = __OFSUB__(a4, v16 + v17);
      v9 = a4 - (v16 + v17) < 0;
      *(_DWORD *)(a3 + 40) = v16;
      if ( !(v9 ^ v10) )
      {
        if ( !(*(_BYTE *)(*(_DWORD *)(a3 + 84) + 3196) & 8) )
          memset(v15, 0, v16);
        return v5;
      }
    }
    return 0;
  }
  if ( v6 != 1 )
    return v5;
  *(_DWORD *)(a3 + 44) = sub_10001650(a2, &v17);
  v8 = sub_10001670(2, a3);
  v5 = v17;
  v10 = __OFSUB__(a4 - v17, v8);
  v9 = a4 - v17 - v8 < 0;
  *(_DWORD *)(a3 + 48) = v8;
  if ( v9 ^ v10 )
    return 0;
  v11 = *(_DWORD *)(a3 + 28);
  v12 = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a3 + 92) = 0;
  *(_DWORD *)(a3 + 88) = v11;
  if ( !v11 )
    return v5;
  do
  {
    sub_100016B0(v12, a3, v4);
    v5 += sub_100016F0(a3, v4, v12);
    *(_BYTE *)(v12 + 9) = 1;
    sub_10001350(2, v12);
    ++v4;
    v12 += 48;
  }
  while ( v4 < *(_DWORD *)(a3 + 28) );
  return v5;
}

//----- (100018F0) --------------------------------------------------------
char __usercall sub_100018F0@<al>(int a1@<eax>, unsigned int a2@<esi>)
{
  unsigned int v2; // edi@1
  char *v3; // eax@1
  unsigned int v4; // ecx@1
  int v5; // eax@1

  v2 = a2 + a1;
  v3 = (char *)sub_10001E00(2);
  v4 = 0;
  v5 = (int)(v3 + 44);
  while ( !*(_BYTE *)(v5 - 8) || *(_DWORD *)v5 + *(_DWORD *)(v5 + 4) <= a2 || *(_DWORD *)v5 >= v2 )
  {
    ++v4;
    v5 += 3200;
    if ( v4 >= 0xA )
      return 0;
  }
  return 1;
}

//----- (10001930) --------------------------------------------------------
_BYTE *__cdecl sub_10001930(char *a1)
{
  _BYTE *result; // eax@6
  int v2; // esi@6

  if ( a1 && *a1 && strlen(a1) < 0x40 && sub_10001E00(2) && !sub_10001410(a1) )
  {
    result = sub_10001EF0();
    v2 = (int)result;
    if ( result )
    {
      sub_1000D560((int)(result + 3132), a1, 64);
      *(_BYTE *)(v2 + 3196) = 2;
      sub_10002110(2);
      result = (_BYTE *)sub_10001600(v2);
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100019B0) --------------------------------------------------------
int __usercall sub_100019B0@<eax>(_BYTE *a1@<eax>)
{
  int v1; // ebx@3
  _BYTE *v2; // esi@3
  signed int v3; // edi@3
  int result; // eax@7

  if ( a1 && *a1 )
  {
    v1 = 0;
    v2 = a1 + 32;
    v3 = 32;
    do
    {
      if ( *v2 )
        v1 += sub_10001670(3, (int)v2);
      v2 += 96;
      --v3;
    }
    while ( v3 );
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100019F0) --------------------------------------------------------
int __cdecl sub_100019F0(int a1)
{
  _BYTE *v1; // eax@1
  int result; // eax@2

  v1 = (_BYTE *)sub_10002170(a1);
  if ( v1 )
    result = sub_100019B0(v1);
  else
    result = 0;
  return result;
}

//----- (10001A10) --------------------------------------------------------
int __cdecl sub_10001A10(int a1, void *a2, size_t a3)
{
  int result; // eax@1
  int v4; // ebp@1
  int v5; // esi@8
  int v6; // ebp@8
  _BYTE *v7; // edi@8
  int v8; // eax@10
  int v9; // edi@13
  int v10; // eax@15
  unsigned int v11; // [sp+4h] [bp-8h]@8
  unsigned int v12; // [sp+4h] [bp-8h]@13
  int v13; // [sp+8h] [bp-4h]@1

  result = sub_10002170(a1);
  v4 = result;
  v13 = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 12) || !a2 || sub_100018F0(a3, (unsigned int)a2) || a3 < sub_100019B0((_BYTE *)v4) )
      goto LABEL_20;
    if ( *(_BYTE *)(v4 + 3196) & 8 )
      memset(a2, 0, a3);
    sub_10001EB0(a1);
    *(_DWORD *)(v4 + 24) = a3;
    v5 = a3;
    *(_DWORD *)(v4 + 20) = a2;
    v6 = 0;
    v11 = 0;
    v7 = (_BYTE *)(v13 + 32);
    do
    {
      if ( *v7 )
      {
        v8 = sub_10001790(1u, (unsigned int)a2 + v6, (int)v7, v5);
        if ( !v8 )
          goto LABEL_20;
        v6 += v8;
        v5 -= v8;
      }
      v7 += 96;
      ++v11;
    }
    while ( v11 < 0x20 );
    v12 = 0;
    v9 = v13 + 32;
    do
    {
      if ( *(_BYTE *)v9 )
      {
        v10 = sub_10001790(2u, (unsigned int)a2 + v6, v9, v5);
        if ( !v10 )
          goto LABEL_20;
        v6 += v10;
        v5 -= v10;
        *(_BYTE *)(v9 + 8) = 1;
      }
      v9 += 96;
      ++v12;
    }
    while ( v12 < 0x20 );
    if ( !sub_10002360(1) )
    {
LABEL_20:
      result = 0;
    }
    else
    {
      result = v13;
      *(_BYTE *)(v13 + 12) = 1;
    }
  }
  return result;
}

//----- (10001B40) --------------------------------------------------------
int __cdecl sub_10001B40(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax@1
  int v4; // ecx@5

  result = a1;
  if ( a1 && a2 && a3 )
  {
    if ( *(_DWORD *)(a1 + 4) == -122944301
      && (v4 = *(_DWORD *)(a1 + 16)) != 0
      && *(_DWORD *)(a1 + 24)
      && *(_DWORD *)(a1 + 28) )
    {
      *a2 = v4 + 8;
      *a3 = *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 28);
    }
    else
    {
      *a2 = 0;
      *a3 = 0;
    }
  }
  return result;
}

//----- (10001BA0) --------------------------------------------------------
int __cdecl sub_10001BA0(int a1)
{
  int result; // eax@2

  if ( sub_10002170(a1) || (result = a1) == 0 || *(_DWORD *)(a1 + 4) != -122944301 )
    result = 0;
  return result;
}

//----- (10001BD0) --------------------------------------------------------
int __cdecl sub_10001BD0(int *a1)
{
  int result; // eax@2

  if ( sub_100021B0((int)a1) )
    result = *a1;
  else
    result = 0;
  return result;
}

//----- (10001BF0) --------------------------------------------------------
bool __cdecl sub_10001BF0(char a1)
{
  return (a1 & 7) == 0;
}

//----- (10001C00) --------------------------------------------------------
void __cdecl sub_10001C00(int a1, int a2)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 12);
    }
  }
}

//----- (10001C20) --------------------------------------------------------
int __cdecl sub_10001C20(int a1, int a2)
{
  int result; // eax@2

  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      result = *(_DWORD *)(a2 + 24) - 16;
      *(_DWORD *)result = *(_DWORD *)a1;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
    }
  }
  return result;
}

//----- (10001C50) --------------------------------------------------------
int __cdecl sub_10001C50(int a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@2
  signed int v4; // ebx@2
  unsigned int v5; // edx@4
  unsigned int v6; // edx@14
  unsigned int v7; // edx@19

  result = 0;
  if ( a1 )
  {
    v3 = a1 + 152;
    v4 = 8;
    do
    {
      if ( *(_BYTE *)(v3 - 120) )
      {
        v5 = *(_DWORD *)(v3 - 96);
        if ( v5 >= a2 && (!result || *(_DWORD *)(result + 24) > v5) )
          result = v3 - 120;
      }
      if ( *(_BYTE *)(v3 - 24) && *(_DWORD *)v3 >= a2 && (!result || *(_DWORD *)(result + 24) > *(_DWORD *)v3) )
        result = v3 - 24;
      if ( *(_BYTE *)(v3 + 72) )
      {
        v6 = *(_DWORD *)(v3 + 96);
        if ( v6 >= a2 && (!result || *(_DWORD *)(result + 24) > v6) )
          result = v3 + 72;
      }
      if ( *(_BYTE *)(v3 + 168) )
      {
        v7 = *(_DWORD *)(v3 + 192);
        if ( v7 >= a2 && (!result || *(_DWORD *)(result + 24) > v7) )
          result = v3 + 168;
      }
      v3 += 384;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10001D00) --------------------------------------------------------
int __cdecl sub_10001D00(int a1)
{
  int result; // eax@1

  result = a1;
  --*(_DWORD *)(result + 4);
  ++*(_DWORD *)result;
  ++*(_DWORD *)(result + 16);
  return result;
}

//----- (10001D10) --------------------------------------------------------
int __cdecl sub_10001D10(int a1)
{
  int result; // eax@1
  unsigned int v2; // ecx@1
  unsigned int v3; // edx@1

  result = a1;
  --*(_DWORD *)result;
  ++*(_DWORD *)(result + 4);
  ++*(_DWORD *)(result + 12);
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 <= v2 )
    *(_DWORD *)(a1 + 8) = v2;
  else
    *(_DWORD *)(a1 + 8) = v3;
  return result;
}

//----- (10001D40) --------------------------------------------------------
void *__usercall sub_10001D40@<eax>(int a1@<esi>)
{
  void *result; // eax@1

  result = memset((void *)a1, 0, 0x7D2Cu);
  *(_BYTE *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = -122944301;
  return result;
}

//----- (10001D60) --------------------------------------------------------
int __usercall sub_10001D60@<eax>(int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@2
  unsigned int v3; // edx@2
  _DWORD *v4; // ecx@3
  int result; // eax@4

  if ( *(_BYTE *)a1 && (v2 = *(_DWORD *)(a1 + 28), v3 = 0, v2) )
  {
    v4 = (_DWORD *)(*(_DWORD *)(a1 + 36) + 24);
    while ( 1 )
    {
      result = (int)(v4 - 6);
      if ( *((_BYTE *)v4 - 15) )
      {
        if ( *v4 == a2 )
          break;
      }
      ++v3;
      v4 += 12;
      if ( v3 >= v2 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

//----- (10001D90) --------------------------------------------------------
int __cdecl sub_10001D90(int a1, unsigned int a2)
{
  int v2; // edi@3

  if ( !a1 || *(_DWORD *)(a1 + 20) < a2 )
    return 0;
  v2 = *(_DWORD *)(a1 + 56);
  if ( !v2 )
  {
    ++*(_DWORD *)(a1 + 80);
    return 0;
  }
  if ( !sub_10001350(1, *(_DWORD *)(a1 + 56)) )
    return 0;
  sub_10001D10(a1 + 60);
  --*(_DWORD *)(a1 + 88);
  ++*(_DWORD *)(a1 + 92);
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 44) + 3196) & 2 )
    memset(*(void **)(v2 + 24), 0, *(_DWORD *)(v2 + 28));
  return *(_DWORD *)(v2 + 24);
}

//----- (10001E00) --------------------------------------------------------
void *__cdecl sub_10001E00(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 == 1 )
  {
    sub_10001D40((int)&unk_100E0890);
    result = &unk_100E0890;
  }
  else if ( a1 == 2 && dword_100E08A0 == -122944301 )
  {
    result = &unk_100E0890;
  }
  return result;
}
// 100E08A0: using guessed type int dword_100E08A0;

//----- (10001E40) --------------------------------------------------------
char __cdecl sub_10001E40(int a1)
{
  int v1; // esi@4
  char result; // al@6

  if ( a1 && sub_10002210(a1) && *(_BYTE *)(a1 + 9) )
  {
    v1 = *(_DWORD *)(a1 + 40);
    if ( *(_BYTE *)(*(_DWORD *)(v1 + 84) + 3196) & 4 )
      memset(*(void **)(a1 + 24), 0, *(_DWORD *)(a1 + 28));
    sub_10001350(2, a1);
    sub_10001D00(v1 + 60);
    result = 1;
    ++*(_DWORD *)(v1 + 88);
    --*(_DWORD *)(v1 + 92);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001EB0) --------------------------------------------------------
_DWORD *__cdecl sub_10001EB0(int a1)
{
  _DWORD *result; // eax@1
  unsigned int v2; // ecx@1

  result = sub_10001E00(2);
  v2 = 0;
  do
  {
    if ( a1 == result[v2 + 8006] )
    {
      result[v2 + 8006] = 0;
      v2 = 5;
    }
    ++v2;
  }
  while ( v2 < 5 );
  return result;
}

//----- (10001EF0) --------------------------------------------------------
_BYTE *sub_10001EF0()
{
  _BYTE *v0; // ebx@1
  void *v1; // edi@1
  unsigned int v2; // ebp@1
  char v3; // al@1
  _BYTE *v4; // esi@1

  v0 = 0;
  v1 = sub_10001E00(2);
  v2 = 0;
  v3 = 0;
  v4 = (char *)v1 + 24;
  do
  {
    if ( v3 )
      return v0;
    v0 = v4;
    if ( *v4 )
    {
      ++v2;
      v4 += 3200;
    }
    else
    {
      ++*((_DWORD *)v1 + 5);
      *v4 = 1;
      sub_10002150((int)v4);
      v3 = 1;
    }
  }
  while ( v2 < 0xA );
  if ( v3 )
    return v0;
  return 0;
}

//----- (10001F50) --------------------------------------------------------
int __usercall sub_10001F50@<eax>(int a1@<eax>, _BYTE *a2@<ecx>)
{
  int v2; // edi@1
  int result; // eax@1
  unsigned int v4; // ebp@1
  char v5; // bl@1
  int v6; // esi@2

  v2 = a1;
  result = 0;
  v4 = 0;
  v5 = 0;
  if ( *a2 )
  {
    v6 = (int)(a2 + 32);
    while ( !v5 )
    {
      result = sub_10001D60(v6, v2);
      if ( result )
      {
        v5 = 1;
      }
      else
      {
        ++v4;
        v6 += 96;
      }
      if ( v4 >= 0x20 )
      {
        if ( v5 )
          return result;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (10001F90) --------------------------------------------------------
int __cdecl sub_10001F90(int a1, unsigned int a2)
{
  int v2; // eax@1

  v2 = sub_10001C50(a1, a2);
  return sub_10001D90(v2, a2);
}

//----- (10001FB0) --------------------------------------------------------
void *__cdecl sub_10001FB0(int a1)
{
  int v1; // ebp@1
  void *result; // eax@1
  unsigned int v3; // edi@2
  char v4; // bl@2
  _BYTE *v5; // esi@2

  v1 = 0;
  result = sub_10001E00(2);
  if ( result )
  {
    v3 = 0;
    v4 = 0;
    v5 = (char *)result + 24;
    do
    {
      if ( v4 )
        return (void *)v1;
      v1 = sub_10001F50(a1, v5);
      if ( v1 )
      {
        v4 = 1;
      }
      else
      {
        ++v3;
        v5 += 3200;
      }
    }
    while ( v3 < 0xA );
    if ( v4 )
      return (void *)v1;
    result = 0;
  }
  return result;
}

//----- (10002010) --------------------------------------------------------
void *__cdecl sub_10002010(int a1)
{
  void *v1; // esi@1
  void *result; // eax@5
  char v3; // [sp+8h] [bp-8h]@1

  sub_10001C00((int)&v3, a1);
  v1 = (void *)sub_10001BD0((int *)&v3);
  if ( (v1 || (v1 = sub_10001FB0(a1)) != 0) && sub_10002070((int)v1) && sub_100020B0((int)v1) )
    result = v1;
  else
    result = 0;
  return result;
}

//----- (10002070) --------------------------------------------------------
bool __cdecl sub_10002070(int a1)
{
  return a1
      && *(_DWORD *)(a1 + 4) == -122944301
      && *(_DWORD *)(a1 + 40)
      && *(_DWORD *)(a1 + 44)
      && *(_DWORD *)(a1 + 28)
      && *(_DWORD *)(a1 + 16)
      && *(_DWORD *)(a1 + 20)
      && *(_DWORD *)(a1 + 24);
}

//----- (100020B0) --------------------------------------------------------
bool __cdecl sub_100020B0(int a1)
{
  int v1; // ecx@0
  bool result; // al@8
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = 0;
  if ( a1 )
  {
    sub_10001B40(a1, &a1, &v3);
    if ( a1 )
    {
      if ( v3
        && *(_DWORD *)a1 == -168364040
        && *(_DWORD *)(a1 + 4) == -235736076
        && *(_DWORD *)v3 == -168364040
        && *(_DWORD *)(v3 + 4) == -235736076 )
      {
        result = 1;
      }
    }
  }
  return result;
}

//----- (10002110) --------------------------------------------------------
bool __cdecl sub_10002110(char a1)
{
  return !(a1 & 1) || a1 == 1;
}

//----- (10002130) --------------------------------------------------------
bool __cdecl sub_10002130(_DWORD *a1)
{
  _DWORD *v1; // eax@1

  v1 = a1;
  if ( !a1 )
    v1 = sub_10001E00(2);
  return v1[4] == -122944301;
}

//----- (10002150) --------------------------------------------------------
bool __cdecl sub_10002150(int a1)
{
  return a1 && *(_DWORD *)(a1 + 4) == -122944301;
}

//----- (10002170) --------------------------------------------------------
int __cdecl sub_10002170(int a1)
{
  _DWORD *v1; // esi@1
  int result; // eax@1
  unsigned int v3; // ecx@3

  v1 = sub_10001E00(2);
  result = 0;
  if ( v1 && a1 )
  {
    v3 = 0;
    do
    {
      if ( a1 == v1[v3 + 8006] )
      {
        result = ~a1;
        v3 = 5;
      }
      ++v3;
    }
    while ( v3 < 5 );
  }
  return result;
}

//----- (100021B0) --------------------------------------------------------
bool __cdecl sub_100021B0(int a1)
{
  return a1 && (*(_DWORD *)a1 ^ 0xAD8CCC84) == *(_DWORD *)(a1 + 4);
}

//----- (100021D0) --------------------------------------------------------
bool __usercall sub_100021D0@<al>(int a1@<eax>)
{
  char v2; // [sp+0h] [bp-8h]@1

  sub_10001C00((int)&v2, *(_DWORD *)(a1 + 24));
  return sub_100021B0((int)&v2);
}

//----- (100021F0) --------------------------------------------------------
bool __usercall sub_100021F0@<al>(int a1@<eax>)
{
  return a1 && *(_DWORD *)(a1 + 4) == -122944301;
}

//----- (10002210) --------------------------------------------------------
char __cdecl sub_10002210(int a1)
{
  _DWORD *v1; // eax@4
  char result; // al@5

  if ( sub_10002070(a1) && sub_100020B0(a1) && sub_100021D0(a1) && (v1 = sub_10001E00(2)) != 0 )
  {
    ++v1[2];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002260) --------------------------------------------------------
bool __usercall sub_10002260@<al>(int a1@<eax>)
{
  int v1; // edi@1
  bool result; // al@1
  _BYTE *v3; // eax@2
  int v4; // edx@2
  unsigned int v5; // esi@3
  int v6; // ebx@4
  unsigned int v7; // edi@8
  int v8; // edx@9
  int v9; // ecx@9

  v1 = a1;
  result = sub_100021F0(a1);
  if ( result )
  {
    v3 = sub_10001E00(2);
    v4 = *(_DWORD *)(v1 + 36);
    if ( *v3 )
    {
      v5 = 0;
      if ( *(_DWORD *)(v1 + 28) )
      {
        v6 = *(_DWORD *)(v1 + 36);
        while ( sub_10002210(v6) )
        {
          ++v5;
          v6 += 48;
          if ( v5 >= *(_DWORD *)(v1 + 28) )
            goto LABEL_7;
        }
        return 0;
      }
    }
    else
    {
      v7 = *(_DWORD *)(v1 + 28);
      if ( v7 )
      {
        while ( sub_10002070(v4) )
        {
          v4 = v8 + 48;
          if ( v9 + 1 >= v7 )
            return 1;
        }
        return 0;
      }
    }
LABEL_7:
    result = 1;
  }
  return result;
}

//----- (100022E0) --------------------------------------------------------
bool __thiscall sub_100022E0(void *this)
{
  bool result; // al@1
  int v2; // ecx@1
  unsigned int v3; // esi@2
  int v4; // edi@2

  result = sub_10002150((int)this);
  if ( result )
  {
    v3 = 0;
    v4 = v2 + 32;
    while ( !*(_BYTE *)(v4 + 8) || sub_10002260(v4) )
    {
      ++v3;
      v4 += 96;
      if ( v3 >= 0x20 )
        return 1;
    }
    result = 0;
  }
  return result;
}

//----- (10002320) --------------------------------------------------------
char __usercall sub_10002320@<al>(int a1@<eax>)
{
  unsigned int v1; // esi@1
  void *v2; // edi@1

  v1 = 0;
  v2 = (void *)(a1 + 24);
  while ( sub_100022E0(v2) )
  {
    ++v1;
    v2 = (char *)v2 + 3200;
    if ( v1 >= 0xA )
      return 1;
  }
  return 0;
}

//----- (10002360) --------------------------------------------------------
bool __cdecl sub_10002360(char a1)
{
  _DWORD *v1; // eax@1
  int v2; // esi@1
  bool result; // al@6

  v1 = sub_10001E00(2);
  v2 = (int)v1;
  if ( v1 )
  {
    if ( a1 )
      *(_BYTE *)v1 = 1;
    result = sub_10002130(v1) && sub_10002320(v2);
    if ( a1 )
      *(_BYTE *)v2 = 0;
    if ( result )
      ++*(_DWORD *)(v2 + 4);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100023C0) --------------------------------------------------------
char __cdecl sub_100023C0(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_1077A428;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 1077A428: using guessed type int dword_1077A428;

//----- (10002470) --------------------------------------------------------
bool __cdecl sub_10002470(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (10002490) --------------------------------------------------------
int __usercall sub_10002490@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_10037FB0(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10037F70: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10037F90: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10037FA0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 100381D0: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002540) --------------------------------------------------------
int __cdecl sub_10002540(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_10002470(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (10002570) --------------------------------------------------------
char __cdecl sub_10002570(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100039D0(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10038220();
        sub_10038270(1);
        v6 = sub_100381E0(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_103F9618;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10038220();
      sub_10038270(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_100381E0(a4, a5, 59);
      LOBYTE(v6) = sub_10002490(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_1000D9C0(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 10054F84: using guessed type void *off_10054F84;

//----- (100026B0) --------------------------------------------------------
char __cdecl sub_100026B0(int a1, char *a2)
{
  char result; // al@5
  int v3; // esi@6

  if ( !a2 )
    sub_1000D9C0(".\\cdp_cnvs_utl.c", 388, 1, 0);
  if ( (a2[24] & 3) == 2 )
  {
    j_gdi_pvg_make_window_current(*((_DWORD *)a2 + 13));
    result = 1;
  }
  else if ( (a2[24] & 3) == 3 )
  {
    j_gdi_pvg_make_window_current(*((_DWORD *)a2 + 13));
    v3 = *(_DWORD *)(a1 + 56);
    if ( *(_DWORD *)(v3 + 8) != *(_DWORD *)(a1 + 44) )
    {
      sub_10002490(a1, v3);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
    }
    result = 1;
  }
  else
  {
    sub_1000D9C0(".\\cdp_cnvs_utl.c", 473, 1, 0);
    result = 1;
  }
  return result;
}
// 10037F90: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10002740) --------------------------------------------------------
unsigned int sub_10002740()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // edx@3

  v0 = dword_10779FC4;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&unk_1077A42C );
  do
  {
    v2 = dword_1004FF38[result];
    dword_10779FC0[2 * v2] = *(int *)((char *)&off_1004FF3C + result * 4);
    v3 = dword_1004FF40[result];
    result += 3;
    dword_10779FC4[2 * v2] = v3;
  }
  while ( result < 33 );
  return result * 4;
}
// 1004FF38: using guessed type int dword_1004FF38[];
// 1004FF3C: using guessed type int (__cdecl *off_1004FF3C)(int, int, int, int, int);
// 1004FF40: using guessed type int dword_1004FF40[];
// 10779FC0: using guessed type int dword_10779FC0[];
// 10779FC4: using guessed type int dword_10779FC4[];

//----- (10002790) --------------------------------------------------------
int __cdecl sub_10002790(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (100027B0) --------------------------------------------------------
int __cdecl sub_100027B0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (100027E0) --------------------------------------------------------
int __cdecl sub_100027E0(int a1, int a2)
{
  byte_10779FA0 = 0;
  sub_1000E310(&unk_100E85C0);
  return nullsub_1(a1, a2);
}
// 10779FA0: using guessed type char byte_10779FA0;

//----- (10002800) --------------------------------------------------------
int __cdecl sub_10002800(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_1000D9C0(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10003950(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10003950(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10003950(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10003950(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10002890) --------------------------------------------------------
char __cdecl sub_10002890(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10038490(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_1000D9C0(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10002900) --------------------------------------------------------
char __cdecl sub_10002900(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10038490(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_1000D9C0(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10002970) --------------------------------------------------------
int sub_10002970()
{
  int result; // eax@1

  result = sub_10038330();
  dword_100E85C8 = result;
  byte_100E85C4 = 0;
  return result;
}
// 100E85C4: using guessed type char byte_100E85C4;
// 100E85C8: using guessed type int dword_100E85C8;

//----- (10002990) --------------------------------------------------------
_DWORD *__cdecl sub_10002990(int a1)
{
  return sub_1000E350(&unk_100E85C0, a1);
}

//----- (100029B0) --------------------------------------------------------
unsigned int __cdecl sub_100029B0(int a1, int a2, int a3)
{
  int v3; // ecx@1
  unsigned int result; // eax@1

  v3 = a3 * (1000 / *(_WORD *)(a1 + 20)) + 500;
  result = ((signed int)((unsigned __int64)(v3 * (signed __int64)(signed int)&unk_10624DD3) >> 32) >> 6)
         + ((unsigned int)((unsigned __int64)(v3 * (signed __int64)(signed int)&unk_10624DD3) >> 32) >> 31);
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (10002A20) --------------------------------------------------------
void __usercall sub_10002A20(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10037F50();
    sub_10038220();
    sub_10038280(1);
    sub_10038290(3000000);
    *(_DWORD *)(a1 + 24) = sub_100381E0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (10002A60) --------------------------------------------------------
int __usercall sub_10002A60@<eax>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  int result; // eax@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_10747D9E = *v1 == -32749;
  byte_10779FA0 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_100386C0(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_1000EB20(v3) != 2 && v7 & 0x1C )
  {
    byte_10747D9E = 0;
    byte_10779FA0 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_1000E790() )
  {
    byte_10747D9E = 0;
    byte_10779FA0 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_1000E4E0(a1, (char *)v5, (int)&unk_100630EC);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = nullsub_1(a1, v2);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 10747D9E: using guessed type char byte_10747D9E;
// 10779FA0: using guessed type char byte_10779FA0;

//----- (10002B40) --------------------------------------------------------
void __usercall sub_10002B40(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_10037DB0(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_100023C0(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10037E80(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_10037DB0(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10037F90: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10002C10) --------------------------------------------------------
int __usercall sub_10002C10@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_10002470(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10037E80(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_10037DB0(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10002B40(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    ;
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10037E80(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10037F80: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10037F90: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10038170: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10002DD0) --------------------------------------------------------
char __thiscall sub_10002DD0(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10002DF0) --------------------------------------------------------
signed int __cdecl sub_10002DF0(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10002890(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10002890(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_10002470(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10002F40) --------------------------------------------------------
char __cdecl sub_10002F40(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10002890(a1, (int)&v4, 8);
}

//----- (10002F70) --------------------------------------------------------
char __cdecl sub_10002F70(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10002900(a1, (int)&v4, 8);
}

//----- (10002FA0) --------------------------------------------------------
char __cdecl sub_10002FA0(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_1000E320((int *)&unk_100E85C0, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10007CB0();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10002A60(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_100027B0(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_100023C0(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_1000E790() != byte_100E85C4 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100E85C4 = sub_1000E790();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10003950(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_10050590, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        nullsub_1(a1, v17);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10002DD0(a1) )
          (*(void (__cdecl **)(int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            sub_10007C10(a1);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_100035B0(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10002F40(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10038210: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100E85C4: using guessed type char byte_100E85C4;

//----- (100032D0) --------------------------------------------------------
int __usercall sub_100032D0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_100382E0(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_100382E0(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10002FA0(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10002C10(v1, (int)&off_10054F84);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 10054F84: using guessed type void *off_10054F84;

//----- (10003360) --------------------------------------------------------
void __usercall __noreturn sub_10003360(char *a1@<edi>)
{
  void *v1; // ecx@8
  unsigned int v2; // esi@16
  int v3; // eax@19
  int v4; // [sp+0h] [bp-FCh]@0
  int v5; // [sp+4h] [bp-F8h]@0
  int v6; // [sp+10h] [bp-ECh]@1
  char v7; // [sp+14h] [bp-E8h]@9
  char v8; // [sp+18h] [bp-E4h]@5

  dword_10779F9C = (int)&dword_10747DA0;
  sub_10038570(&v6);
  if ( !(v6 & 0x10) )
    sub_1000D9C0(".\\cdp_main.c", 403, 1, 0);
  v6 |= 0x10u;
  if ( !sub_10038500(1, 20000) )
    sub_1000D9C0(".\\cdp_main.c", 428, 1, 0);
  sub_1000F070();
  sub_1000EC40(&v8);
  sub_10038860();
  while ( 1 )
  {
    byte_10779F48 = 0;
    if ( v6 & 0x10 || v6 & 0x8000 )
    {
      sub_100027B0((int)&byte_10779DC0);
      byte_10779DC2 = sub_1000E730(v1);
      byte_10779DC4 = 0;
      dword_10779DF4 = (int)&unk_100E85D0;
      word_10779DCE = 768;
      word_10779DD0 = 1024;
      dword_10779E00 = 13;
      word_10779DD4 = 40;
      dword_10779DD8 = -1;
      dword_10779DDC = -1;
      byte_10779DCB = 1;
      dword_10779E08 = 0;
      byte_10779DC0 = 0;
      while ( sub_100382E0(dword_10779DF4, (int)&v7) != 1 )
        ;
      nullsub_1(v4, v5);
      sub_10003930((int)&byte_10779DC0);
      sub_10007CC0((int)a1, (int)&byte_10779DC0);
      sub_1000F060((int)&unk_10050570);
      sub_10002A20((int)&byte_10779DC0);
      sub_10007CF0((unsigned int)&byte_10779DC0);
    }
    if ( v6 & 2 )
      sub_100032D0((int)&byte_10779DC0);
    if ( v6 & 1 )
    {
      v6 |= 0x20000000u;
      if ( (unsigned int)(sub_10038330() - dword_100E85C8) >= 0x3E8 )
      {
        dword_100E85C8 += 1000;
        sub_1000F040(&byte_10779DC0);
        sub_1000EB30((int *)&v8);
      }
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v6 )
      {
        v3 = sub_1000E590(v2);
        sub_10002DF0((int)&byte_10779DC0, v3);
        sub_100032D0((int)&byte_10779DC0);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_10779F48 || byte_10779DC1 )
    {
      a1 = &byte_10779DC0;
      sub_10002C10((int)&byte_10779DC0, (int)&off_10054F84);
    }
    sub_10038570(&v6);
  }
}
// 1000F040: using guessed type int __cdecl sub_1000F040(_DWORD);
// 1000F070: using guessed type int sub_1000F070(void);
// 10054F84: using guessed type void *off_10054F84;
// 100E85C8: using guessed type int dword_100E85C8;
// 10747DA0: using guessed type int dword_10747DA0;
// 10779DC0: using guessed type char byte_10779DC0;
// 10779DC1: using guessed type char byte_10779DC1;
// 10779DC2: using guessed type char byte_10779DC2;
// 10779DC4: using guessed type char byte_10779DC4;
// 10779DCB: using guessed type char byte_10779DCB;
// 10779DCE: using guessed type __int16 word_10779DCE;
// 10779DD0: using guessed type __int16 word_10779DD0;
// 10779DD4: using guessed type __int16 word_10779DD4;
// 10779DD8: using guessed type int dword_10779DD8;
// 10779DDC: using guessed type int dword_10779DDC;
// 10779DF4: using guessed type int dword_10779DF4;
// 10779E00: using guessed type int dword_10779E00;
// 10779E08: using guessed type int dword_10779E08;
// 10779F48: using guessed type char byte_10779F48;
// 10779F9C: using guessed type int dword_10779F9C;

//----- (10003590) --------------------------------------------------------
int __cdecl sub_10003590(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (100035B0) --------------------------------------------------------
char __cdecl sub_100035B0(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_10747DA4 || a2 >= dword_10747DA0 )
    result = sub_1000D9C0(".\\cdp_mem.c", 222, 1, 0);
  dword_10747DA0 = a2;
  return result;
}
// 10747DA0: using guessed type int dword_10747DA0;

//----- (100035F0) --------------------------------------------------------
char sub_100035F0()
{
  char result; // al@1

  byte_100E86A0 = 0;
  result = sub_10039630((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100E86A0 = 1;
  return result;
}
// 100E86A0: using guessed type char byte_100E86A0;

//----- (10003610) --------------------------------------------------------
char __thiscall sub_10003610(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10038350((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_1000D6F0(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_10039630((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10039460(v1, &byte_100E86A8, 4096),
          sub_10039360(v2),
          (v1 = (unsigned int)strstr(&byte_100E86A8, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100E86A8;
      v4 = v1 - (_DWORD)&byte_100E86A8 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !(((unsigned __int8)byte_100654D8[2 * (unsigned __int8)*(&byte_100E86A8 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100E86A8 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100E96A8 = v1;
    }
    else
    {
      dword_100E96A8 = 0;
    }
  }
  else
  {
    dword_100E96A8 = 0;
  }
  return v1;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100E96A8: using guessed type int dword_100E96A8;

//----- (10003780) --------------------------------------------------------
void *__usercall sub_10003780@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_100E96A8 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_100E96A8 = v3;
    sub_10038350((int)&v10, 1, v5, 20);
    sub_1000D6F0(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_1000D560((int)&byte_100E86A8, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_1000D560((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_1000D720(&byte_100E86A8, &v12, 4096);
    }
    sub_1000D6F0(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 204800);
    result = (void *)sub_1000D720(&byte_100E86A8, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_10003A90((int)i, (__int16 *)&v9, &v11);
      sub_1000D6F0(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_1000D720(&byte_100E86A8, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_1000D620(&byte_100E86A8, 0x1000u);
        j_FIL_vfs_write(v6, &byte_100E86A8, v8);
        sub_100395B0(v6, v8, 0);
        result = (void *)sub_10039360(v6);
      }
    }
  }
  return result;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100E96A8: using guessed type int dword_100E96A8;

//----- (10003930) --------------------------------------------------------
char __cdecl sub_10003930(int a1)
{
  char result; // al@2

  dword_10747DA0 = (int)&unk_10747DA4;
  if ( byte_100E86A0 )
    result = sub_10003610(a1);
  return result;
}
// 100E86A0: using guessed type char byte_100E86A0;
// 10747DA0: using guessed type int dword_10747DA0;

//----- (10003950) --------------------------------------------------------
int __cdecl sub_10003950(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100E86A0 )
    sub_10003780(dword_10747DA0 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_10747DA0, dword_10747DA0 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_1000D9C0(".\\cdp_mem.c", 371, 1, 0);
    result = dword_10747DA0;
  }
  dword_10747DA0 = result + 4 * v2;
  return result;
}
// 100E86A0: using guessed type char byte_100E86A0;
// 10747DA0: using guessed type int dword_10747DA0;

//----- (100039D0) --------------------------------------------------------
int __cdecl sub_100039D0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10003590(a2, a3);
  return sub_10003950(a1, v3);
}

//----- (10003A10) --------------------------------------------------------
__int16 __cdecl sub_10003A10(unsigned __int8 a1)
{
  return *(_WORD *)(dword_10747D98 + 4 * (unsigned __int8)byte_100E96B0[a1] + 2);
}
// 10747D98: using guessed type int dword_10747D98;

//----- (10003A30) --------------------------------------------------------
char __cdecl sub_10003A30(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_1000F0A0(a1);
  if ( v1 == -1 )
    sub_1000D9C0(".\\cdp_page_list.c", 705, 1, 0);
  return byte_10055A44[56 * v1];
}

//----- (10003A70) --------------------------------------------------------
char __cdecl sub_10003A70(int (__cdecl *a1)(int))
{
  return *(_BYTE *)(dword_10747D98 + 4 * (unsigned __int8)byte_100E96B0[(unsigned __int8)sub_10003A30(a1)] + 1);
}
// 10747D98: using guessed type int dword_10747D98;

//----- (10003A90) --------------------------------------------------------
char __cdecl sub_10003A90(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_1000F0A0(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_10003A10(byte_10055A44[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = &aPowerUpPage[v3];
    do
    {
      v7 = *v6;
      v6[a3 - &aPowerUpPage[v3]] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (10003B10) --------------------------------------------------------
char __usercall sub_10003B10@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
  signed int v3; // eax@1
  signed int v4; // esi@3
  char *v5; // edi@3
  int v6; // eax@4
  signed int v7; // eax@8
  char *v8; // esi@8
  int v9; // ecx@9
  int v10; // ST08_4@13
  signed int v11; // edi@13
  int (__cdecl **v12)(int); // ebp@13
  int v14; // [sp-Eh] [bp-10h]@3
  int v15; // [sp-2h] [bp-4h]@1

  v15 = a1;
  dword_10747D98 = (int)byte_10055A34;
  dword_100E96B8 = 0;
  BYTE3(v15) = 0;
  byte_100E96B2 = 1;
  v3 = 0;
  do
  {
    byte_100E96B0[(unsigned __int8)byte_10055A34[4 * v3]] = v3;
    ++v3;
  }
  while ( v3 <= 1 );
  v4 = 0;
  v14 = a2;
  v5 = byte_10055A44;
  memset(&unk_100E96C8, 1, 2u);
  do
  {
    LOBYTE(v6) = *v5;
    if ( (unsigned __int8)*v5 < 1u )
    {
      v6 = (unsigned __int8)v6;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v6 + 3) )
      {
        word_100E96B4[v6] = v4;
        *((_BYTE *)&v15 + (unsigned __int8)v6 + 3) = 1;
      }
    }
    ++v4;
    v5 += 56;
  }
  while ( v4 < 2 );
  dword_100E96BC = (int)*(&off_10055A40 + 14 * (unsigned __int16)word_100E96B4[0]);
  v7 = 1;
  BYTE3(v15) = 0;
  v8 = &byte_10055A44[56];
  do
  {
    LOBYTE(v9) = *v8;
    if ( (unsigned __int8)*v8 < 1u )
    {
      v9 = (unsigned __int8)v9;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v9 + 3) )
      {
        word_100E96C0[v9] = v7;
        *((_BYTE *)&v15 + (unsigned __int8)v9 + 3) = 1;
      }
    }
    --v7;
    v8 -= 56;
  }
  while ( v7 >= 0 );
  sub_10007CE0();
  sub_10003C70(a3);
  nullsub_1(a3, v10);
  v11 = 0;
  v12 = &off_10055A40;
  do
  {
    (*v12)(a3);
    ++v11;
    v12 += 14;
  }
  while ( v11 < 2 );
  nullsub_1(a3, v14);
  sub_10007C10(a3);
  return sub_100035B0(0, *(_DWORD *)(a3 + 56));
}
// 10003B10: could not find valid save-restore pair for edi
// 10055A40: using guessed type int (__cdecl *off_10055A40)(int);
// 100E96B2: using guessed type char byte_100E96B2;
// 100E96B4: using guessed type __int16 word_100E96B4[];
// 100E96B8: using guessed type int dword_100E96B8;
// 100E96BC: using guessed type int dword_100E96BC;
// 100E96C0: using guessed type __int16 word_100E96C0[];
// 10747D98: using guessed type int dword_10747D98;

//----- (10003C70) --------------------------------------------------------
_WORD *__cdecl sub_10003C70(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10003950(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_10050590, 0x14Cu);
  sub_10002800(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1003A640(a1 + 392, (int)&off_10054F84, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1003A5E0(a1 + 392);
}
// 10054F84: using guessed type void *off_10054F84;

//----- (10003CE0) --------------------------------------------------------
_WORD *__cdecl sub_10003CE0(int a1, int a2, _WORD *a3, _WORD *a4, _WORD *a5, _BYTE *a6, unsigned __int8 a7, char a8)
{
  int v8; // ecx@0
  int v9; // edi@1
  unsigned __int16 v10; // ax@2
  __int16 v11; // cx@2
  int v12; // ebp@2
  __int16 v13; // bx@2
  __int16 v14; // ax@4
  __int16 v15; // di@5
  __int16 v16; // si@5
  _WORD *result; // eax@5
  int v18; // esi@6
  signed int v19; // eax@8
  __int16 v20; // [sp+10h] [bp-4h]@4
  int v21; // [sp+30h] [bp+1Ch]@2
  int v22; // [sp+34h] [bp+20h]@4

  v9 = 9 * a7 + *a3 + 28;
  if ( a8 )
  {
    v10 = *(_WORD *)(v8 + 4);
    v11 = *(_WORD *)v8;
    LOWORD(v12) = v10 - v11 + 1;
    v13 = v11;
    v21 = v10;
  }
  else
  {
    LOWORD(v12) = *(_WORD *)(a1 + 16);
    v13 = 0;
    v21 = *(_WORD *)(a1 + 16);
  }
  v12 = (signed __int16)v12;
  v14 = v9 - v12;
  v20 = (signed int)*(float *)a2;
  v22 = (signed __int16)v12;
  if ( v9 - (signed __int16)v12 <= 0 )
  {
    LOWORD(v18) = v21;
    while ( 2 )
    {
      switch ( *a6 )
      {
        case 2:
          v19 = (signed int)*(float *)(a2 + 8);
          LOWORD(v18) = v19 + 2;
          if ( v19 + 2 + v9 <= (signed __int16)v21 )
            goto LABEL_18;
          v18 = (signed int)*(float *)a2 - v9 - 2;
          if ( v18 >= v13 )
            goto LABEL_18;
          v12 = v22;
          *a6 = 3;
          continue;
        case 0:
        case 1:
          v18 = v20 + 2;
          if ( v18 + v9 <= (signed __int16)v21 )
            goto LABEL_18;
          v18 = (signed __int16)v21 - v9;
          if ( v18 >= v13 )
            goto LABEL_18;
          result = a4;
          *a4 = v9;
          *a5 = v13;
          return result;
        case 3:
          v18 = v13 + (v12 - v9) / 2;
          if ( v18 + v9 <= (signed __int16)v21 )
            goto LABEL_18;
          v18 = v12 + v13 - v9;
          if ( v18 >= v13 )
            goto LABEL_18;
          result = a4;
          *a4 = v9;
          *a5 = v13;
          break;
        default:
          sub_1000D9C0("..\\lib\\adl\\cdp_pg_3d_flxlst.c", 907, 1, 0);
LABEL_18:
          result = a4;
          *a4 = v9;
          *a5 = v18;
          break;
      }
      break;
    }
  }
  else
  {
    v15 = v9 - v14;
    v16 = *a3 - v14;
    result = a4;
    *a3 = v16;
    *a4 = v15;
    *a5 = v13;
  }
  return result;
}

//----- (10003E90) --------------------------------------------------------
int __usercall sub_10003E90@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, bool *a9, char a10)
{
  _WORD *v10; // ebp@1
  signed int v11; // eax@1
  signed int v12; // edi@3
  __int16 v13; // si@6
  int v14; // eax@9
  int v15; // ebx@12
  int v16; // esi@13
  int result; // eax@18
  int v18; // eax@21
  signed int v19; // [sp+10h] [bp-8h]@1
  __int16 v20; // [sp+14h] [bp-4h]@8
  int v21; // [sp+20h] [bp+8h]@6
  int v22; // [sp+38h] [bp+20h]@6

  v10 = a4;
  v11 = *a4;
  v19 = 4;
  if ( v11 <= 4 )
    v19 = *a4;
  v12 = 10;
  if ( v11 <= 10 )
    v12 = *a4;
  if ( a10 )
  {
    v13 = *(_WORD *)(a1 + 6);
    v22 = *(_WORD *)(a1 + 6);
    v21 = *(_WORD *)(a1 + 2);
  }
  else
  {
    v22 = (unsigned __int16)(*(_WORD *)(a2 + 14) - 1);
    v21 = 0;
    v13 = *(_WORD *)(a2 + 14) - 1;
  }
  v20 = v13 - v21 + 1;
  if ( *(_DWORD *)(a2 + 64) != 1 )
  {
    v14 = *(_WORD *)(a2 + 14) - 26;
    if ( v13 < v14 )
      LOWORD(v14) = v13;
    v22 = (unsigned __int16)v14;
  }
  v15 = a5 + 1;
  while ( 1 )
  {
    *a9 = *v10 > v12;
    v16 = v12 * v15 + 33;
    if ( !*a8 )
      break;
    if ( *a8 == 1 )
    {
      result = (signed int)*(float *)(a3 + 4) - v16 - 1;
      if ( result >= (signed __int16)v21 )
        goto LABEL_28;
    }
    else if ( *a8 == 2 )
    {
      if ( v16 <= v20 )
      {
        result = (signed __int16)v21 + (v20 - v16) / 2;
        goto LABEL_28;
      }
    }
    else
    {
      sub_1000D9C0("..\\lib\\adl\\cdp_pg_3d_flxlst.c", 1132, 1, 0);
    }
LABEL_22:
    if ( v12 > v19 )
    {
      --v12;
    }
    else
    {
      v12 = *v10;
      if ( v12 > 10 )
        v12 = 10;
      ++*a8;
    }
  }
  v18 = (signed int)*(float *)(a3 + 12) + v16 + 2;
  if ( v18 > (signed __int16)v22 )
    goto LABEL_22;
  result = v18 - v16 + 2;
LABEL_28:
  *a6 = v12 * v15 + 32;
  *a7 = result;
  *v10 = v12;
  return result;
}

//----- (10004010) --------------------------------------------------------
int __usercall sub_10004010@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 8), (int)&unk_10051D94, 0, 255);
  result = sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 28), v2, 0, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004060) --------------------------------------------------------
void __usercall sub_10004060(unsigned int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // esi@1
  __int16 v5; // bp@1
  int v6; // eax@4
  __int16 v7; // cx@9
  int v8; // eax@10
  int v9; // eax@13
  int v10; // eax@15
  __int16 v11; // [sp+Ch] [bp-24h]@8
  int v12; // [sp+10h] [bp-20h]@8
  __int16 v13; // [sp+14h] [bp-1Ch]@12
  int v14; // [sp+18h] [bp-18h]@12
  __int16 v15; // [sp+1Ch] [bp-14h]@12
  __int16 v16; // [sp+20h] [bp-10h]@6
  int v17; // [sp+24h] [bp-Ch]@6
  __int16 v18; // [sp+28h] [bp-8h]@6
  __int16 v19; // [sp+2Ah] [bp-6h]@6

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 52);
  v3 = *(_DWORD *)(v1 + 4);
  v4 = *(_DWORD *)(v1 + 12);
  v5 = *(_WORD *)(v4 + 76);
  if ( *(_WORD *)(v2 + 10) != 33 )
    *(_BYTE *)(a1 + 6) = sub_1000E4E0(a1, (char *)v1, v2);
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      v6 = *(_DWORD *)(v4 + 748);
      if ( !v6 || *(_BYTE *)(*(_WORD *)(v4 + 76) + v6) )
      {
        v17 = v3;
        v16 = -32687;
        v19 = *(_WORD *)(v4 + 76);
        v18 = *(_WORD *)(v4 + 754);
        *(_WORD *)(*(_DWORD *)(v4 + 728) + 2) = v19;
        sub_10002900(a1, (int)&v16, 16);
        goto LABEL_7;
      }
      break;
    case 0x20:
    case 0x28:
      v12 = v3;
      v11 = -32690;
      sub_10002900(a1, (int)&v11, 8);
      goto LABEL_7;
    case 0x38:
    case 0x39:
      v7 = *(_WORD *)(v4 + 76);
      if ( v5 != v7 )
      {
        v8 = *(_DWORD *)(v4 + 748);
        if ( !v8 || *(_BYTE *)(v7 + v8) )
        {
          v14 = v3;
          v13 = -32689;
          v15 = *(_WORD *)(v4 + 76);
          sub_10002900(a1, (int)&v13, 12);
        }
      }
      break;
    case 0x1A:
      v9 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
      if ( v9 )
      {
        if ( *(char (__cdecl **)(int))(v9 + 8) == sub_100077A0 )
        {
          v10 = *(_DWORD *)(v4 + 748);
          if ( !v10 || *(_BYTE *)(*(_WORD *)(v4 + 76) + v10) )
          {
            v17 = v3;
            v16 = -32687;
            v19 = *(_WORD *)(v4 + 76);
            v18 = *(_WORD *)(v4 + 754);
            *(_WORD *)(*(_DWORD *)(v4 + 728) + 2) = v19;
            sub_10002900(a1, (int)&v16, 16);
LABEL_7:
            sub_1000C2D0(a1, 1, 0, 0);
            *(_BYTE *)(a1 + 6) = 2;
          }
        }
      }
      break;
    default:
      *(_BYTE *)(a1 + 6) = 1;
      break;
  }
}

//----- (10004220) --------------------------------------------------------
int __usercall sub_10004220@<eax>(int result@<eax>, int a2@<ecx>, int a3)
{
  if ( *(_BYTE *)result == 43 )
    *(float *)(result + 16) = (double)(a3 * (*(_WORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 758) - 4));
  return result;
}

//----- (10004250) --------------------------------------------------------
_WORD *__usercall sub_10004250@<eax>(bool *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11, float a12, float a13, float a14, float a15)
{
  int v15; // eax@1
  __int16 v16; // bp@1
  __int16 v17; // cx@1
  __int16 v18; // cx@4
  __int16 v19; // ax@4
  __int16 v20; // dx@4
  _WORD *result; // eax@4
  char v22; // [sp+Bh] [bp-29h]@1
  int v23; // [sp+Ch] [bp-28h]@1
  int v24; // [sp+10h] [bp-24h]@1
  int v25; // [sp+14h] [bp-20h]@1
  int v26; // [sp+18h] [bp-1Ch]@1
  __int16 v27; // [sp+1Ch] [bp-18h]@1
  __int16 v28; // [sp+1Eh] [bp-16h]@1
  __int16 v29; // [sp+20h] [bp-14h]@1
  __int16 v30; // [sp+22h] [bp-12h]@1
  float v31; // [sp+24h] [bp-10h]@2
  float v32; // [sp+28h] [bp-Ch]@2
  float v33; // [sp+2Ch] [bp-8h]@2
  float v34; // [sp+30h] [bp-4h]@2

  v15 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4);
  v16 = *(_WORD *)(v15 + 30) + *(_WORD *)(v15 + 34);
  v28 = *(_WORD *)(v15 + 30);
  v17 = *(_WORD *)(v15 + 28);
  LOWORD(v15) = v17 + *(_WORD *)(v15 + 32);
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v22 = 0;
  v30 = v16;
  v27 = v17;
  v29 = v15;
  if ( a10 )
  {
    v31 = a12;
    v32 = a13;
    v33 = a14;
    v34 = a15;
  }
  else
  {
    v22 = 3;
    v32 = 0.0;
    v34 = 0.0;
    v31 = 0.0;
    v33 = 0.0;
  }
  sub_10003E90((int)&v27, a2, (int)&v31, a7, a8, &v24, &v26, &v22, a1, a11);
  sub_10003CE0(a2, (int)&v31, a9, &v23, &v25, &v22, *a1, a11);
  v18 = v24;
  *a5 = v23;
  v19 = v25;
  *a6 = v18;
  v20 = v26;
  *a3 = v19;
  result = a4;
  *a4 = v20;
  return result;
}

//----- (10004370) --------------------------------------------------------
int __usercall sub_10004370@<eax>(int a1@<edx>, unsigned __int16 a2@<cx>, int a3@<ebx>, unsigned __int16 a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@1
  void *v7; // eax@2
  const void *v8; // esi@2

  v5 = *(_DWORD *)(*(_DWORD *)(a3 + 56) + 12);
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_WORD *)(a1 + 2) = 0;
  *(_WORD *)(a1 + 4) = 0;
  v6 = 4 * a4;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(v6 + *(_DWORD *)(v5 + 744));
  if ( *(_BYTE *)(*(_DWORD *)(v5 + 732) + 8) & 1 )
  {
    v7 = (void *)(v5 + 52 * (a2 + 2));
    v8 = *(const void **)(v5 + 740);
  }
  else
  {
    v7 = (void *)(52 * (a2 + 2) + v5);
    v8 = *(const void **)(v6 + *(_DWORD *)(v5 + 740));
  }
  qmemcpy(v7, v8, 0x34u);
  *(_DWORD *)(a1 + 8) = v7;
  return sub_10004220((int)v7, a3, a5);
}

//----- (100043F0) --------------------------------------------------------
char __cdecl sub_100043F0(int a1, int a2, unsigned __int16 a3)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // esi@3
  signed int v6; // ecx@5
  char result; // al@8
  int v8; // ecx@11
  int v9; // edx@11
  int v10; // ecx@11
  int v11; // [sp+8h] [bp-10h]@11
  int v12; // [sp+Ch] [bp-Ch]@11
  int v13; // [sp+10h] [bp-8h]@11
  int v14; // [sp+14h] [bp-4h]@11
  char v15; // [sp+1Ch] [bp+4h]@4

  v3 = a1;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( (a3 & 0x8000u) != 0 || (signed __int16)a3 > *(_WORD *)(v4 + 736) - 1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(v4 + 748);
    if ( v5 )
      v15 = (*(_BYTE *)(v5 + (signed __int16)a3) == 0) + 1;
    else
      v15 = 1;
    v6 = (unsigned __int16)(a3 - *(_WORD *)(v4 + 78) + 1);
    if ( v6 >= 0 )
    {
      if ( v6 > 11 )
        LOWORD(v6) = 11;
    }
    else
    {
      LOWORD(v6) = 0;
    }
    sub_10004370((int)&v11, v6, v3, a3, 1);
    v8 = v12;
    *(_DWORD *)a2 = v11;
    v9 = v13;
    *(_DWORD *)(a2 + 4) = v8;
    v10 = v14;
    *(_DWORD *)(a2 + 8) = v9;
    *(_DWORD *)(a2 + 12) = v10;
    result = v15;
  }
  return result;
}

//----- (100044A0) --------------------------------------------------------
signed int __usercall sub_100044A0@<eax>(int a1@<eax>)
{
  int v1; // ecx@1
  char v2; // al@1
  int v3; // esi@1
  signed __int16 v4; // dx@1
  char v5; // al@1
  signed int result; // eax@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = -(*(_BYTE *)(v1 + 760) != 0);
  v3 = *(_DWORD *)(v1 + 732);
  v4 = 16;
  *(_DWORD *)(v1 + 28) = 53;
  *(_DWORD *)(v1 + 52) = -16777216;
  v5 = v2 & 2;
  if ( !(*(_BYTE *)(v3 + 8) & 0x10) )
    v5 |= 4u;
  *(_BYTE *)(v1 + 32) = v5;
  *(_DWORD *)(v1 + 36) = v1 + 96;
  *(_WORD *)(v1 + 44) = *(_WORD *)(v1 + 762);
  *(_WORD *)(v1 + 46) = *(_WORD *)(v1 + 756) + 1;
  *(_BYTE *)(v1 + 33) = 16;
  *(_DWORD *)(v1 + 40) = sub_100043F0;
  *(_WORD *)(v1 + 48) = 0;
  if ( *(_BYTE *)(v3 + 8) & 0xC )
  {
    if ( (*(_BYTE *)(v3 + 8) & 0xC) == 4 )
    {
      *(_WORD *)(v1 + 56) = *(_WORD *)(v1 + 758) / 2 + 15;
      goto LABEL_7;
    }
    v4 = *(_WORD *)(v1 + 758) + 14;
  }
  *(_WORD *)(v1 + 56) = v4;
LABEL_7:
  *(_DWORD *)(v1 + 8) = 10;
  *(_DWORD *)(v1 + 12) = 1;
  *(_DWORD *)(v1 + 16) = -12566464;
  result = 141;
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 24) = 141;
  *(_WORD *)(v1 + 58) = 19;
  *(_DWORD *)(v1 + 60) = 141;
  *(_DWORD *)(v1 + 16) = *(_DWORD *)(v3 + 4);
  return result;
}

//----- (10004580) --------------------------------------------------------
int __usercall sub_10004580@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ecx@1
  int result; // eax@1
  int v4; // esi@1
  int v5; // ebp@1
  bool v6; // zf@1
  _WORD *v7; // eax@2
  double v8; // st7@2
  signed int v9; // edi@2
  signed int v10; // eax@2
  int v11; // ecx@4
  int v12; // eax@4
  _WORD *v13; // [sp+Ch] [bp-1Ch]@2
  int v14; // [sp+10h] [bp-18h]@2
  void (__cdecl *v15)(int, int, _WORD *, char *, void *); // [sp+14h] [bp-14h]@1
  char v16; // [sp+18h] [bp-10h]@2

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 56);
  result = dword_1077A050;
  v4 = *(_DWORD *)(v2 + 12);
  v5 = 0;
  v6 = *(_WORD *)(v4 + 736) == 0;
  v15 = (void (__cdecl *)(int, int, _WORD *, char *, void *))dword_1077A050;
  if ( !v6 )
  {
    do
    {
      sub_10004370((int)&v16, 0, v1, v5, 0);
      sub_1000E3C0((char *)(v4 + 96), (int *)&v13, 0);
      v7 = v13;
      v14 = *v13;
      *(float *)(v1 + 292) = (double)v14;
      v14 = v7[1];
      *(float *)(v1 + 296) = (double)v14;
      v14 = *v7;
      *(float *)(v1 + 300) = (double)v14;
      v14 = v7[1];
      *(float *)(v1 + 304) = (double)v14;
      v15(v1, v4 + 96, v7, &v16, &unk_100630DC);
      v8 = *(float *)(v1 + 304) - *(float *)(v1 + 296);
      v9 = *(_WORD *)(v4 + 756);
      v14 = (unsigned __int16)(signed int)(*(float *)(v1 + 300) - *(float *)(v1 + 292));
      v10 = (signed int)v8;
      if ( (signed __int16)(signed int)v8 <= v9 )
        LOWORD(v10) = v9;
      v11 = (signed __int16)v14;
      *(_WORD *)(v4 + 756) = v10;
      v12 = *(_WORD *)(v4 + 758);
      if ( v11 > v12 )
        LOWORD(v12) = v11;
      *(_WORD *)(v4 + 758) = v12;
      result = *(_WORD *)(v4 + 736);
      ++v5;
    }
    while ( v5 < result );
  }
  return result;
}
// 1077A050: using guessed type int dword_1077A050;

//----- (100046A0) --------------------------------------------------------
char __usercall sub_100046A0@<al>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  _DWORD *v3; // edx@1
  int v4; // edi@1
  int v5; // eax@1
  __int16 v6; // cx@3
  unsigned __int16 v7; // ax@3
  int v8; // ecx@3
  char result; // al@3
  char v10; // [sp+10h] [bp-8h]@1
  _DWORD *v11; // [sp+14h] [bp-4h]@1

  v1 = a1;
  v2 = sub_10002800(a1, *(char **)(a1 + 56), 764, 1);
  v3 = *(_DWORD **)(*(_DWORD *)(v1 + 56) + 60);
  v4 = v2;
  *(_DWORD *)(v2 + 732) = *(_DWORD *)(*(_DWORD *)(v1 + 52) + 8);
  v11 = v3;
  v5 = *(_DWORD *)(*(_DWORD *)(v1 + 52) + 12);
  *(_DWORD *)(v4 + 728) = v5;
  *(_DWORD *)(v4 + 736) = *(_DWORD *)v5;
  *(_DWORD *)(v4 + 740) = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(v4 + 744) = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v4 + 748) = *(_DWORD *)(v5 + 12);
  *(_WORD *)(v4 + 762) = *(_WORD *)(v4 + 736);
  *(_BYTE *)(v4 + 752) = 0;
  *(_BYTE *)(v4 + 760) = 0;
  *(_DWORD *)(v4 + 96) = 18;
  *(_WORD *)(v4 + 100) = 0;
  *(_WORD *)(v4 + 102) = 0;
  *(_WORD *)(v4 + 756) = 0;
  *(_WORD *)(v4 + 758) = 0;
  sub_10004580(v1);
  v10 = 0;
  if ( *(_BYTE *)(*(_DWORD *)(v4 + 732) + 8) & 8 )
    v10 = 1;
  sub_10004250(
    (bool *)(v4 + 760),
    v1,
    (_WORD *)(v4 + 4),
    (_WORD *)(v4 + 6),
    (_WORD *)(v4 + 2),
    (_WORD *)v4,
    (_WORD *)(v4 + 762),
    *(_WORD *)(v4 + 756),
    (_WORD *)(v4 + 758),
    1,
    v10,
    *(float *)(*(_DWORD *)(v1 + 52) + 16),
    *(float *)(*(_DWORD *)(v1 + 52) + 20),
    *(float *)(*(_DWORD *)(v1 + 52) + 24),
    *(float *)(*(_DWORD *)(v1 + 52) + 28));
  sub_100044A0(v1);
  sub_10002570(v1, *(_WORD *)(v4 + 4), *(_WORD *)(v4 + 6), *(_WORD *)(v4 + 2), *(_WORD *)v4, 2);
  sub_1000E410(*(_DWORD *)(v1 + 56), (char *)(v4 + 28));
  *v11 = v4 + 64;
  v6 = *(_WORD *)(v4 + 736);
  *(_DWORD *)(v4 + 64) = 0;
  v7 = *(_WORD *)(v4 + 738);
  *(_WORD *)(v4 + 68) = v6;
  *(_WORD *)(v4 + 78) = v7;
  *(_WORD *)(v4 + 76) = v7;
  *(_DWORD *)(v4 + 72) = v4 + 80;
  *(_WORD *)(v4 + 754) = v7;
  sub_10004370(v4 + 80, 0, v1, v7, 1);
  *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) = 0;
  sub_10002F70(v1, *(_DWORD *)(v1 + 56), -32734);
  sub_1000F5B0(
    v1,
    &unk_100630E4,
    (char *)(v4 + 28),
    *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
  v8 = *(_DWORD *)(v1 + 56);
  *(_BYTE *)(v1 + 9) = 1;
  *(_BYTE *)(v8 + 247) = 1;
  result = sub_1000E4E0(v1, *(char **)(*(_DWORD *)(v1 + 56) + 4), (int)&unk_100630D4);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}

//----- (10004890) --------------------------------------------------------
void __cdecl sub_10004890(unsigned int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8041:
      byte_100E975E = 0;
      goto LABEL_3;
    default:
      return;
    case 0x800F:
      sub_100046A0(a1);
      byte_100E975E = 1;
      break;
    case 0x8022:
      sub_10004010(a1);
      break;
    case 0x8048:
      if ( byte_100E975E )
        sub_10004060(a1);
      else
LABEL_3:
        *(_BYTE *)(a1 + 6) = 2;
      break;
  }
}
// 100E975E: using guessed type char byte_100E975E;

//----- (10004940) --------------------------------------------------------
char __usercall sub_10004940@<al>(int a1@<esi>)
{
  int v1; // eax@1
  _DWORD *v2; // ebx@1
  _WORD *v3; // edi@1
  char result; // al@1

  v1 = sub_10002800(a1, *(char **)(a1 + 56), 376, 1);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) = 1;
  v2 = *(_DWORD **)(*(_DWORD *)(a1 + 56) + 60);
  v3 = (_WORD *)v1;
  sub_10002570(a1, 624, 250, 375, 230, 2);
  sub_1000E410(*(_DWORD *)(a1 + 56), (char *)&unk_10052374);
  *v3 = 5353;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
  *v2 = v3;
  sub_1000F5B0(
    a1,
    *(_WORD **)(a1 + 52),
    (char *)&unk_10052374,
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  result = sub_10002F70(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004A00) --------------------------------------------------------
int __usercall sub_10004A00@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int result; // eax@3
  int v4; // edi@3
  int v5; // ebp@4
  int v6; // ebx@4
  int v7; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v7 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(v1 + 246) )
  {
    *(_BYTE *)(v1 + 246) = 0;
    sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052360, (int)&unk_1005239C, 0, 255);
  }
  result = sub_1000F5B0(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)&unk_10052374,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
             0,
             *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  v4 = 0;
  if ( *(_DWORD *)(v2 + 372) > 0 )
  {
    v5 = v2 + 184;
    v6 = v2 + 4;
    do
    {
      result = sub_1000F840(a1, v5, v6);
      ++v4;
      v6 += 36;
      v5 += 37;
    }
    while ( v4 < *(_DWORD *)(v7 + 372) );
  }
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10004AA0) --------------------------------------------------------
int __cdecl sub_10004AA0(int a1)
{
  int v1; // edx@1
  int v2; // ebp@1
  int result; // eax@1
  int v4; // edi@1
  double v5; // st7@2
  double v6; // st5@2
  int v7; // ebx@2
  double v8; // st4@2
  double v9; // rt0@3
  double v10; // st4@3
  double v11; // rt2@3
  double v12; // rtt@4
  double v13; // st4@4
  double v14; // st5@4
  double v15; // rt1@4
  double v16; // st4@4
  double v17; // st7@4
  int v18; // ecx@4
  char *v19; // edx@8
  _BYTE *v20; // esi@8
  char v21; // cl@9
  signed int v22; // [sp+8h] [bp-4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12);
  v4 = 0;
  *(_DWORD *)(v2 + 372) = result;
  v22 = 0;
  if ( result > 0 )
  {
    v5 = 25.0;
    v6 = 15.0;
    v7 = v2 + 184;
    v8 = 0.0;
    result = v2 + 8;
    while ( 1 )
    {
      v12 = v8;
      *(_DWORD *)(result + 4) = 4;
      *(float *)(result - 4) = v5;
      *(_DWORD *)(result + 12) = -14671840;
      *(_DWORD *)(result + 16) = -1;
      *(float *)result = (double)v22 * 25.0 + 25.0;
      v13 = v6;
      v14 = v5;
      *(float *)(result + 8) = v13;
      v15 = v13;
      v16 = v12;
      v17 = v15;
      *(float *)(result + 20) = v12;
      *(float *)(result + 24) = v12;
      *(float *)(result + 28) = v12;
      v18 = *(_DWORD *)(*(_DWORD *)(v1 + 52) + 8);
      if ( v18 == 1 )
      {
        *(_DWORD *)(result + 16) = -256;
      }
      else if ( v18 == 2 )
      {
        *(_DWORD *)(result + 16) = -65536;
      }
      v19 = (char *)(*(_DWORD *)(v1 + 52) + v4 + 16);
      v20 = (_BYTE *)v7;
      do
      {
        v21 = *v19;
        *v20++ = *v19++;
      }
      while ( v21 );
      result += 36;
      v4 += 37;
      v7 += 37;
      if ( ++v22 >= *(_DWORD *)(v2 + 372) )
        break;
      v1 = a1;
      v9 = v16;
      v10 = v17;
      v5 = v14;
      v11 = v10;
      v8 = v9;
      v6 = v11;
    }
  }
  return result;
}

//----- (10004C50) --------------------------------------------------------
bool __usercall sub_10004C50@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  unsigned __int8 v3; // bl@1
  unsigned __int16 v4; // ax@11
  bool result; // al@13

  v3 = *(_BYTE *)(a2 + 1);
  result = 0;
  if ( (v3 >= *(_BYTE *)(a1 + 1) || *(_BYTE *)a2 != *(_BYTE *)a1 || *(_WORD *)(a2 + 2) != *(_WORD *)(a1 + 2))
    && (v3 < *(_BYTE *)(a3 + 1) || *(_BYTE *)a2 != *(_BYTE *)a3 || *(_WORD *)(a2 + 2) != *(_WORD *)(a3 + 2))
    && (*(_BYTE *)a2 >= *(_BYTE *)a1 || *(_WORD *)(a2 + 2) != *(_WORD *)(a1 + 2))
    && (*(_BYTE *)a2 <= *(_BYTE *)a3 || *(_WORD *)(a2 + 2) != *(_WORD *)(a3 + 2)) )
  {
    v4 = *(_WORD *)(a2 + 2);
    if ( v4 >= *(_WORD *)(a1 + 2) && v4 <= *(_WORD *)(a3 + 2) )
      result = 1;
  }
  return result;
}

//----- (10004CC0) --------------------------------------------------------
int __usercall sub_10004CC0@<eax>(int a1@<eax>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  j_gdi_pvg_color_u32(-8355712);
  j_gdi_pvg_begin(64);
  sub_10038180(677.0, 158.5);
  sub_10038180(677.0, 168.0);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(64);
  sub_10038180(677.0, 168.0);
  sub_10038180(761.0, 168.0);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(64);
  sub_10038180(761.0, 168.0);
  sub_10038180(761.0, 158.5);
  j_gdi_pvg_end();
  if ( *(_BYTE *)(v1 + 2815) )
  {
    j_gdi_pvg_begin(64);
    sub_10038180(677.0, 625.5);
    sub_10038180(677.0, 635.0);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(64);
    sub_10038180(677.0, 635.0);
    sub_10038180(809.0, 635.0);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(64);
    sub_10038180(809.0, 635.0);
    sub_10038180(809.0, 625.5);
    j_gdi_pvg_end();
  }
  j_gdi_pvg_color_u32(-1);
  j_gdi_pvg_begin(72);
  sub_10038180(982.0, 730.0);
  sub_10038180(984.0, 730.0);
  sub_10038180(984.0, 755.0);
  sub_10038180(982.0, 755.0);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(68);
  sub_10038180(978.0, 755.0);
  sub_10038180(988.0, 755.0);
  sub_10038180(983.0, 761.0);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(72);
  sub_10038180(984.0, 730.0);
  sub_10038180(984.0, 728.0);
  sub_10038180(944.0, 728.0);
  sub_10038180(944.0, 730.0);
  return j_gdi_pvg_end();
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (10004FA0) --------------------------------------------------------
char __usercall sub_10004FA0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char result; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
  j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
  sub_10037E80(
    512 - *(_WORD *)(v1 + 3490) / 2,
    384 - *(_WORD *)(v1 + 3488) / 2,
    *(_WORD *)(v1 + 3490),
    *(_WORD *)(v1 + 3488),
    59,
    15,
    *(_DWORD *)(v1 + 3484));
  j_gdi_pvg_update_display_wdw();
  result = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10037F80: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10037F90: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10038170: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10005010) --------------------------------------------------------
signed int __cdecl sub_10005010(int a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  int v3; // esi@1
  unsigned int v4; // eax@3
  signed int v5; // esi@5
  signed int result; // eax@7
  char v7; // [sp+Ch] [bp-50h]@3
  int v8; // [sp+10h] [bp-4Ch]@3
  int v9; // [sp+14h] [bp-48h]@3
  __int16 v10; // [sp+18h] [bp-44h]@3
  int v11; // [sp+20h] [bp-3Ch]@3
  __int16 v12; // [sp+24h] [bp-38h]@3
  void *v13; // [sp+28h] [bp-34h]@3
  int v14; // [sp+2Ch] [bp-30h]@3
  void *v15; // [sp+30h] [bp-2Ch]@3
  int v16; // [sp+34h] [bp-28h]@3
  int v17; // [sp+38h] [bp-24h]@3
  char v18; // [sp+3Ch] [bp-20h]@3
  int v19; // [sp+40h] [bp-1Ch]@3
  char v20; // [sp+44h] [bp-18h]@3

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = v1;
  if ( v1 >= *(_DWORD *)(v2 + 3500) || v1 < 0 )
  {
    result = -15;
  }
  else
  {
    memset(&v8, 0, 0x34u);
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = &unk_100E9A48;
    v14 = 1024;
    v15 = &unk_103EDED0;
    v16 = 46920;
    v17 = 15;
    v18 = -2;
    v19 = 0xFFFF;
    sub_1000D560((int)&v20, "startup_scrn", 20);
    sprintf(&v7, "%03d", v3);
    sub_1000D720(&v20, &v7, 20);
    sub_1000D720(&v20, ".bmp", 20);
    v4 = sub_100114F0((int)dword_100E9E48, &v20, 4, &unk_100E9760, (int)&v8);
    dword_100E9A44 = v4;
    if ( v4 >= 0xFFFFFFC2
      || !v4
      || (*(_DWORD *)(v2 + 3484) = &unk_100EDED0,
          v5 = sub_1000CA00(v4, (int *)(v2 + 3484), 3145728, 0),
          sub_1000D380(dword_100E9A44),
          v5) )
    {
      v5 = -15;
    }
    result = v5;
  }
  return result;
}
// 100E9A44: using guessed type int dword_100E9A44;

//----- (10005170) --------------------------------------------------------
char __usercall sub_10005170@<al>(int a1@<eax>)
{
  _DWORD *v1; // edi@1
  _DWORD *v2; // esi@1
  char result; // al@1

  v1 = (_DWORD *)(a1 + 3524);
  v2 = (_DWORD *)(a1 + 3520);
  *(_DWORD *)(a1 + 3524) = 0;
  *(_DWORD *)(a1 + 3520) = 0;
  result = dword_1077AE98;
  if ( *(_BYTE *)(dword_1077AE98 + 28128) )
  {
    j_gdi_pvg_gen_textures(1, v2);
    j_gdi_pvg_bind_texture(34, *v2);
    j_gdi_pvg_tex_parameteri(34, 95, 97);
    j_gdi_pvg_tex_parameteri(34, 96, 97);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    j_gdi_pvg_tex_parameteri(34, 94, 90);
    if ( !sub_100390D0((char *)(dword_1077AE98 + 28128), 0, 128, 512, 512) )
      *v2 = 0;
    j_gdi_pvg_gen_textures(1, v1);
    j_gdi_pvg_bind_texture(34, *v1);
    j_gdi_pvg_tex_parameteri(34, 95, 97);
    j_gdi_pvg_tex_parameteri(34, 96, 97);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    j_gdi_pvg_tex_parameteri(34, 94, 90);
    result = sub_100390D0((char *)(dword_1077AE98 + 28128), 0, 0, 512, 128);
    if ( !result )
      *v1 = 0;
  }
  return result;
}
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037F40: using guessed type int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD);
// 10038120: using guessed type int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD);
// 1077AE98: using guessed type int dword_1077AE98;

//----- (10005280) --------------------------------------------------------
char __usercall sub_10005280@<al>(int a1@<esi>)
{
  char result; // al@1

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
  result = sub_10002F70(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100052B0) --------------------------------------------------------
char __cdecl sub_100052B0(int a1)
{
  unsigned int v1; // ebx@1
  int v2; // ebp@1
  unsigned int v3; // edx@3
  _DWORD *v4; // eax@3
  _DWORD *v5; // ecx@3
  int v6; // edi@7
  int v7; // edx@8
  _BYTE *v8; // eax@8
  _BYTE *v9; // ecx@8
  int v10; // edx@10
  _BYTE *v11; // eax@10
  _BYTE *v12; // ecx@10
  _BYTE *v13; // eax@12
  _BYTE *v14; // ecx@12
  signed int v15; // eax@14
  unsigned int v16; // eax@19
  _DWORD *v17; // ecx@19
  _DWORD *v18; // edx@19
  int v19; // edi@23
  int v20; // eax@24
  _BYTE *v21; // ecx@24
  _BYTE *v22; // edx@24
  int v23; // eax@26
  _BYTE *v24; // ecx@26
  _BYTE *v25; // edx@26
  _BYTE *v26; // ecx@28
  _BYTE *v27; // edx@28
  signed int v28; // eax@30
  unsigned int v29; // eax@36
  _DWORD *v30; // ecx@36
  _DWORD *v31; // edx@36
  int v32; // edi@40
  int v33; // eax@41
  _BYTE *v34; // ecx@41
  _BYTE *v35; // edx@41
  int v36; // eax@43
  _BYTE *v37; // ecx@43
  _BYTE *v38; // edx@43
  _BYTE *v39; // ecx@45
  _BYTE *v40; // edx@45
  signed int v41; // eax@47
  signed int v42; // eax@52
  int v43; // eax@55
  int v44; // ecx@55
  int v45; // ecx@56
  signed int v46; // eax@59
  bool v47; // sf@59
  unsigned __int8 v48; // of@59
  int v49; // eax@61
  int v50; // ecx@61
  char v52; // [sp+Fh] [bp-15h]@51
  __int16 v53; // [sp+10h] [bp-14h]@67
  int v54; // [sp+14h] [bp-10h]@67
  char v55; // [sp+18h] [bp-Ch]@67
  __int16 v56; // [sp+1Ah] [bp-Ah]@67

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( !(*(_WORD *)(*(_DWORD *)(a1 + 52) + 10) & 0xC000) )
  {
    memcpy((void *)(v2 + 214), (const void *)(v2 + 216), 6u);
    *(_WORD *)(v2 + 220) = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
  }
  v3 = 8;
  v4 = &unk_10052A70;
  v5 = (_DWORD *)(v2 + 214);
  do
  {
    if ( *v5 != *v4 )
      goto LABEL_7;
    v3 -= 4;
    ++v4;
    ++v5;
  }
  while ( v3 >= 4 );
  if ( !v3 )
  {
LABEL_17:
    v15 = 0;
    goto LABEL_18;
  }
LABEL_7:
  v6 = *(_BYTE *)v5 - *(_BYTE *)v4;
  if ( *(_BYTE *)v5 == *(_BYTE *)v4 )
  {
    v7 = v3 - 1;
    v8 = (char *)v4 + 1;
    v9 = (char *)v5 + 1;
    if ( !v7
      || (v6 = *v9 - *v8, *v9 == *v8)
      && ((v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, !v10)
       || (v6 = *v12 - *v11, *v12 == *v11)
       && ((v13 = v11 + 1, v14 = v12 + 1, v10 == 1) || (v6 = *v14 - *v13, *v14 == *v13))) )
    {
      v1 = a1;
      goto LABEL_17;
    }
  }
  v1 = a1;
  v15 = 1;
  if ( v6 <= 0 )
    v15 = -1;
LABEL_18:
  if ( !v15 )
    goto LABEL_35;
  v16 = 8;
  v17 = &unk_10052A78;
  v18 = (_DWORD *)(v2 + 214);
  do
  {
    if ( *v18 != *v17 )
      goto LABEL_23;
    v16 -= 4;
    ++v17;
    ++v18;
  }
  while ( v16 >= 4 );
  if ( !v16 )
  {
LABEL_33:
    v28 = 0;
    goto LABEL_34;
  }
LABEL_23:
  v19 = *(_BYTE *)v18 - *(_BYTE *)v17;
  if ( *(_BYTE *)v18 == *(_BYTE *)v17 )
  {
    v20 = v16 - 1;
    v21 = (char *)v17 + 1;
    v22 = (char *)v18 + 1;
    if ( !v20
      || (v19 = *v22 - *v21, *v22 == *v21)
      && ((v23 = v20 - 1, v24 = v21 + 1, v25 = v22 + 1, !v23)
       || (v19 = *v25 - *v24, *v25 == *v24)
       && ((v26 = v24 + 1, v27 = v25 + 1, v23 == 1) || (v19 = *v27 - *v26, *v27 == *v26))) )
    {
      v1 = a1;
      goto LABEL_33;
    }
  }
  v1 = a1;
  v28 = 1;
  if ( v19 <= 0 )
    v28 = -1;
LABEL_34:
  if ( !v28 )
LABEL_35:
    sub_1000E7C0(1);
  v29 = 8;
  v30 = &unk_10052A80;
  v31 = (_DWORD *)(v2 + 214);
  do
  {
    if ( *v31 != *v30 )
      goto LABEL_40;
    v29 -= 4;
    ++v30;
    ++v31;
  }
  while ( v29 >= 4 );
  if ( !v29 )
  {
LABEL_49:
    v41 = 0;
    goto LABEL_50;
  }
LABEL_40:
  v32 = *(_BYTE *)v31 - *(_BYTE *)v30;
  if ( *(_BYTE *)v31 == *(_BYTE *)v30 )
  {
    v33 = v29 - 1;
    v34 = (char *)v30 + 1;
    v35 = (char *)v31 + 1;
    if ( !v33 )
      goto LABEL_49;
    v32 = *v35 - *v34;
    if ( *v35 == *v34 )
    {
      v36 = v33 - 1;
      v37 = v34 + 1;
      v38 = v35 + 1;
      if ( !v36 )
        goto LABEL_49;
      v32 = *v38 - *v37;
      if ( *v38 == *v37 )
      {
        v39 = v37 + 1;
        v40 = v38 + 1;
        if ( v36 == 1 )
          goto LABEL_49;
        v32 = *v40 - *v39;
        if ( *v40 == *v39 )
          goto LABEL_49;
      }
    }
  }
  v41 = 1;
  if ( v32 <= 0 )
    v41 = -1;
LABEL_50:
  if ( !v41 )
  {
    v52 = 1;
    sub_10038730(9131, (int)&v52, 1);
  }
  v42 = *(_DWORD *)(v1 + 52);
  switch ( *(_WORD *)(v42 + 10) )
  {
    case 0xF:
    case 0x20:
      if ( *(_DWORD *)(v2 + 3496) > 0 && *(_BYTE *)(v2 + 3516) )
      {
        v43 = *(_DWORD *)(v2 + 3508);
        v44 = *(_DWORD *)(v2 + 3512);
        *(_DWORD *)(v2 + 3484) = *(_DWORD *)(v2 + 3504);
        *(_DWORD *)(v2 + 3488) = v43;
        *(_BYTE *)(v2 + 3516) = 0;
        *(_DWORD *)(v2 + 3492) = v44;
        sub_10004FA0(v1);
        --*(_DWORD *)(v2 + 3496);
        goto LABEL_56;
      }
      break;
    case 0x1A:
    case 0x21:
      if ( *(_BYTE *)(v2 + 3516) )
      {
        v46 = ++*(_DWORD *)(v2 + 3496);
        v48 = __OFSUB__(v46, *(_DWORD *)(v2 + 3500));
        v47 = v46 - *(_DWORD *)(v2 + 3500) < 0;
        *(_BYTE *)(v2 + 3516) = 0;
        if ( v47 ^ v48 && v46 < 1000 )
        {
          v49 = *(_DWORD *)(v2 + 3508);
          v50 = *(_DWORD *)(v2 + 3512);
          *(_DWORD *)(v2 + 3484) = *(_DWORD *)(v2 + 3504);
          *(_DWORD *)(v2 + 3488) = v49;
          *(_DWORD *)(v2 + 3492) = v50;
          sub_10004FA0(v1);
LABEL_56:
          v45 = *(_DWORD *)(v2 + 3496);
          v42 = sub_10005010(v1);
          if ( !v42 )
            LOBYTE(v42) = sub_10004FA0(v1);
        }
        else
        {
          if ( !dword_100E9A40 )
            sub_100104D0(dword_100E9E48);
          sub_1000C2D0(v1, -1, 0, 0);
          LOBYTE(v42) = sub_100385B0();
          *(_BYTE *)(v1 + 6) = 2;
        }
      }
      break;
    case 0x28:
      if ( *(_BYTE *)(v2 + 2815) && *(_DWORD *)(v2 + 3496) < 0 )
      {
        *(_DWORD *)(v2 + 4) = " to continue";
        **(_BYTE **)(*(_DWORD *)(v1 + 56) + 64) = 3;
        *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) = 0;
        v54 = 0;
        v53 = -32696;
        v56 = 56;
        v55 = 1;
        LOBYTE(v42) = sub_10002900(v1, (int)&v53, 20);
        *(_BYTE *)(v1 + 6) = 2;
      }
      break;
    default:
      LOBYTE(v42) = sub_1000E4E0(v1, *(char **)(v1 + 56), *(_DWORD *)(v1 + 52));
      *(_BYTE *)(v1 + 6) = v42;
      break;
  }
  return v42;
}
// 100E9A40: using guessed type int dword_100E9A40;

//----- (100056C0) --------------------------------------------------------
char __usercall sub_100056C0@<al>(int a1@<esi>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 2883) = 1;
  *(_BYTE *)(a1 + 6) = sub_1000E4E0(a1, *(char **)(a1 + 56), *(_DWORD *)(a1 + 52));
  **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 2;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_BYTE *)(v1 + 2814) = *(_WORD *)(v1 + 2854) != *(_WORD *)(v1 + 2880);
  return sub_10002F70(a1, *(_DWORD *)(a1 + 56), -32734);
}

//----- (10005720) --------------------------------------------------------
bool sub_10005720()
{
  char v0; // al@1
  char v2; // [sp+0h] [bp-Ch]@1
  unsigned int v3; // [sp+4h] [bp-8h]@1
  char v4; // [sp+8h] [bp-4h]@1

  v0 = sub_1003AC80(&v4, &v2, &v3);
  return v3 > 0x3A41 || v0 != 1;
}

//----- (10005770) --------------------------------------------------------
char __cdecl sub_10005770(int a1)
{
  int v1; // ebx@1
  int v2; // eax@1
  int v3; // eax@10
  int v4; // eax@10
  char v5; // cl@11
  int v6; // eax@13
  char v8; // [sp+Bh] [bp-E1h]@1
  char v9; // [sp+Ch] [bp-E0h]@6
  char v10; // [sp+10h] [bp-DCh]@2
  unsigned __int8 v11; // [sp+1Eh] [bp-CEh]@4
  unsigned __int8 v12; // [sp+1Fh] [bp-CDh]@5
  unsigned __int16 v13; // [sp+20h] [bp-CCh]@3
  char v14; // [sp+26h] [bp-C6h]@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  LOWORD(v2) = sub_10037CB0(48, 0, 1, (int)&v8);
  if ( (_WORD)v2 )
  {
    if ( (_WORD)v2 == 12 )
    {
      qmemcpy((void *)(51 * *(_DWORD *)(v1 + 2776) + v1 + 832), "Verifying Apt Directory Data", 0x1Du);
      *(_DWORD *)(16 * *(_DWORD *)(v1 + 2776) + v1 + 232) = "+";
      return v2;
    }
    v6 = 51 * *(_DWORD *)(v1 + 2776) + v1 + 832;
LABEL_17:
    *(_DWORD *)v6 = 544501825;
    *(_DWORD *)(v6 + 4) = 1701996868;
    *(_DWORD *)(v6 + 8) = 1919906915;
    *(_DWORD *)(v6 + 12) = 1310734969;
    *(_WORD *)(v6 + 16) = 16687;
    *(_BYTE *)(v6 + 18) = 0;
    v2 = 16 * *(_DWORD *)(v1 + 2776);
    *(_DWORD *)(v2 + v1 + 232) = "+";
    return v2;
  }
  if ( !sub_10001080(&v10) )
  {
    v6 = 51 * *(_DWORD *)(v1 + 2776) + v1 + 832;
    goto LABEL_17;
  }
  if ( v13 < 0x7D0u || (unsigned __int8)(v11 - 1) > 0xBu || (unsigned __int8)(v12 - 1) > 0x1Eu )
  {
    v3 = 51 * *(_DWORD *)(v1 + 2776);
    *(_DWORD *)(v3 + v1 + 832) = 544501825;
    v4 = v3 + v1 + 832;
    *(_DWORD *)(v4 + 4) = 1701996868;
    *(_DWORD *)(v4 + 8) = 1919906915;
    *(_DWORD *)(v4 + 12) = 1159733369;
    *(_DWORD *)(v4 + 16) = 1919512696;
    *(_DWORD *)(v4 + 20) = 2126693;
    v2 = 51 * *(_DWORD *)(v1 + 2776) + v1 + 831;
    do
      v5 = *(_BYTE *)(v2++ + 1);
    while ( v5 );
    *(_DWORD *)v2 = 1596809055;
    *(_DWORD *)(v2 + 4) = 1596809055;
    *(_DWORD *)(v2 + 8) = 6250335;
  }
  else
  {
    sprintf(
      (char *)(51 * *(_DWORD *)(v1 + 2776) + v1 + 832),
      "Apt Directory  Expires %d-%s-%d",
      v12,
      &asc_100529DC[4 * v11],
      v13);
    LOBYTE(v2) = sub_100135F0((int)&v9);
    if ( (_BYTE)v2 && (LOBYTE(v2) = sub_10004C50((int)&v14, (int)&v9, (int)&v11), (_BYTE)v2) )
      *(_DWORD *)(16 * *(_DWORD *)(v1 + 2776) + v1 + 232) = "+";
    else
      *(_DWORD *)(16 * *(_DWORD *)(v1 + 2776) + v1 + 232) = &unk_10052A50;
  }
  return v2;
}

//----- (10005A10) --------------------------------------------------------
char __usercall sub_10005A10@<al>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // eax@4
  int v3; // edx@8
  int v4; // eax@8
  char v5; // cl@9
  char v7; // [sp+4h] [bp-18h]@2
  unsigned int v8; // [sp+8h] [bp-14h]@2
  char v9; // [sp+Ch] [bp-10h]@2
  char v10; // [sp+10h] [bp-Ch]@4
  char v11; // [sp+14h] [bp-8h]@2
  char v12; // [sp+18h] [bp-4h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( byte_1077AE94 )
  {
    v2 = 51 * *(_DWORD *)(v1 + 2784) + v1 + 832;
    *(_DWORD *)v2 = 1769365838;
    *(_DWORD *)(v2 + 4) = 1769234791;
    *(_DWORD *)(v2 + 8) = 1142976111;
    *(_DWORD *)(v2 + 12) = 979465313;
    *(_DWORD *)(v2 + 16) = 1093619232;
    *(_BYTE *)(v2 + 20) = 0;
  }
  else
  {
    sub_10013640(&v7, (int)&v9, (int)&v8, (int)&v12, (int)&v11);
    if ( (_WORD)v8 && HIWORD(v8) )
    {
      sprintf(
        (char *)(51 * *(_DWORD *)(v1 + 2784) + v1 + 832),
        "Navigation  Expires %d-%s-%d",
        BYTE1(v8),
        &asc_100529DC[4 * (unsigned __int8)v8],
        HIWORD(v8));
      LOBYTE(v2) = sub_100135F0((int)&v10);
      if ( (_BYTE)v2 && (LOBYTE(v2) = sub_10004C50((int)&v9, (int)&v10, (int)&v8), (_BYTE)v2) )
      {
        v2 = 16 * *(_DWORD *)(v1 + 2784);
        *(_DWORD *)(v2 + v1 + 232) = "+";
      }
      else
      {
        *(_DWORD *)(16 * *(_DWORD *)(v1 + 2784) + v1 + 232) = &unk_10052A50;
      }
    }
    else
    {
      v3 = 51 * *(_DWORD *)(v1 + 2784);
      *(_DWORD *)(v3 + v1 + 832) = 1769365838;
      v4 = v3 + v1 + 832;
      *(_DWORD *)(v4 + 4) = 1769234791;
      *(_DWORD *)(v4 + 8) = 538996335;
      *(_DWORD *)(v4 + 12) = 1768978501;
      *(_DWORD *)(v4 + 16) = 544433522;
      *(_BYTE *)(v4 + 20) = 0;
      v2 = 51 * *(_DWORD *)(v1 + 2784) + v1 + 831;
      do
        v5 = *(_BYTE *)(v2++ + 1);
      while ( v5 );
      *(_DWORD *)v2 = 1596809055;
      *(_DWORD *)(v2 + 4) = 1596809055;
      *(_DWORD *)(v2 + 8) = 6250335;
    }
  }
  return v2;
}
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10005BD0) --------------------------------------------------------
char __cdecl sub_10005BD0(int a1)
{
  void *v1; // ecx@0
  int v2; // ebp@1
  int v3; // eax@1
  char v4; // bl@2
  int v5; // ecx@12
  int v6; // eax@12
  int v7; // eax@12
  char v8; // cl@13
  int v9; // edx@15
  int v10; // eax@15
  char v11; // cl@16
  char *v12; // edi@20
  char *v13; // esi@20
  int v14; // ecx@24
  char v16; // [sp+4h] [bp-9Ch]@3
  unsigned __int8 v17; // [sp+94h] [bp-Ch]@5
  unsigned __int8 v18; // [sp+95h] [bp-Bh]@4
  unsigned __int16 v19; // [sp+96h] [bp-Ah]@6
  unsigned __int8 v20; // [sp+98h] [bp-8h]@9
  unsigned __int8 v21; // [sp+99h] [bp-7h]@9
  unsigned __int16 v22; // [sp+9Ah] [bp-6h]@9

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  LOBYTE(v3) = sub_10007890(v1);
  if ( (_BYTE)v3 )
  {
    LOBYTE(v3) = sub_100078D0();
    v4 = v3;
    if ( (_BYTE)v3 != *(_BYTE *)(v2 + 2812) )
    {
      *(_BYTE *)(v2 + 2812) = v3;
      sub_10007A30(&v16);
      if ( v4 == 1 )
      {
        if ( v18 && v17 && v19 )
        {
          if ( v16 == 1 )
            sprintf(
              (char *)(51 * *(_DWORD *)(v2 + 2796) + v2 + 832),
              "ChartView  Disables %d-%s-%d",
              v21,
              &asc_100529DC[4 * v20],
              v22);
          else
            sprintf(
              (char *)(51 * *(_DWORD *)(v2 + 2796) + v2 + 832),
              "FliteCharts  Expires %d-%s-%d",
              v18,
              &asc_100529DC[4 * v17],
              v19);
        }
        else
        {
          if ( v16 == 1 )
          {
            v9 = 51 * *(_DWORD *)(v2 + 2796);
            *(_DWORD *)(v9 + v2 + 832) = 1918986307;
            v10 = v9 + v2 + 832;
            *(_DWORD *)(v10 + 4) = 1701402228;
            *(_DWORD *)(v10 + 8) = 1142956151;
            *(_DWORD *)(v10 + 12) = 1650553705;
            *(_DWORD *)(v10 + 16) = 544433516;
            *(_BYTE *)(v10 + 20) = 0;
            v7 = 51 * *(_DWORD *)(v2 + 2796) + v2 + 831;
            do
              v11 = *(_BYTE *)(v7++ + 1);
            while ( v11 );
          }
          else
          {
            v5 = 51 * *(_DWORD *)(v2 + 2796);
            *(_DWORD *)(v5 + v2 + 832) = 1953066054;
            v6 = v5 + v2 + 832;
            *(_DWORD *)(v6 + 4) = 1634222949;
            *(_DWORD *)(v6 + 8) = 544437362;
            *(_DWORD *)(v6 + 12) = 1886930208;
            *(_DWORD *)(v6 + 16) = 1936028265;
            *(_WORD *)(v6 + 20) = 32;
            v7 = 51 * *(_DWORD *)(v2 + 2796) + v2 + 831;
            do
              v8 = *(_BYTE *)(v7++ + 1);
            while ( v8 );
          }
          *(_DWORD *)v7 = 1596809055;
          *(_DWORD *)(v7 + 4) = 1596809055;
          *(_DWORD *)(v7 + 8) = 6250335;
        }
        *(_DWORD *)(16 * *(_DWORD *)(v2 + 2796) + v2 + 232) = "+";
      }
      LOBYTE(v3) = v4 - 2;
      switch ( v4 )
      {
        case 9:
          v3 = 51 * *(_DWORD *)(v2 + 2796);
          qmemcpy((void *)(v3 + v2 + 832), "Chart Data is Corrupt!", 0x16u);
          v13 = "";
          v12 = (char *)(v3 + v2 + 854);
          goto LABEL_27;
        case 8:
          v3 = 51 * *(_DWORD *)(v2 + 2796) + v2 + 832;
          *(_DWORD *)v3 = 1769104726;
          *(_DWORD *)(v3 + 4) = 1852406118;
          *(_DWORD *)(v3 + 8) = 1749229671;
          *(_DWORD *)(v3 + 12) = 544502369;
          *(_DWORD *)(v3 + 16) = 1635017060;
          *(_BYTE *)(v3 + 20) = 0;
          break;
        case 3:
          v3 = 51 * *(_DWORD *)(v2 + 2796);
          qmemcpy((void *)(v3 + v2 + 832), "Chart data update available.", 0x1Du);
          *(_DWORD *)(16 * *(_DWORD *)(v2 + 2796) + v2 + 232) = "+";
          break;
        case 2:
          qmemcpy((void *)(51 * *(_DWORD *)(v2 + 2796) + v2 + 832), "Chart data is out of date!", 0x1Bu);
          v3 = 16 * *(_DWORD *)(v2 + 2796);
          *(_DWORD *)(v3 + v2 + 232) = &unk_10052A50;
          break;
        case 7:
          v14 = 51 * *(_DWORD *)(v2 + 2796);
          *(_DWORD *)(v14 + v2 + 832) = 1918986307;
          v3 = v14 + v2 + 832;
          *(_DWORD *)(v3 + 4) = 1633951860;
          *(_DWORD *)(v3 + 8) = 1763729780;
          *(_DWORD *)(v3 + 12) = 1768169587;
          *(_DWORD *)(v3 + 16) = 1818386803;
          *(_DWORD *)(v3 + 20) = 3040357;
          *(_DWORD *)(16 * *(_DWORD *)(v2 + 2796) + v2 + 232) = &unk_10052A50;
          break;
        case 0xA:
          v3 = 51 * *(_DWORD *)(v2 + 2796) + v2 + 832;
          *(_DWORD *)v3 = 1918986307;
          *(_DWORD *)(v3 + 4) = 1631854708;
          *(_DWORD *)(v3 + 8) = 540696948;
          *(_DWORD *)(v3 + 12) = 4271950;
          break;
        case 4:
          v3 = 51 * *(_DWORD *)(v2 + 2796);
          qmemcpy((void *)(v3 + v2 + 832), "Verify chart database cycle.", 0x1Cu);
          v13 = "";
          v12 = (char *)(v3 + v2 + 860);
LABEL_27:
          *v12 = *v13;
          *(_DWORD *)(16 * *(_DWORD *)(v2 + 2796) + v2 + 232) = &unk_10052A50;
          break;
        case 0xD:
          *(_WORD *)(51 * *(_DWORD *)(v2 + 2796) + v2 + 832) = 32;
          LOBYTE(v3) = sub_100079D0(0);
          break;
        default:
          return v3;
      }
    }
  }
  return v3;
}

//----- (10005FF0) --------------------------------------------------------
char __cdecl sub_10005FF0(int a1)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // eax@5
  int v4; // edx@9
  int v5; // eax@9
  char v6; // cl@10
  bool v7; // zf@12
  int v8; // eax@12
  int v9; // eax@13
  int v10; // eax@14
  int v12; // [sp+4h] [bp-8Ch]@1
  char v13; // [sp+Bh] [bp-85h]@12
  int v14; // [sp+Ch] [bp-84h]@1
  char v15; // [sp+10h] [bp-80h]@5
  int v16; // [sp+14h] [bp-7Ch]@1
  int v17; // [sp+1Ch] [bp-74h]@1
  int v18; // [sp+24h] [bp-6Ch]@1
  char v19; // [sp+3Ch] [bp-54h]@1
  int v20; // [sp+60h] [bp-30h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_1003A910(
         1,
         &v19,
         0x21u,
         (int)&v17,
         7u,
         (int)&v18,
         0x15u,
         (int)&v20,
         0x29u,
         (int)&v14,
         (int)&v12,
         (int)&v16,
         5u);
  *(_DWORD *)(16 * *(_DWORD *)(v1 + 2800) + v1 + 232) = "+";
  if ( v2 )
  {
    v7 = sub_10037CB0(21, 0, 1, (int)&v13) == 12;
    v8 = *(_DWORD *)(v1 + 2800);
    if ( v7 )
    {
      v9 = 51 * v8;
      *(_DWORD *)(v9 + v1 + 832) = 1769104726;
      v3 = v9 + v1 + 832;
      *(_DWORD *)(v3 + 4) = 1852406118;
      *(_DWORD *)(v3 + 8) = 1649352807;
      *(_DWORD *)(v3 + 12) = 1667331187;
      *(_DWORD *)(v3 + 16) = 1142973804;
      *(_DWORD *)(v3 + 20) = 6386785;
    }
    else
    {
      v10 = 51 * v8;
      *(_DWORD *)(v10 + v1 + 832) = 1953718863;
      v3 = v10 + v1 + 832;
      *(_DWORD *)(v3 + 4) = 1701602145;
      *(_DWORD *)(v3 + 8) = 1952531488;
      *(_DWORD *)(v3 + 12) = 1310734945;
      *(_WORD *)(v3 + 16) = 16687;
      *(_BYTE *)(v3 + 18) = 0;
    }
  }
  else if ( HIWORD(v12) && (_BYTE)v12 && BYTE1(v12) )
  {
    sprintf(
      (char *)(51 * *(_DWORD *)(v1 + 2800) + v1 + 832),
      "Obstacle  Expires %d-%s-%d",
      BYTE1(v12),
      &asc_100529DC[4 * (unsigned __int8)v12],
      HIWORD(v12));
    LOBYTE(v3) = sub_100135F0((int)&v15);
    if ( (_BYTE)v3 && (LOBYTE(v3) = sub_10004C50((int)&v14, (int)&v15, (int)&v12), (_BYTE)v3) )
    {
      v3 = 16 * *(_DWORD *)(v1 + 2800);
      *(_DWORD *)(v3 + v1 + 232) = "+";
    }
    else
    {
      *(_DWORD *)(16 * *(_DWORD *)(v1 + 2800) + v1 + 232) = &unk_10052A50;
    }
  }
  else
  {
    v4 = 51 * *(_DWORD *)(v1 + 2800);
    *(_DWORD *)(v4 + v1 + 832) = 1953718863;
    v5 = v4 + v1 + 832;
    *(_DWORD *)(v5 + 4) = 1701602145;
    *(_DWORD *)(v5 + 8) = 2017796128;
    *(_DWORD *)(v5 + 12) = 1701996912;
    *(_WORD *)(v5 + 16) = 8307;
    *(_BYTE *)(v5 + 18) = 0;
    v3 = 51 * *(_DWORD *)(v1 + 2800) + v1 + 831;
    do
      v6 = *(_BYTE *)(v3++ + 1);
    while ( v6 );
    *(_DWORD *)v3 = 1596809055;
    *(_DWORD *)(v3 + 4) = 1596809055;
    *(_DWORD *)(v3 + 8) = 6250335;
  }
  return v3;
}

//----- (100062A0) --------------------------------------------------------
char __cdecl sub_100062A0(int a1)
{
  int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@7
  int v4; // edx@10
  int v5; // eax@10
  char v6; // cl@11
  int v7; // eax@13
  unsigned int v9; // [sp+4h] [bp-3Ch]@4
  int v10; // [sp+8h] [bp-38h]@3
  char v11; // [sp+Fh] [bp-31h]@1
  char v12; // [sp+10h] [bp-30h]@4
  char v13; // [sp+14h] [bp-2Ch]@7
  char v14; // [sp+18h] [bp-28h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( sub_10037CB0(25, 0, 1, (int)&v11) == 12 )
  {
    v2 = 51 * *(_DWORD *)(v1 + 2804) + v1 + 832;
    *(_DWORD *)v2 = 1769104726;
    *(_DWORD *)(v2 + 4) = 1852406118;
    *(_DWORD *)(v2 + 8) = 1632837735;
    *(_DWORD *)(v2 + 12) = 1632920934;
    *(_DWORD *)(v2 + 16) = 1142974840;
    *(_DWORD *)(v2 + 20) = 6386785;
LABEL_14:
    v3 = 16 * *(_DWORD *)(v1 + 2804);
    *(_DWORD *)(v3 + v1 + 232) = "+";
    return v3;
  }
  sub_10009BE0(25, &v14, 33, (int)&v10);
  if ( (_WORD)v10 == -1 )
  {
    v7 = 51 * *(_DWORD *)(v1 + 2804) + v1 + 832;
    *(_DWORD *)v7 = 1701208403;
    *(_DWORD *)(v7 + 4) = 1769496916;
    *(_DWORD *)(v7 + 8) = 793649210;
    *(_WORD *)(v7 + 12) = 65;
    goto LABEL_14;
  }
  sub_10009D10(&v12, (char *)&v9);
  if ( HIWORD(v9) < 0x7D0u || (unsigned __int8)(v9 - 1) > 0xBu || (unsigned __int8)(BYTE1(v9) - 1) > 0x1Eu )
  {
    v4 = 51 * *(_DWORD *)(v1 + 2804);
    *(_DWORD *)(v4 + v1 + 832) = 1701208403;
    v5 = v4 + v1 + 832;
    *(_DWORD *)(v5 + 4) = 1769496916;
    *(_DWORD *)(v5 + 8) = 2017796128;
    *(_DWORD *)(v5 + 12) = 1701996912;
    *(_WORD *)(v5 + 16) = 8307;
    *(_BYTE *)(v5 + 18) = 0;
    v3 = 51 * *(_DWORD *)(v1 + 2804) + v1 + 831;
    do
      v6 = *(_BYTE *)(v3++ + 1);
    while ( v6 );
    *(_DWORD *)v3 = 1596809055;
    *(_DWORD *)(v3 + 4) = 1596809055;
    *(_DWORD *)(v3 + 8) = 6250335;
  }
  else
  {
    sprintf(
      (char *)(51 * *(_DWORD *)(v1 + 2804) + v1 + 832),
      "SafeTaxi  Expires %d-%s-%d",
      BYTE1(v9),
      &asc_100529DC[4 * (unsigned __int8)v9],
      HIWORD(v9));
    LOBYTE(v3) = sub_100135F0((int)&v13);
    if ( (_BYTE)v3 )
    {
      LOBYTE(v3) = sub_10004C50((int)&v12, (int)&v13, (int)&v9);
      if ( (_BYTE)v3 )
        goto LABEL_14;
    }
    *(_DWORD *)(16 * *(_DWORD *)(v1 + 2804) + v1 + 232) = &unk_10052A50;
  }
  return v3;
}

//----- (100064F0) --------------------------------------------------------
char __cdecl sub_100064F0(int a1)
{
  void *v1; // ecx@0
  int v2; // ebx@1
  void *v3; // ecx@1
  int v4; // eax@3
  int v5; // eax@5
  int v6; // eax@6
  _WORD *v7; // edi@6
  char v8; // al@7
  unsigned int v9; // eax@8
  char *v10; // edi@8
  char v11; // cl@9
  int v12; // eax@11
  int v13; // eax@15
  signed int i; // eax@15
  char *v15; // eax@18
  char *v16; // esi@18
  char v17; // cl@19
  unsigned int v18; // eax@20
  char *v19; // edi@20
  char v20; // cl@21
  int v21; // eax@23
  int v22; // eax@23
  int v23; // eax@28
  void *v24; // ecx@35
  char result; // al@35
  char v26; // [sp+13h] [bp-C5h]@12
  int v27; // [sp+14h] [bp-C4h]@14
  int v28; // [sp+18h] [bp-C0h]@24
  int v29; // [sp+1Ch] [bp-BCh]@24
  int v30; // [sp+20h] [bp-B8h]@24
  int v31; // [sp+28h] [bp-B0h]@24
  char v32; // [sp+30h] [bp-A8h]@14
  char v33[35]; // [sp+31h] [bp-A7h]@18
  int v34; // [sp+54h] [bp-84h]@24
  char v35; // [sp+6Ch] [bp-6Ch]@6
  char v36; // [sp+84h] [bp-54h]@24
  int v37; // [sp+A8h] [bp-30h]@24

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( sub_1000A940(v1) == 2 )
  {
    sub_100014B0();
    sub_1000AC60();
  }
  v4 = (unsigned __int8)sub_1000A940(v3);
  if ( (_BYTE)v4 )
  {
    if ( v4 == 1 )
    {
      v6 = 51 * *(_DWORD *)(v2 + 2792) + v2 + 832;
      *(_DWORD *)v6 = 1667590211;
      *(_DWORD *)(v6 + 4) = 1936288875;
      *(_DWORD *)(v6 + 8) = 1766203508;
      *(_DWORD *)(v6 + 12) = 3827052;
      sub_10009FD0((int)&v35, 0x15u);
      v7 = (_WORD *)(51 * *(_DWORD *)(v2 + 2792) + v2 + 831);
      do
      {
        v8 = *((_BYTE *)v7 + 1);
        v7 = (_WORD *)((char *)v7 + 1);
      }
      while ( v8 );
      *v7 = 32;
      v9 = strlen(&v35) + 1;
      v10 = (char *)(51 * *(_DWORD *)(v2 + 2792) + v2 + 831);
      do
        v11 = (v10++)[1];
      while ( v11 );
      qmemcpy(v10, &v35, v9);
    }
    else
    {
      v5 = 51 * *(_DWORD *)(v2 + 2792) + v2 + 832;
      *(_DWORD *)v5 = 1667590211;
      *(_DWORD *)(v5 + 4) = 1936288875;
      *(_DWORD *)(v5 + 8) = 1766203508;
      *(_DWORD *)(v5 + 12) = 540697964;
      *(_DWORD *)(v5 + 16) = 4271950;
    }
  }
  else
  {
    v12 = 51 * *(_DWORD *)(v2 + 2792) + v2 + 832;
    *(_DWORD *)v12 = 1667590211;
    *(_DWORD *)(v12 + 4) = 1936288875;
    *(_DWORD *)(v12 + 8) = 1766203508;
    *(_DWORD *)(v12 + 12) = 540697964;
    *(_DWORD *)(v12 + 16) = 1635151433;
    *(_DWORD *)(v12 + 20) = 6580588;
  }
  if ( sub_10037CB0(7, 0, 1, (int)&v26) == 12 )
  {
    qmemcpy((void *)(51 * *(_DWORD *)(v2 + 2788) + v2 + 832), "Verifying Basemap Land Data", 0x1Cu);
    *(_DWORD *)(16 * *(_DWORD *)(v2 + 2788) + v2 + 232) = "+";
  }
  else
  {
    sub_10009BE0(7, &v32, 33, (int)&v27);
    if ( (_WORD)v27 == -1 )
    {
      v21 = 51 * *(_DWORD *)(v2 + 2788);
      *(_DWORD *)(v21 + v2 + 832) = 1702060354;
      v22 = v21 + v2 + 832;
      *(_DWORD *)(v22 + 4) = 544235885;
      *(_DWORD *)(v22 + 8) = 1684955468;
      *(_DWORD *)(v22 + 12) = 793649210;
      *(_WORD *)(v22 + 16) = 65;
    }
    else
    {
      v13 = 51 * *(_DWORD *)(v2 + 2788) + v2 + 832;
      *(_DWORD *)v13 = 1702060354;
      *(_DWORD *)(v13 + 4) = 544235885;
      *(_DWORD *)(v13 + 8) = 1684955468;
      *(_WORD *)(v13 + 12) = 32;
      for ( i = strlen(&v32); i >= 0; --i )
      {
        if ( *(&v32 + i) == 32 )
          break;
      }
      *(&v32 + i) = 0;
      v15 = &v33[i];
      v16 = v15;
      do
        v17 = *v15++;
      while ( v17 );
      v18 = v15 - v16;
      v19 = (char *)(51 * *(_DWORD *)(v2 + 2788) + v2 + 831);
      do
        v20 = (v19++)[1];
      while ( v20 );
      qmemcpy(v19, v16, v18);
      *(_DWORD *)(16 * *(_DWORD *)(v2 + 2788) + v2 + 232) = "+";
    }
  }
  sub_100062A0(a1);
  if ( sub_1003A910(
         0,
         &v36,
         0x21u,
         (int)&v30,
         7u,
         (int)&v34,
         0x15u,
         (int)&v37,
         0x29u,
         (int)&v29,
         (int)&v28,
         (int)&v31,
         5u) )
  {
    if ( sub_10037CB0(10, 0, 1, (int)&v26) == 12 )
    {
      qmemcpy((void *)(51 * *(_DWORD *)(v2 + 2808) + v2 + 832), "Verifying Terrain Data", 0x17u);
    }
    else
    {
      v23 = 51 * *(_DWORD *)(v2 + 2808) + v2 + 832;
      *(_DWORD *)v23 = 1920099668;
      *(_DWORD *)(v23 + 4) = 544106849;
      *(_DWORD *)(v23 + 8) = 1635017028;
      *(_DWORD *)(v23 + 12) = 793649210;
      *(_WORD *)(v23 + 16) = 65;
    }
  }
  else
  {
    sprintf((char *)(51 * *(_DWORD *)(v2 + 2808) + v2 + 832), "Terrain %s", &v30);
  }
  if ( *(_BYTE *)(v2 + 2813) )
  {
    if ( sub_1003A910(
           2,
           &v36,
           0x21u,
           (int)&v30,
           7u,
           (int)&v34,
           0x15u,
           (int)&v37,
           0x29u,
           (int)&v29,
           (int)&v28,
           (int)&v31,
           5u) )
    {
      if ( sub_10037CB0(23, 0, 1, (int)&v26) == 12 )
        qmemcpy((void *)(51 * *(_DWORD *)(v2 + 2780) + v2 + 832), "Verifying Airport Terrain Data", 0x1Fu);
      else
        qmemcpy((void *)(51 * *(_DWORD *)(v2 + 2780) + v2 + 832), "Airport Terrain Data: N/A", 0x1Au);
    }
    else
    {
      sprintf((char *)(51 * *(_DWORD *)(v2 + 2780) + v2 + 832), "Airport Terrain %s", &v30);
    }
  }
  sub_10005FF0(a1);
  sub_10005A10(a1);
  sub_10005770(a1);
  result = sub_10007890(v24);
  if ( result )
    result = sub_10005BD0(a1);
  return result;
}
// 100064F0: using guessed type char var_A7[35];

//----- (100069D0) --------------------------------------------------------
void __cdecl sub_100069D0(int a1)
{
  int v1; // ebp@1
  signed int v2; // esi@1
  _BYTE *v3; // edi@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // eax@4
  int v11; // eax@5
  int v12; // eax@5
  int v13; // eax@5
  bool v14; // zf@5
  int v15; // eax@5
  int v16; // eax@6
  int v17; // ecx@10
  int v18; // ecx@10
  int v19; // ecx@10
  int v20; // eax@10
  char *v21; // ecx@11
  _BYTE *v22; // edx@11
  char v23; // al@12
  signed int v24; // ecx@15
  _DWORD *v25; // eax@16
  unsigned int v26; // edi@19
  int v27; // edi@20
  int v28; // ebp@20
  char *v29; // eax@21
  char v30; // cl@22
  char v31; // [sp+14h] [bp-198h]@18
  int v32; // [sp+18h] [bp-194h]@19
  int v33; // [sp+1Ch] [bp-190h]@19
  char v34[188]; // [sp+20h] [bp-18Ch]@21
  __int16 v35; // [sp+DCh] [bp-D0h]@19
  int v36; // [sp+E0h] [bp-CCh]@19
  int v37; // [sp+E4h] [bp-C8h]@19
  int v38; // [sp+E8h] [bp-C4h]@19
  char v39; // [sp+ECh] [bp-C0h]@22

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 2772) = 0;
  *(_BYTE *)(v1 + 2812) = -1;
  *(_DWORD *)(v1 + 2776) = 0;
  *(_DWORD *)(v1 + 2780) = 0;
  *(_DWORD *)(v1 + 2784) = 0;
  *(_DWORD *)(v1 + 2788) = 0;
  *(_DWORD *)(v1 + 2792) = 0;
  *(_DWORD *)(v1 + 2796) = 0;
  *(_DWORD *)(v1 + 2800) = 0;
  *(_DWORD *)(v1 + 2804) = 0;
  *(_DWORD *)(v1 + 2808) = 0;
  v2 = 0;
  v3 = (_BYTE *)(v1 + 832);
  v4 = v1 + 226;
  do
  {
    *v3 = 0;
    *(_DWORD *)(v4 + 10) = v3;
    *(_BYTE *)(v4 - 1) = 0;
    *(_DWORD *)(v4 + 6) = "+";
    *(_BYTE *)(v4 - 2) = 1;
    v3 += 51;
    *(_WORD *)v4 = v2 >= 17 ? 674 : 709;
    *(_WORD *)(v4 + 2) = 18 * v2++ + 184;
    v4 += 16;
  }
  while ( v2 < 38 );
  v5 = *(_DWORD *)(v1 + 2772);
  *(_DWORD *)(v1 + 2792) = v5++;
  *(_DWORD *)(v1 + 2772) = v5;
  *(_DWORD *)(16 * v5 + v1 + 232) = 0;
  v6 = *(_DWORD *)(v1 + 2772) + 1;
  *(_DWORD *)(v1 + 2788) = v6++;
  *(_DWORD *)(v1 + 2772) = v6;
  *(_DWORD *)(16 * v6 + v1 + 232) = 0;
  v7 = *(_DWORD *)(v1 + 2772) + 1;
  *(_DWORD *)(v1 + 2804) = v7++;
  *(_DWORD *)(v1 + 2772) = v7;
  *(_DWORD *)(16 * v7 + v1 + 232) = 0;
  v8 = *(_DWORD *)(v1 + 2772) + 1;
  *(_DWORD *)(v1 + 2808) = v8++;
  *(_DWORD *)(v1 + 2772) = v8;
  *(_DWORD *)(16 * v8 + v1 + 232) = 0;
  v9 = ++*(_DWORD *)(v1 + 2772);
  if ( *(_BYTE *)(v1 + 2813) )
  {
    *(_DWORD *)(v1 + 2780) = v9;
    v10 = v9 + 1;
    *(_DWORD *)(v1 + 2772) = v10;
    *(_DWORD *)(16 * v10 + v1 + 232) = 0;
    v9 = ++*(_DWORD *)(v1 + 2772);
  }
  *(_DWORD *)(v1 + 2800) = v9;
  v11 = v9 + 1;
  *(_DWORD *)(v1 + 2772) = v11;
  *(_DWORD *)(16 * v11 + v1 + 232) = 0;
  v12 = *(_DWORD *)(v1 + 2772) + 1;
  *(_DWORD *)(v1 + 2784) = v12++;
  *(_DWORD *)(v1 + 2772) = v12;
  *(_DWORD *)(16 * v12 + v1 + 232) = 0;
  v13 = *(_DWORD *)(v1 + 2772) + 1;
  *(_DWORD *)(v1 + 2776) = v13++;
  *(_DWORD *)(v1 + 2772) = v13;
  *(_DWORD *)(16 * v13 + v1 + 232) = 0;
  ++*(_DWORD *)(v1 + 2772);
  v14 = (unsigned __int8)sub_10007890("+") == 0;
  v15 = *(_DWORD *)(v1 + 2772);
  if ( v14 )
  {
    *(_DWORD *)(16 * v15 + v1 + 232) = 0;
    v16 = ++*(_DWORD *)(v1 + 2772);
  }
  else
  {
    *(_DWORD *)(v1 + 2796) = v15;
    v16 = v15 + 1;
    *(_DWORD *)(v1 + 2772) = v16;
  }
  *(_DWORD *)(16 * v16 + v1 + 232) = 0;
  ++*(_DWORD *)(v1 + 2772);
  if ( !*(_BYTE *)(v1 + 2813) )
  {
    *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
    *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  }
  sub_100064F0(a1);
  *(_DWORD *)(16 * *(_DWORD *)(v1 + 2772) + v1 + 232) = &unk_10052A30;
  v17 = 51 * (*(_DWORD *)(v1 + 2772))++;
  qmemcpy((void *)(v17 + v1 + 832), "All map and terrain data provided is only to be", 0x30u);
  *(_DWORD *)(16 * *(_DWORD *)(v1 + 2772) + v1 + 232) = &unk_10052A30;
  v18 = 51 * (*(_DWORD *)(v1 + 2772))++;
  qmemcpy((void *)(v18 + v1 + 832), "used as a general reference to your surrounding", 0x30u);
  *(_DWORD *)(16 * *(_DWORD *)(v1 + 2772) + v1 + 232) = &unk_10052A30;
  v19 = 51 * (*(_DWORD *)(v1 + 2772))++;
  qmemcpy((void *)(v19 + v1 + 832), "and as an aid to situational awareness.", 0x28u);
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  v20 = *(_DWORD *)(v1 + 2772);
  if ( *(_BYTE *)(v1 + 2815) )
  {
    v21 = (char *)(v1 + 2817);
    v22 = (_BYTE *)(51 * v20 + v1 + 832);
    *(_DWORD *)(v1 + 2772) = v20 + 1;
    do
    {
      v23 = *v21;
      *v22++ = *v21++;
    }
    while ( v23 );
  }
  *(_DWORD *)(16 * (*(_DWORD *)(v1 + 2772))++ + v1 + 232) = 0;
  if ( *(_DWORD *)(v1 + 2772) > 38 )
    sub_1000D9C0(".\\cdp_pg_pwrp.c", 1592, 1, 0);
  v24 = 37;
  if ( *(_DWORD *)(v1 + 2772) <= 37 )
  {
    v25 = (_DWORD *)(v1 + 828);
    do
    {
      *(v25 - 1) = 0;
      *v25 = 0;
      --v24;
      v25 -= 4;
    }
    while ( v24 >= *(_DWORD *)(v1 + 2772) );
  }
  sub_10013740(&v31);
  if ( v31 )
  {
    v26 = a1;
    v36 = sub_10002790(a1, (int)sub_10004B90);
    v35 = -32646;
    v37 = v32;
    v38 = v33;
    if ( v33 > 0 )
    {
      v27 = 0;
      v28 = v33;
      do
      {
        v29 = &v34[v27];
        do
        {
          v30 = *v29;
          v29[&v39 - v34] = *v29;
          ++v29;
        }
        while ( v30 );
        v27 += 37;
        --v28;
      }
      while ( v28 );
      v26 = a1;
    }
    sub_10002900(v26, (int)&v35, 204);
    sub_1000C2D0(v26, 0, (int (__cdecl *)(int))sub_10004B90, 0);
  }
}
// 10004B90: using guessed type int sub_10004B90();
// 100069D0: using guessed type char var_18C[188];

//----- (10006EB0) --------------------------------------------------------
signed int __usercall sub_10006EB0@<eax>(int a1@<ebx>)
{
  int v1; // ebp@1
  int *v2; // ecx@1
  int v3; // edx@1
  signed int v4; // esi@1
  _DWORD *v5; // ecx@3
  int v6; // eax@10
  char v7; // cl@11
  unsigned int v8; // eax@12
  char *v9; // edi@12
  char v10; // cl@13
  int *v11; // ecx@15
  int v12; // eax@15
  signed int v13; // edx@15
  unsigned int v14; // edi@18
  signed int result; // eax@22
  int v16; // [sp+8h] [bp-58h]@3
  __int16 v17; // [sp+Ch] [bp-54h]@4
  int v18; // [sp+10h] [bp-50h]@4
  char v19; // [sp+14h] [bp-4Ch]@4
  __int16 v20; // [sp+16h] [bp-4Ah]@4
  __int16 v21; // [sp+18h] [bp-48h]@4
  int v22; // [sp+20h] [bp-40h]@17
  int v23; // [sp+24h] [bp-3Ch]@17
  __int16 v24; // [sp+28h] [bp-38h]@17
  int v25; // [sp+30h] [bp-30h]@17
  __int16 v26; // [sp+34h] [bp-2Ch]@17
  void *v27; // [sp+38h] [bp-28h]@17
  int v28; // [sp+3Ch] [bp-24h]@17
  void *v29; // [sp+40h] [bp-20h]@17
  int v30; // [sp+44h] [bp-1Ch]@17
  int v31; // [sp+48h] [bp-18h]@17
  char v32; // [sp+4Ch] [bp-14h]@17
  int v33; // [sp+50h] [bp-10h]@17
  char v34; // [sp+54h] [bp-Ch]@9

  v1 = sub_10002800(a1, *(char **)(a1 + 56), 3528, 1);
  sub_10002570(a1, 0, 0, 1024, 768, 3);
  sub_1000E410(*(_DWORD *)(a1 + 56), (char *)&unk_10052C5C);
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  v2 = (int *)(v1 + 3328);
  v3 = v1 + 2884;
  v4 = 26;
  do
  {
    *v2 = v3;
    ++v2;
    v3 += 17;
    --v4;
  }
  while ( v4 );
  sub_1000B350(0, 0x1Au, (_BYTE *)(v1 + 2884), (unsigned __int16 *)(v1 + 2852), (unsigned __int16 *)(v1 + 2854));
  *(_WORD *)(v1 + 2880) = *(_WORD *)(v1 + 2854);
  sub_1000B010((char *)(v1 + 2817));
  *(_DWORD *)(v1 + 2860) = v1 + 3328;
  *(_DWORD *)(v1 + 2856) = "+";
  *(_DWORD *)(v1 + 2864) = 0;
  *(_BYTE *)(v1 + 2883) = 0;
  *(_BYTE *)(v1 + 2882) = 0;
  *(_DWORD *)(v1 + 214) = -1;
  *(_DWORD *)(v1 + 218) = -1;
  sub_10039740(12, (_BYTE *)(v1 + 2815));
  sub_10039740(89, (_BYTE *)(v1 + 2816));
  *(_BYTE *)(v1 + 2814) = 0;
  v5 = *(_DWORD **)(*(_DWORD *)(a1 + 56) + 60);
  *v5 = v1 + 2836;
  v16 = (int)v5;
  *(_DWORD *)(v1 + 2868) = 19;
  *(_BYTE *)(v1 + 2876) = 33;
  *(_DWORD *)(v1 + 2872) = -14671840;
  *(_BYTE *)(v1 + 2836) = 1;
  *(_BYTE *)(v1 + 2837) = 0;
  *(_WORD *)(v1 + 2838) = 674;
  *(_WORD *)(v1 + 2840) = 652;
  *(_DWORD *)(v1 + 2848) = v1 + 2852;
  *(_DWORD *)(v1 + 2844) = v1 + 2868;
  **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  if ( *(_BYTE *)(v1 + 2816) )
  {
    v18 = 0;
    v17 = -32696;
    v20 = 40;
    v21 = 0;
    v19 = 1;
    sub_10002900(a1, (int)&v17, 20);
  }
  if ( *(_BYTE *)(v1 + 2815) )
    *(_DWORD *)(v1 + 8) = "Press FMS knob to change profile";
  else
    *(_DWORD *)(v1 + 8) = &unk_10052406;
  sub_100117C0();
  *(_DWORD *)(v1 + 12) = &unk_1005377D;
  if ( *(_BYTE *)dword_1077AE98 != 63 && sub_10013F00((int)&v34) )
  {
    strncpy((char *)(v1 + 3432), (const char *)(dword_1077AE98 + 20440), 0x28u);
    v6 = v1 + 3431;
    do
      v7 = *(_BYTE *)(v6++ + 1);
    while ( v7 );
    *(_DWORD *)v6 = 1937330976;
    *(_DWORD *)(v6 + 4) = 544040308;
    *(_BYTE *)(v6 + 8) = 0;
    v8 = strlen(&v34) + 1;
    v9 = (char *)(v1 + 3431);
    do
      v10 = (v9++)[1];
    while ( v10 );
    qmemcpy(v9, &v34, v8);
    *(_DWORD *)(v1 + 12) = v1 + 3432;
  }
  sub_10005170(v1);
  *(_DWORD *)(v1 + 168) = v1 + 3520;
  *(_DWORD *)(v1 + 172) = v1 + 3524;
  v11 = (int *)(v1 + 16);
  v12 = v1 + 224;
  v13 = 38;
  do
  {
    *v11 = v12;
    v12 += 16;
    ++v11;
    --v13;
  }
  while ( v13 );
  *(_BYTE *)(v1 + 2813) = sub_10005720();
  sub_100069D0(a1);
  *(_DWORD *)v1 = "Press \"ENT\" or rightmost softkey";
  *(_DWORD *)(v1 + 4) = " to continue";
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052A88, (int)&unk_100531D4, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052C5C, v16, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10053008, v1, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052CBC, v1 + 168, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100530A0, v1 + 16, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052DC8, (int)&unk_10053244, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052F30, (int)&unk_10053254, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052DB0, (int)&unk_1005323C, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052FD4, (int)&unk_1005325C, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052FEC, (int)&unk_10053264, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052C68, (int)&unk_100531F4, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052CE8, (int)&unk_10053208, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D3C, (int)&unk_1005321C, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D58, (int)&unk_10053224, 0, 255);
  sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D98, (int)&unk_10053234, 0, 255);
  sub_100029B0(a1, *(_DWORD *)(a1 + 56), 40);
  sub_10002F70(a1, *(_DWORD *)(a1 + 56), -32648);
  memset(&v22, 0, 0x34u);
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = &unk_100E9A48;
  v28 = 1024;
  v29 = &unk_103EDED0;
  v30 = 46920;
  v31 = 15;
  v32 = -2;
  v33 = 0xFFFF;
  dword_100E9E48 = &unk_100EDE50;
  dword_100E9A40 = sub_10010530((int)"/mnt/sys_nand0/sys_files.gca", 4, &unk_100EDE50, 0);
  if ( !dword_100E9A40 )
  {
    v14 = sub_100114F0((int)dword_100E9E48, "loading.bmp", 4, &unk_100E9760, (int)&v22);
    *(_DWORD *)(v1 + 3504) = &unk_100E9E50;
    if ( v14 < 0xFFFFFFC2 )
    {
      if ( v14 )
      {
        sub_1000CA00(v14, (int *)(v1 + 3504), 3145728, 0);
        sub_1000D380(v14);
      }
    }
  }
  dword_100E9A40 = sub_10010530((int)"/mnt/card0/startup_scrn.zip", 4, dword_100E9E48, 0);
  if ( dword_100E9A40
    && (result = sub_10010530((int)"/mnt/card1/startup_scrn.zip", 4, dword_100E9E48, 0), (dword_100E9A40 = result) != 0) )
  {
    dword_100E9E48 = 0;
    *(_DWORD *)(v1 + 3500) = 0;
  }
  else
  {
    result = sub_10010630((int)dword_100E9E48);
    *(_DWORD *)(v1 + 3500) = result;
  }
  dword_100E9A44 = 0;
  *(_DWORD *)(v1 + 3496) = -1;
  *(_BYTE *)(v1 + 3516) = 1;
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100E9A40: using guessed type int dword_100E9A40;
// 100E9A44: using guessed type int dword_100E9A44;
// 1077AE98: using guessed type int dword_1077AE98;

//----- (100074A0) --------------------------------------------------------
char __usercall sub_100074A0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebp@1
  char v3; // al@3
  char result; // al@5
  int v5; // edi@11
  void *v6; // ecx@12
  _WORD *v7; // [sp-14h] [bp-30h]@23
  char *v8; // [sp-10h] [bp-2Ch]@23
  void *v9; // [sp-Ch] [bp-28h]@23
  __int16 v10; // [sp+8h] [bp-14h]@10
  int v11; // [sp+Ch] [bp-10h]@10
  char v12; // [sp+10h] [bp-Ch]@10
  __int16 v13; // [sp+12h] [bp-Ah]@10
  __int16 v14; // [sp+14h] [bp-8h]@10

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(v1 + 230) == -1 )
    sub_100064F0(a1);
  v3 = *(_BYTE *)(v2 + 2883);
  if ( !v3 )
    goto LABEL_31;
  if ( !*(_BYTE *)(v2 + 2882) )
  {
    result = sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052DC8, (int)&unk_10053244, 0, 255);
    *(_BYTE *)(v2 + 2882) = 1;
    return result;
  }
  if ( v3 && *(_BYTE *)(v2 + 2882) )
  {
    if ( *(_BYTE *)(v2 + 2814) )
      sub_1000B270((const char *)(*(_WORD *)(v2 + 2854) + v2 + 16 * *(_WORD *)(v2 + 2854) + 2884));
    *(_BYTE *)(v2 + 2882) = 0;
    *(_BYTE *)(v2 + 2883) = 0;
    v11 = 0;
    v10 = -32696;
    v13 = 33;
    v14 = 0;
    v12 = 1;
    result = sub_10002900(a1, (int)&v10, 20);
  }
  else
  {
LABEL_31:
    *(_DWORD *)(v2 + 176) = 50529027;
    v5 = v2 + 176;
    *(_DWORD *)(v5 + 4) = 50529027;
    *(_DWORD *)(v5 + 8) = 50529027;
    *(_DWORD *)(v5 + 12) = 50529027;
    *(_DWORD *)(v5 + 16) = 50529027;
    *(_DWORD *)(v5 + 20) = 50529027;
    *(_DWORD *)(v5 + 24) = 50529027;
    *(_DWORD *)(v5 + 28) = 50529027;
    *(_DWORD *)(v5 + 32) = 50529027;
    *(_WORD *)(v5 + 36) = 771;
    sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052A88, (int)&unk_100531D4, 0, 255);
    sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052C68, (int)&unk_100531F4, 0, 255);
    if ( *(_BYTE *)(v2 + 2813) )
      sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052CE8, (int)&unk_10053208, 0, 255);
    else
      sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D58, (int)&unk_10053224, 0, 255);
    if ( (unsigned __int8)sub_10007890(v6) && *(_BYTE *)(v2 + 2812) != 13 )
    {
      if ( *(_BYTE *)(v2 + 2813) )
        sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D3C, (int)&unk_1005321C, 0, 255);
      else
        sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052D98, (int)&unk_10053234, 0, 255);
    }
    sub_10004CC0(a1);
    j_gdi_pvg_scissor(0, 108, *(_WORD *)(a1 + 16), 570);
    j_gdi_pvg_enable(36);
    sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_100530A0, v2 + 16, v2 + 176, 255);
    j_gdi_pvg_disable(36);
    sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10053008, v2, 0, 255);
    sub_1000F5B0(
      a1,
      *(_WORD **)(a1 + 52),
      (char *)&unk_10052C5C,
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
    *(_BYTE *)(a1 + 6) = 2;
    if ( !*(_BYTE *)(v2 + 2815) )
      sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052F30, (int)&unk_10053254, 0, 255);
    if ( *(_DWORD *)(v2 + 3520) || *(_DWORD *)(v2 + 3524) )
    {
      v9 = (void *)(v2 + 168);
      v8 = (char *)&unk_10052CBC;
      v7 = *(_WORD **)(a1 + 52);
    }
    else
    {
      v9 = &unk_1005323C;
      v8 = (char *)&unk_10052DB0;
      v7 = *(_WORD **)(a1 + 52);
    }
    sub_1000F5B0(a1, v7, v8, (int)v9, 0, 255);
    result = *(_BYTE *)(dword_1077AE98 + 28413);
    if ( result == 1 )
    {
      result = sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052FEC, (int)&unk_10053264, 0, 255);
    }
    else if ( !result )
    {
      result = sub_1000F5B0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10052FD4, (int)&unk_1005325C, 0, 255);
    }
  }
  return result;
}
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10038070: using guessed type int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD);
// 1077AE98: using guessed type int dword_1077AE98;

//----- (100077A0) --------------------------------------------------------
char __cdecl sub_100077A0(int a1)
{
  int v1; // ecx@1
  int v2; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = **(_WORD **)(a1 + 52);
  switch ( v2 )
  {
    case 32802:
      LOBYTE(v2) = sub_10005280(a1);
      break;
    case 32833:
      LOBYTE(v2) = sub_10006EB0(a1);
      break;
    case 32840:
      LOBYTE(v2) = sub_100052B0(a1);
      break;
    case 32846:
      **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 2;
      v2 = *(_DWORD *)(a1 + 56);
      *(_BYTE *)(v2 + 230) = -1;
      break;
    case 32849:
      LOBYTE(v2) = sub_100056C0(a1);
      break;
    case 32888:
      if ( *(_DWORD *)(v1 + 3496) >= 0 )
        *(_BYTE *)(v1 + 3516) = 1;
      else
        LOBYTE(v2) = sub_100074A0(a1);
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (10007890) --------------------------------------------------------
BOOL __thiscall sub_10007890(void *this)
{
  void *v1; // ecx@1
  char v2; // al@1
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = this;
  sub_10039740(48, (_BYTE *)&v4 + 3);
  v2 = sub_1000E750(v1);
  return BYTE3(v4) && (v2 == 1 || v2 == 8 || v2 == 2 || v2 == 4);
}

//----- (100078D0) --------------------------------------------------------
char sub_100078D0()
{
  int v0; // eax@1
  char result; // al@5
  char v2; // [sp+3h] [bp-59h]@1
  char *v3; // [sp+4h] [bp-58h]@1
  int v4; // [sp+8h] [bp-54h]@1
  int v5; // [sp+Ch] [bp-50h]@1
  __int16 *v6; // [sp+10h] [bp-4Ch]@1
  int v7; // [sp+14h] [bp-48h]@1
  int *v8; // [sp+18h] [bp-44h]@1
  int v9; // [sp+1Ch] [bp-40h]@1
  int v10; // [sp+20h] [bp-3Ch]@1
  __int16 v11; // [sp+24h] [bp-38h]@1
  char v12; // [sp+26h] [bp-36h]@1
  char v13; // [sp+28h] [bp-34h]@1

  v5 = 0;
  v13 = 0;
  v6 = &v11;
  v2 = 10;
  v11 = -32754;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v2;
  v4 = 1;
  v0 = sub_10038490(18, (int)&v6);
  if ( v0 || v5 || v4 != 1 )
  {
    if ( v0 == 3 )
      result = 13;
    else
      result = 10;
  }
  else
  {
    result = v2;
  }
  return result;
}

//----- (100079B0) --------------------------------------------------------
void sub_100079B0()
{
  dword_10747D94 = -15;
}
// 10747D94: using guessed type int dword_10747D94;

//----- (100079C0) --------------------------------------------------------
void sub_100079C0()
{
  dword_10747D90 = -15;
}
// 10747D90: using guessed type int dword_10747D90;

//----- (100079D0) --------------------------------------------------------
char __cdecl sub_100079D0(char a1)
{
  int v1; // eax@1
  __int16 v3; // [sp+0h] [bp-38h]@1
  char v4; // [sp+2h] [bp-36h]@1
  char v5; // [sp+4h] [bp-34h]@1

  v3 = -32750;
  v4 = 1;
  v5 = a1;
  v1 = sub_10038460(18, (int)&v3, 1, 0);
  if ( v1 )
    LOBYTE(v1) = sub_1000D9C0("..\\lib\\adl\\cht_intf.c", 1974, 0, 0);
  return v1;
}

//----- (10007A30) --------------------------------------------------------
char __cdecl sub_10007A30(void *a1)
{
  int v1; // esi@1
  char *v3; // [sp+Ch] [bp-F0h]@1
  int v4; // [sp+10h] [bp-ECh]@1
  int v5; // [sp+14h] [bp-E8h]@1
  __int16 *v6; // [sp+18h] [bp-E4h]@1
  int v7; // [sp+1Ch] [bp-E0h]@1
  int *v8; // [sp+20h] [bp-DCh]@1
  int v9; // [sp+24h] [bp-D8h]@1
  int v10; // [sp+28h] [bp-D4h]@1
  __int16 v11; // [sp+2Ch] [bp-D0h]@1
  char v12; // [sp+2Eh] [bp-CEh]@1
  char v13; // [sp+30h] [bp-CCh]@1
  char v14; // [sp+60h] [bp-9Ch]@1

  memset(&v14, 0, 0x98u);
  v6 = &v11;
  v5 = 0;
  v13 = 0;
  v11 = -32748;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v14;
  v4 = 152;
  v1 = sub_10038490(18, (int)&v6);
  if ( v5 != 3 || sub_100078D0() != 7 )
  {
    if ( !v1 && !v5 && v4 == 152 )
    {
      qmemcpy(a1, &v14, 0x98u);
      return 0;
    }
    memset(a1, 0, 0x98u);
    *(_BYTE *)a1 = 0;
    *((_WORD *)a1 + 69) = 0x7FFF;
    *((_DWORD *)a1 + 35) = -1;
    *((_DWORD *)a1 + 36) = -1;
  }
  else
  {
    qmemcpy(a1, &v14, 0x98u);
  }
  return 3;
}

//----- (10007B90) --------------------------------------------------------
int __cdecl sub_10007B90(char a1, void *a2, size_t a3, int a4)
{
  int v4; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v4 = 21;
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_9;
      v4 = 23;
    }
  }
  else
  {
    v4 = 10;
  }
  if ( !sub_10037CB0(v4, a4, a3, (int)a2) )
    return 0;
LABEL_9:
  memset(a2, 0, a3);
  return 1;
}

//----- (10007C10) --------------------------------------------------------
void __cdecl sub_10007C10(int a1)
{
  int v1; // ecx@1
  int v2; // eax@5
  int v3; // eax@6
  __int16 v4; // [sp+4h] [bp-Ch]@7
  int v5; // [sp+8h] [bp-8h]@7
  char v6; // [sp+Ch] [bp-4h]@6
  char v7; // [sp+Dh] [bp-3h]@7

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 == -32696 )
  {
    if ( *(_WORD *)(v1 + 10) == 57 )
    {
      v2 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v2 + 230) != -1 )
      {
        v6 = *(_BYTE *)(v2 + 230);
        *(_BYTE *)(a1 + 6) = sub_1000B690(a1, *(_BYTE *)(v2 + 230), *(_BYTE *)(v1 + 8));
        v3 = *(_DWORD *)(a1 + 56);
        if ( *(_BYTE *)(v3 + 236) )
        {
          v5 = *(_DWORD *)(a1 + 56);
          v4 = -32705;
          v7 = *(_BYTE *)(v3 + 230);
          sub_10002900(a1, (int)&v4, 12);
        }
      }
    }
    else if ( *(_WORD *)(v1 + 10) & 0xC000 )
    {
      *(_BYTE *)(a1 + 6) = 2;
    }
    if ( *(_BYTE *)(a1 + 6) == 1 )
      *(_BYTE *)(a1 + 6) = 0;
  }
}

//----- (10007CB0) --------------------------------------------------------
char sub_10007CB0()
{
  return 0;
}

//----- (10007CC0) --------------------------------------------------------
char __usercall sub_10007CC0@<al>(int a1@<edi>, int a2)
{
  int v2; // ecx@1
  char result; // al@1

  sub_100014B0();
  sub_1000AC60();
  result = sub_10003B10(v2, a1, a2);
  dword_1077A428 = 0;
  return result;
}
// 1077A428: using guessed type int dword_1077A428;

//----- (10007CE0) --------------------------------------------------------
char sub_10007CE0()
{
  char result; // al@1

  result = 0;
  byte_10747D9C = 0;
  byte_10747D9D = 0;
  return result;
}
// 10747D9C: using guessed type char byte_10747D9C;
// 10747D9D: using guessed type char byte_10747D9D;

//----- (10007CF0) --------------------------------------------------------
void __cdecl sub_10007CF0(unsigned int a1)
{
  sub_1000C2D0(a1, -1, (int (__cdecl *)(int))sub_100077A0, 0);
}

//----- (10007D10) --------------------------------------------------------
int __thiscall sub_10007D10(void *this)
{
  int v1; // eax@1
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  v1 = sub_100382C0();
  return sub_10038350((int)&v3, 5, v1, 4);
}

//----- (10007D30) --------------------------------------------------------
#error "10007D53: call analysis failed (funcsize=19)"

//----- (10007D80) --------------------------------------------------------
_WORD *__usercall sub_10007D80@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5)
{
  _WORD *result; // eax@1
  _WORD *v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  sub_1000E3C0(*(char **)(a2 + 8), (int *)&v6, 0);
  result = v6;
  *(_WORD *)a4 = *(_WORD *)a3 + *v6;
  *(_WORD *)(a4 + 2) = *(_WORD *)(a3 + 2) + result[1] + a5 * *(_WORD *)(a2 + 18);
  return result;
}

//----- (10007DC0) --------------------------------------------------------
__int16 __usercall sub_10007DC0@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // ebp@1
  _WORD *v6; // ebx@1
  int v7; // eax@1
  double v8; // st7@4
  char v10; // [sp+10h] [bp-4h]@1

  v4 = a1;
  v5 = *(_DWORD *)a4;
  *(float *)(a3 + 292) = 0.0;
  v6 = a2;
  *(float *)(a3 + 296) = 0.0;
  *(float *)(a3 + 300) = 0.0;
  *(float *)(a3 + 304) = 0.0;
  sub_10007D80(a2, (int)a2, a1, (int)&v10, 0);
  ((void (__cdecl *)(int, _DWORD, char *, _DWORD, void *))dword_10779FC0[2 * (**((_DWORD **)v6 + 2) & 0xFF)])(
    a3,
    *((_DWORD *)v6 + 2),
    &v10,
    *(_DWORD *)(a4 + 8),
    &unk_100630DC);
  *(float *)(v5 + 44) = *(float *)(a3 + 304) - *(float *)(a3 + 296) + 1.0;
  *(float *)(v5 + 52) = *(float *)(a3 + 292);
  *(float *)(v5 + 56) = (double)*(_WORD *)(v4 + 2) + *(float *)(a3 + 296);
  *(float *)(v5 + 60) = *(float *)(a3 + 300);
  v7 = v6[8];
  *(float *)(v5 + 64) = (double)(v7 * v6[9]) + *(float *)(v5 + 56);
  if ( *((_BYTE *)v6 + 4) & 3 )
  {
    *(_DWORD *)(v5 + 12) = 35;
    *(_DWORD *)(v5 + 16) = 1088421888;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(v5 + 24) = 2;
    *(_WORD *)(v5 + 24) = *(_WORD *)v4 + v6[10];
    if ( !v6[10] )
      *(_WORD *)(v5 + 24) = (signed int)*(float *)(v5 + 60) + 3;
    v8 = *(float *)(v5 + 64) - *(float *)(v5 + 56);
    *(_WORD *)(v5 + 26) = (signed int)*(float *)(v5 + 56);
    *(float *)(v5 + 20) = v8;
    LOWORD(v7) = v6[8];
    *(_WORD *)(v5 + 30) = v7;
  }
  return v7;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (10007EF0) --------------------------------------------------------
char __usercall sub_10007EF0@<al>(__int16 a1@<ax>, int a2@<esi>, int a3, void *a4)
{
  int v4; // ecx@1
  int (__cdecl *v5)(int, void *, __int16); // edx@3
  char result; // al@4

  v4 = *(_DWORD *)a2;
  if ( a1 < 0 || a1 >= (signed int)*(_WORD *)(a2 + 4) )
  {
    result = 0;
  }
  else
  {
    v5 = *(int (__cdecl **)(int, void *, __int16))(v4 + 36);
    if ( v5 )
    {
      result = v5(a3, a4, a1);
    }
    else
    {
      memcpy_0(a4, (const void *)(*(_DWORD *)(v4 + 8) + a1 * *(_WORD *)(v4 + 40)), *(_WORD *)(v4 + 40));
      result = 1;
    }
  }
  return result;
}

//----- (10007F50) --------------------------------------------------------
int __cdecl sub_10007F50(int a1, int a2, int a3, int **a4, int a5)
{
  int v5; // ebp@1
  int *v6; // esi@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // edx@1
  void *v10; // eax@1
  _WORD *v11; // ecx@1
  __int16 v12; // ST10_2@1
  signed __int16 v13; // cx@2
  __int16 v14; // di@4
  char v15; // al@5
  __int16 v16; // cx@10
  int i; // edi@16
  int v18; // ecx@18
  signed __int16 v20; // [sp+10h] [bp-2Ch]@4
  signed __int16 v21; // [sp+14h] [bp-28h]@4
  int v22; // [sp+18h] [bp-24h]@1
  int v23; // [sp+1Ch] [bp-20h]@1
  char v24; // [sp+20h] [bp-1Ch]@1
  void (__cdecl *v25)(int, _DWORD, char *, _DWORD, __int16 *); // [sp+24h] [bp-18h]@1
  void *v26; // [sp+28h] [bp-14h]@1
  int v27; // [sp+2Ch] [bp-10h]@1
  __int16 v28; // [sp+30h] [bp-Ch]@1
  int v29; // [sp+34h] [bp-8h]@1
  char v30; // [sp+38h] [bp-4h]@11
  char v31; // [sp+4Ch] [bp+10h]@1

  v5 = (int)a4;
  v6 = *a4;
  v7 = **a4;
  v8 = (*a4)[1];
  v25 = (void (__cdecl *)(int, _DWORD, char *, _DWORD, __int16 *))dword_10779FC0[2 * (**(_DWORD **)(a3 + 8) & 0xFF)];
  v9 = *(_BYTE *)(a3 + 5);
  v22 = v7;
  v27 = v8;
  v10 = (void *)sub_10003950(a1, v9);
  v29 = 0;
  v28 = -32650;
  v11 = (_WORD *)*((_WORD *)v6 + 24);
  v12 = *((_WORD *)v6 + 24);
  v26 = v10;
  sub_10007D80(v11, a3, a5, (int)&v24, v12);
  v23 = 0;
  v31 = 0;
  if ( a2 >= 0 )
    v13 = 1;
  else
    v13 = -1;
  v14 = *(_WORD *)(v5 + 12);
  v20 = v13;
  v21 = v13;
  while ( a2 )
  {
    v15 = sub_10007EF0(v14 + v20, v5, a1, v26);
    if ( !v15 )
      break;
    if ( v15 == 1 )
    {
      a2 -= v21;
      ++v23;
      v14 += v20;
      v20 = v21;
    }
    else
    {
      v20 += v21;
    }
  }
  v16 = *(_WORD *)(v5 + 14);
  if ( v14 >= v16 )
  {
    if ( v14 < v16 + *(_WORD *)(a3 + 16) )
      goto LABEL_15;
    *(_WORD *)(v5 + 14) = v14 - *(_WORD *)(a3 + 16) + 1;
    v30 = -1;
    LOBYTE(a2) = 0;
  }
  else
  {
    *(_WORD *)(v5 + 14) = v14;
    v30 = 0;
    LOBYTE(a2) = -1;
  }
  v31 = 1;
LABEL_15:
  *(_WORD *)(v5 + 12) = v14;
  if ( v31 )
  {
    for ( i = *(_WORD *)(a3 + 16) - 1; i >= 0; --i )
    {
      *(_BYTE *)(i + v27) = sub_10007EF0(i + *(_WORD *)(v5 + 14), v5, a1, *(void **)(v22 + 4 * i));
      v25(a1, *(_DWORD *)(a3 + 8), &v24, *(_DWORD *)(v22 + 4 * i), &v28);
    }
    v18 = *(_WORD *)(v5 + 12);
    v30 = a2;
    v25(a1, *(_DWORD *)(a3 + 8), &v24, *(_DWORD *)(v22 + 4 * (v18 - *(_WORD *)(v5 + 14))), &v28);
  }
  sub_100035B0(a1, (unsigned int)v26);
  return v23;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (10008150) --------------------------------------------------------
BOOL __cdecl sub_10008150(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1

  v2 = *(_BYTE *)(v1 + 4) & 3;
  return v2 == 2 || v2 == 1 && *(_WORD *)(v1 + 16) < *(_WORD *)(a1 + 4);
}

//----- (10008180) --------------------------------------------------------
char __usercall sub_10008180@<al>(int a1@<edx>, int **a2@<ecx>, int a3, int a4, _WORD *a5, char a6)
{
  int *v6; // ebp@1
  int v7; // ecx@1
  char v8; // dl@1
  int v9; // edx@1
  __int16 v10; // ax@1
  int v11; // edi@2
  int v12; // eax@5
  int v13; // ecx@11
  __int16 v14; // si@12
  float v15; // ST10_4@12
  signed int v16; // eax@12
  float v17; // ST2C_4@12
  float v18; // ST10_4@12
  float v19; // ST2C_4@12
  float v20; // ST2C_4@12
  int v21; // edx@17
  int v22; // ecx@18
  int v23; // eax@18
  float v24; // ST10_4@20
  float v25; // ST0C_4@20
  float v26; // ST10_4@20
  float v27; // ST24_4@20
  float v28; // ST24_4@20
  float v29; // ST10_4@20
  float v30; // ST24_4@20
  float v31; // ST24_4@20
  float v32; // ST0C_4@20
  int v34; // [sp+18h] [bp-3Ch]@1
  bool v35; // [sp+1Fh] [bp-35h]@10
  char v36; // [sp+26h] [bp-2Eh]@1
  char v37; // [sp+27h] [bp-2Dh]@1
  char v38; // [sp+28h] [bp-2Ch]@1
  __int16 v39; // [sp+2Ah] [bp-2Ah]@2
  float v40; // [sp+2Ch] [bp-28h]@12
  int v41; // [sp+30h] [bp-24h]@1
  double v42; // [sp+34h] [bp-20h]@12
  int v43; // [sp+3Ch] [bp-18h]@2
  int v44; // [sp+40h] [bp-14h]@1
  _WORD *v45; // [sp+44h] [bp-10h]@1
  int (__cdecl *v46)(int, _DWORD, char *, _DWORD, int); // [sp+48h] [bp-Ch]@1
  int v47; // [sp+4Ch] [bp-8h]@1
  __int16 v48; // [sp+50h] [bp-4h]@1

  v6 = *a2;
  v34 = (int)a2;
  v7 = **a2;
  v44 = a1;
  v8 = *(_BYTE *)(a3 + 3);
  v47 = v7;
  v36 = v8;
  v9 = **(_DWORD **)(a4 + 8);
  LOBYTE(v7) = *(_BYTE *)(a4 + 4);
  v41 = a3;
  v37 = *(_BYTE *)(a3 + 9);
  v46 = (int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_10779FC0[2 * (unsigned __int8)v9];
  v45 = (_WORD *)(v7 & 0x18);
  sub_10007D80(v45, a4, (int)a5, (int)&v38, 0);
  v10 = *a5 + (signed int)*((float *)v6 + 13);
  v48 = *a5 + (signed int)*((float *)v6 + 13);
  if ( a6 )
  {
    v11 = *((_WORD *)v6 + 24);
    v39 += v11 * *(_WORD *)(a4 + 18);
    v43 = v11;
  }
  else
  {
    v11 = 0;
    v10 = *(_WORD *)(a4 + 16) - 1;
    v43 = *(_WORD *)(a4 + 16) - 1;
  }
  while ( v11 <= v43 )
  {
    v12 = v41;
    if ( v11 == *((_WORD *)v6 + 24) )
    {
      *(_BYTE *)(v41 + 3) = v36;
      *(_BYTE *)(v12 + 9) = v37;
    }
    else
    {
      *(_BYTE *)(v41 + 3) = 0;
      *(_BYTE *)(v12 + 9) = 0;
    }
    if ( v45 == (_WORD *)8 )
    {
      v13 = v6[1];
      v35 = *(_BYTE *)(v11 + v13) != 0;
      LOBYTE(v10) = *(_BYTE *)(v11 + v13) == 0;
      if ( *(_BYTE *)(v11 + v13) )
        goto LABEL_13;
    }
    else
    {
      if ( v45 != (_WORD *)16 )
        goto LABEL_14;
      v35 = *(_BYTE *)(v11 + v6[1]) != 0;
    }
    v14 = (signed int)*((float *)v6 + 14) + v11 * *(_WORD *)(a4 + 18);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a4 + 24));
    *(float *)&v42 = (double)v14;
    v40 = (double)v48;
    sub_10038180(v40, *(float *)&v42);
    v15 = *(float *)&v42;
    *(float *)&v42 = (double)*((_WORD *)v6 + 12) - 2.0;
    sub_10038180(*(float *)&v42, v15);
    v16 = *((_WORD *)v6 + 12);
    v42 = (double)v14;
    v17 = v42 + *((float *)v6 + 11);
    v18 = v17;
    v19 = (double)v16 - 2.0;
    sub_10038180(v19, v18);
    v20 = *((float *)v6 + 11) + v42;
    sub_10038180(v40, v20);
    LOBYTE(v10) = j_gdi_pvg_end();
LABEL_13:
    if ( v35 )
LABEL_14:
      LOBYTE(v10) = v46(v41, *(_DWORD *)(a4 + 8), &v38, *(_DWORD *)(v47 + 4 * v11), v44);
    v39 += *(_WORD *)(a4 + 18);
    ++v11;
  }
  if ( a6 || (LOBYTE(v10) = sub_10008150(v34), !(_BYTE)v10) )
  {
    if ( (*(_BYTE *)(a4 + 4) & 3) == 1 )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a4 + 24));
      v24 = (double)*((_WORD *)v6 + 13);
      v25 = (double)*((_WORD *)v6 + 12);
      sub_10038180(v25, v24);
      v26 = (double)*((_WORD *)v6 + 13);
      v27 = (double)*((_WORD *)v6 + 12) + 7.0;
      sub_10038180(v27, v26);
      v28 = *((float *)v6 + 5) + (double)*((_WORD *)v6 + 13);
      v29 = v28;
      v30 = (double)*((_WORD *)v6 + 12) + 7.0;
      sub_10038180(v30, v29);
      v31 = *((float *)v6 + 5) + (double)*((_WORD *)v6 + 13);
      v32 = (double)*((_WORD *)v6 + 12);
      sub_10038180(v32, v31);
      LOBYTE(v10) = j_gdi_pvg_end();
    }
  }
  else
  {
    *((_WORD *)v6 + 14) = *(_WORD *)(v21 + 4);
    v22 = v41;
    v23 = v44;
    *((_WORD *)v6 + 16) = *(_WORD *)(v21 + 14);
    LOBYTE(v10) = sub_1000E470(v22, v23, (char *)v6 + 12, (int)(v6 + 7));
  }
  return v10;
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (100084F0) --------------------------------------------------------
char __usercall sub_100084F0@<al>(_WORD *a1@<eax>, int a2@<ecx>, int a3, int **a4, int a5)
{
  int v5; // ebx@1
  _WORD *v6; // edi@1
  int *v7; // ebp@1
  int v8; // eax@1
  int v9; // eax@1
  __int16 v10; // ST08_2@1
  _WORD *v11; // ecx@1
  signed int v12; // eax@3
  int **v13; // esi@6
  char v14; // al@6
  char v15; // al@10
  __int16 v16; // dx@13
  char v18; // [sp+13h] [bp-15h]@1
  int v19; // [sp+14h] [bp-14h]@1
  char v20; // [sp+18h] [bp-10h]@1
  int (__cdecl *v21)(int, _DWORD, char *, _DWORD, int); // [sp+1Ch] [bp-Ch]@1
  int v22; // [sp+20h] [bp-8h]@1
  unsigned int v23; // [sp+24h] [bp-4h]@1

  v5 = a2;
  v6 = a1;
  v7 = *a4;
  v8 = *(_BYTE *)(a2 + 5);
  v19 = **a4;
  v21 = (int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_10779FC0[2 * (**(_DWORD **)(a2 + 8) & 0xFF)];
  v18 = 1;
  v22 = v7[1];
  v9 = sub_10003950(a3, v8);
  v10 = *((_WORD *)v7 + 24);
  v23 = v9;
  sub_10007D80(v11, v5, (int)v6, (int)&v20, v10);
  if ( *(_BYTE *)(v5 + 4) & 4
    || (v18 = v21(a3, *(_DWORD *)(v5 + 8), &v20, *(_DWORD *)(v19 + 4 * *((_WORD *)v7 + 24)), a5), v18 == 1) )
  {
    v12 = *(_WORD *)(a5 + 10);
    if ( v12 != 33 && (v12 <= 55 || v12 > 57) )
      goto LABEL_14;
    v13 = a4;
    v14 = sub_10007F50(a3, *(_BYTE *)(a5 + 8), v5, a4, (int)v6);
    *((_WORD *)v7 + 24) = *((_WORD *)v13 + 6) - *((_WORD *)v13 + 7);
    if ( !v14 )
    {
      v18 = 1;
      goto LABEL_14;
    }
    v18 = 2;
  }
  else
  {
    v13 = a4;
  }
  v15 = *(_BYTE *)(*((_WORD *)v7 + 24) + v22);
  if ( v15 != 1 && v15 != 2 )
    sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_xlist.c", 1213, 1, 0);
  v16 = *((_WORD *)v13 + 7);
  v13[2] = *(int **)(v19 + 4 * *((_WORD *)v7 + 24));
  *((_WORD *)v13 + 6) = *((_WORD *)v7 + 24) + v16;
  sub_10008180((int)&unk_100630D4, v13, a3, v5, v6, 0);
LABEL_14:
  sub_100035B0(a3, v23);
  return v18;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (10008660) --------------------------------------------------------
char __cdecl sub_10008660(int a1, int a2, _WORD *a3, int *a4, _WORD *a5)
{
  __int16 v5; // ax@1
  _DWORD *v6; // ebx@3
  int v7; // ebp@3
  int v8; // edi@6
  int v9; // eax@6
  _WORD *v10; // ecx@8
  int v11; // eax@8
  void (__cdecl *v12)(int, _DWORD, char *, _DWORD, __int16 *); // edi@8
  signed int v13; // esi@9
  int v15; // ecx@12
  int v16; // ebx@12
  int v17; // eax@12
  __int16 v18; // ax@13
  int v19; // edi@13
  char v20; // al@14
  int v21; // edi@15
  int v22; // ebp@15
  int v23; // edi@19
  int j; // ebp@19
  char v25; // al@20
  int k; // edi@23
  char v27; // al@24
  __int16 v28; // ax@29
  __int16 v29; // ax@32
  __int16 v30; // di@32
  signed int v31; // edi@37
  char v32; // [sp+Eh] [bp-1Eh]@1
  char i; // [sp+Fh] [bp-1Dh]@13
  int v34; // [sp+10h] [bp-1Ch]@0
  int v35; // [sp+14h] [bp-18h]@0
  int v36; // [sp+14h] [bp-18h]@6
  void *v37; // [sp+18h] [bp-14h]@19
  char v38; // [sp+1Ch] [bp-10h]@8
  __int16 v39; // [sp+20h] [bp-Ch]@1
  int v40; // [sp+24h] [bp-8h]@1
  char v41; // [sp+28h] [bp-4h]@1
  signed int v42; // [sp+40h] [bp+14h]@6

  v5 = *a5;
  v32 = 1;
  v40 = 0;
  v39 = -32650;
  v41 = 0;
  if ( v5 == -32671 || v5 == -32703 )
  {
    v6 = a5;
    v7 = v35;
  }
  else
  {
    v6 = (_DWORD *)*a4;
    v7 = *(_DWORD *)*a4;
    v35 = *(_DWORD *)*a4;
    v34 = *(_DWORD *)(*a4 + 4);
  }
  switch ( v5 )
  {
    case 0x8041:
      v8 = sub_10003950(a1, 68);
      *a4 = v8;
      v9 = sub_10003950(a1, 4 * *(_WORD *)(a2 + 16));
      *(_DWORD *)v8 = v9;
      v36 = v9;
      *(_DWORD *)(v8 + 4) = sub_10003950(a1, *(_WORD *)(a2 + 16));
      v42 = 0;
      if ( *(_WORD *)(a2 + 16) )
      {
        do
          *(_DWORD *)(v36 + 4 * v42++) = sub_10003950(a1, *(_BYTE *)(a2 + 5));
        while ( v42 < *(_WORD *)(a2 + 16) );
      }
      *(_DWORD *)(v8 + 36) = *(_DWORD *)(a2 + 12);
      *(_WORD *)(v8 + 40) = *(_BYTE *)(a2 + 5);
      *(_DWORD *)(v8 + 8) = a4[2] - *(_BYTE *)(a2 + 5) * *((_WORD *)a4 + 6);
      sub_10007DC0((int)a3, (_WORD *)a2, a1, (int)a4);
      sub_10007D80(v10, a2, (int)a3, (int)&v38, 0);
      v11 = **(_DWORD **)(a2 + 8) & 0xFF;
      v12 = (void (__cdecl *)(int, _DWORD, char *, _DWORD, __int16 *))dword_10779FC0[2 * v11];
      if ( v11 != 46 )
        goto LABEL_42;
      v13 = 0;
      if ( !*(_WORD *)(a2 + 16) )
        goto LABEL_42;
      do
        v12(a1, *(_DWORD *)(a2 + 8), &v38, *(_DWORD *)(v36 + 4 * v13++), &v39);
      while ( v13 < *(_WORD *)(a2 + 16) );
      return 2;
    case 0x8040:
      v15 = v6[13];
      v16 = (int)(v6 + 13);
      v17 = a1 + 292;
      *(_DWORD *)v17 = v15;
      *(_DWORD *)(v17 + 4) = *(_DWORD *)(v16 + 4);
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(v16 + 8);
      *(_DWORD *)(v17 + 12) = *(_DWORD *)(v16 + 12);
      return 2;
    case 0x8022:
      v18 = *((_WORD *)a4 + 6) - *((_WORD *)a4 + 7);
      *((_WORD *)v6 + 24) = v18;
      *(_BYTE *)(*((_WORD *)v6 + 24) + v34) = sub_10007EF0(*((_WORD *)a4 + 6), (int)a4, a1, *(void **)(v7 + 4 * v18));
      a4[2] = *(_DWORD *)(v7 + 4 * *((_WORD *)v6 + 24));
      v19 = *((_WORD *)v6 + 24) - 1;
      for ( i = 0; v19 >= 0; --v19 )
      {
        v20 = sub_10007EF0(v19 + *((_WORD *)a4 + 7), (int)a4, a1, *(void **)(v7 + 4 * v19));
        *(_BYTE *)(v19 + v34) = v20;
        if ( !v20 )
        {
          v21 = v19 + 1;
          v22 = 0;
          for ( i = 1; v22 <= *((_WORD *)v6 + 24) - v21; ++v22 )
            *(_BYTE *)(v34 + v22) = sub_10007EF0(v21 + v22 + *((_WORD *)a4 + 7), (int)a4, a1, *(void **)(v35 + 4 * v22));
          *((_WORD *)a4 + 7) += v21;
          *((_WORD *)v6 + 24) -= v21;
          v7 = v35;
          v19 = 0;
        }
      }
      v23 = a2;
      v37 = (void *)sub_10003950(a1, *(_BYTE *)(a2 + 5));
      for ( j = *((_WORD *)v6 + 24) + 1; j < *(_WORD *)(a2 + 16); ++j )
      {
        v25 = sub_10007EF0(j + *((_WORD *)a4 + 7), (int)a4, a1, *(void **)(v35 + 4 * j));
        *(_BYTE *)(v34 + j) = v25;
        if ( !v25 && !i )
        {
          if ( sub_10007EF0(*((_WORD *)a4 + 7) - 1, (int)a4, a1, v37) )
          {
            --*((_WORD *)a4 + 7);
            ++*((_WORD *)v6 + 24);
            for ( k = j; k >= 0; *(_BYTE *)(k + v34 + 1) = v27 )
            {
              v27 = sub_10007EF0(k + *((_WORD *)a4 + 7), (int)a4, a1, *(void **)(v35 + 4 * k));
              --k;
            }
          }
          else
          {
            i = 1;
          }
        }
        v23 = a2;
      }
      sub_100035B0(a1, (unsigned int)v37);
      sub_10008180((int)a5, (int **)a4, a1, v23, a3, 0);
      return 1;
    case 0x8078:
      v28 = *((_WORD *)a4 + 6);
      if ( *((_WORD *)a4 + 7) > v28 && v28 >= 0 )
        sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_xlist.c", 615, 1, 0);
      v29 = *((_WORD *)a4 + 6);
      v30 = *((_WORD *)a4 + 2);
      if ( *((_WORD *)a4 + 6) < (signed int)*((_WORD *)a4 + 2) )
      {
        if ( v29 == -1 && v30 )
          *((_WORD *)a4 + 6) = 0;
      }
      else
      {
        *((_WORD *)a4 + 7) += v30 - v29 - 1;
        *((_WORD *)a4 + 7) &= ((signed int)*((_WORD *)a4 + 7) < 0) - 1;
        *((_WORD *)a4 + 6) = v30 - 1;
      }
      v31 = 0;
      *((_WORD *)v6 + 24) = *((_WORD *)a4 + 6) - *((_WORD *)a4 + 7);
      if ( *(_WORD *)(a2 + 16) )
      {
        do
        {
          *(_BYTE *)(v31 + v34) = sub_10007EF0(v31 + *((_WORD *)a4 + 7), (int)a4, a1, *(void **)(v7 + 4 * v31));
          ++v31;
        }
        while ( v31 < *(_WORD *)(a2 + 16) );
      }
      sub_10008180((int)a5, (int **)a4, a1, a2, a3, 0);
      goto LABEL_42;
    case 0x8048:
      return sub_100084F0(a3, a2, a1, (int **)a4, (int)a5);
    case 0x8049:
    case 0x8067:
      sub_10008180((int)&unk_100630D4, (int **)a4, a1, a2, a3, 1);
LABEL_42:
      v32 = 2;
      break;
    default:
      return v32;
  }
  return v32;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (10008B90) --------------------------------------------------------
char __usercall sub_10008B90@<al>(int a1@<eax>, char *a2@<ecx>)
{
  char *v2; // esi@1
  char v3; // bl@1
  char *v5; // [sp+8h] [bp-8h]@1
  char v6; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v3 = *a2;
  if ( sub_1000E3C0(*(char **)(a1 + 4), (int *)&v6, &v5) )
  {
    do
    {
      if ( *v2 > v3 )
        v3 = *v2;
      ++v2;
    }
    while ( sub_1000E3C0(v5, (int *)&v6, &v5) );
  }
  return v3;
}

//----- (10008BF0) --------------------------------------------------------
char __cdecl sub_10008BF0(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  int v7; // eax@7
  char *v8; // ecx@7
  char v9; // bl@7
  char v10; // al@9
  char v11; // al@12
  char *v12; // edi@15
  _DWORD *v13; // ebx@16
  int v14; // eax@17
  char *v15; // edi@29
  char v16; // dl@29
  char *v17; // ST08_4@29
  bool v18; // zf@31
  float v19; // ecx@32
  __int16 v20; // dx@35
  bool v21; // al@37
  bool v22; // al@41
  int v23; // eax@43
  int v24; // ecx@44
  _BYTE *v25; // eax@44
  int v26; // eax@46
  float v27; // eax@52
  signed int v28; // eax@60
  char v29; // al@63
  char result; // al@66
  char v31; // [sp+13h] [bp-25h]@29
  float v32; // [sp+14h] [bp-24h]@15
  _DWORD *v33; // [sp+14h] [bp-24h]@30
  char *v34; // [sp+18h] [bp-20h]@15
  int v35; // [sp+1Ch] [bp-1Ch]@15
  __int16 v36; // [sp+20h] [bp-18h]@35
  __int16 v37; // [sp+22h] [bp-16h]@35
  int v38; // [sp+24h] [bp-14h]@15
  float v39; // [sp+28h] [bp-10h]@15
  char *v40; // [sp+2Ch] [bp-Ch]@7
  float v41; // [sp+30h] [bp-8h]@17
  int v42; // [sp+34h] [bp-4h]@7
  float v43; // [sp+48h] [bp+10h]@15
  char v44; // [sp+48h] [bp+10h]@29

  v5 = (char *)a4;
  v6 = a5;
  if ( *(_WORD *)a5 != -32650 || **(_WORD **)(a1 + 52) != -32703 )
  {
    if ( !*(_DWORD *)(a4 + 8) )
      sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_tmplt.c", 138, 1, 0);
    if ( !*(_DWORD *)(a4 + 4) )
      sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_tmplt.c", 139, 1, 0);
  }
  v7 = *(_WORD *)a5 - 32832;
  v42 = *(_DWORD *)(a4 + 8);
  v8 = *(char **)(a4 + 4);
  v40 = *(char **)(a4 + 4);
  v9 = 1;
  if ( v7 )
  {
    if ( v7 == 54 )
    {
      v10 = *(_BYTE *)(a5 + 8);
      if ( v10 )
      {
        if ( v10 == -1 )
        {
          v11 = sub_10008B90(a2, v8);
          *(_BYTE *)a4 = v11 < 0 ? 0 : v11;
        }
        else
        {
          *(_BYTE *)a4 = v10;
          if ( *(_BYTE *)a4 > sub_10008B90(a2, v8) )
            sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_tmplt.c", 227, 1, 0);
        }
      }
      else
      {
        *(_BYTE *)a4 = 0;
      }
    }
  }
  else
  {
    v12 = *(char **)(a2 + 4);
    v43 = 9.9999996e24;
    v32 = -1.0;
    v39 = -1.0;
    *(float *)&v38 = 9.9999996e24;
    if ( sub_1000E3C0(v12, &v35, &v34) )
    {
      v13 = v5 + 12;
      do
      {
        v14 = v35;
        LODWORD(v41) = *(_WORD *)v35;
        *(float *)(a1 + 292) = (double)SLODWORD(v41);
        LODWORD(v41) = *(_WORD *)(v14 + 2);
        *(float *)(a1 + 296) = (double)SLODWORD(v41);
        LODWORD(v41) = *(_WORD *)v14;
        *(float *)(a1 + 300) = (double)SLODWORD(v41);
        LODWORD(v41) = *(_WORD *)(v14 + 2);
        *(float *)(a1 + 304) = (double)SLODWORD(v41);
        ((void (__cdecl *)(int, char *, int, _DWORD, int))dword_10779FC0[2 * (*(_DWORD *)v12 & 0xFF)])(
          a1,
          v12,
          v14,
          *v13,
          a5);
        v41 = *(float *)(a1 + 292);
        if ( v41 <= (double)v43 )
          v43 = v41;
        v41 = *(float *)(a1 + 300);
        if ( v41 >= (double)v32 )
          v32 = v41;
        v41 = *(float *)(a1 + 296);
        if ( v41 <= (double)*(float *)&v38 )
          *(float *)&v38 = v41;
        v41 = *(float *)(a1 + 304);
        if ( v41 >= (double)v39 )
          v39 = v41;
        v12 = v34;
        ++v13;
      }
      while ( sub_1000E3C0(v34, &v35, &v34) );
    }
    v6 = a5;
    *(float *)(a1 + 292) = v43;
    v9 = 2;
    *(float *)(a1 + 296) = *(float *)&v38;
    *(float *)(a1 + 300) = v32;
    *(float *)(a1 + 304) = v39;
  }
  if ( *(_WORD *)v6 != -32704 && *(_WORD *)v6 != -32650 )
  {
    v15 = *(char **)(a2 + 4);
    v16 = *(_BYTE *)(a1 + 9);
    v44 = *(_BYTE *)(a1 + 3);
    v17 = *(char **)(a2 + 4);
    *(float *)&v38 = 0.0;
    v31 = v16;
    if ( sub_1000E3C0(v17, &v35, &v34) )
    {
      v33 = v5 + 12;
      while ( 1 )
      {
        v18 = *(_WORD *)a5 == -32696;
        v39 = 0.0;
        if ( !v18 )
          break;
        v19 = *(float *)&v38;
        if ( *(_BYTE *)(*v5 + v42) == v38 )
          goto LABEL_35;
LABEL_54:
        ++v33;
        v15 = v34;
        v38 = LODWORD(v19) + 1;
        if ( LODWORD(v19) + 1 >= 0x7FFF )
          sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_tmplt.c", 353, 1, 0);
        if ( !sub_1000E3C0(v15, &v35, &v34) )
          goto LABEL_57;
      }
      v19 = *(float *)&v38;
LABEL_35:
      v20 = *(_WORD *)v35 + *(_WORD *)a3;
      v36 = *(_WORD *)v35 + *(_WORD *)a3;
      v37 = *(_WORD *)(a3 + 2) + *(_WORD *)(v35 + 2);
      v21 = v44 && v40[LODWORD(v19)] == *v5;
      *(_BYTE *)(a1 + 3) = v21;
      v22 = v31 && v40[LODWORD(v19)] == *v5;
      *(_BYTE *)(a1 + 9) = v22;
      v23 = *(_DWORD *)v15 & 0xFF;
      if ( v23 == 18 )
      {
        v24 = *v33;
        v25 = *(_BYTE **)(*v33 + 8);
        if ( !v25 )
        {
LABEL_53:
          v9 = ((int (__cdecl *)(int, char *, __int16 *, _DWORD, int))dword_10779FC0[2 * (*(_DWORD *)v15 & 0xFF)])(
                 a1,
                 v15,
                 &v36,
                 *v33,
                 a5);
          *(_BYTE *)(a1 + 9) = v31;
          v19 = *(float *)&v38;
          *(_BYTE *)(a1 + 3) = v44;
          goto LABEL_54;
        }
        if ( *v25 != -126 )
        {
          if ( !v25 || *v25 != 37 )
            goto LABEL_53;
          v39 = *(float *)(v24 + 12);
          goto LABEL_52;
        }
        v26 = *(_DWORD *)(v24 + 12);
      }
      else
      {
        if ( v23 != 130 )
        {
          if ( v23 != 37 )
            goto LABEL_53;
          v39 = *(float *)v33;
          goto LABEL_52;
        }
        v26 = *v33;
      }
      if ( v26 )
      {
        *(float *)(v26 + 36) = (double)v20;
        LODWORD(v41) = v37;
        *(float *)(v26 + 40) = (double)v37;
        goto LABEL_53;
      }
LABEL_52:
      v27 = v39;
      *(float *)(LODWORD(v39) + 12) = (double)v20;
      LODWORD(v41) = v37;
      *(float *)(LODWORD(v27) + 16) = (double)v37;
      goto LABEL_53;
    }
LABEL_57:
    v6 = a5;
  }
  if ( *(_WORD *)v6 != -32696 || v9 != 1 || (v28 = *(_WORD *)(v6 + 10), v28 != 33) && (v28 <= 55 || v28 > 57) )
  {
    result = v9;
  }
  else
  {
    *v5 += *(_BYTE *)(v6 + 8);
    v29 = sub_10008B90(a2, v40);
    if ( *v5 < 0 )
      goto LABEL_72;
    if ( *v5 > v29 )
    {
      if ( v29 >= 0 )
      {
        *v5 = v29;
        return 1;
      }
      goto LABEL_72;
    }
    if ( v29 < 0 )
    {
LABEL_72:
      *v5 = 0;
      return 1;
    }
    result = 2;
  }
  return result;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (100090F0) --------------------------------------------------------
int sub_100090F0()
{
  sub_10037E20(1.0, 1.0, 1.0, 1.0);
  j_gdi_pvg_bind_texture(34, dword_104F96A8);
  j_gdi_pvg_begin(72);
  sub_10038080(0.0, 0.0);
  sub_100381A0(-1.0, 0.89999998, 0.0);
  sub_10038080(1.0, 0.0);
  sub_100381A0(1.0, 0.89999998, 0.0);
  sub_10038080(1.0, 1.0);
  sub_100381A0(1.0, -1.1, 0.0);
  sub_10038080(0.0, 1.0);
  sub_100381A0(-1.0, -1.1, 0.0);
  return j_gdi_pvg_end();
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);
// 104F96A8: using guessed type int dword_104F96A8;

//----- (100091E0) --------------------------------------------------------
int sub_100091E0()
{
  j_gdi_pvg_push_matrix();
  sub_10038040(0.050000001, 0.050000001, 0.050000001);
  j_gdi_pvg_bind_texture(34, dword_104F96A0);
  sub_10037E20(1.0, 1.0, 1.0, 1.0);
  j_gdi_pvg_begin(68);
  sub_10038080(1.0, 1.0);
  sub_100381A0(1.0, 1.0, 0.0);
  sub_10038080(0.0, 1.0);
  sub_100381A0(-1.0, 1.0, 0.0);
  sub_10038080(0.0, 0.0);
  sub_100381A0(-1.0, -1.0, 0.0);
  sub_10038080(1.0, 1.0);
  sub_100381A0(1.0, 1.0, 0.0);
  sub_10038080(1.0, 0.0);
  sub_100381A0(1.0, -1.0, 0.0);
  sub_10038080(0.0, 0.0);
  sub_100381A0(-1.0, -1.0, 0.0);
  j_gdi_pvg_end();
  return j_gdi_pvg_pop_matrix();
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);
// 10037FF0: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10038000: using guessed type int j_gdi_pvg_push_matrix(void);
// 104F96A0: using guessed type int dword_104F96A0;

//----- (10009330) --------------------------------------------------------
int sub_10009330()
{
  void *v0; // esi@1
  signed int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@2
  int v4; // eax@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // eax@2
  int result; // eax@2

  v0 = &unk_104F96B8;
  v1 = 8;
  do
  {
    v2 = rand();
    *((float *)v0 - 2) = (double)v2 / 32767.0 + (double)v2 / 32767.0 - 1.0;
    v3 = rand();
    *((float *)v0 - 1) = (double)v3 / 32767.0 + (double)v3 / 32767.0 - 1.0;
    v4 = rand();
    *(float *)v0 = (double)v4 / 32767.0 + (double)v4 / 32767.0 - 1.0;
    v5 = rand();
    *((float *)v0 + 1) = (double)v5 / 32767.0 + (double)v5 / 32767.0 - 1.0;
    v6 = rand();
    *((float *)v0 + 2) = (double)v6 / 32767.0 + (double)v6 / 32767.0 - 1.0;
    v7 = rand();
    *((float *)v0 + 3) = (double)v7 / 32767.0 + (double)v7 / 32767.0 - 1.0;
    *((float *)v0 + 4) = (double)rand() / 32767.0 * 0.1000000238418579 + 1.0;
    *((float *)v0 + 5) = (double)rand() / 32767.0 * 5.0 + 7.0;
    result = rand();
    v0 = (char *)v0 + 36;
    --v1;
    *((float *)v0 - 3) = (double)result / 32767.0 * 360.0;
  }
  while ( v1 );
  return result;
}

//----- (10009470) --------------------------------------------------------
int sub_10009470()
{
  void *v0; // esi@1
  float v1; // ST28_4@4
  float v2; // ST28_4@4
  float v3; // ST10_4@4
  float v4; // ST28_4@6
  float v5; // ST28_4@10
  float v6; // ST0C_4@10
  float v8; // [sp+1Ch] [bp-2Ch]@2
  float v9; // [sp+1Ch] [bp-2Ch]@4
  signed int v10; // [sp+1Ch] [bp-2Ch]@6
  signed int v11; // [sp+20h] [bp-28h]@1
  int v12; // [sp+24h] [bp-24h]@4
  float v13; // [sp+28h] [bp-20h]@10
  float v14; // [sp+2Ch] [bp-1Ch]@10
  int v15; // [sp+30h] [bp-18h]@4
  float v16; // [sp+34h] [bp-14h]@10
  float v17; // [sp+38h] [bp-10h]@10
  int v18; // [sp+3Ch] [bp-Ch]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v0 = &unk_104F96BC;
  v11 = 8;
  do
  {
    v8 = sub_1003AFC0((int)v0);
    if ( v8 <= 0.001 )
      sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_grm_earth.c", 476, 1, 0);
    v1 = 1.0 / v8;
    sub_1003B000(v1, (int)v0, (int)&v12);
    v2 = sub_1003AF90((int)&v12, (int)v0 - 12);
    v3 = -v2;
    sub_1003B000(v3, (int)&v12, (int)&v18);
    sub_1003AF60((int)v0 - 12, (int)&v18, (int)&v15);
    v9 = sub_1003AFC0((int)&v15);
    if ( v9 <= 0.001 )
      sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_grm_earth.c", 491, 1, 0);
    v4 = *((float *)v0 + 3) / v9;
    sub_1003B000(v4, (int)&v15, (int)&v15);
    v10 = 1;
    if ( sub_1003AF90((int)&v12, (int)&v15) >= 0.001 )
      v10 = 0;
    if ( fabs((double)v10) == 0.0 )
      sub_1000D9C0("..\\lib\\adl\\cdp_fld_3d_grm_earth.c", 498, 1, 0);
    v5 = *((float *)v0 + 4) * flt_104F96A4;
    j_gdi_pvg_push_matrix();
    sub_10038010(v5, *(float *)&v12, v13, v14);
    sub_10038140(*(float *)&v15, v16, v17);
    v6 = -v5;
    sub_10038010(v6, *(float *)&v12, v13, v14);
    sub_10038010(*((float *)v0 + 5), 0.0, 0.0, 1.0);
    sub_100091E0();
    j_gdi_pvg_pop_matrix();
    v0 = (char *)v0 + 36;
    --v11;
  }
  while ( v11 );
  return j_gdi_pvg_disable(35);
}
// 10037E00: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037FF0: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10038000: using guessed type int j_gdi_pvg_push_matrix(void);
// 104F96A4: using guessed type float flt_104F96A4;

//----- (100096A0) --------------------------------------------------------
char __cdecl sub_100096A0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@4
  float v6; // ST40_4@6
  float v7; // ST3C_4@6

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32833 )
    {
      flt_104F96A4 = 0.0;
      sub_10009330();
      j_gdi_pvg_gen_textures(1, &dword_104F96A8);
      j_gdi_pvg_bind_texture(34, dword_104F96A8);
      j_gdi_pvg_tex_parameteri(34, 95, 97);
      j_gdi_pvg_tex_parameteri(34, 96, 97);
      j_gdi_pvg_tex_parameteri(34, 93, 86);
      j_gdi_pvg_tex_parameteri(34, 94, 90);
      sub_10039310("garmin_earth.tga_crc");
      j_gdi_pvg_gen_textures(1, &dword_104F96A0);
      j_gdi_pvg_bind_texture(34, dword_104F96A0);
      j_gdi_pvg_tex_parameteri(34, 95, 97);
      j_gdi_pvg_tex_parameteri(34, 96, 97);
      j_gdi_pvg_tex_parameteri(34, 93, 86);
      j_gdi_pvg_tex_parameteri(34, 94, 90);
      sub_10039310("satellite.tga_crc");
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(LODWORD(v6));
  sub_10014F70();
  j_gdi_pvg_matrix_mode(52);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity(LODWORD(v7));
  j_gdi_pvg_clear(256);
  j_gdi_pvg_enable(33);
  j_gdi_pvg_depth_func(20);
  j_gdi_pvg_enable(34);
  j_gdi_pvg_enable(32);
  sub_10037D70(23, 0.0);
  sub_10038140(0.0, 0.0, -2.0);
  sub_100090F0();
  sub_10009470();
  j_gdi_pvg_disable(34);
  j_gdi_pvg_disable(33);
  j_gdi_pvg_disable(32);
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_matrix_mode(52);
  j_gdi_pvg_pop_matrix();
  result = 2;
  flt_104F96A4 = flt_104F96A4 + 0.03333333507180214;
  return result;
}
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037E10: using guessed type int __cdecl j_gdi_pvg_clear(_DWORD);
// 10037E60: using guessed type int __cdecl j_gdi_pvg_depth_func(_DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037F40: using guessed type int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD);
// 10037F70: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10037FA0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10037FF0: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10038000: using guessed type int j_gdi_pvg_push_matrix(void);
// 10038120: using guessed type int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD);
// 104F96A0: using guessed type int dword_104F96A0;
// 104F96A4: using guessed type float flt_104F96A4;
// 104F96A8: using guessed type int dword_104F96A8;

//----- (10009840) --------------------------------------------------------
char __usercall sub_10009840@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5)
{
  char v5; // bl@1
  int v6; // ecx@5
  int v7; // eax@5
  char result; // al@8
  char v9; // [sp+7h] [bp-15h]@1
  int v10; // [sp+8h] [bp-14h]@5
  char v11; // [sp+Ch] [bp-10h]@5
  char v12; // [sp+Dh] [bp-Fh]@5
  __int16 v13; // [sp+Eh] [bp-Eh]@5
  __int16 v14; // [sp+10h] [bp-Ch]@5
  int v15; // [sp+14h] [bp-8h]@6
  int v16; // [sp+18h] [bp-4h]@5

  v9 = byte_10747D9E;
  v5 = *(_BYTE *)(a2 + 3);
  if ( *(_BYTE *)(a2 + 9) || *(_BYTE *)(*(_DWORD *)(a2 + 56) + 237) && v5 )
  {
    *(_BYTE *)(a2 + 3) = 1;
    byte_10747D9E = 1;
  }
  v6 = *(_DWORD *)(a1 + 8);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v7 = 4 * *(_WORD *)(a1 + 2);
  v10 = 18;
  v16 = *(_DWORD *)(v7 + v6);
  if ( (*(_BYTE *)(a3 + 8) & 1) == 1 )
    v15 = *(_DWORD *)(a1 + 4);
  else
    v15 = *(_DWORD *)(v7 + *(_DWORD *)(a1 + 4));
  sub_1000E2A0(a2, (int)&v10, a4, (int)&v11, a5);
  result = v9;
  byte_10747D9E = v9;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}
// 10747D9E: using guessed type char byte_10747D9E;

//----- (100098F0) --------------------------------------------------------
char __cdecl sub_100098F0(unsigned int a1, int a2, int *a3, int a4, int a5)
{
  char v5; // bl@1
  float v6; // eax@3
  float v7; // edx@3
  float v8; // ecx@3
  int v9; // eax@3
  char result; // al@5
  int v11; // eax@6
  __int16 v12; // cx@9
  int v13; // eax@9
  int v14; // eax@9
  __int16 v15; // [sp+8h] [bp-20h]@3
  int v16; // [sp+Ch] [bp-1Ch]@3
  int v17; // [sp+10h] [bp-18h]@3
  int v18; // [sp+14h] [bp-14h]@3
  float v19; // [sp+18h] [bp-10h]@3
  float v20; // [sp+1Ch] [bp-Ch]@3
  float v21; // [sp+20h] [bp-8h]@3
  float v22; // [sp+24h] [bp-4h]@3
  char v23; // [sp+3Ch] [bp+14h]@3

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        goto LABEL_12;
      v16 = 0;
      v15 = -32753;
      v17 = a2;
      v18 = a4;
      sub_10009840(a4, a1, a2, a3, (int)&unk_100630DC);
      v6 = *(float *)(a1 + 300);
      v7 = *(float *)(a1 + 296);
      v19 = *(float *)(a1 + 292);
      v8 = *(float *)(a1 + 304);
      v21 = v6;
      v9 = *(_DWORD *)(a1 + 56);
      v20 = v7;
      v22 = v8;
      v20 = (double)*(_WORD *)(v9 + 30) + v7;
      v22 = (double)*(_WORD *)(v9 + 30) + v8;
      LOBYTE(v7) = *(_BYTE *)(a1 + 3);
      v19 = (double)*(_WORD *)(v9 + 28) + v19;
      v23 = LOBYTE(v7);
      v21 = (double)*(_WORD *)(v9 + 28) + v21;
      *(_BYTE *)(v9 + 237) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      if ( !(*(_BYTE *)(a2 + 8) & 0x40) )
      {
        sub_10009840(a4, a1, a2, a3, (int)&unk_100630D4);
        *(_BYTE *)(a1 + 3) = v23;
      }
      sub_10002890(a1, (int)&v15, 32);
      sub_1000C2D0(a1, 0, (int (__cdecl *)(int))sub_10004890, 0);
      result = 2;
      break;
    case 0x8022:
    case 0x8040:
    case 0x8078:
      v11 = *(_WORD *)a4 - 1;
      if ( *(_WORD *)(a4 + 2) < v11 )
        LOWORD(v11) = *(_WORD *)(a4 + 2);
      *(_WORD *)(a4 + 2) = (signed __int16)v11 <= 0 ? 0 : (unsigned __int16)v11;
      sub_10009840(a4, a1, a2, a3, a5);
      result = 2;
      break;
    case 0x8051:
      v12 = *(_WORD *)(a5 + 10);
      v13 = *(_WORD *)a4;
      *(_WORD *)(a4 + 2) = v12;
      v14 = v13 - 1;
      v5 = 3;
      if ( v12 < v14 )
        LOWORD(v14) = v12;
      *(_WORD *)(a4 + 2) = (signed __int16)v14 <= 0 ? 0 : v14;
      sub_10009840(a4, a1, a2, a3, (int)&unk_100630D4);
      goto LABEL_12;
    default:
LABEL_12:
      result = v5;
      break;
  }
  return result;
}

//----- (10009B40) --------------------------------------------------------
char __cdecl sub_10009B40(int a1, int a2, int a3, int *a4, _WORD *a5)
{
  signed int v6; // ecx@5
  char v7; // [sp+0h] [bp-1Ch]@5
  float v8; // [sp+4h] [bp-18h]@5
  float v9; // [sp+8h] [bp-14h]@5
  float v10; // [sp+Ch] [bp-10h]@5
  float v11; // [sp+10h] [bp-Ch]@5
  float v12; // [sp+14h] [bp-8h]@5
  float v13; // [sp+18h] [bp-4h]@5
  signed int v14; // [sp+30h] [bp+14h]@5

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  j_gdi_pvg_color_u32(-1);
  if ( a2 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v14 = *(_WORD *)a3;
    v7 = 0;
    v8 = (double)v14;
    v9 = (double)v6;
    v10 = *(float *)(a2 + 4);
    v11 = *(float *)(a2 + 8);
    v12 = 0.0;
    v13 = 0.0;
    if ( a4 )
    {
      sub_1000F360(*a4, (int)&v7);
      return 2;
    }
    sub_1000F200(*(_DWORD *)(a2 + 12), (int)&v7);
  }
  return 2;
}
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);

//----- (10009BE0) --------------------------------------------------------
char __cdecl sub_10009BE0(__int16 a1, char *a2, __int16 a3, int a4)
{
  __int16 v4; // ax@4
  char result; // al@4
  char *v6; // [sp+Ch] [bp-F0h]@1
  int v7; // [sp+10h] [bp-ECh]@1
  int v8; // [sp+14h] [bp-E8h]@1
  __int16 *v9; // [sp+18h] [bp-E4h]@1
  int v10; // [sp+1Ch] [bp-E0h]@1
  int *v11; // [sp+20h] [bp-DCh]@1
  int v12; // [sp+24h] [bp-D8h]@1
  int v13; // [sp+28h] [bp-D4h]@1
  char v14; // [sp+2Ch] [bp-D0h]@1
  __int16 v15; // [sp+2Eh] [bp-CEh]@4
  char v16; // [sp+30h] [bp-CCh]@4
  __int16 v17; // [sp+64h] [bp-98h]@1
  __int16 v18; // [sp+68h] [bp-94h]@1
  __int16 v19; // [sp+6Ah] [bp-92h]@1

  v8 = 0;
  v9 = &v17;
  v19 = a1;
  v17 = -32754;
  v18 = a3;
  v13 = 4;
  v10 = 8;
  v11 = (int *)&v6;
  v12 = 200;
  v6 = &v14;
  v7 = 56;
  if ( sub_10038490(38, (int)&v9) || v8 || v7 != 56 )
  {
    sub_1000D560((int)a2, "None", (unsigned __int16)a3);
    *(_WORD *)a4 = -1;
    result = 0;
  }
  else
  {
    strncpy(a2, &v16, (unsigned __int16)a3);
    v4 = v15;
    a2[(unsigned __int16)a3 - 1] = 0;
    *(_WORD *)a4 = v4;
    result = v14;
  }
  return result;
}

//----- (10009D10) --------------------------------------------------------
signed int __cdecl sub_10009D10(char *a1, char *a2)
{
  int v2; // ecx@5
  int v3; // eax@5
  signed int result; // eax@8
  int v5; // ecx@8
  int *v6; // [sp+8h] [bp-C0h]@5
  int v7; // [sp+Ch] [bp-BCh]@5
  int v8; // [sp+10h] [bp-B8h]@5
  __int16 *v9; // [sp+14h] [bp-B4h]@5
  int v10; // [sp+18h] [bp-B0h]@5
  int *v11; // [sp+1Ch] [bp-ACh]@5
  int v12; // [sp+20h] [bp-A8h]@5
  int v13; // [sp+24h] [bp-A4h]@5
  int v14; // [sp+28h] [bp-A0h]@5
  int v15; // [sp+2Ch] [bp-9Ch]@8
  __int16 v16; // [sp+30h] [bp-98h]@5
  int v17; // [sp+34h] [bp-94h]@5
  int v18; // [sp+38h] [bp-90h]@5

  if ( !a1 )
    sub_1000D9C0(".\\mdb\\mdb_intf_map.c", 561, 1, 0);
  if ( !a2 )
    sub_1000D9C0(".\\mdb\\mdb_intf_map.c", 562, 1, 0);
  v2 = *(_DWORD *)a2;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v3 = *(_DWORD *)a1;
  v9 = &v16;
  v17 = v3;
  v18 = v2;
  v16 = -32751;
  v13 = 4;
  v10 = 2;
  v11 = (int *)&v6;
  v12 = 100;
  v6 = &v14;
  v7 = 8;
  if ( sub_10038490(38, (int)&v9) || v8 || v7 != 8 )
  {
    a1[1] = 0;
    *a1 = 0;
    result = 0xFFFF;
    *((_WORD *)a1 + 1) = -1;
    a2[1] = 0;
    *a2 = 0;
    *((_WORD *)a2 + 1) = -1;
  }
  else
  {
    result = v14;
    v5 = v15;
    *(_DWORD *)a1 = v14;
    *(_DWORD *)a2 = v5;
  }
  return result;
}

//----- (10009E50) --------------------------------------------------------
int __cdecl sub_10009E50(unsigned int a1)
{
  return sub_100013D0(dword_104F97E0, a1);
}
// 104F97E0: using guessed type int dword_104F97E0;

//----- (10009E70) --------------------------------------------------------
int sub_10009E70()
{
  _BYTE *v0; // esi@1
  int result; // eax@3

  v0 = sub_10001930("checklist");
  sub_10001530((int)v0, 0x20u, 400);
  sub_10001530((int)v0, 0x40u, 400);
  sub_10001530((int)v0, 0x80u, 400);
  sub_10001530((int)v0, 0x100u, 1000);
  sub_10001530((int)v0, 0x200u, 400);
  sub_10001530((int)v0, 0x400u, 10);
  sub_10001530((int)v0, 0x800u, 0);
  sub_10001530((int)v0, 0x1000u, 0);
  sub_10001530((int)v0, 0x2000u, 0);
  sub_10001530((int)v0, 0x4000u, 0);
  sub_10001530((int)v0, 0x8000u, 8);
  sub_10001530((int)v0, 0x10000u, 6);
  sub_10001530((int)v0, 0x20000u, 1);
  sub_10001530((int)v0, 0x40000u, 0);
  sub_10001530((int)v0, 0x100000u, 0);
  if ( (unsigned int)sub_100019F0((int)v0) > 0x177090 )
    sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 370, 1, 0);
  result = sub_10001A10((int)v0, &unk_104F97E8, 0x177090u);
  dword_104F97E0 = result;
  return result;
}
// 104F97E0: using guessed type int dword_104F97E0;

//----- (10009F90) --------------------------------------------------------
bool __cdecl sub_10009F90(int a1)
{
  void *v1; // eax@5
  bool result; // al@2

  if ( a1 )
  {
    if ( a1 )
    {
      v1 = sub_10002010(a1);
      if ( v1 )
        result = sub_10001E40((int)v1) != 0;
      else
        result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10009FB0) --------------------------------------------------------
int sub_10009FB0()
{
  return sub_10038730(41042, (int)&unk_10059900, 1024);
}

//----- (10009FD0) --------------------------------------------------------
char __cdecl sub_10009FD0(int a1, unsigned __int8 a2)
{
  char result; // al@2

  if ( dword_10670890 )
  {
    sub_1000D560(a1, (_BYTE *)dword_10670890, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10670890: using guessed type int dword_10670890;

//----- (1000A000) --------------------------------------------------------
BOOL __cdecl sub_1000A000(char a1)
{
  return a1 == 99 || a1 == 114 || a1 == 110 || a1 == 112 || a1 == 97 || a1 == 119;
}

//----- (1000A030) --------------------------------------------------------
signed int __usercall sub_1000A030@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 1:
      result = 41072;
      break;
    case 2:
      result = 41073;
      break;
    case 4:
      result = 41074;
      break;
    case 8:
      result = 41075;
      break;
    case 64:
      result = 41076;
      break;
    case 128:
      result = 41077;
      break;
    case 16:
      result = 41078;
      break;
    case 32:
      result = 41079;
      break;
    default:
      result = 42066;
      break;
  }
  return result;
}

//----- (1000A120) --------------------------------------------------------
signed int __usercall sub_1000A120@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 1:
      result = 41080;
      break;
    case 2:
      result = 41081;
      break;
    case 4:
      result = 41082;
      break;
    case 8:
      result = 41083;
      break;
    case 64:
      result = 41084;
      break;
    case 128:
      result = 41085;
      break;
    case 16:
      result = 41086;
      break;
    case 32:
      result = 41087;
      break;
    default:
      result = 42066;
      break;
  }
  return result;
}

//----- (1000A210) --------------------------------------------------------
int sub_1000A210()
{
  int v0; // esi@1
  int v1; // ebx@2
  char *v2; // edi@2
  unsigned int v3; // eax@3
  int v4; // ecx@4
  int result; // eax@7
  char v6; // [sp+7h] [bp-5h]@7
  int v7; // [sp+8h] [bp-4h]@2

  v0 = 0;
  if ( dword_10670878 )
  {
    v1 = dword_10670884;
    v2 = (char *)dword_1067087C + 4;
    v7 = dword_10670878;
    do
    {
      v3 = 0;
      if ( *(_DWORD *)v2 )
      {
        v4 = *((_DWORD *)v2 + 1);
        do
        {
          *(_DWORD *)(v1 + 28 * (v3 + v4) + 20) = v0;
          v4 = *((_DWORD *)v2 + 1);
          v0 += *(_DWORD *)(v1 + 28 * (v4 + v3++) + 16);
        }
        while ( v3 < *(_DWORD *)v2 );
      }
      v2 += 12;
      --v7;
    }
    while ( v7 );
  }
  result = sub_100386C0(41043, &v6, 1, &unk_100593D6);
  if ( !v6 )
  {
    v6 = 1;
    sub_10038730(41043, (int)&v6, 1);
    result = sub_10009FB0();
  }
  return result;
}
// 10670878: using guessed type int dword_10670878;
// 10670884: using guessed type int dword_10670884;

//----- (1000A2C0) --------------------------------------------------------
BOOL __usercall sub_1000A2C0@<eax>(char a1@<al>)
{
  return a1 == 99 || a1 == 114;
}

//----- (1000A2E0) --------------------------------------------------------
BOOL __usercall sub_1000A2E0@<eax>(char a1@<al>)
{
  return a1 == 99 || a1 == 114 || a1 == 110 || a1 == 112 || a1 == 116 || a1 == 97 || a1 == 119 || !a1;
}

//----- (1000A310) --------------------------------------------------------
char __cdecl sub_1000A310(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  v2 = sub_1000A120(a1);
  sub_10038700(v2, (int)&v4 + 3, 1);
  return BYTE3(v4);
}

//----- (1000A330) --------------------------------------------------------
int __cdecl sub_1000A330(int a1, char a2)
{
  int v2; // eax@1

  v2 = sub_1000A120(a1);
  return sub_10038730(v2, (int)&a2, 1);
}

//----- (1000A350) --------------------------------------------------------
char sub_1000A350()
{
  int v0; // edi@1
  unsigned int v1; // esi@1
  char *v2; // eax@2
  _BYTE *v3; // eax@2
  char *v4; // eax@5
  void *v5; // ecx@6
  int v6; // eax@6
  char result; // al@6
  char *v8; // eax@7
  _DWORD *v9; // eax@11
  void *v10; // ecx@12
  int v11; // eax@12
  _BYTE *v12; // ecx@13
  unsigned int i; // esi@15
  char *v14; // ecx@16
  _BYTE *v15; // ecx@16
  char v16; // cl@18
  char *v17; // eax@23
  int v18; // ecx@23
  int v19; // eax@23
  int v20; // eax@25
  char *v21; // ebx@25
  void *v22; // ebp@25
  unsigned int v23; // ecx@27
  int v24; // esi@27
  int v25; // edx@28
  int v26; // ebp@28
  int v27; // ebx@29
  char v28; // al@29
  char *v29; // eax@34
  char v30; // bl@34
  void *v31; // ecx@38
  _DWORD *v32; // edx@39
  int v33; // ecx@39
  int v34; // eax@47
  int v35; // eax@49
  int v36; // eax@50
  int v37; // eax@51
  char v38; // dl@53
  int v39; // eax@53
  int v40; // eax@56
  void *v41; // ecx@57
  int v42; // eax@57
  void *v43; // ecx@58
  int v44; // eax@58
  char v45; // [sp+Bh] [bp-Dh]@27
  int v46; // [sp+Ch] [bp-Ch]@27
  int v47; // [sp+10h] [bp-8h]@27
  unsigned __int16 v48; // [sp+14h] [bp-4h]@1

  v0 = 0;
  v48 = 0;
  dword_10670888[0] = 0;
  dword_104F97D0 = 0;
  dword_104F97D4 = 0;
  dword_1067088C[0] = dword_104F97E4 + 10;
  v1 = 1;
  do
  {
    v2 = strchr((const char *)dword_10670888[v1], 13);
    dword_1067088C[v1] = (int)v2;
    *v2 = 0;
    v3 = (_BYTE *)(dword_1067088C[v1] + 1);
    dword_1067088C[v1] = (int)v3;
    if ( *v3 == 10 )
      dword_1067088C[v1] = (int)(v3 + 1);
    ++v1;
  }
  while ( v1 < 5 );
  v4 = strchr(dword_1067089C, 13);
  if ( v4 )
  {
    *v4 = 0;
    v8 = v4 + 1;
    if ( *v8 == 10 )
      ++v8;
    for ( dword_10670880 = (int)v8; v8; v8 = strchr(v8 + 1, 13) )
      ++dword_10670888[0];
    v9 = (_DWORD *)sub_10009E50(4 * dword_10670888[0]);
    dword_104F97D8 = (int)v9;
    if ( v9 )
    {
      v12 = (_BYTE *)dword_10670880;
      *v9 = dword_10670880;
      if ( *v12 == 60 )
        ++dword_104F97D4;
      for ( i = 1; i < dword_10670888[0] - 1; ++i )
      {
        v14 = strchr((const char *)v9[i - 1], 13);
        v9 = (_DWORD *)dword_104F97D8;
        *(_DWORD *)(dword_104F97D8 + 4 * i) = v14;
        *v14 = 0;
        v15 = (_BYTE *)++v9[i];
        if ( *v15 == 10 )
          v9[i] = v15 + 1;
        v16 = *(_BYTE *)v9[i];
        if ( v16 == 60 )
          ++dword_104F97D4;
        if ( v16 == 40 )
          ++dword_104F97D0;
      }
      v17 = strchr((const char *)v9[i - 1], 13);
      v18 = dword_104F97D8;
      *(_DWORD *)(dword_104F97D8 + 4 * i) = v17;
      *v17 = 0;
      v19 = dword_104F97D4;
      ++*(_DWORD *)(v18 + 4 * i);
      if ( v19 && dword_104F97D0 )
      {
        dword_10670878 = v19;
        dword_1067087C = (void *)sub_10009E50(12 * v19);
        v20 = sub_10009E50(28 * dword_104F97D0);
        v21 = (char *)dword_1067087C;
        v22 = (void *)v20;
        dword_10670884 = v20;
        if ( dword_1067087C && v20 )
        {
          memset(dword_1067087C, 0, 12 * dword_104F97D4);
          memset(v22, 0, 28 * dword_104F97D0);
          v23 = 0;
          v24 = 0;
          v45 = 0;
          v46 = 0;
          v47 = 0;
          if ( dword_10670888[0] )
          {
            v25 = (int)v22 + 16;
            v26 = (int)(v21 + 4);
            do
            {
              v27 = dword_104F97D8;
              v28 = **(_BYTE **)(dword_104F97D8 + 4 * v23);
              if ( v28 == 60 )
              {
                *(_DWORD *)(v26 - 4) = v23;
              }
              else if ( v28 == 62 )
              {
                if ( !v0 )
                {
                  v35 = sub_10014FF0((void *)v23);
                  sub_1000A330(v35, 0);
                  sub_10009F90(dword_10670884);
                  sub_10009F90((int)dword_1067087C);
                  sub_10009F90(dword_104F97D8);
                  sub_10009F90(dword_104F97E4);
                  sub_1000D9C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2380,
                    0,
                    "Invalid checklist file.  Group found with no checklist.");
                  return 0;
                }
                ++v47;
                *(_DWORD *)(v26 + 4) = v46 - v0;
                *(_DWORD *)v26 = v0;
                v26 += 12;
                v0 = 0;
              }
              v29 = *(char **)(v27 + 4 * v23);
              v30 = *v29;
              if ( *v29 == 41 )
              {
                if ( !v24 )
                {
                  v36 = sub_10014FF0((void *)v23);
                  sub_1000A330(v36, 0);
                  sub_10009F90(dword_10670884);
                  sub_10009F90((int)dword_1067087C);
                  sub_10009F90(dword_104F97D8);
                  sub_10009F90(dword_104F97E4);
                  sub_1000D9C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2403,
                    0,
                    "Invalid checklist file.  Checklist found with no entries.");
                  return 0;
                }
                ++v46;
                *(_DWORD *)(v25 - 8) = v24;
                *(_DWORD *)(v25 - 4) = v23 - v24;
                v25 += 28;
                v45 = 0;
                v24 = 0;
              }
              else if ( v45 )
              {
                if ( !(unsigned __int8)sub_1000A2E0(*v29) )
                {
                  v37 = sub_10014FF0(v31);
                  sub_1000A330(v37, 0);
                  sub_10009F90(dword_10670884);
                  sub_10009F90((int)dword_1067087C);
                  sub_10009F90(dword_104F97D8);
                  sub_10009F90(dword_104F97E4);
                  sub_1000D9C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2443,
                    0,
                    "Invalid checklist file.  Entry with invalid code found.");
                  return 0;
                }
                ++v24;
                if ( (unsigned __int8)sub_1000A2C0(v30) )
                {
                  ++*v32;
                  ++v48;
                }
                if ( (unsigned __int8)sub_1000A000(**(_BYTE **)(dword_104F97D8 + 4 * v33)) )
                  *(_DWORD *)(v25 + 8) = v24 - 1;
              }
              if ( **(_BYTE **)(dword_104F97D8 + 4 * v23) == 40 )
              {
                v45 = 1;
                *(_DWORD *)(v25 - 12) = v47;
                *(_DWORD *)(v25 - 16) = v23;
                ++v0;
              }
              ++v23;
            }
            while ( v23 < dword_10670888[0] );
            if ( v48 > 0x800u )
            {
              v34 = sub_10014FF0((void *)v23);
              sub_1000A330(v34, 0);
              sub_10009F90(dword_10670884);
              sub_10009F90((int)dword_1067087C);
              sub_10009F90(dword_104F97D8);
              sub_10009F90(dword_104F97E4);
              sub_1000D9C0(
                "..\\lib\\adl\\cdp_utl_chklst.c",
                2472,
                0,
                "Invalid checklist file.  Number of checkable items exceeds 2048.");
              return 0;
            }
            v21 = (char *)dword_1067087C;
          }
          LOBYTE(v23) = *(_BYTE *)(dword_104F97E4 + 6);
          v38 = *(_BYTE *)(dword_104F97E4 + 7);
          v39 = (unsigned __int8)v23;
          byte_104F97DC = *(_BYTE *)(dword_104F97E4 + 6);
          byte_104F97DD = v38;
          if ( (unsigned __int8)v23 >= (unsigned int)dword_10670878
            || (v23 = (unsigned __int8)v38, (unsigned int)(unsigned __int8)v38 >= *(_DWORD *)&v21[12 * v39 + 4]) )
          {
            byte_104F97DC = 0;
            byte_104F97DD = 0;
          }
          v40 = sub_10014FF0((void *)v23);
          sub_1000A330(v40, 1);
          sub_1000A210();
          result = 1;
        }
        else
        {
          sub_1000D9C0(
            "..\\lib\\adl\\cdp_utl_chklst.c",
            2348,
            0,
            "Error allocating memory for groups or checklist structure.");
          v42 = sub_10014FF0(v41);
          sub_1000A330(v42, 0);
          result = 0;
        }
      }
      else
      {
        sub_1000D9C0(
          "..\\lib\\adl\\cdp_utl_chklst.c",
          2335,
          0,
          "Invalid checklist file.  Group count or checklist count is 0.");
        v44 = sub_10014FF0(v43);
        sub_1000A330(v44, 0);
        sub_10009F90(dword_104F97D8);
        sub_10009F90(dword_104F97E4);
        result = 0;
      }
    }
    else
    {
      sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2288, 0, "Error allocating memory for checklist entries.");
      v11 = sub_10014FF0(v10);
      sub_1000A330(v11, 0);
      result = 0;
    }
  }
  else
  {
    sub_1000D9C0(
      "..\\lib\\adl\\cdp_utl_chklst.c",
      2255,
      0,
      "Invalid checklist file.  No carriage return after last header line.");
    v6 = sub_10014FF0(v5);
    sub_1000A330(v6, 0);
    sub_10009F90(dword_104F97E4);
    result = 0;
  }
  return result;
}
// 104F97D0: using guessed type int dword_104F97D0;
// 104F97D4: using guessed type int dword_104F97D4;
// 104F97D8: using guessed type int dword_104F97D8;
// 104F97DC: using guessed type char byte_104F97DC;
// 104F97DD: using guessed type char byte_104F97DD;
// 104F97E4: using guessed type int dword_104F97E4;
// 10670878: using guessed type int dword_10670878;
// 10670880: using guessed type int dword_10670880;
// 10670884: using guessed type int dword_10670884;
// 10670888: using guessed type int dword_10670888[];
// 1067088C: using guessed type int dword_1067088C[];

//----- (1000A900) --------------------------------------------------------
int __cdecl sub_1000A900(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@1
  int result; // eax@1
  void *v5; // ecx@1
  int v6; // eax@2

  v2 = sub_10014FF0(v1);
  v3 = sub_1000A030(v2);
  result = sub_10038730(v3, (int)&a1, 4);
  if ( !a1 )
  {
    v6 = sub_10014FF0(v5);
    result = sub_1000A330(v6, 0);
  }
  return result;
}

//----- (1000A940) --------------------------------------------------------
char __thiscall sub_1000A940(void *this)
{
  int v1; // eax@1

  v1 = sub_10014FF0(this);
  return sub_1000A310(v1);
}

//----- (1000A950) --------------------------------------------------------
char sub_1000A950()
{
  char *v0; // edi@1
  char v1; // al@2
  unsigned int v2; // eax@3
  char *v3; // edi@3
  char v4; // cl@4
  unsigned int v5; // eax@5
  void *v6; // ecx@5
  unsigned int v7; // esi@5
  char *v8; // edi@7
  char v9; // al@8
  unsigned int v10; // eax@9
  char *v11; // edi@9
  char v12; // cl@10
  int v13; // eax@18
  signed int v15; // edi@23
  void *v16; // eax@24
  char v17; // [sp-4h] [bp-70h]@17
  int v18; // [sp+8h] [bp-64h]@1
  char v19; // [sp+Ch] [bp-60h]@3
  char v20; // [sp+2Bh] [bp-41h]@1
  int v21; // [sp+2Ch] [bp-40h]@1
  int v22; // [sp+30h] [bp-3Ch]@1
  __int16 v23; // [sp+34h] [bp-38h]@1
  char v24; // [sp+36h] [bp-36h]@1

  v21 = 1953393967;
  v18 = 0;
  dword_104F97E4 = 0;
  v22 = 1918985007;
  v23 = 12388;
  v24 = 0;
  v0 = &v20;
  do
    v1 = (v0++)[1];
  while ( v1 );
  *(_WORD *)v0 = 47;
  sub_10038660(6567, (int)&v19, 30);
  v2 = strlen(&v19) + 1;
  v3 = &v20;
  do
    v4 = (v3++)[1];
  while ( v4 );
  qmemcpy(v3, &v19, v2);
  v5 = j_FIL_vfs_open(&v21, 4, 0);
  v7 = v5;
  if ( v5 >= 0xFFFFFFC2 || !v5 )
  {
    v21 = 1953393967;
    v22 = 1918985007;
    v23 = 12644;
    v24 = 0;
    v8 = &v20;
    do
      v9 = (v8++)[1];
    while ( v9 );
    *(_WORD *)v8 = 47;
    v10 = strlen(&v19) + 1;
    v11 = &v20;
    do
      v12 = (v11++)[1];
    while ( v12 );
    qmemcpy(v11, &v19, v10);
    v7 = j_FIL_vfs_open(&v21, 4, 0);
  }
  if ( v7 >= 0xFFFFFFC2 || !v7 )
    v7 = j_FIL_vfs_open("/mnt/sys_nand0/chklist.ace", 4, 0);
  if ( v7 >= 0xFFFFFFC2 || !v7 )
  {
    v17 = 2;
LABEL_18:
    v13 = sub_10014FF0(v6);
    sub_1000A330(v13, v17);
    return 0;
  }
  if ( sub_100396D0(v7, -4, 2) < 0 )
  {
    sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2103, 0, "Error seeking to CRC of checklist file.");
    v17 = 0;
    goto LABEL_18;
  }
  if ( sub_10039460(v7, &v18, 4) != 4 )
  {
    sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2116, 0, "Error reading CRC of checklist file.");
    v17 = 0;
    goto LABEL_18;
  }
  sub_1000A900(v18);
  v15 = sub_100396D0(v7, 0, 2);
  if ( (unsigned int)(v15 - 18) <= 0xFFFED )
  {
    v16 = (void *)sub_10009E50(v15);
    dword_104F97E4 = (int)v16;
    if ( !v16 )
    {
      sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2143, 0, "Error allocating memory for checklist file.");
      v17 = 0;
      goto LABEL_18;
    }
    if ( sub_100394B0(v7, v16, v15, 0, 0) != v15 || sub_1003B050((unsigned int *)dword_104F97E4, v15, 0xFFFFFFFF) )
    {
      sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2158, 0, "Error calculating CRC of checklist file.");
      sub_10009F90(dword_104F97E4);
      dword_104F97E4 = 0;
      sub_1000A900(0);
    }
  }
  sub_10039360(v7);
  if ( !dword_104F97E4 )
  {
    sub_1000D9C0("..\\lib\\adl\\cdp_utl_chklst.c", 2178, 0, "Error reading checklist file.  CRC invalid?");
    v17 = 0;
    goto LABEL_18;
  }
  return 1;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 104F97E4: using guessed type int dword_104F97E4;

//----- (1000AC60) --------------------------------------------------------
char sub_1000AC60()
{
  char result; // al@1

  sub_10009E70();
  result = sub_1000A950();
  if ( result )
    result = sub_1000A350();
  return result;
}

//----- (1000AC80) --------------------------------------------------------
char __cdecl sub_1000AC80(int a1)
{
  return sub_10038680(2021, a1, 128);
}

//----- (1000ACA0) --------------------------------------------------------
int __cdecl sub_1000ACA0(int a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10038660(6901, (int)&v3 + 3, 1);
  return sub_1000D560(a1, &aDefaultProfi_0[17 * BYTE3(v3)], 17);
}

//----- (1000AD20) --------------------------------------------------------
int sub_1000AD20()
{
  __int16 v0; // di@1
  char *v1; // eax@1
  signed int v2; // ecx@1
  int v3; // eax@5
  int v4; // eax@5
  char *v5; // ebp@5
  signed int i; // ebx@5
  char *v7; // eax@8
  char v8; // cl@9
  int v9; // eax@11
  unsigned int v11; // [sp+4h] [bp-1000h]@5
  _BYTE v12[850]; // [sp+8h] [bp-FFCh]@1
  __int16 v13; // [sp+35Ah] [bp-CAAh]@14
  char v14; // [sp+35Ch] [bp-CA8h]@4
  char v15; // [sp+360h] [bp-CA4h]@3
  char v16; // [sp+380h] [bp-C84h]@8
  char v17; // [sp+394h] [bp-C70h]@1
  char v18; // [sp+414h] [bp-BF0h]@1
  char v19; // [sp+768h] [bp-89Ch]@5

  v0 = 0;
  memset(v12, 0, 0x356u);
  v17 = 0;
  v1 = &v18;
  v2 = 50;
  do
  {
    *v1 = 0;
    v1 += 17;
    --v2;
  }
  while ( v2 );
  if ( sub_10039710((int)"/dev/sd_card0", (unsigned int)&v15) < 0 )
  {
    v14 = 0;
LABEL_14:
    v13 = v0;
    return sub_10038730(9947, (int)v12, 854);
  }
  v14 = 1;
  sub_1000D560((int)&v17, &dword_1004F32C, 128);
  sub_1000D720(&v17, "/profiles", 128);
  if ( sub_10039600((int)&v17) )
  {
    v3 = j_FIL_vfs_open(&v17, 260, 0);
    v11 = v3;
    v4 = sub_100396B0(v3, (int)&v19, 2200);
    v5 = &v19;
    for ( i = v4 < 0 ? 0 : v4; i > 0; v5 += v9 )
    {
      if ( (unsigned __int16)v0 >= 0x32u )
        break;
      if ( sub_1000D4B0(v5 + 24, ".gprof") )
      {
        sub_1000CAC0(v5 + 24, ".", &v16, 17);
        v7 = &v16;
        do
        {
          v8 = *v7;
          v7[(_DWORD)&v12[17 * (unsigned __int16)v0 - (_DWORD)&v16]] = *v7;
          ++v7;
        }
        while ( v8 );
        ++v0;
      }
      v9 = *((_WORD *)v5 + 2);
      i -= v9;
    }
    sub_10039360(v11);
    sub_100151E0((int)v12, (unsigned __int16)v0, 0x11u, (int)sub_1000ACE0);
    goto LABEL_14;
  }
  return sub_10038730(9947, (int)v12, 854);
}
// 1000ACE0: using guessed type int sub_1000ACE0();
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1004F32C: using guessed type int dword_1004F32C;

//----- (1000AEF0) --------------------------------------------------------
int sub_1000AEF0()
{
  char *v0; // eax@1
  int v1; // eax@3
  int v2; // eax@3
  char *v3; // ebx@3
  char *v4; // ebp@4
  char *v5; // eax@6
  int v6; // edx@8
  char v7; // cl@9
  int v8; // eax@11
  int v10; // [sp+0h] [bp-45Ch]@3
  signed int v11; // [sp+4h] [bp-458h]@3
  unsigned int v12; // [sp+8h] [bp-454h]@3
  char v13; // [sp+Ch] [bp-450h]@3

  v0 = byte_1077A440;
  do
  {
    *v0 = 0;
    v0 += 17;
  }
  while ( (signed int)v0 < (signed int)&unk_1077A5E9 );
  v1 = j_FIL_vfs_open("/mnt/sys_nand0/usr/othr_usr", 260, 0);
  v12 = v1;
  v2 = sub_100396B0(v1, (int)&v13, 1100);
  v3 = &v13;
  v10 = 0;
  v11 = v2 < 0 ? 0 : v2;
  if ( v11 > 0 )
  {
    v4 = byte_1077A440;
    do
    {
      if ( (signed int)v4 >= (signed int)&unk_1077A5E9 )
        break;
      v5 = v3 + 24;
      if ( memcmp(".", v3 + 24, 2u) && memcmp("..", v3 + 24, 3u) )
      {
        v6 = v4 - v5;
        do
        {
          v7 = *v5;
          v5[v6] = *v5;
          ++v5;
        }
        while ( v7 );
        ++v10;
        v4 += 17;
      }
      v8 = *((_WORD *)v3 + 2);
      v3 += v8;
      v11 -= v8;
    }
    while ( v11 > 0 );
  }
  sub_10039360(v12);
  sub_100151E0((int)byte_1077A440, (unsigned __int16)v10, 0x11u, (int)sub_1000ACE0);
  return v10;
}
// 1000ACE0: using guessed type int sub_1000ACE0();
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1000B010) --------------------------------------------------------
int __cdecl sub_1000B010(char *a1)
{
  char *v1; // eax@1
  int result; // eax@1
  char v3; // [sp+4h] [bp-98h]@1
  char v4; // [sp+18h] [bp-84h]@1

  sub_1000ACA0((int)&v3);
  sub_1000AC80((int)&v4);
  v1 = strrchr(&v4, 47);
  strncpy(a1, v1 + 1, 0x11u);
  result = sub_1000D5B0(a1, "DEFAULT PROFILE", 17);
  if ( !result )
    result = sub_1000D560((int)a1, &v3, 17);
  return result;
}

//----- (1000B0A0) --------------------------------------------------------
char __cdecl sub_1000B0A0(const char *a1)
{
  char v1; // al@1
  char result; // al@5
  int v3; // ebp@12
  int v4; // edi@12
  const char *v5; // esi@13
  char v6; // [sp+4h] [bp-18h]@1

  sub_1000D760((int)a1, 0);
  sub_1000ACA0((int)&v6);
  sub_1000D460(a1, 95, 32);
  v1 = *a1;
  if ( *a1 && v1 != 32 && v1 != 95 )
  {
    if ( !memcmp(a1, "CURRENT SETTINGS", 0x11u) )
    {
      result = 4;
    }
    else if ( !strcmp(a1, &v6) )
    {
      result = 2;
    }
    else if ( !memcmp(a1, "GARMIN DEFAULTS", 0x10u) )
    {
      result = 3;
    }
    else if ( !strcmp(a1, "NONE") )
    {
      result = 5;
    }
    else
    {
      v3 = sub_1000AEF0();
      v4 = 0;
      if ( v3 <= 0 )
      {
LABEL_16:
        result = 0;
      }
      else
      {
        v5 = byte_1077A440;
        while ( strcmp(a1, v5) )
        {
          ++v4;
          v5 += 17;
          if ( v4 >= v3 )
            goto LABEL_16;
        }
        result = 6;
      }
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1000B270) --------------------------------------------------------
char __cdecl sub_1000B270(const char *a1)
{
  int v1; // eax@1
  char *v2; // edi@2
  char v3; // al@3
  unsigned int v4; // eax@4
  char *v5; // edi@4
  char v6; // cl@5
  char v8; // [sp+Bh] [bp-85h]@2
  char v9; // [sp+Ch] [bp-84h]@1

  v9 = 0;
  LOBYTE(v1) = sub_1000B0A0(a1);
  if ( (_BYTE)v1 == 6 )
  {
    qmemcpy(&v9, "/mnt/sys_nand0/usr/othr_usr", 0x1Cu);
    v2 = &v8;
    do
      v3 = (v2++)[1];
    while ( v3 );
    *(_WORD *)v2 = 47;
    v4 = strlen(a1) + 1;
    v5 = &v8;
    do
      v6 = (v5++)[1];
    while ( v6 );
    qmemcpy(v5, a1, v4);
  }
  else
  {
    if ( (_BYTE)v1 != 2 )
      return v1;
    qmemcpy(&v9, "/mnt/sys_nand0/usr/DEFAULT PROFILE", 0x23u);
  }
  v1 = j_SYS_pvg_actvte_pilot_prof(&v9, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_1000B760(0);
  return v1;
}
// 10039BF0: using guessed type int __cdecl j_SYS_pvg_actvte_pilot_prof(_DWORD, _DWORD);

//----- (1000B350) --------------------------------------------------------
int __cdecl sub_1000B350(char a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 v5; // di@1
  int v6; // ecx@1
  _BYTE *v7; // eax@2
  int result; // eax@13
  const char *v9; // ebx@14
  char *v10; // edi@17
  char v11; // al@18
  unsigned int v12; // eax@19
  char *v13; // edi@19
  char v14; // cl@20
  int v15; // eax@21
  signed int v16; // [sp+10h] [bp-124h]@13
  char v17; // [sp+1Ch] [bp-118h]@1
  char v18; // [sp+2Fh] [bp-105h]@17
  char v19; // [sp+30h] [bp-104h]@17
  char v20; // [sp+B0h] [bp-84h]@13

  sub_1000ACA0((int)&v17);
  v5 = a2;
  v6 = a2;
  *a4 = 0;
  *a5 = 0;
  if ( (signed int)a2 > 0 )
  {
    v7 = a3;
    do
    {
      *v7 = 0;
      v7 += 17;
      --v6;
    }
    while ( v6 );
  }
  if ( a1 == 1 )
  {
    if ( *a4 >= a2 )
      goto LABEL_13;
    strncpy(&a3[16 * *a4] + *a4, "GARMIN DEFAULTS", 0x11u);
    ++*a4;
  }
  else if ( a1 )
  {
    goto LABEL_13;
  }
  if ( *a4 < a2 )
  {
    strncpy(&a3[16 * *a4] + *a4, &v17, 0x11u);
    ++*a4;
  }
  if ( a1 == 1 && *a4 < a2 )
  {
    strncpy(&a3[16 * *a4] + *a4, "CURRENT SETTINGS", 0x11u);
    ++*a4;
    *a5 = 2;
  }
LABEL_13:
  sub_1000AEF0();
  sub_1000AD20();
  sub_1000AC80((int)&v20);
  v16 = 0;
  result = sub_1000B260();
  if ( (_WORD)result )
  {
    v9 = byte_1077A440;
    while ( 1 )
    {
      result = *a4;
      if ( (unsigned __int16)result >= v5 )
        return result;
      qmemcpy(&v19, "/mnt/sys_nand0/usr/othr_usr", 0x1Cu);
      v10 = &v18;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 47;
      v12 = strlen(v9) + 1;
      v13 = &v18;
      do
        v14 = (v13++)[1];
      while ( v14 );
      qmemcpy(v13, v9, v12);
      v15 = strcmp(&v20, &v19);
      if ( a1 == 2 )
      {
        if ( !v15 )
          goto LABEL_29;
      }
      else if ( (a1 == 3 || !a1) && !v15 )
      {
        *a5 = *a4;
      }
      strncpy(&a3[16 * *a4] + *a4, v9, 0x11u);
      ++*a4;
LABEL_29:
      ++v16;
      v9 += 17;
      result = sub_1000B260();
      if ( v16 >= (unsigned __int16)result )
        return result;
      v5 = a2;
    }
  }
  return result;
}
// 1000B260: using guessed type int sub_1000B260(void);

//----- (1000B5D0) --------------------------------------------------------
int __usercall sub_1000B5D0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@1
  void (__cdecl *v4)(int, int, int, signed int); // eax@2
  int v5; // eax@5
  int v6; // eax@6
  int v7; // edx@6

  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = -128;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 242) = 1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230) = a1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 231) = *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230);
  result = *(_DWORD *)(a3 + 56);
  if ( result == *(_DWORD *)(a3 + 48) )
  {
    v4 = *(void (__cdecl **)(int, int, int, signed int))(result + 232);
    if ( v4 )
      v4(a3, a2, a1, 1);
    if ( a2 != 255 )
    {
      v5 = *(_DWORD *)(a3 + 56);
      *(_BYTE *)(a3 + 3) = 0;
      *(_BYTE *)(a3 + 5) = 1;
      sub_1000E470(
        a3,
        (int)&unk_100630D4,
        *(char **)(*(_DWORD *)(v5 + 56) + 4 * a2),
        *(_DWORD *)(*(_DWORD *)(v5 + 60) + 4 * a2));
    }
    v6 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 1;
    *(_BYTE *)(a3 + 5) = 0;
    sub_1000E470(
      a3,
      (int)&unk_100630D4,
      *(char **)(*(_DWORD *)(v6 + 56) + 4 * a1),
      *(_DWORD *)(*(_DWORD *)(v6 + 60) + 4 * a1));
    v7 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 0;
    result = *(_DWORD *)(v7 + 232);
    if ( result )
      result = ((int (__cdecl *)(int, int, int, _DWORD))result)(a3, a2, a1, 0);
  }
  return result;
}

//----- (1000B690) --------------------------------------------------------
char __cdecl sub_1000B690(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ebp@2
  unsigned __int8 v5; // dl@2
  int v6; // eax@4
  int v7; // edi@5
  unsigned __int8 v8; // cl@5
  int v9; // edi@15
  signed int v10; // eax@15
  bool v11; // zf@15
  char result; // al@21
  unsigned __int8 v13; // [sp+10h] [bp+8h]@3

  v3 = a2;
  if ( a2 == 255 )
    return 0;
  v4 = *(_DWORD *)(a1 + 56);
  v5 = *(_BYTE *)(v4 + 68);
  if ( !v5 )
    return 0;
  v13 = *(_BYTE *)(v4 + 230);
  if ( *(_BYTE *)(v4 + 68) > 1u )
  {
    v6 = a3;
    if ( a3 )
    {
      v7 = 2 * (a3 >= 0) - 1;
      v8 = *(_BYTE *)(v4 + 230);
      while ( 1 )
      {
        v3 += v7;
        if ( v3 < 0 || v3 >= v5 )
          break;
        if ( *(_BYTE *)(v3 + *(_DWORD *)(v4 + 64)) & 1 )
        {
          v8 = v3;
          v6 -= v7;
        }
        if ( !v6 )
          goto LABEL_20;
      }
      v3 = v8;
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  if ( !a3 )
  {
LABEL_14:
    if ( *(_BYTE *)(v4 + 230) == -1 )
    {
      v9 = *(_DWORD *)(v4 + 64);
      v10 = v3;
      v11 = (*(_BYTE *)(v9 + v3) & 1) == 0;
      v3 = 255;
      if ( v11 )
      {
        do
        {
          if ( v10 >= v5 )
            break;
          ++v10;
        }
        while ( !(*(_BYTE *)(v9 + v10) & 1) );
      }
      if ( v10 < v5 )
        v3 = v10;
    }
  }
LABEL_20:
  if ( v3 == v13 )
  {
    result = 1;
  }
  else
  {
    sub_1000B5D0(v3, v13, a1);
    result = 2;
  }
  return result;
}

//----- (1000B760) --------------------------------------------------------
int __cdecl sub_1000B760(unsigned __int8 a1)
{
  int result; // eax@2
  __int16 v2; // [sp+0h] [bp-10h]@3
  int v3; // [sp+2h] [bp-Eh]@1
  int v4; // [sp+6h] [bp-Ah]@1
  __int16 v5; // [sp+Ah] [bp-6h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
    {
      v2 = -32674;
      result = sub_10038460(9, (int)&v2, -1, 1);
    }
  }
  else
  {
    v2 = 0;
    sub_10038460(43, (int)&v2, -1, 1);
    sub_10038460(40, (int)&v2, -1, 1);
    sub_10038430(38, 0x2000);
    v2 = -32675;
    result = sub_10038460(9, (int)&v2, -1, 1);
  }
  return result;
}

//----- (1000B820) --------------------------------------------------------
char __cdecl sub_1000B820(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@4
  float v7; // ST38_4@5
  float v8; // ST38_4@5
  float v9; // ST24_4@5
  float v10; // ST38_4@5
  float v11; // ST20_4@5
  float v12; // ST38_4@5
  float v13; // ST28_4@5
  float v14; // ST2C_4@5
  float v15; // ST1C_4@5
  float v16; // ST30_4@5
  float v17; // ST24_4@5
  float v18; // ST20_4@5
  float v19; // ST30_4@5
  float v20; // ST2C_4@5
  float v21; // ST38_4@5
  float v22; // ST28_4@5
  float v23; // ST34_4@5
  float v24; // ST38_4@6
  float v25; // ST30_4@6
  float v26; // ST34_4@6
  float v27; // ST38_4@6
  float v28; // ST38_4@6
  float v29; // ST34_4@6
  float v30; // ST38_4@6
  double v31; // st7@6
  float v32; // ST08_4@8
  float v33; // [sp+4h] [bp-30h]@6
  float v34; // [sp+10h] [bp-24h]@4
  float v35; // [sp+48h] [bp+14h]@4
  float v36; // [sp+48h] [bp+14h]@6

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  v6 = *(_DWORD *)(a1 + 56);
  v34 = (double)*(_WORD *)(v6 + 34);
  v35 = (double)*(_WORD *)(v6 + 32);
  if ( !(*(_BYTE *)(a2 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    sub_10038180(0.0, 0.0);
    sub_10038180(v35, 0.0);
    sub_10038180(v35, v34);
    v33 = v34;
    v31 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
  sub_10038180(0.0, 0.0);
  sub_10038180(v35, 0.0);
  sub_10038180(v35, v34);
  sub_10038180(0.0, v34);
  j_gdi_pvg_color_u32(-16777216);
  sub_10038180(0.0, 0.0);
  sub_10038180(v35, 0.0);
  v7 = 0.0 + 3.0;
  sub_10038180(v35, v7);
  sub_10038180(0.0, v7);
  v8 = v34 - 3.0;
  sub_10038180(0.0, v8);
  sub_10038180(v35, v8);
  sub_10038180(v35, v34);
  sub_10038180(0.0, v34);
  j_gdi_pvg_end();
  sub_10037F60(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v9 = v34 - 3.5;
  v10 = 0.0 + 0.5;
  sub_10038180(v10, v9);
  v11 = 0.0 + 3.5;
  sub_10038180(v10, v11);
  v12 = v35 - 0.0;
  sub_10038180(v12, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v13 = 0.0 + 1.5;
  sub_10038180(v13, v9);
  v14 = v35 - 0.5;
  sub_10038180(v14, v9);
  sub_10038180(v14, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v15 = v34 - 4.5;
  sub_10038180(v13, v15);
  v16 = 0.0 + 4.5;
  sub_10038180(v13, v16);
  sub_10038180(v14, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v17 = 0.0 + 2.5;
  sub_10038180(v17, v15);
  v18 = v35 - 1.5;
  sub_10038180(v18, v15);
  sub_10038180(v18, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_10038180(v17, v15);
  v19 = v34 - 9.5;
  v20 = 0.0 + 7.5;
  sub_10038180(v20, v19);
  sub_10038180(v18, v15);
  v21 = v35 - 6.5;
  sub_10038180(v21, v19);
  v22 = 0.0 + 5.5;
  sub_10038180(v18, v22);
  v23 = 0.0 + 10.5;
  sub_10038180(v21, v23);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_10038180(v17, v15);
  sub_10038180(v20, v19);
  sub_10038180(v17, v22);
  sub_10038180(v20, v23);
  sub_10038180(v18, v22);
  sub_10038180(v21, v23);
  j_gdi_pvg_end();
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v24 = 0.0 + 14.0;
    v25 = 0.0 + 11.0;
    sub_10038180(v25, v24);
    v26 = v35 - 11.0;
    sub_10038180(v26, v24);
    v27 = v34 - 14.0;
    sub_10038180(v26, v27);
    sub_10038180(v25, v27);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    v28 = 0.0 + 15.0;
    v29 = 0.0 + 12.0;
    sub_10038180(v29, v28);
    v36 = v35 - 12.0;
    sub_10038180(v36, v28);
    v30 = v34 - 15.0;
    sub_10038180(v36, v30);
    v33 = v30;
    v31 = v29;
LABEL_8:
    v32 = v31;
    sub_10038180(v32, v33);
    j_gdi_pvg_end();
  }
  return 2;
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000BE60) --------------------------------------------------------
void __cdecl sub_1000BE60(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_10003A30(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_10003A30(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (1000BEB0) --------------------------------------------------------
unsigned int __usercall sub_1000BEB0@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_1077A428 )
  {
    dword_1077A428 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 1077A428: using guessed type int dword_1077A428;

//----- (1000BEF0) --------------------------------------------------------
int __usercall sub_1000BEF0@<eax>(int result@<eax>)
{
  if ( dword_1077A428 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_1077A428;
    *(_DWORD *)dword_1077A428 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_1077A428;
    dword_1077A428 = 0;
  }
  return result;
}
// 1077A428: using guessed type int dword_1077A428;

//----- (1000BF20) --------------------------------------------------------
void __cdecl sub_1000BF20(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_1000BEF0(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_10003A70(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_10003A70(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_10003A70(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_1000E610(v5) )
        {
          sub_1000BEB0(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_1000BE60(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_1000E610(v5) )
        {
          sub_1000BEF0(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_10003A70(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_10003A70(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_10002900(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10002790(a1, v6);
    if ( !v6 || !v17 || !sub_10002470(a1, v17) )
    {
      v18 = sub_10002540(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_10002900(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_10002470(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_10002900(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_10002900(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_10002900(a1, (int)&i, 204);
  }
}

//----- (1000C2D0) --------------------------------------------------------
void __cdecl sub_1000C2D0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_1000BF20(a1, a2, a3, a4, 0);
}

//----- (1000C2F0) --------------------------------------------------------
signed int __cdecl sub_1000C2F0(int a1)
{
  signed int result; // eax@1
  unsigned __int16 v2; // cx@2

  result = *(_DWORD *)(a1 + 32);
  if ( !result )
  {
    v2 = *(_WORD *)(a1 + 14);
    if ( v2 < 0x18u )
      result = 1 << v2;
  }
  return result;
}

//----- (1000C310) --------------------------------------------------------
int __cdecl sub_1000C310(unsigned int a1, _DWORD *a2, void *a3, int a4, int a5)
{
  return sub_100394B0(a1, a3, 4 * a5, *a2 + 4 * a4 + 14, 0) != 4 * a5 ? 0xFFFFFFF1 : 0;
}

//----- (1000C350) --------------------------------------------------------
signed int __cdecl sub_1000C350(unsigned int a1, void *a2, void *a3)
{
  signed int v3; // eax@1
  signed int result; // eax@6

  v3 = sub_100394B0(a1, a2, 14, 0, 0);
  if ( v3 == 14 )
    v3 = sub_100394B0(a1, a3, 40, 14, 0);
  if ( v3 != 40 || *(_DWORD *)a3 != 40 || *(_WORD *)a2 != 19778 )
    result = -16;
  else
    result = 0;
  return result;
}

//----- (1000C3B0) --------------------------------------------------------
signed int __cdecl sub_1000C3B0(unsigned int a1, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // esi@4
  unsigned __int8 v5; // cl@6
  __int64 v6; // rax@6
  int v7; // eax@6
  __int16 v8; // ax@12
  signed int v9; // edi@22
  unsigned int v10; // ebx@22
  int v11; // eax@22
  unsigned int v12; // ecx@22
  int v13; // ecx@25
  unsigned int v15; // esi@35
  int v16; // ebp@40
  signed int v17; // ebx@42
  unsigned int v18; // eax@43
  unsigned int v19; // eax@44
  unsigned int v20; // edx@44
  int v21; // ebx@46
  signed int v22; // esi@46
  int v23; // edi@46
  char v24; // bp@47
  int v25; // eax@48
  bool v26; // sf@60
  unsigned __int8 v27; // of@60
  unsigned int v28; // esi@64
  unsigned int v29; // eax@65
  signed int v30; // [sp+10h] [bp-3088h]@21
  char *v31; // [sp+14h] [bp-3084h]@1
  int v32; // [sp+18h] [bp-3080h]@2
  char *v33; // [sp+1Ch] [bp-307Ch]@28
  signed int v34; // [sp+20h] [bp-3078h]@24
  signed int v35; // [sp+24h] [bp-3074h]@42
  char v36; // [sp+28h] [bp-3070h]@22
  int v37; // [sp+2Ch] [bp-306Ch]@22
  char *v38; // [sp+30h] [bp-3068h]@25
  int v39; // [sp+34h] [bp-3064h]@24
  int v40; // [sp+38h] [bp-3060h]@25
  int v41; // [sp+3Ch] [bp-305Ch]@40
  int v42; // [sp+40h] [bp-3058h]@23
  int v43; // [sp+44h] [bp-3054h]@22
  signed int v44; // [sp+48h] [bp-3050h]@40
  unsigned __int16 v45; // [sp+4Ch] [bp-304Ch]@22
  int v46; // [sp+54h] [bp-3044h]@43
  unsigned int v47; // [sp+58h] [bp-3040h]@44
  int v48; // [sp+5Ch] [bp-303Ch]@43
  int v49; // [sp+60h] [bp-3038h]@43
  int v50; // [sp+68h] [bp-3030h]@43
  int v51; // [sp+70h] [bp-3028h]@43
  int v52; // [sp+74h] [bp-3024h]@46
  char v53; // [sp+78h] [bp-3020h]@59
  char v54; // [sp+98h] [bp-3000h]@35

  v3 = a2;
  v31 = 0;
  if ( *(_WORD *)(a2 + 14) < 0x18u )
    v32 = *(_DWORD *)(a2 + 68);
  else
    v32 = 0;
  v4 = a3;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)a3 = *(_DWORD *)(a2 + 56);
  *(_WORD *)(a3 + 4) = abs(*(_DWORD *)(a2 + 8));
  *(_WORD *)(a3 + 6) = *(_WORD *)(a2 + 4);
  *(_BYTE *)(a3 + 8) = *(_BYTE *)(a2 + 64);
  if ( !*(_BYTE *)(a2 + 64) )
    *(_BYTE *)(a3 + 8) = *(_BYTE *)(a2 + 14);
  v5 = *(_BYTE *)(a3 + 8);
  v6 = *(_WORD *)(a3 + 6) * *(_BYTE *)(a3 + 8) + 31;
  v7 = 4 * (((BYTE4(v6) & 0x1F) + (signed int)v6) >> 5);
  *(_BYTE *)(a3 + 9) = 0;
  *(_WORD *)(a3 + 10) = v7;
  if ( *(_WORD *)(a2 + 40) == 19778
    && *(_DWORD *)a2 == 40
    && (unsigned __int16)v7 <= 0x3000u
    && *(_WORD *)(a2 + 12) == 1
    && !*(_DWORD *)(a2 + 16)
    && *(_DWORD *)(a2 + 4)
    && ((v8 = *(_WORD *)(a2 + 14), v8 == 8) || v8 == 4 || v8 == 2 || v8 == 1 || v8 == 32 || v8 == 24)
    && (v5 == 8 || v32 || v8 == v5) )
  {
    v30 = sub_100396D0(a1, *(_DWORD *)(a2 + 50), 0);
    if ( v30 != *(_DWORD *)(a2 + 50) )
      return -16;
    v45 = *(_WORD *)(a2 + 14);
    v9 = v45;
    v37 = *(_WORD *)(a2 + 4);
    v10 = (unsigned __int16)(4 * ((v37 * v45 + 31) / 32));
    v11 = abs(*(_DWORD *)(a2 + 8));
    v12 = *(_DWORD *)(a2 + 60);
    v36 = *(_WORD *)(a2 + 14);
    v43 = (unsigned __int16)v11;
    if ( v10 * (unsigned __int16)v11 > v12
      || (v42 = *(_WORD *)(a3 + 10), (unsigned int)(unsigned __int16)v11 * v42 > v12) )
    {
      sub_1000D9C0("..\\lib\\adl\\bmp_file.c", 977, 0, 0);
      return -15;
    }
    v34 = 0;
    v39 = 0;
    if ( (signed int)(unsigned __int16)v11 > 0 )
    {
      v30 = 0;
      v38 = *(char **)a3;
      v13 = *(_DWORD *)a3 + v42 * ((unsigned __int16)v11 - 1);
      v40 = *(_DWORD *)a3 + v42 * ((unsigned __int16)v11 - 1);
      while ( 1 )
      {
        v34 -= v10;
        if ( *(_DWORD *)(v3 + 8) >= 0 )
          v33 = (char *)v13;
        else
          v33 = v38;
        if ( v45 != *(_BYTE *)(v4 + 8) || v32 )
        {
          if ( v34 > 0 )
          {
            v31 += v10;
          }
          else
          {
            v15 = v10 * (v11 - v39);
            v31 = &v54;
            if ( v15 > 0x3000 )
              v15 = v10 * (0x3000 / v10);
            v34 = sub_10039460(a1, &v54, v15);
            if ( v34 != v15 )
              return -16;
          }
          v44 = -1;
          v16 = 32 / v9;
          v41 = 32 / v9;
          if ( (unsigned __int8)v33 & 3 || (unsigned __int8)v31 & 3 )
          {
            v17 = 0;
          }
          else
          {
            v17 = 0;
            v35 = 0;
            if ( v37 >= v16 )
            {
              v50 = -32 / v9;
              v49 = 32 / v9 / 4;
              v18 = 0;
              v48 = 0;
              v51 = v16 * v9;
              v46 = v37;
              do
              {
                v19 = v18 >> 5;
                v20 = *(_DWORD *)&v31[4 * v19];
                v47 = *(_DWORD *)&v31[4 * v19];
                if ( v44 != v20 || !v17 )
                {
                  v21 = 0;
                  v22 = 0;
                  v44 = *(_DWORD *)&v31[4 * v19];
                  v52 = 8 - v9;
                  v23 = 8 - v9;
                  if ( v16 > 0 )
                  {
                    v24 = 0;
                    do
                    {
                      v25 = ((1 << v36) - 1) & (v20 >> v23);
                      if ( v23 )
                      {
                        v23 -= v45;
                      }
                      else
                      {
                        v23 = v52;
                        v20 >>= 8;
                        v47 = v20;
                      }
                      if ( v32 )
                        v25 = *(_BYTE *)(v25 + v32);
                      ++v22;
                      v21 |= v25 << 8 * v24;
                      v24 = v22 & 3;
                      if ( !(v22 & 3) )
                      {
                        v20 = v47;
                        *(&v52 + v22 / 4) = v21;
                        v21 = 0;
                      }
                    }
                    while ( v22 < v41 );
                    v16 = v41;
                  }
                  v9 = v45;
                  v17 = v35;
                }
                if ( v49 > 0 )
                {
                  qmemcpy(&v33[4 * (v17 / 4)], &v53, 4 * v49);
                  v9 = v45;
                }
                v18 = v51 + v48;
                v17 += v16;
                v27 = __OFSUB__(v50 + v46, v16);
                v26 = v50 + v46 - v16 < 0;
                v35 = v17;
                v48 += v51;
                v46 += v50;
              }
              while ( !(v26 ^ v27) );
            }
          }
          if ( v17 < v37 )
          {
            v28 = v17 * v9;
            do
            {
              v29 = ((1 << v9) - 1) & ((unsigned __int8)v31[v28 >> 3] >> (8 - (v17 * v45 & 7) - v45));
              if ( v32 )
                LOBYTE(v29) = *(_BYTE *)(v29 + v32);
              v33[v17++] = v29;
              v28 += v9;
            }
            while ( v17 < v37 );
          }
          v10 = (unsigned __int16)(4 * ((v37 * v45 + 31) / 32));
          v3 = a2;
          v4 = a3;
        }
        else
        {
          v34 = sub_10039460(a1, v33, v10);
          if ( v34 != v10 )
            return -16;
        }
        v38 += v42;
        v40 -= v42;
        if ( ++v39 >= v43 )
          goto LABEL_72;
        v13 = v40;
        v11 = v43;
      }
    }
    if ( !v30 )
    {
LABEL_72:
      if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
        return sub_1000D3A0(a1, 0) == 0;
    }
  }
  else
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    v30 = -15;
  }
  return v30;
}

//----- (1000C900) --------------------------------------------------------
signed int __cdecl sub_1000C900(unsigned int a1, _DWORD *a2, int a3, signed int a4)
{
  signed int v4; // ebx@1
  int v5; // ebp@2
  int v6; // edi@3
  int v7; // esi@6
  int *v8; // ebx@7
  int v9; // ebp@7
  signed int result; // eax@11
  int v11; // [sp+4h] [bp-448h]@2
  signed int v12; // [sp+8h] [bp-444h]@1
  char v13; // [sp+Ch] [bp-440h]@5
  char v14; // [sp+4Ch] [bp-400h]@2

  v4 = sub_1000C2F0((int)a2);
  v12 = v4;
  if ( v4 > a4 )
  {
    result = -15;
  }
  else
  {
    sub_10039CD0((int)&v14, 0x100u);
    v5 = 0;
    v11 = 0;
    if ( v4 <= 0 )
    {
      result = 0;
    }
    else
    {
      while ( 1 )
      {
        v6 = v4 - v5;
        if ( (unsigned int)(v4 - v5) > 0x10 )
          v6 = 16;
        if ( sub_1000C310(a1, a2, &v13, v5, v6) )
          break;
        v7 = 0;
        if ( v6 > 0 )
        {
          v8 = (int *)&v13;
          v9 = a3 + v5;
          do
          {
            *(_BYTE *)(v7++ + v9) = sub_10039C00(*v8, (int)&v14, 0x100u);
            ++v8;
          }
          while ( v7 < v6 );
          v4 = v12;
          v5 = v11;
        }
        v5 += v6;
        v11 = v5;
        if ( v5 >= v4 )
          return 0;
      }
      result = -15;
    }
  }
  return result;
}

//----- (1000CA00) --------------------------------------------------------
signed int __cdecl sub_1000CA00(unsigned int a1, int *a2, int a3, char a4)
{
  signed int result; // eax@1
  int v5; // edx@3
  char v6; // [sp+8h] [bp-14Ch]@1
  char v7; // [sp+30h] [bp-124h]@1
  int v8; // [sp+40h] [bp-114h]@3
  int v9; // [sp+44h] [bp-110h]@3
  char v10; // [sp+48h] [bp-10Ch]@3
  char *v11; // [sp+4Ch] [bp-108h]@3
  char v12; // [sp+50h] [bp-104h]@2

  memset(&v6, 0, 0x48u);
  result = sub_1000C350(a1, &v7, &v6);
  if ( !result )
  {
    result = sub_1000C900(a1, &v6, (int)&v12, 256);
    if ( !result )
    {
      v5 = *a2;
      v9 = a3;
      v8 = v5;
      v10 = a4;
      v11 = &v12;
      result = sub_1000C3B0(a1, (int)&v6, (int)a2);
    }
  }
  return result;
}

//----- (1000CAB0) --------------------------------------------------------
void sub_1000CAB0()
{
  dword_1077A5EC = -15;
}
// 1077A5EC: using guessed type int dword_1077A5EC;

//----- (1000CAC0) --------------------------------------------------------
_BYTE *__cdecl sub_1000CAC0(_BYTE *a1, const char *a2, _BYTE *a3, signed int a4)
{
  const char *v4; // ebx@1
  signed int v5; // ebp@1
  _BYTE *v6; // esi@1
  _BYTE *v7; // edi@1
  _BYTE *result; // eax@4
  char v9; // cl@6
  const char *i; // edx@6

  v4 = a2;
  v5 = a4;
  v6 = a1;
  v7 = a3;
  if ( !a2 )
    v4 = " \n\r\t";
  if ( a1 )
  {
    if ( *a1 )
    {
      do
      {
        v9 = *v4;
        for ( i = v4; v9; v9 = (i++)[1] )
        {
          if ( *v6 == v9 )
            break;
        }
        if ( v5 > 1 && !*i )
        {
          *v7++ = *v6;
          --v5;
        }
        ++v6;
      }
      while ( !*i && *v6 );
    }
    *v7 = 0;
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000CB40) --------------------------------------------------------
char *__cdecl sub_1000CB40(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_1077A640[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_1077A648];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_1077A644];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_1077A648];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_1077A600)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A640: using guessed type int dword_1077A640[];
// 1077A644: using guessed type __int16 word_1077A644[];
// 1077A648: using guessed type int dword_1077A648[];
// 1000CB40: using guessed type char var_20[28];

//----- (1000CC00) --------------------------------------------------------
signed int sub_1000CC00()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_1077A604 = 0;
  dword_1077A608 = 0xFFFFFF;
  byte_1077A5F4 = 0;
  dword_1077A5F8 = 0xFFFFFF;
  return result;
}
// 1077A5F4: using guessed type char byte_1077A5F4;
// 1077A5F8: using guessed type int dword_1077A5F8;
// 1077A604: using guessed type char byte_1077A604;
// 1077A608: using guessed type int dword_1077A608;

//----- (1000CC20) --------------------------------------------------------
int sub_1000CC20()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_1077A600 + 16))();
  byte_1077A5FC = (_BYTE)result == 0;
  return result;
}
// 1077A5FC: using guessed type char byte_1077A5FC;
// 1077A600: using guessed type int dword_1077A600;

//----- (1000CC80) --------------------------------------------------------
int sub_1000CC80()
{
  int result; // eax@1

  *(_DWORD *)(dword_1077AE90 + 20812) = 1000;
  *(_DWORD *)(dword_1077AE90 + 20816) = dword_1077A6A8 + *(_DWORD *)(dword_1077AE90 + 20812);
  *(_DWORD *)(dword_1077AE90 + 20820) = dword_1077A708 + *(_DWORD *)(dword_1077AE90 + 20816);
  *(_DWORD *)(dword_1077AE90 + 20824) = dword_1077A738 + *(_DWORD *)(dword_1077AE90 + 20820);
  result = dword_1077AE90;
  *(_DWORD *)(dword_1077AE90 + 20828) = dword_1077A780 + *(_DWORD *)(dword_1077AE90 + 20824);
  return result;
}
// 1077A6A8: using guessed type int dword_1077A6A8;
// 1077A708: using guessed type int dword_1077A708;
// 1077A738: using guessed type int dword_1077A738;
// 1077A780: using guessed type int dword_1077A780;
// 1077AE90: using guessed type int dword_1077AE90;

//----- (1000CCF0) --------------------------------------------------------
char *sub_1000CCF0()
{
  sub_1000CB40(0x40u);
  sub_1000CB40(0x39u);
  sub_1000CB40(0x33u);
  sub_1000CB40(0x31u);
  sub_1000CB40(0x32u);
  sub_1000CB40(0x4Eu);
  sub_1000CB40(0x4Fu);
  sub_1000CB40(0x3Du);
  sub_1000CB40(0x3Eu);
  sub_1000CB40(0x45u);
  return sub_1000CB40(0x38u);
}
// 1077AE90: using guessed type int dword_1077AE90;

//----- (1000CDC0) --------------------------------------------------------
int __cdecl sub_1000CDC0(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_1067C330, a1, 0x1Cu);
  dword_1077A600 = (int)dword_1067C330;
  dword_1077AE90 = (int)&unk_1067C350;
  memset(&unk_1067C350, 0, 0x516Cu);
  dword_1067C330[5](dword_1077AE90 + 20832, dword_1077AE90 + 20833, dword_1077AE90 + 20836);
  (*(void (__cdecl **)(int))(dword_1077A600 + 24))(dword_1077AE90 + 20840);
  sub_10013D90();
  sub_10013A20();
  sub_10013BD0();
  sub_10013AF0();
  sub_1000CCF0();
  sub_1000CC00();
  sub_1000D220();
  sub_1000CE70();
  sub_1000CC20();
  sub_1000CC80();
  *(_DWORD *)(dword_1077AE90 + 20800) = 0;
  *(_DWORD *)(dword_1077AE90 + 20804) = dword_1077A828;
  result = dword_1077AE90;
  *(_DWORD *)(dword_1077AE90 + 20808) = dword_1077A834 + *(_DWORD *)(dword_1077AE90 + 20804);
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A828: using guessed type int dword_1077A828;
// 1077A834: using guessed type int dword_1077A834;
// 1077AE90: using guessed type int dword_1077AE90;

//----- (1000CE70) --------------------------------------------------------
int sub_1000CE70()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10015210(0x4Du, 1u) )
  {
    result = dword_1077A9DC;
    dword_10681550 = dword_1077A9DC;
    if ( dword_1077A9DC )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1077A600)(dword_1077A9DC, 8, &v1);
      word_10681548 = v1;
      result = v3 & 0x1FF;
      dword_10681550 += (unsigned __int16)word_1077A9E0;
      word_1068154C = v2 & 0x1FF;
      word_10681544 = v3 & 0x1FF;
    }
  }
  else
  {
    word_10681548 = 6;
    word_1068154C = 6;
    result = dword_1077A85C;
    word_10681544 = 60;
    dword_10681550 = dword_1077A85C;
  }
  return result;
}
// 10681544: using guessed type __int16 word_10681544;
// 10681548: using guessed type __int16 word_10681548;
// 1068154C: using guessed type __int16 word_1068154C;
// 10681550: using guessed type int dword_10681550;
// 1077A600: using guessed type int dword_1077A600;
// 1077A85C: using guessed type int dword_1077A85C;
// 1077A9DC: using guessed type int dword_1077A9DC;
// 1077A9E0: using guessed type __int16 word_1077A9E0;

//----- (1000CF10) --------------------------------------------------------
int __cdecl sub_1000CF10(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10015250(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (1000CF40) --------------------------------------------------------
int sub_1000CF40()
{
  return (*(int (**)(void))(dword_1077A600 + 8))();
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1000CF50) --------------------------------------------------------
int __fastcall sub_1000CF50(unsigned __int8 a1)
{
  return dword_1077A844 + a1 * (unsigned __int16)word_1077A848;
}
// 1077A844: using guessed type int dword_1077A844;
// 1077A848: using guessed type __int16 word_1077A848;

//----- (1000CF70) --------------------------------------------------------
int __fastcall sub_1000CF70(unsigned __int8 a1)
{
  return dword_1077A850 + a1 * (unsigned __int16)word_1077A854;
}
// 1077A850: using guessed type int dword_1077A850;
// 1077A854: using guessed type __int16 word_1077A854;

//----- (1000CF90) --------------------------------------------------------
void *__cdecl sub_1000CF90(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_1000CF10(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_1000CF50(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_1077A600)(v3, 22, &v7);
      result = (void *)sub_10013B50(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1000D060) --------------------------------------------------------
int __cdecl sub_1000D060(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_1000CF50(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1077A600)(v2, 22, &v22);
    sub_10013B50((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_1000CF70(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_1077A600)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10013B50((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_1077A600 + 12))(a1);
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1000D220) --------------------------------------------------------
char sub_1000D220()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_1000CF40();
  sub_1000CF10(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_1000CF90(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10015250(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_1000CF90(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_1000D060((int)&v8);
  }
  return v0;
}

//----- (1000D380) --------------------------------------------------------
signed int __cdecl sub_1000D380(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_1000F8D0(a1);
  return sub_10010E80(v1);
}

//----- (1000D3A0) --------------------------------------------------------
bool __cdecl sub_1000D3A0(unsigned int a1, _DWORD *a2)
{
  bool result; // al@3
  unsigned int v3; // [sp+4h] [bp+4h]@1

  v3 = sub_1000F8D0(a1);
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    result = sub_10011360(v3, *(_DWORD *)(v3 + 44), 0) == *(_DWORD *)(v3 + 44) && sub_1000F900(v3);
    if ( a2 )
      *a2 = *(_DWORD *)(v3 + 36);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000D3E0) --------------------------------------------------------
signed int __cdecl sub_1000D3E0(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_1000F8D0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10011360(v4, a4, 0) == a4 )
      result = sub_10011300(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1000D440) --------------------------------------------------------
signed int __cdecl sub_1000D440(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_1000F8D0(a1);
  return sub_10011360(v3, a2, a3);
}

//----- (1000D460) --------------------------------------------------------
void __cdecl sub_1000D460(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (1000D4B0) --------------------------------------------------------
char __cdecl sub_1000D4B0(const char *a1, const char *a2)
{
  unsigned int v2; // ecx@4
  int v3; // esi@4
  unsigned int v4; // edx@4
  const char *v5; // edx@5
  char result; // al@8

  if ( a1 && a2 )
  {
    if ( strlen(a2) > strlen(a1) )
    {
      result = 0;
    }
    else
    {
      v2 = strlen(a2);
      v3 = v2 - 1;
      v4 = strlen(a1);
      if ( ((v2 - 1) & 0x80000000) != 0 )
      {
LABEL_8:
        result = 1;
      }
      else
      {
        v5 = &a1[v3] + v4 - v2;
        while ( *v5 == a2[v3] )
        {
          --v3;
          --v5;
          if ( v3 < 0 )
            goto LABEL_8;
        }
        result = 0;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000D560) --------------------------------------------------------
int __cdecl sub_1000D560(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1000D5B0) --------------------------------------------------------
signed int __cdecl sub_1000D5B0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (1000D620) --------------------------------------------------------
int __cdecl sub_1000D620(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1000D650) --------------------------------------------------------
int __cdecl sub_1000D650(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1000D6B0) --------------------------------------------------------
int __cdecl sub_1000D6B0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000D6F0) --------------------------------------------------------
int sub_1000D6F0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1000D6B0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1000D720) --------------------------------------------------------
int __cdecl sub_1000D720(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1000D560((int)&a1[v3], a2, a3 - v3);
}

//----- (1000D760) --------------------------------------------------------
int __cdecl sub_1000D760(int a1, int a2)
{
  return sub_1000D650(a1, "_ ", a2);
}

//----- (1000D780) --------------------------------------------------------
char *__cdecl sub_1000D780(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_100382C0();
  *(_DWORD *)(a5 + 596) = sub_10038330();
  sub_10038350((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1000D560(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_100135C0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (1000D8B0) --------------------------------------------------------
char sub_1000D8B0()
{
  char result; // al@1

  result = 0;
  byte_10694208 = 0;
  byte_10694209 = 0;
  return result;
}
// 10694208: using guessed type char byte_10694208;
// 10694209: using guessed type char byte_10694209;

//----- (1000D8C0) --------------------------------------------------------
char __cdecl sub_1000D8C0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_1000D780(-5, a1, a2, a4, a5);
  else
    sub_1000D780(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1000D720((const char *)(a5 + 485), " DBGA", 100);
  sub_10038350((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10694208 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10694209 )
LABEL_15:
      result = sub_10038390(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10039CB0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10694208: using guessed type char byte_10694208;
// 10694209: using guessed type char byte_10694209;

//----- (1000D9C0) --------------------------------------------------------
char __cdecl sub_1000D9C0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_1000D8C0(a1, a2, a3, a4, (int)&v5);
}

//----- (1000DA30) --------------------------------------------------------
char __cdecl sub_1000DA30(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char *v5; // eax@1

  v5 = sub_10016E20(*a4);
  return sub_1000DAA0(a1, a2, a3, (int)v5, a5);
}

//----- (1000DA50) --------------------------------------------------------
int __usercall sub_1000DA50@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (1000DAA0) --------------------------------------------------------
char __cdecl sub_1000DAA0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_1000DA50((int)&v8, a3, a2);
      sub_1000F740(a1, a4, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_1000DA50((int)&v8, a3, a2);
  sub_1000F860(a1, a4, v7);
  return 2;
}

//----- (1000DB20) --------------------------------------------------------
int __usercall sub_1000DB20@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned __int16 v3; // si@1
  unsigned __int16 v4; // di@1
  signed int v5; // ebp@2
  signed int v6; // ebx@2
  float v7; // ST58_4@2
  __int16 v8; // ax@2
  bool v9; // dl@2
  float v10; // ST50_4@2
  double v11; // st6@2
  double v12; // st4@7
  double v13; // st5@9
  double v14; // st4@10
  double v15; // st6@10
  float v16; // ST60_4@10
  float v17; // ST60_4@14
  float v18; // ST4C_4@16
  float v19; // ST50_4@16
  float v20; // ST48_4@16
  float v21; // ST50_4@16
  float v22; // ST60_4@16
  float v23; // ST60_4@16
  float v24; // [sp+24h] [bp-44h]@2
  float v25; // [sp+28h] [bp-40h]@2
  float v26; // [sp+2Ch] [bp-3Ch]@2
  float v27; // [sp+2Ch] [bp-3Ch]@9
  float v28; // [sp+30h] [bp-38h]@6
  float v29; // [sp+30h] [bp-38h]@13
  float v30; // [sp+34h] [bp-34h]@2
  float v31; // [sp+38h] [bp-30h]@2
  float v32; // [sp+3Ch] [bp-2Ch]@2
  float v33; // [sp+40h] [bp-28h]@2
  signed int v34; // [sp+44h] [bp-24h]@2
  char v35; // [sp+4Ch] [bp-1Ch]@16
  float v36; // [sp+50h] [bp-18h]@16
  float v37; // [sp+54h] [bp-14h]@16
  float v38; // [sp+58h] [bp-10h]@16
  float v39; // [sp+5Ch] [bp-Ch]@16
  float v40; // [sp+60h] [bp-8h]@16
  float v41; // [sp+64h] [bp-4h]@16

  v3 = *(_WORD *)a2;
  v4 = *(_WORD *)(a2 + 2);
  if ( *(_WORD *)a2 > v4 )
  {
    v5 = -8355712;
    v6 = -8355712;
    v24 = (double)*(_WORD *)result;
    v25 = *(float *)(a3 + 4) + v24;
    v32 = (double)*(_WORD *)(result + 2);
    v7 = *(float *)(a3 + 8) + v32;
    v8 = *(_WORD *)(a2 + 4);
    v33 = v7 - 7.0;
    v34 = *(_WORD *)(a2 + 4);
    v9 = v34 == (signed __int16)(v3 - v4 + 1) - 1;
    v10 = v32 + 7.0;
    v31 = v10 + 3.0;
    v30 = v33 - 3.0;
    v11 = v31;
    v26 = v30 - v31;
    if ( !v8 )
      v5 = -12566464;
    if ( v9 )
      v6 = -12566464;
    v28 = (double)v4 / (double)v3 * v26;
    if ( v28 > 3.0 )
      v12 = v28;
    else
      v12 = (float)3.0;
    v13 = v12;
    v27 = (v26 - v12) * (double)v34 / (double)((signed __int16)(v3 - v4 + 1) - 1) + v11;
    if ( v8 == 0 )
    {
      v15 = 1.0;
    }
    else
    {
      v14 = v11 + 1.0;
      v15 = 1.0;
      v16 = v14;
      if ( v16 >= (double)v27 )
        v27 = v14;
    }
    v29 = v13 + v27;
    if ( !v9 )
    {
      v17 = v30 - v15;
      if ( v17 <= (double)v29 )
        v29 = v30 - v15;
    }
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(v5);
    v36 = v24;
    v37 = v32;
    v35 = 0;
    v38 = v25 - v24;
    v39 = 7.0;
    v40 = 0.0;
    v41 = 0.0;
    sub_1000F200(5u, (int)&v35);
    j_gdi_pvg_color_u32(v6);
    v37 = v33;
    v35 = 2;
    sub_1000F200(5u, (int)&v35);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    sub_10038180(v24, v31);
    sub_10038180(v25, v31);
    sub_10038180(v25, v30);
    sub_10038180(v24, v30);
    j_gdi_pvg_end();
    sub_1000F100(9, v24, v31, v25, v30, -8355712);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-8355712);
    sub_10038180(v24, v27);
    sub_10038180(v25, v27);
    sub_10038180(v25, v29);
    sub_10038180(v24, v29);
    j_gdi_pvg_end();
    sub_10037F60(1.0);
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    sub_10038180(v24, v29);
    sub_10038180(v24, v27);
    sub_10038180(v25, v27);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-14671840);
    v18 = v27 + 1.0;
    sub_10038180(v25, v18);
    sub_10038180(v25, v29);
    v19 = v24 + 1.0;
    sub_10038180(v19, v29);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-1);
    v20 = v29 - 1.0;
    sub_10038180(v19, v20);
    sub_10038180(v19, v18);
    v21 = v25 - 1.0;
    sub_10038180(v21, v18);
    j_gdi_pvg_end();
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    v22 = v27 + 2.0;
    sub_10038180(v21, v22);
    sub_10038180(v21, v20);
    v23 = v24 + 2.0;
    sub_10038180(v23, v20);
    j_gdi_pvg_end();
    result = j_gdi_pvg_disable(35);
  }
  return result;
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E00: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000DFF0) --------------------------------------------------------
char __cdecl sub_1000DFF0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == -32648 )
  {
    sub_1000DB20(a3, a4, a2);
    result = 2;
  }
  return result;
}

//----- (1000E020) --------------------------------------------------------
char __cdecl sub_1000E020(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@3
  signed int v6; // ecx@4
  signed int v7; // edx@4
  signed int v8; // eax@4
  float v9; // ST1C_4@5
  float v10; // ST20_4@5
  double v11; // st7@5
  float v12; // ST0C_4@7
  float v13; // [sp+4h] [bp-24h]@5
  float v14; // [sp+Ch] [bp-1Ch]@4
  float v15; // [sp+10h] [bp-18h]@4
  float v16; // [sp+14h] [bp-14h]@4
  float v17; // [sp+18h] [bp-10h]@4
  float v18; // [sp+1Ch] [bp-Ch]@4
  float v19; // [sp+20h] [bp-8h]@4
  float v20; // [sp+24h] [bp-4h]@4
  float v21; // [sp+3Ch] [bp+14h]@4

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v7 = *(_WORD *)a3;
    v14 = *(float *)(a2 + 20) + (double)v6;
    v16 = (double)v7;
    v21 = *(float *)(a2 + 16) + (double)v7;
    v15 = (double)v6;
    v20 = v14 - *(float *)(a2 + 24);
    v18 = *(float *)(a2 + 24) + v16;
    v19 = v21 - *(float *)(a2 + 24);
    v17 = *(float *)(a2 + 24) + v15;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v8 = sub_10013EC0(*(_DWORD *)(a2 + 8));
    j_gdi_pvg_color_u32(v8);
    if ( 1.0 == *(float *)(a2 + 24) )
    {
      j_gdi_pvg_begin(66);
      v9 = v15 + 0.5;
      v10 = v16 + 0.5;
      sub_10038180(v10, v9);
      sub_10038180(v21, v9);
      sub_10038180(v21, v14);
      v13 = v14;
      v11 = v10;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_10038180(v16, v15);
      sub_10038180(v18, v17);
      sub_10038180(v21, v15);
      sub_10038180(v19, v17);
      sub_10038180(v21, v14);
      sub_10038180(v19, v20);
      sub_10038180(v16, v14);
      sub_10038180(v18, v20);
      sub_10038180(v16, v15);
      v13 = v17;
      v11 = v18;
    }
    v12 = v11;
    sub_10038180(v12, v13);
    j_gdi_pvg_end();
    if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 12));
      sub_10038180(v18, v17);
      sub_10038180(v19, v17);
      sub_10038180(v19, v20);
      sub_10038180(v18, v20);
      j_gdi_pvg_end();
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E00: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000E2A0) --------------------------------------------------------
char __cdecl sub_1000E2A0(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_10779FC0[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (1000E310) --------------------------------------------------------
_DWORD *__cdecl sub_1000E310(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (1000E320) --------------------------------------------------------
int __cdecl sub_1000E320(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (1000E350) --------------------------------------------------------
_DWORD *__cdecl sub_1000E350(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (1000E360) --------------------------------------------------------
char __cdecl sub_1000E360(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (1000E390) --------------------------------------------------------
char __cdecl sub_1000E390(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (1000E3C0) --------------------------------------------------------
bool __cdecl sub_1000E3C0(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_10779FC4[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (1000E410) --------------------------------------------------------
char __cdecl sub_1000E410(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_1000E3C0(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_1000E3C0(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (1000E470) --------------------------------------------------------
int __cdecl sub_1000E470(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_1000E3C0(a3, &v8, 0);
  sub_100026B0(a1, *(char **)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_10779FC0[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (1000E4E0) --------------------------------------------------------
char __cdecl sub_1000E4E0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_1000D9C0("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_1000E390(a1, v7, (int)v3);
    sub_1000E3C0(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100026B0(a1, v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_10779FC0[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (1000E590) --------------------------------------------------------
int __cdecl sub_1000E590(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_10015280(&a1, 4u, (int)&unk_10063198, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_1000D9C0(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_1006319C + 2 * v2);
}
// 1006319C: using guessed type void *off_1006319C;

//----- (1000E610) --------------------------------------------------------
BOOL __thiscall sub_1000E610(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10039740(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (1000E630) --------------------------------------------------------
char __thiscall sub_1000E630(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_100387F0(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E660) --------------------------------------------------------
int sub_1000E660()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_100387F0(3012, &v2, 4, &v1);
  return v2;
}

//----- (1000E690) --------------------------------------------------------
char __cdecl sub_1000E690(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B290: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 1003B296: using guessed type int SYS_enter_krnl(void);

//----- (1000E6B0) --------------------------------------------------------
int __cdecl sub_1000E6B0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_1000D9C0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_1000D9C0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B29C: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1000E710) --------------------------------------------------------
char __thiscall sub_1000E710(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000E6B0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000E730) --------------------------------------------------------
char __thiscall sub_1000E730(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000E6B0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000E750) --------------------------------------------------------
char __thiscall sub_1000E750(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000E6B0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000E770) --------------------------------------------------------
char __thiscall sub_1000E770(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000E6B0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000E790) --------------------------------------------------------
char sub_1000E790()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_1000E6B0(48, &v1);
  return v1;
}

//----- (1000E7B0) --------------------------------------------------------
int __cdecl sub_1000E7B0(char a1)
{
  return sub_1000E6B0(56, &a1);
}

//----- (1000E7C0) --------------------------------------------------------
int __cdecl sub_1000E7C0(char a1)
{
  return sub_1000E6B0(63, &a1);
}

//----- (1000E7D0) --------------------------------------------------------
char __cdecl sub_1000E7D0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000E810) --------------------------------------------------------
char __cdecl sub_1000E810(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_1000D9C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1000E880) --------------------------------------------------------
signed int __cdecl sub_1000E880(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_1000D9C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000E900) --------------------------------------------------------
char __cdecl sub_1000E900(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_1000D9C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1000E970) --------------------------------------------------------
char __cdecl sub_1000E970(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_1000D9C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1000EA20) --------------------------------------------------------
char __cdecl sub_1000EA20(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_1000D9C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1000EB20) --------------------------------------------------------
char __thiscall sub_1000EB20(void *this)
{
  int v1; // eax@1

  v1 = sub_10014FF0(this);
  return sub_1000EA20(v1);
}

//----- (1000EB30) --------------------------------------------------------
int __cdecl sub_1000EB30(int *a1)
{
  int result; // eax@1

  result = sub_10018DA0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10038330();
    result = sub_10018BE0();
  }
  return result;
}

//----- (1000EB60) --------------------------------------------------------
char __usercall sub_1000EB60@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10038400(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_10019E60("%i %i\r\n", 13, v2);
    sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_100383E0(*(_DWORD *)(a1 + 4));
    v6 = sub_10019E60("%i %i\r\n", 14, v5);
    sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1006436C, (int)v6);
    result = 1;
  }
  else
  {
    sub_1000D9C0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1000EC00) --------------------------------------------------------
int __cdecl sub_1000EC00(const char *a1)
{
  int result; // eax@1

  result = sub_10016F00();
  if ( a1 )
    result = sub_10018DD0(dword_1069420C[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1069420C: using guessed type int dword_1069420C[];

//----- (1000EC40) --------------------------------------------------------
char __cdecl sub_1000EC40(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_10018D20((char *)a1 + 4);
  v1 = sub_1001F780();
  sub_10018CC0((int)v1, 0, 0);
  dword_1069420C[sub_10016F00()] = (int)a1;
  v2 = sub_1001F740((int)sub_1000EC00);
  return sub_10018DF0(v2);
}
// 1069420C: using guessed type int dword_1069420C[];

//----- (1000EC90) --------------------------------------------------------
signed int __cdecl sub_1000EC90(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10038330();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_100384E0(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10038330() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10038570(&v23);
          }
          while ( sub_10038330() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10038310(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10038350((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_10019E60("The %s task is loaded.", &v24);
            sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_10019E60("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_10019E60("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_10019E60(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_100382A0(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_10019E60("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_10019E60("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10019400(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10019400(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10038390(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1001F740((int)sub_1000EC00);
        sub_100194D0((int)v15);
        v16 = sub_10020B20((int)sub_1000EC00);
        sub_100194D0((int)v16);
        v17 = sub_10020B20((int)sub_1000EC00);
        sub_10018DF0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1001F740((int)sub_1000EC00);
        sub_100194D0((int)v18);
        v19 = sub_10020B20((int)sub_1000EC00);
        sub_100194D0((int)v19);
        v20 = sub_1001F740((int)sub_1000EC00);
        sub_10018DF0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1000EB60(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1000F030) --------------------------------------------------------
char **sub_1000F030()
{
  return off_10064358;
}
// 10064358: using guessed type char *off_10064358[3];

//----- (1000F060) --------------------------------------------------------
int __cdecl sub_1000F060(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10694220 = a1;
  return result;
}
// 10694220: using guessed type int dword_10694220;

//----- (1000F070) --------------------------------------------------------
#error "1000F075: call analysis failed (funcsize=28)"

//----- (1000F0A0) --------------------------------------------------------
signed int __cdecl sub_1000F0A0(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_10055A40;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 2 );
  if ( result == 2 )
    result = -1;
  return result;
}
// 10055A40: using guessed type int (__cdecl *off_10055A40)(int);

//----- (1000F0D0) --------------------------------------------------------
char *__cdecl sub_1000F0D0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 2 )
    result = (char *)&unk_1005377D;
  else
    result = &aPowerUpPage[56 * a1];
  return result;
}

//----- (1000F100) --------------------------------------------------------
int __cdecl sub_1000F100(int a1, float a2, float a3, float a4, float a5, int a6)
{
  float v6; // ST1C_4@1
  float v7; // ST18_4@1
  _DWORD *v8; // eax@1

  v6 = (a4 - a2) * 0.0625;
  v7 = 0.0625 * (a5 - a3);
  j_gdi_pvg_enable(34);
  j_gdi_pvg_color_u32(a6);
  v8 = (_DWORD *)sub_10038840(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_10038080(0.0, 0.0);
  sub_10038180(a2, a5);
  sub_10038080(0.0, v7);
  sub_10038180(a2, a3);
  sub_10038080(v6, v7);
  sub_10038180(a4, a3);
  sub_10038080(v6, 0.0);
  sub_10038180(a4, a5);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000F200) --------------------------------------------------------
int __cdecl sub_1000F200(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char *v4; // edi@1
  float v5; // ST28_4@1
  float v6; // ST2C_4@1
  float v7; // ST30_4@1
  _DWORD *v8; // eax@1
  float v10; // [sp+28h] [bp+8h]@1

  v2 = sub_10038840(a1);
  v3 = a2;
  v2 += 4;
  v4 = (char *)&unk_100661F0 + 8 * *(_BYTE *)a2;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 20) * *(float *)(a2 + 12);
  v10 = *(float *)(a2 + 8) - *(float *)(a2 + 24) * *(float *)(a2 + 16);
  v6 = *(float *)(v3 + 12) + v5;
  v7 = *(float *)(v3 + 16) + v10;
  j_gdi_pvg_enable(34);
  sub_100380A0(84, 82, 79.0);
  v8 = (_DWORD *)sub_10038840(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_10038080(*(float *)(v2 + 8 * (unsigned __int8)*v4), *(float *)(v2 + 8 * (unsigned __int8)v4[4] + 4));
  sub_10038180(v5, v10);
  sub_10038080(*(float *)(v2 + 8 * (unsigned __int8)v4[1]), *(float *)(v2 + 8 * (unsigned __int8)v4[5] + 4));
  sub_10038180(v6, v10);
  sub_10038080(*(float *)(v2 + 8 * (unsigned __int8)v4[2]), *(float *)(v2 + 8 * (unsigned __int8)v4[6] + 4));
  sub_10038180(v6, v7);
  sub_10038080(*(float *)(v2 + 8 * (unsigned __int8)v4[3]), *(float *)(v2 + 8 * (unsigned __int8)v4[7] + 4));
  sub_10038180(v5, v7);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000F360) --------------------------------------------------------
int __cdecl sub_1000F360(int a1, int a2)
{
  int v2; // eax@1
  float v3; // ST18_4@1
  float v4; // ST1C_4@1
  float v5; // ST20_4@1
  float v7; // [sp+1Ch] [bp+8h]@1

  v2 = a2;
  v3 = *(float *)(a2 + 4) - *(float *)(a2 + 20) * *(float *)(a2 + 12);
  v7 = *(float *)(a2 + 8) - *(float *)(a2 + 24) * *(float *)(a2 + 16);
  v4 = v3 + *(float *)(v2 + 12);
  v5 = v7 + *(float *)(v2 + 16);
  j_gdi_pvg_enable(34);
  sub_100380A0(84, 82, 79.0);
  j_gdi_pvg_bind_texture(34, a1);
  j_gdi_pvg_begin(72);
  sub_10038080(0.0, 1.0);
  sub_10038180(v3, v7);
  sub_10038080(1.0, 1.0);
  sub_10038180(v4, v7);
  sub_10038080(1.0, 0.0);
  sub_10038180(v4, v5);
  sub_10038080(0.0, 0.0);
  sub_10038180(v3, v5);
  j_gdi_pvg_end();
  return j_gdi_pvg_disable(34);
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037DA0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000F470) --------------------------------------------------------
int __cdecl sub_1000F470(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100026B0(a1, *(char **)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_1000E3C0(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_1000E360(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_1000E390(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_10779FC0[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_1000E3C0(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 10037EF0: using guessed type int j_gdi_pvg_flush(void);
// 10779FC0: using guessed type int dword_10779FC0[];

//----- (1000F5B0) --------------------------------------------------------
int __cdecl sub_1000F5B0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_1000F470(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (1000F5F0) --------------------------------------------------------
void __usercall sub_1000F5F0(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_10038E20(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( LOBYTE(a4) )
  {
    v11 = sub_1003B180(v11, 1.0) + 0.5;
    v12 = sub_1003B220(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (1000F740) --------------------------------------------------------
void __cdecl sub_1000F740(int a1, int a2, int a3)
{
  sub_1000F5F0(a2, a1, a3, COERCE_FLOAT(1));
}

//----- (1000F760) --------------------------------------------------------
int __usercall sub_1000F760@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1

  v4 = a4;
  v5 = a2;
  sub_1000F5F0(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_10038180(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_10038180(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_10038180(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_10038180(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end();
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_10038C80(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 10037D90: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10037E00: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10037E50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10037E70: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10037ED0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10037EE0: using guessed type int j_gdi_pvg_end(void);

//----- (1000F840) --------------------------------------------------------
int __cdecl sub_1000F840(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 1;
  return sub_1000F760(v3, a3, a2, a1);
}

//----- (1000F860) --------------------------------------------------------
int __cdecl sub_1000F860(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_10747D9E || byte_10779FA0) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_1000F840(a1, a2, (int)&v5);
}
// 10747D9E: using guessed type char byte_10747D9E;
// 10779FA0: using guessed type char byte_10779FA0;

//----- (1000F8D0) --------------------------------------------------------
unsigned int __cdecl sub_1000F8D0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (1000F8F0) --------------------------------------------------------
int __cdecl sub_1000F8F0(int a1)
{
  return a1 | 1;
}

//----- (1000F900) --------------------------------------------------------
bool __cdecl sub_1000F900(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (1000F9D0) --------------------------------------------------------
int __cdecl sub_1000F9D0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (1000F9F0) --------------------------------------------------------
int __cdecl sub_1000F9F0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_1000F9D0(a1 + 20);
  return result;
}

//----- (1000FA30) --------------------------------------------------------
bool __cdecl sub_1000FA30(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (1000FA90) --------------------------------------------------------
signed int __cdecl sub_1000FA90(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100394B0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100394B0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (1000FB50) --------------------------------------------------------
signed int __cdecl sub_1000FB50(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_100394B0(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_1000F9F0(0, a3);
    sub_100394B0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_100394B0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000FC00) --------------------------------------------------------
int __cdecl sub_1000FC00(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1000FC20) --------------------------------------------------------
signed int __cdecl sub_1000FC20(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (1000FC80) --------------------------------------------------------
int __usercall sub_1000FC80@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_10039590(v3);
  v10 = sub_100393F0(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_100395B0(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_100395B0(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_10039590(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (1000FD90) --------------------------------------------------------
int __usercall sub_1000FD90@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10025640(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10039590(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100395B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1000FE40) --------------------------------------------------------
signed int __usercall sub_1000FE40@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100395E0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10025A90((void *)(v2 + 555), v7);
  }
  else
  {
    sub_1000FA90(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100394B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100394B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10025960(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100395E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100395E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10010010) --------------------------------------------------------
char __usercall sub_10010010@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_100255F0(a2, a3, a1 + 212);
}

//----- (10010020) --------------------------------------------------------
int __usercall sub_10010020@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_1000FD90(result + 148, result);
  return result;
}

//----- (10010040) --------------------------------------------------------
char __usercall sub_10010040@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10010060) --------------------------------------------------------
int __usercall sub_10010060@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1003B030(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1003B030(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (100100A0) --------------------------------------------------------
int __cdecl sub_100100A0(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_10039590(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_100394B0(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 100100A0: using guessed type char var_84[128];

//----- (10010250) --------------------------------------------------------
int __fastcall sub_10010250(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10010270) --------------------------------------------------------
int __usercall sub_10010270@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (10010280) --------------------------------------------------------
int __usercall sub_10010280@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100396D0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100395B0(v4, v3, 0);
}
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100102C0) --------------------------------------------------------
signed int __usercall sub_100102C0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10010250(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1003B050(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10010010(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_100279F0(a2 + 28, 4);
      else
        v22 = sub_100279F0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10010010(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100104D0) --------------------------------------------------------
int __cdecl sub_100104D0(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_1000FC80((int)a1, v2, 0);
        v3 = sub_10010280((int)a1) | v4;
      }
    }
    sub_10039360(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10010530) --------------------------------------------------------
int __cdecl sub_10010530(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_1000D560((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_10039360(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_10039590(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_100100A0(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_100394B0(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_1000FA30((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10010630) --------------------------------------------------------
signed int __cdecl sub_10010630(int a1)
{
  bool v1; // zf@1
  signed int result; // eax@1

  v1 = sub_1000FA30(a1) == 0;
  result = -15;
  if ( !v1 )
    result = *(_WORD *)(a1 + 16);
  return result;
}

//----- (10010650) --------------------------------------------------------
signed int __cdecl sub_10010650(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_1000FA30(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_100394B0(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_1000D560((int)v6, &unk_1005377D, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_100394B0(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_100394B0(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_1000F9D0(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10010850) --------------------------------------------------------
signed int __cdecl sub_10010850(int a1, int a2)
{
  return sub_1000FB50(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (10010870) --------------------------------------------------------
int __cdecl sub_10010870(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10010020(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_100135C0(&v23);
    sub_10016D20((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_1000F9F0(v1, (int)&v24);
  v13 = sub_10039590(v31);
  if ( v3 == v31 )
  {
    result = sub_100393F0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100396D0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100393F0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100396D0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_1000F9D0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10010280(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10039590(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10010AE0) --------------------------------------------------------
int __cdecl sub_10010AE0(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_1000FC00((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_1000D560((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_10027CB0(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_10029610((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10010BB0) --------------------------------------------------------
signed int __cdecl sub_10010BB0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100396D0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_100102C0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10010C50) --------------------------------------------------------
int __usercall sub_10010C50@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10010040(a1);
  *v3 ^= v2;
  return sub_10010060(v1, *v3);
}

//----- (10010C70) --------------------------------------------------------
int __usercall sub_10010C70@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10010C50(a2);
  return result;
}

//----- (10010CA0) --------------------------------------------------------
signed int __usercall sub_10010CA0@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10010060(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100394B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10010D10) --------------------------------------------------------
int __cdecl sub_10010D10(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_1000FA30(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_10010650(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_1000FC20(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10010E80) --------------------------------------------------------
signed int __cdecl sub_10010E80(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit(a1);
    sub_10028AE0(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10010EE0) --------------------------------------------------------
char __usercall sub_10010EE0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_100255A0(a1, a2, a3 + 212);
  else
    result = sub_10010C70(a2, a3 + 148);
  return result;
}

//----- (10010F10) --------------------------------------------------------
signed int __usercall sub_10010F10@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_1000FE40(v3, v1);
  else
    result = sub_10010CA0(v3, v1);
  return result;
}

//----- (10010F40) --------------------------------------------------------
BOOL __usercall sub_10010F40@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10010C50(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (10010F80) --------------------------------------------------------
signed int __cdecl sub_10010F80(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_1000FC00(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10029700(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10010F10(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10010FD0) --------------------------------------------------------
signed int __cdecl sub_10010FD0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100394B0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10010EE0(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100394B0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10025640(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10010250(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1002AAC0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1003B050(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1003B050(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (100111C0) --------------------------------------------------------
bool __usercall sub_100111C0@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_10010F40(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (100111F0) --------------------------------------------------------
int __cdecl sub_100111F0(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_1000FA30(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10010AE0(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_10010650(a1, v6) )
      return -15;
    sub_10010270(a1, (int)a4);
    if ( sub_10010850((int)a4, (int)&v7) )
    {
      sub_1000D380((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_1000F9F0((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_10010F80((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_100111C0((int)a4) )
    {
      result = sub_1000F8F0((int)a4);
    }
    else
    {
      sub_10010E80((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10011300) --------------------------------------------------------
signed int __cdecl sub_10011300(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10010FD0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_1000F900(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10011360) --------------------------------------------------------
signed int __cdecl sub_10011360(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10010F80(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_1000FC00(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10010F80(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10011300(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (100114F0) --------------------------------------------------------
int __cdecl sub_100114F0(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_1000FA30(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10010AE0(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_1000F9F0((int)a4, 0);
          sub_10010270(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_1000F9F0((int)a4, 0);
          sub_100395E0(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_10010F10((int)a4);
          result = sub_1000F8F0((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10010D10(a1, a2, 0);
      if ( result >= 0 )
        result = sub_100111F0(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10011730) --------------------------------------------------------
int __cdecl sub_10011730(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10011770) --------------------------------------------------------
void *__usercall sub_10011770@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10038660(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_100387B0(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (100117C0) --------------------------------------------------------
signed int sub_100117C0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1077AE98 = 0;
  v4 = 0;
  sub_10039740(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10038730(3201, (int)&v4, 1);
    sub_10039770(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10038730(3201, (int)&v4, 1);
    sub_10039770(94, (int)&v4);
  }
  sub_10011770(1u, 6011, &unk_10694228);
  sub_10011770(0x16u, 6194, &unk_10694229);
  sub_10011770(1u, 6012, &unk_1069423F);
  sub_10011770(1u, 6013, &unk_10694240);
  sub_10011770(1u, 6014, &unk_10694241);
  sub_10011770(1u, 6015, &unk_10694242);
  sub_10011770(4u, 6078, &unk_10694244);
  sub_10011770(4u, 6104, &unk_10694248);
  sub_10011770(0x20u, 6016, &unk_1069424C);
  sub_10011770(0x20u, 6017, &unk_1069426C);
  sub_10011770(0x20u, 6018, &unk_1069428C);
  sub_10011770(0x20u, 6019, &unk_106942AC);
  sub_10011770(0x20u, 6020, &unk_106942CC);
  sub_10011770(0x20u, 6021, &unk_106942EC);
  sub_10011770(0x20u, 6022, &unk_1069430C);
  sub_10011770(0x20u, 6023, &unk_1069432C);
  sub_10011770(0x20u, 6024, &unk_1069434C);
  sub_10011770(0x20u, 6025, &unk_1069436C);
  sub_10011770(0x20u, 6026, &unk_1069438C);
  sub_10011770(0x20u, 6027, &unk_106943AC);
  sub_10011770(0x20u, 6028, &unk_106943CC);
  sub_10011770(0x20u, 6029, &unk_106943EC);
  sub_10011770(0x20u, 6030, &unk_1069440C);
  sub_10011770(0x20u, 6031, &unk_1069442C);
  sub_10011770(0x20u, 6032, &unk_1069444C);
  sub_10011770(0x20u, 6033, &unk_1069446C);
  sub_10011770(0x20u, 6034, &unk_1069448C);
  sub_10011770(0x20u, 6035, &unk_106944AC);
  sub_10011770(0x20u, 6036, &unk_106944CC);
  sub_10011770(0x20u, 6037, &unk_106944EC);
  sub_10011770(0x20u, 6038, &unk_1069450C);
  sub_10011770(0x20u, 6039, &unk_1069452C);
  sub_10011770(0x20u, 6040, &unk_1069454C);
  sub_10011770(0x20u, 6041, &unk_1069456C);
  sub_10011770(0x20u, 6042, &unk_1069458C);
  sub_10011770(0x20u, 6043, &unk_106945AC);
  sub_10011770(4u, 6044, &unk_106945CC);
  sub_10011770(4u, 6045, &unk_106945D0);
  sub_10011770(4u, 6046, &unk_106945D4);
  sub_10011770(4u, 6357, &unk_106945D8);
  sub_10011770(4u, 6358, &unk_106945DC);
  sub_10011770(4u, 6359, &unk_106945E0);
  sub_10011770(0x20u, 6047, &unk_106945E4);
  sub_10011770(0x20u, 6048, &unk_10694604);
  sub_10011770(0x20u, 6049, &unk_10694624);
  sub_10011770(0x20u, 6050, &unk_10694644);
  sub_10011770(0x20u, 6051, &unk_10694664);
  sub_10011770(0x20u, 6052, &unk_10694684);
  sub_10011770(0x20u, 6053, &unk_106946A4);
  sub_10011770(0x20u, 6054, &unk_106946C4);
  sub_10011770(1u, 6511, &unk_106946E4);
  sub_10011770(1u, 6522, &unk_106946E5);
  sub_10011770(1u, 6057, &unk_106946E6);
  sub_10011770(0x20u, 6075, &unk_10694738);
  sub_10011770(0x20u, 6076, &unk_10694758);
  sub_10011770(1u, 6077, &unk_10694778);
  sub_10011770(4u, 6079, &unk_1069477C);
  sub_10011770(4u, 6080, &unk_10694780);
  sub_10011770(0x20u, 6082, &unk_10694784);
  sub_10011770(0x20u, 6083, &unk_106947A4);
  sub_10011770(0x20u, 6084, &unk_106947C4);
  sub_10011770(0x20u, 6085, &unk_106947E4);
  sub_10011770(0x20u, 6086, &unk_10694804);
  sub_10011770(0x20u, 6087, &unk_10694824);
  sub_10011770(0x20u, 6088, &unk_10694844);
  sub_10011770(0x20u, 6089, &unk_10694864);
  sub_10011770(0x20u, 6123, &unk_10694884);
  sub_10011770(0x48u, 6906, &unk_106948A4);
  sub_10011770(0x48u, 6907, &unk_106948EC);
  sub_10011770(0x48u, 6908, &unk_10694934);
  sub_10011770(0x48u, 6909, &unk_1069497C);
  sub_10011770(0x48u, 6910, &unk_106949C4);
  sub_10011770(0x48u, 6911, &unk_10694A0C);
  sub_10011770(0x48u, 6912, &unk_10694A54);
  sub_10011770(0x48u, 6913, &unk_10694A9C);
  sub_10011770(0x48u, 6914, &unk_10694AE4);
  sub_10011770(0x48u, 6915, &unk_10694B2C);
  sub_10011770(0x48u, 6916, &unk_10694B74);
  sub_10011770(0x48u, 6917, &unk_10694BBC);
  sub_10011770(0x48u, 6918, &unk_10694C04);
  sub_10011770(0x48u, 6919, &unk_10694C4C);
  sub_10011770(0x48u, 6920, &unk_10694C94);
  sub_10011770(0x48u, 6921, &unk_10694CDC);
  sub_10011770(0x48u, 6922, &unk_10694D24);
  sub_10011770(0x48u, 6923, &unk_10694D6C);
  sub_10011770(0x48u, 6924, &unk_10694DB4);
  sub_10011770(0x48u, 6925, &unk_10694DFC);
  sub_10011770(0x48u, 6926, &unk_10694E44);
  sub_10011770(0x48u, 6927, &unk_10694E8C);
  sub_10011770(0x48u, 6928, &unk_10694ED4);
  sub_10011770(0x48u, 6929, &unk_10694F1C);
  sub_10011770(0x48u, 6930, &unk_10694F64);
  sub_10011770(0x48u, 6931, &unk_10694FAC);
  sub_10011770(0x48u, 6932, &unk_10694FF4);
  sub_10011770(0x48u, 6933, &unk_1069503C);
  sub_10011770(0x48u, 6934, &unk_10695084);
  sub_10011770(0x48u, 6935, &unk_106950CC);
  sub_10011770(0x18u, 6163, &unk_10695114);
  sub_10011770(0x20u, 6164, &unk_1069512C);
  sub_10011770(0x20u, 6165, &unk_1069514C);
  sub_10011770(2u, 6166, &unk_1069516C);
  sub_10011770(0xA4u, 40100, &unk_10695170);
  sub_10011770(0xA4u, 40101, &unk_10695214);
  sub_10011770(0xA4u, 40102, &unk_106952B8);
  sub_10011770(0xA4u, 40103, &unk_1069535C);
  sub_10011770(0xA4u, 40104, &unk_10695400);
  sub_10011770(0xA4u, 40105, &unk_106954A4);
  sub_10011770(0xA4u, 40106, &unk_10695548);
  sub_10011770(0xA4u, 40107, &unk_106955EC);
  sub_10011770(0xA4u, 40108, &unk_10695690);
  sub_10011770(0xA4u, 40109, &unk_10695734);
  sub_10011770(0xA4u, 40110, &unk_106957D8);
  sub_10011770(0xA4u, 40111, &unk_1069587C);
  sub_10011770(0xA4u, 40112, &unk_10695920);
  sub_10011770(0xA4u, 40113, &unk_106959C4);
  sub_10011770(0xA4u, 40114, &unk_10695A68);
  sub_10011770(0xA4u, 40115, &unk_10695B0C);
  sub_10011770(0xA4u, 40116, &unk_10695BB0);
  sub_10011770(0xA4u, 40117, &unk_10695C54);
  sub_10011770(0xA4u, 40118, &unk_10695CF8);
  sub_10011770(0xA4u, 40119, &unk_10695D9C);
  sub_10011770(0xA4u, 40120, &unk_10695E40);
  sub_10011770(0xA4u, 40121, &unk_10695EE4);
  sub_10011770(0xA4u, 40122, &unk_10695F88);
  sub_10011770(0xA4u, 40123, &unk_1069602C);
  sub_10011770(0xA4u, 40124, &unk_106960D0);
  sub_10011770(0xA4u, 40125, &unk_10696174);
  sub_10011770(0xA4u, 40126, &unk_10696218);
  sub_10011770(0xA4u, 40127, &unk_106962BC);
  sub_10011770(0xA4u, 40128, &unk_10696360);
  sub_10011770(0xA4u, 40129, &unk_10696404);
  sub_10011770(0xA4u, 40130, &unk_106964A8);
  sub_10011770(0xA4u, 40131, &unk_1069654C);
  sub_10011770(0xA4u, 40132, &unk_106965F0);
  sub_10011770(0xA4u, 40133, &unk_10696694);
  sub_10011770(0xA4u, 40134, &unk_10696738);
  sub_10011770(0xA4u, 40135, &unk_106967DC);
  sub_10011770(0xA4u, 40136, &unk_10696880);
  sub_10011770(0xA4u, 40137, &unk_10696924);
  sub_10011770(0xA4u, 40138, &unk_106969C8);
  sub_10011770(0xA4u, 40139, &unk_10696A6C);
  sub_10011770(0xA4u, 40140, &unk_10696B10);
  sub_10011770(0xA4u, 40141, &unk_10696BB4);
  sub_10011770(0xA4u, 40142, &unk_10696C58);
  sub_10011770(0xA4u, 40143, &unk_10696CFC);
  sub_10011770(0xA4u, 40144, &unk_10696DA0);
  sub_10011770(0xA4u, 40145, &unk_10696E44);
  sub_10011770(0xA4u, 40146, &unk_10696EE8);
  sub_10011770(0xA4u, 40147, &unk_10696F8C);
  sub_10011770(0xA4u, 40148, &unk_10697030);
  sub_10011770(0xA4u, 40149, &unk_106970D4);
  sub_10011770(0xA4u, 40150, &unk_10697178);
  sub_10011770(0xA4u, 40151, &unk_1069721C);
  sub_10011770(0xA4u, 40152, &unk_106972C0);
  sub_10011770(0xA4u, 40153, &unk_10697364);
  sub_10011770(0xA4u, 40154, &unk_10697408);
  sub_10011770(0xA4u, 40155, &unk_106974AC);
  sub_10011770(0xA4u, 40156, &unk_10697550);
  sub_10011770(0xA4u, 40157, &unk_106975F4);
  sub_10011770(0xA4u, 40158, &unk_10697698);
  sub_10011770(0xA4u, 40159, &unk_1069773C);
  sub_10011770(0xA4u, 40160, &unk_106977E0);
  sub_10011770(0xA4u, 40161, &unk_10697884);
  sub_10011770(0xA4u, 40162, &unk_10697928);
  sub_10011770(0xA4u, 40163, &unk_106979CC);
  sub_10011770(0xA4u, 40164, &unk_10697A70);
  sub_10011770(0xA4u, 40165, &unk_10697B14);
  sub_10011770(0xA4u, 40166, &unk_10697BB8);
  sub_10011770(0xA4u, 40167, &unk_10697C5C);
  sub_10011770(0xA4u, 40168, &unk_10697D00);
  sub_10011770(0xA4u, 40169, &unk_10697DA4);
  sub_10011770(0xA4u, 40170, &unk_10697E48);
  sub_10011770(0xA4u, 40171, &unk_10697EEC);
  sub_10011770(0xA4u, 40172, &unk_10697F90);
  sub_10011770(0xA4u, 40173, &unk_10698034);
  sub_10011770(0xA4u, 40174, &unk_106980D8);
  sub_10011770(0xA4u, 40175, &unk_1069817C);
  sub_10011770(0xA4u, 40176, &unk_10698220);
  sub_10011770(0xA4u, 40177, &unk_106982C4);
  sub_10011770(0xA4u, 40178, &unk_10698368);
  sub_10011770(0xA4u, 40179, &unk_1069840C);
  sub_10011770(0xA4u, 40180, &unk_106984B0);
  sub_10011770(0xA4u, 40181, &unk_10698554);
  sub_10011770(0xA4u, 40182, &unk_106985F8);
  sub_10011770(0xA4u, 40183, &unk_1069869C);
  sub_10011770(0xA4u, 40184, &unk_10698740);
  sub_10011770(0xA4u, 40185, &unk_106987E4);
  sub_10011770(0xA4u, 40186, &unk_10698888);
  sub_10011770(0xA4u, 40187, &unk_1069892C);
  sub_10011770(0xA4u, 40188, &unk_106989D0);
  sub_10011770(0xA4u, 40189, &unk_10698A74);
  sub_10011770(0xA4u, 40190, &unk_10698B18);
  sub_10011770(0xA4u, 40191, &unk_10698BBC);
  sub_10011770(0xA4u, 40192, &unk_10698C60);
  sub_10011770(0xA4u, 40193, &unk_10698D04);
  sub_10011770(0xA4u, 40194, &unk_10698DA8);
  sub_10011770(0xA4u, 40195, &unk_10698E4C);
  sub_10011770(0xA4u, 40196, &unk_10698EF0);
  sub_10011770(0xA4u, 40197, &unk_10698F94);
  sub_10011770(0xA4u, 40198, &unk_10699038);
  sub_10011770(0xA4u, 40199, &unk_106990DC);
  sub_10011770(0x20u, 6190, &unk_10699180);
  sub_10011770(0x20u, 6191, &unk_106991A0);
  sub_10011770(0x20u, 6192, &unk_106991C0);
  sub_10011770(0x20u, 6199, &unk_106991E0);
  sub_10011770(0x28u, 6207, &unk_10699200);
  sub_10011770(4u, 6231, &unk_10699D18);
  sub_10011770(4u, 6232, &unk_10699D1C);
  sub_10011770(4u, 6233, &unk_10699D20);
  sub_10011770(4u, 6234, &unk_10699D24);
  sub_10011770(0x1Cu, 40000, &unk_10699228);
  sub_10011770(0x1Cu, 40001, &unk_10699244);
  sub_10011770(0x1Cu, 40002, &unk_10699260);
  sub_10011770(0x1Cu, 40003, &unk_1069927C);
  sub_10011770(0x1Cu, 40004, &unk_10699298);
  sub_10011770(0x1Cu, 40005, &unk_106992B4);
  sub_10011770(0x1Cu, 40006, &unk_106992D0);
  sub_10011770(0x1Cu, 40007, &unk_106992EC);
  sub_10011770(0x1Cu, 40008, &unk_10699308);
  sub_10011770(0x1Cu, 40009, &unk_10699324);
  sub_10011770(0x1Cu, 40010, &unk_10699340);
  sub_10011770(0x1Cu, 40011, &unk_1069935C);
  sub_10011770(0x1Cu, 40012, &unk_10699378);
  sub_10011770(0x1Cu, 40013, &unk_10699394);
  sub_10011770(0x1Cu, 40014, &unk_106993B0);
  sub_10011770(0x1Cu, 40015, &unk_106993CC);
  sub_10011770(0x1Cu, 40016, &unk_106993E8);
  sub_10011770(0x1Cu, 40017, &unk_10699404);
  sub_10011770(0x1Cu, 40018, &unk_10699420);
  sub_10011770(0x1Cu, 40019, &unk_1069943C);
  sub_10011770(0x1Cu, 40020, &unk_10699458);
  sub_10011770(0x1Cu, 40021, &unk_10699474);
  sub_10011770(0x1Cu, 40022, &unk_10699490);
  sub_10011770(0x1Cu, 40023, &unk_106994AC);
  sub_10011770(0x1Cu, 40024, &unk_106994C8);
  sub_10011770(0x1Cu, 40025, &unk_106994E4);
  sub_10011770(0x1Cu, 40026, &unk_10699500);
  sub_10011770(0x1Cu, 40027, &unk_1069951C);
  sub_10011770(0x1Cu, 40028, &unk_10699538);
  sub_10011770(0x1Cu, 40029, &unk_10699554);
  sub_10011770(0x1Cu, 40030, &unk_10699570);
  sub_10011770(0x1Cu, 40031, &unk_1069958C);
  sub_10011770(0x1Cu, 40032, &unk_106995A8);
  sub_10011770(0x1Cu, 40033, &unk_106995C4);
  sub_10011770(0x1Cu, 40034, &unk_106995E0);
  sub_10011770(0x1Cu, 40035, &unk_106995FC);
  sub_10011770(0x1Cu, 40036, &unk_10699618);
  sub_10011770(0x1Cu, 40037, &unk_10699634);
  sub_10011770(0x1Cu, 40038, &unk_10699650);
  sub_10011770(0x1Cu, 40039, &unk_1069966C);
  sub_10011770(0x1Cu, 40040, &unk_10699688);
  sub_10011770(0x1Cu, 40041, &unk_106996A4);
  sub_10011770(0x1Cu, 40042, &unk_106996C0);
  sub_10011770(0x1Cu, 40043, &unk_106996DC);
  sub_10011770(0x1Cu, 40044, &unk_106996F8);
  sub_10011770(0x1Cu, 40045, &unk_10699714);
  sub_10011770(0x1Cu, 40046, &unk_10699730);
  sub_10011770(0x1Cu, 40047, &unk_1069974C);
  sub_10011770(0x1Cu, 40048, &unk_10699768);
  sub_10011770(0x1Cu, 40049, &unk_10699784);
  sub_10011770(0x1Cu, 40050, &unk_106997A0);
  sub_10011770(0x1Cu, 40051, &unk_106997BC);
  sub_10011770(0x1Cu, 40052, &unk_106997D8);
  sub_10011770(0x1Cu, 40053, &unk_106997F4);
  sub_10011770(0x1Cu, 40054, &unk_10699810);
  sub_10011770(0x1Cu, 40055, &unk_1069982C);
  sub_10011770(0x1Cu, 40056, &unk_10699848);
  sub_10011770(0x1Cu, 40057, &unk_10699864);
  sub_10011770(0x1Cu, 40058, &unk_10699880);
  sub_10011770(0x1Cu, 40059, &unk_1069989C);
  sub_10011770(0x1Cu, 40060, &unk_106998B8);
  sub_10011770(0x1Cu, 40061, &unk_106998D4);
  sub_10011770(0x1Cu, 40062, &unk_106998F0);
  sub_10011770(0x1Cu, 40063, &unk_1069990C);
  sub_10011770(0x1Cu, 40064, &unk_10699928);
  sub_10011770(0x1Cu, 40065, &unk_10699944);
  sub_10011770(0x1Cu, 40066, &unk_10699960);
  sub_10011770(0x1Cu, 40067, &unk_1069997C);
  sub_10011770(0x1Cu, 40068, &unk_10699998);
  sub_10011770(0x1Cu, 40069, &unk_106999B4);
  sub_10011770(0x1Cu, 40070, &unk_106999D0);
  sub_10011770(0x1Cu, 40071, &unk_106999EC);
  sub_10011770(0x1Cu, 40072, &unk_10699A08);
  sub_10011770(0x1Cu, 40073, &unk_10699A24);
  sub_10011770(0x1Cu, 40074, &unk_10699A40);
  sub_10011770(0x1Cu, 40075, &unk_10699A5C);
  sub_10011770(0x1Cu, 40076, &unk_10699A78);
  sub_10011770(0x1Cu, 40077, &unk_10699A94);
  sub_10011770(0x1Cu, 40078, &unk_10699AB0);
  sub_10011770(0x1Cu, 40079, &unk_10699ACC);
  sub_10011770(0x1Cu, 40080, &unk_10699AE8);
  sub_10011770(0x1Cu, 40081, &unk_10699B04);
  sub_10011770(0x1Cu, 40082, &unk_10699B20);
  sub_10011770(0x1Cu, 40083, &unk_10699B3C);
  sub_10011770(0x1Cu, 40084, &unk_10699B58);
  sub_10011770(0x1Cu, 40085, &unk_10699B74);
  sub_10011770(0x1Cu, 40086, &unk_10699B90);
  sub_10011770(0x1Cu, 40087, &unk_10699BAC);
  sub_10011770(0x1Cu, 40088, &unk_10699BC8);
  sub_10011770(0x1Cu, 40089, &unk_10699BE4);
  sub_10011770(0x1Cu, 40090, &unk_10699C00);
  sub_10011770(0x1Cu, 40091, &unk_10699C1C);
  sub_10011770(0x1Cu, 40092, &unk_10699C38);
  sub_10011770(0x1Cu, 40093, &unk_10699C54);
  sub_10011770(0x1Cu, 40094, &unk_10699C70);
  sub_10011770(0x1Cu, 40095, &unk_10699C8C);
  sub_10011770(0x1Cu, 40096, &unk_10699CA8);
  sub_10011770(0x1Cu, 40097, &unk_10699CC4);
  sub_10011770(0x1Cu, 40098, &unk_10699CE0);
  sub_10011770(0x1Cu, 40099, &unk_10699CFC);
  sub_10011770(4u, 6238, &unk_10699D28);
  sub_10011770(4u, 6239, &unk_10699D2C);
  sub_10011770(4u, 6240, &unk_10699D30);
  sub_10011770(4u, 6242, &unk_10699D34);
  sub_10011770(4u, 6244, &unk_10699D38);
  sub_10011770(4u, 6245, &unk_10699D3C);
  sub_10011770(4u, 6246, &unk_10699D40);
  sub_10011770(4u, 6251, &unk_10699D44);
  sub_10011770(4u, 6252, &unk_10699D48);
  sub_10011770(4u, 6253, &unk_10699D4C);
  sub_10011770(4u, 6254, &unk_10699D50);
  sub_10011770(1u, 6255, &unk_10699D54);
  sub_10011770(4u, 6256, &unk_10699D58);
  sub_10011770(4u, 6257, &unk_10699D5C);
  sub_10011770(0xE2u, 6286, &unk_10699D60);
  v0 = 18000;
  v1 = &unk_10699E44;
  v2 = 16;
  do
  {
    sub_10011770(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10011770(4u, 6262, &unk_1069B004);
  sub_10011770(0x28u, 6263, &unk_1069B008);
  sub_10011770(0x28u, 6264, &unk_1069B030);
  sub_10011770(0x40u, 6268, &unk_1069B058);
  sub_10011770(4u, 6272, &unk_1069B118);
  sub_10011770(4u, 6273, &unk_1069B11C);
  sub_10011770(1u, 6274, &unk_1069B120);
  sub_10011770(2u, 6275, &unk_1069B122);
  sub_10011770(1u, 6276, &unk_1069B124);
  sub_10011770(1u, 6277, &unk_1069B125);
  sub_10011770(1u, 6278, &unk_1069B126);
  sub_10011770(0x40u, 6279, &unk_1069B128);
  sub_10011770(0x28u, 6753, &unk_1069BFDD);
  sub_10011770(0x30u, 6754, &unk_1069C008);
  sub_10011770(0x28u, 6958, &unk_1069C038);
  sub_10011770(0x80u, 6802, &unk_1069B098);
  sub_10011770(1u, 6760, &unk_1069C060);
  sub_10011770(0x10u, 6312, &unk_1069B4AC);
  sub_10011770(0x10u, 6313, &unk_1069B4BC);
  sub_10011770(0x10u, 6314, &unk_1069B4CC);
  sub_10011770(1u, 6307, &unk_1069B4DC);
  sub_10011770(1u, 6308, &unk_1069B4DD);
  sub_10011770(1u, 6309, &unk_1069B4DE);
  sub_10011770(4u, 6285, &unk_1069B4E0);
  sub_10011770(0xA8u, 6318, &unk_1069B4E4);
  sub_10011770(4u, 6319, &unk_1069B58C);
  sub_10011770(1u, 6350, &unk_1069B590);
  sub_10011770(0x50u, 6351, &unk_1069B594);
  sub_10011770(4u, 6352, &unk_1069B5E4);
  sub_10011770(4u, 6353, &unk_1069B5E8);
  sub_10011770(0x54u, 6448, &unk_1069B834);
  sub_10011770(0x54u, 6449, &unk_1069B888);
  sub_10011770(8u, 6287, &unk_1069B18C);
  sub_10011770(8u, 6288, &unk_1069B194);
  sub_10011770(8u, 6289, &unk_1069B19C);
  sub_10011770(8u, 6290, &unk_1069B1A4);
  sub_10011770(8u, 6291, &unk_1069B1AC);
  sub_10011770(8u, 6292, &unk_1069B1B4);
  sub_10011770(8u, 6293, &unk_1069B1BC);
  sub_10011770(8u, 6294, &unk_1069B1C4);
  sub_10011770(8u, 6295, &unk_1069B1CC);
  sub_10011770(8u, 6296, &unk_1069B1D4);
  sub_10011770(8u, 6297, &unk_1069B1DC);
  sub_10011770(8u, 6298, &unk_1069B1E4);
  sub_10011770(8u, 6299, &unk_1069B1EC);
  sub_10011770(8u, 6300, &unk_1069B1F4);
  sub_10011770(8u, 6301, &unk_1069B1FC);
  sub_10011770(8u, 6302, &unk_1069B204);
  sub_10011770(8u, 6303, &unk_1069B20C);
  sub_10011770(8u, 6304, &unk_1069B214);
  sub_10011770(8u, 6305, &unk_1069B21C);
  sub_10011770(8u, 6306, &unk_1069B224);
  sub_10011770(8u, 6409, &unk_1069B22C);
  sub_10011770(8u, 6410, &unk_1069B234);
  sub_10011770(8u, 6411, &unk_1069B23C);
  sub_10011770(8u, 6412, &unk_1069B244);
  sub_10011770(8u, 6413, &unk_1069B24C);
  sub_10011770(8u, 6414, &unk_1069B254);
  sub_10011770(8u, 6415, &unk_1069B25C);
  sub_10011770(8u, 6416, &unk_1069B264);
  sub_10011770(8u, 6417, &unk_1069B26C);
  sub_10011770(8u, 6418, &unk_1069B274);
  sub_10011770(8u, 6419, &unk_1069B27C);
  sub_10011770(8u, 6420, &unk_1069B284);
  sub_10011770(8u, 6421, &unk_1069B28C);
  sub_10011770(8u, 6422, &unk_1069B294);
  sub_10011770(8u, 6423, &unk_1069B29C);
  sub_10011770(8u, 6424, &unk_1069B2A4);
  sub_10011770(8u, 6425, &unk_1069B2AC);
  sub_10011770(8u, 6426, &unk_1069B2B4);
  sub_10011770(8u, 6427, &unk_1069B2BC);
  sub_10011770(8u, 6428, &unk_1069B2C4);
  sub_10011770(4u, 6429, &unk_1069B7CC);
  sub_10011770(8u, 6430, &unk_1069B7D0);
  sub_10011770(8u, 6431, &unk_1069B7D8);
  sub_10011770(8u, 6432, &unk_1069B7E0);
  sub_10011770(8u, 6433, &unk_1069B7E8);
  sub_10011770(8u, 6434, &unk_1069B7F0);
  sub_10011770(8u, 6435, &unk_1069B7F8);
  sub_10011770(8u, 6436, &unk_1069B800);
  sub_10011770(8u, 6437, &unk_1069B808);
  sub_10011770(8u, 6438, &unk_1069B810);
  sub_10011770(8u, 6439, &unk_1069B818);
  sub_10011770(8u, 6440, &unk_1069B820);
  sub_10011770(0xAu, 6519, &unk_1069BC8C);
  sub_10011770(4u, 6442, &unk_1069B828);
  sub_10011770(4u, 6443, &unk_1069B82C);
  sub_10011770(0xF0u, 6367, &unk_1069B5EC);
  sub_10011770(0xF0u, 6368, &unk_1069B6DC);
  sub_10011770(1u, 6446, &unk_1069B830);
  sub_10011770(6u, 6452, &unk_1069B8DC);
  sub_10011770(4u, 6457, &unk_1069B8E4);
  sub_10011770(4u, 6458, &unk_1069B8E8);
  sub_10011770(4u, 6459, &unk_1069B8EC);
  sub_10011770(4u, 6460, &unk_1069B8F0);
  sub_10011770(0x208u, 6515, &unk_1069B8F4);
  sub_10011770(0x160u, 6516, &unk_1069BAFC);
  sub_10011770(0x18u, 6517, &unk_1069BC5C);
  sub_10011770(0x18u, 6518, &unk_1069BC74);
  sub_10011770(1u, 6520, &unk_1069BC96);
  sub_10011770(0x10u, 6521, &unk_1069BC98);
  sub_10011770(4u, 6523, &unk_1069BCA8);
  sub_10011770(4u, 6524, &unk_1069BCAC);
  sub_10011770(4u, 6525, &unk_1069BCB0);
  sub_10011770(1u, 6526, &unk_1069BCB4);
  sub_10011770(1u, 6527, &unk_1069BCB5);
  sub_10011770(0x50u, 6528, &unk_1069BCB8);
  sub_10011770(4u, 6529, &unk_1069BD08);
  sub_10011770(1u, 6530, &unk_1069BD0C);
  sub_10011770(1u, 6531, &unk_1069BD0D);
  sub_10011770(1u, 6532, &unk_1069BD0E);
  sub_10011770(0x14u, 6533, &unk_1069BD0F);
  sub_10011770(0xAu, 6883, &unk_1069C428);
  sub_10011770(0xAu, 6884, &unk_1069C432);
  sub_10011770(0xAu, 6885, &unk_1069C43C);
  sub_10011770(1u, 6664, &unk_1069BD23);
  sub_10011770(1u, 6666, &unk_1069BD24);
  sub_10011770(1u, 6667, &unk_1069BD25);
  sub_10011770(1u, 6668, &unk_1069BD26);
  sub_10011770(0xA0u, 6669, &unk_1069BD28);
  sub_10011770(2u, 6670, &unk_1069BE18);
  sub_10011770(4u, 6671, &unk_1069BE1C);
  sub_10011770(4u, 6672, &unk_1069BE20);
  sub_10011770(4u, 6673, &unk_1069BE24);
  sub_10011770(4u, 6674, &unk_1069BE28);
  sub_10011770(4u, 6675, &unk_1069BE2C);
  sub_10011770(4u, 6676, &unk_1069BE34);
  sub_10011770(4u, 6677, &unk_1069BE3C);
  sub_10011770(4u, 6678, &unk_1069BE40);
  sub_10011770(1u, 6679, &unk_1069BE44);
  sub_10011770(0x140u, 6680, &unk_1069BE48);
  sub_10011770(4u, 6882, &unk_1069C424);
  sub_10011770(0xCu, 6652, &unk_1069BF88);
  sub_10011770(0x48u, 6653, &unk_1069BF94);
  sub_10011770(1u, 6688, &unk_1069BFDC);
  sub_10011770(4u, 6771, &unk_1069C064);
  sub_10011770(4u, 6772, &unk_1069C068);
  sub_10011770(8u, 6787, &unk_1069C06C);
  sub_10011770(1u, 6832, &unk_1069C09C);
  sub_10011770(1u, 6833, &unk_1069C09D);
  sub_10011770(1u, 6834, &unk_1069C09E);
  sub_10011770(4u, 6835, &unk_1069C0A0);
  sub_10011770(4u, 6836, &unk_1069C0A4);
  sub_10011770(4u, 6837, &unk_1069C0A8);
  sub_10011770(4u, 6838, &unk_1069C0AC);
  sub_10011770(1u, 6839, &unk_1069C0B0);
  sub_10011770(0x50u, 6840, &unk_1069BDC8);
  sub_10011770(4u, 6841, &unk_1069C0B4);
  sub_10011770(4u, 6842, &unk_1069C0B8);
  sub_10011770(4u, 6843, &unk_1069C0BC);
  sub_10011770(1u, 6844, &unk_1069C0C0);
  sub_10011770(0x360u, 6845, &unk_1069C0C4);
  sub_10011770(4u, 6846, &unk_1069BE30);
  sub_10011770(4u, 6847, &unk_1069BE38);
  result = 1;
  dword_1077AE98 = (int)&unk_10694228;
  return result;
}
// 1077AE98: using guessed type int dword_1077AE98;

//----- (100135C0) --------------------------------------------------------
char __cdecl sub_100135C0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1000E6B0(13, (char *)&v3 + 3);
  sub_1000E6B0(12, a1);
  return BYTE3(v3);
}

//----- (100135F0) --------------------------------------------------------
char __cdecl sub_100135F0(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_100135C0((char *)&v4);
  if ( v2 )
  {
    if ( sub_1000E630(v1) == 1 )
      sub_10016DA0((int *)&v4, v4);
    sub_10016BE0(a1, v4);
  }
  return v2;
}

//----- (10013640) --------------------------------------------------------
char __cdecl sub_10013640(_WORD *a1, int a2, int a3, int a4, int a5)
{
  char result; // al@1
  char v6; // cl@2
  char v7; // dl@2
  __int16 v8; // ax@2
  char v9; // cl@2
  char v10; // dl@2
  __int16 v11; // ax@2
  char v12; // cl@2
  char v13; // dl@2
  __int16 v14; // ax@2
  __int16 v15; // cx@2
  char v16; // dl@2
  __int16 v17; // [sp+10h] [bp-14h]@2
  char v18; // [sp+12h] [bp-12h]@2
  char v19; // [sp+13h] [bp-11h]@2
  __int16 v20; // [sp+14h] [bp-10h]@2
  char v21; // [sp+16h] [bp-Eh]@2
  char v22; // [sp+17h] [bp-Dh]@2
  __int16 v23; // [sp+18h] [bp-Ch]@2
  char v24; // [sp+1Ah] [bp-Ah]@2
  char v25; // [sp+1Bh] [bp-9h]@2
  __int16 v26; // [sp+1Ch] [bp-8h]@2
  unsigned __int8 v27; // [sp+1Eh] [bp-6h]@2
  char v28; // [sp+1Fh] [bp-5h]@2
  char v29; // [sp+20h] [bp-4h]@2

  *a1 = 0x7FFF;
  result = -1;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)a3 = -1;
  *(_DWORD *)a4 = -1;
  *(_DWORD *)a5 = -32769;
  if ( !byte_1077AE94 )
  {
    (*(void (__cdecl **)(signed int, signed int, __int16 *))dword_1077A600)(129, 17, &v17);
    v6 = v18;
    *a1 = v17;
    v7 = v19;
    v8 = v20;
    *(_BYTE *)a2 = v6;
    v9 = v21;
    *(_BYTE *)(a2 + 1) = v7;
    v10 = v22;
    *(_WORD *)(a2 + 2) = v8;
    v11 = v23;
    *(_BYTE *)a3 = v9;
    v12 = v24;
    *(_BYTE *)(a3 + 1) = v10;
    v13 = v25;
    *(_WORD *)(a3 + 2) = v11;
    v14 = v26;
    *(_BYTE *)a4 = v12;
    v15 = v27;
    *(_BYTE *)(a4 + 1) = v13;
    v16 = v28;
    *(_WORD *)(a4 + 2) = v14;
    result = v29;
    *(_WORD *)a5 = v15;
    *(_BYTE *)(a5 + 2) = v16;
    *(_BYTE *)(a5 + 3) = result;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10013710) --------------------------------------------------------
int __cdecl sub_10013710(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_1077AE94 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_1077A600)(146, 1, a1);
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10013740) --------------------------------------------------------
char __cdecl sub_10013740(_BYTE *a1)
{
  unsigned int v1; // eax@1
  int v2; // ebx@1
  _BYTE *v3; // esi@1
  int v4; // ebp@3
  int v5; // ecx@4
  int v6; // ebp@4
  _BYTE *v7; // edi@5
  int v8; // ecx@6

  LOBYTE(v1) = 32;
  v2 = 0;
  v3 = a1;
  *a1 = 0;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 1) = 0;
  *((_DWORD *)v3 + 3) = 538976288;
  *((_DWORD *)v3 + 4) = 538976288;
  *((_DWORD *)v3 + 5) = 538976288;
  *((_DWORD *)v3 + 6) = 538976288;
  *((_DWORD *)v3 + 7) = 538976288;
  *((_DWORD *)v3 + 8) = 538976288;
  *((_DWORD *)v3 + 9) = 538976288;
  *((_DWORD *)v3 + 10) = 538976288;
  *((_DWORD *)v3 + 11) = 538976288;
  *(_DWORD *)(v3 + 49) = 538976288;
  *(_DWORD *)(v3 + 53) = 538976288;
  *(_DWORD *)(v3 + 57) = 538976288;
  *(_DWORD *)(v3 + 61) = 538976288;
  *(_DWORD *)(v3 + 65) = 538976288;
  *(_DWORD *)(v3 + 69) = 538976288;
  *(_DWORD *)(v3 + 73) = 538976288;
  *(_DWORD *)(v3 + 77) = 538976288;
  *(_DWORD *)(v3 + 81) = 538976288;
  *(_DWORD *)(v3 + 86) = 538976288;
  *(_DWORD *)(v3 + 90) = 538976288;
  *(_DWORD *)(v3 + 94) = 538976288;
  *(_DWORD *)(v3 + 98) = 538976288;
  *(_DWORD *)(v3 + 102) = 538976288;
  *(_DWORD *)(v3 + 106) = 538976288;
  *(_DWORD *)(v3 + 110) = 538976288;
  *(_DWORD *)(v3 + 114) = 538976288;
  *(_DWORD *)(v3 + 118) = 538976288;
  *(_DWORD *)(v3 + 123) = 538976288;
  *(_DWORD *)(v3 + 127) = 538976288;
  *(_DWORD *)(v3 + 131) = 538976288;
  *(_DWORD *)(v3 + 135) = 538976288;
  *(_DWORD *)(v3 + 139) = 538976288;
  *(_DWORD *)(v3 + 143) = 538976288;
  *(_DWORD *)(v3 + 147) = 538976288;
  *(_DWORD *)(v3 + 151) = 538976288;
  *(_DWORD *)(v3 + 155) = 538976288;
  *((_DWORD *)v3 + 40) = 538976288;
  *((_DWORD *)v3 + 41) = 538976288;
  *((_DWORD *)v3 + 42) = 538976288;
  *((_DWORD *)v3 + 43) = 538976288;
  *((_DWORD *)v3 + 44) = 538976288;
  *((_DWORD *)v3 + 45) = 538976288;
  *((_DWORD *)v3 + 46) = 538976288;
  *((_DWORD *)v3 + 47) = 538976288;
  *((_DWORD *)v3 + 48) = 538976288;
  if ( !byte_1077AE94 )
  {
    LOBYTE(v1) = sub_10015210(0, 0x44u);
    if ( (_BYTE)v1 )
    {
      v4 = dword_1077A970;
      (*(void (__cdecl **)(int, signed int, _BYTE **))dword_1077A600)(dword_1077A970, 2, &a1);
      LOBYTE(v1) = (_BYTE)a1;
      if ( (_BYTE)a1 )
      {
        v5 = (unsigned __int8)a1;
        v1 = (unsigned int)(unsigned __int16)a1 >> 8;
        *v3 = 1;
        *((_DWORD *)v3 + 2) = v5;
        *((_DWORD *)v3 + 1) = v1;
        v6 = (unsigned __int16)word_1077A974 + v4;
        if ( v5 > 0 )
        {
          v7 = v3 + 48;
          do
          {
            (*(void (__cdecl **)(int, signed int, _BYTE *))dword_1077A600)(v6, 37, v7 - 36);
            v8 = (unsigned __int8)a1;
            *v7 = 0;
            LOBYTE(v1) = word_1077ADEE;
            ++v2;
            v6 += (unsigned __int16)word_1077ADEE;
            v7 += 37;
          }
          while ( v2 < v8 );
        }
      }
    }
  }
  if ( byte_1077AE94 == 2 )
  {
    *v3 = 1;
    *((_DWORD *)v3 + 2) = 3;
    *((_DWORD *)v3 + 1) = 2;
    *((_DWORD *)v3 + 3) = 1635017028;
    *((_DWORD *)v3 + 4) = 1702060386;
    *((_DWORD *)v3 + 5) = 1986359840;
    *((_DWORD *)v3 + 6) = 1869181801;
    *((_DWORD *)v3 + 7) = 1936269422;
    v3[32] = 0;
    *(_DWORD *)(v3 + 49) = 1868787305;
    *(_DWORD *)(v3 + 53) = 1952542829;
    *(_DWORD *)(v3 + 57) = 1701601897;
    *(_DWORD *)(v3 + 61) = 1953068832;
    *(_WORD *)(v3 + 65) = 104;
    *(_DWORD *)(v3 + 86) = 1685025392;
    *(_DWORD *)(v3 + 90) = 544498549;
    LOBYTE(v1) = 115;
    *(_DWORD *)(v3 + 94) = 1952870259;
    *(_DWORD *)(v3 + 98) = 1701994871;
    *((_WORD *)v3 + 51) = 46;
  }
  v3[48] = 0;
  v3[85] = 0;
  v3[122] = 0;
  v3[159] = 0;
  v3[196] = 0;
  return v1;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A970: using guessed type int dword_1077A970;
// 1077A974: using guessed type __int16 word_1077A974;
// 1077ADEE: using guessed type __int16 word_1077ADEE;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10013980) --------------------------------------------------------
char __cdecl sub_10013980(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1077AE94 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_1077A600)(dword_1077A964, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A964: using guessed type int dword_1077A964;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (100139D0) --------------------------------------------------------
char __cdecl sub_100139D0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1077AE94 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1077A600)(dword_1077A964, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A964: using guessed type int dword_1077A964;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10013A20) --------------------------------------------------------
int sub_10013A20()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_1077A640, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_1077A5F0)(512, &v6);
  v1 = 0;
  do
  {
    word_1077A644[v1 / 2] = 0;
    dword_1077A648[v1 / 4] = 0;
    dword_1077A640[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_1077A64C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_1077A650 = v7;
    dword_1077A654 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_1077A658;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_1077A5F0)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_1077A650;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 1077A5F0: using guessed type int dword_1077A5F0;
// 1077A640: using guessed type int dword_1077A640[];
// 1077A644: using guessed type __int16 word_1077A644[];
// 1077A648: using guessed type int dword_1077A648[];
// 1077A64C: using guessed type int dword_1077A64C;
// 1077A650: using guessed type int dword_1077A650;
// 1077A654: using guessed type int dword_1077A654;
// 1077A658: using guessed type int dword_1077A658;

//----- (10013AF0) --------------------------------------------------------
__int16 sub_10013AF0()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_1077A65C;
  v1 = dword_1077A660;
  v2 = 1;
  v3 = dword_1077A658;
  if ( (unsigned int)dword_1077A660 >= 1 )
  {
    v4 = (unsigned __int16)word_1077A65C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_1077A600)(v3, 2, &v5);
      result = v5;
      word_1077AD60[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;
// 1077A658: using guessed type int dword_1077A658;
// 1077A65C: using guessed type __int16 word_1077A65C;
// 1077A660: using guessed type int dword_1077A660;
// 1077AD60: using guessed type __int16 word_1077AD60[];

//----- (10013B50) --------------------------------------------------------
int __usercall sub_10013B50@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10013BD0) --------------------------------------------------------
char sub_10013BD0()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_1077AE94 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_1077A600)(147, 12, &v17);
  byte_1077AE94 = 1;
  dword_1069DBF8 = 0;
  dword_1069DBFC = 0;
  dword_1069DC00 = 0;
  dword_1069DC04 = 0;
  byte_1069DC08 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  sub_10013B50((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  }
  byte_1077AE94 = 0;
  sub_10013710(&v16);
  if ( v16 != 101 )
  {
    byte_1077AE94 = 2;
    return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  }
  if ( byte_1077AE94 )
    return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  sub_100139D0(&unk_1077AD48, &byte_1077AE8D);
  byte_1077AE8C = byte_1077AE8D - 1;
  if ( byte_1077AE94 )
    return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  result = sub_10013980(&unk_1077AD49, &unk_1077AD4A);
  byte_1077A624 = 0;
  if ( byte_1077AE94 )
    return (unsigned int)memset(dword_1077A640, 0, 0x708u);
  return result;
}
// 1069DBF8: using guessed type int dword_1069DBF8;
// 1069DBFC: using guessed type int dword_1069DBFC;
// 1069DC00: using guessed type int dword_1069DC00;
// 1069DC04: using guessed type int dword_1069DC04;
// 1069DC08: using guessed type char byte_1069DC08;
// 1077A600: using guessed type int dword_1077A600;
// 1077A624: using guessed type char byte_1077A624;
// 1077A640: using guessed type int dword_1077A640[];
// 1077AE8C: using guessed type char byte_1077AE8C;
// 1077AE8D: using guessed type char byte_1077AE8D;
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10013D90) --------------------------------------------------------
int (__cdecl *(*sub_10013D90())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_1077A5F0 = (int)off_1008F7F8;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_1077A600)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10013B50((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_1006A0C0)[8 * v1];
      v3 = strlen((&off_1006A0C0)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_1006A0C4)[v1];
        dword_1077A5F0 = (int)(&off_1006A0C4)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 1006A0C0: using guessed type char *off_1006A0C0;
// 1006A0C4: using guessed type int (__cdecl *(*off_1006A0C4)[2])(int, int);
// 1008F7F8: using guessed type int (__cdecl *off_1008F7F8[2])(int, int);
// 1077A5F0: using guessed type int dword_1077A5F0;
// 1077A600: using guessed type int dword_1077A600;

//----- (10013EC0) --------------------------------------------------------
signed int __cdecl sub_10013EC0(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_10039740(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (10013F00) --------------------------------------------------------
char __cdecl sub_10013F00(int a1)
{
  char result; // al@1
  int v2; // edx@3
  char v3; // [sp+4h] [bp-5BCh]@1
  int v4; // [sp+9h] [bp-5B7h]@3
  int v5; // [sp+Dh] [bp-5B3h]@3

  sub_1002AF50(&v3);
  *(_BYTE *)a1 = 0;
  result = 0;
  if ( *(_BYTE *)dword_1077AE98 != 63 )
  {
    if ( v3 )
    {
      v2 = v4;
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)a1 = v2;
      *(_BYTE *)(a1 + 4) = 46;
      result = 1;
    }
  }
  return result;
}
// 1077AE98: using guessed type int dword_1077AE98;

//----- (10013F80) --------------------------------------------------------
int __cdecl sub_10013F80(int a1, int a2)
{
  sub_100035F0();
  sub_10002970();
  sub_10002740();
  j_nullsub_1();
  return nullsub_1(a1, a2);
}
// 1000F050: using guessed type int j_nullsub_1(void);

//----- (10013FA0) --------------------------------------------------------
BOOL __cdecl sub_10013FA0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10038330();
  for ( i = sub_10037CB0(6, 0, 1, (int)&v4); i == 12; i = sub_10037CB0(6, 0, 1, (int)&v4) )
  {
    if ( sub_10038330() - v1 >= a1 )
      break;
    sub_100384E0(100);
  }
  return i == 12;
}

//----- (10014010) --------------------------------------------------------
char __thiscall sub_10014010(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10039740(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10014030) --------------------------------------------------------
void __cdecl sub_10014030(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10039740(120, a1);
  sub_10039740(124, a2);
  sub_10039740(121, a3);
}

//----- (10014060) --------------------------------------------------------
int __cdecl sub_10014060(int a1)
{
  return sub_10038660(3025, a1, 84);
}

//----- (10014080) --------------------------------------------------------
signed int sub_10014080()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_10037CF0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (100140B0) --------------------------------------------------------
void __cdecl sub_100140B0(_BYTE *a1)
{
  sub_10039740(129, a1);
}

//----- (100140D0) --------------------------------------------------------
char __cdecl sub_100140D0(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_10037CB0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10014110) --------------------------------------------------------
int __cdecl sub_10014110(int a1)
{
  return sub_10038730(3025, a1, 84);
}

//----- (10014130) --------------------------------------------------------
char __fastcall sub_10014130(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_1077AE94 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_100140D0(147, 0xCu, &v38);
  sub_100140D0(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_100386C0(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_10014FC0(a1);
  if ( !result || result == 3 )
    result = sub_1000E7B0(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10038730(2000, (int)&v20, 29);
  }
  return result;
}
// 1077AE94: using guessed type char byte_1077AE94;

//----- (10014350) --------------------------------------------------------
char sub_10014350()
{
  int *v0; // ecx@1

  sub_10013FA0(0x9C40u);
  sub_1000CDC0(&off_1006B7A8);
  return sub_10014130(v0);
}
// 1006B7A8: using guessed type int (__cdecl *off_1006B7A8)(int, size_t, void *);

//----- (10014370) --------------------------------------------------------
int __cdecl sub_10014370(int a1, int a2)
{
  byte_1077A614[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10014380) --------------------------------------------------------
void sub_10014380()
{
  dword_1069DC0C = -15;
}
// 1069DC0C: using guessed type int dword_1069DC0C;

//----- (10014390) --------------------------------------------------------
int __cdecl sub_10014390(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1006CE74[a1];
  return result;
}
// 1006CE74: using guessed type __int16 word_1006CE74[];

//----- (100143B0) --------------------------------------------------------
signed int sub_100143B0()
{
  signed int result; // eax@1

  result = -15;
  dword_1069DC2C = -15;
  dword_1069DC38 = -15;
  dword_1069DC14 = -15;
  dword_1069DC3C = -15;
  dword_1069DC28 = -15;
  dword_1069DC18 = -15;
  dword_1069DC10 = -15;
  dword_1069DC24 = -15;
  dword_1069DC34 = -15;
  dword_1069DC30 = -15;
  dword_1069DC20 = -15;
  dword_1069DC1C = -15;
  return result;
}
// 1069DC10: using guessed type int dword_1069DC10;
// 1069DC14: using guessed type int dword_1069DC14;
// 1069DC18: using guessed type int dword_1069DC18;
// 1069DC1C: using guessed type int dword_1069DC1C;
// 1069DC20: using guessed type int dword_1069DC20;
// 1069DC24: using guessed type int dword_1069DC24;
// 1069DC28: using guessed type int dword_1069DC28;
// 1069DC2C: using guessed type int dword_1069DC2C;
// 1069DC30: using guessed type int dword_1069DC30;
// 1069DC34: using guessed type int dword_1069DC34;
// 1069DC38: using guessed type int dword_1069DC38;
// 1069DC3C: using guessed type int dword_1069DC3C;

//----- (10014400) --------------------------------------------------------
signed int __usercall sub_10014400@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_10039B10((int)&off_1006CE94);
      break;
    case 0:
      result = sub_10039B10((int)&off_1006CEA8);
      break;
    case 1:
      result = sub_10039B10((int)&off_1006CEBC);
      break;
    case 2:
      result = sub_10039B10((int)&off_1006CEE4);
      break;
    case 3:
      result = sub_10039B10((int)&off_1006CED0);
      break;
    case 5:
      result = sub_10039B10((int)&off_1006CEF8);
      break;
    default:
      result = sub_10039B10(a2);
      break;
  }
  return result;
}
// 1006CE94: using guessed type char *off_1006CE94;
// 1006CEA8: using guessed type char *off_1006CEA8;
// 1006CEBC: using guessed type char *off_1006CEBC;
// 1006CED0: using guessed type char *off_1006CED0;
// 1006CEE4: using guessed type char *off_1006CEE4;
// 1006CEF8: using guessed type char *off_1006CEF8;

//----- (100144A0) --------------------------------------------------------
int __usercall sub_100144A0@<eax>(char a1@<al>)
{
  return sub_100383E0(dword_1006C9C4[a1]);
}
// 1006C9C4: using guessed type int dword_1006C9C4[];

//----- (100144C0) --------------------------------------------------------
int __usercall sub_100144C0@<eax>(char a1@<al>)
{
  return sub_10038400(dword_1006C9C4[a1], 10);
}
// 1006C9C4: using guessed type int dword_1006C9C4[];

//----- (100144E0) --------------------------------------------------------
signed __int16 __usercall sub_100144E0@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10014400(a1, a1) )
        {
          sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1069DC2C + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10014400(a1, a1) )
      {
        result = *(_WORD *)(dword_1069DC38 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_1000E690(15000) )
        goto LABEL_6;
      sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10014400(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1069DC14 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10014400(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1069DC3C + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10014400(a1, a1) )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1069DC28 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10014400(a1, a1) )
        {
          result = *(_WORD *)(dword_1069DC18 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 1069DC14: using guessed type int dword_1069DC14;
// 1069DC18: using guessed type int dword_1069DC18;
// 1069DC28: using guessed type int dword_1069DC28;
// 1069DC2C: using guessed type int dword_1069DC2C;
// 1069DC38: using guessed type int dword_1069DC38;
// 1069DC3C: using guessed type int dword_1069DC3C;

//----- (10014720) --------------------------------------------------------
char __cdecl sub_10014720(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_100144E0(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10014400(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC2C + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10014400(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC38 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10014400(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC14 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10014400(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC3C + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10014400(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC28 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10014400(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1069DC18 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 1069DC14: using guessed type int dword_1069DC14;
// 1069DC18: using guessed type int dword_1069DC18;
// 1069DC28: using guessed type int dword_1069DC28;
// 1069DC2C: using guessed type int dword_1069DC2C;
// 1069DC38: using guessed type int dword_1069DC38;
// 1069DC3C: using guessed type int dword_1069DC3C;

//----- (100148A0) --------------------------------------------------------
char __cdecl sub_100148A0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_100144E0(a1, a2);
  if ( v3 != -1 && !sub_100144C0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC2C + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC38 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC14 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC3C + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC28 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10014400(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1069DC18 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_100144A0(a1);
        return 1;
      default:
LABEL_17:
        sub_100144A0(a1);
        break;
    }
  }
  return 0;
}
// 1069DC14: using guessed type int dword_1069DC14;
// 1069DC18: using guessed type int dword_1069DC18;
// 1069DC28: using guessed type int dword_1069DC28;
// 1069DC2C: using guessed type int dword_1069DC2C;
// 1069DC38: using guessed type int dword_1069DC38;
// 1069DC3C: using guessed type int dword_1069DC3C;

//----- (10014A00) --------------------------------------------------------
char __cdecl sub_10014A00(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10014400(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_100144E0(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10014720(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10038330();
      v13 = 0;
      LOBYTE(v7) = sub_1002B720(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10014B40) --------------------------------------------------------
char __cdecl sub_10014B40(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_100144E0(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1002B720(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10014C20) --------------------------------------------------------
char __cdecl sub_10014C20(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10038330();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_100144E0(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1069DC2C + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC2C + 210116;
          v12 = dword_1069DC2C + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_1069DC38 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC38 + 257156;
          v12 = dword_1069DC38 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_1069DC14 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC14 + 321708;
          v12 = dword_1069DC14 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1069DC3C + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC3C + 326220;
          v12 = dword_1069DC3C + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_1069DC28 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC28 + 18832;
          v12 = dword_1069DC28 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10014400(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_1069DC18 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1069DC18 + 1596;
          v12 = dword_1069DC18 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_100144C0(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_100144A0(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1069DC10: using guessed type int dword_1069DC10;
// 1069DC14: using guessed type int dword_1069DC14;
// 1069DC18: using guessed type int dword_1069DC18;
// 1069DC24: using guessed type int dword_1069DC24;
// 1069DC28: using guessed type int dword_1069DC28;
// 1069DC2C: using guessed type int dword_1069DC2C;
// 1069DC34: using guessed type int dword_1069DC34;
// 1069DC38: using guessed type int dword_1069DC38;
// 1069DC3C: using guessed type int dword_1069DC3C;

//----- (10014EA0) --------------------------------------------------------
char __cdecl sub_10014EA0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10014C20(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10014ED0) --------------------------------------------------------
char __cdecl sub_10014ED0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10014C20(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10014F00) --------------------------------------------------------
char __cdecl sub_10014F00(char a1, int a2, void *a3, int a4)
{
  return sub_10014C20(a1, a2, 0, 0, a3, a4);
}

//----- (10014F40) --------------------------------------------------------
signed int sub_10014F40()
{
  return 1000;
}

//----- (10014F60) --------------------------------------------------------
int sub_10014F60()
{
  return sub_10016DC0((int)off_1006D4D8);
}
// 1006D4D8: using guessed type int (*off_1006D4D8[4])();

//----- (10014F70) --------------------------------------------------------
int sub_10014F70()
{
  return sub_10037F00(-0.0128, 0.028159998, -0.018048, 0.012672, 0.020479999, 50.0);
}

//----- (10014FC0) --------------------------------------------------------
char __thiscall sub_10014FC0(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_1000E6B0(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 1003B284: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10014FF0) --------------------------------------------------------
int __thiscall sub_10014FF0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000E6B0(46, (char *)&v2);
  return (int)v2;
}

//----- (10015060) --------------------------------------------------------
unsigned int __cdecl sub_10015060(int a1, int a2, size_t a3, int a4, int a5)
{
  int v5; // ecx@1
  unsigned int result; // eax@1
  int v7; // ebp@4
  int v8; // ebx@4
  int v9; // esi@6
  char *v10; // ebx@7
  char *v11; // [sp+0h] [bp-190h]@5
  char *v12; // [sp+4h] [bp-18Ch]@7
  char *v13; // [sp+8h] [bp-188h]@5
  int v14; // [sp+10h] [bp-180h]@4
  int v15; // [sp+14h] [bp-17Ch]@3
  size_t v16; // [sp+1Ch] [bp-174h]@5
  char v17; // [sp+24h] [bp-16Ch]@6

  v5 = a1;
  result = a4;
  if ( a1 && (signed int)a3 <= 360 )
  {
    result = 0;
    v15 = 0;
    do
    {
      v7 = *(int *)((char *)&dword_1006EA98 + result);
      v8 = *(int *)((char *)&dword_1006EA98 + result);
      v14 = *(int *)((char *)&dword_1006EA98 + result);
      if ( v7 < a2 )
      {
        v16 = a3 * v7;
        v11 = (char *)(v5 + a3 * v7);
        v13 = (char *)v5;
        do
        {
          memcpy_0(&v17, v11, a3);
          v9 = v8;
          if ( v8 >= v7 )
          {
            v10 = v13;
            v12 = v11;
            do
            {
              if ( ((int (__cdecl *)(char *, char *, int))a4)(&v17, v10, a5) >= 0 )
                break;
              memcpy_0(v12, v10, a3);
              v12 -= v16;
              v9 -= v7;
              v10 -= v16;
            }
            while ( v9 >= v7 );
            v8 = v14;
          }
          memcpy_0((void *)(a1 + a3 * v9), &v17, a3);
          v11 += a3;
          v13 += a3;
          v14 = ++v8;
        }
        while ( v8 < a2 );
        result = v15;
        v5 = a1;
      }
      result += 4;
      v15 = result;
    }
    while ( result < 0x40 );
  }
  return result;
}
// 1006EA98: using guessed type int dword_1006EA98;

//----- (100151E0) --------------------------------------------------------
unsigned int __cdecl sub_100151E0(int a1, int a2, size_t a3, int a4)
{
  return sub_10015060(a1, a2, a3, (int)sub_100151C0, a4);
}
// 100151C0: using guessed type int sub_100151C0();

//----- (10015210) --------------------------------------------------------
bool __cdecl sub_10015210(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_1077A648[v2 / 4] && word_1077A644[v2 / 2] && dword_1077A640[v2 / 4] )
      result = 1;
  }
  return result;
}
// 1077A640: using guessed type int dword_1077A640[];
// 1077A644: using guessed type __int16 word_1077A644[];
// 1077A648: using guessed type int dword_1077A648[];

//----- (10015250) --------------------------------------------------------
int __cdecl sub_10015250(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10015210(0, a1) )
    result = dword_1077A648[3 * v1];
  else
    result = 0;
  return result;
}
// 1077A648: using guessed type int dword_1077A648[];

//----- (10015280) --------------------------------------------------------
int __cdecl sub_10015280(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10015410) --------------------------------------------------------
int sub_10015410()
{
  int result; // eax@1

  sub_10038700(6361, (int)&unk_1069DCC8, 4);
  result = sub_10038700(6362, (int)&unk_1069DCCC, 4);
  dword_1069DCD0 = 1379255385;
  return result;
}
// 1069DCD0: using guessed type int dword_1069DCD0;

//----- (10015440) --------------------------------------------------------
unsigned int __cdecl sub_10015440(char *a1)
{
  return sub_1002B410(a1, -100, 100, 0, 0);
}

//----- (10015460) --------------------------------------------------------
int __cdecl sub_10015460(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 2u, 0, 0);
}

//----- (10015480) --------------------------------------------------------
int __cdecl sub_10015480(_BYTE *a1)
{
  return sub_1002B670(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100154A0) --------------------------------------------------------
int __cdecl sub_100154A0(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 1u, 1u, 0);
}

//----- (100154C0) --------------------------------------------------------
unsigned int __cdecl sub_100154C0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1002B2D0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1002B580((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1002B2D0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B580((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B580((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100157F0) --------------------------------------------------------
unsigned int __cdecl sub_100157F0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1002B2D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B2D0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002B410((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10015C30) --------------------------------------------------------
unsigned int __cdecl sub_10015C30(_BYTE *a1)
{
  return sub_1002B460(a1, -1, 5, -1, 0);
}

//----- (10015C50) --------------------------------------------------------
int __cdecl sub_10015C50(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 5u, 0, 0);
}

//----- (10015C70) --------------------------------------------------------
int __cdecl sub_10015C70(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 4u, 2u, 0);
}

//----- (10015C90) --------------------------------------------------------
int __cdecl sub_10015C90(_BYTE *a1)
{
  return sub_1002B670(a1, 0, 2u, 0, 0);
}

//----- (10015CB0) --------------------------------------------------------
int __cdecl sub_10015CB0(int a1)
{
  return sub_1002B320(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10015D00) --------------------------------------------------------
int __cdecl sub_10015D00(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10015CB0((int)(a1 + 4));
  if ( !result )
    result = sub_10015C70(a1);
  return result;
}

//----- (10015D20) --------------------------------------------------------
int __cdecl sub_10015D20(int a1)
{
  int result; // eax@1

  result = sub_10015C50((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10015C50((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10015C50((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1002BAD0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1002B2D0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1002B2D0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1002B2D0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1002B2D0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10015DB0) --------------------------------------------------------
unsigned int __cdecl sub_10015DB0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015C30((_BYTE *)a1);
  if ( !result )
    result = sub_10015C30((_BYTE *)(a1 + 4));
  return result;
}

//----- (10015DD0) --------------------------------------------------------
signed int __cdecl sub_10015DD0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1002B2D0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1002B2D0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10015E20) --------------------------------------------------------
unsigned int __cdecl sub_10015E20(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015C30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10015C30((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10015C30((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10015C30((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1002B2D0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10015E80) --------------------------------------------------------
int __cdecl sub_10015E80(_BYTE *a1)
{
  return sub_1002B670(a1, 0, 0x20u, 2u, 0);
}

//----- (10015EA0) --------------------------------------------------------
unsigned int __cdecl sub_10015EA0(_BYTE *a1)
{
  return sub_1002B460(a1, -1, 4, -1, 0);
}

//----- (10015EC0) --------------------------------------------------------
int __cdecl sub_10015EC0(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 9u, 0, 0);
}

//----- (10015EE0) --------------------------------------------------------
int __cdecl sub_10015EE0(_BYTE *a1)
{
  return sub_1002B670(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10015F00) --------------------------------------------------------
signed int __cdecl sub_10015F00(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1002B670(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10015F30) --------------------------------------------------------
int __cdecl sub_10015F30(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1002B5D0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10015F70) --------------------------------------------------------
int __cdecl sub_10015F70(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10015F00((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10015F30((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10015F30((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002BBF0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10015F30((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10016000) --------------------------------------------------------
int __cdecl sub_10016000(int a1)
{
  int result; // eax@1

  result = sub_1002B580((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1002B580((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10016030) --------------------------------------------------------
int __cdecl sub_10016030(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 3u, 1u, 0);
}

//----- (10016050) --------------------------------------------------------
unsigned int __cdecl sub_10016050(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002B460((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1002B460((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10016080) --------------------------------------------------------
int __cdecl sub_10016080(int a1)
{
  int result; // eax@1

  result = sub_1002B320(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1002B320(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1002B320(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1002B320(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1002B320(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10016170) --------------------------------------------------------
int __cdecl sub_10016170(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1002B2D0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1002B580((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10016050(a1 + 36);
        if ( !result )
        {
          result = sub_1002B320(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10016080(a1 + 8);
            if ( !result )
            {
              result = sub_10016050(a1 + 28);
              if ( !result )
              {
                result = sub_1002B5D0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10015460((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10016000(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1002B2D0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10016030((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10016280) --------------------------------------------------------
signed int __cdecl sub_10016280(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1002B580(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100162B0) --------------------------------------------------------
signed int __cdecl sub_100162B0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1002B5D0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100162E0) --------------------------------------------------------
int __cdecl sub_100162E0(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10016340) --------------------------------------------------------
int __cdecl sub_10016340(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1002B2D0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_100162E0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10016350) --------------------------------------------------------
signed int __cdecl sub_10016350(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1002B670(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10016380) --------------------------------------------------------
int __cdecl sub_10016380(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1002B580((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1002B580((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10016400) --------------------------------------------------------
unsigned int __cdecl sub_10016400(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015440((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10015440((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10015440((char *)a1);
      if ( !result )
        result = sub_10015440((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10016440) --------------------------------------------------------
unsigned int __cdecl sub_10016440(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10016400(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10015460((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100154A0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10016490) --------------------------------------------------------
int __cdecl sub_10016490(int a1)
{
  int result; // eax@1

  result = sub_10015480((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1002B5D0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (100164C0) --------------------------------------------------------
int __cdecl sub_100164C0(int a1)
{
  int result; // eax@1

  result = sub_10015C90((_BYTE *)a1);
  if ( !result )
    result = sub_10015EE0((_BYTE *)(a1 + 4));
  return result;
}

//----- (100164F0) --------------------------------------------------------
unsigned int __cdecl sub_100164F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015C30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10015C30((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10015EA0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10016520) --------------------------------------------------------
unsigned int __cdecl sub_10016520(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015C30((_BYTE *)a1);
  if ( !result )
    result = sub_10015EC0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10016540) --------------------------------------------------------
unsigned int __cdecl sub_10016540(int a1)
{
  unsigned int result; // eax@1

  result = sub_10015C30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1002B580((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10015EA0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10016580) --------------------------------------------------------
void __cdecl __noreturn sub_10016580(int a1)
{
  exit_0(a1 + 4);
}

//----- (100166F0) --------------------------------------------------------
signed int __cdecl sub_100166F0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10016280((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_100162B0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10016280((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10016750) --------------------------------------------------------
signed int __usercall sub_10016750@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100166F0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1002B580((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1002B2D0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_100157F0(v2 + 5, a2);
    else
      result = sub_100154C0(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10016350((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10016820) --------------------------------------------------------
signed int __cdecl sub_10016820(int a1)
{
  return sub_10016750(a1, 0);
}

//----- (10016830) --------------------------------------------------------
char __cdecl sub_10016830(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10016870) --------------------------------------------------------
int __cdecl sub_10016870(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10037CE0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (100168E0) --------------------------------------------------------
bool __cdecl sub_100168E0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1000EB20(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_10072458[(unsigned __int8)v4](v3) )
    {
      sub_10016870((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10016E90(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10014390(2) )
    result = 0;
  else
    result = sub_10014ED0(2, v5, a2) == 1 && !sub_1002BB90(a2);
  return result;
}
// 10072458: using guessed type int (__cdecl *off_10072458[3])(char);

//----- (100169A0) --------------------------------------------------------
char __cdecl sub_100169A0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_100168E0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10016E70(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10016A60) --------------------------------------------------------
char __thiscall sub_10016A60(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1069DCE0 = sub_1000E750(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1069DCE8, 0, 0x1540u);
  memset(&unk_1069F228, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1069DCE8;
  do
  {
    sub_1002BDD0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1069F228 );
  v3 = 0;
  v4 = &unk_1069F228;
  do
  {
    result = sub_1002BE50(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_106A0BD8 );
  return result;
}
// 1069DCE0: using guessed type int dword_1069DCE0;
// 106A0BD8: using guessed type int dword_106A0BD8;

//----- (10016AF0) --------------------------------------------------------
char __cdecl sub_10016AF0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1069DCE0 != 1379255385;
  v7 = 0;
  v8 = dword_1069DCE0 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10038600(86, 10);
      memset((char *)&unk_1069DCE8 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1002BDD0(a1, (int)&unk_1069DCE8 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1069DFC0[v6] == a2 || byte_1069DFC1[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100385D0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1069DCE0: using guessed type int dword_1069DCE0;

//----- (10016BB0) --------------------------------------------------------
char __cdecl sub_10016BB0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10016AF0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10016BE0) --------------------------------------------------------
int __cdecl sub_10016BE0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= LOWORD((&off_10087F84)[2 * *(_BYTE *)a1 + 2]) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - LOBYTE((&off_10087F84)[2 * *(_BYTE *)a1 + 2]);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 10087F84: using guessed type char *;

//----- (10016CD0) --------------------------------------------------------
__int16 __cdecl sub_10016CD0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10016D20) --------------------------------------------------------
__int16 __cdecl sub_10016D20(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10016CD0((int)&v5, *a1);
  sub_10016BE0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10016DA0) --------------------------------------------------------
int __cdecl sub_10016DA0(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_1077A618)();
  *a1 = result;
  return result;
}
// 1077A618: using guessed type int dword_1077A618;

//----- (10016DC0) --------------------------------------------------------
int __cdecl sub_10016DC0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_106A0BD8 = *(_DWORD *)a1;
  dword_106A0BDC = *(_DWORD *)(a1 + 4);
  dword_106A0BE0 = *(_DWORD *)(a1 + 8);
  dword_106A0BE4 = *(_DWORD *)(a1 + 12);
  dword_1077A618 = (int)&dword_106A0BD8;
  return result;
}
// 106A0BD8: using guessed type int dword_106A0BD8;
// 106A0BDC: using guessed type int dword_106A0BDC;
// 106A0BE0: using guessed type int dword_106A0BE0;
// 106A0BE4: using guessed type int dword_106A0BE4;
// 1077A618: using guessed type int dword_1077A618;

//----- (10016E00) --------------------------------------------------------
int __cdecl sub_10016E00(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10016E20) --------------------------------------------------------
char *__cdecl sub_10016E20(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_10087FA0;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_1077A614[(unsigned __int16)sub_10016E00(a1)];
  return result;
}
// 10037CA8: using guessed type int TXT_get_static_string(void);

//----- (10016E60) --------------------------------------------------------
signed int __fastcall sub_10016E60(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10016E70) --------------------------------------------------------
char __cdecl sub_10016E70(unsigned __int8 a1)
{
  return byte_10087FAC[6 * sub_10016E60(a1)];
}

//----- (10016E90) --------------------------------------------------------
__int16 __cdecl sub_10016E90(unsigned __int8 a1)
{
  return word_10087FA8[3 * sub_10016E60(a1)];
}
// 10087FA8: using guessed type __int16 word_10087FA8[];

//----- (10016EB0) --------------------------------------------------------
char *__cdecl sub_10016EB0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_1005377D;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10016F00) --------------------------------------------------------
int sub_10016F00()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_100382C0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_106A0BFC[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_106A0BFC[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 106A0BFC: using guessed type int dword_106A0BFC[];

//----- (10016F40) --------------------------------------------------------
int __cdecl sub_10016F40(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10016FB0) --------------------------------------------------------
signed int __cdecl sub_10016FB0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10017050) --------------------------------------------------------
int __usercall sub_10017050@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10016FB0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017080) --------------------------------------------------------
signed int __usercall sub_10017080@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10016FB0((_BYTE *)a3, (int)(&off_100888F8)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100888FC[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1003D432(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1003D432(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1003D432(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100888F8: using guessed type char *off_100888F8;

//----- (10017250) --------------------------------------------------------
char *__usercall sub_10017250@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_10053650, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (100172B0) --------------------------------------------------------
int __usercall sub_100172B0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10016FB0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017340) --------------------------------------------------------
int __usercall sub_10017340@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10017050(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10017390) --------------------------------------------------------
char **__usercall sub_10017390@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10016EB0(v6);
      if ( !sub_10016FB0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (100173F0) --------------------------------------------------------
const char *__usercall sub_100173F0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10017410) --------------------------------------------------------
int __usercall sub_10017410@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_106A0BE8[sub_10016F00()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (10017450) --------------------------------------------------------
int __usercall sub_10017450@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10017080(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (100174E0) --------------------------------------------------------
int __usercall sub_100174E0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10017630) --------------------------------------------------------
int __usercall sub_10017630@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10019380(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10017F10(v3, v6, 0);
        v7 = -*v3;
        sub_10019380(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10019380(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100885B0);
      sub_1002BFF0(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100885B0);
      sub_10019380(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (100176D0) --------------------------------------------------------
int __usercall sub_100176D0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10017710) --------------------------------------------------------
char *__cdecl sub_10017710(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10017250(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10017250(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10017250(result, v5, (int)&v20);
      v10 = (const char *)&unk_1005377D;
    }
    LOBYTE(v9) = 0;
    sub_10017250(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10017250(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10017250(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10017250(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10019310(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10017710: using guessed type int var_61C[6];

//----- (100178C0) --------------------------------------------------------
int __usercall sub_100178C0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10016EB0((char **)a1);
  result = sub_100193A0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100885B0);
  return result;
}

//----- (100178F0) --------------------------------------------------------
int __usercall sub_100178F0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100885B0);
  v2 = (unsigned int)sub_10016EB0((char **)a1);
  return sub_10019380(10, v2);
}

//----- (10017920) --------------------------------------------------------
void __cdecl sub_10017920(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10016EB0(v5);
            v7 = sub_10016EB0((char **)v3);
            if ( !sub_10016F40(v7, (int)v6) )
            {
              v8 = sub_10016EB0((char **)v3);
              sub_10019440(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10016EB0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10016EB0((char **)v3);
        sub_10019440(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_100173F0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_10019E60("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10016EB0((char **)v3);
            sub_10019480(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10016F40(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_100173F0(v18);
                  v25 = sub_10019E60("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10016EB0((char **)v3);
                  sub_10019480(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10016EB0((char **)v3);
                  sub_10019480(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10016EB0((char **)v3);
              sub_10019480(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10016EB0((char **)v3);
              sub_10019480(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10016EB0((char **)v3);
              sub_10019480(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10017920(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10016EB0((char **)v3);
            sub_10019480(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10016EB0((char **)v3);
            sub_10019480(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10016EB0((char **)v3);
          sub_10019480(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10016EB0((char **)v3);
        sub_10019480(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10016EB0(a2);
      sub_10019440(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10017D90) --------------------------------------------------------
int sub_10017D90()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_106A0BE8[sub_10016F00()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10017920(i, 0, &v2);
  }
  return v2;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (10017DE0) --------------------------------------------------------
void *sub_10017DE0()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_106A0BE8[0] = 0;
  dword_106A0BEC = 0;
  dword_106A0BF0 = 0;
  dword_106A0BF4 = 0;
  dword_106A0BF8 = 0;
  result = &unk_106A0C10;
  dword_106A0BFC[0] = -1;
  dword_106A0C00 = -1;
  dword_106A0C04 = -1;
  dword_106A0C08 = -1;
  dword_106A0C0C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_100176D0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];
// 106A0BEC: using guessed type int dword_106A0BEC;
// 106A0BF0: using guessed type int dword_106A0BF0;
// 106A0BF4: using guessed type int dword_106A0BF4;
// 106A0BF8: using guessed type int dword_106A0BF8;
// 106A0BFC: using guessed type int dword_106A0BFC[];
// 106A0C00: using guessed type int dword_106A0C00;
// 106A0C04: using guessed type int dword_106A0C04;
// 106A0C08: using guessed type int dword_106A0C08;
// 106A0C0C: using guessed type int dword_106A0C0C;

//----- (10017E40) --------------------------------------------------------
char *sub_10017E40()
{
  return (char *)&unk_106A0C10 + 56 * sub_10016F00();
}

//----- (10017E60) --------------------------------------------------------
char sub_10017E60()
{
  return sub_10017E40()[33];
}

//----- (10017E70) --------------------------------------------------------
char __cdecl sub_10017E70(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10017E40();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10018F00(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10017EB0) --------------------------------------------------------
int *__usercall sub_10017EB0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10017E40() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10016FB0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10017F00) --------------------------------------------------------
char **sub_10017F00()
{
  return &off_10088960;
}
// 10088960: using guessed type char *off_10088960;

//----- (10017F10) --------------------------------------------------------
int __cdecl sub_10017F10(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1001E0D0();
  v3 = sub_10017E40();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10017D90();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_100178C0(a2);
    if ( a3 )
    {
      v7 = sub_10017630(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10017630(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_100178F0(a2);
        return v7;
      }
    }
    sub_100178F0(a2);
    result = v7;
  }
  return result;
}

//----- (10017FC0) --------------------------------------------------------
int __cdecl sub_10017FC0(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10017250(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10017250(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10017250(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10019310(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10017250(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10017250(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10017250(v14, "group-begin", (int)&v29);
          sub_10019310(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10016EB0(v15);
          sub_10017FC0(v16[2], v16[3], v16[4], v17, a4);
          sub_10016EB0(v16);
          v18 = sub_10017710((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10017250(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10017250(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10017250(v20, "group-end", (int)&v29);
          result = sub_10019310(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10017250(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10017250(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10017250(v21, a4, (int)&v28);
          v23 = (const char *)&unk_1005377D;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10017250(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10017250(v24, *(const char **)v5, (int)&v30);
        result = sub_10019310(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10017FC0: using guessed type int var_414[4];

//----- (100181D0) --------------------------------------------------------
char *__usercall sub_100181D0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10017250(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10017250(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10019310(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10017FC0(a3, (int)a4, a5, a2, 0);
    result = sub_10017710(a3, a4, a5, 0);
  }
  return result;
}
// 100181D0: using guessed type int var_20C[2];

//----- (10018290) --------------------------------------------------------
char *__cdecl sub_10018290(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_106A0BE8[sub_10016F00()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10016EB0((char **)v2);
    sub_100181D0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10017E40() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_100181D0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (10018330) --------------------------------------------------------
int *__cdecl sub_10018330(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_106A0BE8[sub_10016F00()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10016EB0(v2);
      if ( !sub_10016FB0(a1, (int)v4) )
      {
        v5 = sub_10016EB0(v3);
        sub_100181D0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10017E40();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10016FB0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_100181D0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (100183F0) --------------------------------------------------------
int __usercall sub_100183F0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10017410(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10017F10((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10017410(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10017F10((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_100178C0(v5);
        sub_10017630(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_100178F0(v8);
          v10 = sub_10017410(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10018550) --------------------------------------------------------
signed int __usercall sub_10018550@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_106A0BE8[sub_10016F00()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10017F10((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (100185C0) --------------------------------------------------------
int __cdecl sub_100185C0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10017E40();
  switch ( a1 )
  {
    case 9:
      sub_10019380(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10016FB0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10016FB0(v6, (int)"-q") )
            {
              sub_10018330(v6);
              v9 = sub_10017D90();
              sub_10019380(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10018290(0);
              v8 = sub_10017D90();
              sub_10019380(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10018290(1);
            v7 = sub_10017D90();
            sub_10019380(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10019400(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10019380(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10018290(0);
        v4 = sub_10017D90();
        sub_10019380(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10019380(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_106A0BE8[sub_10016F00()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_100185C0 )
              v12(2, (int)&unk_100885B0);
          }
        }
      }
      sub_1001E0D0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10019380(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_106A0BE8[sub_10016F00()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10019400(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_100183F0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10019400(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10018550((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10019400(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_100185C0 )
          v15(3, (int)&unk_100885B0);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 100185C0: using guessed type int __cdecl sub_100185C0(int, int);
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (100188A0) --------------------------------------------------------
char **sub_100188A0()
{
  return off_10088754;
}
// 10088754: using guessed type char *off_10088754[3];

//----- (100188B0) --------------------------------------------------------
int __usercall sub_100188B0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10017340(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10017450(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_100188A0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (100189A0) --------------------------------------------------------
int __cdecl sub_100189A0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10017E40();
  *a1 = 0;
  v4 = sub_10019E60("Processing command '%s'", v2);
  sub_10019400(3, (int)&unk_10089100, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_100174E0(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_100183F0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10018550((int)v3);
    v11 = 0;
    v6 = sub_10016F00();
    v7 = sub_10017390((int (**)(void))dword_106A0BE8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_100172B0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_100172B0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10017F10(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10017F10(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_100188B0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10017EB0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_100188B0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_100188A0();
        result = sub_100188B0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 106A0BE8: using guessed type int dword_106A0BE8[];
// 100189A0: using guessed type char var_2D4[720];

//----- (10018BE0) --------------------------------------------------------
int sub_10018BE0()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_100189A0(&v4);
  if ( !sub_10017E40()[32] )
    sub_10019380(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_10019E60("%s %i, %s", "Command status:", v0, &v4);
    sub_10019400(3, (int)&unk_10089100, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_10019E60("%s %i", "Command status:", v0);
    sub_10019400(3, (int)&unk_10089100, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10018CC0) --------------------------------------------------------
int __cdecl sub_10018CC0(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_106A0BE8[sub_10016F00()] = a1;
  sub_10017E40()[32] = a3;
  sub_1001E0D0();
  sub_1002C200(a2);
  v3 = sub_10017F00();
  sub_10018DF0(v3);
  return sub_10018BE0();
}
// 106A0BE8: using guessed type int dword_106A0BE8[];

//----- (10018D10) --------------------------------------------------------
int __cdecl sub_10018D10(int a1)
{
  return a1 + 9;
}

//----- (10018D20) --------------------------------------------------------
int __cdecl sub_10018D20(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_100382C0();
  memset(a1, 0, 0xDCu);
  sub_1000D6F0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_10018D10(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1002C390((int)a1, (int)v3);
}

//----- (10018DA0) --------------------------------------------------------
int __cdecl sub_10018DA0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1002C5A0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10018DD0) --------------------------------------------------------
signed int __cdecl sub_10018DD0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_10039DA0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10038330();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10038330() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1002C390(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (10018DF0) --------------------------------------------------------
char __cdecl sub_10018DF0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10017E40() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1002C040("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10018BE0() )
          v7 = 0;
      }
      v5 = sub_1002C040("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10018BE0() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10018F00) --------------------------------------------------------
char __cdecl sub_10018F00(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10018F30) --------------------------------------------------------
bool __cdecl sub_10018F30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10018F60) --------------------------------------------------------
bool __cdecl sub_10018F60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10018F90) --------------------------------------------------------
bool __cdecl sub_10018F90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10018FC0) --------------------------------------------------------
bool __cdecl sub_10018FC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10018FF0) --------------------------------------------------------
bool __cdecl sub_10018FF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10019020) --------------------------------------------------------
bool __cdecl sub_10019020(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10019060) --------------------------------------------------------
bool __cdecl sub_10019060(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (100190A0) --------------------------------------------------------
bool __cdecl sub_100190A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (100190D0) --------------------------------------------------------
bool __cdecl sub_100190D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10019100) --------------------------------------------------------
char __cdecl sub_10019100(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10019130) --------------------------------------------------------
bool __cdecl sub_10019130(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10019160) --------------------------------------------------------
bool __cdecl sub_10019160(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10019190) --------------------------------------------------------
bool __cdecl sub_10019190(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (100191C0) --------------------------------------------------------
bool __cdecl sub_100191C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (100191F0) --------------------------------------------------------
bool __cdecl sub_100191F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_10089100, 9u);
}

//----- (10019220) --------------------------------------------------------
bool __cdecl sub_10019220(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10019250) --------------------------------------------------------
bool __cdecl sub_10019250(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10019280) --------------------------------------------------------
bool __cdecl sub_10019280(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (100192B0) --------------------------------------------------------
bool __cdecl sub_100192B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (100192E0) --------------------------------------------------------
bool __cdecl sub_100192E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10019310) --------------------------------------------------------
int __cdecl sub_10019310(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10017E40() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10019380) --------------------------------------------------------
int __cdecl sub_10019380(int a1, char a2)
{
  return sub_10019310(a1, (int)&a2, 1);
}

//----- (100193A0) --------------------------------------------------------
int __cdecl sub_100193A0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10019310(a1, (int)&v4, 2);
}

//----- (100193D0) --------------------------------------------------------
int __cdecl sub_100193D0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10019310(a1, (int)&v5, 3);
}

//----- (10019400) --------------------------------------------------------
int __cdecl sub_10019400(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10019310(a1, (int)&v6, 4);
}

//----- (10019440) --------------------------------------------------------
int __cdecl sub_10019440(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10019310(a1, (int)&v7, 5);
}

//----- (10019480) --------------------------------------------------------
int __cdecl sub_10019480(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10019310(a1, (int)&v8, 6);
}

//----- (100194D0) --------------------------------------------------------
char __cdecl sub_100194D0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10017E40();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10019500) --------------------------------------------------------
char __cdecl sub_10019500(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10019510) --------------------------------------------------------
char __cdecl sub_10019510(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  __int16 *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = &word_1004F3E0, v3) )
          v11 = (__int16 *)&unk_1005377D;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1002C6C0(v16) )
        sub_1002C6A0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1002C6D0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1002C6C0: using guessed type _DWORD __cdecl sub_1002C6C0(_DWORD);
// 1004F3E0: using guessed type __int16 word_1004F3E0;
// 10019510: using guessed type char var_104[255];

//----- (10019690) --------------------------------------------------------
signed int __cdecl sub_10019690(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (100196D0) --------------------------------------------------------
signed int __cdecl sub_100196D0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10019770) --------------------------------------------------------
char __cdecl sub_10019770(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (100197D0) --------------------------------------------------------
char __cdecl sub_100197D0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1002C680(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (10019840) --------------------------------------------------------
char *__cdecl sub_10019840(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_106A0D28, v1, v2);
  *(&byte_106A0D28 + v2) = 0;
  return &byte_106A0D28;
}

//----- (100198E0) --------------------------------------------------------
int __cdecl sub_100198E0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10019950) --------------------------------------------------------
bool __cdecl sub_10019950(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1003D432(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1003D432(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (100199E0) --------------------------------------------------------
char __cdecl sub_100199E0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10019A90) --------------------------------------------------------
char __cdecl sub_10019A90(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10019AA0) --------------------------------------------------------
char __cdecl sub_10019AA0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1002C680(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (10019B20) --------------------------------------------------------
int (__cdecl *__cdecl sub_10019B20(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1002C750((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (10019B70) --------------------------------------------------------
signed int __cdecl sub_10019B70(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_10019AA0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10019BC0) --------------------------------------------------------
char *__cdecl sub_10019BC0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  __int16 *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1002C040("CFG_ActDir", (int)&unk_1005377D);
      v10 = sub_1002C040("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1002C040("CFG_ExpDir", (int)&unk_1005377D);
      v10 = sub_1002C040("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1002C040("CFG_ActDir", (int)&unk_1005377D);
      break;
    case 4:
      v10 = sub_1002C040("CFG_ExpDir", (int)&unk_1005377D);
      break;
    default:
      v10 = (char *)&unk_1005377D;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = &word_1004F3E0, v14) )
    v15 = (__int16 *)&unk_1005377D;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1004F3E0: using guessed type __int16 word_1004F3E0;
// 10019BC0: using guessed type char var_104[256];

//----- (10019D40) --------------------------------------------------------
int sub_10019D40()
{
  return dword_106A5A18[sub_10016F00()];
}
// 106A5A18: using guessed type int dword_106A5A18[];

//----- (10019D50) --------------------------------------------------------
const char *__cdecl sub_10019D50(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1008932C[a1];
  return result;
}
// 1008932C: using guessed type char *off_1008932C[7];

//----- (10019D70) --------------------------------------------------------
int __cdecl sub_10019D70(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10019440(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (10019E20) --------------------------------------------------------
int __cdecl sub_10019E20(int a1)
{
  int result; // eax@1

  result = sub_10016F00();
  dword_106A7B24[result] = a1;
  return result;
}
// 106A7B24: using guessed type int dword_106A7B24[];

//----- (10019E40) --------------------------------------------------------
int __cdecl sub_10019E40(int a1)
{
  int result; // eax@1

  result = sub_10016F00();
  dword_106A5A18[result] = a1;
  return result;
}
// 106A5A18: using guessed type int dword_106A5A18[];

//----- (10019E60) --------------------------------------------------------
char *sub_10019E60(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10016F00() << 8;
  _vsnprintf(&byte_106A0E28[v1], 0x100u, a1, va);
  result = &byte_106A0E28[v1];
  byte_106A0F26[v1] = 42;
  byte_106A0F27[v1] = 0;
  return result;
}

//----- (10019EA0) --------------------------------------------------------
char *__usercall sub_10019EA0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_10089340[a1 & 1];
  else
    result = off_10089338[a2];
  return result;
}
// 10089338: using guessed type char *off_10089338[4];
// 10089340: using guessed type char *off_10089340[2];

//----- (10019EC0) --------------------------------------------------------
char __usercall sub_10019EC0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10016F00();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_10019D40() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_106A9118[v6];
      v12 = dword_106A912C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_106A5A2C[v6];
      v12 = dword_106A7B10[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 106A5A2C: using guessed type int dword_106A5A2C[];
// 106A7B10: using guessed type int dword_106A7B10[];
// 106A9118: using guessed type int dword_106A9118[];
// 106A912C: using guessed type int dword_106A912C[];

//----- (1001A0A0) --------------------------------------------------------
int sub_1001A0A0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1001A0C0) --------------------------------------------------------
int sub_1001A0C0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1001A0E0) --------------------------------------------------------
int __cdecl sub_1001A0E0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10016F00();
  dword_106A7B10[result] = a1;
  if ( a2 >= 0 )
  {
    dword_106A5A2C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_10019E60(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10019400(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_106A5A2C[result] = 8;
  }
  return result;
}
// 106A5A2C: using guessed type int dword_106A5A2C[];
// 106A7B10: using guessed type int dword_106A7B10[];

//----- (1001A140) --------------------------------------------------------
int __cdecl sub_1001A140(int a1)
{
  return sub_1001A0E0(0, a1);
}

//----- (1001A150) --------------------------------------------------------
int __cdecl sub_1001A150(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10016F00();
  dword_106A912C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_106A9118[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_10019E60(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10019400(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_106A9118[result] = 8;
  }
  return result;
}
// 106A9118: using guessed type int dword_106A9118[];
// 106A912C: using guessed type int dword_106A912C[];

//----- (1001A1B0) --------------------------------------------------------
int __cdecl sub_1001A1B0(int a1)
{
  return sub_1001A150(0, a1);
}

//----- (1001A1C0) --------------------------------------------------------
bool __cdecl sub_1001A1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10017E60() )
    v8 = v8 == 0;
  v9 = (&off_10089310)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_10089300[v8 != 0];
  v19 = off_10089308[a1];
  v18 = v10;
  v21 = sub_10019EA0(0, a6);
  v22 = sub_10019EA0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1002C930();
  sub_10019310(7, (int)&v14, v11);
  sub_1002C940(v12);
  return v8;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001A300) --------------------------------------------------------
bool __cdecl sub_1001A300(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10016F00();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10017E60() )
    v16 = v16 == 0;
  sub_10019EC0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_106A1E18[v11], 0x400u, &v30, a6);
  byte_106A2216[v11] = 42;
  byte_106A2217[v11] = 0;
  v17 = sub_10019EC0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v11], 0x400u, &v30, a7);
  byte_106A2616[v11] = 42;
  byte_106A2617[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_106A2618[v11];
    byte_106A2618[v11] = 0;
  }
  else
  {
    v17 = sub_10019EC0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_106A2618[v11];
    _snprintf(&byte_106A2618[v11], 0x400u, &v30, 0);
    byte_106A2A16[v11] = 42;
    byte_106A2A17[v11] = 0;
  }
  v19 = (&off_10089310)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_106A1E18[v11];
  v27 = &byte_106A2218[v11];
  v13 = off_10089308[a1];
  v23 = off_10089300[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1002C930();
  sub_10019310(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v14);
  return v16;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001A6B0) --------------------------------------------------------
bool __cdecl sub_1001A6B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10016F00();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10017E60() )
    v20 = v20 == 0;
  sub_10019EC0((int)&v34, (char *)&unk_100895F8, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v34);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v21 = sub_10019EC0((int)&v34, (char *)&unk_100895F8, 3, 0xCu, a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v34, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v13 = &byte_106A2618[v12];
    v21 = sub_10019EC0((int)&v34, (char *)&unk_100895F8, 3, 0xCu, v10);
    _snprintf(&byte_106A2618[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v23 = (&off_10089310)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_106A1E18[v12];
  v32 = v13;
  v17 = off_10089308[a1];
  v27 = off_10089300[v20 != 0];
  v28 = v17;
  v31 = &byte_106A2218[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1002C930();
  sub_10019310(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v18);
  return v20;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001AB00) --------------------------------------------------------
bool __cdecl sub_1001AB00(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10016F00();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10017E60() )
    v25 = v25 == 0;
  sub_10019EC0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_106A1E18[v20], 0x400u, &v40);
  byte_106A2216[v20] = 42;
  byte_106A2217[v20] = 0;
  v26 = sub_10019EC0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_106A2218[v20], 0x400u, &v40, a7);
  byte_106A2616[v20] = 42;
  byte_106A2617[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_106A2618[v20];
    byte_106A2618[v20] = 0;
  }
  else
  {
    v21 = &byte_106A2618[v20];
    v26 = sub_10019EC0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_106A2618[v20], 0x400u, &v40, v28);
    byte_106A2A16[v20] = 42;
    byte_106A2A17[v20] = 0;
  }
  v29 = (&off_10089310)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_106A1E18[v20];
  v37 = &byte_106A2218[v20];
  v38 = v21;
  v22 = off_10089300[v25 != 0];
  v34 = off_10089308[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1002C930();
  sub_10019310(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v23);
  return v25;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001AFC0) --------------------------------------------------------
bool __cdecl sub_1001AFC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1008963C;
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001B380) --------------------------------------------------------
bool __cdecl sub_1001B380(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v13 = &byte_106A2618[v12];
    v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106A1E18[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089308[a1];
  v24 = off_10089300[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001B780) --------------------------------------------------------
bool __cdecl sub_1001B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001BB40) --------------------------------------------------------
bool __cdecl sub_1001BB40(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10016F00();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10017E60() )
        v18 = v18 == 0;
      sub_10019EC0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_106A1E18[3072 * v21], 0x400u, &v33, a6);
      byte_106A2216[v13] = 42;
      byte_106A2217[v13] = 0;
      v19 = sub_10019EC0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_106A2218[3072 * v21], 0x400u, &v33, a7);
      byte_106A2616[v13] = 42;
      byte_106A2617[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_106A2618[v13];
        byte_106A2618[v13] = 0;
      }
      else
      {
        v19 = sub_10019EC0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_106A2618[v13];
        _snprintf(&byte_106A2618[v13], 0x400u, &v33, a8);
        byte_106A2A16[v13] = 42;
        byte_106A2A17[v13] = 0;
      }
      v22 = (&off_10089310)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_106A1E18[3072 * v21];
      v30 = &byte_106A2218[3072 * v21];
      v15 = off_10089308[a1];
      v26 = off_10089300[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1002C930();
      sub_10019310(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10019400(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1002C940(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001C080) --------------------------------------------------------
bool __cdecl sub_1001C080(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v13 = &byte_106A2618[v12];
    v18 = sub_10019EC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106A1E18[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089308[a1];
  v24 = off_10089300[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001C460) --------------------------------------------------------
bool __cdecl sub_1001C460(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001C820) --------------------------------------------------------
bool __cdecl sub_1001C820(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001CBC0) --------------------------------------------------------
bool __cdecl sub_1001CBC0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v13 = &byte_106A2618[v12];
    v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106A1E18[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089308[a1];
  v24 = off_10089300[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001CFC0) --------------------------------------------------------
bool __cdecl sub_1001CFC0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001D360) --------------------------------------------------------
bool __cdecl sub_1001D360(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10016F00();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10017E60() )
        v19 = v19 == 0;
      sub_10019EC0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_106A1E18[3072 * v22];
      _snprintf(&byte_106A1E18[3072 * v22], 0x400u, &v35, a6);
      byte_106A2216[v13] = 42;
      byte_106A2217[v13] = 0;
      v20 = sub_10019EC0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_106A2218[3072 * v22];
      _snprintf(&byte_106A2218[v13], 0x400u, &v35, a7);
      byte_106A2616[v13] = 42;
      byte_106A2617[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_106A2618[v13];
        byte_106A2618[v13] = 0;
      }
      else
      {
        v20 = sub_10019EC0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_106A2618[v13];
        _snprintf(&byte_106A2618[v13], 0x400u, &v35, a8);
        byte_106A2A16[v13] = 42;
        byte_106A2A17[v13] = 0;
      }
      v24 = (&off_10089310)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_10089308[a1];
      v28 = off_10089300[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1002C930();
      sub_10019310(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10019400(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1002C940(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001D940) --------------------------------------------------------
bool __cdecl sub_1001D940(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v13 = &byte_106A2618[v12];
    v18 = sub_10019EC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106A1E18[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_106A2218[v12];
  v29 = v13;
  v14 = off_10089308[a1];
  v24 = off_10089300[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001DD30) --------------------------------------------------------
bool __cdecl sub_1001DD30(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10016F00();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10017E60() )
    v17 = v17 == 0;
  sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106A1E18[v12], 0x400u, &v31, a6);
  byte_106A2216[v12] = 42;
  byte_106A2217[v12] = 0;
  v18 = sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_106A2218[v12], 0x400u, &v31, a7);
  byte_106A2616[v12] = 42;
  byte_106A2617[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106A2618[v12];
    byte_106A2618[v12] = 0;
  }
  else
  {
    v18 = sub_10019EC0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_106A2618[v12];
    _snprintf(&byte_106A2618[v12], 0x400u, &v31, a8);
    byte_106A2A16[v12] = 42;
    byte_106A2A17[v12] = 0;
  }
  v20 = (&off_10089310)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_10089300[v17 != 0];
  v25 = off_10089308[a1];
  v24 = v14;
  v27 = &byte_106A1E18[v12];
  v28 = &byte_106A2218[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1002C930();
  sub_10019310(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10019400(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1002C940(v15);
  return v17;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001E0D0) --------------------------------------------------------
int sub_1001E0D0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10016F00();
  sub_10019E20(1);
  sub_1001A1B0(-1);
  result = sub_1001A140(-1);
  dword_106A5A18[v0] = 0;
  return result;
}
// 106A5A18: using guessed type int dword_106A5A18[];

//----- (1001E100) --------------------------------------------------------
BOOL __usercall sub_1001E100@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10016F00();
  sub_1002C970((int)&v13);
  sub_1002C970((int)&v14);
  sub_1002C970((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_1002D5C0((int (__cdecl *)(unsigned int))sub_1001A0A0, v7, (int)&v13) )
  {
    if ( sub_1002D5C0((int (__cdecl *)(unsigned int))sub_1001A0A0, a2, (int)&v14) )
    {
      v9 = sub_1002D430(
             dword_106A7B24[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1001A0A0,
             (void (__cdecl *)(_DWORD))sub_1001A0C0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_1002D860((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1002CA40((void (__cdecl *)(_DWORD))sub_1001A0C0, (int)&v12);
  sub_1002CA40((void (__cdecl *)(_DWORD))sub_1001A0C0, (int)&v13);
  sub_1002CA40((void (__cdecl *)(_DWORD))sub_1001A0C0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 106A7B24: using guessed type int dword_106A7B24[];

//----- (1001E270) --------------------------------------------------------
bool __usercall sub_1001E270@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10016F00();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10017E60() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1001C820(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10017E60() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_106A1E18[3072 * v24], 0x400u, "%s", v9);
  byte_106A2216[v15] = 42;
  byte_106A2217[v15] = 0;
  _snprintf(&byte_106A2218[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_10089310)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_106A2616[v15] = 42;
  v17 = off_10089300[v14 != 0];
  v18 = off_10089308[a3];
  byte_106A2617[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_106A1E18[3072 * v24];
  v34 = &byte_106A2218[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1002C930();
  sub_10019310(7, (int)&v26, v19);
  sub_1002C940(v20);
  return v14;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;

//----- (1001E4E0) --------------------------------------------------------
char __cdecl sub_1001E4E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10016F00();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_106A7B24[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_106A9140[v10];
  sub_10019BC0(a3, 1, a6, 0x230u, &byte_106A9140[v10]);
  v27 = &byte_106A5A40[v10];
  sub_10019BC0(a3, 2, a7, 0x230u, &byte_106A5A40[v10]);
  v24 = &byte_106A7020[v10];
  sub_10019BC0(a3, 3, a6, 0x230u, &byte_106A7020[v10]);
  v26 = &byte_106A7B38[v10];
  sub_10019BC0(a3, 4, a7, 0x230u, &byte_106A7B38[v10]);
  _snprintf(&byte_106A8628[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_106A8628[v10];
  byte_106A8857[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_10019BC0(a3, 0, v25, 560 - (v11 - &byte_106A8628[v10 + 1]), &byte_106A8628[v10] + v11 - &byte_106A8628[v10 + 1]);
  v13 = &byte_106A8628[v10];
  byte_106A8857[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_106A8624[v10] + v13 - &byte_106A8628[v10 + 1]) = 0;
  sub_10019BC0(a3, 1, (int)&byte_106A8628[v10], 0x230u, &byte_106A1328[v10]);
  sub_10019BC0(a3, 1, (int)&byte_106A8628[v10], 0x230u, &byte_106A6530[v10]);
  v15 = sub_1001E100(v22, v27, v21, a2 == 1, (int)&byte_106A1328[v10], (const char **)&v22);
  if ( sub_10017E60() )
    v15 = v15 == 0;
  v30 = (&off_10089310)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_10089308[a1];
  v34 = off_10089300[v15 != 0];
  v17 = dword_106A7B24[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1002C930();
  sub_10019310(7, (int)&v30, v18);
  sub_1002C940(v19);
  return v15;
}
// 10089300: using guessed type char *off_10089300[5];
// 10089308: using guessed type char *off_10089308[3];
// 10089310: using guessed type char *off_10089310;
// 106A7B24: using guessed type int dword_106A7B24[];

//----- (1001E7E0) --------------------------------------------------------
bool __cdecl sub_1001E7E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1001AFC0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1001E890) --------------------------------------------------------
bool __cdecl sub_1001E890(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1001E270(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1001E8D0) --------------------------------------------------------
const char *__cdecl sub_1001E8D0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1001E910) --------------------------------------------------------
char __cdecl sub_1001E910(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10016F00();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_106A9C38 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_10019B70((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10019690((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_10019B70((int)v6, 0);
      return v5;
    case 4:
      sub_10019510((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_10019840((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_10019B20((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10019500((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10018F00((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1001E8D0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_10019B20((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        if ( v48 )
          sub_10019B20((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        if ( v48 )
          sub_10019B20((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_10019B20((int)v6, v55);
              if ( v48 )
                sub_10019B20((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_10019B20((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_10019B20((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_10019B20((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10019770((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10019220((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_100192E0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10019130((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_1005377D;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_1005377D;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_1005377D;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_1005377D;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_1005377D;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_1005377D;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_1005377D;
          v10 = sub_100191F0((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_1005377D;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10018F30((const void **)a2, a3) )
      {
        dword_106A9C30 = 2;
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20((int)v6, "   Command Format:\r\n");
        sub_10019B20(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_10019B20(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_10019B20(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_10019B20(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_10019B20((int)v6, "                                         strings depending upon the command\r\n");
        sub_10019B20((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_10019B20(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_10019B20(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20((int)v6, "   Notes:\r\n");
        sub_10019B20((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_10019B20(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_10019B20(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_10019B20((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_10019B20(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_10019B20((int)v6, "       without a test suite name.\r\n");
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20((int)v6, "   Examples:\r\n");
        sub_10019B20(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_10019B20((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_10019B20(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_10019B20(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_10019B20(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_10019B20(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_10019B20(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_10019B20(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_10019B20((int)v6, (const char *)&word_1008A62C);
        sub_10019B20((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_10019B20(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10018FC0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, (const char *)&word_1008A62C);
        return v5;
      }
      if ( sub_10018F90((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_106A9C30,
          &unk_1005377D,
          &v58,
          6 - dword_106A9C30,
          word_10053650,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
        return v5;
      }
      if ( sub_10018FF0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10019020((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_106A9C30 += 2;
          return v5;
        }
        if ( sub_10019060((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_106A9C30 < 2 )
            dword_106A9C30 = 0;
          else
            dword_106A9C30 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_106A9C30,
          &unk_1005377D,
          a2[2],
          6 - dword_106A9C30,
          word_10053650,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
        return v5;
      }
      if ( sub_10018F60((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_106A9C30,
          &unk_1005377D,
          a2[3],
          6 - dword_106A9C30,
          word_10053650,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_100190D0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
      }
      else if ( sub_100190A0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1001E8D0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1001E8D0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_10019B20((int)v6, v55);
      }
      LOBYTE(v5) = sub_100197D0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_10019AA0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10019B20((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1008A62C: using guessed type __int16 word_1008A62C;
// 106A9C30: using guessed type int dword_106A9C30;
// 1001E910: using guessed type char var_304[508];

//----- (1001F6C0) --------------------------------------------------------
signed int __cdecl sub_1001F6C0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_106A9C38 + 580 * sub_10016F00();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_100196D0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1001F740) --------------------------------------------------------
char **__cdecl sub_1001F740(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_106A9C38 + 580 * sub_10016F00();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_100198E0((int)v1, a1, (int)".txt");
  return &off_100899F8;
}
// 100899F8: using guessed type char *off_100899F8;

//----- (1001F780) --------------------------------------------------------
int (**sub_1001F780())()
{
  return off_1008A6E8;
}
// 1008A6E8: using guessed type int (*off_1008A6E8[2])();

//----- (1001F790) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001F790(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10016F00();
  return sub_10019B20((int)&unk_106AA790 + 1812 * v1, a1);
}

//----- (1001F7B0) --------------------------------------------------------
const char *sub_1001F7B0()
{
  return "See version control for test execution date";
}

//----- (1001F7C0) --------------------------------------------------------
__int64 sub_1001F7C0()
{
  return 0i64;
}

//----- (1001F7D0) --------------------------------------------------------
const char *sub_1001F7D0()
{
  return "Not Available";
}

//----- (1001F7E0) --------------------------------------------------------
int __usercall sub_1001F7E0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1001F830) --------------------------------------------------------
signed int __cdecl sub_1001F830(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10016F00();
  return sub_100196D0(a1, a2, (int)&unk_106AA790 + 1812 * v2);
}

//----- (1001F980) --------------------------------------------------------
int __usercall sub_1001F980@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10035250((int)&a2[151 * (*a2 + 1)], (int)sub_1001F790, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1001F7C0();
  v4 = sub_1002C040("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_100356A0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1002C040("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_100356A0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_100356A0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10035620((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_100354B0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1002C040("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10016FB0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10035620((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10035620((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_10019840(v3);
  sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_100355A0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1002C000(i, &v15, &v16); ++i )
  {
    sub_10035620((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_100356F0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_100355A0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_100355A0((int)&a2[151 * (*a2 + 1)]);
  sub_10035620((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_100354B0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1001F980: using guessed type char var_103[253];

//----- (1001FD00) --------------------------------------------------------
char __cdecl sub_1001FD00(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10016F00();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_106AA790 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10019280(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1001F7E0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10035620(v8, (int)"Req");
            sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10019250(a2, a3) )
      {
        if ( sub_100199E0((int)v5, 3, 1, 0) )
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_100355A0(v12);
          sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_100354B0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10019190(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_100356F0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_100192B0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_100356F0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10019220(a2, a3) )
      {
        if ( sub_100199E0((int)v5, 3, 1, 0) )
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10019950((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_100191C0(a2, a3) )
      {
        sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_100354B0(v13, (int)"success", (unsigned __int8 *)"0");
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_100354B0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_100199E0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10019160(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10019A90((int)v5) )
            sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_100356F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_100199E0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10019510((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1001F980((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10019500((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_100356F0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_100356F0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_100356F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10019A90((int)v5) )
        sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10019100((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10035550((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_100356F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10018F00((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10035500((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10035500((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10035500((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100870E8, 3u) )
              v44 = (const char *)&unk_1005377D;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10035620(v19, (int)"Expected");
          sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_100199E0((int)v5, 8, 1, 0) )
        sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10019770((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_100197D0((int)v5, (void (__cdecl *)(int))sub_1001F860);
      return v4;
    case 0:
    case 11:
      sub_10019B70((int)v5, (void (__cdecl *)(int))sub_1001F860);
      goto LABEL_139;
    case 1:
      sub_10019690((int)v5);
      goto LABEL_139;
    case 12:
      sub_10019AA0((int)v5, (void (__cdecl *)(int))sub_1001F860);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10035620((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_100354B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_100199E0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_100355A0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1001F860: using guessed type int sub_1001F860();
// 1001FD00: using guessed type char var_104[255];

//----- (10020B20) --------------------------------------------------------
char **__cdecl sub_10020B20(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_106AA790 + 1812 * sub_10016F00();
  *((_DWORD *)v1 + 146) = 0;
  sub_100198E0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10035250(v2, (int)sub_1001F790, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_1008A798;
}
// 1008A798: using guessed type char *off_1008A798;

//----- (10020B90) --------------------------------------------------------
char __thiscall sub_10020B90(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_106ACAF8 = sub_1000E750(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_106ACB00, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_106ACB00;
  do
  {
    result = sub_1002BDD0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 106ACAF8: using guessed type int dword_106ACAF8;

//----- (10020C00) --------------------------------------------------------
char __usercall sub_10020C00@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10014EA0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10014EA0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10020C40) --------------------------------------------------------
void *__usercall sub_10020C40@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_106ACAF8 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10038600(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_106ACB00 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_1002BDD0(a1, (int)&unk_106ACB00 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_106ACB00 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_106ACAF8 != 1379255385 )
    result = (void *)sub_100385D0(v4, 86);
  return result;
}
// 106ACAF8: using guessed type int dword_106ACAF8;

//----- (10020CE0) --------------------------------------------------------
char __cdecl sub_10020CE0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10020C00(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10020D20) --------------------------------------------------------
bool __cdecl sub_10020D20(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10020C40(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10020D80) --------------------------------------------------------
char __cdecl sub_10020D80(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10020C00(a2, 1, a3, a1);
  return result;
}

//----- (10020DC0) --------------------------------------------------------
char __cdecl sub_10020DC0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10020C40(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10020DF0) --------------------------------------------------------
char __cdecl sub_10020DF0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10020C00(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10020E30) --------------------------------------------------------
char __cdecl sub_10020E30(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10020C40(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10020E70) --------------------------------------------------------
char __cdecl sub_10020E70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10020C00(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10020EB0) --------------------------------------------------------
bool __cdecl sub_10020EB0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10020C40(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10020F00) --------------------------------------------------------
char __cdecl sub_10020F00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10020C00(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10020F40) --------------------------------------------------------
bool __cdecl sub_10020F40(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10020C40(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10020F80) --------------------------------------------------------
char __cdecl sub_10020F80(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10020C00(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10020FC0) --------------------------------------------------------
bool __cdecl sub_10020FC0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10020C40(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10021000) --------------------------------------------------------
char __cdecl sub_10021000(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10020C00(1229, 1, a2, a1);
  return result;
}

//----- (10021030) --------------------------------------------------------
char __cdecl sub_10021030(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10020C40(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10021060) --------------------------------------------------------
char __cdecl sub_10021060(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10020C00(1212, 16, a2, a1);
  return result;
}

//----- (10021090) --------------------------------------------------------
char __cdecl sub_10021090(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10020C40(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100210C0) --------------------------------------------------------
char __cdecl sub_100210C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10020C00(2400, 65, a2, a1);
  return result;
}

//----- (100210F0) --------------------------------------------------------
char __cdecl sub_100210F0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10020C40(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10021120) --------------------------------------------------------
char __cdecl sub_10021120(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10020C00(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10021160) --------------------------------------------------------
char __cdecl sub_10021160(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_1000D9C0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10020C40(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (100211B0) --------------------------------------------------------
char __cdecl sub_100211B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10020C00(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (100211F0) --------------------------------------------------------
char __cdecl sub_100211F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10020C40(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10021220) --------------------------------------------------------
char __cdecl sub_10021220(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10020C00(22, 1, a2, a1);
  return result;
}

//----- (10021250) --------------------------------------------------------
char __cdecl sub_10021250(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10020C00(832, 4, a2, a1);
  return result;
}

//----- (10021280) --------------------------------------------------------
char __cdecl sub_10021280(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10020C40(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (100212B0) --------------------------------------------------------
char __cdecl sub_100212B0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10016830(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10021160(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10021120(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_100211F0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_100211B0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10020D20(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020CE0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10020F40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020F00(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10020FC0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020F80(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10020DC0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020D80(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10020E30(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020DF0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10021220(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10021090(v6, a5);
        else
          result = sub_10021060(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10020EB0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10020E70(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100210F0(v6, a5);
        else
          result = sub_100210C0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10021030(v6, a5);
        else
          result = sub_10021000(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10021280(v6, a5);
        else
          result = sub_10021250(v6, a5);
        break;
      default:
        sub_1000D9C0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10039CC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10021650) --------------------------------------------------------
bool __cdecl sub_10021650(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_106AE040 != 1379255385 )
    {
      sub_1002BDB0(a1, (int)&byte_106AE048[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_106AE04D[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_106AE04C[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 106AE040: using guessed type int dword_106AE040;

//----- (100216C0) --------------------------------------------------------
bool __cdecl sub_100216C0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_106AE040 != 1379255385 )
      sub_1002BDB0(a1, (int)&byte_106AE048[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_106AE05C[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106AE040: using guessed type int dword_106AE040;
// 106AE05C: using guessed type int dword_106AE05C[];

//----- (10021720) --------------------------------------------------------
bool __cdecl sub_10021720(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_106AE040 != 1379255385 )
    {
      sub_1002BDB0(a1, (int)&byte_106AE048[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_106AE054[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 106AE040: using guessed type int dword_106AE040;
// 106AE054: using guessed type int dword_106AE054[];

//----- (10021790) --------------------------------------------------------
char __cdecl sub_10021790(char a1, _BYTE *a2)
{
  if ( dword_106AE040 != 1379255385 )
    sub_1002BDB0(a1, (int)&byte_106AE048[24 * (unsigned __int8)a1]);
  *a2 = byte_106AE048[24 * (unsigned __int8)a1];
  return 1;
}
// 106AE040: using guessed type int dword_106AE040;

//----- (100217D0) --------------------------------------------------------
char __thiscall sub_100217D0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_106AE040 = sub_1000E750(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_106AE048, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_106AE048;
  do
  {
    result = sub_1002BDB0(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 106AE040: using guessed type int dword_106AE040;

//----- (10021840) --------------------------------------------------------
char __cdecl sub_10021840(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1000E880(a1);
  v3 = sub_10039F10(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10021870) --------------------------------------------------------
char __cdecl sub_10021870(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1000E880(a1);
  v3 = sub_10039F80(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100218A0) --------------------------------------------------------
char __cdecl sub_100218A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_1000E970(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10021720(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10021650(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100216C0(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10021790(v7, a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10021870(v7, (int)a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10021840(v7, (int)a5);
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021A70) --------------------------------------------------------
signed int __usercall sub_10021A70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_1008C448[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_1008B848[2 * (unsigned __int8)v68] ^ dword_1008BC48[2 * BYTE1(v65)] ^ dword_1008C048[2 * (unsigned __int8)(v66 >> 16)] ^ dword_1008C448[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_1008C448[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_1008C448[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_1008C448[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_1008C448[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_1008C448[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_1008C448[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_1008C448[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_1008C448[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_1008C848[(unsigned __int8)v57] ^ dword_1008D448[v58 >> 24] ^ dword_1008CC48[BYTE1(v59)] ^ dword_1008D048[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_1008C848[(unsigned __int8)v59] ^ dword_1008D048[(unsigned __int8)(v58 >> 16)] ^ dword_1008D448[v57 >> 24] ^ dword_1008CC48[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_1008C848[(unsigned __int8)v60] ^ dword_1008CC48[BYTE1(v58)] ^ dword_1008D048[(unsigned __int8)(v57 >> 16)] ^ dword_1008D448[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_1008C848[(unsigned __int8)v58] ^ dword_1008CC48[BYTE1(v57)] ^ dword_1008D048[(unsigned __int8)(v59 >> 16)] ^ dword_1008D448[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_1008C448[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_1008C448[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_1008C448[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_1008C448[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_1008C448[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1008B848[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_1008BC48[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_1008C048[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_1008C448[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 1008C848: using guessed type int dword_1008C848[];
// 1008CC48: using guessed type int dword_1008CC48[];
// 1008D048: using guessed type int dword_1008D048[];
// 1008D448: using guessed type int dword_1008D448[];

//----- (10022B20) --------------------------------------------------------
int __usercall sub_10022B20@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10021A70(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10022B80) --------------------------------------------------------
signed int __usercall sub_10022B80@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_1008D448[(unsigned __int8)v9] ^ dword_1008C848[BYTE1(v9)] ^ dword_1008CC48[(unsigned __int8)(v9 >> 16)] ^ dword_1008D048[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_1008D448[(unsigned __int8)v129] ^ dword_1008C848[BYTE1(v129)] ^ dword_1008CC48[(unsigned __int8)(v129 >> 16)] ^ dword_1008D048[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_1008D448[(unsigned __int8)v133] ^ dword_1008C848[BYTE1(v133)] ^ dword_1008CC48[(unsigned __int8)(v133 >> 16)] ^ dword_1008D048[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_1008D448[(unsigned __int8)v137] ^ dword_1008C848[BYTE1(v137)] ^ dword_1008CC48[(unsigned __int8)(v137 >> 16)] ^ dword_1008D048[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_1008D448[(unsigned __int8)v141] ^ dword_1008C848[BYTE1(v141)] ^ dword_1008CC48[(unsigned __int8)(v141 >> 16)] ^ dword_1008D048[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_1008D448[(unsigned __int8)v145] ^ dword_1008C848[BYTE1(v145)] ^ dword_1008CC48[(unsigned __int8)(v145 >> 16)] ^ dword_1008D048[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_1008D448[(unsigned __int8)v149] ^ dword_1008C848[BYTE1(v149)] ^ dword_1008CC48[(unsigned __int8)(v149 >> 16)] ^ dword_1008D048[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_1008D448[(unsigned __int8)v153] ^ dword_1008C848[BYTE1(v153)] ^ dword_1008CC48[(unsigned __int8)(v153 >> 16)] ^ dword_1008D048[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_1008D448[(unsigned __int8)v157] ^ dword_1008C848[BYTE1(v157)] ^ dword_1008CC48[(unsigned __int8)(v157 >> 16)] ^ dword_1008D048[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_1008D448[(unsigned __int8)v161] ^ dword_1008C848[BYTE1(v161)] ^ dword_1008CC48[(unsigned __int8)(v161 >> 16)] ^ dword_1008D048[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_1008D448[(unsigned __int8)v77] ^ dword_1008C848[BYTE1(v77)] ^ dword_1008CC48[(unsigned __int8)(v77 >> 16)] ^ dword_1008D048[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_1008D448[(unsigned __int8)v82] ^ dword_1008C848[BYTE1(v82)] ^ dword_1008CC48[(unsigned __int8)(v82 >> 16)] ^ dword_1008D048[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_1008D448[(unsigned __int8)v89] ^ dword_1008C848[BYTE1(v89)] ^ dword_1008CC48[(unsigned __int8)(v89 >> 16)] ^ dword_1008D048[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_1008D448[(unsigned __int8)v94] ^ dword_1008C848[BYTE1(v94)] ^ dword_1008CC48[(unsigned __int8)(v94 >> 16)] ^ dword_1008D048[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_1008D448[(unsigned __int8)v100] ^ dword_1008C848[BYTE1(v100)] ^ dword_1008CC48[(unsigned __int8)(v100 >> 16)] ^ dword_1008D048[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_1008D448[(unsigned __int8)v100] ^ dword_1008C848[BYTE1(v100)] ^ dword_1008CC48[(unsigned __int8)(v100 >> 16)] ^ dword_1008D048[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_1008D448[(unsigned __int8)v108] ^ dword_1008C848[BYTE1(v108)] ^ dword_1008CC48[(unsigned __int8)(v108 >> 16)] ^ dword_1008D048[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_1008D448[(unsigned __int8)v114] ^ dword_1008C848[BYTE1(v114)] ^ dword_1008CC48[(unsigned __int8)(v114 >> 16)] ^ dword_1008D048[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_1008D448[(unsigned __int8)v120] ^ dword_1008C848[BYTE1(v120)] ^ dword_1008CC48[(unsigned __int8)(v120 >> 16)] ^ dword_1008D048[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_1008D448[(unsigned __int8)v19] ^ dword_1008C848[BYTE1(v19)] ^ dword_1008CC48[(unsigned __int8)(v19 >> 16)] ^ dword_1008D048[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_1008C848[(unsigned __int8)v23] ^ dword_1008CC48[BYTE1(v23)] ^ dword_1008D048[(unsigned __int8)(v23 >> 16)] ^ dword_1008D448[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_1008D448[(unsigned __int8)v26] ^ dword_1008C848[BYTE1(v26)] ^ dword_1008CC48[(unsigned __int8)(v26 >> 16)] ^ dword_1008D048[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_1008C848[(unsigned __int8)v31] ^ dword_1008CC48[BYTE1(v31)] ^ dword_1008D048[(unsigned __int8)(v31 >> 16)] ^ dword_1008D448[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_1008D448[(unsigned __int8)v35] ^ dword_1008C848[BYTE1(v35)] ^ dword_1008CC48[(unsigned __int8)(v35 >> 16)] ^ dword_1008D048[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_1008C848[(unsigned __int8)v41] ^ dword_1008CC48[BYTE1(v41)] ^ dword_1008D048[(unsigned __int8)(v41 >> 16)] ^ dword_1008D448[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_1008D448[(unsigned __int8)v43] ^ dword_1008C848[BYTE1(v43)] ^ dword_1008CC48[(unsigned __int8)(v43 >> 16)] ^ dword_1008D048[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_1008C848[(unsigned __int8)v47] ^ dword_1008CC48[BYTE1(v47)] ^ dword_1008D048[(unsigned __int8)(v47 >> 16)] ^ dword_1008D448[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_1008D448[(unsigned __int8)v52] ^ dword_1008C848[BYTE1(v52)] ^ dword_1008CC48[(unsigned __int8)(v52 >> 16)] ^ dword_1008D048[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_1008C848[(unsigned __int8)v58] ^ dword_1008CC48[BYTE1(v58)] ^ dword_1008D048[(unsigned __int8)(v58 >> 16)] ^ dword_1008D448[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_1008D448[(unsigned __int8)v60] ^ dword_1008C848[BYTE1(v60)] ^ dword_1008CC48[(unsigned __int8)(v60 >> 16)] ^ dword_1008D048[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_1008C848[(unsigned __int8)v66] ^ dword_1008CC48[BYTE1(v66)] ^ dword_1008D048[(unsigned __int8)(v66 >> 16)] ^ dword_1008D448[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_1008D448[(unsigned __int8)v69] ^ dword_1008C848[BYTE1(v69)] ^ dword_1008CC48[(unsigned __int8)(v69 >> 16)] ^ dword_1008D048[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 1008C848: using guessed type int dword_1008C848[];
// 1008CC48: using guessed type int dword_1008CC48[];
// 1008D048: using guessed type int dword_1008D048[];
// 1008D448: using guessed type int dword_1008D448[];

//----- (10023900) --------------------------------------------------------
void *__usercall sub_10023900@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10023920) --------------------------------------------------------
unsigned int __cdecl sub_10023920(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10038330();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10038380: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10023980) --------------------------------------------------------
int __usercall sub_10023980@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = &unk_10325476;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100239C0) --------------------------------------------------------
int __usercall sub_100239C0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (100250E0) --------------------------------------------------------
unsigned int __usercall sub_100250E0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_1008D870[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_1008D880[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100239C0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100239C0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 1008D870: using guessed type int dword_1008D870[];
// 1008D880: using guessed type int dword_1008D880[];

//----- (100251E0) --------------------------------------------------------
void *__usercall sub_100251E0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100239C0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10025260) --------------------------------------------------------
void *__usercall sub_10025260@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_100250E0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10023980(v3 + 64);
    result = sub_100251E0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_100251E0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10025300) --------------------------------------------------------
int __usercall sub_10025300@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10025260(a1, 0, 0);
  sub_100250E0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10023980(a1 + 64);
  sub_100251E0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_100251E0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_100250E0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (100253C0) --------------------------------------------------------
int __usercall sub_100253C0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10023980(a2 + 64);
    sub_100251E0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_100251E0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10025420) --------------------------------------------------------
int __usercall sub_10025420@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_100239C0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10025420: using guessed type char var_40[64];

//----- (100254E0) --------------------------------------------------------
int __usercall sub_100254E0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10025420((char *)a1);
  return sub_10025420(v8);
}

//----- (100255A0) --------------------------------------------------------
char __cdecl sub_100255A0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10025260(a3 + 296, a2, a1);
    sub_10022B20(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100255F0) --------------------------------------------------------
char __cdecl sub_100255F0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10022B20(a3, (int)a1, a2);
    sub_10025260(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025640) --------------------------------------------------------
bool __cdecl sub_10025640(int a1, int a2)
{
  if ( a2 )
    sub_10025300(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10025670) --------------------------------------------------------
int __usercall sub_10025670@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10023900(&v24);
  sub_100253C0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10025260((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10025260((int)&v23, v12, (char *)&v31);
          sub_10025300((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10025670: using guessed type char var_14[16];

//----- (10025880) --------------------------------------------------------
int __usercall sub_10025880@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_100254E0(v2);
  v3 = 20;
  do
  {
    sub_10025420((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_100254E0(v2);
}

//----- (100258D0) --------------------------------------------------------
char *__cdecl sub_100258D0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_100254E0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10025960) --------------------------------------------------------
signed int __cdecl sub_10025960(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10025670(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10022B80(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10023900((void *)(a6 + 296));
      sub_100253C0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10025960: using guessed type char var_40[8];
// 10025960: using guessed type __int16 var_38[26];

//----- (10025A90) --------------------------------------------------------
bool __cdecl sub_10025A90(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10025880(&v4, (int)sub_10023920);
  if ( v2 )
    sub_100258D0(a2, (int)&v4);
  return v2;
}

//----- (10025B10) --------------------------------------------------------
BOOL __usercall sub_10025B10@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_1008E088[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_1008DF88[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_1008DE88[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10025BB0) --------------------------------------------------------
int __usercall sub_10025BB0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10025C40) --------------------------------------------------------
unsigned int __fastcall sub_10025C40(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10025C60) --------------------------------------------------------
int __usercall sub_10025C60@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10025CF0) --------------------------------------------------------
int __usercall sub_10025CF0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_1008E088[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_1008E088[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_1008D890[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_1008E188[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_1008DF88[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_1008DE88[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_1008D918[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_1008E200[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 1008D890: using guessed type int dword_1008D890[];
// 1008D918: using guessed type int dword_1008D918[];
// 1008E188: using guessed type int dword_1008E188[];
// 1008E200: using guessed type int dword_1008E200[];

//----- (10026170) --------------------------------------------------------
int __usercall sub_10026170@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10025C60(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10026220) --------------------------------------------------------
void *__usercall sub_10026220@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10026280) --------------------------------------------------------
int __usercall sub_10026280@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10026450) --------------------------------------------------------
signed int __usercall sub_10026450@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10025C40(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (100264D0) --------------------------------------------------------
_WORD *__fastcall sub_100264D0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10026540) --------------------------------------------------------
signed int __usercall sub_10026540@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_1008E27A[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_1008E278[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_1008E27C[v3];
  v4 = (unsigned __int16)word_1008E27E[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 1008E278: using guessed type __int16 word_1008E278[];
// 1008E27A: using guessed type __int16 word_1008E27A[];
// 1008E27C: using guessed type __int16 word_1008E27C[];
// 1008E27E: using guessed type __int16 word_1008E27E[];

//----- (10026600) --------------------------------------------------------
unsigned int __usercall sub_10026600@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (100267B0) --------------------------------------------------------
unsigned int __usercall sub_100267B0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10026880) --------------------------------------------------------
int __usercall sub_10026880@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10026930) --------------------------------------------------------
int __usercall sub_10026930@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10026970) --------------------------------------------------------
unsigned int __usercall sub_10026970@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_100289E0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100269D0) --------------------------------------------------------
signed int __usercall sub_100269D0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10026AB0) --------------------------------------------------------
int __usercall sub_10026AB0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10027050) --------------------------------------------------------
_WORD *__fastcall sub_10027050(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_1008E42C;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_1008E440;
  *(_DWORD *)(a2 + 5660) = &unk_1008E454;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_100264D0(a2 + 5228, a2);
}
// 1008E42C: using guessed type void *off_1008E42C;
// 1008E440: using guessed type void *off_1008E440;

//----- (100270B0) --------------------------------------------------------
signed int __cdecl sub_100270B0(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_100289E0(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_10027050(v3, v1);
    sub_10026540(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10027140) --------------------------------------------------------
int __usercall sub_10027140@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10025BB0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10025BB0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10025BB0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10027380) --------------------------------------------------------
int __usercall sub_10027380@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10026170(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10026170(a1, a3, a4);
  }
  return result;
}

//----- (10027420) --------------------------------------------------------
signed int __usercall sub_10027420@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10026880(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10026880(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10026880(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10026280(a1, a2);
  return sub_10026450(a1, v16, v5);
}

//----- (10027600) --------------------------------------------------------
unsigned int __usercall sub_10027600@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10026970(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10027740) --------------------------------------------------------
int __usercall sub_10027740@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_1008D904[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10026AB0(a1, a1 + 2936, a2 - 1);
  return sub_10026AB0(v24, v24 + 5228, a3 - 1);
}

//----- (100279F0) --------------------------------------------------------
signed int __cdecl sub_100279F0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10026930(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10026930(v9, *(_WORD *)(a1 + 30));
      sub_10026930(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_100289E0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10026220(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_1008E280 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10027140(v2);
    }
    else
    {
      sub_10027380(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10026220(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10026930(v2, *(_WORD *)(a1 + 30));
    sub_10026930(v13, *(_WORD *)(a1 + 28));
    sub_10026220(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1008E280: using guessed type int (__cdecl *off_1008E280)(int, int);

//----- (10027CB0) --------------------------------------------------------
signed int __cdecl sub_10027CB0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_100270B0(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10027E60) --------------------------------------------------------
signed int __usercall sub_10027E60@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_100269D0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_100269D0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10027420(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D904[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D903[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D902[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D901[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10027F30) --------------------------------------------------------
_WORD *__usercall sub_10027F30@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10027420(a2, a2 + 5628);
  sub_10027420(v4, v4 + 5640);
  v8 = sub_10027E60(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10027380(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10025CF0(v4, (int)&unk_1008D990, (int)&unk_1008DE10);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10027740(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10025CF0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_100264D0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10025C60(v4);
  return result;
}

//----- (10028150) --------------------------------------------------------
signed int __cdecl sub_10028150(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10027600(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10026600(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_100267B0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10025B10(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10025B10(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10027F30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10026220(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10027F30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10026220(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10028460) --------------------------------------------------------
signed int __cdecl sub_10028460(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10027600(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10026600(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_100267B0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10025B10(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10027F30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10026220(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10025B10(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10027F30(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10026220(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10025B10(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10027F30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10026220(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10028870) --------------------------------------------------------
signed int __cdecl sub_10028870(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10027600(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10027F30(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10026220(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10027F30(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10026220(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10027F30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10026220(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100289E0) --------------------------------------------------------
int __cdecl sub_100289E0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10028AE0) --------------------------------------------------------
signed int __cdecl sub_10028AE0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10028B00) --------------------------------------------------------
signed int __usercall sub_10028B00@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10028B00: using guessed type int var_78[14];
// 10028B00: using guessed type int var_3C[15];

//----- (10028FA0) --------------------------------------------------------
int (__cdecl *__usercall sub_10028FA0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10028FF0) --------------------------------------------------------
int __usercall sub_10028FF0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10029010) --------------------------------------------------------
signed int __cdecl sub_10029010(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_1008E468[a1];
  v51 = dword_1008E468[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_1008E468[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_1008E468[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_1008E468[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_1008E468[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 1008E468: using guessed type int dword_1008E468[];

//----- (100293C0) --------------------------------------------------------
int __usercall sub_100293C0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10029500) --------------------------------------------------------
signed int __usercall sub_10029500@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10028B00(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10029550) --------------------------------------------------------
signed int __usercall sub_10029550@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10028B00(a7, a6, a4, 257, (int)&unk_1008E500, (int)&unk_1008E580, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10028B00(a8, &a6[a4], a5, 0, (int)&unk_1008E600, (int)&unk_1008E678, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100295F0) --------------------------------------------------------
int __usercall sub_100295F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_1008E6F0;
  *a4 = &unk_1008F6F0;
  return 0;
}

//----- (10029610) --------------------------------------------------------
signed int __cdecl sub_10029610(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 0;
  if ( a2 < 0 )
  {
    v5 = 1;
    v4 = -a2;
  }
  if ( (1 << v4) + 14152 <= a4 && !(a3 & 3) )
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v4;
    *(_DWORD *)(a3 + 12) = v5;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v4) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_100289E0;
    sub_10028FA0(0, *(_DWORD *)(a3 + 20), a1);
    JUMPOUT(&loc_100294C0);
  }
  return -4;
}

//----- (10029700) --------------------------------------------------------
signed int __cdecl sub_10029700(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10028FA0(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10029710) --------------------------------------------------------
int __usercall sub_10029710@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10029010(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_1008E468[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_1008E468[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_1008E468[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_1008E468[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_100293C0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_100293C0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_100293C0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_100293C0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 1008E468: using guessed type int dword_1008E468[];

//----- (10029DB0) --------------------------------------------------------
int __usercall sub_10029DB0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_100295F0(&v67, &v69, &v66, &v68);
          sub_10028FF0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_100293C0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_1008E4B0[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_1008E4B0[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10029500(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10029550(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10028FF0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10029710(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_100293C0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_100293C0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_100293C0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_1008E468[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_1008E468[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_100293C0(v7, v3, v58);
}
// 1008E468: using guessed type int dword_1008E468[];
// 1008E4B0: using guessed type int dword_1008E4B0[];

//----- (1002A790) --------------------------------------------------------
signed int __usercall sub_1002A790@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10029DB0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10028FA0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1002AAC0) --------------------------------------------------------
signed int __cdecl sub_1002AAC0(int a1, int a2)
{
  return sub_1002A790(a1, a2);
}

//----- (1002AAE0) --------------------------------------------------------
char __cdecl sub_1002AAE0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1077A600)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1002AB30) --------------------------------------------------------
char __cdecl sub_1002AB30(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1077A600)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1002ABE0) --------------------------------------------------------
char __cdecl sub_1002ABE0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1077A600)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1002AC40) --------------------------------------------------------
char __cdecl sub_1002AC40(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1077A600)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 1077A600: using guessed type int dword_1077A600;

//----- (1002AD10) --------------------------------------------------------
char __cdecl sub_1002AD10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_10014ED0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10014ED0(0, 183, a2);
  }
  return result;
}

//----- (1002AD60) --------------------------------------------------------
unsigned __int8 __cdecl sub_1002AD60(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10038730(dword_1008F800[a1], (int)&a2, 1);
  }
  return result;
}
// 1008F800: using guessed type int dword_1008F800[];

//----- (1002ADA0) --------------------------------------------------------
int __cdecl sub_1002ADA0(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_1002AD10(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1002ADE0) --------------------------------------------------------
char __cdecl sub_1002ADE0(char a1)
{
  return byte_100906C1[2 * (unsigned __int8)sub_10015280(&a1, 1u, (int)&unk_100906C0, 2, 4, 3)];
}

//----- (1002AE10) --------------------------------------------------------
char __cdecl sub_1002AE10(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10014ED0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1002BA30(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10014ED0(1, 538, a2);
  }
  if ( !v4 || sub_10016490((int)v3) )
    return 0;
  return 1;
}

//----- (1002AE90) --------------------------------------------------------
int __cdecl sub_1002AE90(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1002AE10(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1002AEE0) --------------------------------------------------------
void __cdecl sub_1002AEE0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10038730(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_1002BAA0(a2);
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10038730(2010, (int)&a2, 1);
    }
  }
}

//----- (1002AF50) --------------------------------------------------------
char *__cdecl sub_1002AF50(char *a1)
{
  char *v1; // esi@1
  signed int v2; // edi@1
  char *result; // eax@2
  char v4; // [sp+Ch] [bp-5BCh]@1
  char v5; // [sp+1Ch] [bp-5ACh]@1
  char v6[720]; // [sp+24h] [bp-5A4h]@2
  char v7[16]; // [sp+2F4h] [bp-2D4h]@1
  char v8[704]; // [sp+304h] [bp-2C4h]@2

  sub_10038660(6120, (int)&v4, 744);
  sub_10038660(6466, (int)v7, 720);
  strncpy(a1, &v4, 0x10u);
  strncpy(a1 + 16, &v5, 8u);
  v1 = a1 + 40;
  v2 = 0;
  do
  {
    strncpy(v1 - 16, &v6[v2], 0x10u);
    strncpy(v1, &v1[&v4 - a1], 8u);
    strncpy(v1 + 704, &v7[v2], 0x10u);
    result = strncpy(v1 + 720, &v8[v2], 8u);
    v2 += 24;
    v1 += 24;
  }
  while ( v2 < 720 );
  return result;
}
// 1002AF50: using guessed type char var_2D4[16];
// 1002AF50: using guessed type char var_5A4[720];
// 1002AF50: using guessed type char var_2C4[704];

//----- (1002B040) --------------------------------------------------------
char __thiscall sub_1002B040(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_10014FF0(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002B060) --------------------------------------------------------
_DWORD *__usercall sub_1002B060@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_10035B00(a2, a1);
  result = (_DWORD *)sub_10011730(a3, a4);
  if ( (_BYTE)result )
    result = sub_10002990(a2);
  return result;
}

//----- (1002B140) --------------------------------------------------------
char __cdecl sub_1002B140(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_1000F0A0(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_1000F0A0(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_1002B040(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_1000F0D0(v16);
  LOBYTE(v3) = sub_10035B20(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (1002B240) --------------------------------------------------------
_DWORD *sub_1002B240()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10038700(6463, (int)&v1, 256);
  sub_1002B060((int)sub_1002B0F0, (int)&unk_106AE0A0, &v1, "PAGE_INIT");
  sub_1002B060((int)sub_1002B090, (int)&unk_106AE090, &v1, "PAGE_SET_FOCUS");
  return sub_1002B060((int)sub_1002B140, (int)&unk_106AE098, &v1, "KEY_PRESS");
}
// 1002B090: using guessed type int sub_1002B090();
// 1002B0F0: using guessed type int sub_1002B0F0();

//----- (1002B2D0) --------------------------------------------------------
signed int __cdecl sub_1002B2D0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1002B320) --------------------------------------------------------
int __cdecl sub_1002B320(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1002B410) --------------------------------------------------------
unsigned int __cdecl sub_1002B410(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1002B460) --------------------------------------------------------
unsigned int __cdecl sub_1002B460(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1002B520) --------------------------------------------------------
unsigned int __cdecl sub_1002B520(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1000D620(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1002B580) --------------------------------------------------------
int __cdecl sub_1002B580(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1002B5D0) --------------------------------------------------------
int __cdecl sub_1002B5D0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1002B670) --------------------------------------------------------
int __cdecl sub_1002B670(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1002B720) --------------------------------------------------------
char __cdecl sub_1002B720(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10015280((_DWORD *)a2, 2u, (int)&unk_10091500, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_10091504[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10038490(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_100382C0();
        sub_1000D6F0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_1000D9C0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 10091504: using guessed type int dword_10091504[];

//----- (1002B840) --------------------------------------------------------
char __cdecl sub_1002B840(int a1)
{
  return sub_1002B720(31, a1);
}

//----- (1002B850) --------------------------------------------------------
char sub_1002B850()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10038700(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 1002B850: using guessed type int var_1C[7];

//----- (1002B8D0) --------------------------------------------------------
char __cdecl sub_1002B8D0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10035F70(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10035D70(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10035DF0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10035E70(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10035EF0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1002B9E0) --------------------------------------------------------
int __cdecl sub_1002B9E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10015280(&a1, 1u, (int)&unk_10093250, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_10093254[2 * v1];
  }
  return result;
}
// 10093254: using guessed type int dword_10093254[];

//----- (1002BA30) --------------------------------------------------------
bool __cdecl sub_1002BA30(void *a1)
{
  char v1; // al@1

  v1 = sub_10014ED0(1, 1946, a1);
  *((_DWORD *)a1 + 1) = (unsigned int)(*((_DWORD *)a1 + 1) * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  return v1 && !sub_10016490((int)a1);
}

//----- (1002BA70) --------------------------------------------------------
char __cdecl sub_1002BA70(char a1)
{
  sub_10014A00(1, 1672, &a1, 0, 1, 1);
  return sub_10014B40(1, 0x688u, 0xFFFFFFF);
}

//----- (1002BAA0) --------------------------------------------------------
char __cdecl sub_1002BAA0(char a1)
{
  int v1; // eax@1

  v1 = sub_10038730(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_1002BA70(a1);
  return v1;
}

//----- (1002BAD0) --------------------------------------------------------
int __cdecl sub_1002BAD0(unsigned __int8 *a1)
{
  return sub_1002B580(a1, 0, 0, 0, 0);
}

//----- (1002BAF0) --------------------------------------------------------
unsigned int __cdecl sub_1002BAF0(void *a1)
{
  return sub_1002B520(a1, 0xCu, 0);
}

//----- (1002BB10) --------------------------------------------------------
unsigned int __cdecl sub_1002BB10(void *a1)
{
  return sub_1002B520(a1, 0x20u, 0);
}

//----- (1002BB30) --------------------------------------------------------
unsigned int __cdecl sub_1002BB30(void *a1)
{
  return sub_1002B520(a1, 0x1Cu, 0);
}

//----- (1002BB50) --------------------------------------------------------
unsigned int __cdecl sub_1002BB50(void *a1)
{
  return sub_1002B520(a1, 0x10u, 0);
}

//----- (1002BB70) --------------------------------------------------------
unsigned int __cdecl sub_1002BB70(void *a1)
{
  return sub_1002B520(a1, 8u, 0);
}

//----- (1002BB90) --------------------------------------------------------
unsigned int __cdecl sub_1002BB90(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1002BB10((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1002BB30((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1002BB50(a1);
      if ( !result )
      {
        result = sub_1002BAF0((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1002BAF0((char *)a1 + 24);
          if ( !result )
            result = sub_1002BB70((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1002BBF0) --------------------------------------------------------
int __cdecl sub_1002BBF0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1002B580(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002BC20) --------------------------------------------------------
signed int __cdecl sub_1002BC20(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_10096D20;
    v6 = &unk_10096D20;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10096D38;
    v6 = &unk_10096D38;
    v5 = &a1;
  }
  v3 = sub_10015280(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (1002BC80) --------------------------------------------------------
int __cdecl sub_1002BC80(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10015280(&a1, 1u, (int)&unk_10096D80, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10096D84[2 * v1];
  return result;
}
// 10096D84: using guessed type int dword_10096D84[];

//----- (1002BCC0) --------------------------------------------------------
signed int __cdecl sub_1002BCC0(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10096D90;
    v7 = &unk_10096D90;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10096DA8;
    v7 = &unk_10096DA8;
    v6 = &a1;
  }
  v4 = sub_10015280(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (1002BD30) --------------------------------------------------------
int __cdecl sub_1002BD30(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10015280(&a1, 1u, (int)&unk_10096DC0, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_10096DC4[2 * v1];
  return result;
}
// 10096DC4: using guessed type int dword_10096DC4[];

//----- (1002BD70) --------------------------------------------------------
int __cdecl sub_1002BD70(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10015280(&a1, 1u, (int)&unk_10096DD8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10096DDC[2 * v1];
  return result;
}
// 10096DDC: using guessed type int dword_10096DDC[];

//----- (1002BDB0) --------------------------------------------------------
char __cdecl sub_1002BDB0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BC20(a1, 11);
  return sub_10038680(v2, a2, 24);
}

//----- (1002BDD0) --------------------------------------------------------
char __cdecl sub_1002BDD0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BC80(a1);
  return sub_10038680(v2, a2, 2720);
}

//----- (1002BE00) --------------------------------------------------------
char __cdecl sub_1002BE00(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_1002BCC0(a1, 11, 1);
  sub_10038680(v2, a2, 36);
  v3 = sub_1002BCC0(a1, 11, 0);
  return sub_10038680(v3, a2 + 36, 32);
}

//----- (1002BE50) --------------------------------------------------------
char __cdecl sub_1002BE50(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BD30(a1);
  return sub_10038680(v2, a2, 2192);
}

//----- (1002BE80) --------------------------------------------------------
char __cdecl sub_1002BE80(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BD70(a1);
  return sub_10038680(v2, a2, 60);
}

//----- (1002BEA0) --------------------------------------------------------
char __cdecl sub_1002BEA0(int a1)
{
  return sub_10038680(6453, a1, 5);
}

//----- (1002BEC0) --------------------------------------------------------
char __cdecl sub_1002BEC0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10016BB0(11);
  }
  else
  {
    result = sub_10016BB0(5);
  }
  return result;
}

//----- (1002BEF0) --------------------------------------------------------
char sub_1002BEF0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10014ED0(1, 1309, &v1) )
    sub_10016580((int)&v1);
  return 0;
}

//----- (1002BF90) --------------------------------------------------------
BOOL __cdecl sub_1002BF90(int a1, int a2)
{
  return sub_10038660(6455, a2, 252) == 0;
}

//----- (1002BFB0) --------------------------------------------------------
char __cdecl sub_1002BFB0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002BF90(a1, a5);
  }
  else
  {
    result = sub_1002BEF0();
  }
  return result;
}

//----- (1002BFF0) --------------------------------------------------------
int __cdecl sub_1002BFF0(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1002C000) --------------------------------------------------------
char __cdecl sub_1002C000(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_1070DDF8[592 * a1]) || byte_1070DE48[v3]) )
  {
    *a2 = &byte_1070DDF8[v3];
    *a3 = &byte_1070DE48[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C040) --------------------------------------------------------
char *__cdecl sub_1002C040(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_1070DDF8;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_1070DE48[592 * v2];
}

//----- (1002C0B0) --------------------------------------------------------
char *__usercall sub_1002C0B0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1002C0E0) --------------------------------------------------------
void __cdecl sub_1002C0E0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1002C040(v2 + 3, (int)&unk_1005377D);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1002C0E0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1002C1A0) --------------------------------------------------------
void __cdecl sub_1002C1A0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_1070DDF0 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_1070DDF0;
    v4 = (char *)(&byte_1070DDF8[592 * dword_1070DDF0] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_1070DE48[v3];
    v8 = (char *)(&byte_1070DE48[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1002C0E0(v7);
    ++dword_1070DDF0;
  }
}
// 1070DDF0: using guessed type int dword_1070DDF0;

//----- (1002C200) --------------------------------------------------------
void *__cdecl sub_1002C200(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_1070DDF8, 0, 0x73A0u);
  dword_1070DDF0 = 0;
  if ( a1 )
  {
    v2 = sub_1002C6D0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1002C8B0((int)&v11, 512, v2) )
      {
        do
        {
          sub_1002C0B0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1002C1A0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1002C1A0(&v11, v4 + 1);
          }
        }
        while ( sub_1002C8B0((int)&v11, 512, v3) );
      }
      result = (void *)sub_1002C680(v3);
    }
    else
    {
      result = (void *)sub_10019480(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 1070DDF0: using guessed type int dword_1070DDF0;

//----- (1002C390) --------------------------------------------------------
int __cdecl sub_1002C390(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10039D10: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10039D20: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10039D30: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10039D40: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10039DF0: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1002C4D0) --------------------------------------------------------
char __usercall sub_1002C4D0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1002C5A0) --------------------------------------------------------
signed int __cdecl sub_1002C5A0(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10039D50(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1002C4D0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1002C390(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10039E00: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1002C680) --------------------------------------------------------
BOOL __cdecl sub_1002C680(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10039360(a1) == 0;
}
// 10039350: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1002C6A0) --------------------------------------------------------
BOOL __cdecl sub_1002C6A0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100393C0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1002C6D0) --------------------------------------------------------
unsigned int __cdecl sub_1002C6D0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1002C730) --------------------------------------------------------
signed int __cdecl sub_1002C730(void *a1, int a2, unsigned int a3)
{
  return sub_10039460(a3, a1, a2);
}

//----- (1002C750) --------------------------------------------------------
int __cdecl sub_1002C750(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 100395D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1002C770) --------------------------------------------------------
char __cdecl sub_1002C770(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1002C6D0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1002C6D0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1002C730(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1002C750((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1002C730(&v8, 512, v3);
        }
        v2 = i;
        sub_1002C680(v4);
      }
      sub_1002C680(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1002C8B0) --------------------------------------------------------
int __cdecl sub_1002C8B0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1002C730(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1002C930) --------------------------------------------------------
int sub_1002C930()
{
  return 0;
}

//----- (1002C940) --------------------------------------------------------
void __cdecl sub_1002C940(int a1)
{
  if ( a1 > 0 )
    exit_1(14);
}

//----- (1002C970) --------------------------------------------------------
int __cdecl sub_1002C970(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1002C990) --------------------------------------------------------
bool __cdecl sub_1002C990(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1002C9C0) --------------------------------------------------------
void *__cdecl sub_1002C9C0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1002CA00) --------------------------------------------------------
unsigned int __usercall sub_1002CA00@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1002CA20) --------------------------------------------------------
int __usercall sub_1002CA20@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1002CA40) --------------------------------------------------------
char __cdecl sub_1002CA40(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1002C990(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1002C970(a2);
  }
  return result;
}

//----- (1002CA70) --------------------------------------------------------
signed int __cdecl sub_1002CA70(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1002CA00(v5, v7, v9);
          v11 = (_BYTE *)sub_1002CA00(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1002CA00(a4, v7, v9);
            sub_1002CA20(v16, (int)&unk_10098C04);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1002CB50) --------------------------------------------------------
void __cdecl sub_1002CB50(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1002CA00((int)v3, v4, v6);
          v8 = sub_1002CA00(a2, v4, v6);
          v9 = sub_1002CA00(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1002CC00) --------------------------------------------------------
void *__usercall sub_1002CC00@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1002CA00(a1, v31, v4);
      v6 = sub_1002CA00(a2, 0, 0);
      sub_1002CA20(v5, v6);
      v7 = sub_1002CA00(a1, v33, v4);
      v8 = sub_1002CA00(a2, *(_DWORD *)a2 - 1, 0);
      sub_1002CA20(v7, v8);
      v9 = sub_1002CA00(a1, v31, v34 - v4 - 1);
      v10 = sub_1002CA00(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1002CA20(v9, v10);
      v11 = sub_1002CA00(a1, v33, v34 - v4 - 1);
      v12 = sub_1002CA00(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1002CA20(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1002CA00(a2, 0, 1);
    v16 = (void *)sub_1002CA00(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1002CA00(a1, a3 + i, v18);
      v20 = sub_1002CA00(a2, i, 0);
      sub_1002CA20(v19, v20);
      v21 = sub_1002CA00(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1002CA00(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1002CA20(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1002CA00(a2, i, 1);
    v25 = (void *)sub_1002CA00(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1002CA00(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1002CA00(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (1002CE80) --------------------------------------------------------
void __cdecl sub_1002CE80(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1002CA00(a1, v2, v4);
          v6 = sub_1002CA00(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (1002CF50) --------------------------------------------------------
char __cdecl sub_1002CF50(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1002C990(a1);
  if ( result )
  {
    result = sub_1002C990(a4);
    if ( result )
    {
      sub_1002CA40(a3, a4);
      sub_1002C9C0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (1002CFC0) --------------------------------------------------------
int __usercall sub_1002CFC0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1002C9C0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1002CC00((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1002CA00((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1002CA00(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1002CA40((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_1002CF50(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (1002D320) --------------------------------------------------------
int __usercall sub_1002D320@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1002C9C0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1002CB50(v8, a3, (int)&v16);
  sub_1002C9C0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_1002CFC0(9u, v7, (int)&v16, (int)&unk_10098BE0, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1002CA00((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1002CA00(a6, v9, v11);
            sub_1002CA20(v13, (int)&unk_10098C04);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1002CA40(a5, (int)&v15);
  sub_1002CA40(a5, (int)&v16);
  return v10;
}

//----- (1002D430) --------------------------------------------------------
int __cdecl sub_1002D430(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1002C9C0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_1002CE80(a3, a8);
  if ( a1 )
    result = sub_1002D320(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1002CA70((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (1002D5C0) --------------------------------------------------------
char __cdecl sub_1002D5C0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1002C6D0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1002C730(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1002C730(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1002C9C0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1002C730(v6, v7, v12) == v7 && (!v9 || sub_1002C730(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1002C680(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002D710) --------------------------------------------------------
char __usercall sub_1002D710@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1002C6D0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1002C750((int)&v14, 14, v9) == 14 && sub_1002C750((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1002C750(v12, v6, v10) == v6 && (!v7 || sub_1002C750((int)&unk_10098DA8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1002C680(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1002C680(v10);
  }
  return v30;
}

//----- (1002D860) --------------------------------------------------------
char __cdecl sub_1002D860(int a1, int a2)
{
  char result; // al@2

  if ( sub_1002C990(a1) )
    result = sub_1002D710(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (1002D8A0) --------------------------------------------------------
signed int __cdecl sub_1002D8A0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10715199 = 1;
    byte_10715198 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10715198 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10715199 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;
// 10715199: using guessed type char byte_10715199;

//----- (1002D900) --------------------------------------------------------
bool __cdecl sub_1002D900(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_100193D0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100B09A0, (int)"failing_subroutine( depth-1 )");
    sub_1002D900(a1 - 1);
    exit_1(14);
  }
  return sub_1001E890(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1002D970) --------------------------------------------------------
int sub_1002D970()
{
  const char *v0; // eax@1

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10715198 )
  {
    sub_1001E890(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_100193D0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1002D900(1);
    exit_1(14);
  }
  return sub_10019400(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10715198: using guessed type char byte_10715198;

//----- (1002DC90) --------------------------------------------------------
char sub_1002DC90()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10715198 )
  {
    v2 = 0;
    do
    {
      if ( off_10099A14[v2] )
      {
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10099A1C[v2 * 4], 0x100u, &v11);
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10099A14[v2], 0x100u, &v12);
        sub_1002C770(&v12, &v11);
      }
      if ( byte_10099A10[v2 * 4] )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_10099A18[v2];
        v4 = *(char **)&off_10099A1C[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10099A1C[v2 * 4],
               off_10099A18[v2]);
        v6 = sub_1001E4E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001A1C0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_10099A18[v2];
        v8 = *(char **)&off_10099A1C[v2 * 4];
        v9 = sub_10019E60(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10099A1C[v2 * 4],
               off_10099A18[v2]);
        v10 = sub_1001E4E0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001A1C0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10099A14: using guessed type char *off_10099A14[3];
// 10099A18: using guessed type char *off_10099A18[2];
// 10715198: using guessed type char byte_10715198;

//----- (1002DEB0) --------------------------------------------------------
char sub_1002DEB0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10715198 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1001A1C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1001A1C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1001A1C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1001A1C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001A1C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (1002E0B0) --------------------------------------------------------
char sub_1002E0B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_10099AA4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_10099AA1[v2 * 4];
        v4 = byte_10099AA0[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + dword_10099AA4[v2])],
               (&off_10099AA8)[v2 * 4]);
        v6 = sub_1001A300(
               0,
               *(&dword_100999F4 + dword_10099AA4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10019E60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_10099AA4[v2]],
               (&off_10099AA8)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10099AA4: using guessed type int dword_10099AA4[];
// 10099AA8: using guessed type char *off_10099AA8;
// 10715198: using guessed type char byte_10715198;

//----- (1002E230) --------------------------------------------------------
char sub_1002E230()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_10099D28[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10099D20[v2 / 8];
        v4 = dbl_10099D18[v2 / 8];
        v5 = dbl_10099D10[v2 / 8];
        v6 = sub_10019E60(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_10099D2C[v2]);
        v7 = sub_1001A6B0(
               0,
               *(&dword_100999F4 + dword_10099D28[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_10099D28[v2 / 4]],
               *(_DWORD *)&off_10099D2C[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10099D10: using guessed type double dbl_10099D10[];
// 10099D18: using guessed type double dbl_10099D18[];
// 10099D20: using guessed type double dbl_10099D20[];
// 10099D28: using guessed type int dword_10099D28[];
// 10715198: using guessed type char byte_10715198;

//----- (1002E3B0) --------------------------------------------------------
char sub_1002E3B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009A93C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1009A938[v2];
        v4 = flt_1009A934[v2];
        v5 = flt_1009A930[v2];
        v6 = sub_10019E60(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009A940)[v2 * 4]);
        v7 = sub_1001AB00(
               0,
               *(&dword_100999F4 + dword_1009A93C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009A93C[v2]],
               (&off_1009A940)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009A930: using guessed type float flt_1009A930[];
// 1009A934: using guessed type float flt_1009A934[];
// 1009A938: using guessed type float flt_1009A938[];
// 1009A93C: using guessed type int dword_1009A93C[];
// 1009A940: using guessed type char *off_1009A940;
// 10715198: using guessed type char byte_10715198;

//----- (1002E520) --------------------------------------------------------
char sub_1002E520()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10715198 )
  {
    sub_1001E7E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1002E520,
      (int)sub_1002E520,
      (int)"This test is expected to fail");
    sub_1001E7E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1002E520,
      0,
      (int)"This test is expected to fail");
    result = sub_1001E7E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1002E520,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (1002E620) --------------------------------------------------------
char sub_1002E620()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009B0E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009B0E0[v2];
        v4 = dword_1009B0DC[v2];
        v5 = dword_1009B0D8[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009B0E8[v2 * 4]);
        v7 = sub_1001AFC0(
               0,
               *(&dword_100999F4 + dword_1009B0E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009B0E4[v2]],
               *(_DWORD *)&off_1009B0E8[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009B0D8: using guessed type int dword_1009B0D8[];
// 1009B0DC: using guessed type int dword_1009B0DC[];
// 1009B0E0: using guessed type int dword_1009B0E0[];
// 1009B0E4: using guessed type int dword_1009B0E4[];
// 10715198: using guessed type char byte_10715198;

//----- (1002E780) --------------------------------------------------------
char sub_1002E780()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009B878[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009B874[v2 / 2];
        v4 = word_1009B872[v2 / 2];
        v5 = word_1009B870[v2 / 2];
        v6 = sub_10019E60(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009B87C[v2]);
        v7 = sub_1001B380(
               0,
               *(&dword_100999F4 + dword_1009B878[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009B878[v2 / 4]],
               *(_DWORD *)&off_1009B87C[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009B870: using guessed type __int16 word_1009B870[];
// 1009B872: using guessed type __int16 word_1009B872[];
// 1009B874: using guessed type __int16 word_1009B874[];
// 1009B878: using guessed type int dword_1009B878[];
// 10715198: using guessed type char byte_10715198;

//----- (1002E8E0) --------------------------------------------------------
char sub_1002E8E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009BE8C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009BE88[v2];
        v4 = dword_1009BE84[v2];
        v5 = dword_1009BE80[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009BE90)[v2 * 4]);
        v7 = sub_1001B780(
               0,
               *(&dword_100999F4 + dword_1009BE8C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009BE8C[v2]],
               (&off_1009BE90)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009BE80: using guessed type int dword_1009BE80[];
// 1009BE84: using guessed type int dword_1009BE84[];
// 1009BE88: using guessed type int dword_1009BE88[];
// 1009BE8C: using guessed type int dword_1009BE8C[];
// 1009BE90: using guessed type char *off_1009BE90;
// 10715198: using guessed type char byte_10715198;

//----- (1002EA40) --------------------------------------------------------
char sub_1002EA40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009C630[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009C62C[v2];
        LODWORD(v3) = dword_1009C628[v2];
        HIDWORD(v4) = dword_1009C624[v2];
        LODWORD(v4) = dword_1009C620[v2];
        HIDWORD(v5) = dword_1009C61C[v2];
        LODWORD(v5) = dword_1009C618[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009C634[v2 * 4]);
        v7 = sub_1001BB40(
               0,
               *(&dword_100999F4 + dword_1009C630[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009C630[v2]],
               *(_DWORD *)&off_1009C634[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009C618: using guessed type int dword_1009C618[];
// 1009C61C: using guessed type int dword_1009C61C[];
// 1009C620: using guessed type int dword_1009C620[];
// 1009C624: using guessed type int dword_1009C624[];
// 1009C628: using guessed type int dword_1009C628[];
// 1009C62C: using guessed type int dword_1009C62C[];
// 1009C630: using guessed type int dword_1009C630[];
// 10715198: using guessed type char byte_10715198;

//----- (1002EBB0) --------------------------------------------------------
char sub_1002EBB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009D23C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1009D23A[v2 * 4];
        v4 = byte_1009D239[v2 * 4];
        v5 = byte_1009D238[v2 * 4];
        v6 = sub_10019E60(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009D240)[v2 * 4]);
        v7 = sub_1001C080(
               0,
               *(&dword_100999F4 + dword_1009D23C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009D23C[v2]],
               (&off_1009D240)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009D23C: using guessed type int dword_1009D23C[];
// 1009D240: using guessed type char *off_1009D240;
// 10715198: using guessed type char byte_10715198;

//----- (1002ED10) --------------------------------------------------------
char sub_1002ED10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009D6D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009D6D0[v2];
        v4 = dword_1009D6CC[v2];
        v5 = dword_1009D6C8[v2];
        v6 = sub_10019E60(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009D6D8[v2 * 4]);
        v7 = sub_1001C460(
               0,
               *(&dword_100999F4 + dword_1009D6D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009D6D4[v2]],
               *(_DWORD *)&off_1009D6D8[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009D6C8: using guessed type int dword_1009D6C8[];
// 1009D6CC: using guessed type int dword_1009D6CC[];
// 1009D6D0: using guessed type int dword_1009D6D0[];
// 1009D6D4: using guessed type int dword_1009D6D4[];
// 10715198: using guessed type char byte_10715198;

//----- (1002EE70) --------------------------------------------------------
char sub_1002EE70()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10715198 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1001E890(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005377D,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1001E890(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005377D,
           "a",
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1001E890(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005377D,
           (const char *)&unk_1005377D,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1001E890(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1001A1C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (1002F090) --------------------------------------------------------
char sub_1002F090()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009DE6C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009DE68[v2];
        v4 = dword_1009DE64[v2];
        v5 = dword_1009DE60[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009DE70)[v2 * 4]);
        v7 = sub_1001C820(
               0,
               *(&dword_100999F4 + dword_1009DE6C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009DE6C[v2]],
               (&off_1009DE70)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009DE60: using guessed type int dword_1009DE60[];
// 1009DE64: using guessed type int dword_1009DE64[];
// 1009DE68: using guessed type int dword_1009DE68[];
// 1009DE6C: using guessed type int dword_1009DE6C[];
// 1009DE70: using guessed type char *off_1009DE70;
// 10715198: using guessed type char byte_10715198;

//----- (1002F1F0) --------------------------------------------------------
char sub_1002F1F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009E1D8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009E1D4[v2 / 2];
        v4 = word_1009E1D2[v2 / 2];
        v5 = word_1009E1D0[v2 / 2];
        v6 = sub_10019E60(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009E1DC[v2]);
        v7 = sub_1001CBC0(
               0,
               *(&dword_100999F4 + dword_1009E1D8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009E1D8[v2 / 4]],
               *(_DWORD *)&off_1009E1DC[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009E1D0: using guessed type __int16 word_1009E1D0[];
// 1009E1D2: using guessed type __int16 word_1009E1D2[];
// 1009E1D4: using guessed type __int16 word_1009E1D4[];
// 1009E1D8: using guessed type int dword_1009E1D8[];
// 10715198: using guessed type char byte_10715198;

//----- (1002F350) --------------------------------------------------------
char sub_1002F350()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009E49C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009E498[v2];
        v4 = dword_1009E494[v2];
        v5 = dword_1009E490[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009E4A0)[v2 * 4]);
        v7 = sub_1001CFC0(
               0,
               *(&dword_100999F4 + dword_1009E49C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009E49C[v2]],
               (&off_1009E4A0)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009E490: using guessed type int dword_1009E490[];
// 1009E494: using guessed type int dword_1009E494[];
// 1009E498: using guessed type int dword_1009E498[];
// 1009E49C: using guessed type int dword_1009E49C[];
// 1009E4A0: using guessed type char *off_1009E4A0;
// 10715198: using guessed type char byte_10715198;

//----- (1002F4B0) --------------------------------------------------------
char sub_1002F4B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009E818[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009E814[v2];
        LODWORD(v3) = dword_1009E810[v2];
        HIDWORD(v4) = dword_1009E80C[v2];
        LODWORD(v4) = dword_1009E808[v2];
        HIDWORD(v5) = dword_1009E804[v2];
        LODWORD(v5) = dword_1009E800[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009E81C[v2 * 4]);
        v7 = sub_1001D360(
               0,
               *(&dword_100999F4 + dword_1009E818[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009E818[v2]],
               *(_DWORD *)&off_1009E81C[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009E800: using guessed type int dword_1009E800[];
// 1009E804: using guessed type int dword_1009E804[];
// 1009E808: using guessed type int dword_1009E808[];
// 1009E80C: using guessed type int dword_1009E80C[];
// 1009E810: using guessed type int dword_1009E810[];
// 1009E814: using guessed type int dword_1009E814[];
// 1009E818: using guessed type int dword_1009E818[];
// 10715198: using guessed type char byte_10715198;

//----- (1002F620) --------------------------------------------------------
char sub_1002F620()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009ED84[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1009ED82[v2 * 4];
        v4 = byte_1009ED81[v2 * 4];
        v5 = byte_1009ED80[v2 * 4];
        v6 = sub_10019E60(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009ED88)[v2 * 4]);
        v7 = sub_1001D940(
               0,
               *(&dword_100999F4 + dword_1009ED84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009ED84[v2]],
               (&off_1009ED88)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009ED84: using guessed type int dword_1009ED84[];
// 1009ED88: using guessed type char *off_1009ED88;
// 10715198: using guessed type char byte_10715198;

//----- (1002F780) --------------------------------------------------------
char sub_1002F780()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009EF9C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009EF98[v2];
        v4 = dword_1009EF94[v2];
        v5 = dword_1009EF90[v2];
        v6 = sub_10019E60(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_1009EFA0)[v2 * 4]);
        v7 = sub_1001DD30(
               0,
               *(&dword_100999F4 + dword_1009EF9C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009EF9C[v2]],
               (&off_1009EFA0)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009EF90: using guessed type int dword_1009EF90[];
// 1009EF94: using guessed type int dword_1009EF94[];
// 1009EF98: using guessed type int dword_1009EF98[];
// 1009EF9C: using guessed type int dword_1009EF9C[];
// 1009EFA0: using guessed type char *off_1009EFA0;
// 10715198: using guessed type char byte_10715198;

//----- (1002F8E0) --------------------------------------------------------
char sub_1002F8E0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10715198 )
  {
    v2 = 0;
    do
    {
      if ( off_1009F304[v2] )
      {
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1009F30C[v2 * 4], 0x100u, &v11);
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1009F304[v2], 0x100u, &v12);
        sub_1002C770(&v12, &v11);
      }
      if ( byte_1009F300[v2 * 4] )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_1009F308[v2];
        v4 = *(char **)&off_1009F30C[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009F30C[v2 * 4],
               off_1009F308[v2]);
        v6 = sub_1001E4E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001A1C0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_1009F308[v2];
        v8 = *(char **)&off_1009F30C[v2 * 4];
        v9 = sub_10019E60(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009F30C[v2 * 4],
               off_1009F308[v2]);
        v10 = sub_1001E4E0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001A1C0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1009F304: using guessed type char *off_1009F304[3];
// 1009F308: using guessed type char *off_1009F308[2];
// 10715198: using guessed type char byte_10715198;

//----- (1002FB00) --------------------------------------------------------
char sub_1002FB00()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10715198 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1001A1C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1001A1C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1001A1C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1001A1C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001A1C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (1002FD00) --------------------------------------------------------
char sub_1002FD00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F394[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_1009F391[v2 * 4];
        v4 = byte_1009F390[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + dword_1009F394[v2])],
               (&off_1009F398)[v2 * 4]);
        v6 = sub_1001A300(
               1,
               *(&dword_100999F4 + dword_1009F394[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10019E60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009F394[v2]],
               (&off_1009F398)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F394: using guessed type int dword_1009F394[];
// 1009F398: using guessed type char *off_1009F398;
// 10715198: using guessed type char byte_10715198;

//----- (1002FE80) --------------------------------------------------------
char sub_1002FE80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F618[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1009F610[v2 / 8];
        v4 = dbl_1009F608[v2 / 8];
        v5 = dbl_1009F600[v2 / 8];
        v6 = sub_10019E60(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_1009F61C[v2]);
        v7 = sub_1001A6B0(
               1,
               *(&dword_100999F4 + dword_1009F618[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_1009F618[v2 / 4]],
               *(_DWORD *)&off_1009F61C[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F600: using guessed type double dbl_1009F600[];
// 1009F608: using guessed type double dbl_1009F608[];
// 1009F610: using guessed type double dbl_1009F610[];
// 1009F618: using guessed type int dword_1009F618[];
// 10715198: using guessed type char byte_10715198;

//----- (10030000) --------------------------------------------------------
char sub_10030000()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A022C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100A0228[v2];
        v4 = flt_100A0224[v2];
        v5 = flt_100A0220[v2];
        v6 = sub_10019E60(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A0230)[v2 * 4]);
        v7 = sub_1001AB00(
               1,
               *(&dword_100999F4 + dword_100A022C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A022C[v2]],
               (&off_100A0230)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A0220: using guessed type float flt_100A0220[];
// 100A0224: using guessed type float flt_100A0224[];
// 100A0228: using guessed type float flt_100A0228[];
// 100A022C: using guessed type int dword_100A022C[];
// 100A0230: using guessed type char *off_100A0230;
// 10715198: using guessed type char byte_10715198;

//----- (10030170) --------------------------------------------------------
char sub_10030170()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10715198 )
  {
    sub_1001E7E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10030170,
      (int)sub_10030170,
      0);
    sub_1001E7E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10030170,
      0,
      0);
    result = sub_1001E7E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10030170,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (10030260) --------------------------------------------------------
char sub_10030260()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A09C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A09C0[v2];
        v4 = dword_100A09BC[v2];
        v5 = dword_100A09B8[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A09C8[v2 * 4]);
        v7 = sub_1001AFC0(
               1,
               *(&dword_100999F4 + dword_100A09C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A09C4[v2]],
               *(_DWORD *)&off_100A09C8[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A09B8: using guessed type int dword_100A09B8[];
// 100A09BC: using guessed type int dword_100A09BC[];
// 100A09C0: using guessed type int dword_100A09C0[];
// 100A09C4: using guessed type int dword_100A09C4[];
// 10715198: using guessed type char byte_10715198;

//----- (100303C0) --------------------------------------------------------
char sub_100303C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A1158[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A1154[v2 / 2];
        v4 = word_100A1152[v2 / 2];
        v5 = word_100A1150[v2 / 2];
        v6 = sub_10019E60(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A115C[v2]);
        v7 = sub_1001B380(
               1,
               *(&dword_100999F4 + dword_100A1158[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A1158[v2 / 4]],
               *(_DWORD *)&off_100A115C[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A1150: using guessed type __int16 word_100A1150[];
// 100A1152: using guessed type __int16 word_100A1152[];
// 100A1154: using guessed type __int16 word_100A1154[];
// 100A1158: using guessed type int dword_100A1158[];
// 10715198: using guessed type char byte_10715198;

//----- (10030520) --------------------------------------------------------
char sub_10030520()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A176C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A1768[v2];
        v4 = dword_100A1764[v2];
        v5 = dword_100A1760[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A1770)[v2 * 4]);
        v7 = sub_1001B780(
               1,
               *(&dword_100999F4 + dword_100A176C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A176C[v2]],
               (&off_100A1770)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A1760: using guessed type int dword_100A1760[];
// 100A1764: using guessed type int dword_100A1764[];
// 100A1768: using guessed type int dword_100A1768[];
// 100A176C: using guessed type int dword_100A176C[];
// 100A1770: using guessed type char *off_100A1770;
// 10715198: using guessed type char byte_10715198;

//----- (10030680) --------------------------------------------------------
char sub_10030680()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A1F10[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A1F0C[v2];
        LODWORD(v3) = dword_100A1F08[v2];
        HIDWORD(v4) = dword_100A1F04[v2];
        LODWORD(v4) = dword_100A1F00[v2];
        HIDWORD(v5) = dword_100A1EFC[v2];
        LODWORD(v5) = dword_100A1EF8[v2];
        v6 = sub_10019E60(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A1F14[v2 * 4]);
        v7 = sub_1001BB40(
               1,
               *(&dword_100999F4 + dword_100A1F10[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A1F10[v2]],
               *(_DWORD *)&off_100A1F14[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A1EF8: using guessed type int dword_100A1EF8[];
// 100A1EFC: using guessed type int dword_100A1EFC[];
// 100A1F00: using guessed type int dword_100A1F00[];
// 100A1F04: using guessed type int dword_100A1F04[];
// 100A1F08: using guessed type int dword_100A1F08[];
// 100A1F0C: using guessed type int dword_100A1F0C[];
// 100A1F10: using guessed type int dword_100A1F10[];
// 10715198: using guessed type char byte_10715198;

//----- (100307F0) --------------------------------------------------------
char sub_100307F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A2B1C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A2B1A[v2 * 4];
        v4 = byte_100A2B19[v2 * 4];
        v5 = byte_100A2B18[v2 * 4];
        v6 = sub_10019E60(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A2B20)[v2 * 4]);
        v7 = sub_1001C080(
               1,
               *(&dword_100999F4 + dword_100A2B1C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A2B1C[v2]],
               (&off_100A2B20)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A2B1C: using guessed type int dword_100A2B1C[];
// 100A2B20: using guessed type char *off_100A2B20;
// 10715198: using guessed type char byte_10715198;

//----- (10030950) --------------------------------------------------------
char sub_10030950()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A2FB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A2FB0[v2];
        v4 = dword_100A2FAC[v2];
        v5 = dword_100A2FA8[v2];
        v6 = sub_10019E60(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A2FB8[v2 * 4]);
        v7 = sub_1001C460(
               1,
               *(&dword_100999F4 + dword_100A2FB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A2FB4[v2]],
               *(_DWORD *)&off_100A2FB8[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A2FA8: using guessed type int dword_100A2FA8[];
// 100A2FAC: using guessed type int dword_100A2FAC[];
// 100A2FB0: using guessed type int dword_100A2FB0[];
// 100A2FB4: using guessed type int dword_100A2FB4[];
// 10715198: using guessed type char byte_10715198;

//----- (10030AB0) --------------------------------------------------------
char sub_10030AB0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10715198 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1001E890(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1001E890(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005377D,
           "a",
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1001E890(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005377D,
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1001E890(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1001A1C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10715198: using guessed type char byte_10715198;

//----- (10030CB0) --------------------------------------------------------
char sub_10030CB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A374C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A3748[v2];
        v4 = dword_100A3744[v2];
        v5 = dword_100A3740[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A3750)[v2 * 4]);
        v7 = sub_1001C820(
               1,
               *(&dword_100999F4 + dword_100A374C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A374C[v2]],
               (&off_100A3750)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A3740: using guessed type int dword_100A3740[];
// 100A3744: using guessed type int dword_100A3744[];
// 100A3748: using guessed type int dword_100A3748[];
// 100A374C: using guessed type int dword_100A374C[];
// 100A3750: using guessed type char *off_100A3750;
// 10715198: using guessed type char byte_10715198;

//----- (10030E10) --------------------------------------------------------
char sub_10030E10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A3AB8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A3AB4[v2 / 2];
        v4 = word_100A3AB2[v2 / 2];
        v5 = word_100A3AB0[v2 / 2];
        v6 = sub_10019E60(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A3ABC[v2]);
        v7 = sub_1001CBC0(
               1,
               *(&dword_100999F4 + dword_100A3AB8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A3AB8[v2 / 4]],
               *(_DWORD *)&off_100A3ABC[v2]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A3AB0: using guessed type __int16 word_100A3AB0[];
// 100A3AB2: using guessed type __int16 word_100A3AB2[];
// 100A3AB4: using guessed type __int16 word_100A3AB4[];
// 100A3AB8: using guessed type int dword_100A3AB8[];
// 10715198: using guessed type char byte_10715198;

//----- (10030F70) --------------------------------------------------------
char sub_10030F70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A3D7C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A3D78[v2];
        v4 = dword_100A3D74[v2];
        v5 = dword_100A3D70[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A3D80)[v2 * 4]);
        v7 = sub_1001CFC0(
               1,
               *(&dword_100999F4 + dword_100A3D7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A3D7C[v2]],
               (&off_100A3D80)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A3D70: using guessed type int dword_100A3D70[];
// 100A3D74: using guessed type int dword_100A3D74[];
// 100A3D78: using guessed type int dword_100A3D78[];
// 100A3D7C: using guessed type int dword_100A3D7C[];
// 100A3D80: using guessed type char *off_100A3D80;
// 10715198: using guessed type char byte_10715198;

//----- (100310D0) --------------------------------------------------------
char sub_100310D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A40F8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A40F4[v2];
        LODWORD(v3) = dword_100A40F0[v2];
        HIDWORD(v4) = dword_100A40EC[v2];
        LODWORD(v4) = dword_100A40E8[v2];
        HIDWORD(v5) = dword_100A40E4[v2];
        LODWORD(v5) = dword_100A40E0[v2];
        v6 = sub_10019E60(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               *(_DWORD *)&off_100A40FC[v2 * 4]);
        v7 = sub_1001D360(
               1,
               *(&dword_100999F4 + dword_100A40F8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A40F8[v2]],
               *(_DWORD *)&off_100A40FC[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A40E0: using guessed type int dword_100A40E0[];
// 100A40E4: using guessed type int dword_100A40E4[];
// 100A40E8: using guessed type int dword_100A40E8[];
// 100A40EC: using guessed type int dword_100A40EC[];
// 100A40F0: using guessed type int dword_100A40F0[];
// 100A40F4: using guessed type int dword_100A40F4[];
// 100A40F8: using guessed type int dword_100A40F8[];
// 10715198: using guessed type char byte_10715198;

//----- (10031240) --------------------------------------------------------
char sub_10031240()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A4664[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A4662[v2 * 4];
        v4 = byte_100A4661[v2 * 4];
        v5 = byte_100A4660[v2 * 4];
        v6 = sub_10019E60(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A4668)[v2 * 4]);
        v7 = sub_1001D940(
               1,
               *(&dword_100999F4 + dword_100A4664[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A4664[v2]],
               (&off_100A4668)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4664: using guessed type int dword_100A4664[];
// 100A4668: using guessed type char *off_100A4668;
// 10715198: using guessed type char byte_10715198;

//----- (100313A0) --------------------------------------------------------
char sub_100313A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10715198 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A487C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A4878[v2];
        v4 = dword_100A4874[v2];
        v5 = dword_100A4870[v2];
        v6 = sub_10019E60(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * *(&dword_100999F4 + v0)],
               (&off_100A4880)[v2 * 4]);
        v7 = sub_1001DD30(
               1,
               *(&dword_100999F4 + dword_100A487C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10019E60(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A487C[v2]],
               (&off_100A4880)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4870: using guessed type int dword_100A4870[];
// 100A4874: using guessed type int dword_100A4874[];
// 100A4878: using guessed type int dword_100A4878[];
// 100A487C: using guessed type int dword_100A487C[];
// 100A4880: using guessed type char *off_100A4880;
// 10715198: using guessed type char byte_10715198;

//----- (10031500) --------------------------------------------------------
char sub_10031500()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10715199 )
  {
    sub_1001E890(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10019400(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1001AFC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10017E60() )
      v1 = 3;
    sub_1001AFC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10017E60();
    sub_1001AFC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10019400(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1001AFC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (10031AA0) --------------------------------------------------------
char sub_10031AA0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10715199 )
  {
    v2 = 0;
    do
    {
      if ( off_100A4BE4[v2] )
      {
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A4BEC[v2 * 4], 0x100u, &v13);
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100A4BE4[v2], 0x100u, &v14);
        sub_1002C770(&v14, &v13);
      }
      if ( byte_100A4BE0[v2 * 4] )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100A4BE8[v2];
        v4 = *(char **)&off_100A4BEC[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A4BEC[v2 * 4],
               off_100A4BE8[v2]);
        v12 = 1;
        v11 = sub_1001E4E0(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100A4BE8[v2];
        v7 = *(char **)&off_100A4BEC[v2 * 4];
        v8 = sub_10019E60(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A4BEC[v2 * 4],
               off_100A4BE8[v2]);
        v12 = 1;
        v11 = sub_1001E4E0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A4BE4: using guessed type char *off_100A4BE4[3];
// 100A4BE8: using guessed type char *off_100A4BE8[2];
// 10715199: using guessed type char byte_10715199;

//----- (10031CB0) --------------------------------------------------------
char sub_10031CB0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10715199 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1001A1C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1001A1C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1001A1C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1001A1C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001A1C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (10031EA0) --------------------------------------------------------
char sub_10031EA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100A4C34[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100A4C31[v2 * 4];
        v4 = byte_100A4C30[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * dword_100A4C34[v2]],
               (&off_100A4C38)[v2 * 4]);
        v6 = sub_1001A300(0, dword_100A4C34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_10019E60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100A4C34[v2]],
               (&off_100A4C38)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100A4C34: using guessed type int dword_100A4C34[];
// 100A4C38: using guessed type char *off_100A4C38;
// 10715199: using guessed type char byte_10715199;

//----- (10032010) --------------------------------------------------------
char sub_10032010()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100A4EB0[v2 / 2];
      v4 = dbl_100A4EA8[v2 / 2];
      v5 = dbl_100A4EA0[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A4EB8[v2]],
             *(_DWORD *)&off_100A4EBC[v2 * 4]);
      v7 = sub_1001A6B0(0, dword_100A4EB8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A4EB8[v2]],
             *(_DWORD *)&off_100A4EBC[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A4EA0: using guessed type double dbl_100A4EA0[];
// 100A4EA8: using guessed type double dbl_100A4EA8[];
// 100A4EB0: using guessed type double dbl_100A4EB0[];
// 100A4EB8: using guessed type int dword_100A4EB8[];
// 10715199: using guessed type char byte_10715199;

//----- (10032180) --------------------------------------------------------
char sub_10032180()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100A5AC8[v2];
      v4 = flt_100A5AC4[v2];
      v5 = flt_100A5AC0[v2];
      v6 = sub_10019E60(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A5ACC[v2]],
             (&off_100A5AD0)[v2 * 4]);
      v7 = sub_1001AB00(0, dword_100A5ACC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A5ACC[v2]],
             (&off_100A5AD0)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A5AC0: using guessed type float flt_100A5AC0[];
// 100A5AC4: using guessed type float flt_100A5AC4[];
// 100A5AC8: using guessed type float flt_100A5AC8[];
// 100A5ACC: using guessed type int dword_100A5ACC[];
// 100A5AD0: using guessed type char *off_100A5AD0;
// 10715199: using guessed type char byte_10715199;

//----- (100322E0) --------------------------------------------------------
char sub_100322E0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10715199 )
  {
    sub_1001E7E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_100322E0,
      (int)sub_100322E0,
      0);
    sub_1001E7E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_100322E0,
      0,
      0);
    result = sub_1001E7E0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100322E0,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (100323D0) --------------------------------------------------------
char sub_100323D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100A6260[v2];
      v4 = dword_100A625C[v2];
      v5 = dword_100A6258[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A6264[v2]],
             *(_DWORD *)&off_100A6268[v2 * 4]);
      v7 = sub_1001AFC0(0, dword_100A6264[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A6264[v2]],
             *(_DWORD *)&off_100A6268[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A6258: using guessed type int dword_100A6258[];
// 100A625C: using guessed type int dword_100A625C[];
// 100A6260: using guessed type int dword_100A6260[];
// 100A6264: using guessed type int dword_100A6264[];
// 10715199: using guessed type char byte_10715199;

//----- (10032530) --------------------------------------------------------
char sub_10032530()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100A69F4[v2 / 2];
      v4 = word_100A69F2[v2 / 2];
      v5 = word_100A69F0[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A69F8[v2 / 4]],
             *(_DWORD *)&off_100A69FC[v2]);
      v7 = sub_1001B380(
             0,
             dword_100A69F8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A69F8[v2 / 4]],
             *(_DWORD *)&off_100A69FC[v2]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A69F0: using guessed type __int16 word_100A69F0[];
// 100A69F2: using guessed type __int16 word_100A69F2[];
// 100A69F4: using guessed type __int16 word_100A69F4[];
// 100A69F8: using guessed type int dword_100A69F8[];
// 10715199: using guessed type char byte_10715199;

//----- (10032690) --------------------------------------------------------
char sub_10032690()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100A7008[v2];
      v4 = dword_100A7004[v2];
      v5 = dword_100A7000[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A700C[v2]],
             (&off_100A7010)[v2 * 4]);
      v7 = sub_1001B780(0, dword_100A700C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A700C[v2]],
             (&off_100A7010)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A7000: using guessed type int dword_100A7000[];
// 100A7004: using guessed type int dword_100A7004[];
// 100A7008: using guessed type int dword_100A7008[];
// 100A700C: using guessed type int dword_100A700C[];
// 100A7010: using guessed type char *off_100A7010;
// 10715199: using guessed type char byte_10715199;

//----- (100327F0) --------------------------------------------------------
char sub_100327F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100A77AC[v2];
      LODWORD(v3) = dword_100A77A8[v2];
      HIDWORD(v4) = dword_100A77A4[v2];
      LODWORD(v4) = dword_100A77A0[v2];
      HIDWORD(v5) = dword_100A779C[v2];
      LODWORD(v5) = dword_100A7798[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A77B0[v2]],
             *(_DWORD *)&off_100A77B4[v2 * 4]);
      v7 = sub_1001BB40(0, dword_100A77B0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A77B0[v2]],
             *(_DWORD *)&off_100A77B4[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A7798: using guessed type int dword_100A7798[];
// 100A779C: using guessed type int dword_100A779C[];
// 100A77A0: using guessed type int dword_100A77A0[];
// 100A77A4: using guessed type int dword_100A77A4[];
// 100A77A8: using guessed type int dword_100A77A8[];
// 100A77AC: using guessed type int dword_100A77AC[];
// 100A77B0: using guessed type int dword_100A77B0[];
// 10715199: using guessed type char byte_10715199;

//----- (10032960) --------------------------------------------------------
char sub_10032960()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100A83BA[v2 * 4];
      v4 = byte_100A83B9[v2 * 4];
      v5 = byte_100A83B8[v2 * 4];
      v6 = sub_10019E60(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A83BC[v2]],
             (&off_100A83C0)[v2 * 4]);
      v7 = sub_1001C080(0, dword_100A83BC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A83BC[v2]],
             (&off_100A83C0)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A83BC: using guessed type int dword_100A83BC[];
// 100A83C0: using guessed type char *off_100A83C0;
// 10715199: using guessed type char byte_10715199;

//----- (10032AC0) --------------------------------------------------------
char sub_10032AC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100A8850[v2];
      v4 = dword_100A884C[v2];
      v5 = dword_100A8848[v2];
      v6 = sub_10019E60(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A8854[v2]],
             *(_DWORD *)&off_100A8858[v2 * 4]);
      v7 = sub_1001C460(0, dword_100A8854[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A8854[v2]],
             *(_DWORD *)&off_100A8858[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8848: using guessed type int dword_100A8848[];
// 100A884C: using guessed type int dword_100A884C[];
// 100A8850: using guessed type int dword_100A8850[];
// 100A8854: using guessed type int dword_100A8854[];
// 10715199: using guessed type char byte_10715199;

//----- (10032C20) --------------------------------------------------------
char sub_10032C20()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10715199 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1001E890(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005377D,
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1001E890(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1001E890(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1001E890(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001A1C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (10032E20) --------------------------------------------------------
char sub_10032E20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100A8FE8[v2];
      v4 = dword_100A8FE4[v2];
      v5 = dword_100A8FE0[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A8FEC[v2]],
             (&off_100A8FF0)[v2 * 4]);
      v7 = sub_1001C820(0, dword_100A8FEC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A8FEC[v2]],
             (&off_100A8FF0)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8FE0: using guessed type int dword_100A8FE0[];
// 100A8FE4: using guessed type int dword_100A8FE4[];
// 100A8FE8: using guessed type int dword_100A8FE8[];
// 100A8FEC: using guessed type int dword_100A8FEC[];
// 100A8FF0: using guessed type char *off_100A8FF0;
// 10715199: using guessed type char byte_10715199;

//----- (10032F80) --------------------------------------------------------
char sub_10032F80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100A9354[v2 / 2];
      v4 = word_100A9352[v2 / 2];
      v5 = word_100A9350[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A9358[v2 / 4]],
             *(_DWORD *)&off_100A935C[v2]);
      v7 = sub_1001CBC0(
             0,
             dword_100A9358[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A9358[v2 / 4]],
             *(_DWORD *)&off_100A935C[v2]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9350: using guessed type __int16 word_100A9350[];
// 100A9352: using guessed type __int16 word_100A9352[];
// 100A9354: using guessed type __int16 word_100A9354[];
// 100A9358: using guessed type int dword_100A9358[];
// 10715199: using guessed type char byte_10715199;

//----- (100330E0) --------------------------------------------------------
char sub_100330E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100A9618[v2];
      v4 = dword_100A9614[v2];
      v5 = dword_100A9610[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A961C[v2]],
             (&off_100A9620)[v2 * 4]);
      v7 = sub_1001CFC0(0, dword_100A961C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A961C[v2]],
             (&off_100A9620)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9610: using guessed type int dword_100A9610[];
// 100A9614: using guessed type int dword_100A9614[];
// 100A9618: using guessed type int dword_100A9618[];
// 100A961C: using guessed type int dword_100A961C[];
// 100A9620: using guessed type char *off_100A9620;
// 10715199: using guessed type char byte_10715199;

//----- (10033240) --------------------------------------------------------
char sub_10033240()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100A9994[v2];
      LODWORD(v3) = dword_100A9990[v2];
      HIDWORD(v4) = dword_100A998C[v2];
      LODWORD(v4) = dword_100A9988[v2];
      HIDWORD(v5) = dword_100A9984[v2];
      LODWORD(v5) = dword_100A9980[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A9998[v2]],
             *(_DWORD *)&off_100A999C[v2 * 4]);
      v7 = sub_1001D360(0, dword_100A9998[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A9998[v2]],
             *(_DWORD *)&off_100A999C[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9980: using guessed type int dword_100A9980[];
// 100A9984: using guessed type int dword_100A9984[];
// 100A9988: using guessed type int dword_100A9988[];
// 100A998C: using guessed type int dword_100A998C[];
// 100A9990: using guessed type int dword_100A9990[];
// 100A9994: using guessed type int dword_100A9994[];
// 100A9998: using guessed type int dword_100A9998[];
// 10715199: using guessed type char byte_10715199;

//----- (100333B0) --------------------------------------------------------
char sub_100333B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100A9F02[v2 * 4];
      v4 = byte_100A9F01[v2 * 4];
      v5 = byte_100A9F00[v2 * 4];
      v6 = sub_10019E60(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100A9F04[v2]],
             (&off_100A9F08)[v2 * 4]);
      v7 = sub_1001D940(0, dword_100A9F04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100A9F04[v2]],
             (&off_100A9F08)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9F04: using guessed type int dword_100A9F04[];
// 100A9F08: using guessed type char *off_100A9F08;
// 10715199: using guessed type char byte_10715199;

//----- (10033510) --------------------------------------------------------
char sub_10033510()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100AA118[v2];
      v4 = dword_100AA114[v2];
      v5 = dword_100AA110[v2];
      v6 = sub_10019E60(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AA11C[v2]],
             (&off_100AA120)[v2 * 4]);
      v7 = sub_1001DD30(0, dword_100AA11C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AA11C[v2]],
             (&off_100AA120)[v2 * 4]);
      result = sub_1001A1C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA110: using guessed type int dword_100AA110[];
// 100AA114: using guessed type int dword_100AA114[];
// 100AA118: using guessed type int dword_100AA118[];
// 100AA11C: using guessed type int dword_100AA11C[];
// 100AA120: using guessed type char *off_100AA120;
// 10715199: using guessed type char byte_10715199;

//----- (10033670) --------------------------------------------------------
char sub_10033670()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10715199 )
  {
    v2 = 0;
    do
    {
      if ( off_100AA484[v2] )
      {
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100AA48C[v2 * 4], 0x100u, &v13);
        sub_10019BC0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100AA484[v2], 0x100u, &v14);
        sub_1002C770(&v14, &v13);
      }
      if ( byte_100AA480[v2 * 4] )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100AA488[v2];
        v4 = *(char **)&off_100AA48C[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AA48C[v2 * 4],
               off_100AA488[v2]);
        v12 = 1;
        v11 = sub_1001E4E0(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100AA488[v2];
        v7 = *(char **)&off_100AA48C[v2 * 4];
        v8 = sub_10019E60(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AA48C[v2 * 4],
               off_100AA488[v2]);
        v12 = 1;
        v11 = sub_1001E4E0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA484: using guessed type char *off_100AA484[3];
// 100AA488: using guessed type char *off_100AA488[2];
// 10715199: using guessed type char byte_10715199;

//----- (10033880) --------------------------------------------------------
char sub_10033880()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10715199 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1001A1C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1001A1C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1001A1C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1001A1C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001A1C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (10033A70) --------------------------------------------------------
char sub_10033A70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      v0 = dword_100AA4D4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100AA4D1[v2 * 4];
        v4 = byte_100AA4D0[v2 * 4];
        v5 = sub_10019E60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100999D8[4 * dword_100AA4D4[v2]],
               (&off_100AA4D8)[v2 * 4]);
        v6 = sub_1001A300(1, dword_100AA4D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_10019E60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100999D8[4 * dword_100AA4D4[v2]],
               (&off_100AA4D8)[v2 * 4]);
        LOBYTE(v0) = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10019400(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100AA4D4: using guessed type int dword_100AA4D4[];
// 100AA4D8: using guessed type char *off_100AA4D8;
// 10715199: using guessed type char byte_10715199;

//----- (10033BE0) --------------------------------------------------------
char sub_10033BE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100AA750[v2 / 2];
      v4 = dbl_100AA748[v2 / 2];
      v5 = dbl_100AA740[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AA758[v2]],
             *(_DWORD *)&off_100AA75C[v2 * 4]);
      v7 = sub_1001A6B0(1, dword_100AA758[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AA758[v2]],
             *(_DWORD *)&off_100AA75C[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA740: using guessed type double dbl_100AA740[];
// 100AA748: using guessed type double dbl_100AA748[];
// 100AA750: using guessed type double dbl_100AA750[];
// 100AA758: using guessed type int dword_100AA758[];
// 10715199: using guessed type char byte_10715199;

//----- (10033D50) --------------------------------------------------------
char sub_10033D50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100AB368[v2];
      v4 = flt_100AB364[v2];
      v5 = flt_100AB360[v2];
      v6 = sub_10019E60(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AB36C[v2]],
             (&off_100AB370)[v2 * 4]);
      v7 = sub_1001AB00(1, dword_100AB36C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AB36C[v2]],
             (&off_100AB370)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB360: using guessed type float flt_100AB360[];
// 100AB364: using guessed type float flt_100AB364[];
// 100AB368: using guessed type float flt_100AB368[];
// 100AB36C: using guessed type int dword_100AB36C[];
// 100AB370: using guessed type char *off_100AB370;
// 10715199: using guessed type char byte_10715199;

//----- (10033EB0) --------------------------------------------------------
char sub_10033EB0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10715199 )
  {
    sub_1001E7E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10033EB0,
      (int)sub_10033EB0,
      0);
    sub_1001E7E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10033EB0,
      0,
      0);
    result = sub_1001E7E0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10033EB0,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (10033FA0) --------------------------------------------------------
char sub_10033FA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100ABB00[v2];
      v4 = dword_100ABAFC[v2];
      v5 = dword_100ABAF8[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100ABB04[v2]],
             *(_DWORD *)&off_100ABB08[v2 * 4]);
      v7 = sub_1001AFC0(1, dword_100ABB04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100ABB04[v2]],
             *(_DWORD *)&off_100ABB08[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100ABAF8: using guessed type int dword_100ABAF8[];
// 100ABAFC: using guessed type int dword_100ABAFC[];
// 100ABB00: using guessed type int dword_100ABB00[];
// 100ABB04: using guessed type int dword_100ABB04[];
// 10715199: using guessed type char byte_10715199;

//----- (10034100) --------------------------------------------------------
char sub_10034100()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100AC294[v2 / 2];
      v4 = word_100AC292[v2 / 2];
      v5 = word_100AC290[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AC298[v2 / 4]],
             *(_DWORD *)&off_100AC29C[v2]);
      v7 = sub_1001B380(
             1,
             dword_100AC298[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AC298[v2 / 4]],
             *(_DWORD *)&off_100AC29C[v2]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AC290: using guessed type __int16 word_100AC290[];
// 100AC292: using guessed type __int16 word_100AC292[];
// 100AC294: using guessed type __int16 word_100AC294[];
// 100AC298: using guessed type int dword_100AC298[];
// 10715199: using guessed type char byte_10715199;

//----- (10034260) --------------------------------------------------------
char sub_10034260()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100AC8A8[v2];
      v4 = dword_100AC8A4[v2];
      v5 = dword_100AC8A0[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AC8AC[v2]],
             (&off_100AC8B0)[v2 * 4]);
      v7 = sub_1001B780(1, dword_100AC8AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AC8AC[v2]],
             (&off_100AC8B0)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AC8A0: using guessed type int dword_100AC8A0[];
// 100AC8A4: using guessed type int dword_100AC8A4[];
// 100AC8A8: using guessed type int dword_100AC8A8[];
// 100AC8AC: using guessed type int dword_100AC8AC[];
// 100AC8B0: using guessed type char *off_100AC8B0;
// 10715199: using guessed type char byte_10715199;

//----- (100343C0) --------------------------------------------------------
char sub_100343C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100AD04C[v2];
      LODWORD(v3) = dword_100AD048[v2];
      HIDWORD(v4) = dword_100AD044[v2];
      LODWORD(v4) = dword_100AD040[v2];
      HIDWORD(v5) = dword_100AD03C[v2];
      LODWORD(v5) = dword_100AD038[v2];
      v6 = sub_10019E60(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AD050[v2]],
             *(_DWORD *)&off_100AD054[v2 * 4]);
      v7 = sub_1001BB40(1, dword_100AD050[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AD050[v2]],
             *(_DWORD *)&off_100AD054[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AD038: using guessed type int dword_100AD038[];
// 100AD03C: using guessed type int dword_100AD03C[];
// 100AD040: using guessed type int dword_100AD040[];
// 100AD044: using guessed type int dword_100AD044[];
// 100AD048: using guessed type int dword_100AD048[];
// 100AD04C: using guessed type int dword_100AD04C[];
// 100AD050: using guessed type int dword_100AD050[];
// 10715199: using guessed type char byte_10715199;

//----- (10034530) --------------------------------------------------------
char sub_10034530()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100ADC5A[v2 * 4];
      v4 = byte_100ADC59[v2 * 4];
      v5 = byte_100ADC58[v2 * 4];
      v6 = sub_10019E60(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100ADC5C[v2]],
             (&off_100ADC60)[v2 * 4]);
      v7 = sub_1001C080(1, dword_100ADC5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100ADC5C[v2]],
             (&off_100ADC60)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100ADC5C: using guessed type int dword_100ADC5C[];
// 100ADC60: using guessed type char *off_100ADC60;
// 10715199: using guessed type char byte_10715199;

//----- (10034690) --------------------------------------------------------
char sub_10034690()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100AE0F0[v2];
      v4 = dword_100AE0EC[v2];
      v5 = dword_100AE0E8[v2];
      v6 = sub_10019E60(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AE0F4[v2]],
             *(_DWORD *)&off_100AE0F8[v2 * 4]);
      v7 = sub_1001C460(1, dword_100AE0F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AE0F4[v2]],
             *(_DWORD *)&off_100AE0F8[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AE0E8: using guessed type int dword_100AE0E8[];
// 100AE0EC: using guessed type int dword_100AE0EC[];
// 100AE0F0: using guessed type int dword_100AE0F0[];
// 100AE0F4: using guessed type int dword_100AE0F4[];
// 10715199: using guessed type char byte_10715199;

//----- (100347F0) --------------------------------------------------------
char sub_100347F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10019400(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10019D50(0);
  sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10019400(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10715199 )
  {
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1001E890(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005377D,
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1001E890(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1001E890(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005377D,
           0);
    sub_1001A1C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1001E890(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001A1C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10715199: using guessed type char byte_10715199;

//----- (100349F0) --------------------------------------------------------
char sub_100349F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100AE888[v2];
      v4 = dword_100AE884[v2];
      v5 = dword_100AE880[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AE88C[v2]],
             (&off_100AE890)[v2 * 4]);
      v7 = sub_1001C820(1, dword_100AE88C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AE88C[v2]],
             (&off_100AE890)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AE880: using guessed type int dword_100AE880[];
// 100AE884: using guessed type int dword_100AE884[];
// 100AE888: using guessed type int dword_100AE888[];
// 100AE88C: using guessed type int dword_100AE88C[];
// 100AE890: using guessed type char *off_100AE890;
// 10715199: using guessed type char byte_10715199;

//----- (10034B50) --------------------------------------------------------
char sub_10034B50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100AEBF4[v2 / 2];
      v4 = word_100AEBF2[v2 / 2];
      v5 = word_100AEBF0[v2 / 2];
      v6 = sub_10019E60(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AEBF8[v2 / 4]],
             *(_DWORD *)&off_100AEBFC[v2]);
      v7 = sub_1001CBC0(
             1,
             dword_100AEBF8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AEBF8[v2 / 4]],
             *(_DWORD *)&off_100AEBFC[v2]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AEBF0: using guessed type __int16 word_100AEBF0[];
// 100AEBF2: using guessed type __int16 word_100AEBF2[];
// 100AEBF4: using guessed type __int16 word_100AEBF4[];
// 100AEBF8: using guessed type int dword_100AEBF8[];
// 10715199: using guessed type char byte_10715199;

//----- (10034CB0) --------------------------------------------------------
char sub_10034CB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100AEEB8[v2];
      v4 = dword_100AEEB4[v2];
      v5 = dword_100AEEB0[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AEEBC[v2]],
             (&off_100AEEC0)[v2 * 4]);
      v7 = sub_1001CFC0(1, dword_100AEEBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AEEBC[v2]],
             (&off_100AEEC0)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AEEB0: using guessed type int dword_100AEEB0[];
// 100AEEB4: using guessed type int dword_100AEEB4[];
// 100AEEB8: using guessed type int dword_100AEEB8[];
// 100AEEBC: using guessed type int dword_100AEEBC[];
// 100AEEC0: using guessed type char *off_100AEEC0;
// 10715199: using guessed type char byte_10715199;

//----- (10034E10) --------------------------------------------------------
char sub_10034E10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100AF234[v2];
      LODWORD(v3) = dword_100AF230[v2];
      HIDWORD(v4) = dword_100AF22C[v2];
      LODWORD(v4) = dword_100AF228[v2];
      HIDWORD(v5) = dword_100AF224[v2];
      LODWORD(v5) = dword_100AF220[v2];
      v6 = sub_10019E60(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AF238[v2]],
             *(_DWORD *)&off_100AF23C[v2 * 4]);
      v7 = sub_1001D360(1, dword_100AF238[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AF238[v2]],
             *(_DWORD *)&off_100AF23C[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AF220: using guessed type int dword_100AF220[];
// 100AF224: using guessed type int dword_100AF224[];
// 100AF228: using guessed type int dword_100AF228[];
// 100AF22C: using guessed type int dword_100AF22C[];
// 100AF230: using guessed type int dword_100AF230[];
// 100AF234: using guessed type int dword_100AF234[];
// 100AF238: using guessed type int dword_100AF238[];
// 10715199: using guessed type char byte_10715199;

//----- (10034F80) --------------------------------------------------------
char sub_10034F80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100AF7A2[v2 * 4];
      v4 = byte_100AF7A1[v2 * 4];
      v5 = byte_100AF7A0[v2 * 4];
      v6 = sub_10019E60(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AF7A4[v2]],
             (&off_100AF7A8)[v2 * 4]);
      v7 = sub_1001D940(1, dword_100AF7A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AF7A4[v2]],
             (&off_100AF7A8)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AF7A4: using guessed type int dword_100AF7A4[];
// 100AF7A8: using guessed type char *off_100AF7A8;
// 10715199: using guessed type char byte_10715199;

//----- (100350E0) --------------------------------------------------------
char sub_100350E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10715199 )
  {
    sub_10019400(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10019D50(0);
    sub_10019400(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10019400(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10019E40(0);
    v2 = 0;
    do
    {
      sub_10019D70((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100AF9B8[v2];
      v4 = dword_100AF9B4[v2];
      v5 = dword_100AF9B0[v2];
      v6 = sub_10019E60(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100999D8[4 * dword_100AF9BC[v2]],
             (&off_100AF9C0)[v2 * 4]);
      v7 = sub_1001DD30(1, dword_100AF9BC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_10019E60(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100999D8[4 * dword_100AF9BC[v2]],
             (&off_100AF9C0)[v2 * 4]);
      result = sub_1001A1C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10019400(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AF9B0: using guessed type int dword_100AF9B0[];
// 100AF9B4: using guessed type int dword_100AF9B4[];
// 100AF9B8: using guessed type int dword_100AF9B8[];
// 100AF9BC: using guessed type int dword_100AF9BC[];
// 100AF9C0: using guessed type char *off_100AF9C0;
// 10715199: using guessed type char byte_10715199;

//----- (10035240) --------------------------------------------------------
char **sub_10035240()
{
  return off_1009B0C4;
}
// 1009B0C4: using guessed type char *off_1009B0C4[3];

//----- (10035250) --------------------------------------------------------
int __cdecl sub_10035250(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10035270) --------------------------------------------------------
int (__cdecl *__usercall sub_10035270@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10035280) --------------------------------------------------------
int __usercall sub_10035280@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (100354B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100354B0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10035270(a1, (int)word_10053650);
  sub_10035270(a1, a2);
  sub_10035270(a1, (int)&unk_100B3C14);
  v3 = sub_10035280(a3, a1);
  sub_10035270(a1, v3);
  return sub_10035270(a1, (int)&unk_100B3C10);
}

//----- (10035500) --------------------------------------------------------
int (__cdecl *__cdecl sub_10035500(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10035270(a1, (int)word_10053650);
  sub_10035270(a1, a2);
  sub_10035270(a1, (int)&unk_100B3C1C);
  v3 = sub_10035280(a3, a1);
  sub_10035270(a1, v3);
  return sub_10035270(a1, (int)&unk_100B3C18);
}

//----- (10035550) --------------------------------------------------------
int (__cdecl *__cdecl sub_10035550(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10035270(a1, (int)&unk_100B3C20);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10035280(a2, a1);
    result = sub_10035270(a1, v3);
  }
  return result;
}

//----- (100355A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100355A0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100B3C28;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10035270(a1, dword_100B3B7C[(signed int)result]);
      sub_10035270(a1, (int)&unk_100B3C24);
      sub_10035270(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100B3C20;
    }
    result = sub_10035270(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10035270(a1, (int)&word_1008A62C);
  }
  return result;
}
// 1008A62C: using guessed type __int16 word_1008A62C;
// 100B3B7C: using guessed type int dword_100B3B7C[];

//----- (10035620) --------------------------------------------------------
int __cdecl sub_10035620(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10035270(a1, (int)&unk_100B3C20);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10035270(a1, *((_DWORD *)&off_100B3B80 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_10035270(a1, (int)&unk_100B3C2C);
  sub_10035270(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (100356A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100356A0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10035280(a2, a1);
    sub_10035270(a1, v3);
    result = sub_10035270(a1, (int)&word_1008A62C);
  }
  else
  {
    sub_10035270(a1, (int)a2);
    result = sub_10035270(a1, (int)&word_1008A62C);
  }
  return result;
}
// 1008A62C: using guessed type __int16 word_1008A62C;

//----- (100356F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100356F0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10035620(a1, a2);
  if ( a3 && *a3 )
    sub_10035550(a1, a3);
  return sub_100355A0(a1);
}

//----- (10035730) --------------------------------------------------------
int (__cdecl *__cdecl sub_10035730(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_100356F0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10035790) --------------------------------------------------------
int __cdecl sub_10035790(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10015280(&a1, 1u, (int)&unk_100B56A0, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100B56A4[2 * v1];
  }
  else
  {
    sub_1000D9C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100B56A4: using guessed type int dword_100B56A4[];

//----- (100357E0) --------------------------------------------------------
BOOL __cdecl sub_100357E0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (100357F0) --------------------------------------------------------
BOOL __usercall sub_100357F0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_100357E0(a1) && *v2 < 3u && a2 == 24;
}

//----- (10035820) --------------------------------------------------------
bool __cdecl sub_10035820(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_100357E0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_100169A0((unsigned __int8)byte_100B67B8[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10014ED0(1, (unsigned __int16)word_100B67B0[v6], &Tm.tm_mon) || sub_10016440((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1002AE90(a1, &v15) || v15 != dword_100B67D0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10014ED0(1, (unsigned __int16)word_100B67B4[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100B67B0: using guessed type __int16 word_100B67B0[];
// 100B67B4: using guessed type __int16 word_100B67B4[];
// 100B67D0: using guessed type int dword_100B67D0[];

//----- (100359D0) --------------------------------------------------------
bool __cdecl sub_100359D0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_100357E0(a1) )
    result = sub_10038660((unsigned __int16)word_100B67BA[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100B67BA: using guessed type __int16 word_100B67BA[];

//----- (10035A10) --------------------------------------------------------
bool __cdecl sub_10035A10(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1002ADE0(a1);
  if ( !(unsigned __int8)sub_100357F0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10035820(v9, a3, *a4, (int)a5);
  if ( sub_100169A0((unsigned __int8)byte_100B67B8[20 * v6], (bool *)&v8) && v8 && sub_100359D0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10035A10: using guessed type int var_20[7];

//----- (10035B00) --------------------------------------------------------
int __cdecl sub_10035B00(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (10035B20) --------------------------------------------------------
char __cdecl sub_10035B20(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_1002B840((int)&v12);
}
// 10035B20: using guessed type char var_518[1300];

//----- (10035BF0) --------------------------------------------------------
int __cdecl sub_10035BF0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100B804C[2 * sub_10015280(&a1, 1u, (int)&unk_100B8048, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100B808C[2 * sub_10015280(&a2, 1u, (int)&unk_100B8088, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100B80BC[2 * sub_10015280(&a2, 1u, (int)&unk_100B80B8, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100B8064[2 * sub_10015280(&a2, 1u, (int)&unk_100B8060, 8, 5, 5)];
  }
  return result;
}
// 100B804C: using guessed type int dword_100B804C[];
// 100B8064: using guessed type int dword_100B8064[];
// 100B808C: using guessed type int dword_100B808C[];
// 100B80BC: using guessed type int dword_100B80BC[];

//----- (10035CA0) --------------------------------------------------------
bool __usercall sub_10035CA0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100C44D7[44 * a1] - (unsigned __int8)byte_100C44D2[44 * a1];
}

//----- (10035CD0) --------------------------------------------------------
char __usercall sub_10035CD0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10035CA0(a1, a4, a5) )
  {
    v6 = a3
       + sub_10035BF0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100C44D2[44 * a1] - (unsigned __int8)byte_100C44D7[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10035BF0(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10035D70) --------------------------------------------------------
char __cdecl sub_10035D70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B9E0(a1);
  sub_10038680(v5, (int)&v7, 3684);
  return sub_10035CD0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10035DF0) --------------------------------------------------------
char __cdecl sub_10035DF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B9E0(a1);
  sub_10038680(v5, (int)&v7, 3684);
  return sub_10035CD0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10035E70) --------------------------------------------------------
char __cdecl sub_10035E70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B9E0(a1);
  sub_10038680(v5, (int)&v7, 3684);
  return sub_10035CD0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10035EF0) --------------------------------------------------------
char __cdecl sub_10035EF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B9E0(a1);
  sub_10038680(v5, (int)&v7, 3684);
  return sub_10035CD0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10035F70) --------------------------------------------------------
char __cdecl sub_10035F70(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10036010) --------------------------------------------------------
bool __cdecl sub_10036010(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10015280(&a2, 4u, (int)&dword_100BBB40, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10038660((unsigned __int16)word_100BBB44[a1 + 6 * v3], a3, (unsigned __int16)word_100BBB48[6 * v3]) == 0;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100BBB40: using guessed type int dword_100BBB40;
// 100BBB44: using guessed type __int16 word_100BBB44[];
// 100BBB48: using guessed type __int16 word_100BBB48[];

//----- (100360A0) --------------------------------------------------------
bool __cdecl sub_100360A0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10036140(a1);
  v6 = sub_10015280(&a3, 1u, (int)&unk_100BBB64, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10015280(&dword_100BBB68[2 * v6], 4u, (int)&dword_100BBB40, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100BBB48[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10036010(v11, *(int *)((char *)&dword_100BBB40 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100BBB40: using guessed type int dword_100BBB40;
// 100BBB48: using guessed type __int16 word_100BBB48[];

//----- (10036140) --------------------------------------------------------
char __cdecl sub_10036140(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (100361C0) --------------------------------------------------------
char __cdecl sub_100361C0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_1002BE80(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10038660(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_1002BEA0((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (10036330) --------------------------------------------------------
int __usercall sub_10036330@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_100361C0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 10036330: using guessed type int var_2C[10];

//----- (10036370) --------------------------------------------------------
int __usercall sub_10036370@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_100361C0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10036370: using guessed type int var_14[4];

//----- (100363B0) --------------------------------------------------------
signed int sub_100363B0()
{
  return sub_10039B10((int)&off_100BDA08);
}
// 100BDA08: using guessed type char *off_100BDA08;

//----- (100363C0) --------------------------------------------------------
char __cdecl sub_100363C0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_100363B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1077A60C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1077A60C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1077A60C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1077A60C: using guessed type int dword_1077A60C;

//----- (10036420) --------------------------------------------------------
char __cdecl sub_10036420(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_100363B0() )
  {
    if ( (sub_1002BEC0(a1)
       || *(_BYTE *)(dword_1077A60C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1077A60C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1077A60C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 176))
      && *(_BYTE *)(dword_1077A60C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1077A60C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1077A60C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1077A60C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1077A60C: using guessed type int dword_1077A60C;

//----- (10036540) --------------------------------------------------------
char __cdecl sub_10036540(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_100363B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1077A60C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1077A60C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1077A60C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1077A60C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1077A60C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1077A60C: using guessed type int dword_1077A60C;

//----- (100365C0) --------------------------------------------------------
char __cdecl sub_100365C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10036370(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10036540(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_10036330(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_100363C0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_100361C0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10036420(v6, a5);
        }
      }
      else
      {
        sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10036770) --------------------------------------------------------
int __cdecl sub_10036770(char a1)
{
  return sub_10015280(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (10036790) --------------------------------------------------------
BOOL __cdecl sub_10036790(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10035790(a1);
  return sub_10014ED0(0, 604, a2) && sub_100148A0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (100367F0) --------------------------------------------------------
int __usercall sub_100367F0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10036770(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100BDA4C[2 * v1];
  return result;
}
// 100BDA4C: using guessed type int dword_100BDA4C[];

//----- (10036820) --------------------------------------------------------
BOOL __cdecl sub_10036820(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100367F0(a1);
  return sub_10038660(v2, a2, 16) == 0;
}

//----- (10036850) --------------------------------------------------------
int __cdecl sub_10036850(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10036820(a1, (int)a5);
  else
    result = sub_10036790(a1, a5);
  return result;
}

//----- (10036880) --------------------------------------------------------
char __cdecl sub_10036880(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10014F00(1, 1947, a1, (int)&v3);
}

//----- (100368A0) --------------------------------------------------------
BOOL __cdecl sub_100368A0(int a1)
{
  return sub_10038660(6792, a1, 284) == 0;
}

//----- (100368C0) --------------------------------------------------------
char __cdecl sub_100368C0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_100368A0((int)a5);
  else
    result = sub_10036880(a5);
  return result;
}

//----- (100368F0) --------------------------------------------------------
bool __cdecl sub_100368F0(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10038660((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10036930) --------------------------------------------------------
signed int __usercall sub_10036930@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10036950) --------------------------------------------------------
bool __cdecl sub_10036950(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10036930(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_100148A0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10014F00(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_100368F0(a1, a2);
  }
  else
  {
    v9 = sub_10014FF0(v4);
    v8 = 1708;
    sub_10014A00(1, 0, &v8, 0, 8, 1);
    sub_10014B40(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10039CA0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10039CC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10036A40) --------------------------------------------------------
bool __cdecl sub_10036A40(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_100368F0(a1, a5);
  else
    result = sub_10036950(a1, a5);
  return result;
}

//----- (10036A70) --------------------------------------------------------
char __cdecl sub_10036A70(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_10717A40, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_1002BE50(a1, (int)byte_10717A40);
    v3 = 4 * a2 - 64;
    v4 = byte_10717A41[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10717A40[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10036B10) --------------------------------------------------------
bool __cdecl sub_10036B10(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_10717A40, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_1002BE50(a1, (int)byte_10717A40);
    v3 = (char *)&unk_10717AE0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10036B90) --------------------------------------------------------
char __cdecl sub_10036B90(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10717A40, 0, 0x890u);
  sub_1002BE50(a1, (int)byte_10717A40);
  if ( a2 > 0x10u )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_10717DB0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10717DB4[2 * a2];
    result = 1;
  }
  return result;
}
// 10717DB0: using guessed type int dword_10717DB0[];
// 10717DB4: using guessed type int dword_10717DB4[];

//----- (10036C00) --------------------------------------------------------
char __cdecl sub_10036C00(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10014ED0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10014ED0(0, 572, a2);
    }
    else
    {
      sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10014ED0(0, 226, a2);
  }
  return result;
}

//----- (10036C80) --------------------------------------------------------
char __cdecl sub_10036C80(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_10717A40, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10036C00(a1, byte_10717A40);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_10717A41[v4];
    *(_BYTE *)a3 = byte_10717A40[v4];
  }
  return result;
}

//----- (10036D00) --------------------------------------------------------
char __cdecl sub_10036D00(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_10717A40, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10036C00(a1, byte_10717A40);
    v4 = (char *)&unk_10717AE0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10036D80) --------------------------------------------------------
char __cdecl sub_10036D80(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10717A40, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10036C00(a1, byte_10717A40);
    *(_DWORD *)a3 = dword_10717DB0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10717DB4[2 * a2];
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 10717DB0: using guessed type int dword_10717DB0[];
// 10717DB4: using guessed type int dword_10717DB4[];

//----- (10036DF0) --------------------------------------------------------
char __cdecl sub_10036DF0(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10037C50(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10036B90(v6, *a4, a5);
    else
      result = sub_10036D80(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_10036A70(v6, *a4, a5);
    else
      result = sub_10036C80(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10036B10(v6, *a4, a5);
    else
      result = sub_10036D00(v6, *a4, a5);
  }
  return result;
}

//----- (10036F00) --------------------------------------------------------
char __cdecl sub_10036F00(char a1, void *a2)
{
  return sub_10014ED0(6, (unsigned __int16)word_100BEA82[8 * (unsigned __int8)a1], a2);
}
// 100BEA82: using guessed type __int16 word_100BEA82[];

//----- (10036F20) --------------------------------------------------------
bool __cdecl sub_10036F20(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10038660(dword_100BEA88[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100BEA88: using guessed type int dword_100BEA88[];

//----- (10036F60) --------------------------------------------------------
char __cdecl sub_10036F60(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10037C90(a1);
  if ( a2 )
    result = sub_10036F20(v6, (char *)a5);
  else
    result = sub_10036F00(v6, a5);
  return result;
}

//----- (10036FA0) --------------------------------------------------------
BOOL sub_10036FA0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_100168E0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10037000) --------------------------------------------------------
char __cdecl sub_10037000(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10014ED0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10036FA0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10016170((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (100370F0) --------------------------------------------------------
BOOL __cdecl sub_100370F0(int a1, int a2)
{
  return sub_10038660(6200, a2, 60) == 0;
}

//----- (10037110) --------------------------------------------------------
char __cdecl sub_10037110(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_100370F0(a1, (int)a5);
  }
  else
  {
    result = sub_10037000(a1, a5);
  }
  return result;
}

//----- (10037150) --------------------------------------------------------
char __cdecl sub_10037150(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10014ED0(2, 284, &v6) || sub_10016340((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10037200) --------------------------------------------------------
BOOL __cdecl sub_10037200(int a1, int a2)
{
  return sub_10038660(6169, a2, 40) == 0;
}

//----- (10037220) --------------------------------------------------------
char __cdecl sub_10037220(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10037200(a1, a5);
  }
  else
  {
    result = sub_10037150(a1, a5);
  }
  return result;
}

//----- (10037260) --------------------------------------------------------
char __cdecl sub_10037260(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10014ED0(2, 363, a1);
}

//----- (10037280) --------------------------------------------------------
char __cdecl sub_10037280(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10038660(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (100373D0) --------------------------------------------------------
char __cdecl sub_100373D0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10037280(a5);
      else
        result = sub_10037260(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10037280(&unk_107182D0);
      else
        v7 = sub_10037260(&unk_107182D0);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_107182D0 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10037280(&unk_107182D0);
      else
        v9 = sub_10037260(&unk_107182D0);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_1071B1D8 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10037280(&unk_107182D0);
      else
        v11 = sub_10037260(&unk_107182D0);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_1071B6D8 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10037280(&unk_107182D0);
      else
        v13 = sub_10037260(&unk_107182D0);
      v14 = v13;
      memcpy_0(a5, &unk_1071B780, a6);
      result = v14;
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10037570) --------------------------------------------------------
char __cdecl sub_10037570(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100375B0) --------------------------------------------------------
__int16 __usercall sub_100375B0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100C1638[a1];
}
// 100C1638: using guessed type __int16 word_100C1638[];

//----- (100375C0) --------------------------------------------------------
char __cdecl sub_100375C0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_100375B0(a1);
    if ( sub_10014F00(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10037690) --------------------------------------------------------
char __cdecl sub_10037690(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10037570(a1);
  if ( a3 != 11 )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_100375C0(v7, a5);
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10037710) --------------------------------------------------------
char __cdecl sub_10037710(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_1000D9C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10014F00(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10014F00(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10016820((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1071B7A8, (char *)&v6 + 1, 0x20u);
      byte_1071B7A0 = 1;
      byte_1071B7A1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1071B7C8, (char *)&v6 + 1, 0x20u);
    byte_1071B7A1 = 1;
    byte_1071B7A2 = 1;
    return result;
  }
  return 0;
}
// 1071B7A0: using guessed type char byte_1071B7A0;
// 1071B7A1: using guessed type char byte_1071B7A1;
// 1071B7A2: using guessed type char byte_1071B7A2;

//----- (10037840) --------------------------------------------------------
char __cdecl sub_10037840(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_1002BE00(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_1000D9C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (100378C0) --------------------------------------------------------
bool __cdecl sub_100378C0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1071B7A0 == 0;
    qmemcpy(a1, &unk_1071B7A8, 0x40u);
    result = !v1 && byte_1071B7A2;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1071B7A0: using guessed type char byte_1071B7A0;
// 1071B7A2: using guessed type char byte_1071B7A2;

//----- (10037910) --------------------------------------------------------
char __cdecl sub_10037910(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_1000D9C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10016BB0(15);
    v3 = 555;
  }
  else
  {
    result = sub_10016BB0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1071B7A1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10014A00(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10039CC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1071B7A1: using guessed type char byte_1071B7A1;

//----- (100379F0) --------------------------------------------------------
__int16 __usercall sub_100379F0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100C1748[a1];
}
// 100C1748: using guessed type __int16 word_100C1748[];

//----- (10037A00) --------------------------------------------------------
char __cdecl sub_10037A00(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_100379F0(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10014A00(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10014B40(1, v3, 0xFFFFFFF);
}

//----- (10037A90) --------------------------------------------------------
char __cdecl sub_10037A90(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_1000D9C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1071B7A1 != 0 ? 25 : 11;
      sub_10037A00(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10037A00(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1071B7A1: using guessed type char byte_1071B7A1;

//----- (10037B50) --------------------------------------------------------
bool __cdecl sub_10037B50(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10037840(a1, (int)a5);
    return 1;
  }
  if ( byte_1071B7A1 )
  {
    if ( sub_10037710(a1, &v6, 1) )
    {
LABEL_14:
      byte_1071B7A3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1071B7A3 >= 5u )
    {
      byte_1071B7A0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10037710(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1071B7A3 >= 5u )
    {
      byte_1071B7A2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10037840(a1, (int)&v6);
    sub_10037910(a1, (int)&v6);
  }
  sub_10037A90(a1, 11);
  return sub_100378C0(a5);
}
// 10039CC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1071B7A0: using guessed type char byte_1071B7A0;
// 1071B7A1: using guessed type char byte_1071B7A1;
// 1071B7A2: using guessed type char byte_1071B7A2;
// 1071B7A3: using guessed type char byte_1071B7A3;

//----- (10037C50) --------------------------------------------------------
char __cdecl sub_10037C50(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_1000D9C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10037C90) --------------------------------------------------------
char __cdecl sub_10037C90(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10037CB0) --------------------------------------------------------
__int16 __cdecl sub_10037CB0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B2A2: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037CF0) --------------------------------------------------------
__int16 __cdecl sub_10037CF0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 10037CE0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10037D50) --------------------------------------------------------
__int16 __cdecl sub_10037D50(int a1, _DWORD *a2)
{
  int v2; // ecx@0
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  return sub_10037CF0(a1, a2, (_BYTE *)&v4 + 3);
}

//----- (10037D70) --------------------------------------------------------
int __cdecl sub_10037D70(int a1, float a2)
{
  return gdi_pvg_alpha_func(a1, LODWORD(a2));
}
// 1003B2AE: using guessed type int __cdecl gdi_pvg_alpha_func(_DWORD, _DWORD);

//----- (10037DB0) --------------------------------------------------------
int __cdecl sub_10037DB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 1003B2C0: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037E20) --------------------------------------------------------
int __cdecl sub_10037E20(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_color4f(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 1003B2D2: using guessed type int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037E80) --------------------------------------------------------
int __cdecl sub_10037E80(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 1003B2EA: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037F00) --------------------------------------------------------
int __cdecl sub_10037F00(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_frustum(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1003B302: using guessed type int __cdecl gdi_pvg_frustum(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037F50) --------------------------------------------------------
int sub_10037F50()
{
  gdi_pvg_init();
  return sub_10038220();
}
// 1003B30E: using guessed type int gdi_pvg_init(void);

//----- (10037F60) --------------------------------------------------------
int __cdecl sub_10037F60(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 1003B314: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (10037FB0) --------------------------------------------------------
int __cdecl sub_10037FB0(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1003B332: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038010) --------------------------------------------------------
int __cdecl sub_10038010(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_rotatef(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 1003B344: using guessed type int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038040) --------------------------------------------------------
int __cdecl sub_10038040(float a1, float a2, float a3)
{
  return gdi_pvg_scalef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1003B34A: using guessed type int __cdecl gdi_pvg_scalef(_DWORD, _DWORD, _DWORD);

//----- (10038080) --------------------------------------------------------
int __cdecl sub_10038080(float a1, float a2)
{
  return gdi_pvg_tex_coord2f(LODWORD(a1), LODWORD(a2));
}
// 1003B356: using guessed type int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD);

//----- (100380A0) --------------------------------------------------------
int __cdecl sub_100380A0(int a1, int a2, float a3)
{
  return gdi_pvg_tex_envf(a1, a2, LODWORD(a3));
}
// 1003B35C: using guessed type int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD);

//----- (100380C0) --------------------------------------------------------
int __cdecl sub_100380C0(int a1, char a2, char a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10)
{
  char v11; // [sp+0h] [bp-20h]@1
  char v12; // [sp+1h] [bp-1Fh]@1
  char v13; // [sp+2h] [bp-1Eh]@1

  v12 = a2;
  v13 = a3;
  v11 = a7;
  return gdi_pvg_tex_image_2d(&v11, *(_DWORD *)&v11, a8, a4, a10, a1, a9, a6, a5);
}
// 1003B362: using guessed type int __cdecl gdi_pvg_tex_image_2d(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038140) --------------------------------------------------------
int __cdecl sub_10038140(float a1, float a2, float a3)
{
  return gdi_pvg_translatef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1003B374: using guessed type int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD);

//----- (10038180) --------------------------------------------------------
int __cdecl sub_10038180(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 1003B380: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (100381A0) --------------------------------------------------------
int __cdecl sub_100381A0(float a1, float a2, float a3)
{
  return gdi_pvg_vertex3f(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1003B386: using guessed type int __cdecl gdi_pvg_vertex3f(_DWORD, _DWORD, _DWORD);

//----- (100381E0) --------------------------------------------------------
int __cdecl sub_100381E0(int a1, int a2, int a3)
{
  dword_1071C9BC = a1;
  dword_1071C9B0 = a2;
  dword_1071C9B4 = a3;
  return gdi_pvg_create_window(&dword_1071C9A8);
}
// 1003B392: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 1071C9A8: using guessed type int dword_1071C9A8;
// 1071C9B0: using guessed type int dword_1071C9B0;
// 1071C9B4: using guessed type int dword_1071C9B4;
// 1071C9BC: using guessed type int dword_1071C9BC;

//----- (10038220) --------------------------------------------------------
int sub_10038220()
{
  int result; // eax@1

  result = 0;
  dword_1071C9BC = 0;
  dword_1071C9B0 = 0;
  dword_1071C9B4 = 59;
  dword_1071C9A8 = 1;
  dword_1071C9AC = 0;
  dword_1071C9B8 = 0;
  return result;
}
// 1071C9A8: using guessed type int dword_1071C9A8;
// 1071C9AC: using guessed type int dword_1071C9AC;
// 1071C9B0: using guessed type int dword_1071C9B0;
// 1071C9B4: using guessed type int dword_1071C9B4;
// 1071C9B8: using guessed type int dword_1071C9B8;
// 1071C9BC: using guessed type int dword_1071C9BC;

//----- (10038270) --------------------------------------------------------
int __cdecl sub_10038270(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1071C9A8 = a1;
  return result;
}
// 1071C9A8: using guessed type int dword_1071C9A8;

//----- (10038280) --------------------------------------------------------
int __cdecl sub_10038280(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1071C9AC = a1;
  return result;
}
// 1071C9AC: using guessed type int dword_1071C9AC;

//----- (10038290) --------------------------------------------------------
int __cdecl sub_10038290(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1071C9B8 = a1;
  return result;
}
// 1071C9B8: using guessed type int dword_1071C9B8;

//----- (100382A0) --------------------------------------------------------
int __cdecl sub_100382A0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B39E: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (100382C0) --------------------------------------------------------
int sub_100382C0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3A4: using guessed type int TSK_pvg_get_id(void);

//----- (100382E0) --------------------------------------------------------
int __cdecl sub_100382E0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3AA: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10038310) --------------------------------------------------------
__int16 __cdecl sub_10038310(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3B0: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10038330) --------------------------------------------------------
int sub_10038330()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3B6: using guessed type int TSK_pvg_get_timer(void);

//----- (10038350) --------------------------------------------------------
int __cdecl sub_10038350(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3BC: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038390) --------------------------------------------------------
int __cdecl sub_10038390(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3C8: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100383C0) --------------------------------------------------------
int __cdecl sub_100383C0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3CE: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (100383E0) --------------------------------------------------------
int __cdecl sub_100383E0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3D4: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10038400) --------------------------------------------------------
int __cdecl sub_10038400(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3DA: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10038430) --------------------------------------------------------
int __cdecl sub_10038430(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3E0: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10038460) --------------------------------------------------------
int __cdecl sub_10038460(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3E6: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038490) --------------------------------------------------------
int __cdecl sub_10038490(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3EC: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (100384C0) --------------------------------------------------------
int __cdecl sub_100384C0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3F2: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (100384E0) --------------------------------------------------------
int __cdecl sub_100384E0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3F8: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10038500) --------------------------------------------------------
char __cdecl sub_10038500(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10038330();
  if ( sub_100383C0(a1) == 5 )
    goto LABEL_4;
  while ( sub_10038330() < v2 )
  {
    sub_100384E0(20);
    if ( sub_100383C0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_100383C0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10038570) --------------------------------------------------------
int __cdecl sub_10038570(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_100382C0();
    sub_10038350((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B3FE: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (100385B0) --------------------------------------------------------
int sub_100385B0()
{
  return sub_10038390(36, 0, 0, 0);
}

//----- (100385D0) --------------------------------------------------------
int __cdecl sub_100385D0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_100383E0(a2);
  return result;
}
// 100570B0: using guessed type void *tsk_app_hdr_ptr;

//----- (10038600) --------------------------------------------------------
int __cdecl sub_10038600(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10038400(a1, a2);
  return result;
}
// 100570B0: using guessed type void *tsk_app_hdr_ptr;

//----- (10038620) --------------------------------------------------------
int __cdecl sub_10038620(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100CD810[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100CD814[2 * v1];
}
// 100CD810: using guessed type int dword_100CD810[];
// 100CD814: using guessed type int dword_100CD814[];

//----- (10038660) --------------------------------------------------------
int __cdecl sub_10038660(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1003B404: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038680) --------------------------------------------------------
char __cdecl sub_10038680(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10038660(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_1000D9C0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (100386C0) --------------------------------------------------------
int __cdecl sub_100386C0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10038660(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10038700) --------------------------------------------------------
int __cdecl sub_10038700(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10038660(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10038730) --------------------------------------------------------
int __cdecl sub_10038730(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1003B40A: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038750) --------------------------------------------------------
int __cdecl sub_10038750(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10038730(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1003A020() )
  {
    v4 = sub_10038620(a1);
    if ( v4 != 42066 )
      v3 = sub_10038730(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1003A020: using guessed type int sub_1003A020(void);

//----- (100387B0) --------------------------------------------------------
int __cdecl sub_100387B0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10038750(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_1000D9C0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (100387F0) --------------------------------------------------------
int __cdecl sub_100387F0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10038660(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_10038730(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10038840) --------------------------------------------------------
int __cdecl sub_10038840(unsigned int a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0x8A )
  {
    if ( a1 < 0x8A && (unsigned __int8)sub_1003A040() )
      result = dword_1073B054 + 24 * a1;
    else
      result = 0;
  }
  return result;
}
// 1073B054: using guessed type int dword_1073B054;

//----- (10038860) --------------------------------------------------------
void sub_10038860()
{
  dword_10722240 = 0;
  dword_1073B054 = -15;
}
// 1073B054: using guessed type int dword_1073B054;

//----- (10038870) --------------------------------------------------------
signed int __fastcall sub_10038870(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (100388C0) --------------------------------------------------------
char __usercall sub_100388C0@<al>(int a1@<eax>, char *a2@<ecx>, unsigned int a3)
{
  unsigned int v3; // ebx@1
  unsigned int v4; // edi@1
  char *v5; // esi@1
  unsigned __int8 v6; // al@3
  bool v7; // zf@3
  unsigned int v8; // eax@5
  signed int v9; // eax@8
  int v10; // edx@8
  char result; // al@11
  unsigned __int8 v12; // [sp+13h] [bp-5h]@2
  int v13; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(a1 + 12) * *(_WORD *)(a1 + 14);
  v4 = 0;
  v5 = a2;
  if ( v3 )
  {
    while ( sub_10039460(a3, &v12, 1) == 1 )
    {
      v6 = (v12 & 0x7F) + 1;
      v7 = v12 >> 7 == 1;
      v12 = (v12 & 0x7F) + 1;
      if ( v7 )
      {
        if ( sub_10039460(a3, &v13, 4) != 4 )
          break;
        v8 = 0;
        if ( v12 )
        {
          do
          {
            *(_DWORD *)v5 = v13;
            ++v8;
            v5 += 4;
            ++v4;
          }
          while ( v8 < v12 );
        }
      }
      else
      {
        v9 = sub_10039460(a3, v5, 4 * v6);
        v10 = 4 * v12;
        if ( v9 != v10 )
          break;
        v5 += v10;
        v4 += v12;
      }
      if ( v4 >= v3 )
        goto LABEL_11;
    }
    result = 0;
  }
  else
  {
LABEL_11:
    result = 1;
  }
  return result;
}

//----- (10038990) --------------------------------------------------------
int __usercall sub_10038990@<eax>(unsigned int a1@<eax>)
{
  return sub_1003A050(a1);
}

//----- (100389A0) --------------------------------------------------------
int __cdecl sub_100389A0(int a1, int a2, char *a3)
{
  int result; // eax@4
  int v4; // [sp+4h] [bp-34h]@5
  int v5; // [sp+8h] [bp-30h]@5
  __int16 v6; // [sp+Ch] [bp-2Ch]@5
  int v7; // [sp+14h] [bp-24h]@5
  __int16 v8; // [sp+18h] [bp-20h]@5
  void *v9; // [sp+1Ch] [bp-1Ch]@5
  int v10; // [sp+20h] [bp-18h]@5
  void *v11; // [sp+24h] [bp-14h]@5
  int v12; // [sp+28h] [bp-10h]@5
  int v13; // [sp+2Ch] [bp-Ch]@5
  char v14; // [sp+30h] [bp-8h]@5
  int v15; // [sp+34h] [bp-4h]@5

  if ( dword_10722240 )
    sub_100104D0(dword_10722240);
  dword_10722240 = &unk_107221C0;
  memset(&unk_107221C0, 0, 0x80u);
  memset(&unk_10722248, 0, 0x2E0u);
  if ( sub_10010530(a1, 4, &unk_107221C0, a2) )
  {
    dword_10722240 = 0;
    result = 0;
  }
  else
  {
    memset(&v4, 0, 0x34u);
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = &unk_1072DC70;
    v10 = 1024;
    v11 = &unk_10722528;
    v12 = 46920;
    v13 = 15;
    v14 = -2;
    v15 = 0xFFFF;
    result = sub_100114F0((int)dword_10722240, a3, 4, &unk_10722248, (int)&v4);
  }
  return result;
}

//----- (10038A90) --------------------------------------------------------
int __usercall sub_10038A90@<eax>(_BYTE *a1@<eax>, signed int a2@<ecx>, signed int a3, int a4, int a5, _BYTE *a6)
{
  int v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edx@1
  int result; // eax@1
  _BYTE *v10; // ecx@1
  _BYTE *v11; // edi@1
  _BYTE *v12; // ebx@1
  __int64 v13; // rax@7
  bool v14; // zf@7
  int v15; // [sp+10h] [bp-Ch]@2
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  int v18; // [sp+20h] [bp+4h]@1
  int v19; // [sp+20h] [bp+4h]@6
  _BYTE *v20; // [sp+24h] [bp+8h]@1
  int v21; // [sp+2Ch] [bp+10h]@4

  v6 = a5 * a4;
  v7 = a1;
  v16 = a2 / 2;
  v8 = a2 * a5 * a4;
  v18 = a3 / 2;
  v20 = a6;
  result = v18;
  v10 = &v7[v8];
  v17 = v8;
  v11 = &v7[v6];
  v12 = &v7[v8] + v6;
  if ( v18 > 0 )
  {
    v15 = v18;
    do
    {
      result = v16;
      if ( v16 > 0 )
      {
        v21 = v16;
        do
        {
          result = a5;
          if ( a5 > 0 )
          {
            v19 = a5;
            do
            {
              v13 = *v7 + *v11 + *v10 + *v12;
              *v20 = (signed int)(v13 + (BYTE4(v13) & 3)) >> 2;
              result = (int)(v20 + 1);
              ++v7;
              ++v11;
              ++v10;
              ++v12;
              v14 = v19-- == 1;
              ++v20;
            }
            while ( !v14 );
            v8 = v17;
          }
          v7 += v6;
          v11 += v6;
          v10 += v6;
          v12 += v6;
          --v21;
        }
        while ( v21 );
      }
      v7 += v8;
      v11 += v8;
      v10 += v8;
      v12 += v8;
      --v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (10038B70) --------------------------------------------------------
_BYTE *__cdecl sub_10038B70(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  _BYTE *result; // eax@1
  signed int v8; // esi@5
  signed int v9; // edi@6
  int v10; // ebp@8
  int v11; // [sp+0h] [bp-4h]@3

  result = (_BYTE *)(a5 - 58);
  if ( a5 == 58 )
  {
    v11 = 1;
  }
  else
  {
    result = (_BYTE *)(a5 - 59);
    if ( a5 != 59 )
      return result;
    v11 = 4;
  }
  v8 = a3;
  if ( a3 <= 2048 )
  {
    v9 = a4;
    if ( a4 <= 2048 )
    {
      result = (_BYTE *)(a4 / 2);
      if ( (unsigned int)(v11 * a4 / 2 * (a3 / 2)) <= 0x100000 )
      {
        v10 = 0;
        sub_100380C0(a1, 0, 0, a2, a3, a4, 0, a5, a6, a7);
        result = (_BYTE *)a7;
        while ( v8 > 1 || v9 > 1 )
        {
          sub_10038A90(result, v8, v9, 1, v11, &unk_103F9620);
          v8 /= 2;
          v9 /= 2;
          if ( v8 < 1 )
            v8 = 1;
          if ( v9 < 1 )
            v9 = 1;
          sub_100380C0(a1, ++v10, 0, a2, v8, v9, 0, a5, a6, (int)&unk_103F9620);
          result = &unk_103F9620;
        }
      }
    }
  }
  return result;
}

//----- (10038C80) --------------------------------------------------------
double __cdecl sub_10038C80(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_103F9620;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_10038870((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_10038990(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_10038660(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_103F9620, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 10038130: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (10038E20) --------------------------------------------------------
double __cdecl sub_10038E20(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_10038990(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (10038E80) --------------------------------------------------------
unsigned int __cdecl sub_10038E80(char *a1)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // esi@2
  unsigned int result; // eax@3
  int v5; // [sp+10h] [bp-10h]@1
  const char *v6; // [sp+14h] [bp-Ch]@1
  int v7; // [sp+18h] [bp-8h]@1
  const char *v8; // [sp+1Ch] [bp-4h]@1

  v5 = (int)"/mnt/sys_nand0/sys_files.gca";
  v6 = "/mnt/sys_nand0/arfrm_imgs.zip";
  v7 = (int)"GarminSplashDontGiveOut*$&)aslkd932(lkasdf93023";
  v8 = "gARMIN system DONT give out PWD *&(AS;L238%))+,.023";
  v1 = 0;
LABEL_2:
  v2 = *(&v5 + v1);
  v3 = 0;
  while ( 1 )
  {
    result = sub_100389A0(v2, *(&v7 + v3), a1);
    if ( result < 0xFFFFFFC2 )
    {
      if ( result )
        return result;
    }
    if ( (unsigned int)++v3 >= 2 )
    {
      if ( (unsigned int)++v1 < 2 )
        goto LABEL_2;
      return 0;
    }
  }
}

//----- (10038EF0) --------------------------------------------------------
char __cdecl sub_10038EF0(char *a1)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@1
  char result; // al@3
  int v4; // esi@16
  char v5; // al@16
  int v6; // edi@16
  unsigned int v7; // ebp@18
  unsigned int v8; // eax@19
  int *v9; // [sp+4h] [bp-90h]@9
  unsigned int v10; // [sp+8h] [bp-8Ch]@1
  char v11; // [sp+Ch] [bp-88h]@18
  unsigned int v12; // [sp+10h] [bp-84h]@18
  int v13; // [sp+14h] [bp-80h]@4
  int v14; // [sp+18h] [bp-7Ch]@5
  int v15; // [sp+1Ch] [bp-78h]@6
  int v16; // [sp+20h] [bp-74h]@16
  int v17; // [sp+24h] [bp-70h]@16
  char v18; // [sp+30h] [bp-64h]@16
  int v19; // [sp+64h] [bp-30h]@7
  int v20; // [sp+68h] [bp-2Ch]@8

  v1 = sub_10038E80(a1);
  v2 = v1;
  v10 = v1;
  if ( v1 >= 0xFFFFFFC2 || !v1 )
  {
    sub_1000D9C0("..\\lib\\adl\\gdi_usr_util.c", 713, 0, 0);
    return 0;
  }
  sub_10039460(v1, &v13, 128);
  if ( v13 != 542327876 || v14 != 124 || (v15 & 0x1001) != 4097 )
    goto LABEL_26;
  if ( v19 & 4 && v20 == 827611204 )
  {
    v9 = (int *)&unk_100CB030;
    goto LABEL_16;
  }
  if ( !(v19 & 4) )
    goto LABEL_26;
  if ( v20 == 861165636 )
  {
    v9 = (int *)&unk_100CB034;
    goto LABEL_16;
  }
  if ( !(v19 & 4) || v20 != 894720068 )
  {
LABEL_26:
    sub_10039360(v2);
    return 0;
  }
  v9 = (int *)&unk_100CB038;
LABEL_16:
  v4 = v17;
  v5 = v18;
  v6 = v16;
  if ( !(v15 & 0x20000) )
    v5 = 1;
  v11 = v5;
  v7 = 0;
  v12 = (unsigned __int8)v5;
  if ( v5 )
  {
    while ( 1 )
    {
      v8 = 8 * (v4 + 3) / 4 * (v6 + 3) / 4 * ((*v9 != 60) + 1);
      if ( v8 > 0x100000 )
        break;
      sub_10039460(v10, &unk_103F9620, v8);
      sub_100380C0(34, v7++, v11, *v9, v4, v6, 0, *v9, 15, (int)&unk_103F9620);
      v4 = (unsigned int)(v4 + 1) >> 1;
      v6 = (unsigned int)(v6 + 1) >> 1;
      if ( v7 >= v12 )
        goto LABEL_21;
    }
    sub_10039360(v10);
    result = 0;
  }
  else
  {
LABEL_21:
    sub_10039360(v10);
    result = 1;
  }
  return result;
}

//----- (100390D0) --------------------------------------------------------
bool __cdecl sub_100390D0(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  bool result; // al@3
  int v7; // ecx@14
  int v8; // ebx@16
  unsigned int v9; // esi@29
  int v10; // edi@29
  char *v11; // ebp@32
  char v12; // [sp+2h] [bp-1Eh]@4
  char v13; // [sp+3h] [bp-1Dh]@4
  unsigned int v14; // [sp+4h] [bp-1Ch]@1
  char v15; // [sp+8h] [bp-18h]@4
  char v16; // [sp+9h] [bp-17h]@5
  char v17; // [sp+Ah] [bp-16h]@7
  unsigned __int16 v18; // [sp+14h] [bp-Ch]@15
  unsigned __int16 v19; // [sp+16h] [bp-Ah]@17
  unsigned __int8 v20; // [sp+18h] [bp-8h]@12

  v5 = sub_10038E80(a1);
  v14 = v5;
  if ( v5 >= 0xFFFFFFC2 || !v5 )
    return 0;
  sub_10039460(v5, &v15, 18);
  v12 = 0;
  v13 = 0;
  if ( v15 || v16 )
    v12 = 1;
  if ( v17 == 2 )
  {
    v13 = 0;
  }
  else if ( v17 == 10 )
  {
    v13 = 1;
  }
  else
  {
    v12 = 1;
  }
  if ( v20 != 32 )
    v12 = 1;
  v7 = a4;
  if ( !a4 )
  {
    a4 = v18;
    v7 = v18;
  }
  v8 = a5;
  if ( !a5 )
  {
    a5 = v19;
    v8 = v19;
  }
  if ( a2 < 0 || a3 < 0 || a2 + v7 > v18 || v8 + a3 > v19 )
    v12 = 1;
  if ( v13 && (a2 || a3 || v7 != v18 || v8 != v19) )
    v12 = 1;
  v9 = (unsigned int)v20 >> 3;
  v10 = v7 * v9;
  if ( (signed int)(v8 * v7 * v9) > 0x100000 )
    goto LABEL_41;
  if ( !v12 )
  {
    if ( !v13 )
    {
      sub_100396D0(v14, v9 * (a2 + a3 * v18), 1);
      v11 = (char *)&unk_103F9620;
      if ( v8 > 0 )
      {
        do
        {
          if ( sub_10039460(v14, v11, v10) != v10 )
            v12 = 1;
          sub_100396D0(v14, v9 * (v18 - a4), 1);
          v11 += v10;
          --v8;
        }
        while ( v8 );
        if ( v12 )
          goto LABEL_39;
        v8 = a5;
      }
      goto LABEL_38;
    }
    if ( sub_100388C0((int)&v15, (char *)&unk_103F9620, v14) )
    {
LABEL_38:
      sub_10038B70(34, 59, a4, v8, 59, 15, (int)&unk_103F9620);
      goto LABEL_39;
    }
LABEL_41:
    v12 = 1;
  }
LABEL_39:
  sub_10039360(v14);
  sub_100104D0(dword_10722240);
  result = v12 == 0;
  dword_10722240 = 0;
  return result;
}

//----- (10039310) --------------------------------------------------------
char __cdecl sub_10039310(char *a1)
{
  char result; // al@2

  if ( strstr(a1, ".dds") )
    result = sub_10038EF0(a1);
  else
    result = sub_100390D0(a1, 0, 0, 0, 0);
  return result;
}

//----- (10039360) --------------------------------------------------------
signed int __cdecl sub_10039360(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_1000D380(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_1073B0D8 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_1073B0E0[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_1073B0D8 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_1003A0B0(
        v2,
        *(_DWORD *)(dword_1073B0E0[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_10039360(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 1003B416: using guessed type int FIL_vfs_close(void);
// 1073B0D8: using guessed type int dword_1073B0D8;
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (100393A0) --------------------------------------------------------
signed int __cdecl sub_100393A0(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_10039360(a1);
  else
    result = -6;
  return result;
}

//----- (100393F0) --------------------------------------------------------
int __cdecl sub_100393F0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1003B42E: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039460) --------------------------------------------------------
signed int __cdecl sub_10039460(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_1000F8D0(a1);
    return sub_10011300(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_100396D0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1003A450(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1003B440: using guessed type int FIL_vfs_read(void);

//----- (100394B0) --------------------------------------------------------
signed int __cdecl sub_100394B0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_1000D3E0(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1003A450(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1003B44C: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039540) --------------------------------------------------------
signed int __cdecl sub_10039540(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_1000D440(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1003B458: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039590) --------------------------------------------------------
__int64 __cdecl sub_10039590(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1003B45E: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100395B0) --------------------------------------------------------
int __cdecl sub_100395B0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1003B464: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100395E0) --------------------------------------------------------
int __cdecl sub_100395E0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1003B470: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039600) --------------------------------------------------------
char __cdecl sub_10039600(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 772, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10039360(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10039630) --------------------------------------------------------
char __cdecl sub_10039630(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10039360(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10039660) --------------------------------------------------------
int __cdecl sub_10039660(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@3
  unsigned int v4; // ST00_4@4

  v2 = a2;
  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1;
    a1 = a2;
    result = j_FIL_vfs_ioctl(v4, 106, &a1, 4);
    if ( !result )
      return result;
  }
  else
  {
    result = -6;
  }
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  return result;
}
// 100393E0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100396B0) --------------------------------------------------------
int __cdecl sub_100396B0(int a1, int a2, int a3)
{
  return j_FIL_vfs_read_dir_cnt(a1, a2, a3, -1);
}
// 100394A0: using guessed type int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100396D0) --------------------------------------------------------
signed int __cdecl sub_100396D0(unsigned int a1, int a2, int a3)
{
  return sub_10039540(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (100396F0) --------------------------------------------------------
int __cdecl sub_100396F0(int a1, int a2, int a3)
{
  return sub_100395B0(a1, a2, a3);
}

//----- (10039710) --------------------------------------------------------
int __cdecl sub_10039710(int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int v3; // edi@1

  v2 = j_FIL_vfs_open(a1, 4, 0);
  v3 = sub_10039660(v2, a2);
  sub_100393A0(v2);
  return v3;
}
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10039740) --------------------------------------------------------
void __cdecl sub_10039740(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1003A5A0(a1, a2);
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B476: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10039770) --------------------------------------------------------
int __cdecl sub_10039770(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B47C: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10039790) --------------------------------------------------------
int __cdecl sub_10039790(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1003A5D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100397F0) --------------------------------------------------------
int __usercall sub_100397F0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100396D0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_100396F0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10039790((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10038330();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10039460(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100395E0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10039360(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10039360(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10039440: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10039450: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10039530: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (10039AF0) --------------------------------------------------------
int __usercall sub_10039AF0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1003A5D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10039B10) --------------------------------------------------------
signed int __cdecl sub_10039B10(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_1000D9C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10038600(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_100385D0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_10039AF0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_100397F0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_100385D0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (10039C00) --------------------------------------------------------
unsigned int __cdecl sub_10039C00(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@2
  int v6; // edx@4
  int v7; // ecx@4
  unsigned int v8; // ecx@4
  unsigned int v9; // [sp+4h] [bp-8h]@1
  unsigned int v10; // [sp+8h] [bp-4h]@1

  result = 0;
  v4 = -1;
  v10 = 0;
  v9 = 0;
  if ( a3 )
  {
    v5 = a2 + 1;
    do
    {
      if ( !v4 )
        break;
      v6 = *(_BYTE *)(v5 + 1) - BYTE2(a1);
      v7 = *(_BYTE *)(v5 - 1) - (unsigned __int8)a1;
      v8 = v6 * v6 + (*(_BYTE *)v5 - BYTE1(a1)) * (*(_BYTE *)v5 - BYTE1(a1)) + v7 * v7;
      if ( v8 >= v4 )
      {
        result = v10;
      }
      else
      {
        result = v9;
        v4 = v8;
        v10 = v9;
      }
      v5 += 4;
      ++v9;
    }
    while ( v9 < a3 );
  }
  return result;
}

//----- (10039CD0) --------------------------------------------------------
unsigned int __cdecl sub_10039CD0(int a1, unsigned int a2)
{
  unsigned int v2; // edi@1
  int v3; // esi@1

  v2 = 0;
  v3 = a1 + 1;
  do
  {
    if ( v2 >= a2 )
      break;
    *(_BYTE *)(v3 + 2) = 0;
    j_HWM_pvg_get_rgb(v2++, v3 + 1, v3, v3 - 1);
    v3 += 4;
  }
  while ( v2 < 0x100 );
  return v2;
}
// 10039C90: using guessed type int __cdecl j_HWM_pvg_get_rgb(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039D50) --------------------------------------------------------
int __cdecl sub_10039D50(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B4B8: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10039DA0) --------------------------------------------------------
int __cdecl sub_10039DA0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1003B28A: using guessed type int SYS_exit_krnl(void);
// 1003B296: using guessed type int SYS_enter_krnl(void);
// 1003B4BE: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10039E10) --------------------------------------------------------
int __cdecl sub_10039E10(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FF0(v1);
  a1 = v2;
  v3 = sub_10015280(&a1, 4u, (int)&unk_100CBB68, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100CBB6C[2 * v3];
}
// 100CBB6C: using guessed type int dword_100CBB6C[];

//----- (10039E50) --------------------------------------------------------
int __cdecl sub_10039E50(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FF0(v1);
  a1 = v2;
  v3 = sub_10015280(&a1, 4u, (int)&unk_100CBBA0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100CBBA4[2 * v3];
}
// 100CBBA4: using guessed type int dword_100CBBA4[];

//----- (10039E90) --------------------------------------------------------
int __cdecl sub_10039E90(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FF0(v1);
  a1 = v2;
  v3 = sub_10015280(&a1, 4u, (int)&unk_100CBBD8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100CBBDC[2 * v3];
}
// 100CBBDC: using guessed type int dword_100CBBDC[];

//----- (10039ED0) --------------------------------------------------------
int __cdecl sub_10039ED0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FF0(v1);
  a1 = v2;
  v3 = sub_10015280(&a1, 4u, (int)&unk_100CBC10, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100CBC14[2 * v3];
}
// 100CBC14: using guessed type int dword_100CBC14[];

//----- (10039F10) --------------------------------------------------------
int __cdecl sub_10039F10(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10039E50(a4);
    result = sub_10038660(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10038660(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10039E10(a4);
      result = sub_10038660(v6, a3, 6);
    }
  }
  return result;
}

//----- (10039F80) --------------------------------------------------------
int __cdecl sub_10039F80(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10039ED0(a3);
    result = sub_10038660(v4, a1, 64);
    if ( result == -7 )
    {
      sub_100384E0(100);
      v5 = sub_10039ED0(a3);
      result = sub_10038660(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10039E90(a3);
    result = sub_10038660(v6, a2, 8);
    if ( result == -7 )
    {
      sub_100384E0(100);
      v7 = sub_10039E90(a3);
      result = sub_10038660(v7, a2, 8);
    }
  }
  return result;
}

//----- (1003A040) --------------------------------------------------------
signed int sub_1003A040()
{
  return sub_10039B10((int)&off_100CDE80);
}
// 100CDE80: using guessed type char *off_100CDE80;

//----- (1003A050) --------------------------------------------------------
int __cdecl sub_1003A050(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_1003A040() )
    result = 8216 * a1 + dword_1073B054 + 3312;
  else
    result = 0;
  return result;
}
// 1073B054: using guessed type int dword_1073B054;

//----- (1003A0B0) --------------------------------------------------------
unsigned int __cdecl sub_1003A0B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1073B0E0[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1073B098[a1];
  dword_1073B098[a1] = a3 + v9;
  dword_1073B058[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1073B058[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1073B098: using guessed type int dword_1073B098[];
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (1003A260) --------------------------------------------------------
int __usercall sub_1003A260@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1073B0E0[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1073B0E0[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (1003A310) --------------------------------------------------------
int __cdecl sub_1003A310(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1003A260(a1);
  v3 = &dword_1073B0E0[a1];
  v4 = sub_100394B0(
         *(_DWORD *)dword_1073B0E0[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1073B0E0[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1073B098[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1073B098: using guessed type int dword_1073B098[];
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (1003A3C0) --------------------------------------------------------
int __usercall sub_1003A3C0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1073B0E0[a1];
  v3 = (int *)(dword_1073B098[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1073B0E0[a1] + 32)) % *(_WORD *)(dword_1073B0E0[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1003A310(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1073B098: using guessed type int dword_1073B098[];
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (1003A450) --------------------------------------------------------
unsigned int __cdecl sub_1003A450(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1073B0D8 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1073B0E0[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1073B0D8 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10038400(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1073B0E0[v6] + 28);
        v12 = sub_1003A3C0(v6, (unsigned int)v7 & *(_DWORD *)(dword_1073B0E0[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1073B0E0[v6] + 4) != 138 )
        sub_100383E0(*(_DWORD *)(dword_1073B0E0[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1073B0E0[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_100383E0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1073B0D8: using guessed type int dword_1073B0D8;
// 1073B0E0: using guessed type int dword_1073B0E0[];

//----- (1003A5A0) --------------------------------------------------------
void __cdecl sub_1003A5A0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1000E730(v2) && sub_1000E770(v3) != 1 )
    *a2 = 0;
}

//----- (1003A5E0) --------------------------------------------------------
_WORD *__cdecl sub_1003A5E0(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1003A640) --------------------------------------------------------
int __cdecl sub_1003A640(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1003A730(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1003A730) --------------------------------------------------------
int __cdecl sub_1003A730(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1003A840) --------------------------------------------------------
int __cdecl sub_1003A840(char a1, void *a2, size_t a3, int a4)
{
  int result; // eax@1

  result = sub_10007B90(a1, a2, a3, *(_DWORD *)a4);
  if ( !result )
    *(_DWORD *)a4 += a3;
  return result;
}

//----- (1003A870) --------------------------------------------------------
int __usercall sub_1003A870@<eax>(int a1@<esi>)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 152;
  result = sub_1003A840(1, (void *)a1, 0x14u, (int)&v2);
  if ( !result )
  {
    result = 4;
    if ( *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 12) )
        result = 0;
    }
  }
  return result;
}

//----- (1003A8B0) --------------------------------------------------------
int __cdecl sub_1003A8B0(_WORD *a1, _DWORD *a2)
{
  _WORD *v2; // edi@1
  _DWORD *v3; // esi@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-Ch]@5
  __int16 v6; // [sp+Ch] [bp-8h]@7
  int v7; // [sp+Eh] [bp-6h]@9

  v2 = a1;
  if ( a1 )
    *a1 = 0;
  v3 = a2;
  if ( a2 )
    *a2 = 0;
  a1 = (_WORD *)152;
  result = sub_1003A840(2, &v5, 0xAu, (int)&a1);
  if ( !result )
  {
    if ( v2 )
      *v2 = v6;
    if ( v3 )
      *v3 = v7;
  }
  return result;
}

//----- (1003A910) --------------------------------------------------------
int __cdecl sub_1003A910(char a1, void *a2, size_t a3, int a4, size_t a5, int a6, size_t a7, int a8, size_t a9, int a10, int a11, int a12, size_t a13)
{
  int result; // eax@4
  const char *v14; // ebp@6
  char v15; // dl@9
  __int16 v16; // ax@9
  char v17; // dl@14
  __int16 v18; // ax@14
  int v19; // [sp+10h] [bp-298h]@5
  void *v20; // [sp+14h] [bp-294h]@1
  void *v21; // [sp+18h] [bp-290h]@1
  void *v22; // [sp+1Ch] [bp-28Ch]@1
  void *v23; // [sp+20h] [bp-288h]@1
  int v24; // [sp+24h] [bp-284h]@5
  int v25; // [sp+28h] [bp-280h]@8
  int v26; // [sp+2Ch] [bp-27Ch]@19
  char v27; // [sp+30h] [bp-278h]@6
  char v28; // [sp+43h] [bp-265h]@6
  char v29; // [sp+44h] [bp-264h]@6
  char v30; // [sp+6Bh] [bp-23Dh]@6
  char v31; // [sp+6Ch] [bp-23Ch]@6
  char v32; // [sp+8Bh] [bp-21Dh]@6
  char v33; // [sp+9Ah] [bp-20Eh]@6
  char v34; // [sp+9Fh] [bp-209h]@6
  int v35; // [sp+A6h] [bp-202h]@11
  int v36; // [sp+AAh] [bp-1FEh]@13
  char v37; // [sp+B0h] [bp-1F8h]@19
  char v38; // [sp+B8h] [bp-1F0h]@20

  v21 = (void *)a6;
  v23 = (void *)a4;
  v22 = (void *)a8;
  v20 = (void *)a12;
  memset(a2, 0, a3);
  memset((void *)a4, 0, a5);
  memset((void *)a6, 0, a7);
  memset((void *)a8, 0, a9);
  memset((void *)a12, 0, a13);
  *(_BYTE *)(a10 + 1) = 0;
  *(_BYTE *)a10 = 0;
  *(_WORD *)(a10 + 2) = 0;
  *(_BYTE *)(a11 + 1) = 0;
  *(_BYTE *)a11 = 0;
  *(_WORD *)(a11 + 2) = 0;
  if ( a1 && a1 != 1 && a1 != 2 )
  {
    result = 4;
  }
  else
  {
    v19 = 16;
    v19 = sub_1003A840(a1, &v24, 0x88u, (int)&v19);
    if ( !v19 )
    {
      v32 = 0;
      v34 = 0;
      v28 = 0;
      v30 = 0;
      sub_1000D560((int)a2, &v31, a3);
      v14 = (const char *)v23;
      sub_1000D560((int)v23, &v33, a5);
      sub_1000D560((int)v21, &v27, a7);
      sub_1000D560((int)v22, &v29, a9);
      if ( (unsigned __int16)(v24 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v24) - 1) <= 0xBu
        && (unsigned __int16)(v25 - 1990) <= 0x6Eu )
      {
        v15 = BYTE2(v24);
        v16 = v25;
        *(_BYTE *)(a10 + 1) = v24;
        *(_BYTE *)a10 = v15;
        *(_WORD *)(a10 + 2) = v16;
      }
      if ( a1 == 1
        && (unsigned __int16)(v35 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v35) - 1) <= 0xBu
        && (unsigned __int16)(v36 - 1990) <= 0x6Eu )
      {
        v17 = BYTE2(v35);
        v18 = v36;
        *(_BYTE *)(a11 + 1) = v35;
        *(_BYTE *)a11 = v17;
        *(_WORD *)(a11 + 2) = v18;
      }
      sub_1000D560((int)v20, "____", a13);
      if ( !memcmp(v14, "2.00", 5u) )
      {
        if ( (unsigned __int8)a1 < 3u )
          sub_1000D560((int)v20, off_100CE8A0[(unsigned __int8)a1], a13);
      }
      else if ( memcmp(v14, "2.01", 5) >= 0 )
      {
        v19 = v26 - 501;
        v19 = sub_1003A840(a1, &v37, 0x1F4u, (int)&v19);
        if ( !v19 )
          sub_1000D560((int)v20, &v38, a13);
      }
    }
    result = v19;
  }
  return result;
}
// 100CE8A0: using guessed type char *off_100CE8A0[3];

//----- (1003AC20) --------------------------------------------------------
int __cdecl sub_1003AC20(int a1, void *a2)
{
  int result; // eax@2

  if ( (unsigned __int8)a1 >= 1u )
  {
    a1 = 28 * ((unsigned __int8)a1 - 1) + 156;
    result = sub_1003A840(0, a2, 0x1Cu, (int)&a1);
  }
  else
  {
    result = 9;
  }
  return result;
}

//----- (1003AC60) --------------------------------------------------------
int __cdecl sub_1003AC60(int a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+0h] [bp-1Ch]@1

  result = sub_1003AC20(a1, &v3);
  *a2 = v3;
  return result;
}

//----- (1003AC80) --------------------------------------------------------
char __cdecl sub_1003AC80(_DWORD *a1, _WORD *a2, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // ecx@1
  char result; // al@3

  v3 = sub_1003A8B0(a2, a1);
  v4 = sub_1003AC60(1, a3);
  if ( v4 || v3 )
  {
    result = 2;
    if ( v3 )
    {
      result = 1;
      if ( v4 )
        result = 0;
    }
  }
  else
  {
    result = 3;
    if ( *a3 >= *a1 )
    {
      result = 4;
      if ( *a3 > *a1 )
        result = 5;
    }
  }
  return result;
}

//----- (1003ACE0) --------------------------------------------------------
char sub_1003ACE0()
{
  int v0; // edi@1
  int v1; // ebp@1
  int v2; // eax@1
  int v4; // [sp+10h] [bp-18h]@1
  char v5; // [sp+14h] [bp-14h]@1
  __int16 v6; // [sp+24h] [bp-4h]@2

  word_1077AE9E = 0;
  word_1077AEA0 = 0;
  word_1077AEA4 = 0;
  memset(&unk_1073B124, 0, 0x2Cu);
  byte_1073B150 = 0;
  v4 = 152;
  v0 = sub_1003A840(2, &word_1077AEA0, 2u, (int)&v4);
  v4 = 152;
  v1 = sub_1003A840(0, &word_1077AEA4, 2u, (int)&v4);
  v2 = sub_1003A870((int)&v5);
  if ( v2 )
    byte_1077AE9C = 7;
  else
    word_1077AE9E = v6;
  if ( v0 || v2 || v1 )
  {
    byte_1077AEA2 = 0;
    byte_1077AEA6 = 0;
  }
  else
  {
    LOBYTE(v2) = 1;
    byte_1077AEA2 = 1;
    byte_1077AEA6 = 1;
  }
  return v2;
}
// 1073B150: using guessed type char byte_1073B150;
// 1077AE9C: using guessed type char byte_1077AE9C;
// 1077AE9E: using guessed type __int16 word_1077AE9E;
// 1077AEA0: using guessed type __int16 word_1077AEA0;
// 1077AEA2: using guessed type char byte_1077AEA2;
// 1077AEA4: using guessed type __int16 word_1077AEA4;
// 1077AEA6: using guessed type char byte_1077AEA6;

//----- (1003ADA0) --------------------------------------------------------
void *sub_1003ADA0()
{
  void *v0; // esi@1
  signed int v1; // edi@1
  void *result; // eax@3

  byte_1077AE9C = 1;
  byte_1077AEA2 = 1;
  word_1077AEA4 = 0;
  word_1077AEA0 = 0;
  word_1077AE9E = 0;
  byte_1077AEA6 = 0;
  sub_1003ACE0();
  sub_1003ADD0((int)&unk_1073B188, 80, 80);
  sub_1003AE20();
  sub_1003ADD0((int)&unk_107454C4, 60, 60);
  memset(&unk_10745498, 0, 0x2Cu);
  dword_107470E4 = 0;
  dword_107470E8 = 0;
  dword_107470EC = 0;
  dword_107470F0 = 0;
  dword_107470F4 = 0;
  dword_107470F8 = 0;
  dword_107470FC = 0;
  dword_10747100 = 0;
  dword_10747104 = 0;
  dword_10747108 = 0;
  dword_1074710C = 0;
  dword_10747110 = 0;
  dword_1074711C = -536868000;
  dword_10747120 = -1073736000;
  dword_10747114 = 536868000;
  dword_10747118 = 1073736000;
  memset(&unk_1073E398, 0, 0x2Cu);
  v0 = &unk_1073E3C4;
  v1 = 4;
  do
  {
    sub_1003ADD0((int)v0, 60, 60);
    v0 = (char *)v0 + 7200;
    --v1;
  }
  while ( v1 );
  result = memset(&unk_10745444, 0, 0x50u);
  dword_10745494 = 0;
  return result;
}
// 10745494: using guessed type int dword_10745494;
// 107470E4: using guessed type int dword_107470E4;
// 107470E8: using guessed type int dword_107470E8;
// 107470EC: using guessed type int dword_107470EC;
// 107470F0: using guessed type int dword_107470F0;
// 107470F4: using guessed type int dword_107470F4;
// 107470F8: using guessed type int dword_107470F8;
// 107470FC: using guessed type int dword_107470FC;
// 10747100: using guessed type int dword_10747100;
// 10747104: using guessed type int dword_10747104;
// 10747108: using guessed type int dword_10747108;
// 1074710C: using guessed type int dword_1074710C;
// 10747110: using guessed type int dword_10747110;
// 10747114: using guessed type int dword_10747114;
// 10747118: using guessed type int dword_10747118;
// 1074711C: using guessed type int dword_1074711C;
// 10747120: using guessed type int dword_10747120;
// 1077AE9C: using guessed type char byte_1077AE9C;
// 1077AE9E: using guessed type __int16 word_1077AE9E;
// 1077AEA0: using guessed type __int16 word_1077AEA0;
// 1077AEA2: using guessed type char byte_1077AEA2;
// 1077AEA4: using guessed type __int16 word_1077AEA4;
// 1077AEA6: using guessed type char byte_1077AEA6;

//----- (1003ADD0) --------------------------------------------------------
void __cdecl sub_1003ADD0(int a1, signed int a2, signed int a3)
{
  int v3; // ebx@1
  int v4; // ecx@2
  int v5; // edx@3
  int v6; // ecx@4
  int v7; // eax@4

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = 0;
    do
    {
      v5 = 0;
      if ( a3 > 0 )
      {
        v6 = a3 * v4;
        v7 = 0;
        do
        {
          ++v5;
          *(_WORD *)(a1 + 2 * (v6 + v7)) = -32767;
          v7 = (unsigned __int16)v5;
        }
        while ( (unsigned __int16)v5 < a3 );
      }
      v4 = (unsigned __int16)++v3;
    }
    while ( (unsigned __int16)v3 < a2 );
  }
}

//----- (1003AE20) --------------------------------------------------------
signed int sub_1003AE20()
{
  signed int result; // eax@1

  memset(&unk_1073B158, 0, 0x30u);
  dword_1073B160 = 1073736000;
  dword_1073B164 = 1073736000;
  result = -1073736000;
  byte_1073E388 = 0;
  dword_1073B178 = -1;
  dword_1073B168 = -1073736000;
  dword_1073B16C = -1073736000;
  return result;
}
// 1073B160: using guessed type int dword_1073B160;
// 1073B164: using guessed type int dword_1073B164;
// 1073B168: using guessed type int dword_1073B168;
// 1073B16C: using guessed type int dword_1073B16C;
// 1073B178: using guessed type int dword_1073B178;
// 1073E388: using guessed type char byte_1073E388;

//----- (1003AF60) --------------------------------------------------------
int __cdecl sub_1003AF60(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (1003AF90) --------------------------------------------------------
double __cdecl sub_1003AF90(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4)
               + *(float *)a1 * *(float *)a2
               + *(float *)(a1 + 8) * *(float *)(a2 + 8));
}

//----- (1003AFC0) --------------------------------------------------------
double __cdecl sub_1003AFC0(int a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@1
  float v3; // ST00_4@1

  v1 = *(float *)a1 * *(float *)a1 + 0.0;
  v2 = *(float *)(a1 + 4) * *(float *)(a1 + 4) + v1;
  v3 = *(float *)(a1 + 8) * *(float *)(a1 + 8) + v2;
  return (float)sqrt(v3);
}

//----- (1003B000) --------------------------------------------------------
int __cdecl sub_1003B000(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (1003B030) --------------------------------------------------------
int __cdecl sub_1003B030(unsigned __int8 a1, unsigned int a2)
{
  return dword_100CEE60[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100CEE60: using guessed type int dword_100CEE60[];

//----- (1003B050) --------------------------------------------------------
unsigned int __cdecl sub_1003B050(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100CEE60[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100CEE60[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100CEE60[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100CEE60[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100CEE60[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100CEE60[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100CEE60[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100CEE60[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100CEE60[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100CEE60[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100CEE60: using guessed type int dword_100CEE60[];

//----- (1003B180) --------------------------------------------------------
double __cdecl sub_1003B180(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1003B220) --------------------------------------------------------
double __cdecl sub_1003B220(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1003D432) --------------------------------------------------------
int __cdecl sub_1003D432(int a1, int a2, char a3)
{
  return vscan_fn(sub_100450CF, a2, 0, &a3);
}
// 1003D3CA: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003ED7E) --------------------------------------------------------
int __cdecl sub_1003ED7E(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10048A51() + 8 && (void **)v2 != sub_10048A51() + 16 || !sub_100489F3((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100DF2F0;
      else
        v9 = (_BYTE *)(dword_1077BF00[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_100488D3((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_100488D3((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 100489AF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1003F913) --------------------------------------------------------
int __cdecl sub_1003F913(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10747464 = a1;
  return result;
}
// 10747464: using guessed type int dword_10747464;

//----- (10040015) --------------------------------------------------------
signed int __cdecl sub_10040015(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1074746C )
  {
    *a1 = dword_1074746C;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1074746C: using guessed type int dword_1074746C;

//----- (1004004C) --------------------------------------------------------
signed int __cdecl sub_1004004C(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1074746C )
  {
    *a1 = dword_10747478;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1074746C: using guessed type int dword_1074746C;
// 10747478: using guessed type int dword_10747478;

//----- (10040C92) --------------------------------------------------------
void sub_10040C92()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_1077BF00;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_1077C000 );
}
// 1077BF00: using guessed type int dword_1077BF00[];
// 1077C000: using guessed type int dword_1077C000;

//----- (1004113F) --------------------------------------------------------
int (*sub_1004113F())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100DD490;
  v1 = (int (**)(void))&unk_100DD490;
  if ( &unk_100DD490 < &unk_100DD490 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100DD490 );
  }
  return result;
}

//----- (10041163) --------------------------------------------------------
void __cdecl sub_10041163()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100DD498;
  if ( &unk_100DD498 < &unk_100DD498 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100DD498 );
  }
}

//----- (100450CF) --------------------------------------------------------
int __cdecl sub_100450CF(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100DF2F0;
  }
  else
  {
    v6 = &dword_1077BF00[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100DF2F0) : (v8 = &dword_1077BF00[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1004BE95(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1004BE95(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1004BE95(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1004BE95(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1004BE95(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100DF29C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1004BE95(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1004BE95(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1004BE95(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1004BE95(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004034B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10045094: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100450AA: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100DF29C: using guessed type int (*off_100DF29C[3])();
// 1077BF00: using guessed type int dword_1077BF00[];
// 100450CF: using guessed type char var_24[11];

//----- (10046E34) --------------------------------------------------------
#error "10046E39: positive sp value has been found (funcsize=0)"

//----- (10046E3F) --------------------------------------------------------
#error "10046E44: positive sp value has been found (funcsize=0)"

//----- (10046E4A) --------------------------------------------------------
#error "10046E4F: positive sp value has been found (funcsize=0)"

//----- (10046E50) --------------------------------------------------------
#error "10046E55: positive sp value has been found (funcsize=0)"

//----- (10046E56) --------------------------------------------------------
#error "10046E5B: positive sp value has been found (funcsize=0)"

//----- (10046E5C) --------------------------------------------------------
#error "10046E61: positive sp value has been found (funcsize=0)"

//----- (10046E62) --------------------------------------------------------
#error "10046E7D: positive sp value has been found (funcsize=0)"

//----- (10046E83) --------------------------------------------------------
#error "10046E98: positive sp value has been found (funcsize=0)"

//----- (10046E9E) --------------------------------------------------------
#error "10046EB9: positive sp value has been found (funcsize=0)"

//----- (10046EBA) --------------------------------------------------------
#error "10046EC9: positive sp value has been found (funcsize=0)"

//----- (10046ECA) --------------------------------------------------------
#error "10046EDD: positive sp value has been found (funcsize=0)"

//----- (10046EDE) --------------------------------------------------------
#error "10046EED: positive sp value has been found (funcsize=0)"

//----- (10046EEE) --------------------------------------------------------
#error "10046F0D: positive sp value has been found (funcsize=0)"

//----- (10046F13) --------------------------------------------------------
#error "10046F2C: positive sp value has been found (funcsize=0)"

//----- (10046F32) --------------------------------------------------------
#error "10046F51: positive sp value has been found (funcsize=0)"

//----- (10046F52) --------------------------------------------------------
#error "10046F65: positive sp value has been found (funcsize=0)"

//----- (10046F66) --------------------------------------------------------
#error "10046F7D: positive sp value has been found (funcsize=0)"

//----- (10046F7E) --------------------------------------------------------
#error "10046F91: positive sp value has been found (funcsize=0)"

//----- (10046F92) --------------------------------------------------------
#error "10046FB1: positive sp value has been found (funcsize=0)"

//----- (10046FB7) --------------------------------------------------------
#error "10046FD0: positive sp value has been found (funcsize=0)"

//----- (10046FD6) --------------------------------------------------------
#error "10046FF5: positive sp value has been found (funcsize=0)"

//----- (10046FF6) --------------------------------------------------------
#error "10047009: positive sp value has been found (funcsize=0)"

//----- (1004700A) --------------------------------------------------------
#error "10047021: positive sp value has been found (funcsize=0)"

//----- (10047022) --------------------------------------------------------
#error "10047035: positive sp value has been found (funcsize=0)"

//----- (10047036) --------------------------------------------------------
#error "10047055: positive sp value has been found (funcsize=0)"

//----- (1004705B) --------------------------------------------------------
#error "10047074: positive sp value has been found (funcsize=0)"

//----- (1004707A) --------------------------------------------------------
#error "10047099: positive sp value has been found (funcsize=0)"

//----- (1004709A) --------------------------------------------------------
#error "100470AD: positive sp value has been found (funcsize=0)"

//----- (100470AE) --------------------------------------------------------
#error "100470C5: positive sp value has been found (funcsize=0)"

//----- (100470C6) --------------------------------------------------------
#error "100470D9: positive sp value has been found (funcsize=0)"

//----- (100470DA) --------------------------------------------------------
#error "100470F9: positive sp value has been found (funcsize=0)"

//----- (100470FF) --------------------------------------------------------
#error "10047118: positive sp value has been found (funcsize=0)"

//----- (1004711E) --------------------------------------------------------
#error "1004713D: positive sp value has been found (funcsize=0)"

//----- (1004713E) --------------------------------------------------------
#error "10047151: positive sp value has been found (funcsize=0)"

//----- (10047152) --------------------------------------------------------
#error "10047169: positive sp value has been found (funcsize=0)"

//----- (1004716A) --------------------------------------------------------
#error "1004717D: positive sp value has been found (funcsize=0)"

//----- (1004717E) --------------------------------------------------------
#error "1004719D: positive sp value has been found (funcsize=0)"

//----- (100471A3) --------------------------------------------------------
#error "100471BC: positive sp value has been found (funcsize=0)"

//----- (100471C2) --------------------------------------------------------
#error "100471E1: positive sp value has been found (funcsize=0)"

//----- (100471E2) --------------------------------------------------------
#error "100471F5: positive sp value has been found (funcsize=0)"

//----- (100471F6) --------------------------------------------------------
#error "1004720D: positive sp value has been found (funcsize=0)"

//----- (1004720E) --------------------------------------------------------
#error "10047221: positive sp value has been found (funcsize=0)"

//----- (10047222) --------------------------------------------------------
#error "10047241: positive sp value has been found (funcsize=0)"

//----- (10047247) --------------------------------------------------------
#error "10047260: positive sp value has been found (funcsize=0)"

//----- (10047266) --------------------------------------------------------
#error "10047285: positive sp value has been found (funcsize=0)"

//----- (10047286) --------------------------------------------------------
#error "10047299: positive sp value has been found (funcsize=0)"

//----- (1004729A) --------------------------------------------------------
#error "100472B1: positive sp value has been found (funcsize=0)"

//----- (100472B2) --------------------------------------------------------
#error "100472C5: positive sp value has been found (funcsize=0)"

//----- (10047A9B) --------------------------------------------------------
void sub_10047A9B()
{
  dword_1077BEE4 = 0;
}
// 1077BEE4: using guessed type int dword_1077BEE4;

//----- (10047B53) --------------------------------------------------------
int sub_10047B53()
{
  dword_1077C018 = _get_sse2_info();
  return 0;
}
// 10047AF3: using guessed type int _get_sse2_info(void);
// 1077C018: using guessed type int dword_1077C018;

//----- (10047B60) --------------------------------------------------------
int __cdecl sub_10047B60(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1004AD19((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100421CB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10047C06) --------------------------------------------------------
int __cdecl sub_10047C06(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1004B25B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100421CB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10048115) --------------------------------------------------------
DWORD __cdecl sub_10048115(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1004D63A(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_1077BF00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1003DD0B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (100482B1) --------------------------------------------------------
_WORD *__cdecl sub_100482B1(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_1077BF00[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_1077BF00[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10048115(a1, 0, 0, 2u);
  if ( sub_100489F3(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1003DD0B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10040567: using guessed type int _getptd(void);
// 1077BF00: using guessed type int dword_1077BF00[];
// 100482B1: using guessed type CHAR var_410[688];

//----- (100488D3) --------------------------------------------------------
_WORD *__cdecl sub_100488D3(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_1077BF00[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_100482B1(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1004D74B(a1);
  return v6;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004D6AB: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (100489F3) --------------------------------------------------------
int __cdecl sub_100489F3(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_1077BF00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (10048A51) --------------------------------------------------------
void **sub_10048A51()
{
  return &off_100DFCD0;
}
// 100DFCD0: using guessed type void *off_100DFCD0;

//----- (10048A57) --------------------------------------------------------
signed int sub_10048A57()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_1077BEE0;
  if ( !dword_1077BEE0 )
  {
    v0 = 512;
LABEL_5:
    dword_1077BEE0 = v0;
    goto LABEL_6;
  }
  if ( dword_1077BEE0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_1077AEC0 = v1;
  if ( v1 || (dword_1077BEE0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_1077AEC0 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100DFCD0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_100DFF50 )
        break;
      v1 = dword_1077AEC0;
    }
    v5 = 0;
    v6 = &unk_100DFCE0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_1077BF00[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100DFD40 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1004095B: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100DFCD0: using guessed type void *off_100DFCD0;
// 100DFF50: using guessed type int dword_100DFF50;
// 1077BEE0: using guessed type int dword_1077BEE0;
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (10049392) --------------------------------------------------------
int sub_10049392()
{
  return _decode_pointer(dword_10747AA0);
}
// 1004034B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10747AA0: using guessed type int dword_10747AA0;

//----- (1004954F) --------------------------------------------------------
int __cdecl sub_1004954F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10747AAC = a1;
  return result;
}
// 10747AAC: using guessed type int dword_10747AAC;

//----- (10049559) --------------------------------------------------------
int __cdecl sub_10049559(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10747AB8 = a1;
  return result;
}
// 10747AB8: using guessed type int dword_10747AB8;

//----- (10049563) --------------------------------------------------------
int __cdecl sub_10049563(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10747ABC = a1;
  return result;
}
// 10747ABC: using guessed type int dword_10747ABC;

//----- (10049642) --------------------------------------------------------
int __cdecl sub_10049642(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10747AC0 = a1;
  return result;
}
// 10747AC0: using guessed type int dword_10747AC0;

//----- (1004AD19) --------------------------------------------------------
signed int __cdecl sub_1004AD19(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100E0128 - 1;
    v64 = v3;
    v65 = dword_100E0128 / 32;
    v9 = dword_100E0128 % 32;
    v10 = (int *)(&v60 + dword_100E0128 / 32);
    v66 = 31 - dword_100E0128 % 32;
    if ( (1 << (31 - dword_100E0128 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100E0124 - dword_100E0128 )
    {
      if ( v3 > dword_100E0124 )
      {
        if ( v3 < dword_100E0120 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100E0134 + v3;
          v50 = dword_100E012C / 32;
          v51 = dword_100E012C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100E012C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100E012C / 32;
          v44 = dword_100E012C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100E012C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100E0134 + dword_100E0120;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100E0124 - v64) / 32;
      v62 = v59;
      v18 = (dword_100E0124 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100E0128 - 1;
      v25 = dword_100E0128 / 32;
      v65 = dword_100E0128 / 32;
      v26 = (int *)(&v60 + dword_100E0128 / 32);
      v64 = 31 - dword_100E0128 % 32;
      if ( (1 << (31 - dword_100E0128 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100E0128 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100E012C + 1) / 32;
      v37 = (dword_100E012C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100E012C));
  if ( dword_100E0130 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100E0130 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100E0120: using guessed type int dword_100E0120;
// 100E0124: using guessed type int dword_100E0124;
// 100E0128: using guessed type int dword_100E0128;
// 100E012C: using guessed type int dword_100E012C;
// 100E0130: using guessed type int dword_100E0130;
// 100E0134: using guessed type int dword_100E0134;

//----- (1004B25B) --------------------------------------------------------
signed int __cdecl sub_1004B25B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100E0140 - 1;
    v64 = v3;
    v65 = dword_100E0140 / 32;
    v9 = dword_100E0140 % 32;
    v10 = (int *)(&v60 + dword_100E0140 / 32);
    v66 = 31 - dword_100E0140 % 32;
    if ( (1 << (31 - dword_100E0140 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100E013C - dword_100E0140 )
    {
      if ( v3 > dword_100E013C )
      {
        if ( v3 < dword_100E0138 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100E014C + v3;
          v50 = dword_100E0144 / 32;
          v51 = dword_100E0144 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100E0144 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100E0144 / 32;
          v44 = dword_100E0144 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100E0144 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100E014C + dword_100E0138;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100E013C - v64) / 32;
      v62 = v59;
      v18 = (dword_100E013C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100E0140 - 1;
      v25 = dword_100E0140 / 32;
      v65 = dword_100E0140 / 32;
      v26 = (int *)(&v60 + dword_100E0140 / 32);
      v64 = 31 - dword_100E0140 % 32;
      if ( (1 << (31 - dword_100E0140 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100E0140 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100E0144 + 1) / 32;
      v37 = (dword_100E0144 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100E0144));
  if ( dword_100E0148 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100E0148 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100E0138: using guessed type int dword_100E0138;
// 100E013C: using guessed type int dword_100E013C;
// 100E0140: using guessed type int dword_100E0140;
// 100E0144: using guessed type int dword_100E0144;
// 100E0148: using guessed type int dword_100E0148;
// 100E014C: using guessed type int dword_100E014C;

//----- (1004BD75) --------------------------------------------------------
int __cdecl sub_1004BD75(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100DF2F0;
    }
    else
    {
      v7 = &dword_1077BF00[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100489AF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1004BE95) --------------------------------------------------------
int __cdecl sub_1004BE95(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100DF2F0;
    }
    else
    {
      v2 = &dword_1077BF00[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100DF2F0) : (v4 = &dword_1077BF00[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100489AF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1004C0DD) --------------------------------------------------------
int sub_1004C0DD()
{
  return 0;
}

//----- (1004D5B9) --------------------------------------------------------
signed int __cdecl sub_1004D5B9(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_1077BF00[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1074713C == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1074713C: using guessed type int dword_1074713C;
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1004D63A) --------------------------------------------------------
signed int __cdecl sub_1004D63A(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_1077BF00[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1003FA19: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1004D74B) --------------------------------------------------------
void __cdecl sub_1004D74B(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_1077BF00[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 1077BF00: using guessed type int dword_1077BF00[];

//----- (1004DA4C) --------------------------------------------------------
int sub_1004DA4C()
{
  return flsall(1);
}
// 1004D972: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1004DA55) --------------------------------------------------------
int __cdecl sub_1004DA55(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10747ADC )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_10747ADC = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10747AE0 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10747AE4 = _encode_pointer(v7);
    if ( sub_10040015(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10747AEC = _encode_pointer(v8);
      if ( dword_10747AEC )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10747AE8 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10747AE8 == v23
    || dword_10747AEC == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10747AE8),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10747AEC),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10747AE0 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10747AE0);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10747AE4 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10747AE4);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1004004C(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10747ADC);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1003F91D: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100402D4: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 10040342: using guessed type int _encoded_null(void);
// 1004034B: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10747ADC: using guessed type int dword_10747ADC;
// 10747AE0: using guessed type int dword_10747AE0;
// 10747AE4: using guessed type int dword_10747AE4;
// 10747AE8: using guessed type int dword_10747AE8;
// 10747AEC: using guessed type int dword_10747AEC;

//----- (1004E861) --------------------------------------------------------
signed int __cdecl sub_1004E861(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1004D63A(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_1077BF00[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_1077BF00[0] + 68) & 1)
    && (v1 = sub_1004D63A(2), sub_1004D63A(1) == v1)
    || (v2 = (void *)sub_1004D63A(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1004D5B9(a1);
  *(_BYTE *)(dword_1077BF00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003DD0B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1077BF00: using guessed type int dword_1077BF00[];

#error "There were 50 decompilation failure(s) on 1174 function(s)"
