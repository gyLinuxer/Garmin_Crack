/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD sub_10001000(); // weak
char __cdecl sub_10001070(char a1, _BYTE *a2);
char __cdecl sub_10001220(int a1, int a2);
char __cdecl sub_100013F0(const void *a1);
char __cdecl sub_10001430(const void *a1);
char __cdecl sub_10001470(__int16 a1);
// signed __int16 __usercall sub_100014C0@<ax>(int a1@<eax>);
signed int sub_10001500();
signed int sub_10001560();
char __cdecl sub_10001580(__int16 a1, int a2);
int __cdecl sub_100016F0(int a1, int a2, int a3);
char __cdecl sub_10001740(int a1, int a2);
char __cdecl sub_100017A0(int a1, int a2);
char __cdecl sub_10001800(int a1, int a2);
unsigned __int8 __cdecl sub_100018A0(int a1, int a2);
void __cdecl sub_10001940(int a1, int a2);
char __cdecl sub_100019F0(int a1, int a2);
char __cdecl sub_10001A20(int a1, int a2);
char __cdecl sub_10001B90(int a1, int a2);
char __cdecl sub_10001C50(int a1, int a2);
char __cdecl sub_10001C90(int a1, int a2);
char __cdecl sub_10001D30(int a1, int a2);
char __cdecl sub_10001D90(__int16 a1);
char __cdecl sub_10001E10(int a1, int a2);
_DWORD sub_10001EE0(); // weak
char __cdecl sub_10001F30(__int16 a1);
// char __usercall sub_10001F50@<al>(int a1@<eax>);
int sub_10001FB0();
void __noreturn sub_100023E0();
char __cdecl sub_10002510(int a1);
int sub_100025E0();
char __cdecl sub_10002690(int a1, int a2);
char sub_10002720();
BOOL __cdecl sub_10002840(int a1, char a2);
// void __usercall sub_10002870(int a1@<esi>);
void __cdecl sub_100028B0(int a1, int a2);
signed int sub_10002900();
void sub_10002920();
char __cdecl sub_10002940(int a1, int a2);
char __cdecl sub_10002A20(int a1, int a2);
char **sub_10002B80();
// char __usercall sub_10002B90@<al>(char a1@<dl>, int a2@<ecx>, int a3);
char __cdecl sub_10002BE0(int a1, int a2, char a3);
char __cdecl sub_10002C00(int a1, int a2);
char __cdecl sub_10002C70(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8);
int __cdecl sub_10002D10(char a1, int a2);
char __cdecl sub_10002D40(int a1);
int __cdecl sub_10002E20(char a1, int a2);
int sub_10002E50();
char sub_10002E60();
int sub_10002E70();
char sub_10002E80();
char sub_10002E90();
void sub_10002EA0();
int (__cdecl *sub_10002EB0())(_DWORD);
int __cdecl sub_10002EE0(char, char, char, char, int, void *, size_t); // idb
void *__cdecl sub_10002F90(int a1);
// signed int __usercall sub_10003050@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4);
signed int sub_10003230();
void *sub_10003280();
void *sub_100032A0();
void *sub_100032C0();
char __cdecl sub_100032E0(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7);
void *sub_10003480();
// char __usercall sub_100034D0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4);
char __cdecl sub_100035A0(int a1);
int sub_10003890();
int __cdecl sub_10003B50(char a1);
char __cdecl sub_10003BA0(char a1);
char __cdecl sub_10003BF0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10003C60(char a1, _WORD *a2);
char __cdecl sub_10003CA0(unsigned int a1);
signed int sub_10003D00();
signed int sub_10003D10();
signed int sub_10003D20();
// char __usercall sub_10003D30@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
char __cdecl sub_10003E90(_BYTE *a1);
char __cdecl sub_10003EC0(unsigned __int8 a1, _BYTE *a2);
char __cdecl sub_10003EF0(char a1, char a2, int a3);
char __cdecl sub_10003F20(unsigned __int8 a1, char a2);
char __cdecl sub_10003FA0(char a1);
char sub_10004170();
char __cdecl sub_100041A0(int a1, int a2, int a3, int a4, char a5, char *a6);
// __int16 __usercall sub_10004200@<ax>(unsigned __int8 a1@<al>);
// __int16 __usercall sub_10004210@<ax>(unsigned __int8 a1@<al>);
// char __usercall sub_10004220@<al>(const void *a1@<edx>, int *a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_100042C0(unsigned __int8 a1);
char sub_10004380();
char __cdecl sub_100043F0(unsigned __int8 a1);
char __cdecl sub_10004460(unsigned __int8 a1, const void *a2);
char __cdecl sub_10004510(char a1);
char __cdecl sub_10004590(char a1, int a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_10004680(int a1, int a2, int a3, int a4, char a5, char *a6);
char __cdecl sub_10004780(int a1, char a2);
char sub_100049E0();
char __cdecl sub_10004A10(_BYTE *a1);
int __thiscall sub_10004A40(void *this);
char __cdecl sub_10004A70(char a1);
char __cdecl sub_10004A80(char a1);
char __cdecl sub_10004B70(char a1);
// char __usercall sub_10004C00@<al>(void *a1@<esi>);
// char __usercall sub_10004C60@<al>(void *a1@<esi>);
char sub_10004C90();
char __cdecl sub_10004CD0(int a1, int a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10004EA0(int a1, char a2, char a3);
char sub_10004F90();
char sub_10005050();
char sub_100051C0();
char __cdecl sub_10005210(int a1, int a2, int a3, int a4, char a5, char *a6);
char __fastcall sub_100052D0(char a1);
int __cdecl sub_10005310(char a1);
// char __usercall sub_10005340@<al>(unsigned __int8 a1@<dl>, unsigned __int8 a2@<cl>, _BYTE *a3);
// int __usercall sub_10005360@<eax>(int a1@<esi>, int a2);
// char __usercall sub_10005410@<al>(_BYTE *a1@<edi>, int a2, unsigned __int8 a3);
// char __usercall sub_100054F0@<al>(unsigned __int8 a1@<dl>, char a2@<cl>, unsigned __int8 a3, unsigned __int8 *a4);
// char __usercall sub_10005520@<al>(unsigned __int8 a1@<al>, char a2@<dl>, unsigned __int8 a3@<cl>, unsigned __int8 *a4@<esi>, int a5, unsigned __int8 *a6, char *a7);
void *__cdecl sub_100055B0(int a1);
// bool __usercall sub_100055D0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// bool __usercall sub_10005600@<al>(char a1@<bl>, unsigned __int16 a2@<si>);
// char __usercall sub_10005620@<al>(char a1@<al>, int a2, void *a3);
// void *__usercall sub_100056A0@<eax>(size_t a1@<eax>, int a2@<esi>, char a3);
// char __usercall sub_100056C0@<al>(char a1@<al>, unsigned __int8 a2@<dl>, unsigned __int8 a3@<cl>, char a4);
char __cdecl sub_10005770(char a1, char a2, int a3);
char __cdecl sub_10005AF0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_10005BA0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_10005C50(char a1);
char __cdecl sub_10005CC0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_10005D70(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_10005E20(int a1, int a2);
char __cdecl sub_100061A0(char a1, int a2, int a3, int a4, int a5);
char __cdecl sub_100062D0(char a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10006350(char a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10006420(char a1, int a2, int a3, int a4, int a5);
char __cdecl sub_100064B0(int a1);
int __cdecl sub_10006580(unsigned __int8 a1, char a2, unsigned __int8 a3, int a4);
// char __usercall sub_10006620@<al>(unsigned __int8 *a1@<eax>, _BYTE *a2@<ebx>, unsigned __int8 *a3@<esi>, int a4);
char __cdecl sub_100066B0(int a1, int a2, int a3);
char __cdecl sub_10006CB0(char a1, char a2, char a3, int a4, int a5, size_t a6);
char __cdecl sub_10006FD0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10007240(char a1, char a2);
int __cdecl sub_100072F0(char a1, int a2);
char __cdecl sub_10007350(char a1, int a2);
int __cdecl sub_10007380(char a1, int a2);
// char __usercall sub_100073F0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
// int __usercall sub_10007490@<eax>(unsigned __int8 a1@<bl>, size_t a2@<edi>, char a3, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10007590(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10007610(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10007690(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10007710(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
int __cdecl sub_10007790(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
int __cdecl sub_100077C0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
int __cdecl sub_100077F0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
int __cdecl sub_10007820(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
int __cdecl sub_10007850(unsigned __int8 a1);
void *__cdecl sub_10007880(unsigned __int8 a1);
int __cdecl sub_100078C0(unsigned __int8 a1);
int __cdecl sub_100078E0(unsigned __int8 a1, const void *a2);
// char __usercall sub_10007910@<al>(unsigned __int8 a1@<bl>);
// char __usercall sub_10007B50@<al>(unsigned __int16 a1@<ax>);
// int __usercall sub_10007BB0@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_10007CB0@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_10007D10@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10007D70@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_10007E40@<eax>(int a1@<eax>, unsigned __int8 a2);
// char __usercall sub_10007EB0@<al>(int a1@<eax>, unsigned __int8 a2@<bl>, int a3@<esi>);
// int __usercall sub_10007F10@<eax>(int a1@<eax>, unsigned __int8 a2, int a3);
char __cdecl sub_10007F70(int a1, int a2);
char __cdecl sub_10008280(unsigned __int16 a1, float *a2);
bool __cdecl sub_100083A0(int a1, void *a2);
void sub_10008430();
double __cdecl sub_10008440(float a1);
bool sub_100084A0();
// char __usercall sub_100084D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10008A10(unsigned __int8 a1, int a2);
char __cdecl sub_10008D00(unsigned __int8 a1, int a2);
char __cdecl sub_10008D60(float a1, int a2, int a3);
char __cdecl sub_10008E20(unsigned __int8 a1, _DWORD *a2);
// char __usercall sub_10008E90@<al>(int a1@<ecx>, _BYTE *a2@<edi>, _BYTE *a3@<esi>);
// char __usercall sub_10008F30@<al>(unsigned __int8 a1@<al>, int a2);
char __cdecl sub_10008FB0(int a1, int a2, int a3, __int16 a4);
char __cdecl sub_10009040(int a1, char a2, int a3, __int16 a4);
char __cdecl sub_10009120(char a1, _BYTE *a2);
char __cdecl sub_10009170(int a1, int a2, int a3, int a4, char a5, char *a6);
char __cdecl sub_100091D0(int a1);
char __cdecl sub_10009240(int a1);
char sub_10009380();
char __cdecl sub_100093C0(unsigned __int8 a1, char a2);
// BOOL __usercall sub_100093E0@<eax>(char a1@<al>, void *a2);
char __cdecl sub_10009440(unsigned int *a1);
// char __usercall sub_10009480@<al>(char a1@<bl>, unsigned __int8 a2);
char __cdecl sub_10009570(char a1);
// char __usercall sub_10009590@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5, int a6);
unsigned __int8 __cdecl sub_100095C0(char a1);
char __cdecl sub_10009610(char a1, char a2);
char __cdecl sub_10009740(int a1, int a2, int a3, int a4, void *a5, size_t a6);
char __cdecl sub_100097F0(unsigned __int8 a1, signed int a2);
// char __usercall sub_100098A0@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>);
unsigned __int8 __cdecl sub_100098E0(char a1);
// char __usercall sub_10009930@<al>(int a1@<eax>, char a2);
char __cdecl sub_10009990(int a1);
char __cdecl sub_100099B0(int a1);
char sub_100099C0();
char __cdecl sub_100099D0(int a1, int a2);
char __fastcall sub_10009AA0(char a1);
// char __usercall sub_10009B60@<al>(__int16 *a1@<eax>, char a2@<cl>);
char __cdecl sub_10009B90(int a1, int a2);
char __cdecl sub_10009BF0(char a1, char *a2);
char __cdecl sub_10009CA0(char a1, _BYTE *a2);
unsigned int __cdecl sub_10009D00(char a1);
char __cdecl sub_10009D40(char a1, int a2, int a3, int a4, char a5, int a6);
char sub_10009DA0();
char __cdecl sub_10009DD0(char a1);
char __cdecl sub_10009F10(char a1);
char __cdecl sub_10009FB0(char a1, const void *a2);
int __cdecl sub_10009FF0(unsigned __int8 a1, char a2);
char __cdecl sub_1000A000(char a1, char a2);
char __cdecl sub_1000A0E0(const void *a1);
// char __usercall sub_1000A160@<al>(const void *a1@<edi>, char a2);
// void __usercall sub_1000A1C0(int a1@<ecx>, char a2@<bl>);
// char __usercall sub_1000A230@<al>(char a1@<bl>);
char __cdecl sub_1000A310(char a1);
char __cdecl sub_1000A3B0(char a1, char a2);
char __cdecl sub_1000A440(char a1);
char sub_1000A560();
char __cdecl sub_1000A600(int a1);
char __cdecl sub_1000A730(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000A800(char a1, const void *a2);
char __cdecl sub_1000A820(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000A8A0(char a1, char *a2);
char __cdecl sub_1000A8F0(char a1, unsigned __int8 a2, int a3);
void __cdecl sub_1000AAF0(char a1);
char __cdecl sub_1000ABE0(char a1, int a2, char a3, unsigned __int8 *a4, char *a5, int a6);
char __cdecl sub_1000AD30(int a1);
char __cdecl sub_1000ADD0(int a1, char a2, int a3, __int16 a4);
char __cdecl sub_1000AE70(int a1);
char __cdecl sub_1000AEE0(char a1, int a2, int a3, int a4, char a5, int a6);
char sub_1000AF70();
char __cdecl sub_1000AFE0(void *a1);
char sub_1000B040();
// BOOL __usercall sub_1000B080@<eax>(char a1@<al>, _BYTE *a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_1000B0B0(char a1, char a2, _BYTE *a3);
char __cdecl sub_1000B160(char a1, char a2, char a3, int a4, void *a5, size_t a6);
bool __cdecl sub_1000B430(char a1, char a2, char a3, _BYTE *a4);
char __cdecl sub_1000B5E0(char a1, int a2, char a3, _BYTE *a4);
char __cdecl sub_1000B710(char a1, char a2, _BYTE *a3);
void __cdecl sub_1000B8E0(__int16 a1);
bool sub_1000B920();
signed int __cdecl sub_1000B980(unsigned __int8 a1);
// char __usercall sub_1000B9E0@<al>(int a1@<ecx>, __int16 a2@<di>, int a3);
// char __usercall sub_1000BAE0@<al>(char a1@<bl>, const char *a2@<esi>);
// char __usercall sub_1000BB40@<al>(char a1@<bl>, int a2@<esi>);
void __cdecl sub_1000BBA0(int a1);
// signed __int16 __usercall sub_1000BCE0@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1000BD00@<eax>(int a1@<esi>, signed int a2);
// int __usercall sub_1000BF00@<eax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1000C020(int a1, int a2);
signed __int16 __cdecl sub_1000C0A0(int a1, int a2);
char __cdecl sub_1000C0B0(int a1, int a2, void *a3, unsigned __int16 a4);
int __cdecl sub_1000C2A0(int a1, int a2);
int __cdecl sub_1000C2F0(int a1, int a2);
char __cdecl sub_1000C340(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5);
int __cdecl sub_1000C550(int a1);
int __cdecl sub_1000C600(int a1);
char __cdecl sub_1000C6B0(int a1);
int __cdecl sub_1000CAB0(int a1);
char __cdecl sub_1000CE40(int a1, char a2, int a3, const void *a4, int a5);
char __cdecl sub_1000D150(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_1000D440(int a1, int a2, int a3);
char __cdecl sub_1000D700(int a1, int a2, void *a3, char a4, int a5);
int __cdecl sub_1000D990(int a1);
char __cdecl sub_1000DA50(int a1, int a2, void *a3);
char __cdecl sub_1000DA70(int a1, int a2, void *a3, unsigned __int16 *a4);
int __cdecl sub_1000DAA0(int a1);
char __cdecl sub_1000DBF0(int a1, int a2);
char sub_1000DC70();
int __cdecl sub_1000DC80(int a1);
int __cdecl sub_1000DC90(int a1, int a2, unsigned __int16 a3, char a4, char a5);
int __cdecl sub_1000DD40(int a1);
char __cdecl sub_1000DD50(int a1, int a2);
char sub_1000DEF0();
signed int sub_1000E070();
int sub_1000E1A0();
void *sub_1000E1C0();
int __cdecl sub_1000E330(char a1);
signed int sub_1000E350();
// signed int __usercall sub_1000E3A0@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_1000E440@<eax>(char a1@<al>);
// int __usercall sub_1000E460@<eax>(char a1@<al>);
// signed __int16 __usercall sub_1000E480@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_1000E680(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_1000E7D0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_1000E940(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000EA90(int a1, int a2, void *a3, char a4, int a5, int a6);
char __cdecl sub_1000EC40(char a1, int a2);
char __cdecl sub_1000ED50(char a1, int a2, int a3);
char __cdecl sub_1000EE60(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_1000F0D0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_1000F100(char a1, int a2, void *a3);
char __cdecl sub_1000F130(char a1, int a2, void *a3, int a4);
const char *__cdecl sub_1000F160(int a1, unsigned __int16 a2);
int __cdecl sub_1000F190(char a1, int a2);
char __cdecl sub_1000F2B0(char a1);
int sub_1000F320();
char __thiscall sub_1000F330(void *this);
int sub_1000F370();
char __thiscall sub_1000F3A0(void *this);
// _BYTE *__usercall sub_1000F3D0@<eax>(char a1@<bl>, int a2@<esi>);
// _DWORD *__usercall sub_1000F470@<eax>(int a1@<ecx>, int a2@<esi>);
// signed int __usercall sub_1000F490@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>);
signed int sub_1000F4B0();
// char __usercall sub_1000F530@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10);
// char __usercall sub_1000F970@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4);
char __cdecl sub_1000FA00(char a1);
int sub_1000FB30();
char __cdecl sub_1000FBD0(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9);
_BYTE *__cdecl sub_1000FC40(char a1);
// _BYTE *__usercall sub_1000FD00@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>);
// __int16 __usercall sub_10010020@<ax>(unsigned __int64 a1@<edx:eax>);
char __thiscall sub_10010230(void *this);
// _BYTE *__usercall sub_10010550@<eax>(int a1@<esi>);
char __thiscall sub_100107D0(int this);
char __cdecl sub_10010940(int a1, int a2);
void __thiscall sub_10010A40(int *this);
char sub_10010AD0();
char __cdecl sub_10010AF0(int a1, int a2);
char __cdecl sub_10010C30(unsigned int a1);
char __cdecl sub_10010CB0(int a1, int a2);
char __cdecl sub_10010F20(char a1);
char __cdecl sub_10010FA0(char a1);
char __cdecl sub_10011020(__int16 a1);
// char __usercall sub_10011140@<al>(__int16 a1@<si>);
char __cdecl sub_10011200(int a1);
// char __usercall sub_10011240@<al>(__int16 *a1@<eax>, __int16 a2@<cx>);
char __cdecl sub_10011280(int a1, int a2);
int __cdecl sub_100112E0(float); // idb
int sub_10011300();
// __int16 __usercall sub_10011310@<ax>(int a1@<esi>, unsigned __int8 a2, int a3);
// char __usercall sub_100113C0@<al>(__int16 a1@<ax>);
bool __cdecl sub_10011420(char a1, __int16 a2);
// char __usercall sub_10011450@<al>(__int16 a1@<si>);
// void __usercall sub_100115C0(int a1@<esi>);
// char __usercall sub_10011700@<al>(__int16 a1@<si>);
// unsigned __int8 __usercall sub_10011760@<al>(__int16 a1@<si>);
// char __usercall sub_100117F0@<al>(char a1@<al>);
// char __usercall sub_10011800@<al>(char a1@<dl>, __int16 a2@<cx>, int a3@<edi>);
void __cdecl sub_10011BF0(int a1, int a2);
// bool __usercall sub_10011C90@<al>(float *a1@<esi>);
// char __usercall sub_10011D80@<al>(int a1@<esi>);
// int __usercall sub_10011DD0@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10011E00@<eax>(int a1@<eax>, int a2@<ecx>);
char __thiscall sub_10011E30(void *this);
char sub_10011EF0();
char __thiscall sub_10012650(void *this);
char sub_10012700();
char __cdecl sub_10012790(int a1, int a2);
char __cdecl sub_100127F0(int a1, int a2, __int16 a3);
int __cdecl sub_10012840(int a1, int a2);
char __cdecl sub_10012890(int a1);
__int16 __thiscall sub_10012960(void *this);
char __cdecl sub_10012990(int a1, int a2, unsigned __int16 a3);
char __cdecl sub_10012AF0(const void *a1, unsigned __int16 a2, int a3);
char __cdecl sub_10012B30(int a1, int a2);
int __cdecl sub_10012BC0(int a1, __int16 a2, int a3);
char __cdecl sub_10012C70(int a1, int a2);
int sub_10012CC0();
int __cdecl sub_10012D10(char a1);
char __cdecl sub_10012D40(int a1, void *a2);
// void *__usercall sub_10012DA0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10012DF0();
char **sub_10014BF0();
char **sub_10014C00();
char **sub_10014C10();
char **sub_10014C20();
char **sub_10014C30();
char **sub_10014C40();
char **sub_10014C50();
bool sub_10014C60();
bool sub_10014D90();
bool sub_10014F00();
bool sub_10015180();
bool sub_100153D0();
bool sub_10015530();
bool sub_10015730();
// bool __usercall sub_10015760@<al>(int a1@<esi>);
bool sub_100163F0();
bool sub_10016510();
bool sub_100167B0();
bool sub_10016840();
bool sub_10016870();
bool sub_100168E0();
char __cdecl sub_10016A50(char a1);
bool sub_10016AA0();
bool sub_10016C90();
char sub_10017710();
bool sub_10017810();
bool sub_10017A10();
bool sub_10017B50();
bool __thiscall sub_10017BF0(void *this);
bool sub_10017CE0();
bool __thiscall sub_10017DF0(void *this);
bool __thiscall sub_10017F80(void *this);
int (**sub_10018130())();
int __cdecl sub_10018140(int a1);
int sub_10018160();
int __cdecl sub_10018180(int a1, int a2);
__int16 __cdecl sub_100181B0(int a1);
int sub_100181D0();
int __cdecl sub_100181F0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10018230(int a1, int a2, int a3, int a4);
int __cdecl sub_10018260(int a1);
int __cdecl sub_10018280(int a1);
int __cdecl sub_100182A0(int a1, int a2);
int __cdecl sub_100182D0(int a1, int a2);
int __cdecl sub_10018300(int a1, int a2, int a3, int a4);
int __cdecl sub_10018330(int a1, int a2);
int __cdecl sub_10018360(int a1);
int __cdecl sub_10018380(int a1);
char __cdecl sub_100183A0(int a1, int a2);
int __cdecl sub_10018410(_BYTE *a1);
int __cdecl sub_10018450(int a1, int a2);
int __cdecl sub_10018480(int a1, int a2);
int __cdecl sub_100184A0(int a1);
int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD); // weak
unsigned int __cdecl sub_100184F0(unsigned int a1);
int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10018540(int a1, int a2, int a3);
int __cdecl sub_10018560(int a1, int a2, __int16 a3, int a4, int a5);
char __cdecl sub_100185C0(int a1, int a2, int a3);
int __cdecl sub_10018600(int, void *, int, void *); // idb
int __cdecl sub_10018640(int a1, int a2, int a3);
int __cdecl sub_10018670(int a1, int a2, int a3);
int __cdecl sub_10018690(int a1, int a2, int a3);
int __cdecl sub_100186F0(int a1, int a2, int a3);
char __cdecl sub_10018730(int a1, int a2, int a3);
int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD); // weak
int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD); // weak
int __cdecl sub_100187A0(int, void *, int, void *); // idb
int sub_100187F0(void); // weak
char *__cdecl sub_10018800(int a1, char *a2, int a3, char *a4, int a5);
char sub_10018930();
char __cdecl sub_10018940(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10018A40(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10018AB0(int a1, int a2);
signed int __cdecl sub_10018B10(int a1);
// int __usercall sub_10018B90@<eax>(const char **a1@<esi>);
// int __usercall sub_10018E90@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_10018EB0(int a1);
int __cdecl sub_10018F80(LONG Value); // idb
int __cdecl sub_10019010(int a1);
int __cdecl sub_10019050(int a1);
int __cdecl sub_10019090(int a1);
int __cdecl sub_100190D0(int a1);
int __cdecl sub_10019110(int a1, int a2, int a3, int a4);
int __cdecl sub_10019180(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_hsdb_put(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10019290(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100192F0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10019360(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_100193A0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10019430(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10019480(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_100194B0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100194E0(int a1, int a2, int a3, char a4);
char __cdecl sub_10019500(int a1);
signed int __cdecl sub_10019530(unsigned int a1, int a2, int a3);
int __cdecl sub_10019550(int a1, int a2, int a3);
void __cdecl sub_10019570(int a1, _BYTE *a2);
int __cdecl sub_100195A0(int a1, int a2);
int __cdecl sub_100195C0(char a1);
__int16 __cdecl sub_100195F0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_10019630(int a1, _DWORD *a2, _BYTE *a3);
int sub_10019690(void); // weak
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_100196B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10019860@<eax>(int a1@<esi>);
int __cdecl sub_10019910(int a1, unsigned __int64 a2);
// int __usercall sub_100199C0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10019A50(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10019BA0(__int16 a1, _BYTE *a2);
int __cdecl sub_10019BD0(float, float, float); // idb
double __cdecl sub_10019C20(char a1);
signed int __cdecl sub_10019CB0(char a1);
char __cdecl sub_10019CD0(_BYTE *a1);
char __cdecl sub_10019D10(float *a1);
char sub_10019E80();
bool __cdecl sub_10019EA0(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6);
char sub_1001A020();
bool __cdecl sub_1001A0E0(void *a1);
double __cdecl sub_1001A130(_BYTE *a1);
char __cdecl sub_1001A270(float *a1);
char __cdecl sub_1001A4A0(float *a1);
double __cdecl sub_1001A610(float a1);
char __cdecl sub_1001A680(float *a1);
char __cdecl sub_1001A820(float *a1);
unsigned int __cdecl sub_1001A9D0(char a1, _BYTE *a2, float *a3);
char __cdecl sub_1001ABC0(int a1);
void __cdecl sub_1001AE10(float *a1, float *a2, int a3);
double __cdecl sub_1001AED0(int a1, int a2);
bool __cdecl sub_1001AEF0(unsigned __int8 a1, float *a2);
char *__cdecl sub_1001AFF0(unsigned __int8 a1);
signed int sub_1001B0B0();
int sub_1001B0D0();
int sub_1001B130();
char *sub_1001B1A0();
int __cdecl sub_1001B270(const void *a1);
void sub_1001B320();
char __cdecl sub_1001B330(char a1);
// void __usercall sub_1001B350(unsigned __int8 a1@<bl>, char a2, char a3, char a4);
void __cdecl sub_1001B460(unsigned __int8 a1);
bool __cdecl sub_1001B4E0(unsigned __int8 a1, int a2);
char __cdecl sub_1001B600(__int16 a1);
char __cdecl sub_1001B760();
char __cdecl sub_1001B770();
char __cdecl sub_1001B780(const void *a1);
char __cdecl sub_1001B7D0();
char sub_1001B7E0();
int sub_1001B800();
int __cdecl sub_1001B8A0(_BYTE *a1, _BYTE *a2);
int sub_1001B8D0();
int __fastcall sub_1001B8E0(unsigned __int8 a1);
int __fastcall sub_1001B900(unsigned __int8 a1);
void *__cdecl sub_1001B920(char a1, void *a2);
int __cdecl sub_1001B9F0(int a1);
char sub_1001BBB0();
BOOL __cdecl sub_1001BD10(unsigned int a1);
char __thiscall sub_1001BD80(void *this);
void __cdecl sub_1001BDA0(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_1001BDD0(int a1);
signed int sub_1001BDF0();
void __cdecl sub_1001BE20(_BYTE *a1);
char __cdecl sub_1001BE40(int a1, size_t a2, void *a3);
int __cdecl sub_1001BE80(int a1);
char __fastcall sub_1001BEA0(int *a1);
char sub_1001C0C0();
char __fastcall sub_1001C0E0(int a1);
BOOL __cdecl sub_1001C130(char a1);
char __cdecl sub_1001C230(unsigned int a1);
char __cdecl sub_1001C2A0(char a1);
char __cdecl sub_1001C2F0(char a1);
char __cdecl sub_1001C340(char a1);
BOOL __cdecl sub_1001C370(char a1);
char __cdecl sub_1001C3E0(char a1);
void sub_1001C410();
char __cdecl sub_1001C420(char a1, int a2);
// char __usercall sub_1001C4A0@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
// char __usercall sub_1001C4D0@<al>(bool *a1@<esi>);
char __cdecl sub_1001C500(char a1);
char __cdecl sub_1001C570(void *a1, int a2);
bool __cdecl sub_1001C820(int a1);
char __cdecl sub_1001C870(int a1, void *a2);
char __cdecl sub_1001C8D0(int a1);
char __cdecl sub_1001C900(int a1);
char __cdecl sub_1001C930(int a1);
// char __usercall sub_1001C960@<al>(void *a1@<esi>, int a2);
char __cdecl sub_1001C9D0(void *a1);
bool __thiscall sub_1001C9F0(void *this);
bool __cdecl sub_1001CAC0(int a1);
char __cdecl sub_1001CB60(int a1, void *a2);
bool __cdecl sub_1001CC90(int a1, int a2);
char __cdecl sub_1001CDE0(int a1);
void sub_1001CFA0();
signed int sub_1001CFB0();
double sub_1001CFC0();
char sub_1001CFF0();
char sub_1001D010();
void sub_1001D030();
signed int sub_1001D040();
// char __usercall sub_1001D050@<al>(const char *a1@<esi>, int a2, int a3, char a4, int a5, int a6, __int16 a7, char a8, int a9);
char __cdecl sub_1001D150(_BYTE *a1);
char __cdecl sub_1001D180(const char *a1, int a2, int a3, char a4, __int16 a5, int a6);
char __thiscall sub_1001D1E0(void *this);
char sub_1001D200();
double __cdecl sub_1001D240(char a1);
char __cdecl sub_1001D2C0(signed int a1, char a2);
int __cdecl sub_1001D350(unsigned __int8 a1);
double sub_1001D370(void); // weak
char __fastcall sub_1001D380(int a1);
int __thiscall sub_1001D3C0(void *this);
int __cdecl sub_1001D450(int a1, int a2, int a3);
void sub_1001D460();
signed int sub_1001D470();
int sub_1001D480();
char sub_1001D4B0();
int __cdecl sub_1001D550(double, double); // idb
void sub_1001D5A0();
signed int sub_1001D5B0();
// char __usercall sub_1001D5C0@<al>(float *a1@<esi>);
signed int sub_1001D630();
bool __cdecl sub_1001D660(char a1, int a2);
char __cdecl sub_1001D880(float *a1);
char sub_1001D8E0();
bool __cdecl sub_1001D950(float *a1);
char sub_1001DA00();
bool __cdecl sub_1001DA60(float *a1);
char __cdecl sub_1001DAC0(float *a1, float *a2);
int sub_1001DB30(void); // weak
signed int sub_1001DB40();
int sub_1001DB60();
char __thiscall sub_1001DB70(void *this);
char __cdecl sub_1001DC00(char a1);
char __cdecl sub_1001DCB0(int a1, char a2);
char __cdecl sub_1001DD70(int a1, char a2);
char __cdecl sub_1001DE30(char a1, char a2);
char __cdecl sub_1001DE80(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001DF00(char a1, char a2);
char __cdecl sub_1001DF50(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001DFD0(char a1);
char __cdecl sub_1001E000(char a1);
char __cdecl sub_1001E030(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001E0B0(char a1);
char __cdecl sub_1001E0F0(char a1, _BYTE *a2);
char __cdecl sub_1001E140(char a1, _DWORD *a2);
// signed __int16 __usercall sub_1001E180@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_1001E3D0(signed __int16 a1);
int __cdecl sub_1001E460(signed __int16 a1);
char __cdecl sub_1001E570(unsigned __int16 a1);
char __cdecl sub_1001E610(char a1);
// __int16 __usercall sub_1001E650@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1001E660(unsigned __int8 a1, char *a2);
char __cdecl sub_1001E730(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
int __cdecl sub_1001E7B0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001E940(char a1);
// int __usercall sub_1001E950@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_1001E960@<al>(char a1@<bl>, char a2);
// char __usercall sub_1001EA20@<al>(char a1@<dl>, char a2@<cl>, char a3);
char __cdecl sub_1001EA70(char a1, char a2);
char __cdecl sub_1001EA90(char a1, char a2);
char __cdecl sub_1001EAC0(char a1);
char __thiscall sub_1001EAF0(void *this);
char sub_1001EB00();
void __cdecl sub_1001EB40(float a1, int a2);
void __cdecl sub_1001EBA0(float a1, float a2, int a3);
double __cdecl sub_1001EC10(float a1, float a2, int a3, float a4);
char __cdecl sub_1001ECF0(int a1, void *a2);
char __cdecl sub_1001ED40(int a1, void *a2);
bool __cdecl sub_1001ED90(int a1, void *a2, int a3);
char __cdecl sub_1001EE10(unsigned __int16 a1);
bool __cdecl sub_1001EE80(int a1, void *a2);
bool __cdecl sub_1001EEB0(float *a1);
int sub_1001EF50();
// char __usercall sub_1001EF80@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4);
char __cdecl sub_1001EFE0(float *a1);
char __cdecl sub_1001F0E0(void *a1);
char __cdecl sub_1001F1C0(const void *a1);
int __cdecl sub_1001F230(unsigned __int8 a1);
int __cdecl sub_1001F2C0(unsigned __int8 a1);
char __cdecl sub_1001F2F0(bool *a1);
bool __thiscall sub_1001F430(void *this);
char __cdecl sub_1001F460(int a1);
char __cdecl sub_1001F4D0(int a1, int a2, void *a3);
char __cdecl sub_1001F770(unsigned __int16 a1, void *a2);
int __cdecl sub_1001F7C0(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_1001F810(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1001F880(void *, size_t); // idb
int __cdecl sub_1001F8B0(char *, size_t, char *, va_list); // idb
int sub_1001F8F0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1001F920(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1001F960(void *); // idb
int __cdecl sub_1001F990(float, float); // idb
char __cdecl sub_1001FB40(int a1, int a2, float *a3);
double sub_1001FC20(void); // weak
char __thiscall sub_1001FC40(void *this);
char __thiscall sub_1001FC80(void *this);
int sub_1001FCB0();
char __cdecl sub_1001FCE0(int a1);
bool __cdecl sub_1001FD00(int a1);
int __cdecl sub_1001FD20(int, char *); // idb
char __thiscall sub_1001FD80(void *this);
char __thiscall sub_1001FDA0(void *this);
int __thiscall sub_1001FDC0(void *this);
char __thiscall sub_1001FDE0(void *this);
char __thiscall sub_1001FE00(void *this);
int __cdecl sub_1001FE20(char a1);
int __cdecl sub_1001FE30(char a1);
void sub_1001FE40();
char __cdecl sub_1001FE50(unsigned __int8 a1);
signed int sub_1001FEB0();
// char __usercall sub_1001FEC0@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_1001FFA0(int a1, char a2, void *a3);
char __cdecl sub_10020020(int a1, void *a2);
char __cdecl sub_10020040(char a1);
char __cdecl sub_10020080(char a1);
char __cdecl sub_100200F0(char a1);
signed int __cdecl sub_10020160(char a1);
char __cdecl sub_100201E0(char a1);
char __cdecl sub_10020250(char a1);
char __cdecl sub_10020300(int a1);
char __cdecl sub_10020410(int a1);
// char __usercall sub_10020510@<al>(int a1@<edi>, char a2, unsigned __int8 a3);
char __cdecl sub_10020540(char a1);
char __thiscall sub_10020560(void *this);
char __cdecl sub_10020570(char a1);
char __cdecl sub_100205A0(bool *a1, unsigned int a2);
char __thiscall sub_100206A0(void *this);
int __thiscall sub_100206D0(void *this);
bool __cdecl sub_100206F0(char a1);
void sub_10020760();
int __cdecl sub_10020770(char, int, __int16, __int16, void *); // idb
signed int sub_10020780();
int sub_10020790();
signed int sub_100207A0();
void sub_100207B0();
char __cdecl sub_100207C0(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4);
int __cdecl sub_10020890(char a1, __int16 a2, int a3);
signed int sub_10020900();
unsigned __int8 __cdecl sub_10020910(unsigned __int8 a1, int a2, unsigned __int8 a3);
char __cdecl sub_100209E0(unsigned __int8 a1, __int16 a2, _DWORD *a3);
int __cdecl sub_10020AA0(int *a1);
// char __usercall sub_10020AD0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10020B70(const char *a1);
char __cdecl sub_10020BB0(void *a1);
signed int __cdecl sub_10020C00(unsigned int a1, int a2);
char **sub_10020FA0();
int sub_10020FB0(void); // weak
char __cdecl sub_10020FE0(char *a1);
char __cdecl sub_10021010(int a1, int a2);
char __cdecl sub_10021130(int a1);
char __cdecl sub_10021140(int a1);
char __cdecl sub_10021150(int a1);
char __cdecl sub_10021160(int a1);
char __cdecl sub_10021170(int a1);
char __cdecl sub_10021180(int a1);
signed int __cdecl sub_10021190(char a1, char a2);
int __cdecl sub_100211F0(char a1);
int __cdecl sub_10021230(char a1);
signed int __cdecl sub_10021270(char a1, char a2, char a3);
int __cdecl sub_100212E0(char a1);
int __cdecl sub_10021320(char a1);
char __cdecl sub_10021360(int a1, int a2);
char __cdecl sub_10021380(char a1, int a2);
int __cdecl sub_100213A0(char a1, int a2);
char __cdecl sub_100213D0(char a1, int a2);
char __cdecl sub_10021400(char a1, int a2);
char __cdecl sub_10021450(char a1, int a2);
char __cdecl sub_10021480(int a1);
char __cdecl sub_100214A0(char a1, int a2);
char __cdecl sub_100214C0(int a1);
char __cdecl sub_100214E0(void *a1);
char __cdecl sub_10021500(void *a1);
char __cdecl sub_10021650(int a1, unsigned int *a2);
bool __thiscall sub_100216A0(void *this);
char __cdecl sub_100216C0(unsigned __int8 a1);
char __cdecl sub_10021730(char *a1, size_t a2);
char __cdecl sub_10021930(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10021AD0(int a1, unsigned int *a2);
int __cdecl sub_10021B20(char a1);
char __cdecl sub_10021B40(unsigned __int8 a1);
int __cdecl sub_10021B60(int, void *); // idb
// int __usercall sub_10021BC0@<eax>(char a1@<al>);
BOOL __cdecl sub_10021BF0(char a1, int a2);
char __cdecl sub_10021C20(char a1, int a2);
int __cdecl sub_10021C40(int, char, int, int, void *); // idb
char __cdecl sub_10021C70(void *a1);
BOOL __cdecl sub_10021C90(int a1);
char __cdecl sub_10021CB0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10021CE0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_10021D70(char a1, char a2, void *a3);
bool __cdecl sub_10021DF0(unsigned __int8 a1, int a2, _DWORD *a3);
// char __usercall sub_10021E80@<al>(void *a1@<eax>, int a2);
bool __cdecl sub_10021EB0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_10021F50(int a1, char a2, void *a3);
bool __cdecl sub_10022070(char a1, void *a2);
// signed int __usercall sub_100220B0@<eax>(char a1@<al>);
bool __cdecl sub_100220D0(char a1, void *a2);
bool __cdecl sub_100221C0(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_100221F0(unsigned __int8 a1);
// BOOL __usercall sub_10022200@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10022230(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_100223E0(unsigned __int8 a1, int a2);
bool __cdecl sub_10022420(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
bool __thiscall sub_10022510(void *this);
char sub_10022530();
BOOL __cdecl sub_100225D0(int a1, int a2);
char __cdecl sub_100225F0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10022630(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100226D0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10022750(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100227C0(char a1, void *a2);
char __cdecl sub_10022840(char a1, void *a2);
char __cdecl sub_100228C0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10022940(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100229C0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10022A30(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10022B40(char a1, void *a2);
bool __cdecl sub_10022B60(unsigned __int8 a1, char *a2);
char __cdecl sub_10022BA0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10022BE0();
char __cdecl sub_10022C40(int a1, char *a2);
BOOL __cdecl sub_10022D30(int a1, int a2);
char __cdecl sub_10022D50(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10022D90(int a1, int a2);
BOOL __cdecl sub_10022E40(int a1, int a2);
char __cdecl sub_10022E60(int a1, char a2, int a3, int a4, int a5);
bool __cdecl sub_10022EA0(unsigned __int8 a1);
char __cdecl sub_10022F30(unsigned __int16 a1);
char __cdecl sub_10022FD0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_100230E0(char a1);
char __cdecl sub_10023130(char a1, int a2);
// int __usercall sub_100232A0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_100232E0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_10023320();
char __cdecl sub_10023330(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10023390(char a1, void *a2);
char __cdecl sub_100234B0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10023530(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_100236E0(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10023810(char a1, int a2);
bool __cdecl sub_10023890(void *a1);
char __cdecl sub_100238E0(char a1, int a2);
// __int16 __usercall sub_100239C0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_100239D0(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10023A60(unsigned __int8 a1, char a2);
bool __cdecl sub_10023B20(__int16 a1, char a2, int a3, int a4, void *a5);
char __thiscall sub_10023C20(void *this);
// char __usercall sub_10023C90@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10023CD0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10023D70(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023DB0(char a1, char a2, void *a3);
char __cdecl sub_10023E10(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023E50(char a1, char a2, void *a3);
char __cdecl sub_10023E80(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023EC0(char a1, char a2, void *a3);
char __cdecl sub_10023F00(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023F40(char a1, char a2, void *a3);
char __cdecl sub_10023F90(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023FD0(char a1, char a2, void *a3);
char __cdecl sub_10024010(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10024050(char a1, char a2, void *a3);
char __cdecl sub_10024090(char a1, void *a2);
char __cdecl sub_100240C0(char a1, void *a2);
char __cdecl sub_100240F0(char a1, void *a2);
char __cdecl sub_10024120(char a1, void *a2);
char __cdecl sub_10024150(char a1, void *a2);
char __cdecl sub_10024180(char a1, void *a2);
char __cdecl sub_100241B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100241F0(char a1, char a2, void *a3);
char __cdecl sub_10024240(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10024280(char a1, char a2, void *a3);
char __cdecl sub_100242B0(char a1, void *a2);
char __cdecl sub_100242E0(char a1, void *a2);
char __cdecl sub_10024310(char a1, void *a2);
char __cdecl sub_10024340(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_100246E0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10024750(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100247B0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10024820(char a1, _BYTE *a2);
char __thiscall sub_10024860(void *this);
char __cdecl sub_100248D0(char a1, int a2);
char __cdecl sub_10024900(char a1, int a2);
char __cdecl sub_10024930(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10024B00(unsigned __int16 a1);
char *__cdecl sub_10024B20(unsigned __int16 a1);
char __cdecl sub_10024B60(char a1);
char __cdecl sub_10024C00(unsigned __int8 a1);
char __cdecl sub_10024C60(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int8 *a4);
char __cdecl sub_10024CB0(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int8 *a4);
__int16 __cdecl sub_10024D00(char a1);
char __cdecl sub_10024D40(char a1, char a2, char *a3);
char __cdecl sub_10024DD0(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
char __cdecl sub_10024E30(char a1, __int16 a2, unsigned __int16 *a3);
signed int __cdecl sub_10024E90(_BYTE *a1, char a2, int a3);
int __cdecl sub_10024EE0(int, float, float, int, int); // idb
unsigned int __cdecl sub_10024FD0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10025020(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_100250E0(void *a1, size_t a2, int a3);
int __cdecl sub_10025140(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10025190(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10025230(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_100252E0(char *a1, char a2);
bool __cdecl sub_10025350(int a1, void *a2);
char __cdecl sub_10025410(int a1, bool *a2);
int __cdecl sub_100254D0(unsigned __int8 a1);
int __cdecl sub_100254F0(char a1);
bool __cdecl sub_10025510(unsigned __int8 a1);
char __cdecl sub_10025540(char a1, void *a2);
char __thiscall sub_100255A0(void *this);
char __cdecl sub_100255D0(int a1);
int __cdecl sub_100256A0(char a1, int a2, int *a3);
int __cdecl sub_100257A0(char a1, int a2);
int __cdecl sub_10025810(int a1);
char __cdecl sub_10025830(char a1);
char __cdecl sub_10025870(char a1);
signed int __cdecl sub_100258B0(char a1);
char __cdecl sub_10025900(char a1);
char __cdecl sub_10025940(int a1);
char __cdecl sub_10025990(char a1, _DWORD *a2);
char __cdecl sub_100259F0(char a1, _DWORD *a2);
char __cdecl sub_10025A50(char a1, _DWORD *a2);
int __cdecl sub_10025AA0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10025B70(unsigned __int8 a1, char a2);
char __cdecl sub_10025C00(unsigned __int8 a1);
char __cdecl sub_10025C30(unsigned __int8 a1);
char __cdecl sub_10025C60(unsigned __int8 a1);
int __cdecl sub_10025C90(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10025D60(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10025E00(unsigned __int8 a1, char a2);
char __cdecl sub_10025E20(char a1);
unsigned __int8 __cdecl sub_10025E40(unsigned int a1, char a2);
char __cdecl sub_10025E60(char a1);
char __cdecl sub_10025EE0(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_10025F40(char *a1);
bool __cdecl sub_10025FC0(void *a1);
BOOL sub_10026200();
char __cdecl sub_10026220(char a1, __int16 a2, unsigned int *a3, unsigned int a4, char a5);
char __cdecl sub_10026280(char a1, __int16 a2, unsigned int a3, int a4, int a5);
char __cdecl sub_10026310(char a1, _BYTE *a2, _BYTE *a3, char a4);
char __thiscall sub_10026350(void *this);
// void __usercall sub_10026410(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6);
char __cdecl sub_10026470(unsigned __int8 a1);
// char __usercall sub_100264B0@<al>(void *a1@<ecx>, int a2@<esi>);
char __cdecl sub_100264F0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10026A70(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10026AD0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10026B20(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10026BA0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10027350(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10027430(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_100274C0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_100276D0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_100278F0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10027950(char a1, unsigned __int16 a2, int a3, int a4, int a5);
// void *__usercall sub_100279B0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
char sub_100279E0();
char __cdecl sub_10027A10(int a1);
unsigned int __cdecl sub_10027A50(unsigned int a1);
int __cdecl sub_10027A70(int a1);
bool __cdecl sub_10027A80(int a1);
int __cdecl sub_10027B50(int a1);
int __cdecl sub_10027B70(int a1, int a2);
bool __cdecl sub_10027BB0(int a1);
signed int __cdecl sub_10027C10(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_10027CD0(int a1, int a2, int a3);
int __cdecl sub_10027D80(int a1);
signed int __cdecl sub_10027DA0(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_10027E00@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_10027F10@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10027FC0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10028190@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100281A0@<eax>(int result@<eax>);
// char __usercall sub_100281C0@<al>(int a1@<eax>);
// int __usercall sub_100281E0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10028220(unsigned int a1);
int __fastcall sub_100283D0(int a1, int a2);
// int __usercall sub_100283F0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10028400@<eax>(int a1@<esi>);
// signed int __usercall sub_10028440@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10028650(void *); // idb
int __cdecl sub_100286B0(int, int, void *, int); // idb
signed int __cdecl sub_100287B0(int a1, unsigned __int64 a2);
signed int __cdecl sub_100289B0(int a1, int a2);
int __cdecl sub_100289D0(int a1);
int __cdecl sub_10028C40(void *, int, char); // idb
signed int __cdecl sub_10028D10(unsigned int a1, int a2, int a3);
// int __usercall sub_10028DB0@<eax>(int a1@<eax>);
// int __usercall sub_10028DD0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10028E00@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10028E70(int, char *, int); // idb
// void __cdecl __noreturn exit(int);
signed int __cdecl sub_10028FE0(int a1);
// char __usercall sub_10029040@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10029070@<eax>(int a1@<eax>);
// BOOL __usercall sub_100290A0@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_100290E0(unsigned int a1);
signed int __cdecl sub_10029130(int a1, int a2);
// bool __usercall sub_10029320@<al>(int a1@<eax>);
int __cdecl sub_10029350(int, int, char, void *, int); // idb
signed int __cdecl sub_10029460(unsigned int a1, int a2, int a3);
signed int __cdecl sub_100294C0(unsigned int a1, int a2, int a3);
int __cdecl sub_10029650(int a1, char *a2, int a3, void *a4, int a5);
bool __cdecl sub_10029840(unsigned int a1);
char __cdecl sub_10029870(char a1, void *a2);
char __cdecl sub_100298C0(char a1, char *a2);
char __cdecl sub_10029980(char a1, _WORD *a2);
char __cdecl sub_100299F0(int a1);
char sub_10029A40();
int __cdecl sub_10029A50(char a1);
_DWORD __cdecl sub_10029A80(char); // weak
char __cdecl sub_10029A90(char a1, char a2, __int16 a3);
char __cdecl sub_10029AD0(char a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
int __cdecl sub_10029B10(int a1, int a2);
int __cdecl sub_10029B50(int, float); // idb
char __cdecl sub_10029B80(void *a1);
char __cdecl sub_10029B90(void *a1);
// int __usercall sub_10029BA0@<eax>(char a1@<al>, int a2@<ecx>);
bool __cdecl sub_10029BD0(char a1, int *a2);
char __cdecl sub_10029C80(float *a1);
int __cdecl sub_10029CF0(void *); // idb
char *__cdecl sub_10029D60(int a1, int a2, int a3, size_t a4, char *a5);
int sub_10029EE0();
const char *__cdecl sub_10029EF0(unsigned int a1);
int __cdecl sub_10029F10(int a1, int a2, int a3, int a4);
int __cdecl sub_10029FC0(int a1);
int __cdecl sub_10029FE0(int a1);
char *sub_1002A000(char *a1, ...);
// char *__usercall sub_1002A040@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1002A060@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1002A240();
int sub_1002A260();
int __cdecl sub_1002A280(int a1, int a2);
int __cdecl sub_1002A2E0(int a1);
int __cdecl sub_1002A2F0(int a1, int a2);
int __cdecl sub_1002A350(int a1);
bool __cdecl sub_1002A360(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1002A4A0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1002A850(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1002ACA0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1002B160(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1002B520(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1002B920(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1002BCE0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1002C220(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1002C600(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1002C9C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1002CD60(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1002D160(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1002D500(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1002DAE0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1002DED0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1002E270();
// BOOL __usercall sub_1002E2A0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1002E410@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1002E680(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1002E980(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, unsigned int a8, int a9);
bool __cdecl sub_1002EAB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1002EB60(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
char __cdecl sub_1002EBA0(_DWORD *a1);
char __cdecl sub_1002ECB0(int a1, unsigned int a2);
bool __cdecl sub_1002ECE0(const void **a1, int a2);
bool __cdecl sub_1002ED10(const void **a1, int a2);
bool __cdecl sub_1002ED40(const void **a1, int a2);
bool __cdecl sub_1002ED70(const void **a1, int a2);
bool __cdecl sub_1002EDA0(const void **a1, int a2);
bool __cdecl sub_1002EDD0(int a1, int a2);
bool __cdecl sub_1002EE10(int a1, int a2);
bool __cdecl sub_1002EE50(const void **a1, int a2);
bool __cdecl sub_1002EE80(const void **a1, int a2);
char __cdecl sub_1002EEB0(int a1, unsigned int a2);
bool __cdecl sub_1002EEE0(const void **a1, int a2);
bool __cdecl sub_1002EF10(const void **a1, int a2);
bool __cdecl sub_1002EF40(const void **a1, int a2);
bool __cdecl sub_1002EF70(const void **a1, int a2);
bool __cdecl sub_1002EFA0(const void **a1, int a2);
bool __cdecl sub_1002EFD0(const void **a1, int a2);
bool __cdecl sub_1002F000(const void **a1, int a2);
bool __cdecl sub_1002F030(const void **a1, int a2);
bool __cdecl sub_1002F060(const void **a1, int a2);
bool __cdecl sub_1002F090(const void **a1, int a2);
int __cdecl sub_1002F0C0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_1002F130(int a1, char a2);
int __cdecl sub_1002F150(int a1, int a2, int a3);
int __cdecl sub_1002F180(int a1, int a2, int a3, int a4);
int __cdecl sub_1002F1B0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1002F1F0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1002F230(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1002F280(int a1);
char __cdecl sub_1002F2B0(int a1);
char __cdecl sub_1002F2C0(int a1, int a2);
signed int __cdecl sub_1002F440(int a1);
signed int __cdecl sub_1002F480(int a1, int a2, int a3);
char __cdecl sub_1002F520(int a1);
char __cdecl sub_1002F580(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1002F5F0(char *a1);
int __cdecl sub_1002F690(int a1, int a2, int a3);
bool __cdecl sub_1002F700(int a1, unsigned int a2, int a3);
char __cdecl sub_1002F790(int a1, int a2, char a3, char a4);
char __cdecl sub_1002F840(int a1);
char __cdecl sub_1002F850(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1002F8D0(int a1, const char *a2))(const char *);
signed int __cdecl sub_1002F920(int a1, void (__cdecl *a2)(int));
signed int __cdecl sub_1002F970(int a1, int a2);
bool __cdecl sub_1002F9D0(signed int a1);
int sub_1002FA40();
char sub_1002FD60();
char sub_1002FF80();
char sub_10030180();
char sub_10030300();
char sub_10030480();
char sub_100305F0();
char sub_100306F0();
char sub_10030850();
char sub_100309B0();
char sub_10030B10();
char sub_10030C80();
char sub_10030DE0();
char sub_10030F40();
char sub_10031160();
char sub_100312C0();
char sub_10031420();
char sub_10031580();
char sub_100316F0();
char sub_10031850();
char sub_100319B0();
char sub_10031BD0();
char sub_10031DD0();
char sub_10031F50();
char sub_100320D0();
char sub_10032240();
char sub_10032330();
char sub_10032490();
char sub_100325F0();
char sub_10032750();
char sub_100328C0();
char sub_10032A20();
char sub_10032B80();
char sub_10032D80();
char sub_10032EE0();
char sub_10033040();
char sub_100331A0();
char sub_10033310();
char sub_10033470();
char sub_100335D0();
char sub_10033B70();
char sub_10033D80();
char sub_10033F70();
char sub_100340E0();
char sub_10034250();
char sub_100343B0();
char sub_100344A0();
char sub_10034600();
char sub_10034760();
char sub_100348C0();
char sub_10034A30();
char sub_10034B90();
char sub_10034CF0();
char sub_10034EF0();
char sub_10035050();
char sub_100351B0();
char sub_10035310();
char sub_10035480();
char sub_100355E0();
char sub_10035740();
char sub_10035950();
char sub_10035B40();
char sub_10035CB0();
char sub_10035E20();
char sub_10035F80();
char sub_10036070();
char sub_100361D0();
char sub_10036330();
char sub_10036490();
char sub_10036600();
char sub_10036760();
char sub_100368C0();
char sub_10036AC0();
char sub_10036C20();
char sub_10036D80();
char sub_10036EE0();
char sub_10037050();
char sub_100371B0();
char **sub_10037310();
signed int __cdecl sub_10037320(unsigned int a1);
signed int __cdecl sub_10037360(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_100373C0(unsigned int a1, int a2, int a3);
int __cdecl sub_100373E0(unsigned __int8 *a1);
int __cdecl sub_10037400(unsigned __int8 *a1, int a2);
int __cdecl sub_10037430(unsigned __int8 *a1);
_DWORD __cdecl sub_10037450(_DWORD); // weak
bool sub_10037460();
bool sub_10037470();
int __cdecl sub_10037490(_BYTE *a1);
char __cdecl sub_100374C0(_BYTE *a1, _BYTE *a2);
char __cdecl sub_10037510(_BYTE *a1, _BYTE *a2);
int sub_10037560();
__int16 sub_10037630();
// int __usercall sub_10037690@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_10037710();
int (__cdecl *(*sub_100378D0())[2])(int, int);
bool __cdecl sub_10037A00(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10037A40(unsigned __int16 a1);
int __cdecl sub_10037A70(int a1);
unsigned int __cdecl sub_10037AA0(char *a1);
int __cdecl sub_10037AC0(unsigned __int8 *a1);
int __cdecl sub_10037AE0(_BYTE *a1);
int __cdecl sub_10037B00(unsigned __int8 *a1);
int __cdecl sub_10037B20(int a1);
unsigned int __cdecl sub_10037B50(int a1, int a2);
unsigned int __cdecl sub_10037E80(int a1, int a2);
int __cdecl sub_100382C0(unsigned __int8 *a1);
int __cdecl sub_100382E0(unsigned __int8 *a1);
int __cdecl sub_10038300(int a1);
int __cdecl sub_10038330(int a1);
unsigned int __cdecl sub_10038360(_BYTE *a1);
int __cdecl sub_10038380(unsigned __int8 *a1);
int __cdecl sub_100383A0(_BYTE *a1);
int __cdecl sub_100383C0(int a1);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10038410(unsigned __int8 *a1);
int __cdecl sub_10038430(int a1);
unsigned int __cdecl sub_100384C0(int a1);
signed int __cdecl sub_100384E0(int a1);
unsigned int __cdecl sub_10038530(int a1);
int __cdecl sub_10038590(_BYTE *a1);
unsigned int __cdecl sub_100385B0(_BYTE *a1);
int __cdecl sub_100385D0(unsigned __int8 *a1);
int __cdecl sub_100385F0(_BYTE *a1);
signed int __cdecl sub_10038610(_BYTE *a1, int a2);
int __cdecl sub_10038640(_BYTE *a1);
int __cdecl sub_10038660(_BYTE *a1, int a2);
int __cdecl sub_100386A0(int a1, int a2);
int __cdecl sub_10038730(int a1);
int __cdecl sub_10038760(unsigned __int8 *a1);
unsigned int __cdecl sub_10038780(int a1);
int __cdecl sub_100387B0(int a1);
int __cdecl sub_100388A0(int a1);
signed int __cdecl sub_100389B0(_BYTE *a1, int a2);
signed int __cdecl sub_100389E0(unsigned __int8 *a1, int a2);
int __cdecl sub_10038A10(int a1);
int __cdecl sub_10038A40(unsigned __int8 *a1);
int __cdecl sub_10038AA0(int a1);
int __cdecl sub_10038AB0(unsigned __int8 *a1);
int __cdecl sub_10038AD0(unsigned __int8 *a1, int a2);
int __cdecl sub_10038B00(unsigned __int8 *a1);
int __cdecl sub_10038B20(unsigned __int8 *a1, int a2);
int __cdecl sub_10038B50(unsigned __int8 *a1);
int __cdecl sub_10038B70(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10038BA0(_BYTE *a1, int a2);
int __cdecl sub_10038BD0(int a1, int a2);
_DWORD __cdecl sub_10038C70(_DWORD); // weak
int __cdecl sub_10038C80(int a1);
unsigned int __cdecl sub_10038D00(int a1);
unsigned int __cdecl sub_10038D40(int a1);
int __cdecl sub_10038D90(int a1);
int __cdecl sub_10038DC0(int a1);
unsigned int __cdecl sub_10038DF0(int a1);
unsigned int __cdecl sub_10038E20(int a1);
unsigned int __cdecl sub_10038E40(int a1);
void __cdecl __noreturn sub_10038E80(int a1);
signed int __cdecl sub_10038FF0(int a1, int a2);
int __cdecl sub_10039040(int a1);
int __cdecl sub_100390B0(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_100390D0@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_100391A0@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_10039290(unsigned __int8 *a1);
signed int __cdecl sub_100392A0(int a1);
int __cdecl sub_100392B0(int a1);
signed int __cdecl sub_100393B0(int a1, int a2);
char __cdecl sub_10039450(char a1);
char __cdecl sub_10039490(char a1);
signed int __cdecl sub_100394D0(char a1);
char __cdecl sub_10039510(char a1);
char __cdecl sub_10039550(int a1);
char __cdecl sub_10039590(char a1);
char __cdecl sub_100395B0(char a1);
char __cdecl sub_100395D0(char a1);
char __cdecl sub_100395F0(char a1);
char __cdecl sub_10039620(char a1);
char __cdecl sub_10039650(char a1);
bool __fastcall sub_10039690(int a1);
signed int sub_100396D0();
char __cdecl sub_100396E0(void *a1);
bool sub_10039730();
char __cdecl sub_10039770(unsigned __int8 a1, signed int *a2, int a3, _BYTE *a4);
int __cdecl sub_10039E60(signed int a1, char a2);
double __cdecl sub_1003A020(int a1);
int __cdecl sub_1003A070(int a1);
int __cdecl sub_1003A0B0(char a1, char *a2);
char sub_1003A100();
char sub_1003A110();
char __cdecl sub_1003A120(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_1003A180(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
_DWORD __cdecl sub_1003A1E0(_DWORD, _DWORD); // weak
char sub_1003A1F0();
// int __usercall sub_1003A270@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_1003A2B0(unsigned __int16 a1);
int __cdecl sub_1003A2E0(_BYTE *a1);
int __cdecl sub_1003A300(unsigned __int8 *a1);
int __cdecl sub_1003A320(unsigned __int8 *a1);
int __cdecl sub_1003A340(unsigned __int8 *a1);
int __cdecl sub_1003A360(unsigned __int8 *a1);
_DWORD __cdecl sub_1003A380(_DWORD); // weak
int __cdecl sub_1003A390(int a1);
int __cdecl sub_1003A3D0(int a1);
signed int __fastcall sub_1003A3F0(unsigned __int8 a1);
char __cdecl sub_1003A400(unsigned __int8 a1);
__int16 __cdecl sub_1003A420(unsigned __int8 a1);
char __cdecl sub_1003A440(char a1, void *a2);
char __cdecl sub_1003A4F0(char a1);
int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_1003A560(char **a1);
int sub_1003A5B0();
int __cdecl sub_1003A5F0(_BYTE *a1, int a2);
signed int __cdecl sub_1003A660(_BYTE *a1, int a2);
// int __usercall sub_1003A700@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_1003A730@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_1003A900@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_1003A960@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_1003A9F0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_1003AA40@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1003AAA0@<eax>(int a1@<eax>);
// int __usercall sub_1003AAC0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_1003AB00@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_1003AB90@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_1003ACE0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_1003AD80@<eax>(int result@<eax>);
char *__cdecl sub_1003ADC0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_1003AF70@<eax>(int a1@<eax>);
// int __usercall sub_1003AFA0@<eax>(int a1@<esi>);
void __cdecl sub_1003AFD0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_1003B440();
void *sub_1003B490();
char *sub_1003B4F0();
char sub_1003B510();
char __cdecl sub_1003B520(int a1, int a2, unsigned int a3);
// int *__usercall sub_1003B560@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_1003B5B0();
int __cdecl sub_1003B5C0(_DWORD *a1, int a2, int a3);
int __cdecl sub_1003B670(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1003B880@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1003B940(char a1);
int *__cdecl sub_1003B9E0(_BYTE *a1);
// int __usercall sub_1003BAA0@<eax>(int a1@<eax>);
// signed int __usercall sub_1003BC00@<eax>(int a1@<esi>);
int __cdecl sub_1003BC70(int, int); // weak
char **sub_1003BF50();
// int __usercall sub_1003BF60@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1003C050(char *a1);
int sub_1003C290();
int __cdecl sub_1003C370(int a1, int a2, char a3);
int __cdecl sub_1003C3C0(int a1);
int __cdecl sub_1003C3D0(void *); // idb
int __cdecl sub_1003C450(int a1, int a2);
signed int __cdecl sub_1003C480(int a1, int a2, int a3);
const char *__cdecl sub_1003C4A0(int a1, int a2);
char __cdecl sub_1003C4E0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1003D290(int a1, int a2);
char **__cdecl sub_1003D310(int a1);
int (__cdecl *__cdecl sub_1003D350(const char *a1))(const char *);
const char *sub_1003D370();
__int64 sub_1003D380();
const char *sub_1003D390();
// int __usercall sub_1003D3A0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1003D3F0(int a1, int a2);
int sub_1003D420(); // weak
// int __usercall sub_1003D540@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_1003D8C0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_1003E6E0(int a1);
int __cdecl sub_1003E750(int a1, unsigned int a2);
__int16 __cdecl sub_1003E840(int a1, unsigned int a2);
__int16 __cdecl sub_1003E890(unsigned int *a1, _WORD *a2, _WORD *a3);
signed int __cdecl sub_1003E910(unsigned __int8 a1);
char __cdecl sub_1003EA40(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_1003EB70(char *a1, char a2, char a3, char a4);
char __cdecl sub_1003EC10(char a1);
char __cdecl sub_1003EC40(char a1, void *a2);
int __cdecl sub_1003ECC0(char a1, _DWORD *a2);
int __cdecl sub_1003ED10(unsigned __int8 *a1);
unsigned int __cdecl sub_1003ED30(void *a1);
unsigned int __cdecl sub_1003ED50(void *a1);
unsigned int __cdecl sub_1003ED70(void *a1);
unsigned int __cdecl sub_1003ED90(void *a1);
unsigned int __cdecl sub_1003EDB0(void *a1);
int __cdecl sub_1003EDD0(int a1);
int __cdecl sub_1003EE20(void *); // idb
unsigned int __cdecl sub_1003EEF0(void *a1);
int __cdecl sub_1003EF50(float, float); // idb
char __cdecl sub_1003EFA0(char a1, int a2, int a3);
void __cdecl sub_1003F0B0(char a1, int a2);
unsigned __int8 __cdecl sub_1003F650(unsigned __int16 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
__int16 *__cdecl sub_1003F710(char a1, unsigned __int16 a2);
int __cdecl sub_1003F980(unsigned __int8 a1, char a2);
int __cdecl sub_1003FA00(unsigned __int8 a1, char a2);
int __cdecl sub_1003FA80(unsigned __int8 a1, char a2);
void *__cdecl sub_1003FB00(unsigned __int8 a1, char a2);
int __cdecl sub_1003FB80(char a1);
int __cdecl sub_1003FBA0(char a1);
int __cdecl sub_1003FBC0(char a1);
void *__cdecl sub_1003FBE0(char a1, unsigned __int8 a2, char a3);
void *__cdecl sub_1003FCA0(unsigned __int8 a1, char a2, char a3);
void *__cdecl sub_1003FD40(unsigned __int8 a1, char a2, char a3);
char sub_1003FE10();
BOOL __fastcall sub_1003FE20(int a1);
void *__cdecl sub_1003FE50(char a1);
char sub_1003FEA0();
int *__cdecl sub_10040130(char a1);
bool __thiscall sub_10040190(void *this);
void *__cdecl sub_100401B0(char a1);
int __cdecl sub_10040210(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_100402E0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __cdecl sub_10040580(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10040650(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10040720(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_100407F0(unsigned __int8 a1, char a2);
int __cdecl sub_10040880(unsigned __int8 a1, char a2);
int __cdecl sub_10040910(unsigned __int8 a1, char a2);
int __cdecl sub_100409A0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10040A70(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10040B40(unsigned __int8 a1, char a2);
int __cdecl sub_10040BD0(unsigned __int8 a1, char a2);
int __cdecl sub_10040C60(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10040D00(unsigned __int8 a1, char a2);
int __cdecl sub_10040D20(unsigned __int8 a1, char a2);
void *__cdecl sub_10040D40(char a1);
int __cdecl sub_10040DA0(unsigned __int8 a1, char a2);
void *__cdecl sub_10040E20(char a1);
void *__cdecl sub_10040E80(char a1);
void *__cdecl sub_10040EE0(char a1);
int __cdecl sub_10040F40(char a1, char a2);
void *__cdecl sub_10040FE0(char a1);
void *__cdecl sub_10041040(char a1);
// signed int __usercall sub_100410A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10042150@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_100421B0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10042F30@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10042F50(int a1, unsigned int a2);
// int __usercall sub_10042FB0@<eax>(int result@<eax>);
// int __usercall sub_10042FF0@<eax>(int result@<eax>);
// unsigned int __usercall sub_10044710@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10044810@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10044890@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10044930@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_100449F0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10044A50@<eax>(char *a1@<edi>);
// int __usercall sub_10044B10@<eax>(int a1@<ebx>);
char __cdecl sub_10044BD0(char *a1, size_t a2, int a3);
char __cdecl sub_10044C20(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10044C70(int a1, int a2);
// int __usercall sub_10044CA0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10044EB0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10044F00(int a1, int a2);
signed int __cdecl sub_10044F90(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_100450C0(void *a1, int a2);
// BOOL __usercall sub_10045140@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100451E0@<eax>(int result@<eax>);
unsigned int __fastcall sub_10045270(unsigned int a1, int a2);
// int __usercall sub_10045290@<eax>(int result@<eax>);
// int __usercall sub_10045320@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_100457A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10045850@<eax>(int a1@<edi>);
// int __usercall sub_100458B0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10045A80@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10045B00(int a1, int a2);
// signed int __usercall sub_10045B70@<eax>(int a1@<esi>);
// unsigned int __usercall sub_10045C30@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10045DE0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10045EB0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10045F60@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10045FA0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10046000@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100460E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_10046680(int a1, int a2);
signed int __cdecl sub_100466E0(int a1);
// int __usercall sub_10046770@<eax>(int a1@<eax>);
// int __usercall sub_100469B0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10046A50@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10046C30@<eax>(int a1@<edi>);
// int __usercall sub_10046D70@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10047020(int a1, int a2);
signed int __cdecl sub_100472E0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_10047490@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10047560@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10047780(int a1, int a2);
signed int __cdecl sub_10047A90(int a1, int a2);
signed int __cdecl sub_10047EA0(int a1, int a2);
int __cdecl sub_10048010(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10048110(int a1);
// signed int __usercall sub_10048130@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_100485D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10048620@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10048640(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100489F0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10048B30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10048B80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10048C20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10048C40(int a1, int a2, int a3, int a4);
signed int __cdecl sub_10048D30(int a1);
// int __usercall sub_10048D40@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100493E0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10049DC0@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1004A0F0(int a1, int a2);
char __cdecl sub_1004A110(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1004A150(const char *a1, int a2);
// char *__usercall sub_1004A1C0@<eax>(char *result@<eax>);
void __cdecl sub_1004A1F0(char *a1);
void __cdecl sub_1004A2B0(char *a1, char *a2);
void *__cdecl sub_1004A310(int a1);
int sub_1004A4A0();
void __cdecl sub_1004A4B0(int a1);
int __cdecl sub_1004A4E0(int a1);
bool __cdecl sub_1004A500(int a1);
void *__cdecl sub_1004A530(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1004A570@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1004A590@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1004A5B0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1004A5E0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1004A6C0(int a1, int a2, int a3);
// void *__usercall sub_1004A770@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_1004A9F0(int a1, int a2);
char __cdecl sub_1004AAC0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_1004AB30@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_1004AE90@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_1004AFA0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_1004B130(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_1004B280@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_1004B3D0(int a1, int a2);
BOOL __cdecl sub_1004B410(unsigned int a1);
BOOL __cdecl sub_1004B430(int a1);
_DWORD __cdecl sub_1004B450(_DWORD); // weak
unsigned int __cdecl sub_1004B460(int a1, char a2);
signed int __cdecl sub_1004B4C0(void *a1, int a2, unsigned int a3);
int __cdecl sub_1004B4E0(int a1, int a2, int a3);
char __cdecl sub_1004B500(const char *a1, const char *a2);
int __cdecl sub_1004B640(int a1, int a2, unsigned int a3);
char __cdecl sub_1004B6C0(int a1, int a2);
char __cdecl sub_1004B710(int a1, int a2);
char __cdecl sub_1004B7C0(int a1, int a2);
char __cdecl sub_1004B820(int a1, int a2);
char __cdecl sub_1004B8F0(char a1, char a2, char *a3, char *a4);
bool __cdecl sub_1004BB00(void *a1);
int __cdecl sub_1004BB40(char a1);
int __cdecl sub_1004BB90(int a1);
int __cdecl sub_1004BBA0(int a1, int a2);
// char __usercall sub_1004BCE0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1004BDB0(_DWORD *a1, char *a2);
int __cdecl sub_1004BE90(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1004BEB0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1004BEC0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1004C0F0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004C140(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004C190(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1004C1E0(int a1))(int);
int __cdecl sub_1004C260(int a1, int a2);
int (__cdecl *__cdecl sub_1004C2E0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1004C330(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004C370(int a1, int a2, int a3))(int);
bool __thiscall sub_1004C3D0(void *this);
char __cdecl sub_1004C410(char a1, void *a2);
char __cdecl sub_1004C4C0(char a1);
// int TXT_get_static_string(void); weak
int __cdecl sub_1004C540(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1004C560(unsigned int *a1, signed int a2, unsigned int a3);
int __cdecl sub_1004C690(int a1, int a2);
int __cdecl sub_1004C6A0(int a1, _DWORD *a2);
int __cdecl sub_1004C8B0(int a1, int *a2, int *a3);
double __cdecl sub_1004C950(float a1, float a2);
int __cdecl sub_1004C9F0(signed int a1, signed int a2);
double __cdecl sub_1004CA30(float a1, float a2);
double __cdecl sub_1004CAD0(double a1, double a2);
double __cdecl sub_1004CB30(float a1, float a2);
int __cdecl sub_1004CBB0(double); // idb
double __cdecl sub_1004CBD0(float a1);
int __cdecl sub_1004CC10(int a1, int a2);
int __cdecl sub_1004CC30(float, int, int); // idb
int __cdecl sub_1004CC50(int a1, int a2);
double __cdecl sub_1004CC70(double a1, double a2);
double __cdecl sub_1004CCE0(float a1, float a2);
int __cdecl sub_1004CD70(int a1, int a2, int a3);
int __cdecl sub_1004CDA0(float, int, int); // idb
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// int sprintf(char *, const char *, ...);
// char *__cdecl strncpy(char *, const char *, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strstr(const char *, const char *);
// char *__cdecl strrchr(const char *, int);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// char *__cdecl strchr(const char *, int);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// double __cdecl floor(double);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1004F1A8(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
int __cdecl sub_1005041D(int, FILE *); // idb
int __cdecl sub_10050FB2(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10051185(_DWORD *a1);
signed int __cdecl sub_100511BC(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10051E02();
int (*sub_100522AF())(void);
void __cdecl sub_100522D3(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1005685F(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_100587FC(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_100588A2(int, int, struct localeinfo_struct *); // idb
void sub_10058D12();
// int _get_sse2_info(void); weak
int sub_10058DCA();
DWORD __cdecl sub_10058DD7(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_10058F73(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10059595(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_100596B5(signed int a1);
void **sub_10059713();
signed int sub_10059719();
// int __cdecl _fileno(FILE *);
int sub_1005A002();
int __cdecl sub_1005A1BF(int a1);
int __cdecl sub_1005A1C9(int a1);
int __cdecl sub_1005A1D3(int a1);
int __cdecl sub_1005A2B2(int a1);
signed int __cdecl sub_1005BA89(int a1, int a2);
signed int __cdecl sub_1005BFCB(int a1, int a2);
int sub_1005CADC();
int __cdecl sub_1005D2C1(FILE *); // idb
int __cdecl sub_1005D3E1(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_1005E320(signed int a1);
signed int __cdecl sub_1005E3A1(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1005E4B2(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1005E7B3();
int __cdecl sub_1005E7BC(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1005F5D1(signed int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1005F7B0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1005F800(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
double __cdecl sub_1005F870(float a1);
void __cdecl sub_1005F8A0(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_1005F900(float, float, int); // idb
void __cdecl sub_1005FAC0(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_1005FE90(int a1, int a2, float *a3, float *a4);
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10048AF0; // weak
// extern _UNKNOWN SIM_intf; weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char *off_10061C30 = "/shr_mem/iop_gia_aud_queue_intf.shr"; // weak
_UNKNOWN unk_10061D06; // weak
_UNKNOWN unk_10061D07; // weak
_UNKNOWN unk_10061D41; // weak
wchar_t a9aBCDE[12] = L"`9a:b;c<d=e>"; // weak
_UNKNOWN unk_1006253C; // weak
char a_l_fire_warn[13] = "_l_fire_warn"; // weak
__int16 word_1006254E[] = { 357 }; // weak
__int16 word_10062564[] = { 400 }; // weak
__int16 word_10062566[] = { 411 }; // weak
__int16 word_10062568[] = { 409 }; // weak
__int16 word_10062570[] = { 404 }; // weak
__int16 word_10062572[] = { 358 }; // weak
__int16 word_10062574[] = { 359 }; // weak
char byte_10062576[] = { '\0' }; // weak
_UNKNOWN unk_10064018; // weak
char *off_10064068 = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
char *off_10064258[3] = { "IOP_B_test.c", "$Id$", &off_10064140 }; // weak
char byte_10065A71 = '\0'; // idb
char byte_10067110[] = { '\x0F' }; // weak
int (__cdecl *off_10067114)(int) = &sub_10004510; // weak
int (__cdecl *off_10067118[2])(int, int, char, int, int, int) = { &sub_10004590, &sub_10004590 }; // weak
int (__cdecl *off_1006711C)(int, int, char, int, int, int) = &sub_10004590; // weak
int dword_10067120[] = { 0 }; // weak
int (__cdecl *off_10067124)(int) = &sub_10003FA0; // weak
int (*off_10067128)() = &sub_10004170; // weak
int dword_1006712C[] = { 0 }; // weak
int (__cdecl *off_10067130)(int, int, int, int, char, char *) = &sub_100041A0; // weak
int dword_10067134[] = { 0 }; // weak
int (*off_10067138)() = &sub_10004500; // weak
char *off_10067378 = "/shr_mem/iop_b_cnfg_mngr_intf.shr"; // weak
_UNKNOWN unk_10068B64; // weak
_UNKNOWN unk_10068B70; // weak
int dword_10068B74[] = { 0 }; // weak
void *off_10068B78 = &unk_10067A48; // weak
__int16 word_10068B7C[] = { 978 }; // weak
_UNKNOWN unk_10068F10; // weak
char byte_10068F11[] = { '' }; // weak
int dword_10068F14[] = { 0 }; // weak
_UNKNOWN unk_10069128; // weak
char *off_10069168 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char *off_1006917C = "/shr_mem/iop_prod_enbl_intf.shr"; // weak
_UNKNOWN unk_100699B8; // weak
char byte_100699B9[2010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'C',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1006A194[] = { 114 }; // weak
__int16 word_1006A198[] = { 113 }; // weak
_UNKNOWN unk_1006A19C; // weak
char byte_1006A19D[] = { '\x02' }; // weak
_UNKNOWN unk_1006B740; // weak
int dword_1006B744[] = { 44 }; // weak
_UNKNOWN unk_1006B780; // weak
char byte_1006B781[4010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  '%',
  's',
  ' ',
  'C',
  'H',
  'N',
  'L',
  ' ',
  '%',
  's',
  ' ',
  'O',
  'N',
  ' ',
  'B',
  'O',
  'A',
  'R',
  'D',
  ' ',
  '%',
  's',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'G',
  'E',
  'A',
  '1',
  ':',
  ' ',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '2',
  ':',
  ' ',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'E',
  'A',
  '3',
  ':',
  ' ',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'G',
  'E',
  'A',
  '4',
  ':',
  ' ',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1006CF70; // weak
int dword_1006CF74[] = { 0 }; // weak
_UNKNOWN unk_1006CF88; // weak
int dword_1006CF8C[] = { 0 }; // weak
_UNKNOWN unk_1006CFB0; // weak
int dword_1006CFB4[] = { 0 }; // weak
_UNKNOWN unk_1006CFE0; // weak
int dword_1006CFE4[] = { 0 }; // weak
_UNKNOWN unk_1006EE30; // weak
char byte_1006EE31[1010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'R',
  'A',
  ' ',
  '#',
  '%',
  'd',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1006F224[] = { 228 }; // weak
__int16 word_1006F226[] = { 230 }; // weak
_UNKNOWN unk_10070770; // weak
_BYTE byte_10070771[3010] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  83,
  68,
  32,
  35,
  51,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_10071334; // weak
char byte_10071336[] = { '\0' }; // weak
_UNKNOWN unk_10071340; // weak
char byte_10071341[] = { '\x01' }; // weak
_UNKNOWN unk_100721A8; // weak
int dword_100721AC[] = { 64 }; // weak
__int16 word_100721B0[] = { 128 }; // weak
_DWORD off_100721B4[4] = { 268902592, 24, 62, 76 }; // idb
int dword_100721D8[] = { 256 }; // weak
_UNKNOWN unk_100721DC; // weak
_UNKNOWN unk_10072BA0; // weak
int dword_10072BB0[] = { 4 }; // weak
_UNKNOWN unk_10076628; // weak
_UNKNOWN unk_1007D19C; // weak
_UNKNOWN unk_1007D1A0; // weak
char *off_1007D828[530] =
{
  "RGN_NOTIFICATION",
  "RGN_BUFFER",
  "RGN_ACK",
  "GET_HSDB",
  "LANDING_ELEV",
  "CMD",
  "GIA_1_MODE",
  "GIA_2_MODE",
  "ADC_STBY_DSC_LBL_350",
  "FLAPS_STATUS_LBL",
  "FLAPS_LEVER_POS",
  "FLAPS_FAIL_LBL",
  "LH_FLAPS_POSITION",
  "RH_FLAPS_POSITION",
  "FLAPS_POSITION",
  "FLAPS_FAIL_LBL_2",
  "AHRS_STBY_DSC_LBL_350",
  "AI_WINGSTB_OFF",
  "AHRS_1_M_HDG",
  "AHRS_2_M_HDG",
  "AHRS_1_PITCH",
  "AHRS_2_PITCH",
  "AHRS_1_ROLL",
  "AHRS_2_ROLL",
  "TCAS_LBL_274",
  "GDC_1_INST_TX",
  "GDC_1_INST_RX",
  "GDC_2_INST_TX",
  "GDC_2_INST_RX",
  "OVERSPEED_WARNING",
  "UNDERSPEED_WARNING",
  "XFIL_REG_TAG_TBL_PFD_1",
  "XFIL_REG_TAG_TBL_MFD_1",
  "XFIL_REG_TAG_TBL_PFD_2",
  "XFIL_REG_DATA_RQST",
  "XFIL_REG_DATA_MFD_1",
  "XFIL_REG_DATA_PFD_1",
  "XFIL_REG_DATA_PFD_2",
  "WAAS_1_RAIM_RSLT",
  "WAAS_2_RAIM_RSLT",
  "WAAS_1_RAIM_RQST",
  "WAAS_2_RAIM_RQST",
  "WAAS_1_PERF_DATA",
  "WAAS_2_PERF_DATA",
  "WAAS_1_PVT_DATA",
  "WAAS_2_PVT_DATA",
  "WAAS_1_INTEG_DATA",
  "WAAS_2_INTEG_DATA",
  "WAAS_1_SAT_VIS_DATA",
  "WAAS_2_SAT_VIS_DATA",
  "WAAS_1_CHNL_STAT_DATA",
  "WAAS_2_CHNL_STAT_DATA",
  "WAAS_1_RCVR_STAT",
  "WAAS_2_RCVR_STAT",
  "ACTV_PIL_FMS_VERT_NAV",
  "ACTV_COPIL_FMS_VERT_NAV",
  "ACTV_PIL_WAAS_VERT_DEVTN",
  "ACTV_COPIL_WAAS_VERT_DEVTN",
  "GS_1_DATA",
  "GS_2_DATA",
  "VLC_1_CMND_RX",
  "VLC_1_CMND_TX",
  "VLC_1_DATA",
  "VLC_1_SEL_CRS",
  "VLC_1_TUNE_FREQ",
  "VLC_2_CMND_RX",
  "VLC_2_CMND_TX",
  "VLC_2_DATA",
  "VLC_2_SEL_CRS",
  "VLC_2_TUNE_FREQ",
  "ACTV_PIL_GS_DEVTN",
  "ACTV_COPIL_GS_DEVTN",
  "ACTV_PIL_LOC_DEVTN",
  "ACTV_COPIL_LOC_DEVTN",
  "ACTV_PIL_VOR_BRG",
  "ACTV_COPIL_VOR_BRG",
  "ACTV_PIL_VOR_DEVTN",
  "ACTV_COPIL_VOR_DEVTN",
  "RADIO_HT",
  "PFD1_GENERIC_DATA",
  "MFD1_GENERIC_DATA",
  "PFD2_GENERIC_DATA",
  "ADC_STBY_MACH_NMBR",
  "ADC_STBY_IAS",
  "ADC_STBY_TAS",
  "ADC_STBY_VSPD",
  "ADC_STBY_PRESS_ALT",
  "ADC_STBY_STATIC_PRESS",
  "AHRS_STBY_PITCH",
  "AHRS_STBY_ROLL",
  "AHRS_STBY_ATT_PTCH_RT",
  "AHRS_STBY_ATT_RLL_RT",
  "AHRS_STBY_ATT_HDG_RT",
  "AHRS_STBY_X_ACCEL",
  "AHRS_STBY_Y_ACCEL",
  "AHRS_STBY_Z_ACCEL",
  "AHRS_STBY_M_HDG",
  "GSD_1_STATUS",
  "GSD_1_TICK",
  "GSD_1_MODE",
  "GSD_2_TICK",
  "GSD_2_MODE",
  "GSD_2_STATUS",
  "CFG_GSD_1_CRC",
  "CFG_GSD_2_CRC",
  "CFG_GSD_1_ACT",
  "CFG_GSD_2_ACT",
  "CFG_GSD_1_SET",
  "CFG_GSD_2_SET",
  "GDU_SWS_IMPENDING_STALL",
  "ENG_1_FADEC_CHNL_STATUS",
  "ENG_1_FADEC_LBL_271_CH_A",
  "ENG_1_FADEC_LBL_271_CH_B",
  "ENG_2_FADEC_CHNL_STATUS",
  "ENG_2_FADEC_LBL_271_CH_A",
  "ENG_2_FADEC_LBL_271_CH_B",
  "ENG_1_TLA",
  "ENG_2_TLA",
  "ENG_1_FADEC_CTRL_CHNL",
  "ENG_2_FADEC_CTRL_CHNL",
  "ENG_1_OP_MODE",
  "ENG_2_OP_MODE",
  "ENG_1_THRUST_MODE",
  "ENG_2_THRUST_MODE",
  "TCAS_VERT_RA",
  "TCAS_LBL_270",
  "TCAS_LBL_350",
  "GDL59_CFG_SET",
  "WAAS_1_GPS_DATA",
  "WAAS_2_GPS_DATA",
  "EAU_LH_AOA_HEAT_MON",
  "EAU_RH_AOA_HEAT_MON",
  "LH_GEAR_ON_GROUND",
  "RH_GEAR_ON_GROUND",
  "RH_GEAR_ON_GROUND_2",
  "LH_GEAR_ON_GROUND_2",
  "EAU_ENG_1_ITT",
  "EAU_ENG_2_ITT",
  "EAU_ENG_1_N2",
  "EAU_ENG_2_N2",
  "EAU_ENG_1_N1",
  "EAU_ENG_2_N1",
  "RA_MODE",
  "ADC_STBY_IAS_SSEC",
  "ADC_STBY_BAROSET",
  "FUEL_CH_1_LBL_270",
  "FUEL_CH_1_LBL_271",
  "FUEL_CH_2_LBL_270",
  "FUEL_CH_2_LBL_271",
  "GEA_1_RX",
  "GEA_1_TX",
  "GEA_2_RX",
  "GEA_2_TX",
  "GEA_3_RX",
  "GEA_3_TX",
  "SPOILER_LEVER_POS_1",
  "SPOILER_LEVER_POS_2",
  "DSCRT_IN_RMT_IDENT",
  "DSCRT_IN_TCAS_SYSTEM_VALID_1",
  "DSCRT_IN_TCAS_SYSTEM_VALID_2",
  "DSCRT_IN_XPDR_1_ALT_VALID",
  "DSCRT_IN_XPDR_2_ALT_VALID",
  "DSCRT_IN_XPDR_1_VALID",
  "DSCRT_IN_XPDR_2_VALID",
  "DSCRT_OUT_TCAS_II_CLMB_INHBT_1",
  "DSCRT_OUT_TCAS_II_CLMB_INHBT_2",
  "DSCRT_OUT_TCAS_II_INC_CLMB_INHBT_1",
  "DSCRT_OUT_TCAS_II_INC_CLMB_INHBT_2",
  "DSCRT_OUT_TCAS_RA_DSPL_1",
  "DSCRT_OUT_TCAS_RA_DSPL_2",
  "DSCRT_OUT_XPDR_1_STANDBY",
  "DSCRT_OUT_XPDR_2_STANDBY",
  "TCAS_XPDR_PIL_CTRL",
  "TCAS_XPDR_COPIL_CTRL",
  "GEA_1_DIS_IN",
  "GEA_2_DIS_IN",
  "GEA_3_DIS_IN",
  "DSCRT_OUT_E1_N2_GT_70",
  "DSCRT_OUT_E2_N2_GT_70",
  "LRU_PKT_ENBL",
  "EAU_ENG_1_TORQUE",
  "EAU_ENG_2_TORQUE",
  "DSCRT_IN_ENG_1_AUTO_FEATHER_ARM",
  "DSCRT_IN_ENG_2_AUTO_FEATHER_ARM",
  "EAU_N1_DISPLAY",
  "EAU_N2_DISPLAY",
  "EAU_MGT_DISPLAY",
  "EAU_TORQUE_DISPLAY",
  "EAU_NR_DISPLAY",
  "EAU_ENG_1_TORQUE_EXC",
  "EAU_ENG_2_TORQUE_EXC",
  "EAU_ENG_1_TORQUE_RAW",
  "EAU_ENG_2_TORQUE_RAW",
  "EAU_ENG_1_MGT",
  "EAU_ENG_2_MGT",
  "EAU_NR_A",
  "EAU_NR_B",
  "GTX_CMND",
  "GTX_1_STATUS_FLAGS",
  "GTX_1_STATUS",
  "GTX_1_FLIGHT_ID",
  "GTX_2_STATUS_FLAGS",
  "GTX_2_STATUS",
  "GTX_2_FLIGHT_ID",
  "GSD_1_DIS_IN",
  "GSD_2_DIS_IN",
  "ENG_1_FADEC_LBL_270",
  "ENG_1_FADEC_LBL_272",
  "ENG_1_FADEC_LBL_273",
  "ENG_1_FADEC_LBL_274",
  "ENG_1_FADEC_LBL_275",
  "ENG_1_FADEC_LBL_370",
  "ENG_1_FADEC_LBL_371",
  "ENG_1_FADEC_LBL_372",
  "XFIL_REG_TAG_TBL_GTC_1",
  "XFIL_REG_TAG_TBL_GTC_2",
  "XFIL_REG_DATA_GTC_1",
  "XFIL_REG_DATA_GTC_2",
  "FLAP_OK_1",
  "FLAP_OK_2",
  "FLAP_LDG",
  "FLAP_TO",
  "HND_FADEC_LBL_274_1_A",
  "HND_FADEC_LBL_274_1_B",
  "HND_FADEC_LBL_274_2_A",
  "HND_FADEC_LBL_274_2_B",
  "HND_FADEC_LBL_276_1",
  "HND_FADEC_LBL_276_2",
  "HND_FADEC_LBL_322_1",
  "HND_FADEC_LBL_322_2",
  "HND_FADEC_LBL_323_1",
  "HND_FADEC_LBL_323_2",
  "FUEL_CH_3_LBL_270",
  "HND_FADEC_LBL_274_1",
  "HND_FADEC_LBL_274_2",
  "CPCS_LANDING_ELEV",
  "EAU_ENG_1_PS3",
  "EAU_ENG_2_PS3",
  "EAU_ENG_N1_1A",
  "EAU_ENG_N1_1B",
  "EAU_ENG_N1_2A",
  "EAU_ENG_N1_2B",
  "EAU_ENG_PS3_1A",
  "EAU_ENG_PS3_1B",
  "EAU_ENG_PS3_2A",
  "EAU_ENG_PS3_2B",
  "PTCH_TRM_POS_1",
  "PTCH_TRM_POS_2",
  "ENG_1_FADEC_LBL_373",
  "ENG_1_FADEC_LBL_374",
  "GTC_1_KEY_INST",
  "GTC_2_KEY_INST",
  "AUDIO_MSG_RQST",
  "FLAP_POS_CTRL_L",
  "FLAP_POS_CTRL_R",
  "FLAP_POS_IND_L",
  "FLAP_POS_IND_R",
  "AFCS_1_HND_RBS_STATUS",
  "AFCS_2_HND_RBS_STATUS",
  "EAU_ENG_1_TRIM_N1",
  "EAU_ENG_2_TRIM_N1",
  "GEA_4_RX",
  "GEA_4_TX",
  "GEA_4_DIS_IN",
  "ENG_1_LBL_134",
  "ENG_2_LBL_134",
  "ENG_1_WFR",
  "ENG_2_WFR",
  "AHRS_STBY_LBL_271",
  "AHRS_STBY_LBL_272",
  "ADC_STBY_LBL_274",
  "ADC_STBY_LBL_275",
  "RA_LBL_270",
  "RA_LBL_350",
  "FLAPS_LEVER_ANGLE",
  "DSCRT_OUT_L_ENG_FIRE_PUSH_OUT",
  "DSCRT_OUT_R_ENG_FIRE_PUSH_OUT",
  "DSCRT_OUT_RAD_ALT_VALID",
  "AIRBORNE_STATUS",
  "STBY_AIR_DATA_STATUS_WORD",
  "ADC_STBY_DSC_LBL_351",
  "FUEL_QNTY_C_1",
  "FUEL_QNTY_C_2",
  "FUEL_QNTY_L_1",
  "FUEL_QNTY_L_2",
  "FUEL_QNTY_R_1",
  "FUEL_QNTY_R_2",
  "FUEL_WEIGHT_C_1",
  "FUEL_WEIGHT_C_2",
  "FUEL_WEIGHT_L_1",
  "FUEL_WEIGHT_R_1",
  "FUEL_DENSITY_C_1",
  "FUEL_DENSITY_C_2",
  "FUEL_DENSITY_L_1",
  "FUEL_DENSITY_R_1",
  "FUEL_PROBE_1_C_1",
  "FUEL_PROBE_2_C_1",
  "FUEL_PROBE_3_C_1",
  "FUEL_PROBE_4_C_1",
  "FUEL_PROBE_5_C_1",
  "FUEL_PROBE_6_C_1",
  "FUEL_PROBE_7_C_1",
  "FUEL_PROBE_1_C_2",
  "FUEL_PROBE_2_C_2",
  "FUEL_PROBE_3_C_2",
  "FUEL_PROBE_4_C_2",
  "FUEL_PROBE_5_C_2",
  "FUEL_PROBE_6_C_2",
  "FUEL_PROBE_7_C_2",
  "FUEL_PROBE_1_L_1",
  "FUEL_PROBE_2_L_1",
  "FUEL_PROBE_3_L_1",
  "FUEL_PROBE_4_L_1",
  "FUEL_PROBE_5_L_1",
  "FUEL_PROBE_6_L_1",
  "FUEL_PROBE_7_L_1",
  "FUEL_PROBE_1_R_1",
  "FUEL_PROBE_2_R_1",
  "FUEL_PROBE_3_R_1",
  "FUEL_PROBE_4_R_1",
  "FUEL_PROBE_5_R_1",
  "FUEL_PROBE_6_R_1",
  "FUEL_PROBE_7_R_1",
  "GSD_3_DIS_IN",
  "CPCS_LANDING_ELEV_2",
  "GSD_3_STATUS",
  "GSD_3_TICK",
  "GSD_3_MODE",
  "CFG_GSD_3_CRC",
  "CFG_GSD_3_ACT",
  "CFG_GSD_3_SET",
  "EAU_FUEL_QNTY_L_FAIL",
  "EAU_FUEL_QNTY_R_FAIL",
  "EAU_FUEL_QNTY_C_FAIL",
  "EAU_FUEL_QNTY_C_2_FAIL",
  "WAAS_1_GPS_DATA_UNFIL",
  "WAAS_2_GPS_DATA_UNFIL",
  "ENG_1_FADEC_LBL_273_CH_B",
  "ENG_2_FADEC_LBL_273_CH_B",
  "ENG_1_FADEC_LBL_146_CH_B",
  "ENG_2_FADEC_LBL_146_CH_B",
  "DEST_APT_IDENT",
  "XFIL_REG_TAG_TBL_GTC_3",
  "XFIL_REG_TAG_TBL_GTC_4",
  "XFIL_REG_DATA_GTC_3",
  "XFIL_REG_DATA_GTC_4",
  "GTC_3_KEY_INST",
  "GTC_4_KEY_INST",
  "ACFT_REG_DATA",
  "LANDING_ELEV_SET",
  "PREPRESSURIZATION",
  "FLAPS_MAINT_1",
  "FLAPS_MAINT_2",
  "GRA_LOOPBACK_CAL",
  "GRA_1_HEIGHT_RATE",
  "GRA_2_HEIGHT_RATE",
  "GRA_SELF_TEST",
  "GRA_1_STATE",
  "GRA_2_STATE",
  "GRA_1_MODE",
  "GRA_2_MODE",
  "GRA_CONFIG",
  "GEA_1_ANLG_IN",
  "GEA_2_ANLG_IN",
  "GEA_3_ANLG_IN",
  "GEA_4_ANLG_IN",
  "DSCRT_OUT_TCAS_II_INHBT_TO_STBY",
  "DSCRT_OUT_TCAS_II_INHBT_TO_TA_ONLY",
  "PFD1_WINDSHEAR_STATUS",
  "NRST_APT_IDENT",
  "GRA_CFG_CRC",
  "LIGHT_CTRL_PFD_1_DSPL",
  "LIGHT_CTRL_PFD_1_KEYS",
  "LIGHT_CTRL_MFD_1_DSPL",
  "LIGHT_CTRL_MFD_1_KEYS",
  "LIGHT_CTRL_PFD_2_DSPL",
  "LIGHT_CTRL_PFD_2_KEYS",
  "LIGHT_CTRL_GTC_1_DSPL",
  "LIGHT_CTRL_GTC_1_KEYS",
  "LIGHT_CTRL_GTC_2_DSPL",
  "LIGHT_CTRL_GTC_2_KEYS",
  "LIGHT_CTRL_SFD_1_DSPL",
  "LIGHT_CTRL_IP_1_KEYS",
  "LIGHT_CTRL_IP_2_KEYS",
  "LIGHT_CTRL_BEACON_CMD",
  "LIGHT_CTRL_ICE_INSP_CMD",
  "LIGHT_CTRL_LDG_CMD",
  "LIGHT_CTRL_LOGO_CMD",
  "LIGHT_CTRL_MAP_COPILOT",
  "LIGHT_CTRL_MAP_PILOT",
  "LIGHT_CTRL_NAV_CMD",
  "LIGHT_CTRL_NO_SMOKING_CMD",
  "LIGHT_CTRL_COCKPIT_OVHD",
  "LIGHT_CTRL_PILOT_FOOTWELL_CMD",
  "LIGHT_CTRL_COPILOT_FOOTWELL_CMD",
  "LIGHT_CTRL_RECOG_CMD",
  "LIGHT_CTRL_SEAT_BELT_CMD",
  "LIGHT_CTRL_STROBE_CMD",
  "LIGHT_CTRL_SW_ILLUM_TEST",
  "LIGHT_CTRL_SW_PANEL_DIM",
  "LIGHT_CTRL_TAXI_CMD",
  "LIGHT_CTRL_SPARE_CMD",
  "PFD2_WINDSHEAR_STATUS",
  "DSCRT_OUT_FADEC_LH_CHNL_SELECT",
  "DSCRT_OUT_FADEC_RH_CHNL_SELECT",
  "DSCRT_OUT_ENG_1_IGNITION_ON",
  "DSCRT_OUT_ENG_2_IGNITION_ON",
  "DSCRT_OUT_ENG_1_IGNITION_OFF",
  "DSCRT_OUT_ENG_2_IGNITION_OFF",
  "CABIN_ALT_RATE_SEL",
  "DSCRT_OUT_TR_EMG_STOW_LIGHT_L",
  "DSCRT_OUT_TR_EMG_STOW_LIGHT_R",
  "FLAPS_LBL_270",
  "FLAPS_LBL_271",
  "FLAPS_LBL_272",
  "AHRS_STBY_BDY_YAW_RT",
  "ADC_STBY_BARO_ALT",
  "GSD_1_A429_PORT_1",
  "GSD_1_A429_PORT_2",
  "GSD_1_A429_PORT_3",
  "GSD_1_A429_PORT_4",
  "GSD_1_A429_PORT_5",
  "GSD_1_A429_PORT_6",
  "GSD_1_A429_PORT_7",
  "GSD_1_A429_PORT_8",
  "GSD_1_A429_PORT_9",
  "GSD_1_A429_PORT_10",
  "GSD_1_A429_PORT_11",
  "GSD_1_A429_PORT_12",
  "GSD_1_A429_PORT_13",
  "GSD_1_A429_PORT_14",
  "GSD_1_A429_PORT_15",
  "GSD_2_A429_PORT_1",
  "GSD_2_A429_PORT_2",
  "GSD_2_A429_PORT_3",
  "GSD_2_A429_PORT_4",
  "GSD_2_A429_PORT_5",
  "GSD_2_A429_PORT_6",
  "GSD_2_A429_PORT_7",
  "GSD_2_A429_PORT_8",
  "GSD_2_A429_PORT_9",
  "GSD_2_A429_PORT_10",
  "GSD_2_A429_PORT_11",
  "GSD_2_A429_PORT_12",
  "GSD_2_A429_PORT_13",
  "GSD_2_A429_PORT_14",
  "GSD_2_A429_PORT_15",
  "GSD_3_A429_PORT_1",
  "GSD_3_A429_PORT_2",
  "GSD_3_A429_PORT_3",
  "GSD_3_A429_PORT_4",
  "GSD_3_A429_PORT_5",
  "GSD_3_A429_PORT_6",
  "GSD_3_A429_PORT_7",
  "GSD_3_A429_PORT_8",
  "GSD_3_A429_PORT_9",
  "GSD_3_A429_PORT_10",
  "GSD_3_A429_PORT_11",
  "GSD_3_A429_PORT_12",
  "GSD_3_A429_PORT_13",
  "GSD_3_A429_PORT_14",
  "GSD_3_A429_PORT_15",
  "GIA_1_A429_PORT_1",
  "GIA_1_A429_PORT_2",
  "GIA_1_A429_PORT_3",
  "GIA_1_A429_PORT_4",
  "GIA_1_A429_PORT_5",
  "GIA_1_A429_PORT_6",
  "GIA_1_A429_PORT_7",
  "GIA_1_A429_PORT_8",
  "GIA_2_A429_PORT_1",
  "GIA_2_A429_PORT_2",
  "GIA_2_A429_PORT_3",
  "GIA_2_A429_PORT_4",
  "GIA_2_A429_PORT_5",
  "GIA_2_A429_PORT_6",
  "GIA_2_A429_PORT_7",
  "GIA_2_A429_PORT_8",
  "HND_FADEC_LBL_275_1",
  "HND_FADEC_LBL_275_2",
  "ENG_1_RIGGED_TLA",
  "ENG_2_RIGGED_TLA",
  "FADEC_CROSS_300_DATA_1_B",
  "FADEC_CROSS_300_DATA_2_B",
  "FADEC_CROSS_301_DATA_1_B",
  "FADEC_CROSS_301_DATA_2_B",
  "FADEC_CROSS_302_DATA_1_B",
  "FADEC_CROSS_302_DATA_2_B",
  "FADEC_CROSS_327_DATA_1_B",
  "FADEC_CROSS_327_DATA_2_B",
  "GEA_PIN_DATA_ASSIGNMENTS",
  "ENG_MANUAL_SYNC_OFF",
  "VIB_DET_TEST_ENG_1",
  "VIB_DET_TEST_ENG_2",
  "LGHT_BUS_PFD_1",
  "LGHT_BUS_PFD_2",
  "LGHT_BUS_MFD_1",
  "LGHT_BUS_MFD_2",
  "LGHT_BUS_GTC_1",
  "LGHT_BUS_GTC_2",
  "LGHT_BUS_GTC_3",
  "LGHT_BUS_GTC_4",
  "RGN_ACK_VAR",
  "LEFT_RESOLVER_ANGLE",
  "RIGHT_RESOLVER_ANGLE",
  "LEFT_FLAP_POSITION",
  "RIGHT_FLAP_POSITION",
  "COLLECTIVE_POS",
  "PWR_LVL_ANGL",
  "EEC_NCRT_FAULT",
  "EEC_CRT_FAULT",
  "FUEL_DIS_LBL_L_350",
  "FUEL_DIS_LBL_R_350",
  "CMD_DATA",
  "CMD_ACK",
  "THIRD_PARTY_SELECT_1",
  "THIRD_PARTY_SELECT_2",
  "THIRD_PARTY_SCRATCH",
  "THIRD_PARTY_VIDEO",
  "AUDIO_MSG_RQST_QUEUE",
  "AUDIO_QUEUE_RESP",
  "AUDIO_LRU_IN_CONTROL",
  "AHRS_STBY_BDY_PTCH_RT",
  "AHRS_STBY_BDY_RLL_RT",
  "FUEL_QTY_LOW_L",
  "FUEL_QTY_LOW_R",
  "MARK_EVENT",
  "VLC_1_NAV_VOL",
  "VLC_2_NAV_VOL",
  "/shr_mem/iop_b_pkt_intf.shr"
}; // weak
char *off_1007E06C = "/shr_mem/iop_b_pkt_intf.shr"; // weak
_UNKNOWN unk_1007E080; // weak
char *off_1007E6B4 = "/shr_mem/iop_b_pkt_names_intf.shr"; // weak
int dword_1007F06C[] = { 88 }; // weak
__int16 word_1007F51C[] = { 836 }; // weak
char *off_1007F53C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1007F550 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1007F564 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1007F578 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1007F58C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1007F5A0 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int dword_10080F70[] = { 256 }; // weak
int dword_10080F74[] = { 0 }; // weak
int (__cdecl *off_10080F78)(int, char, int, __int16) = &sub_10009040; // weak
int (__cdecl *off_10080F7C)(int, int, int, __int16) = &sub_10008FB0; // weak
char *off_10080FE0 = "/shr_mem/iop_b_upld_mngr_intf.shr"; // weak
_UNKNOWN unk_100820B1; // weak
__int16 word_100820C0[] = { 52 }; // weak
_UNKNOWN unk_10082EB8; // weak
__int16 word_10082EBC[] = { 132 }; // weak
_UNKNOWN unk_10083470; // weak
int dword_10083474[] = { 1 }; // weak
char *off_100871E8[3] = { "iop_gea_cnfg_intf.c", "$Id$", &off_10087170 }; // weak
char *off_100871FC[3] = { "iop_gea_cnfg_data.c", "$Id$", &off_10087210 }; // weak
char *off_10087350[3] = { "iop_gea_cnfg_utl.c", "$Id$", &off_10087260 }; // weak
char *off_10087364[3] = { "iop_gea_intf.c", "$Id$", &off_10087378 }; // weak
char *off_100875B8[3] = { "iop_gtx_frmt.c", "$Id$", &off_10087540 }; // weak
char *off_100875CC[3] = { "iop_gtx_intf.c", "$Id$", &off_100875E0 }; // weak
char *off_10087680[3] = { "iop_gtx_xpdr_intf", "$Id$", &off_10087658 }; // weak
_UNKNOWN unk_10087EA0; // weak
_UNKNOWN unk_100886A8; // weak
_UNKNOWN unk_100886AC; // weak
_UNKNOWN unk_10088748; // weak
_UNKNOWN unk_1008874C; // weak
_UNKNOWN unk_1008879C; // weak
_UNKNOWN unk_100887A0; // weak
_UNKNOWN unk_100887F4; // weak
_UNKNOWN unk_100887F8; // weak
_UNKNOWN unk_10088878; // weak
_UNKNOWN unk_1008887C; // weak
_UNKNOWN unk_100888B0; // weak
_UNKNOWN unk_100888B4; // weak
_UNKNOWN unk_100888F8; // weak
_UNKNOWN unk_10088934; // weak
_UNKNOWN unk_1008896C; // weak
_UNKNOWN unk_10088970; // weak
_UNKNOWN unk_100889A0; // weak
_UNKNOWN unk_100889A4; // weak
_UNKNOWN unk_100889E4; // weak
_UNKNOWN unk_100889E8; // weak
_UNKNOWN unk_10088A34; // weak
_UNKNOWN unk_10088A38; // weak
_UNKNOWN unk_10088A84; // weak
_UNKNOWN unk_10088A88; // weak
_UNKNOWN unk_10088AD4; // weak
_UNKNOWN unk_10088AD8; // weak
_UNKNOWN unk_10088B24; // weak
_UNKNOWN unk_10088B28; // weak
_UNKNOWN unk_10088B74; // weak
_UNKNOWN unk_10088B78; // weak
_UNKNOWN unk_10088BC4; // weak
_UNKNOWN unk_10088BC8; // weak
_UNKNOWN unk_10088C14; // weak
_UNKNOWN unk_10088C18; // weak
__int16 word_1008A7F8[] = { 419 }; // weak
__int16 word_1008A7FA[] = { 418 }; // weak
__int16 word_1008A800[] = { 118 }; // weak
_UNKNOWN off_1008A804; // idb
char *off_1008A824 = "iop_gtx_rx_proc"; // weak
_UNKNOWN unk_1008A831; // weak
char *off_1008A834 = "GTX index"; // weak
_UNKNOWN unk_1008A840; // weak
_UNKNOWN unk_1008A841; // weak
char byte_1008A858[] = { '\0' }; // weak
char byte_1008A859[] = { '\x01' }; // weak
char off_1008A85C[8] = { 'D', '', '\b', '\x10', '\x01', '\x01', '\0', '\0' }; // idb
char byte_1008A8D0[] = { '@' }; // weak
char byte_1008A8D1[] = { '\x04' }; // weak
char off_1008A8D4[8] = { 'l', '', '\b', '\x10', '\x01', '\0', '\0', '\0' }; // idb
int (*off_1008ABC8[3])() = { &sub_10037310, &sub_10020FA0, &sub_10002B80 }; // weak
_UNKNOWN unk_1008B698; // weak
int dword_1008B69C[] = { 3535 }; // weak
_UNKNOWN unk_1008B6D0; // weak
int dword_1008B6D4[] = { 6813 }; // weak
_UNKNOWN unk_1008B708; // weak
int dword_1008B70C[] = { 9036 }; // weak
_UNKNOWN unk_1008B740; // weak
int dword_1008B744[] = { 6763 }; // weak
_UNKNOWN unk_1008B778; // weak
char byte_1008C1D0[] = { '\0' }; // weak
int dword_1008C1D4[] = { 29 }; // weak
int dword_1008E568[] = { 6103 }; // weak
int dword_1008E56C[] = { 8000 }; // weak
__int16 word_10090004[] = { 116 }; // weak
__int16 word_10090154[] = { 118 }; // weak
__int16 word_10090156[] = { 120 }; // weak
__int16 word_10090158[] = { 116 }; // weak
__int16 word_1009015A[] = { 244 }; // weak
__int16 word_1009015C[] = { 122 }; // weak
_UNKNOWN unk_10090690; // weak
char byte_10090691[] = { '\x03' }; // weak
char byte_10090692[] = { '\x04' }; // weak
char aWgs84[21] = "WGS 84              "; // weak
int (__cdecl *off_10092138)(int, size_t, void *) = &sub_1001BE40; // weak
_UNKNOWN unk_10092FD8; // weak
__int16 word_10092FDA[] = { 492 }; // weak
char byte_10092FE8[] = { '@' }; // weak
char byte_10092FE9[] = { '\x04' }; // weak
char *off_10093080 = "/shr_mem/iop_tcas_intf.shr"; // weak
char *off_10093198 = "/shr_mem/iop_upld_mngr_intf.shr"; // weak
int dword_10094040[] = { 9032 }; // weak
char *off_10094084 = "/shr_mem/prx_intf.shr"; // weak
char *off_100940B0 = "/shr_mem/nav_intf.shr"; // weak
char *off_100940DC = "/shr_mem/pvt_intf.shr"; // weak
int (*off_10094630[4])() = { &sub_1001DB50, &sub_1001DB40, &sub_1001DB30, &sub_1001DB40 }; // weak
_UNKNOWN unk_10094BDC; // weak
_UNKNOWN unk_10094BE4; // weak
char byte_10094BEC[] = { '\x02' }; // weak
char byte_10094BED[] = { '\0' }; // weak
_UNKNOWN unk_10094C0C; // weak
__int16 word_100952A8[] = { 114 }; // weak
_UNKNOWN unk_10095D28; // weak
char byte_10095D2C[] = { '\0' }; // weak
_UNKNOWN unk_10095D60; // weak
char byte_10095D64[] = { '\0' }; // weak
_UNKNOWN unk_10096490; // weak
_UNKNOWN unk_100972F8; // weak
_UNKNOWN unk_10097300; // weak
char byte_10097308[] = { '\x01' }; // weak
__int16 word_10097884[] = { 241 }; // weak
char *off_100985AC = "/shr_mem/iop_fltr_data_intf.shr"; // weak
_UNKNOWN unk_10098B00; // weak
char *off_100996DC = "/shr_mem/dat_intf.shr"; // weak
char *off_1009A4A0 = "/shr_mem/iop_rgn_data_intf.shr"; // weak
char *off_1009A858[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_1009A6C8 }; // weak
_UNKNOWN unk_1009A86C; // weak
_UNKNOWN unk_1009A870; // weak
_UNKNOWN unk_1009B460; // weak
int dword_1009B464[] = { 1312 }; // weak
_UNKNOWN unk_1009B7F8; // weak
_UNKNOWN unk_1009B810; // weak
_UNKNOWN unk_1009B848; // weak
int dword_1009B84C[] = { 6364 }; // weak
_UNKNOWN unk_1009B858; // weak
int dword_1009B85C[] = { 6767 }; // weak
_UNKNOWN unk_1009B868; // weak
_UNKNOWN unk_1009B880; // weak
_UNKNOWN unk_1009B898; // weak
int dword_1009B89C[] = { 6769 }; // weak
_UNKNOWN unk_1009B8B0; // weak
int dword_1009B8B4[] = { 6093 }; // weak
char byte_1009CA10[] = { '7' }; // weak
int dword_1009CA14[] = { 6829 }; // weak
int dword_1009D888 = 64; // weak
__int16 word_1009D88C[] = { 6782 }; // weak
__int16 word_1009D890[] = { 128 }; // weak
_UNKNOWN unk_1009D8AC; // weak
_DWORD dword_1009D8B0[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_1009D8C4; // weak
__int16 word_1009D8C6[] = { 420 }; // weak
int dword_1009D8D4[] = { 0 }; // weak
_UNKNOWN unk_1009D8E0; // weak
__int16 word_1009D8E2[] = { 0 }; // weak
__int16 word_1009ECC0[] = { 1565 }; // weak
__int16 word_1009ECC4[] = { 534 }; // weak
char byte_1009ECC8[] = { '\x04' }; // weak
__int16 word_1009ECCA[] = { 6512 }; // weak
int dword_1009ECE0[] = { 118000 }; // weak
__int16 word_100A0672[] = { 233 }; // weak
int dword_100A0678[] = { 6201 }; // weak
_UNKNOWN unk_100A2B88; // weak
int dword_100A2B8C[] = { 6006 }; // weak
char *off_100A3A38 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_100A3B58[] = { 551 }; // weak
_UNKNOWN unk_100A425B; // weak
_UNKNOWN unk_100A4260; // weak
__int16 word_100A4262[] = { 1629 }; // weak
__int16 word_100A4282[] = { 3048 }; // weak
char byte_100A4284[] = { '\0' }; // weak
char byte_100A4285[] = { '\0' }; // weak
char byte_100A4286[] = { '\0' }; // weak
char byte_100A4287[] = { '\0' }; // weak
char byte_100A4288[] = { '\0' }; // weak
char byte_100A42A2[] = { '\x04' }; // weak
char byte_100A42A7[] = { '\a' }; // weak
_UNKNOWN unk_100A4AAC; // weak
char byte_100A4B3C[] = { '\f' }; // weak
char byte_100A4B3E[] = { '\x18' }; // weak
char byte_100A4B80[] = { '\x01' }; // weak
__int16 word_100A4B82[] = { 3020 }; // weak
int (__cdecl *off_100A5850[3])(char) = { &sub_100201E0, &sub_100200F0, &sub_10020040 }; // weak
int dword_100A5870[] = { 67108864 }; // weak
int dword_100A58B8 = 6094848; // weak
int dword_100A58D8[] = { 14811136 }; // weak
int dword_100A58DC[] = { 14680292 }; // weak
int dword_100A58F0[] = { 14417920 }; // weak
void *off_100A7D70 = &unk_100A7D5C; // weak
void *off_100A7D7C = &unk_100A6E20; // weak
void *off_100A7D88 = &unk_100A6EA0; // weak
void *off_100A7D94 = &unk_100A6F00; // weak
void *off_100A7DA0 = &unk_100A6E0C; // weak
void *off_100A7DAC = &unk_100A7D5C; // weak
void *off_100A7DEC = &unk_100A7D5C; // weak
void *off_100A7DF8 = &unk_100A7D60; // weak
void *off_100A7E04 = &unk_100A7D64; // weak
void *off_100A7E10 = &unk_100A7D68; // weak
void *off_100A7E1C = &unk_100A7D6C; // weak
char byte_100A86A8[] = { '\x06' }; // weak
char byte_100A86A9[] = { '\x04' }; // weak
char byte_100A86AA[] = { '\x03' }; // weak
void *off_100A86AC = &unk_100A7D5C; // weak
void *off_100A86B8 = &unk_100A7D60; // weak
void *off_100A86C4 = &unk_100A7D64; // weak
void *off_100A86D0 = &unk_100A7D68; // weak
void *off_100A86DC = &unk_100A7D6C; // weak
__int16 word_100AB626[] = { 1 }; // weak
_UNKNOWN unk_100AB682; // weak
_UNKNOWN unk_100ACD28; // weak
void *off_100ACD2C = &unk_100ACAA0; // weak
_UNKNOWN unk_100AD410; // weak
char *off_100AD5C0[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_100AD5C8[3] = { "normal", "robust", "EQ" }; // weak
char *off_100AD5D0 = "EQ"; // weak
char *off_100AD5EC[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100AD5F8[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100AD600[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100AD8D8; // weak
_UNKNOWN unk_100AD924; // weak
_UNKNOWN unk_100ADB74; // weak
char off_100AE7D0[] = { '', '', '\n', '\x10' }; // idb
int dword_100AE7EC = 1; // idb
char byte_100AE808[] = { '\x01' }; // weak
char *off_100AE80C[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_100AE810[2] = { "2", "fail_normal_1" }; // weak
char off_100AE814[8] = { '', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100AE898[] = { '\0' }; // weak
char byte_100AE899[] = { '\0' }; // weak
int dword_100AE89C[] = { 0 }; // weak
char *off_100AE8A0 = "0, 0, 0"; // weak
double dbl_100AEB08[] = {  0.0 }; // weak
double dbl_100AEB10[] = {  0.0 }; // weak
double dbl_100AEB18[] = {  0.0 }; // weak
int dword_100AEB20[] = { 0 }; // weak
char *off_100AEB24 = "0, 0, 0"; // weak
float flt_100AF728[] = {  0.0 }; // weak
float flt_100AF72C[] = {  0.0 }; // weak
float flt_100AF730[] = {  0.0 }; // weak
int dword_100AF734[] = { 0 }; // weak
char off_100AF738[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100AFEBC[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100C4B18
}; // weak
int dword_100AFED0[] = { 0 }; // weak
int dword_100AFED4[] = { 0 }; // weak
int dword_100AFED8[] = { 0 }; // weak
int dword_100AFEDC[] = { 0 }; // weak
char *off_100AFEE0 = "0, 0, 0"; // weak
__int16 word_100B0668[] = { 0 }; // weak
__int16 word_100B066A[] = { 0 }; // weak
__int16 word_100B066C[] = { 0 }; // weak
int dword_100B0670[] = { 0 }; // weak
char *off_100B0674 = "0, 0, 0"; // weak
int dword_100B0C78[] = { 0 }; // weak
int dword_100B0C7C[] = { 0 }; // weak
int dword_100B0C80[] = { 0 }; // weak
int dword_100B0C84[] = { 0 }; // weak
char off_100B0C88[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B1410[] = { 0 }; // weak
int dword_100B1414[] = { 0 }; // weak
int dword_100B1418[] = { 0 }; // weak
int dword_100B141C[] = { 0 }; // weak
int dword_100B1420[] = { 0 }; // weak
int dword_100B1424[] = { 0 }; // weak
int dword_100B1428[] = { 0 }; // weak
char off_100B142C[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B2030[] = { '\0' }; // weak
char byte_100B2031[] = { '\0' }; // weak
char byte_100B2032[] = { '\0' }; // weak
int dword_100B2034[] = { 0 }; // weak
char *off_100B2038 = "0, 0, 0"; // weak
int dword_100B24C0[] = { 0 }; // weak
int dword_100B24C4[] = { 0 }; // weak
int dword_100B24C8[] = { 0 }; // weak
int dword_100B24CC[] = { 0 }; // weak
char *off_100B24D0 = "0, 0, 0"; // weak
int dword_100B2C58[] = { 0 }; // weak
int dword_100B2C5C[] = { 0 }; // weak
int dword_100B2C60[] = { 0 }; // weak
int dword_100B2C64[] = { 0 }; // weak
char off_100B2C68[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B2FC8[] = { 0 }; // weak
__int16 word_100B2FCA[] = { 0 }; // weak
__int16 word_100B2FCC[] = { 0 }; // weak
int dword_100B2FD0[] = { 0 }; // weak
char *off_100B2FD4 = "0, 0, 0"; // weak
int dword_100B3288[] = { 0 }; // weak
int dword_100B328C[] = { 0 }; // weak
int dword_100B3290[] = { 0 }; // weak
int dword_100B3294[] = { 0 }; // weak
char off_100B3298[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B35F8[] = { 0 }; // weak
int dword_100B35FC[] = { 0 }; // weak
int dword_100B3600[] = { 0 }; // weak
int dword_100B3604[] = { 0 }; // weak
int dword_100B3608[] = { 0 }; // weak
int dword_100B360C[] = { 0 }; // weak
int dword_100B3610[] = { 0 }; // weak
char off_100B3614[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B3B78[] = { '\0' }; // weak
char byte_100B3B79[] = { '\0' }; // weak
char byte_100B3B7A[] = { '\0' }; // weak
int dword_100B3B7C[] = { 0 }; // weak
char *off_100B3B80 = "0, 0, 0"; // weak
int dword_100B3D88[] = { 0 }; // weak
int dword_100B3D8C[] = { 0 }; // weak
int dword_100B3D90[] = { 0 }; // weak
int dword_100B3D94[] = { 0 }; // weak
char off_100B3D98[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B40F8[] = { '\x01' }; // weak
char *off_100B40FC[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_100B4100[2] = { "2", "fail_robust_1" }; // weak
char off_100B4104[8] = { '8', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B4188[] = { '\0' }; // weak
char byte_100B4189[] = { '\0' }; // weak
int dword_100B418C[] = { 0 }; // weak
char *off_100B4190 = "0, 0, 0"; // weak
double dbl_100B43F8[] = {  0.0 }; // weak
double dbl_100B4400[] = {  0.0 }; // weak
double dbl_100B4408[] = {  0.0 }; // weak
int dword_100B4410[] = { 0 }; // weak
char off_100B4414[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B5018[] = {  0.0 }; // weak
float flt_100B501C[] = {  0.0 }; // weak
float flt_100B5020[] = {  0.0 }; // weak
int dword_100B5024[] = { 0 }; // weak
char off_100B5028[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B57B0[] = { 0 }; // weak
int dword_100B57B4[] = { 0 }; // weak
int dword_100B57B8[] = { 0 }; // weak
int dword_100B57BC[] = { 0 }; // weak
char *off_100B57C0 = "0, 0, 0"; // weak
__int16 word_100B5F48[] = { 0 }; // weak
__int16 word_100B5F4A[] = { 0 }; // weak
__int16 word_100B5F4C[] = { 0 }; // weak
int dword_100B5F50[] = { 0 }; // weak
char *off_100B5F54 = "0, 0, 0"; // weak
int dword_100B6558[] = { 0 }; // weak
int dword_100B655C[] = { 0 }; // weak
int dword_100B6560[] = { 0 }; // weak
int dword_100B6564[] = { 0 }; // weak
char off_100B6568[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B6CF0[] = { 0 }; // weak
int dword_100B6CF4[] = { 0 }; // weak
int dword_100B6CF8[] = { 0 }; // weak
int dword_100B6CFC[] = { 0 }; // weak
int dword_100B6D00[] = { 0 }; // weak
int dword_100B6D04[] = { 0 }; // weak
int dword_100B6D08[] = { 0 }; // weak
char off_100B6D0C[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B7910[] = { '\0' }; // weak
char byte_100B7911[] = { '\0' }; // weak
char byte_100B7912[] = { '\0' }; // weak
int dword_100B7914[] = { 0 }; // weak
char *off_100B7918 = "0, 0, 0"; // weak
int dword_100B7DA0[] = { 0 }; // weak
int dword_100B7DA4[] = { 0 }; // weak
int dword_100B7DA8[] = { 0 }; // weak
int dword_100B7DAC[] = { 0 }; // weak
char *off_100B7DB0 = "0, 0, 0"; // weak
int dword_100B8538[] = { 0 }; // weak
int dword_100B853C[] = { 0 }; // weak
int dword_100B8540[] = { 0 }; // weak
int dword_100B8544[] = { 0 }; // weak
char off_100B8548[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B88A8[] = { 0 }; // weak
__int16 word_100B88AA[] = { 0 }; // weak
__int16 word_100B88AC[] = { 0 }; // weak
int dword_100B88B0[] = { 0 }; // weak
char *off_100B88B4 = "0, 0, 0"; // weak
int dword_100B8B68[] = { 0 }; // weak
int dword_100B8B6C[] = { 0 }; // weak
int dword_100B8B70[] = { 0 }; // weak
int dword_100B8B74[] = { 0 }; // weak
char off_100B8B78[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B8ED8[] = { 0 }; // weak
int dword_100B8EDC[] = { 0 }; // weak
int dword_100B8EE0[] = { 0 }; // weak
int dword_100B8EE4[] = { 0 }; // weak
int dword_100B8EE8[] = { 0 }; // weak
int dword_100B8EEC[] = { 0 }; // weak
int dword_100B8EF0[] = { 0 }; // weak
char off_100B8EF4[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B9458[] = { '\0' }; // weak
char byte_100B9459[] = { '\0' }; // weak
char byte_100B945A[] = { '\0' }; // weak
int dword_100B945C[] = { 0 }; // weak
char *off_100B9460 = "0, 0, 0"; // weak
int dword_100B9668[] = { 0 }; // weak
int dword_100B966C[] = { 0 }; // weak
int dword_100B9670[] = { 0 }; // weak
int dword_100B9674[] = { 0 }; // weak
char off_100B9678[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B99D8[] = { '\x01' }; // weak
char *off_100B99DC[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100B99E0[2] = { "1", "pass_normal_1" }; // weak
char off_100B99E4[8] = { '', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B9A28[] = { '\0' }; // weak
char byte_100B9A29[] = { '\0' }; // weak
int dword_100B9A2C[] = { 0 }; // weak
char *off_100B9A30 = "0, 0, 0"; // weak
double dbl_100B9C98[] = {  0.0 }; // weak
double dbl_100B9CA0[] = {  0.0 }; // weak
double dbl_100B9CA8[] = {  0.0 }; // weak
int dword_100B9CB0[] = { 0 }; // weak
char off_100B9CB4[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100BA8B8[] = {  0.0 }; // weak
float flt_100BA8BC[] = {  0.0 }; // weak
float flt_100BA8C0[] = {  0.0 }; // weak
int dword_100BA8C4[] = { 0 }; // weak
char off_100BA8C8[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BB050[] = { 0 }; // weak
int dword_100BB054[] = { 0 }; // weak
int dword_100BB058[] = { 0 }; // weak
int dword_100BB05C[] = { 0 }; // weak
char *off_100BB060 = "0, 0, 0"; // weak
__int16 word_100BB7E8[] = { 0 }; // weak
__int16 word_100BB7EA[] = { 0 }; // weak
__int16 word_100BB7EC[] = { 0 }; // weak
int dword_100BB7F0[] = { 0 }; // weak
char *off_100BB7F4 = "0, 0, 0"; // weak
int dword_100BBDF8[] = { 0 }; // weak
int dword_100BBDFC[] = { 0 }; // weak
int dword_100BBE00[] = { 0 }; // weak
int dword_100BBE04[] = { 0 }; // weak
char off_100BBE08[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BC590[] = { 0 }; // weak
int dword_100BC594[] = { 0 }; // weak
int dword_100BC598[] = { 0 }; // weak
int dword_100BC59C[] = { 0 }; // weak
int dword_100BC5A0[] = { 0 }; // weak
int dword_100BC5A4[] = { 0 }; // weak
int dword_100BC5A8[] = { 0 }; // weak
char off_100BC5AC[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BD1B0[] = { '\0' }; // weak
char byte_100BD1B1[] = { '\0' }; // weak
char byte_100BD1B2[] = { '\0' }; // weak
int dword_100BD1B4[] = { 0 }; // weak
char *off_100BD1B8 = "0, 0, 0"; // weak
int dword_100BD640[] = { 0 }; // weak
int dword_100BD644[] = { 0 }; // weak
int dword_100BD648[] = { 0 }; // weak
int dword_100BD64C[] = { 0 }; // weak
char *off_100BD650 = "0, 0, 0"; // weak
int dword_100BDDD8[] = { 0 }; // weak
int dword_100BDDDC[] = { 0 }; // weak
int dword_100BDDE0[] = { 0 }; // weak
int dword_100BDDE4[] = { 0 }; // weak
char off_100BDDE8[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100BE148[] = { 0 }; // weak
__int16 word_100BE14A[] = { 0 }; // weak
__int16 word_100BE14C[] = { 0 }; // weak
int dword_100BE150[] = { 0 }; // weak
char *off_100BE154 = "0, 0, 0"; // weak
int dword_100BE408[] = { 0 }; // weak
int dword_100BE40C[] = { 0 }; // weak
int dword_100BE410[] = { 0 }; // weak
int dword_100BE414[] = { 0 }; // weak
char off_100BE418[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BE778[] = { 0 }; // weak
int dword_100BE77C[] = { 0 }; // weak
int dword_100BE780[] = { 0 }; // weak
int dword_100BE784[] = { 0 }; // weak
int dword_100BE788[] = { 0 }; // weak
int dword_100BE78C[] = { 0 }; // weak
int dword_100BE790[] = { 0 }; // weak
char off_100BE794[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BECF8[] = { '\0' }; // weak
char byte_100BECF9[] = { '\0' }; // weak
char byte_100BECFA[] = { '\0' }; // weak
int dword_100BECFC[] = { 0 }; // weak
char *off_100BED00 = "0, 0, 0"; // weak
int dword_100BEF08[] = { 0 }; // weak
int dword_100BEF0C[] = { 0 }; // weak
int dword_100BEF10[] = { 0 }; // weak
int dword_100BEF14[] = { 0 }; // weak
char off_100BEF18[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BF278[] = { '\x01' }; // weak
char *off_100BF27C[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100BF280[2] = { "1", "pass_robust_1" }; // weak
char off_100BF284[8] = { 'X', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100BF2C8[] = { '\0' }; // weak
char byte_100BF2C9[] = { '\0' }; // weak
int dword_100BF2CC[] = { 0 }; // weak
char *off_100BF2D0 = "0, 0, 0"; // weak
double dbl_100BF538[] = {  0.0 }; // weak
double dbl_100BF540[] = {  0.0 }; // weak
double dbl_100BF548[] = {  0.0 }; // weak
int dword_100BF550[] = { 0 }; // weak
char off_100BF554[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100C0158[] = {  0.0 }; // weak
float flt_100C015C[] = {  0.0 }; // weak
float flt_100C0160[] = {  0.0 }; // weak
int dword_100C0164[] = { 0 }; // weak
char off_100C0168[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C08F0[] = { 0 }; // weak
int dword_100C08F4[] = { 0 }; // weak
int dword_100C08F8[] = { 0 }; // weak
int dword_100C08FC[] = { 0 }; // weak
char *off_100C0900 = "0, 0, 0"; // weak
__int16 word_100C1088[] = { 0 }; // weak
__int16 word_100C108A[] = { 0 }; // weak
__int16 word_100C108C[] = { 0 }; // weak
int dword_100C1090[] = { 0 }; // weak
char *off_100C1094 = "0, 0, 0"; // weak
int dword_100C1698[] = { 0 }; // weak
int dword_100C169C[] = { 0 }; // weak
int dword_100C16A0[] = { 0 }; // weak
int dword_100C16A4[] = { 0 }; // weak
char off_100C16A8[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C1E30[] = { 0 }; // weak
int dword_100C1E34[] = { 0 }; // weak
int dword_100C1E38[] = { 0 }; // weak
int dword_100C1E3C[] = { 0 }; // weak
int dword_100C1E40[] = { 0 }; // weak
int dword_100C1E44[] = { 0 }; // weak
int dword_100C1E48[] = { 0 }; // weak
char off_100C1E4C[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C2A50[] = { '\0' }; // weak
char byte_100C2A51[] = { '\0' }; // weak
char byte_100C2A52[] = { '\0' }; // weak
int dword_100C2A54[] = { 0 }; // weak
char *off_100C2A58 = "0, 0, 0"; // weak
int dword_100C2EE0[] = { 0 }; // weak
int dword_100C2EE4[] = { 0 }; // weak
int dword_100C2EE8[] = { 0 }; // weak
int dword_100C2EEC[] = { 0 }; // weak
char *off_100C2EF0 = "0, 0, 0"; // weak
int dword_100C3678[] = { 0 }; // weak
int dword_100C367C[] = { 0 }; // weak
int dword_100C3680[] = { 0 }; // weak
int dword_100C3684[] = { 0 }; // weak
char off_100C3688[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100C39E8[] = { 0 }; // weak
__int16 word_100C39EA[] = { 0 }; // weak
__int16 word_100C39EC[] = { 0 }; // weak
int dword_100C39F0[] = { 0 }; // weak
char *off_100C39F4 = "0, 0, 0"; // weak
int dword_100C3CA8[] = { 0 }; // weak
int dword_100C3CAC[] = { 0 }; // weak
int dword_100C3CB0[] = { 0 }; // weak
int dword_100C3CB4[] = { 0 }; // weak
char off_100C3CB8[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C4018[] = { 0 }; // weak
int dword_100C401C[] = { 0 }; // weak
int dword_100C4020[] = { 0 }; // weak
int dword_100C4024[] = { 0 }; // weak
int dword_100C4028[] = { 0 }; // weak
int dword_100C402C[] = { 0 }; // weak
int dword_100C4030[] = { 0 }; // weak
char off_100C4034[32] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C4598[] = { '\0' }; // weak
char byte_100C4599[] = { '\0' }; // weak
char byte_100C459A[] = { '\0' }; // weak
int dword_100C459C[] = { 0 }; // weak
char *off_100C45A0 = "0, 0, 0"; // weak
int dword_100C47A8[] = { 0 }; // weak
int dword_100C47AC[] = { 0 }; // weak
int dword_100C47B0[] = { 0 }; // weak
int dword_100C47B4[] = { 0 }; // weak
char off_100C47B8[20] =
{
  '(',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100C5798; // weak
_UNKNOWN unk_100DB232; // weak
int dword_100DB234 = 9429; // idb
int dword_100DBF2C[] = { 9826 }; // weak
_UNKNOWN unk_100DBF30; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100DD294 = "006-D0170-"; // weak
int (__cdecl *(*off_100DD298)[2])(int, int) = &off_100F6338; // weak
_UNKNOWN unk_100DE210; // weak
_UNKNOWN unk_100DE278; // weak
_UNKNOWN unk_100DE2DC; // weak
char *off_100DE3A8 = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
_UNKNOWN unk_100DE4E8; // weak
int dword_100DE4EC[] = { 256 }; // weak
char byte_100DE4F0[] = { '\0' }; // weak
char byte_100DE4F1[] = { '\0' }; // weak
char byte_100DE4F2[] = { '\0' }; // weak
_UNKNOWN unk_100DFBD8; // weak
_UNKNOWN unk_100DFBD9; // weak
__int16 word_100E15B8[] = { 0 }; // weak
__int16 word_100E17B8[] = { 43 }; // weak
char byte_100E17BC[] = { '\x06' }; // weak
_UNKNOWN unk_100E2C60; // weak
char *off_100E2E04[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100E2E18 }; // weak
char *off_100E2FA8 = "true"; // weak
char byte_100E2FAC[] = { '\x01' }; // weak
char *off_100E3010 = "failure listener"; // weak
char *off_100E39F0 = "printf_listener"; // weak
__int16 word_100E4624 = 2573; // weak
char *off_100E4780 = "gate_listener"; // weak
_BYTE word_100E4BAE[118] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0
}; // idb
char byte_100E4C25[] = { '\x1E' }; // weak
_UNKNOWN unk_100E5AD8; // weak
char byte_100E5AD9[] = { '\0' }; // weak
_UNKNOWN unk_100E5B98; // weak
_UNKNOWN unk_100E7CC8; // weak
_UNKNOWN unk_100E7CCC; // weak
_UNKNOWN unk_100E7CD0; // weak
_UNKNOWN unk_100E7CD4; // weak
_UNKNOWN unk_100E7CD8; // weak
_UNKNOWN unk_100E7CDC; // weak
_UNKNOWN unk_100E8390; // weak
void *off_100E8394 = &unk_100E7CC8; // weak
_UNKNOWN unk_100E8440; // weak
void *off_100E8444 = &unk_100E7CC8; // weak
void *off_100E8450 = &unk_100E7CCC; // weak
void *off_100E845C = &unk_100E7CD0; // weak
void *off_100E8468 = &unk_100E7CD4; // weak
void *off_100E8474 = &unk_100E7CD8; // weak
void *off_100E8900 = &unk_100E7D38; // weak
void *off_100E890C = &unk_100E7D04; // weak
void *off_100E8918 = &unk_100E7D84; // weak
void *off_100E8924 = &unk_100E7DB8; // weak
void *off_100E8930 = &unk_100E7E88; // weak
void *off_100E893C = &unk_100E7E74; // weak
void *off_100E8948 = &unk_100E7F64; // weak
void *off_100E8954 = &unk_100E7F88; // weak
void *off_100E8960 = &unk_100E7FAC; // weak
void *off_100E896C = &unk_100E7FD0; // weak
void *off_100E8978 = &unk_100E7CD8; // weak
void *off_100E8990 = &unk_100E7CC8; // weak
void *off_100E899C = &unk_100E7CCC; // weak
void *off_100E89A8 = &unk_100E82DC; // weak
void *off_100E89B4 = &unk_100E7CD4; // weak
void *off_100E89C0 = &unk_100E7CD8; // weak
void *off_100E89CC = &unk_100E7CDC; // weak
void *off_100E89D8 = &unk_100E7CC8; // weak
void *off_100E89E4 = &unk_100E82E8; // weak
void *off_100E89F0 = &unk_100E7CD0; // weak
void *off_100E89FC = &unk_100E7CD4; // weak
void *off_100E8A08 = &unk_100E7CD8; // weak
void *off_100E8A14 = &unk_100E7CDC; // weak
_UNKNOWN unk_100E8A20; // weak
void *off_100E8A24 = &unk_100E7CCC; // weak
void *off_100E8A30 = &unk_100E7F54; // weak
_UNKNOWN unk_100E8CE4; // weak
_UNKNOWN unk_100E8CE8; // weak
_UNKNOWN unk_100E8CEC; // weak
_UNKNOWN unk_100E8CF4; // weak
_UNKNOWN unk_100E8CF8; // weak
_UNKNOWN unk_100E8DA0; // weak
_UNKNOWN unk_100E8DB0; // weak
_UNKNOWN unk_100E8EA4; // weak
_UNKNOWN unk_100E8F30; // weak
_UNKNOWN unk_100E8F34; // weak
_UNKNOWN unk_100E8F38; // weak
_UNKNOWN unk_100E8F8C; // weak
_UNKNOWN unk_100E8FB0; // weak
void *off_100ED194 = &unk_100ECAA0; // weak
void *off_100ED19C = &unk_100ECAA4; // weak
void *off_100ED1A4 = &unk_100ECAA8; // weak
void *off_100ED1AC = &unk_100ECAAC; // weak
void *off_100ED1B4 = &unk_100ECAB0; // weak
void *off_100EDA58 = &unk_100ECAA0; // weak
void *off_100EDA60 = &unk_100ECAA4; // weak
void *off_100EDA68 = &unk_100ECAA8; // weak
void *off_100EDA70 = &unk_100ECAAC; // weak
void *off_100EDA78 = &unk_100ECAB0; // weak
void *off_100EDBE8 = &unk_100ECAA0; // weak
void *off_100EDBF0 = &unk_100ECAA4; // weak
void *off_100EDBF8 = &unk_100ECAA8; // weak
void *off_100EDC00 = &unk_100ECAAC; // weak
void *off_100EDC08 = &unk_100ECAB0; // weak
void *off_100EDC88 = &unk_100ECAA0; // weak
void *off_100EDC90 = &unk_100ECAA4; // weak
void *off_100EDC98 = &unk_100ECAA8; // weak
void *off_100EDCA0 = &unk_100ECAAC; // weak
void *off_100EDCA8 = &unk_100ECAB0; // weak
void *off_100EDE44 = &unk_100ECAA0; // weak
void *off_100EDE4C = &unk_100ECAA4; // weak
void *off_100EDE54 = &unk_100ECAA8; // weak
void *off_100EDE5C = &unk_100ECAAC; // weak
void *off_100EDE64 = &unk_100ECAB0; // weak
void *off_100EDFA0 = &unk_100ECAA0; // weak
void *off_100EDFA8 = &unk_100ECAA4; // weak
void *off_100EDFB0 = &unk_100ECAA8; // weak
void *off_100EDFB8 = &unk_100ECAAC; // weak
void *off_100EDFC0 = &unk_100ECAB0; // weak
void *off_100EE018 = &unk_100ECAA0; // weak
void *off_100EE020 = &unk_100ECAA4; // weak
void *off_100EE028 = &unk_100E9880; // weak
void *off_100EE030 = &unk_100ECAAC; // weak
void *off_100EE038 = &unk_100ECAB0; // weak
void *off_100EE040 = &unk_100EC158; // weak
void *off_100EE048 = &unk_100ECAA4; // weak
void *off_100EE050 = &unk_100EC168; // weak
void *off_100EE058 = &unk_100ECAAC; // weak
void *off_100EE060 = &unk_100ECAB0; // weak
void *off_100EE068 = &unk_100EBD08; // weak
void *off_100EE070 = &unk_100EBE28; // weak
void *off_100EE078 = &unk_100EBF20; // weak
void *off_100EE080 = &unk_100EBFA0; // weak
void *off_100EE088 = &unk_100EC0C4; // weak
void *off_100EE094 = &unk_100ECAA0; // weak
void *off_100EE09C = &unk_100ECAA4; // weak
void *off_100EE0A4 = &unk_100ECAA8; // weak
void *off_100EE0AC = &unk_100ECAAC; // weak
void *off_100EE0B4 = &unk_100ECAB0; // weak
void *off_100EE904 = &unk_100ECAA0; // weak
void *off_100EE90C = &unk_100ECAA4; // weak
void *off_100EE914 = &unk_100ECAA8; // weak
void *off_100EE91C = &unk_100ECAAC; // weak
void *off_100EE924 = &unk_100ECAB0; // weak
void *off_100EEE24 = &unk_100ECAA0; // weak
void *off_100EEE2C = &unk_100ECE1C; // weak
void *off_100EEE34 = &unk_100ECAA8; // weak
void *off_100EEE3C = &unk_100ECAAC; // weak
void *off_100EEE44 = &unk_100ECAB0; // weak
void *off_100EEE4C = &unk_100ECE6C; // weak
void *off_100EEE54 = &unk_100ECE7C; // weak
void *off_100EEE5C = &unk_100ECEB4; // weak
void *off_100EEE64 = &unk_100ECAAC; // weak
void *off_100EEE6C = &unk_100ECAB0; // weak
void *off_100EEE74 = &unk_100ECAA0; // weak
void *off_100EEE9C = &unk_100ECAA0; // weak
_UNKNOWN unk_100EEF48; // weak
_UNKNOWN unk_100EEF4C; // weak
_UNKNOWN unk_100EEF50; // weak
_UNKNOWN unk_100EEFD8; // weak
_UNKNOWN unk_100EF04C; // weak
void *off_100EF12C = &unk_100EF084; // weak
void *off_100EF134 = &unk_100EF088; // weak
void *off_100EF13C = &unk_100EF0F0; // weak
void *off_100EF144 = &unk_100EF0F4; // weak
void *off_100EF14C = &unk_100EF124; // weak
_UNKNOWN unk_100EF158; // weak
_UNKNOWN unk_100EF15C; // weak
_UNKNOWN unk_100EF160; // weak
_UNKNOWN unk_100EF164; // weak
_UNKNOWN unk_100EF168; // weak
_UNKNOWN unk_100EF16C; // weak
_UNKNOWN unk_100EF170; // weak
_UNKNOWN unk_100EF19C; // weak
_UNKNOWN unk_100EF1C0; // weak
_UNKNOWN unk_100EF1F0; // weak
_UNKNOWN unk_100EF268; // weak
_UNKNOWN unk_100EF360; // weak
_UNKNOWN unk_100EF36C; // weak
_UNKNOWN unk_100EF380; // weak
void *off_100EF390 = &unk_100EF1E4; // weak
void *off_100EF3A0 = &unk_100EF2D0; // weak
void *off_100EF3B0 = &unk_100EF300; // weak
void *off_100EF3C0 = &unk_100EF330; // weak
void *off_100EF3D0 = &unk_100EF168; // weak
void *off_100EF3E0 = &unk_100EF16C; // weak
_UNKNOWN unk_100EF3F0; // weak
_UNKNOWN unk_100EF3F4; // weak
_UNKNOWN unk_100EF428; // weak
_UNKNOWN unk_100EF458; // weak
_UNKNOWN unk_100EF498; // weak
_UNKNOWN unk_100EF4C0; // weak
_UNKNOWN unk_100EF4C4; // weak
_UNKNOWN unk_100EF4E0; // weak
_UNKNOWN unk_100EF524; // weak
_UNKNOWN unk_100EF538; // weak
_WORD dword_100EF560[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100EF960[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100EFD60[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100F0160[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100F0560[] = { 99 }; // weak
int dword_100F0960[] = { 25344 }; // weak
int dword_100F0D60[] = { 6488064 }; // weak
int dword_100F1160[] = { 1660944384 }; // weak
int dword_100F1588[] = { 128 }; // weak
int dword_100F1598[] = { 0 }; // weak
int dword_100F15A8[] = { 0 }; // weak
char byte_100F1619[] = { '\0' }; // weak
char byte_100F161A[] = { '\0' }; // weak
char byte_100F161B[] = { '\0' }; // weak
char byte_100F161C[] = { '\x10' }; // weak
int dword_100F1630[] = { 0 }; // weak
_UNKNOWN unk_100F16A8; // weak
_UNKNOWN unk_100F1B28; // weak
char byte_100F1BA0[] = { '\0' }; // weak
char byte_100F1CA0[] = { '\0' }; // weak
char byte_100F1DA0[] = { '\0' }; // weak
int dword_100F1EA0[] = { 0 }; // weak
int dword_100F1F18[] = { 0 }; // weak
__int16 word_100F1F90[] = { 0 }; // weak
__int16 word_100F1F92[] = { 0 }; // weak
__int16 word_100F1F94[] = { 0 }; // weak
__int16 word_100F1F96[] = { 0 }; // weak
int (__cdecl *off_100F1F98)(int, int) = &sub_10047EA0; // weak
void *off_100F2144 = &unk_100F16A8; // weak
void *off_100F2158 = &unk_100F1B28; // weak
_UNKNOWN unk_100F216C; // weak
int dword_100F2180[] = { 0 }; // weak
int dword_100F21C8[] = { 16 }; // weak
_UNKNOWN unk_100F2218; // weak
_UNKNOWN unk_100F2298; // weak
_UNKNOWN unk_100F2318; // weak
_UNKNOWN unk_100F2390; // weak
_UNKNOWN unk_100F2408; // weak
_UNKNOWN unk_100F3408; // weak
_UNKNOWN unk_100F35F4; // weak
_UNKNOWN unk_100F3618; // weak
_UNKNOWN unk_100F37C0; // weak
int (__cdecl *off_100F6338[2])(int, int) = { &sub_1004B7C0, &sub_1004B820 }; // weak
_UNKNOWN unk_100F8010; // weak
__int16 word_100F8012[] = { 82 }; // weak
char byte_100F8E98[] = { '\x01' }; // weak
__int16 word_100F8E9A[] = { 3020 }; // weak
char byte_100FA760[] = { '\x01' }; // weak
__int16 word_100FA768[] = { 3020 }; // weak
int dword_100FBE5C[] = { 0 }; // weak
__int16 *off_100FBE60 = &word_100E4624; // weak
_UNKNOWN unk_100FBEF0; // weak
_UNKNOWN unk_100FBEF4; // weak
_UNKNOWN unk_100FBEF8; // weak
_UNKNOWN unk_100FBEFC; // weak
_UNKNOWN unk_100FBF00; // weak
_UNKNOWN unk_100FBF04; // weak
_UNKNOWN unk_100FBF08; // weak
_UNKNOWN unk_100FBF0C; // weak
int dword_10102798[] = { 0 }; // weak
_UNKNOWN unk_1010D780; // weak
_UNKNOWN unk_1010D788; // weak
int (*off_1010F264[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_1010F288; // weak
void *off_1010FCF0 = &unk_10223540; // weak
_UNKNOWN unk_1010FD00; // weak
_UNKNOWN unk_1010FD60; // weak
int dword_1010FF70 = 2; // weak
int dword_10110140 = 1024; // weak
int dword_10110144 = 4294966273; // weak
int dword_10110148 = 53; // weak
int dword_1011014C = 11; // weak
int dword_10110150 = 64; // weak
int dword_10110154 = 1023; // weak
int dword_10110158 = 128; // weak
int dword_1011015C = 4294967169; // weak
int dword_10110160 = 24; // weak
int dword_10110164 = 8; // weak
int dword_10110168 = 32; // weak
int dword_1011016C = 127; // weak
_UNKNOWN unk_10110844; // weak
_UNKNOWN unk_10110848; // weak
_UNKNOWN unk_1011084C; // weak
_UNKNOWN unk_10110850; // weak
__int16 word_10110854 = 0; // weak
char byte_10110858 = '\0'; // weak
char byte_10110859 = '\0'; // weak
char byte_10110860 = '\0'; // weak
char byte_10110868 = '\0'; // weak
char byte_1011086A = '\0'; // weak
char byte_1011086B = '\0'; // weak
char byte_1011086C = '\0'; // weak
char byte_10110876 = '\0'; // weak
char byte_10110878 = '\0'; // weak
__int16 word_1011087C = 0; // weak
int dword_10110884 = 0; // weak
float flt_10110894 =  0.0; // weak
float flt_101108B0 =  0.0; // weak
float flt_101108B4 =  0.0; // weak
float flt_101108B8 =  0.0; // weak
float flt_101108BC =  0.0; // weak
float flt_101108C0 =  0.0; // weak
float flt_101108C4 =  0.0; // weak
float flt_101108DC =  0.0; // weak
__int16 word_101108F4 = 0; // weak
__int16 word_101108F6 = 0; // weak
char byte_101108F8 = '\0'; // weak
char byte_101108F9 = '\0'; // weak
float flt_101108FC =  0.0; // weak
char byte_10110900 = '\0'; // weak
float flt_10110904 =  0.0; // weak
int dword_10110908 = 0; // weak
int dword_1011090C = 0; // weak
void *dword_10110910 = NULL; // idb
int dword_10110914 = 0; // weak
int dword_10110918 = 0; // weak
int dword_1011091C = 0; // weak
int dword_10110920 = 0; // weak
int dword_10110924 = 0; // weak
int dword_10110928 = 0; // weak
int dword_10116128; // weak
int dword_1011612C; // weak
char byte_10116130; // weak
int dword_10116134; // weak
int dword_10116138; // weak
int dword_1011613C; // weak
int dword_10116140; // weak
int dword_1011B940; // weak
int dword_1011B944; // weak
char byte_1011B948; // weak
_UNKNOWN unk_1011B950; // weak
__int16 word_1011B952; // weak
float flt_1011B974; // weak
float flt_1011B978; // weak
_UNKNOWN unk_1011B9A4; // weak
int dword_1011B9F0; // weak
char byte_1011B9F8; // weak
char byte_1011B9F9; // weak
int dword_1011B9FC; // weak
int dword_1011BA00; // weak
int dword_1011BA04; // weak
_UNKNOWN unk_1011BA08; // weak
int dword_1011EED8; // weak
int dword_1011EEDC; // weak
_UNKNOWN unk_1011EEE0; // weak
int dword_1011FD44; // weak
int dword_1011FD48; // weak
int dword_1011FD4C; // weak
char byte_1011FD70; // weak
char byte_1011FD74; // weak
int dword_1011FD78; // weak
int dword_1011FD7C; // weak
int dword_1011FD80[]; // weak
int dword_1011FD90; // weak
char byte_1011FD94; // weak
char byte_1011FD98[]; // weak
int dword_1011FD9C; // weak
int dword_1011FDA0; // weak
int dword_1011FDA4; // weak
int dword_1011FDA8; // weak
int dword_1011FDAC; // weak
int dword_1011FDB0; // weak
int dword_1011FDB4; // weak
int dword_1011FDB8; // weak
int dword_1011FDBC; // weak
int dword_1011FDC0[]; // weak
char byte_1011FDC8[]; // weak
char byte_1011FDCA; // weak
char byte_1011FDCB; // weak
__int16 word_1011FDD0; // weak
char byte_1011FDD2; // weak
char byte_1011FDD3; // weak
char byte_1011FDD4[]; // weak
_UNKNOWN unk_1011FDD8; // weak
char byte_10120640[]; // weak
char byte_10120641[]; // weak
char byte_10120668[]; // weak
int dword_1012066C; // weak
int dword_10120670[]; // weak
_UNKNOWN unk_10120680; // weak
_UNKNOWN unk_10120681; // weak
_UNKNOWN unk_10120720; // weak
_UNKNOWN unk_10120721; // weak
int dword_101209F0[]; // weak
int dword_101209F4[]; // weak
char byte_10120A70; // weak
_UNKNOWN unk_10120A71; // weak
__int16 word_10120F10; // weak
char byte_10120F12; // weak
char byte_10120F18[100]; // idb
int dword_10120F7C; // weak
_UNKNOWN unk_10120F80; // weak
int dword_10121000; // weak
int dword_10121004; // weak
char dword_10121008[]; // idb
int dword_10121014; // weak
int dword_10121018; // weak
int dword_1012101C; // weak
int dword_10121020; // weak
void *dword_10121028; // idb
int dword_1012102C; // weak
_BYTE byte_10121030[836]; // idb
int dword_10121374; // weak
int dword_10121378; // weak
int dword_1012137C; // weak
int dword_10121380; // weak
int dword_10121384; // weak
int dword_10121388; // weak
int dword_1012138C; // weak
int dword_10121390; // weak
int dword_10121394; // weak
int dword_10121398; // weak
int dword_1012139C; // weak
int dword_101213A0; // weak
int dword_101213A4; // weak
char byte_101213A8; // weak
char byte_101213A9; // weak
char byte_101213AA; // weak
int dword_101213AC; // weak
int dword_101213B0; // weak
char byte_101213B8; // weak
__int16 word_101213BA; // weak
int dword_101213BC; // weak
int dword_101213C4; // weak
char byte_10121469; // weak
char byte_1012146A; // weak
char byte_1012146B; // weak
int dword_1012146C; // weak
int dword_1012D42C; // weak
int dword_1012D74C; // weak
int dword_10133020; // weak
int dword_10133024; // weak
int dword_10133028; // weak
int dword_101330B4; // weak
char byte_101330B8; // weak
char byte_101330B9; // weak
int dword_101330C0; // weak
char byte_101330C4; // weak
char byte_101330C5; // weak
char byte_101330C6; // weak
float flt_101330C8; // weak
float flt_101330CC; // weak
int dword_101330D0; // weak
float flt_101330D4; // weak
float flt_101330D8; // weak
int dword_101330DC; // weak
int dword_101330E0; // weak
int dword_101330E4; // weak
float flt_101330E8[]; // weak
int dword_10133408; // weak
int dword_1013340C; // weak
int dword_10133410; // weak
int dword_10133414; // weak
float flt_10133418; // weak
char byte_10133420; // weak
char byte_10133421; // weak
int dword_10133424; // weak
int dword_10133428; // weak
int dword_1013342C; // weak
int dword_10133430; // weak
int dword_10133434; // weak
char byte_10133438; // weak
int dword_10138C3C; // weak
int dword_10138C40; // weak
int dword_10138C44; // weak
int dword_10138C48; // weak
_UNKNOWN unk_10138C50; // weak
_UNKNOWN unk_10138FF8; // weak
_UNKNOWN unk_10138FF9; // weak
_UNKNOWN unk_1013900F; // weak
_UNKNOWN unk_10139010; // weak
_UNKNOWN unk_10139011; // weak
_UNKNOWN unk_10139012; // weak
_UNKNOWN unk_10139014; // weak
_UNKNOWN unk_10139018; // weak
_UNKNOWN unk_1013901C; // weak
_UNKNOWN unk_1013903C; // weak
_UNKNOWN unk_1013905C; // weak
_UNKNOWN unk_1013907C; // weak
_UNKNOWN unk_1013909C; // weak
_UNKNOWN unk_101390BC; // weak
_UNKNOWN unk_101390DC; // weak
_UNKNOWN unk_101390FC; // weak
_UNKNOWN unk_1013911C; // weak
_UNKNOWN unk_1013913C; // weak
_UNKNOWN unk_1013915C; // weak
_UNKNOWN unk_1013917C; // weak
_UNKNOWN unk_1013919C; // weak
_UNKNOWN unk_101391BC; // weak
_UNKNOWN unk_101391DC; // weak
_UNKNOWN unk_101391FC; // weak
_UNKNOWN unk_1013921C; // weak
_UNKNOWN unk_1013923C; // weak
_UNKNOWN unk_1013925C; // weak
_UNKNOWN unk_1013927C; // weak
_UNKNOWN unk_1013929C; // weak
_UNKNOWN unk_101392BC; // weak
_UNKNOWN unk_101392DC; // weak
_UNKNOWN unk_101392FC; // weak
_UNKNOWN unk_1013931C; // weak
_UNKNOWN unk_1013933C; // weak
_UNKNOWN unk_1013935C; // weak
_UNKNOWN unk_1013937C; // weak
_UNKNOWN unk_1013939C; // weak
_UNKNOWN unk_101393A0; // weak
_UNKNOWN unk_101393A4; // weak
_UNKNOWN unk_101393A8; // weak
_UNKNOWN unk_101393AC; // weak
_UNKNOWN unk_101393B0; // weak
_UNKNOWN unk_101393B4; // weak
_UNKNOWN unk_101393D4; // weak
_UNKNOWN unk_101393F4; // weak
_UNKNOWN unk_10139414; // weak
_UNKNOWN unk_10139434; // weak
_UNKNOWN unk_10139454; // weak
_UNKNOWN unk_10139474; // weak
_UNKNOWN unk_10139494; // weak
_UNKNOWN unk_101394B4; // weak
_UNKNOWN unk_101394B5; // weak
_UNKNOWN unk_101394B6; // weak
_UNKNOWN unk_10139508; // weak
_UNKNOWN unk_10139528; // weak
_UNKNOWN unk_10139548; // weak
_UNKNOWN unk_1013954C; // weak
_UNKNOWN unk_10139550; // weak
_UNKNOWN unk_10139554; // weak
_UNKNOWN unk_10139574; // weak
_UNKNOWN unk_10139594; // weak
_UNKNOWN unk_101395B4; // weak
_UNKNOWN unk_101395D4; // weak
_UNKNOWN unk_101395F4; // weak
_UNKNOWN unk_10139614; // weak
_UNKNOWN unk_10139634; // weak
_UNKNOWN unk_10139654; // weak
_UNKNOWN unk_10139674; // weak
_UNKNOWN unk_101396BC; // weak
_UNKNOWN unk_10139704; // weak
_UNKNOWN unk_1013974C; // weak
_UNKNOWN unk_10139794; // weak
_UNKNOWN unk_101397DC; // weak
_UNKNOWN unk_10139824; // weak
_UNKNOWN unk_1013986C; // weak
_UNKNOWN unk_101398B4; // weak
_UNKNOWN unk_101398FC; // weak
_UNKNOWN unk_10139944; // weak
_UNKNOWN unk_1013998C; // weak
_UNKNOWN unk_101399D4; // weak
_UNKNOWN unk_10139A1C; // weak
_UNKNOWN unk_10139A64; // weak
_UNKNOWN unk_10139AAC; // weak
_UNKNOWN unk_10139AF4; // weak
_UNKNOWN unk_10139B3C; // weak
_UNKNOWN unk_10139B84; // weak
_UNKNOWN unk_10139BCC; // weak
_UNKNOWN unk_10139C14; // weak
_UNKNOWN unk_10139C5C; // weak
_UNKNOWN unk_10139CA4; // weak
_UNKNOWN unk_10139CEC; // weak
_UNKNOWN unk_10139D34; // weak
_UNKNOWN unk_10139D7C; // weak
_UNKNOWN unk_10139DC4; // weak
_UNKNOWN unk_10139E0C; // weak
_UNKNOWN unk_10139E54; // weak
_UNKNOWN unk_10139E9C; // weak
_UNKNOWN unk_10139EE4; // weak
_UNKNOWN unk_10139EFC; // weak
_UNKNOWN unk_10139F1C; // weak
_UNKNOWN unk_10139F3C; // weak
_UNKNOWN unk_10139F40; // weak
_UNKNOWN unk_10139FE4; // weak
_UNKNOWN unk_1013A088; // weak
_UNKNOWN unk_1013A12C; // weak
_UNKNOWN unk_1013A1D0; // weak
_UNKNOWN unk_1013A274; // weak
_UNKNOWN unk_1013A318; // weak
_UNKNOWN unk_1013A3BC; // weak
_UNKNOWN unk_1013A460; // weak
_UNKNOWN unk_1013A504; // weak
_UNKNOWN unk_1013A5A8; // weak
_UNKNOWN unk_1013A64C; // weak
_UNKNOWN unk_1013A6F0; // weak
_UNKNOWN unk_1013A794; // weak
_UNKNOWN unk_1013A838; // weak
_UNKNOWN unk_1013A8DC; // weak
_UNKNOWN unk_1013A980; // weak
_UNKNOWN unk_1013AA24; // weak
_UNKNOWN unk_1013AAC8; // weak
_UNKNOWN unk_1013AB6C; // weak
_UNKNOWN unk_1013AC10; // weak
_UNKNOWN unk_1013ACB4; // weak
_UNKNOWN unk_1013AD58; // weak
_UNKNOWN unk_1013ADFC; // weak
_UNKNOWN unk_1013AEA0; // weak
_UNKNOWN unk_1013AF44; // weak
_UNKNOWN unk_1013AFE8; // weak
_UNKNOWN unk_1013B08C; // weak
_UNKNOWN unk_1013B130; // weak
_UNKNOWN unk_1013B1D4; // weak
_UNKNOWN unk_1013B278; // weak
_UNKNOWN unk_1013B31C; // weak
_UNKNOWN unk_1013B3C0; // weak
_UNKNOWN unk_1013B464; // weak
_UNKNOWN unk_1013B508; // weak
_UNKNOWN unk_1013B5AC; // weak
_UNKNOWN unk_1013B650; // weak
_UNKNOWN unk_1013B6F4; // weak
_UNKNOWN unk_1013B798; // weak
_UNKNOWN unk_1013B83C; // weak
_UNKNOWN unk_1013B8E0; // weak
_UNKNOWN unk_1013B984; // weak
_UNKNOWN unk_1013BA28; // weak
_UNKNOWN unk_1013BACC; // weak
_UNKNOWN unk_1013BB70; // weak
_UNKNOWN unk_1013BC14; // weak
_UNKNOWN unk_1013BCB8; // weak
_UNKNOWN unk_1013BD5C; // weak
_UNKNOWN unk_1013BE00; // weak
_UNKNOWN unk_1013BEA4; // weak
_UNKNOWN unk_1013BF48; // weak
_UNKNOWN unk_1013BFEC; // weak
_UNKNOWN unk_1013C090; // weak
_UNKNOWN unk_1013C134; // weak
_UNKNOWN unk_1013C1D8; // weak
_UNKNOWN unk_1013C27C; // weak
_UNKNOWN unk_1013C320; // weak
_UNKNOWN unk_1013C3C4; // weak
_UNKNOWN unk_1013C468; // weak
_UNKNOWN unk_1013C50C; // weak
_UNKNOWN unk_1013C5B0; // weak
_UNKNOWN unk_1013C654; // weak
_UNKNOWN unk_1013C6F8; // weak
_UNKNOWN unk_1013C79C; // weak
_UNKNOWN unk_1013C840; // weak
_UNKNOWN unk_1013C8E4; // weak
_UNKNOWN unk_1013C988; // weak
_UNKNOWN unk_1013CA2C; // weak
_UNKNOWN unk_1013CAD0; // weak
_UNKNOWN unk_1013CB74; // weak
_UNKNOWN unk_1013CC18; // weak
_UNKNOWN unk_1013CCBC; // weak
_UNKNOWN unk_1013CD60; // weak
_UNKNOWN unk_1013CE04; // weak
_UNKNOWN unk_1013CEA8; // weak
_UNKNOWN unk_1013CF4C; // weak
_UNKNOWN unk_1013CFF0; // weak
_UNKNOWN unk_1013D094; // weak
_UNKNOWN unk_1013D138; // weak
_UNKNOWN unk_1013D1DC; // weak
_UNKNOWN unk_1013D280; // weak
_UNKNOWN unk_1013D324; // weak
_UNKNOWN unk_1013D3C8; // weak
_UNKNOWN unk_1013D46C; // weak
_UNKNOWN unk_1013D510; // weak
_UNKNOWN unk_1013D5B4; // weak
_UNKNOWN unk_1013D658; // weak
_UNKNOWN unk_1013D6FC; // weak
_UNKNOWN unk_1013D7A0; // weak
_UNKNOWN unk_1013D844; // weak
_UNKNOWN unk_1013D8E8; // weak
_UNKNOWN unk_1013D98C; // weak
_UNKNOWN unk_1013DA30; // weak
_UNKNOWN unk_1013DAD4; // weak
_UNKNOWN unk_1013DB78; // weak
_UNKNOWN unk_1013DC1C; // weak
_UNKNOWN unk_1013DCC0; // weak
_UNKNOWN unk_1013DD64; // weak
_UNKNOWN unk_1013DE08; // weak
_UNKNOWN unk_1013DEAC; // weak
_UNKNOWN unk_1013DF50; // weak
_UNKNOWN unk_1013DF70; // weak
_UNKNOWN unk_1013DF90; // weak
_UNKNOWN unk_1013DFB0; // weak
_UNKNOWN unk_1013DFD0; // weak
_UNKNOWN unk_1013DFF8; // weak
_UNKNOWN unk_1013E014; // weak
_UNKNOWN unk_1013E030; // weak
_UNKNOWN unk_1013E04C; // weak
_UNKNOWN unk_1013E068; // weak
_UNKNOWN unk_1013E084; // weak
_UNKNOWN unk_1013E0A0; // weak
_UNKNOWN unk_1013E0BC; // weak
_UNKNOWN unk_1013E0D8; // weak
_UNKNOWN unk_1013E0F4; // weak
_UNKNOWN unk_1013E110; // weak
_UNKNOWN unk_1013E12C; // weak
_UNKNOWN unk_1013E148; // weak
_UNKNOWN unk_1013E164; // weak
_UNKNOWN unk_1013E180; // weak
_UNKNOWN unk_1013E19C; // weak
_UNKNOWN unk_1013E1B8; // weak
_UNKNOWN unk_1013E1D4; // weak
_UNKNOWN unk_1013E1F0; // weak
_UNKNOWN unk_1013E20C; // weak
_UNKNOWN unk_1013E228; // weak
_UNKNOWN unk_1013E244; // weak
_UNKNOWN unk_1013E260; // weak
_UNKNOWN unk_1013E27C; // weak
_UNKNOWN unk_1013E298; // weak
_UNKNOWN unk_1013E2B4; // weak
_UNKNOWN unk_1013E2D0; // weak
_UNKNOWN unk_1013E2EC; // weak
_UNKNOWN unk_1013E308; // weak
_UNKNOWN unk_1013E324; // weak
_UNKNOWN unk_1013E340; // weak
_UNKNOWN unk_1013E35C; // weak
_UNKNOWN unk_1013E378; // weak
_UNKNOWN unk_1013E394; // weak
_UNKNOWN unk_1013E3B0; // weak
_UNKNOWN unk_1013E3CC; // weak
_UNKNOWN unk_1013E3E8; // weak
_UNKNOWN unk_1013E404; // weak
_UNKNOWN unk_1013E420; // weak
_UNKNOWN unk_1013E43C; // weak
_UNKNOWN unk_1013E458; // weak
_UNKNOWN unk_1013E474; // weak
_UNKNOWN unk_1013E490; // weak
_UNKNOWN unk_1013E4AC; // weak
_UNKNOWN unk_1013E4C8; // weak
_UNKNOWN unk_1013E4E4; // weak
_UNKNOWN unk_1013E500; // weak
_UNKNOWN unk_1013E51C; // weak
_UNKNOWN unk_1013E538; // weak
_UNKNOWN unk_1013E554; // weak
_UNKNOWN unk_1013E570; // weak
_UNKNOWN unk_1013E58C; // weak
_UNKNOWN unk_1013E5A8; // weak
_UNKNOWN unk_1013E5C4; // weak
_UNKNOWN unk_1013E5E0; // weak
_UNKNOWN unk_1013E5FC; // weak
_UNKNOWN unk_1013E618; // weak
_UNKNOWN unk_1013E634; // weak
_UNKNOWN unk_1013E650; // weak
_UNKNOWN unk_1013E66C; // weak
_UNKNOWN unk_1013E688; // weak
_UNKNOWN unk_1013E6A4; // weak
_UNKNOWN unk_1013E6C0; // weak
_UNKNOWN unk_1013E6DC; // weak
_UNKNOWN unk_1013E6F8; // weak
_UNKNOWN unk_1013E714; // weak
_UNKNOWN unk_1013E730; // weak
_UNKNOWN unk_1013E74C; // weak
_UNKNOWN unk_1013E768; // weak
_UNKNOWN unk_1013E784; // weak
_UNKNOWN unk_1013E7A0; // weak
_UNKNOWN unk_1013E7BC; // weak
_UNKNOWN unk_1013E7D8; // weak
_UNKNOWN unk_1013E7F4; // weak
_UNKNOWN unk_1013E810; // weak
_UNKNOWN unk_1013E82C; // weak
_UNKNOWN unk_1013E848; // weak
_UNKNOWN unk_1013E864; // weak
_UNKNOWN unk_1013E880; // weak
_UNKNOWN unk_1013E89C; // weak
_UNKNOWN unk_1013E8B8; // weak
_UNKNOWN unk_1013E8D4; // weak
_UNKNOWN unk_1013E8F0; // weak
_UNKNOWN unk_1013E90C; // weak
_UNKNOWN unk_1013E928; // weak
_UNKNOWN unk_1013E944; // weak
_UNKNOWN unk_1013E960; // weak
_UNKNOWN unk_1013E97C; // weak
_UNKNOWN unk_1013E998; // weak
_UNKNOWN unk_1013E9B4; // weak
_UNKNOWN unk_1013E9D0; // weak
_UNKNOWN unk_1013E9EC; // weak
_UNKNOWN unk_1013EA08; // weak
_UNKNOWN unk_1013EA24; // weak
_UNKNOWN unk_1013EA40; // weak
_UNKNOWN unk_1013EA5C; // weak
_UNKNOWN unk_1013EA78; // weak
_UNKNOWN unk_1013EA94; // weak
_UNKNOWN unk_1013EAB0; // weak
_UNKNOWN unk_1013EACC; // weak
_UNKNOWN unk_1013EAE8; // weak
_UNKNOWN unk_1013EAEC; // weak
_UNKNOWN unk_1013EAF0; // weak
_UNKNOWN unk_1013EAF4; // weak
_UNKNOWN unk_1013EAF8; // weak
_UNKNOWN unk_1013EAFC; // weak
_UNKNOWN unk_1013EB00; // weak
_UNKNOWN unk_1013EB04; // weak
_UNKNOWN unk_1013EB08; // weak
_UNKNOWN unk_1013EB0C; // weak
_UNKNOWN unk_1013EB10; // weak
_UNKNOWN unk_1013EB14; // weak
_UNKNOWN unk_1013EB18; // weak
_UNKNOWN unk_1013EB1C; // weak
_UNKNOWN unk_1013EB20; // weak
_UNKNOWN unk_1013EB24; // weak
_UNKNOWN unk_1013EB28; // weak
_UNKNOWN unk_1013EB2C; // weak
_UNKNOWN unk_1013EB30; // weak
_UNKNOWN unk_1013EC14; // weak
_UNKNOWN unk_1013FDD4; // weak
_UNKNOWN unk_1013FDD8; // weak
_UNKNOWN unk_1013FE00; // weak
_UNKNOWN unk_1013FE28; // weak
_UNKNOWN unk_1013FE68; // weak
_UNKNOWN unk_1013FEE8; // weak
_UNKNOWN unk_1013FEEC; // weak
_UNKNOWN unk_1013FEF0; // weak
_UNKNOWN unk_1013FEF2; // weak
_UNKNOWN unk_1013FEF4; // weak
_UNKNOWN unk_1013FEF5; // weak
_UNKNOWN unk_1013FEF6; // weak
_UNKNOWN unk_1013FEF8; // weak
_UNKNOWN unk_1013FF5C; // weak
_UNKNOWN unk_1013FF64; // weak
_UNKNOWN unk_1013FF6C; // weak
_UNKNOWN unk_1013FF74; // weak
_UNKNOWN unk_1013FF7C; // weak
_UNKNOWN unk_1013FF84; // weak
_UNKNOWN unk_1013FF8C; // weak
_UNKNOWN unk_1013FF94; // weak
_UNKNOWN unk_1013FF9C; // weak
_UNKNOWN unk_1013FFA4; // weak
_UNKNOWN unk_1013FFAC; // weak
_UNKNOWN unk_1013FFB4; // weak
_UNKNOWN unk_1013FFBC; // weak
_UNKNOWN unk_1013FFC4; // weak
_UNKNOWN unk_1013FFCC; // weak
_UNKNOWN unk_1013FFD4; // weak
_UNKNOWN unk_1013FFDC; // weak
_UNKNOWN unk_1013FFE4; // weak
_UNKNOWN unk_1013FFEC; // weak
_UNKNOWN unk_1013FFF4; // weak
_UNKNOWN unk_1013FFFC; // weak
_UNKNOWN unk_10140004; // weak
_UNKNOWN unk_1014000C; // weak
_UNKNOWN unk_10140014; // weak
_UNKNOWN unk_1014001C; // weak
_UNKNOWN unk_10140024; // weak
_UNKNOWN unk_1014002C; // weak
_UNKNOWN unk_10140034; // weak
_UNKNOWN unk_1014003C; // weak
_UNKNOWN unk_10140044; // weak
_UNKNOWN unk_1014004C; // weak
_UNKNOWN unk_10140054; // weak
_UNKNOWN unk_1014005C; // weak
_UNKNOWN unk_10140064; // weak
_UNKNOWN unk_1014006C; // weak
_UNKNOWN unk_10140074; // weak
_UNKNOWN unk_1014007C; // weak
_UNKNOWN unk_10140084; // weak
_UNKNOWN unk_1014008C; // weak
_UNKNOWN unk_10140094; // weak
_UNKNOWN unk_1014027C; // weak
_UNKNOWN unk_1014028C; // weak
_UNKNOWN unk_1014029C; // weak
_UNKNOWN unk_101402AC; // weak
_UNKNOWN unk_101402AD; // weak
_UNKNOWN unk_101402AE; // weak
_UNKNOWN unk_101402B0; // weak
_UNKNOWN unk_101402B4; // weak
_UNKNOWN unk_1014035C; // weak
_UNKNOWN unk_10140360; // weak
_UNKNOWN unk_10140364; // weak
_UNKNOWN unk_101403B4; // weak
_UNKNOWN unk_101403B8; // weak
_UNKNOWN unk_101403BC; // weak
_UNKNOWN unk_101404AC; // weak
_UNKNOWN unk_1014059C; // weak
_UNKNOWN unk_101405A0; // weak
_UNKNOWN unk_101405A8; // weak
_UNKNOWN unk_101405B0; // weak
_UNKNOWN unk_101405B8; // weak
_UNKNOWN unk_101405C0; // weak
_UNKNOWN unk_101405C8; // weak
_UNKNOWN unk_101405D0; // weak
_UNKNOWN unk_101405D8; // weak
_UNKNOWN unk_101405E0; // weak
_UNKNOWN unk_101405E8; // weak
_UNKNOWN unk_101405F0; // weak
_UNKNOWN unk_101405F8; // weak
_UNKNOWN unk_101405FC; // weak
_UNKNOWN unk_10140600; // weak
_UNKNOWN unk_10140604; // weak
_UNKNOWN unk_10140658; // weak
_UNKNOWN unk_101406AC; // weak
_UNKNOWN unk_101406B4; // weak
_UNKNOWN unk_101406B8; // weak
_UNKNOWN unk_101406BC; // weak
_UNKNOWN unk_101406C0; // weak
_UNKNOWN unk_101406C4; // weak
_UNKNOWN unk_101408CC; // weak
_UNKNOWN unk_10140A2C; // weak
_UNKNOWN unk_10140A44; // weak
_UNKNOWN unk_10140A5C; // weak
_UNKNOWN unk_10140A66; // weak
_UNKNOWN unk_10140A68; // weak
_UNKNOWN unk_10140A78; // weak
_UNKNOWN unk_10140A7C; // weak
_UNKNOWN unk_10140A80; // weak
_UNKNOWN unk_10140A84; // weak
_UNKNOWN unk_10140A85; // weak
_UNKNOWN unk_10140A88; // weak
_UNKNOWN unk_10140AD8; // weak
_UNKNOWN unk_10140ADC; // weak
_UNKNOWN unk_10140ADD; // weak
_UNKNOWN unk_10140ADE; // weak
_UNKNOWN unk_10140ADF; // weak
_UNKNOWN unk_10140AF3; // weak
_UNKNOWN unk_10140AF4; // weak
_UNKNOWN unk_10140AF5; // weak
_UNKNOWN unk_10140AF6; // weak
_UNKNOWN unk_10140AF8; // weak
_UNKNOWN unk_10140B98; // weak
_UNKNOWN unk_10140BE8; // weak
_UNKNOWN unk_10140BEC; // weak
_UNKNOWN unk_10140BF0; // weak
_UNKNOWN unk_10140BF4; // weak
_UNKNOWN unk_10140BF8; // weak
_UNKNOWN unk_10140BFC; // weak
_UNKNOWN unk_10140C00; // weak
_UNKNOWN unk_10140C04; // weak
_UNKNOWN unk_10140C08; // weak
_UNKNOWN unk_10140C0C; // weak
_UNKNOWN unk_10140C10; // weak
_UNKNOWN unk_10140C14; // weak
_UNKNOWN unk_10140C18; // weak
_UNKNOWN unk_10140D58; // weak
_UNKNOWN unk_10140D64; // weak
_UNKNOWN unk_10140DAC; // weak
_UNKNOWN unk_10140DAD; // weak
_UNKNOWN unk_10140DD8; // weak
_UNKNOWN unk_10140E08; // weak
_UNKNOWN unk_10140E30; // weak
_UNKNOWN unk_10140E34; // weak
_UNKNOWN unk_10140E38; // weak
_UNKNOWN unk_10140E3C; // weak
_UNKNOWN unk_10140E6C; // weak
_UNKNOWN unk_10140E6D; // weak
_UNKNOWN unk_10140E6E; // weak
_UNKNOWN unk_10140E70; // weak
_UNKNOWN unk_10140E74; // weak
_UNKNOWN unk_10140E78; // weak
_UNKNOWN unk_10140E7C; // weak
_UNKNOWN unk_10140E80; // weak
_UNKNOWN unk_10140E84; // weak
_UNKNOWN unk_10140E88; // weak
_UNKNOWN unk_10140E8C; // weak
_UNKNOWN unk_10140E90; // weak
_UNKNOWN unk_10140E94; // weak
_UNKNOWN unk_101411F4; // weak
_UNKNOWN unk_101411F8; // weak
_UNKNOWN unk_10141202; // weak
_UNKNOWN unk_1014120C; // weak
char byte_101745A0; // weak
char byte_101745A1; // weak
_DWORD dword_10181590[16]; // idb
int dword_101815D0[]; // weak
int dword_10181610; // weak
int dword_10181618[]; // weak
void (__cdecl *dword_10181658[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_10181678; // weak
__int16 word_1018686C; // weak
__int16 word_10186870; // weak
__int16 word_10186874; // weak
int dword_10186878; // weak
int dword_10186884; // weak
int dword_10186888; // weak
char byte_1018688C; // weak
int dword_10186890; // weak
int dword_10186898; // weak
_UNKNOWN unk_101868A0; // weak
char byte_10186B78[]; // weak
char byte_10186B79[]; // weak
char byte_10186B98[]; // weak
char byte_10186B99[]; // weak
_UNKNOWN unk_10187DE0; // weak
char byte_10188150[]; // weak
char byte_10188151[]; // weak
char byte_10189790[100]; // idb
float flt_101897F4; // weak
float flt_101897F8; // weak
int dword_101897FC; // weak
int dword_10189830; // weak
int dword_10189834; // weak
int dword_10189838[]; // weak
_UNKNOWN unk_10189850; // weak
_UNKNOWN unk_1018C758; // weak
_UNKNOWN unk_1018CC58; // weak
_UNKNOWN unk_1018CD00; // weak
char byte_1018F5B0[]; // weak
char byte_1018F5B1[]; // weak
_UNKNOWN unk_1018F650; // weak
int dword_1018F920[]; // weak
int dword_1018F924[]; // weak
char byte_1018FE40; // weak
char byte_1018FE41; // weak
char byte_1018FE42; // weak
char byte_1018FE43; // weak
_UNKNOWN unk_1018FE48; // weak
_UNKNOWN unk_1018FE68; // weak
int dword_1018FE88; // weak
_UNKNOWN unk_1018FE90; // weak
int dword_101913D0; // weak
char byte_101913D8[]; // weak
char byte_101913DC[]; // weak
char byte_101913DD[]; // weak
int dword_101913E4[]; // weak
int dword_101913EC[]; // weak
char byte_10191458[]; // weak
char byte_10191462[]; // weak
_UNKNOWN unk_10191471; // weak
_UNKNOWN unk_10191499; // weak
_UNKNOWN unk_1019149E; // weak
_UNKNOWN unk_1019168A; // weak
_UNKNOWN unk_10191731; // weak
_UNKNOWN unk_10191732; // weak
_UNKNOWN unk_10191751; // weak
_UNKNOWN unk_10191778; // weak
_UNKNOWN unk_10191779; // weak
_UNKNOWN unk_10191798; // weak
char byte_10191924; // weak
__int16 word_10191EF8[]; // weak
__int16 word_10191EFA[]; // weak
__int16 word_10191EFC[]; // weak
__int16 word_10191EFE[]; // weak
__int16 word_10191F00[]; // weak
__int16 word_101926C8[]; // weak
__int16 word_101926CA[]; // weak
__int16 word_101926CC[]; // weak
__int16 word_101926CE[]; // weak
__int16 word_101926D0[]; // weak
_UNKNOWN unk_10192E98; // weak
_UNKNOWN unk_10192F22; // weak
_UNKNOWN unk_10196D20; // weak
_UNKNOWN unk_10196D21; // weak
_UNKNOWN unk_10196DA2; // weak
_UNKNOWN unk_10196DBD; // weak
_UNKNOWN unk_10196DC2; // weak
_UNKNOWN unk_10197091; // weak
_UNKNOWN unk_10197092; // weak
_UNKNOWN unk_10197111; // weak
char byte_101975B8[254]; // idb
char byte_101976B6[]; // weak
char byte_101976B7[]; // weak
char byte_10197AB8[2800]; // idb
char byte_101985A8[1022]; // idb
char byte_101989A6[]; // weak
char byte_101989A7[]; // weak
char byte_101989A8[1022]; // idb
char byte_10198DA6[]; // weak
char byte_10198DA7[]; // weak
char byte_10198DA8[1022]; // idb
char byte_101991A6[]; // weak
char byte_101991A7[]; // weak
int dword_1019C1A8[]; // weak
int dword_1019C1BC[]; // weak
char byte_1019C1D0[2800]; // idb
char byte_1019CCC0[2800]; // idb
char byte_1019D7B0[2800]; // idb
int dword_1019E2A0[]; // weak
int dword_1019E2B4[]; // weak
char byte_1019E2C8[2796]; // idb
char byte_1019EDB4[]; // weak
char byte_1019EDB8[559]; // idb
char byte_1019EFE7[]; // weak
int dword_1019F8A8[]; // weak
int dword_1019F8BC[]; // weak
char byte_1019F8D0[2800]; // idb
char byte_101A03C0; // idb
char byte_101A04C0; // weak
char byte_101A04C1; // weak
int dword_101ADC10; // weak
int dword_101ADC14; // weak
int dword_101ADC18; // weak
int dword_101ADC1C; // weak
char byte_101ADC20; // weak
int dword_101ADC24; // weak
int dword_101ADC28; // weak
int dword_101ADC2C; // weak
int dword_101ADC30; // weak
int dword_101ADC34; // weak
int dword_1020D980[]; // weak
int dword_1020D984; // weak
int dword_1020D988; // weak
int dword_1020D98C; // weak
int dword_1020D990; // weak
int dword_1020D994[]; // weak
int dword_1020D998; // weak
int dword_1020D99C; // weak
int dword_1020D9A0; // weak
int dword_1020D9A4; // weak
_UNKNOWN unk_1020D9A8; // weak
int dword_1020DAC0; // weak
_UNKNOWN unk_1020DAC8; // weak
_UNKNOWN unk_1020E620; // weak
__int16 word_102119E0[]; // weak
char byte_102119E2[]; // weak
__int16 word_102119E4; // weak
char byte_102119E6; // weak
int dword_102123B0[]; // weak
int dword_102123B4[]; // weak
int dword_102123B8[]; // weak
int dword_102123BC[]; // weak
int dword_102123C0[]; // weak
int dword_102123C4[]; // weak
int dword_102123C8[]; // weak
int dword_102123CC[]; // weak
int dword_102123D0[]; // weak
int dword_102123D4[]; // weak
int dword_102123D8[]; // weak
int dword_102123DC[]; // weak
int dword_102123E0[]; // weak
int dword_1021240C; // weak
int dword_10212410; // weak
int dword_10212414; // weak
int dword_10212418; // weak
int dword_1021241C; // weak
int dword_10212420; // weak
int dword_10212424; // weak
int dword_10212428; // weak
int dword_1021242C; // weak
int dword_10212430; // weak
int dword_102124B0; // weak
char byte_102124B8[]; // weak
char byte_10212508[]; // weak
int dword_10219878; // weak
int dword_10219BA4; // weak
int dword_10219BAC; // weak
int dword_10219BB8; // weak
int dword_1021A1E0; // weak
int dword_1021A1EC; // weak
int dword_1021A1F8; // weak
int dword_1021A1FC; // weak
int dword_1021A200; // weak
int dword_1021A21C; // weak
int dword_1021A220; // weak
int dword_1021A224; // weak
int dword_1021A228; // weak
int dword_1021A22C; // weak
_UNKNOWN unk_1021A300; // weak
int dword_1021A3C8; // weak
int dword_1021A3CC; // weak
int dword_1021A3D0; // weak
_UNKNOWN unk_1021A3E0; // weak
_UNKNOWN unk_1021A820; // weak
_UNKNOWN unk_10220060; // weak
int dword_102229B4; // weak
_UNKNOWN unk_102229C0; // weak
__int16 word_10222BC0; // weak
char byte_10222BE0; // weak
char byte_10222BE1; // weak
char byte_10222BE2; // weak
char byte_10222BE3; // weak
int dword_10222BE4; // weak
int dword_10222BEC; // weak
int dword_10222BF0; // weak
int dword_10222BF4; // weak
int dword_10222BF8; // weak
int dword_10222BFC; // weak
int dword_10222C00; // weak
int dword_10222C04; // weak
int dword_10222C08; // weak
int dword_10222C0C; // weak
int dword_10222C10; // weak
int dword_10222C14; // weak
int dword_10222C18; // weak
int dword_10222C1C; // weak
int dword_10222C20; // weak
int dword_10222C24; // weak
int dword_10222C28; // weak
int dword_10222C2C; // weak
int dword_10222C30; // weak
int dword_10222C34; // weak
int dword_10222C38; // weak
int dword_10222C3C; // weak
char byte_10222C40; // weak
int dword_10222C44; // weak
char byte_10222C48; // weak
int dword_10222C4C; // weak
char byte_10222C50; // weak
int dword_10222C54; // weak
int dword_10222C5C; // weak
char byte_10222C60; // weak
int dword_10222C80[]; // weak
__int16 word_10222C84[]; // weak
int dword_10222C88[]; // weak
int dword_10222C8C; // weak
int dword_10222C90; // weak
int dword_10222C94; // weak
int dword_10222C98; // weak
__int16 word_10222C9C; // weak
int dword_10222CA0; // weak
int dword_10222CE8; // weak
int dword_10222D48; // weak
int dword_10222D78; // weak
int dword_10222DC0; // weak
int dword_10222E68; // weak
int dword_10222E74; // weak
int dword_10222E84; // weak
__int16 word_10222E88; // weak
int dword_10222E90; // weak
__int16 word_10222E94; // weak
int dword_10222E9C; // weak
int dword_10222FA4; // weak
int dword_1022301C; // weak
__int16 word_10223020; // weak
_UNKNOWN unk_10223388; // weak
_UNKNOWN unk_10223389; // weak
_UNKNOWN unk_1022338A; // weak
__int16 word_102233A0[]; // weak
char byte_102234CC; // weak
char byte_102234CD; // weak
int dword_102234D0; // weak
char byte_102234D4; // weak
char byte_102234D5[]; // weak
int dword_102234D8; // weak
int dword_102234DC; // weak
int dword_102234E0; // weak
int dword_102234E4; // weak
int dword_102234E8; // weak
int dword_102234F0; // weak
int dword_102234F4; // weak
int dword_102234F8; // weak
int dword_102234FC; // weak
int dword_10223500; // weak
int dword_10223504; // weak
void *dword_10223520; // idb
int dword_10224540; // weak
int dword_10224544; // weak
UINT uNumber; // idb
int dword_10224560[]; // weak
int dword_10224660; // weak
int dword_10224678; // weak


//----- (10001000) --------------------------------------------------------
#error "10001019: call analysis failed (funcsize=52)"

//----- (10001070) --------------------------------------------------------
char __cdecl sub_10001070(char a1, _BYTE *a2)
{
  char (__cdecl *v2)(int, void *); // esi@2
  float *v3; // edi@2
  float *v4; // ebp@2
  char v5; // bl@4
  double v6; // st7@7
  double v7; // st6@7
  char result; // al@9
  double v9; // st7@12
  int v10; // eax@12
  float v11; // [sp+20h] [bp-64h]@11
  _BYTE *v12; // [sp+24h] [bp-60h]@1
  float v13; // [sp+28h] [bp-5Ch]@5
  int v14; // [sp+2Ch] [bp-58h]@6
  float v15; // [sp+30h] [bp-54h]@12
  float v16; // [sp+34h] [bp-50h]@4
  char v17; // [sp+38h] [bp-4Ch]@1
  float v18; // [sp+54h] [bp-30h]@12
  float v19; // [sp+5Ch] [bp-28h]@6

  v12 = a2;
  sub_10012D40(512, &v17);
  if ( a1 )
  {
    v2 = sub_1001ECF0;
    v3 = (float *)&unk_10110844;
    v4 = (float *)&unk_10110848;
  }
  else
  {
    v2 = sub_1001ED40;
    v3 = (float *)&unk_1011084C;
    v4 = (float *)&unk_10110850;
  }
  v5 = v2(1, &v16);
  if ( v5
    && (*v3 = sub_1001EC10(v16, *v3, 40, 0.001), (v5 = v2(7, &v13)) != 0)
    && (sub_1001EBA0(*(float *)(dword_1021A3CC + 23308), v13, (int)&v14), v5 = 0, v19 > (double)*(float *)&v14) )
  {
    v6 = *v3;
    v7 = *(float *)(dword_1021A3CC + 23316) + *(float *)(dword_1021A3CC + 23308);
  }
  else
  {
    if ( !v2(0, &v11) )
      return v5;
    v11 = v11 * 1.943844437599182;
    v15 = sub_1001EC10(v11, *v4, 40, 1.0);
    v9 = v15;
    v10 = dword_1021A3CC;
    *v4 = v15;
    v6 = v9 * 0.5144444444444445;
    v7 = *(float *)(v10 + 23320) + v18;
  }
  if ( v7 > v6 )
  {
    result = 1;
    *v12 = 0;
  }
  else
  {
    result = 1;
    *v12 = 1;
  }
  return result;
}
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (10001220) --------------------------------------------------------
char __cdecl sub_10001220(int a1, int a2)
{
  char v2; // bl@12
  char v3; // al@13
  int v4; // eax@23
  char v6; // [sp+9h] [bp-5Fh]@1
  char v7; // [sp+Ah] [bp-5Eh]@1
  char v8; // [sp+Bh] [bp-5Dh]@8
  int v9; // [sp+Ch] [bp-5Ch]@1
  float v10; // [sp+10h] [bp-58h]@5
  float v11; // [sp+14h] [bp-54h]@5
  float v12; // [sp+18h] [bp-50h]@1
  char v13; // [sp+1Ch] [bp-4Ch]@7

  v12 = 0.0;
  v7 = 0;
  v6 = 0;
  LOBYTE(v9) = sub_1001EFE0(&v12);
  if ( (_BYTE)v9 == 1 )
  {
    if ( (unsigned __int16)a1 == 119 )
    {
      sub_100185C0(6205, (int)&v10, 4);
      sub_100185C0(6206, (int)&v11, 4);
      goto LABEL_19;
    }
    if ( (unsigned __int16)a1 == 125 )
    {
      if ( 9.8999998e24 != *(float *)(dword_1021A3CC + 23308) && sub_10012D40(512, &v13) )
      {
        if ( sub_1001EE80(140, &v8) && v8 )
        {
          LOBYTE(v9) = 1;
LABEL_11:
          v6 = 1;
          goto LABEL_23;
        }
        v2 = sub_10001070(0, &v6);
        LOBYTE(v9) = v2;
        if ( v6 )
          goto LABEL_23;
        v3 = sub_10001070(1, &v6);
        if ( v2 || v3 )
        {
          LOBYTE(v9) = 1;
          goto LABEL_23;
        }
      }
      else
      {
        sub_10018A40("..\\lib\\adl\\iop_air_data.c", 249, 0, 0);
      }
      LOBYTE(v9) = 0;
      goto LABEL_23;
    }
    if ( (unsigned __int16)a1 == 126 )
    {
      v10 = 66.877785;
      v11 = 69.450005;
LABEL_19:
      if ( sub_1000DA50(a1, a2, &v7) != 1 )
        v7 = 0;
      if ( v10 > (double)v12 )
      {
        v6 = 1;
        goto LABEL_23;
      }
      if ( v7 != 1 )
        goto LABEL_23;
      if ( v11 < (double)v12 )
      {
        v6 = 0;
        goto LABEL_23;
      }
      goto LABEL_11;
    }
  }
LABEL_23:
  v4 = sub_100181D0();
  return sub_1000CE40(a1, v9, a2, &v6, v4);
}
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (100013F0) --------------------------------------------------------
char __cdecl sub_100013F0(const void *a1)
{
  int v1; // eax@1

  v1 = sub_100181D0();
  sub_1000D150(492, 0x11Cu, 1, (int)&byte_10222BE0, a1, v1);
  return sub_1000D440(492, 768, (int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10001430) --------------------------------------------------------
char __cdecl sub_10001430(const void *a1)
{
  int v1; // eax@1

  v1 = sub_100181D0();
  sub_1000CE40(766, 1, (int)&byte_10222BE0, a1, v1);
  return sub_1000D440(766, 768, (int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10001470) --------------------------------------------------------
char __cdecl sub_10001470(__int16 a1)
{
  char result; // al@3
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 24;
  if ( a1 != 768 )
    sub_10018A40(
      "..\\lib\\acl\\iop\\iop_aud_msg.c",
      238,
      0,
      "iop_rx_gia_in_control() was called by an incorrect HSDB packet.");
  result = sub_1000F100(0, 768, &v2);
  if ( result )
    word_10110854 = v2;
  return result;
}
// 10110854: using guessed type __int16 word_10110854;

//----- (100014C0) --------------------------------------------------------
signed __int16 __usercall sub_100014C0@<ax>(int a1@<eax>)
{
  signed __int16 result; // ax@3

  if ( a1 == 256 )
  {
    result = 1;
  }
  else if ( a1 == 512 )
  {
    result = 2;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\iop_aud_msg.c", 375, 0, 0);
    result = 24;
  }
  return result;
}

//----- (10001500) --------------------------------------------------------
signed int sub_10001500()
{
  int v0; // eax@1
  signed int v1; // ecx@1

  sub_10018F80((LONG)&off_10061C30);
  v0 = 0;
  v1 = 32;
  do
  {
    *(_WORD *)(v0 + dword_102234E4 + 4) = 24;
    *(_DWORD *)(v0 + dword_102234E4 + 8) = 255;
    *(_DWORD *)(v0 + dword_102234E4 + 12) = 0;
    v0 += 12;
    --v1;
  }
  while ( v1 );
  return sub_10018B10((int)&off_10061C30);
}
// 10061C30: using guessed type char *off_10061C30;
// 102234E4: using guessed type int dword_102234E4;

//----- (10001560) --------------------------------------------------------
signed int sub_10001560()
{
  signed int result; // eax@1

  dword_102234E4 = -15;
  result = sub_10001500();
  word_10110854 = 24;
  return result;
}
// 10110854: using guessed type __int16 word_10110854;
// 102234E4: using guessed type int dword_102234E4;

//----- (10001580) --------------------------------------------------------
char __cdecl sub_10001580(__int16 a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@5
  int v5; // [sp+4h] [bp-1A0h]@1
  int v6; // [sp+8h] [bp-19Ch]@1
  int v7; // [sp+Ch] [bp-198h]@1
  int v8; // [sp+10h] [bp-194h]@1
  int v9; // [sp+14h] [bp-190h]@1
  int v10; // [sp+18h] [bp-18Ch]@1
  int v11; // [sp+1Ch] [bp-188h]@1
  char v12; // [sp+20h] [bp-184h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  memset(&v12, 0, 0x180u);
  v5 = 0;
  if ( a1 == 767 )
  {
    LOBYTE(v2) = sub_1000F130(0, 767, &v12, (int)&v5);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = sub_1000E940(0, 0x300u, (int)&v6);
      if ( (_BYTE)v2 )
      {
        if ( !(_BYTE)v6 )
        {
          v3 = sub_1000C2A0(767, a2);
          LOWORD(v2) = sub_100014C0(v3);
          if ( (_WORD)v2 == word_10110854 )
          {
            v2 = sub_100182A0(2, 1000);
            if ( !v2 )
            {
              memset((void *)(dword_102234E4 + 4), 0, 0x180u);
              memcpy((void *)(dword_102234E4 + 4), &v12, (unsigned __int16)v5);
              ++*(_DWORD *)dword_102234E4;
              LOBYTE(v2) = sub_10018280(2);
            }
          }
        }
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_10018A40(
                   "..\\lib\\acl\\iop\\iop_aud_msg.c",
                   326,
                   0,
                   "iop_rx_gia_aud_queue() was called by an incorrect HSDB packet.");
  }
  return v2;
}
// 10110854: using guessed type __int16 word_10110854;
// 102234E4: using guessed type int dword_102234E4;

//----- (100016F0) --------------------------------------------------------
int __cdecl sub_100016F0(int a1, int a2, int a3)
{
  flt_10110904 = 0.0;
  byte_10110900 = 0;
  flt_101108FC = 50.0;
  dword_10110908 = 0;
  dword_1011090C = 0;
  byte_10110858 = 1;
  byte_10110859 = 1;
  word_101108F4 = 0;
  word_101108F6 = 0;
  byte_101108F8 = 0;
  byte_101108F9 = 0;
  return nullsub_1(a1, a2, a3);
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10110858: using guessed type char byte_10110858;
// 10110859: using guessed type char byte_10110859;
// 101108F4: using guessed type __int16 word_101108F4;
// 101108F6: using guessed type __int16 word_101108F6;
// 101108F8: using guessed type char byte_101108F8;
// 101108F9: using guessed type char byte_101108F9;
// 101108FC: using guessed type float flt_101108FC;
// 10110900: using guessed type char byte_10110900;
// 10110904: using guessed type float flt_10110904;
// 10110908: using guessed type int dword_10110908;
// 1011090C: using guessed type int dword_1011090C;

//----- (10001740) --------------------------------------------------------
char __cdecl sub_10001740(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  char v5; // [sp+8h] [bp-44h]@1

  v2 = sub_10018540(6786, (int)&v5, 64);
  v3 = sub_100181D0();
  return sub_1000CE40(a1, v2 == 0, a2, &v5, v3);
}

//----- (100017A0) --------------------------------------------------------
char __cdecl sub_100017A0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  char result; // al@1
  int v5; // eax@2
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  v3 = sub_1001E7B0(&a1, 2u, (int)L"`9a:b;c<d=e>\", 4, 6, 6);
  result = sub_1000F100(6, a9aBCDE[2 * v3 + 1], &v6);
  if ( result == 1 )
  {
    v5 = sub_100181D0();
    result = sub_1000CE40(a1, 1, a2, &v6, v5);
  }
  return result;
}
// 10062520: using guessed type wchar_t a9aBCDE[12];

//----- (10001800) --------------------------------------------------------
char __cdecl sub_10001800(int a1, int a2)
{
  int v2; // eax@7
  char v4; // [sp+0h] [bp-8h]@1
  char v5; // [sp+1h] [bp-7h]@1
  char v6; // [sp+2h] [bp-6h]@3
  char v7; // [sp+3h] [bp-5h]@5
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_1001F2F0((bool *)&v5);
  v4 = v5 == 0;
  if ( (_BYTE)v8
    && v5
    && !sub_10018600(9131, &v6, 1, &unk_10061D07)
    && v6
    && !sub_10018600(41023, &v7, 1, &unk_10061D06) )
  {
    v4 = v7;
  }
  v2 = sub_100181D0();
  return sub_1000CE40(a1, v8, a2, &v4, v2);
}

//----- (100018A0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100018A0(int a1, int a2)
{
  int v2; // ecx@0
  unsigned __int8 result; // al@1
  int v4; // esi@2
  int v5; // eax@7
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  HIWORD(v6) = 0;
  result = sub_1001E7B0(&a1, 2u, (int)&unk_1006253C, 20, 2, 2);
  if ( result < 2u )
  {
    v4 = 20 * result;
    if ( sub_1001F770(word_1006254E[10 * result], (char *)&v6 + 3) && BYTE3(v6) )
    {
      BYTE2(v6) = 1;
    }
    else if ( sub_1001F460((int)&a_l_fire_warn[v4]) )
    {
      BYTE2(v6) = 2;
    }
    v5 = sub_100181D0();
    result = sub_1000CE40(a1, 1, a2, (char *)&v6 + 2, v5);
  }
  return result;
}
// 1006254E: using guessed type __int16 word_1006254E[];

//----- (10001940) --------------------------------------------------------
void __cdecl sub_10001940(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // eax@8
  float v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@4
  float v7; // [sp+14h] [bp-4h]@3

  v4 = 9.8999998e24;
  LOBYTE(v5) = 0;
  v2 = 0;
  do
  {
    if ( (_WORD)a1 == word_10062564[v2] )
    {
      LOBYTE(v5) = sub_1000F100(0, (unsigned __int16)word_10062566[v2], &v7);
      if ( (_BYTE)v5 )
      {
        LOBYTE(v5) = sub_1000F100(0, (unsigned __int16)word_10062568[v2], &v6);
        if ( (_BYTE)v5 )
          v4 = v6 * v7;
      }
    }
    v2 += 3;
  }
  while ( v2 < 6 );
  if ( 9.8999998e24 != v4 )
  {
    v3 = sub_100181D0();
    sub_1000CE40(a1, v5, a2, &v4, v3);
  }
}
// 10062564: using guessed type __int16 word_10062564[];
// 10062566: using guessed type __int16 word_10062566[];
// 10062568: using guessed type __int16 word_10062568[];

//----- (100019F0) --------------------------------------------------------
char __cdecl sub_100019F0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  sub_1001F960(&v5);
  v3 = sub_100181D0();
  return sub_1000CE40(a1, 1, a2, &v5, v3);
}

//----- (10001A20) --------------------------------------------------------
char __cdecl sub_10001A20(int a1, int a2)
{
  double v2; // st7@1
  int v3; // eax@12
  char v5; // [sp+0h] [bp-30h]@1
  char v6; // [sp+1h] [bp-2Fh]@4
  char v7; // [sp+2h] [bp-2Eh]@4
  char v8; // [sp+3h] [bp-2Dh]@5
  char v9; // [sp+4h] [bp-2Ch]@7
  char v10; // [sp+5h] [bp-2Bh]@7
  char v11; // [sp+6h] [bp-2Ah]@7
  bool v12; // [sp+7h] [bp-29h]@10
  __int16 v13; // [sp+8h] [bp-28h]@4
  int v14; // [sp+Ch] [bp-24h]@7
  float v15; // [sp+10h] [bp-20h]@7
  float v16; // [sp+14h] [bp-1Ch]@2
  float v17; // [sp+18h] [bp-18h]@7
  float v18; // [sp+20h] [bp-10h]@7
  float v19; // [sp+24h] [bp-Ch]@7
  float v20; // [sp+28h] [bp-8h]@7
  float v21; // [sp+2Ch] [bp-4h]@7

  memset(&v5, 0, 0x30u);
  sub_1001A0E0(&byte_10110860);
  v2 = 9.9999996e24;
  if ( flt_10110894 == 9.9999996e24 )
  {
    v16 = sub_1001FC20();
    v2 = 9.9999996e24;
  }
  else
  {
    v16 = flt_10110894;
  }
  v5 = byte_10110860;
  v6 = byte_1011086B;
  v13 = word_1011087C;
  v7 = byte_1011086C;
  if ( byte_1011086A != 3 || (v8 = 1, byte_10110876 != 1) )
    v8 = 0;
  v17 = flt_101108B0;
  v10 = byte_1011086A;
  v18 = flt_101108C0;
  v11 = byte_10110878;
  v19 = flt_101108DC;
  v14 = dword_10110884;
  v9 = byte_10110868;
  v20 = flt_101108B4;
  v21 = flt_101108BC;
  v15 = flt_101108C4;
  v12 = v2 != flt_101108B4 && flt_101108B8 != v2 && flt_101108B4 + 20.0 < flt_101108B8;
  sub_1001FB40((int)&byte_10110860, (int)&byte_10110900, &v19);
  v3 = sub_100181D0();
  return sub_1000CE40(a1, 1, a2, &v5, v3);
}
// 1001FC20: using guessed type double sub_1001FC20(void);
// 10110860: using guessed type char byte_10110860;
// 10110868: using guessed type char byte_10110868;
// 1011086A: using guessed type char byte_1011086A;
// 1011086B: using guessed type char byte_1011086B;
// 1011086C: using guessed type char byte_1011086C;
// 10110876: using guessed type char byte_10110876;
// 10110878: using guessed type char byte_10110878;
// 1011087C: using guessed type __int16 word_1011087C;
// 10110884: using guessed type int dword_10110884;
// 10110894: using guessed type float flt_10110894;
// 101108B0: using guessed type float flt_101108B0;
// 101108B4: using guessed type float flt_101108B4;
// 101108B8: using guessed type float flt_101108B8;
// 101108BC: using guessed type float flt_101108BC;
// 101108C0: using guessed type float flt_101108C0;
// 101108C4: using guessed type float flt_101108C4;
// 101108DC: using guessed type float flt_101108DC;
// 10110900: using guessed type char byte_10110900;

//----- (10001B90) --------------------------------------------------------
char __cdecl sub_10001B90(int a1, int a2)
{
  signed int v2; // edi@1
  char *v3; // esi@1
  char v4; // al@2
  double v5; // st7@2
  int v6; // eax@3
  char v8; // [sp+10h] [bp-84h]@1
  char v9; // [sp+24h] [bp-70h]@1

  memset(&v8, 0, 0x84u);
  v2 = 0;
  v3 = &v9;
  do
  {
    *(v3 - 8) = sub_1001FFA0(53, v2, v3 - 12);
    *v3 = sub_1001EFE0((float *)v3 - 1);
    *(v3 - 16) = sub_1001FFA0(0, v2, v3 - 20);
    v3[20] = sub_1001FFA0(20, v2, v3 + 16);
    v4 = sub_1001FFA0(59, v2, v3 + 4);
    v5 = *((float *)v3 - 1) - *((float *)v3 - 3);
    v3[8] = v4;
    ++v2;
    *((float *)v3 + 3) = v5;
    v3 += 44;
  }
  while ( v2 < 3 );
  v6 = sub_100181D0();
  return sub_1000CE40(a1, 1, a2, &v8, v6);
}

//----- (10001C50) --------------------------------------------------------
char __cdecl sub_10001C50(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v2;
  sub_10018600(9879, (char *)&v5 + 3, 1, &unk_10061D41);
  v3 = sub_100181D0();
  return sub_1000CE40(a1, 1, a2, (char *)&v5 + 3, v3);
}

//----- (10001C90) --------------------------------------------------------
char __cdecl sub_10001C90(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // eax@6
  float v5; // [sp+8h] [bp-8h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v5 = 9.8999998e24;
  LOBYTE(v6) = 0;
  v2 = 0;
  do
  {
    if ( (_WORD)a1 == word_10062570[v2] )
    {
      LOBYTE(v6) = sub_1000F100(byte_10062576[v2 * 2], (unsigned __int16)word_10062572[v2], &v5);
      if ( !(_BYTE)v6 )
        LOBYTE(v6) = sub_1000F100(byte_10062576[v2 * 2], (unsigned __int16)word_10062574[v2], &v5);
    }
    v2 += 4;
  }
  while ( v2 < 20 );
  v3 = sub_100181D0();
  return sub_1000CE40(a1, v6, a2, &v5, v3);
}
// 10062570: using guessed type __int16 word_10062570[];
// 10062572: using guessed type __int16 word_10062572[];
// 10062574: using guessed type __int16 word_10062574[];

//----- (10001D30) --------------------------------------------------------
char __cdecl sub_10001D30(int a1, int a2)
{
  int v2; // eax@4
  char v4; // [sp+1h] [bp-7h]@2
  char v5; // [sp+2h] [bp-6h]@1
  char v6; // [sp+3h] [bp-5h]@1
  int v7; // [sp+4h] [bp-4h]@1

  LOBYTE(v7) = sub_100205A0((bool *)&v5, (unsigned int)&v6);
  if ( v5 || (v4 = 0, v6) )
    v4 = 1;
  v2 = sub_100181D0();
  return sub_1000CE40(a1, v7, a2, &v4, v2);
}

//----- (10001D90) --------------------------------------------------------
char __cdecl sub_10001D90(__int16 a1)
{
  void *v1; // ecx@0
  void *v2; // ecx@1
  int v3; // esi@1
  bool v4; // cl@3
  char v6; // [sp+Bh] [bp-1h]@1

  v6 = sub_1001EAF0(v1);
  v3 = sub_100206D0(v2);
  v4 = v3 == 4 && sub_100206F0(1);
  if ( a1 == 168 )
  {
    if ( v3 == 1 || v4 && !v6 )
      return 1;
    return 0;
  }
  if ( a1 == 169 )
  {
    if ( v3 == 2 || v4 && v6 == 1 )
      return 1;
    return 0;
  }
  return 0;
}

//----- (10001E10) --------------------------------------------------------
char __cdecl sub_10001E10(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@6
  char v5; // [sp+7h] [bp-19h]@3
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@1
  int v9; // [sp+14h] [bp-Ch]@1
  int v10; // [sp+18h] [bp-8h]@1
  int v11; // [sp+1Ch] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  LOBYTE(v6) = 0;
  if ( !sub_1001D380(v2) )
  {
    if ( sub_10001D90(a1) )
    {
      LOBYTE(v7) = sub_10019EA0((float *)&v9, (float *)&v10, (float *)&v8, (_BYTE *)&v7 + 1, 0, 0);
      if ( (unsigned __int8)sub_10019CD0(&v5) < 4u || (LOBYTE(v6) = 1, !v5) )
        LOBYTE(v6) = 0;
    }
  }
  v3 = sub_100181D0();
  return sub_1000CE40(a1, v6, a2, &v7, v3);
}

//----- (10001EE0) --------------------------------------------------------
#error "10001EEF: call analysis failed (funcsize=26)"

//----- (10001F30) --------------------------------------------------------
char __cdecl sub_10001F30(__int16 a1)
{
  int v1; // ecx@0
  char result; // al@1

  result = 0;
  if ( v1 != 1 || a1 == 417 )
    result = 1;
  return result;
}

//----- (10001F50) --------------------------------------------------------
char __usercall sub_10001F50@<al>(int a1@<eax>)
{
  unsigned int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 > 0x17DA )
  {
    if ( v1 > 0x1A00 )
    {
      v1 -= 6769;
      if ( v1 > 1 )
        return v1;
    }
    else if ( v1 < 0x19FF && v1 != 6453 )
    {
      return v1;
    }
LABEL_15:
    LOBYTE(v1) = sub_1000DC70();
    return v1;
  }
  if ( v1 >= 0x17D9 )
    goto LABEL_15;
  if ( v1 > 0x1778 )
  {
    if ( v1 < 0x17CD || v1 > 0x17CE )
      return v1;
    goto LABEL_15;
  }
  if ( v1 >= 0x1776 )
    goto LABEL_15;
  if ( v1 == 2117 )
    LOBYTE(v1) = sub_100025E0();
  return v1;
}

//----- (10001FB0) --------------------------------------------------------
int sub_10001FB0()
{
  int result; // eax@1
  signed int v1; // edi@9
  char *v2; // esi@9
  unsigned int v3; // eax@18
  int v4; // edx@25
  int v5; // [sp-Ch] [bp-548h]@24
  char v6; // [sp-8h] [bp-544h]@24
  int v7; // [sp+Ch] [bp-530h]@1
  unsigned __int16 v8; // [sp+10h] [bp-52Ch]@1
  char v9[4]; // [sp+14h] [bp-528h]@6
  int v10; // [sp+18h] [bp-524h]@6
  int v11; // [sp+1Ch] [bp-520h]@30
  int v12; // [sp+20h] [bp-51Ch]@30
  int v13; // [sp+24h] [bp-518h]@35
  int v14; // [sp+28h] [bp-514h]@35
  unsigned __int16 v15; // [sp+2Ch] [bp-510h]@35
  int v16; // [sp+2Eh] [bp-50Eh]@35
  int v17; // [sp+A0h] [bp-49Ch]@30
  int v18; // [sp+A4h] [bp-498h]@30
  int v19; // [sp+A8h] [bp-494h]@30
  int v20; // [sp+ACh] [bp-490h]@30
  size_t v21; // [sp+530h] [bp-Ch]@23

  for ( result = sub_10018180((int)&v8, (int)&v7); result != 1; result = sub_10018180((int)&v8, (int)&v7) )
  {
    if ( (signed int)v8 > 32769 )
    {
      switch ( v8 )
      {
        case 0x8013u:
          switch ( v9[1] )
          {
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x19:
            case 0x1A:
            case 0x1F:
            case 0x2A:
            case 0x2B:
            case 0x30:
            case 0x31:
            case 0x37:
            case 0x38:
              sub_100032E0(v9[0], v9[1], v9[2], v9[3], (int)&v10, (char *)&v10 + 3, v21);
              break;
            default:
              v6 = 0;
              v5 = 818;
              goto LABEL_38;
          }
          break;
        case 0x8002u:
          if ( sub_10001F30(*(__int16 *)v9) )
            sub_1000D440(v4, v10, (int)&byte_10222BE0);
          break;
        case 0x800Bu:
          sub_1000E1A0();
          break;
        case 0x8011u:
          sub_1000F190(v9[0], (int)&byte_10222BE0);
          break;
        case 0x8016u:
          sub_100013F0(v9);
          break;
        case 0x8006u:
          sub_1000FBD0(v20, v10, v9[0], v11, (const char *)&v12, v17, v18, *(__int16 *)&v9[2], v19);
          break;
        case 0x8007u:
          sub_1000FC40(1);
          break;
        case 0x8036u:
          sub_10002510((int)v9);
          break;
        case 0x803Du:
          sub_10004A80(v9[0]);
          break;
        case 0x803Fu:
          sub_1000DC90(*(int *)v9, (int)&v10 + 2, v10, 1, 1);
          break;
        case 0x8048u:
          sub_10002C70(*(int *)v9, v10, v11, v12, v13, v14, v15, v16);
          break;
        case 0x8049u:
          sub_10001430(v9);
          break;
        default:
          goto LABEL_37;
      }
    }
    else if ( (signed int)v8 >= 0x8000 )
    {
      if ( v8 == -32767 )
      {
        v1 = *(_DWORD *)v9;
        v2 = (char *)&v10;
      }
      else
      {
        v2 = v9;
        v1 = (HIWORD(v10) + 15) & 0xFFFFFFFC;
      }
      if ( sub_10001F30(*((_WORD *)v2 + 1)) )
      {
        do
        {
          if ( v2[4] )
            sub_1000D150(
              *((_WORD *)v2 + 1),
              *((_WORD *)v2 + 3),
              v2[1],
              (int)&byte_10222BE0,
              v2 + 12,
              *((_DWORD *)v2 + 2));
          else
            sub_1000CE40(*((_WORD *)v2 + 1), v2[1], (int)&byte_10222BE0, v2 + 12, *((_DWORD *)v2 + 2));
          if ( *v2 == 1 && *(_DWORD *)(52 * *(_WORD *)(dword_10222C08 + 2 * *((_WORD *)v2 + 1)) + dword_10222C00 + 36) )
            (*(void (__cdecl **)(_DWORD, char *))(52 * *(_WORD *)(dword_10222C08 + 2 * *((_WORD *)v2 + 1))
                                                + dword_10222C00
                                                + 36))(
              *((_WORD *)v2 + 1),
              &byte_10222BE0);
          v3 = (*((_WORD *)v2 + 3) + 15) & 0xFFFFFFFC;
          v2 += v3;
          v1 -= v3;
        }
        while ( *((_WORD *)v2 + 3) && v1 > 0 );
      }
    }
    else if ( v8 == 1 )
    {
      sub_10001F50((int)&v8);
    }
    else if ( v8 == 2 )
    {
      sub_10012BC0(*(int *)v9, v10, 0xFFFFFFF);
    }
    else
    {
LABEL_37:
      v6 = 0;
      v5 = 1037;
LABEL_38:
      sub_10018A40("..\\lib\\adl\\iop_b_main.c", v5, v6, 0);
    }
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;
// 10222C00: using guessed type int dword_10222C00;
// 10222C08: using guessed type int dword_10222C08;

//----- (100023E0) --------------------------------------------------------
void __noreturn sub_100023E0()
{
  char v0; // bl@1
  void *v1; // ecx@5
  int *v2; // ecx@13
  char v3; // [sp+5h] [bp-EBh]@1
  char v4; // [sp+6h] [bp-EAh]@1
  char v5; // [sp+7h] [bp-E9h]@1
  char v6; // [sp+8h] [bp-E8h]@3
  char v7; // [sp+Ch] [bp-E4h]@1

  v0 = 20;
  sub_10020FB0();
  sub_10020BB0(&v7);
  v5 = 4;
  v4 = 40;
  v3 = 2;
  if ( !sub_100183A0(33, 10000) )
    sub_10018A40("..\\lib\\adl\\iop_b_main.c", 439, 1, 0);
  sub_10018410(&v6);
  while ( 1 )
  {
    sub_10018410(&v6);
    if ( v6 & 1 )
    {
      sub_1000C6B0((int)&byte_10222BE0);
      sub_1000CAB0((int)&byte_10222BE0);
      if ( --v0 <= 0 )
      {
        sub_1000D990((int)&byte_10222BE0);
        v0 = 20;
      }
      if ( --v4 <= 0 )
      {
        sub_10020AA0((int *)&v7);
        v4 = 40;
      }
      if ( --v5 <= 0 )
      {
        sub_10012CC0();
        v5 = 4;
      }
      if ( --v3 <= 0 )
      {
        sub_1000F3A0(v1);
        sub_10011EF0();
        v3 = 2;
      }
      sub_10003890();
      sub_10010A40(v2);
    }
    if ( v6 & 2 )
      sub_10001FB0();
  }
}
// 10020FB0: using guessed type int sub_10020FB0(void);
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10002510) --------------------------------------------------------
char __cdecl sub_10002510(int a1)
{
  void *v1; // eax@3
  char v3[4]; // [sp+8h] [bp-58h]@1
  int v4; // [sp+Ch] [bp-54h]@9
  int v5; // [sp+10h] [bp-50h]@9
  char v6; // [sp+14h] [bp-4Ch]@9

  sub_10020FE0(v3);
  if ( a1 && !sub_100182A0(37, 5) )
  {
    v1 = dword_10110910;
    if ( !*((_BYTE *)dword_10110910 + 12) && *(_BYTE *)(a1 + 4) == 1 )
    {
      if ( *((_BYTE *)dword_10110910 + 58) )
      {
LABEL_8:
        sub_10018280(37);
        goto LABEL_9;
      }
      *((_DWORD *)dword_10110910 + 15) = *(_DWORD *)v3;
      v1 = dword_10110910;
    }
    qmemcpy((char *)v1 + 8, (const void *)a1, 0x34u);
    goto LABEL_8;
  }
LABEL_9:
  memset(&v4, 0, 0x50u);
  v4 = *(_DWORD *)dword_10110910;
  v5 = *((_DWORD *)dword_10110910 + 1);
  qmemcpy(&v6, (char *)dword_10110910 + 8, 0x38u);
  return sub_10018730(2117, (int)&v4, 80);
}

//----- (100025E0) --------------------------------------------------------
int sub_100025E0()
{
  int result; // eax@1
  int v1; // [sp+8h] [bp-A4h]@1
  int v2; // [sp+Ch] [bp-A0h]@2
  char v3; // [sp+10h] [bp-9Ch]@2
  int v4; // [sp+44h] [bp-68h]@2
  char v5; // [sp+58h] [bp-54h]@1

  qmemcpy(&v5, &unk_10064018, 0x50u);
  sub_100187A0(2117, &v1, 80, &v5);
  result = sub_100182A0(37, 5);
  if ( !result )
  {
    *(_DWORD *)dword_10110910 = v1;
    *((_DWORD *)dword_10110910 + 1) = v2;
    qmemcpy((char *)dword_10110910 + 8, &v3, 0x34u);
    *((_DWORD *)dword_10110910 + 15) = v4;
    result = sub_10018280(37);
  }
  return result;
}

//----- (10002690) --------------------------------------------------------
char __cdecl sub_10002690(int a1, int a2)
{
  char v2; // al@1
  int v3; // eax@5
  char v5; // [sp+Fh] [bp-39h]@4
  char v6; // [sp+10h] [bp-38h]@1
  char v7; // [sp+42h] [bp-6h]@1

  qmemcpy(&v6, (char *)dword_10110910 + 8, 0x34u);
  v2 = sub_1001C0E0(0);
  if ( v7 )
    goto LABEL_4;
  if ( (_WORD)a1 != 390 )
  {
    if ( (_WORD)a1 == 391 && !v2 )
      goto LABEL_4;
LABEL_8:
    v5 = 0;
    goto LABEL_5;
  }
  if ( v2 != 1 )
    goto LABEL_8;
LABEL_4:
  v5 = 1;
LABEL_5:
  v3 = sub_100181D0();
  return sub_1000CE40(a1, 1, a2, &v5, v3);
}

//----- (10002720) --------------------------------------------------------
char sub_10002720()
{
  char result; // al@1
  _DWORD *v1; // edx@1
  unsigned int v2; // ecx@1
  unsigned int v3; // [sp+0h] [bp-58h]@1
  int v4; // [sp+4h] [bp-54h]@8
  int v5; // [sp+8h] [bp-50h]@8
  char v6; // [sp+Ch] [bp-4Ch]@8

  result = sub_10020FE0((char *)&v3);
  v1 = dword_10110910;
  v2 = *((_DWORD *)dword_10110910 + 15);
  if ( v2 )
  {
    if ( !*((_BYTE *)dword_10110910 + 58) && (!result || v3 >= v2 && v3 <= v2 + 18) )
    {
      result = sub_1001FCE0(8000);
      if ( !result )
        return result;
      v1 = dword_10110910;
    }
    v1[15] = 0;
    *((_BYTE *)dword_10110910 + 12) = 0;
    memset(&v4, 0, 0x50u);
    v4 = *(_DWORD *)dword_10110910;
    v5 = *((_DWORD *)dword_10110910 + 1);
    qmemcpy(&v6, (char *)dword_10110910 + 8, 0x38u);
    result = sub_10018730(2117, (int)&v4, 80);
  }
  return result;
}

//----- (10002840) --------------------------------------------------------
BOOL __cdecl sub_10002840(int a1, char a2)
{
  return a2 && !(a1 & 0x20000000) && a1 & 0x40000000;
}

//----- (10002870) --------------------------------------------------------
void __usercall sub_10002870(int a1@<esi>)
{
  if ( a1 )
  {
    if ( !sub_100182A0(37, 5) )
    {
      *(_DWORD *)dword_10110910 = *(_DWORD *)a1;
      *((_DWORD *)dword_10110910 + 1) = *(_DWORD *)(a1 + 4);
      sub_10018280(37);
    }
  }
}

//----- (100028B0) --------------------------------------------------------
void __cdecl sub_100028B0(int a1, int a2)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  if ( (_WORD)a1 == 260 )
  {
    if ( !sub_1000DA50(a1, a2, &v2) )
    {
      v2 = 0;
      v3 = 0;
    }
    sub_10002870((int)&v2);
  }
}

//----- (10002900) --------------------------------------------------------
signed int sub_10002900()
{
  dword_10110914 = 0;
  dword_10110918 = 0;
  dword_1011091C = 0;
  dword_10110910 = (void *)-15;
  if ( !sub_10018F80((LONG)&off_10064068) )
    sub_10018A40("..\\lib\\acl\\iop\\tcas\\iop_b_tcas_data.c", 901, 1, 0);
  memset(dword_10110910, 0, 0x40u);
  sub_100025E0();
  return sub_10018B10((int)&off_10064068);
}
// 10064068: using guessed type char *off_10064068;
// 10110914: using guessed type int dword_10110914;
// 10110918: using guessed type int dword_10110918;
// 1011091C: using guessed type int dword_1011091C;

//----- (10002920) --------------------------------------------------------
void sub_10002920()
{
  int v0; // [sp+4h] [bp-8h]@1
  int v1; // [sp+8h] [bp-4h]@1

  v0 = 0;
  v1 = 0;
  sub_10002870((int)&v0);
}

//----- (10002940) --------------------------------------------------------
char __cdecl sub_10002940(int a1, int a2)
{
  char v2; // bl@1
  int v3; // esi@1
  char v5; // [sp+Bh] [bp-15h]@1
  int v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@1
  char v10; // [sp+1Ch] [bp-4h]@8

  v8 = 0;
  LOBYTE(v6) = sub_1000F100(0, 317, &v7);
  v2 = sub_10002840(v7, v6);
  v5 = 1;
  v3 = sub_100181D0();
  sub_10018600(9188, &v9, 4, &v8);
  if ( v2 )
  {
    if ( !dword_1011091C )
      dword_1011091C = v3;
  }
  else if ( dword_1011091C )
  {
    dword_1011091C = 0;
  }
  if ( !(_BYTE)v6
    || (unsigned int)(v3 - v9) >= 0x7D0
    || !sub_1001F0E0(&v10)
    || dword_1011091C && (unsigned int)(v3 - dword_1011091C) < 0xFA0 )
  {
    v5 = 0;
  }
  return sub_1000CE40(a1, 1, a2, &v5, v3);
}
// 10110918: using guessed type int dword_10110918;
// 1011091C: using guessed type int dword_1011091C;

//----- (10002A20) --------------------------------------------------------
char __cdecl sub_10002A20(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@22
  char v4; // [sp+Ch] [bp-38h]@1
  char v5; // [sp+15h] [bp-2Fh]@12
  char v6; // [sp+35h] [bp-Fh]@2

  sub_10002720();
  qmemcpy(&v4, (char *)dword_10110910 + 8, 0x34u);
  result = sub_1001C0E0(0);
  if ( (unsigned int)(unsigned __int16)a1 - 392 <= 1 )
  {
    if ( !v6 )
      goto LABEL_12;
    if ( result )
    {
      if ( result != 1 || (_WORD)a1 != 393 )
        goto LABEL_12;
    }
    else if ( (_WORD)a1 != 392 )
    {
      goto LABEL_12;
    }
    if ( dword_10110918 )
    {
      if ( (unsigned int)(sub_100181D0() - dword_10110918) > 0xBB8 )
      {
        v6 = 0;
        dword_10110918 = 0;
        sub_10002510((int)&v4);
      }
    }
    else
    {
      dword_10110918 = sub_100181D0();
    }
LABEL_12:
    if ( v5 == 1 )
    {
      if ( sub_1001CFC0() == 9.9999996e24 )
      {
        v5 = 0;
        dword_10110914 = 0;
        sub_10002510((int)&v4);
LABEL_22:
        v3 = sub_100181D0();
        return sub_1000CE40(a1, 1, a2, &v4, v3);
      }
      if ( v5 == 1 && !sub_1001CFF0() )
      {
        if ( dword_10110914 )
        {
          if ( (unsigned int)(sub_100181D0() - dword_10110914) > 0x7530 )
          {
            v5 = 0;
            dword_10110914 = 0;
            sub_10002510((int)&v4);
          }
        }
        else
        {
          dword_10110914 = sub_100181D0();
        }
        goto LABEL_22;
      }
    }
    dword_10110914 = 0;
    goto LABEL_22;
  }
  return result;
}
// 10110914: using guessed type int dword_10110914;
// 10110918: using guessed type int dword_10110918;

//----- (10002B80) --------------------------------------------------------
char **sub_10002B80()
{
  return off_10064258;
}
// 10064258: using guessed type char *off_10064258[3];

//----- (10002B90) --------------------------------------------------------
char __usercall sub_10002B90@<al>(char a1@<dl>, int a2@<ecx>, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  int v5; // [sp+4h] [bp-528h]@1
  int v6; // [sp+8h] [bp-524h]@1
  char v7; // [sp+Ch] [bp-520h]@1

  v5 = a3;
  v4 = -32697;
  v6 = a2;
  v7 = a1;
  return sub_10021140((int)&v4);
}

//----- (10002BE0) --------------------------------------------------------
char __cdecl sub_10002BE0(int a1, int a2, char a3)
{
  return sub_10002B90(a3, a2, a1);
}

//----- (10002C00) --------------------------------------------------------
char __cdecl sub_10002C00(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+8h] [bp-14h]@2
  char v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  char v7; // [sp+14h] [bp-8h]@2

  result = sub_1000DA70(a1, a2, &v6, (unsigned __int16 *)&v5);
  if ( result )
  {
    v3 = sub_1000C2A0(a1, a2);
    v4 = 2;
    if ( !v7 )
      v4 = 3;
    result = sub_10002BE0(v3, v6, v4);
  }
  return result;
}

//----- (10002C70) --------------------------------------------------------
char __cdecl sub_10002C70(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8)
{
  int v8; // eax@1
  char result; // al@1
  int v10; // [sp+4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-14h]@1
  int v12; // [sp+Ch] [bp-10h]@1
  int v13; // [sp+10h] [bp-Ch]@1
  int v14; // [sp+14h] [bp-8h]@1

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  v8 = sub_100181D0();
  sub_1000D150(760, a7, 1, (int)&byte_10222BE0, &v10, v8);
  result = sub_1000D440(760, a1, (int)&byte_10222BE0);
  if ( a8 )
    result = sub_10002BE0(a1, v10, 1);
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10002D10) --------------------------------------------------------
int __cdecl sub_10002D10(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100211F0(a1);
  return sub_10018690(v2, a2, 160);
}

//----- (10002D40) --------------------------------------------------------
char __cdecl sub_10002D40(int a1)
{
  int v1; // edx@1
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // ecx@1
  char v7; // [sp+Ch] [bp-208h]@1
  int v8; // [sp+4Bh] [bp-1C9h]@1
  int v9; // [sp+4Fh] [bp-1C5h]@1
  int v10; // [sp+53h] [bp-1C1h]@1
  int v11; // [sp+57h] [bp-1BDh]@1
  int v12; // [sp+5Ch] [bp-1B8h]@1
  int v13; // [sp+60h] [bp-1B4h]@1
  __int16 v14; // [sp+64h] [bp-1B0h]@1
  char v15; // [sp+66h] [bp-1AEh]@1
  char v16; // [sp+BAh] [bp-15Ah]@1
  char v17; // [sp+FAh] [bp-11Ah]@1

  sub_100185C0(6444, (int)&v7, 514);
  v1 = *(_DWORD *)(a1 + 13324);
  v2 = *(_DWORD *)(a1 + 13328);
  v8 = *(_DWORD *)(a1 + 13320);
  v3 = *(_DWORD *)(a1 + 13332);
  v9 = v1;
  LOWORD(v1) = *(_WORD *)(a1 + 13336);
  v11 = v3;
  v10 = v2;
  v4 = *(_DWORD *)(a1 + 12032);
  v14 = v1;
  LOBYTE(v1) = *(_BYTE *)(a1 + 13488);
  qmemcpy(&v15, (const void *)(a1 + 13340), 0x54u);
  v5 = *(_DWORD *)(a1 + 12036);
  v12 = v4;
  v13 = v5;
  qmemcpy(&v16, (const void *)(a1 + 13424), 0x40u);
  v17 = v1;
  return sub_10018730(6444, (int)&v7, 514);
}

//----- (10002E20) --------------------------------------------------------
int __cdecl sub_10002E20(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100212E0(a1);
  return sub_100186F0(v2, a2, 2192);
}

//----- (10002E50) --------------------------------------------------------
int sub_10002E50()
{
  int result; // eax@1

  result = 0;
  dword_1011612C = 0;
  dword_10110924 = 0;
  return result;
}
// 10110924: using guessed type int dword_10110924;
// 1011612C: using guessed type int dword_1011612C;

//----- (10002E60) --------------------------------------------------------
char sub_10002E60()
{
  return *(_BYTE *)(dword_10116128 + 3);
}
// 10116128: using guessed type int dword_10116128;

//----- (10002E70) --------------------------------------------------------
int sub_10002E70()
{
  return dword_10110924;
}
// 10110924: using guessed type int dword_10110924;

//----- (10002E80) --------------------------------------------------------
char sub_10002E80()
{
  return *(_BYTE *)(dword_10116128 + 1);
}
// 10116128: using guessed type int dword_10116128;

//----- (10002E90) --------------------------------------------------------
char sub_10002E90()
{
  return byte_10116130;
}
// 10116130: using guessed type char byte_10116130;

//----- (10002EA0) --------------------------------------------------------
void sub_10002EA0()
{
  ++dword_10110924;
}
// 10110924: using guessed type int dword_10110924;

//----- (10002EB0) --------------------------------------------------------
int (__cdecl *sub_10002EB0())(_DWORD)
{
  unsigned int v0; // esi@1
  int (__cdecl *result)(_DWORD); // eax@2

  v0 = 0;
  do
  {
    result = *(int (__cdecl **)(_DWORD))((char *)&off_10067138 + v0);
    if ( result )
      result = (int (__cdecl *)(_DWORD))result((unsigned __int8)byte_10067110[v0]);
    v0 += 44;
  }
  while ( v0 < 0x268 );
  return result;
}
// 10067138: using guessed type int (*off_10067138)();

//----- (10002EE0) --------------------------------------------------------
int __cdecl sub_10002EE0(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@2
  int result; // eax@6

  *(_BYTE *)(dword_10116128 + 3) = a3;
  if ( a5 )
  {
    v7 = dword_10116128 + 5;
    *(_WORD *)v7 = *(_WORD *)a5;
    *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  }
  if ( a7 > 0x27100 )
  {
    *(_DWORD *)(dword_10116128 + 160008) = 0;
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1412, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_10116128 + 8), a6, a7);
    *(_DWORD *)(dword_10116128 + 160008) = a7;
  }
  result = dword_10116128;
  *(_BYTE *)(dword_10116128 + 4) = a4;
  LOBYTE(result) = a2;
  *(_BYTE *)(dword_10116128 + 2) = a2;
  *(_BYTE *)(dword_10116128 + 1) = a1;
  return result;
}
// 10116128: using guessed type int dword_10116128;

//----- (10002F90) --------------------------------------------------------
void *__cdecl sub_10002F90(int a1)
{
  int v1; // eax@7
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, int, int, int); // ecx@8
  void *result; // eax@9

  *(_BYTE *)dword_10116128 = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 7u:
      dword_10110920 = sub_100181D0();
      break;
    case 8u:
      dword_10116134 = sub_100181D0();
      break;
    case 9u:
      dword_10116138 = sub_100181D0();
      break;
  }
  v1 = sub_1001E7B0((_DWORD *)(dword_10116128 + 2), 1u, (int)byte_10067110, 44, 14, 57);
  if ( v1 >= 57
    || (v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, int))*(&off_10067130 + 11 * v1)) == 0
    || (result = (void *)v2(
                           *(_BYTE *)(dword_10116128 + 2),
                           *(_BYTE *)(dword_10116128 + 3),
                           *(_BYTE *)(dword_10116128 + 4),
                           dword_10116128 + 5,
                           a1,
                           dword_10116128 + 160012),
        !(_BYTE)result) )
  {
    result = memset((void *)(dword_10116128 + 160012), 0, 0x64u);
  }
  return result;
}
// 10067130: using guessed type int (__cdecl *off_10067130)(int, int, int, int, char, char *);
// 10110920: using guessed type int dword_10110920;
// 10116128: using guessed type int dword_10116128;
// 10116134: using guessed type int dword_10116134;
// 10116138: using guessed type int dword_10116138;

//----- (10003050) --------------------------------------------------------
signed int __usercall sub_10003050@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4)
{
  __int16 v4; // bx@1
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  signed int result; // eax@2
  void *v8; // eax@3
  unsigned int v9; // ecx@5
  int v10; // edx@13
  signed int v11; // ebx@13
  char *v12; // ecx@14
  int v13; // esi@14
  int v14; // eax@18
  unsigned int v15; // edi@18
  int v16; // eax@19
  unsigned int v17; // edx@19
  int v18; // eax@20
  int v19; // ecx@23
  bool v20; // cf@34
  char v21; // [sp+Ah] [bp-96h]@17
  char v22; // [sp+Bh] [bp-95h]@17
  int v23; // [sp+Ch] [bp-94h]@1
  int v24; // [sp+10h] [bp-90h]@18
  char *v25; // [sp+14h] [bp-8Ch]@14
  int v26; // [sp+18h] [bp-88h]@13
  int v27[32]; // [sp+20h] [bp-80h]@7

  v4 = word_10222BC0;
  v5 = 0;
  v6 = a1;
  v23 = 0;
  if ( word_10222BC0 == 1491 )
  {
    result = 0;
  }
  else
  {
    v8 = &unk_102229C0;
    do
    {
      if ( *((_WORD *)v8 + 2) == v4 )
      {
        v9 = *(_WORD *)v8;
        if ( v6 >= v9 && v6 < v9 + *((_WORD *)v8 + 1) )
        {
          v27[v23++] = (int)v8;
          if ( *((_DWORD *)v8 + 2) == -1 && *((_DWORD *)v8 + 3) == -1 )
            return 0;
        }
      }
      v5 += 16;
      v8 = (char *)v8 + 16;
    }
    while ( v5 < 0x200 );
    if ( v23 )
    {
      v10 = 0;
      v11 = 0;
      v26 = 0;
      if ( a4 )
      {
        v12 = a3;
        v13 = a2 - (_DWORD)a3;
        v25 = a3;
        while ( !v11 )
        {
          v22 = v12[v13];
          v21 = *v12;
          if ( v22 != *v12 )
          {
            v14 = 0;
            v15 = 8 * v10;
            v11 = -34;
            v24 = 0;
            if ( v23 > 0 )
            {
              while ( 1 )
              {
                v16 = v27[v14];
                v17 = *(_DWORD *)(v16 + 8);
                if ( v15 + 7 >= v17 )
                {
                  v18 = *(_DWORD *)(v16 + 12);
                  if ( v15 < v18 + v17 )
                    break;
                }
LABEL_31:
                v14 = v24++ + 1;
                if ( v24 >= v23 )
                  goto LABEL_34;
              }
              if ( v17 & 7 || v18 & 7 )
              {
                v19 = 0;
                while ( 1 )
                {
                  if ( (1 << v19) & (unsigned __int8)(v21 ^ v22) )
                  {
                    if ( v19 + v15 < v17 || v19 + v15 >= v18 + v17 )
                    {
                      v11 = -34;
                      goto LABEL_31;
                    }
                    v11 = 0;
                  }
                  if ( (unsigned int)++v19 >= 8 )
                    goto LABEL_31;
                }
              }
              v11 = 0;
            }
          }
LABEL_34:
          v10 = v26 + 1;
          v12 = v25 + 1;
          v20 = v26++ + 1 < (unsigned int)a4;
          ++v25;
          if ( !v20 )
          {
            if ( !v11 )
              goto LABEL_37;
            break;
          }
          v13 = a2 - (_DWORD)a3;
        }
        sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 2449, 0, "no perm for reg_tag bits\n");
      }
LABEL_37:
      result = v11;
    }
    else
    {
      sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 2367, 0, "no perm for reg_tag\n");
      result = -34;
    }
  }
  return result;
}
// 10222BC0: using guessed type __int16 word_10222BC0;
// 10003050: using guessed type int var_80[32];

//----- (10003230) --------------------------------------------------------
signed int sub_10003230()
{
  signed int result; // eax@2

  if ( sub_10018F80((LONG)&off_10067378) )
  {
    *(_BYTE *)dword_10116128 = 0;
    *(_BYTE *)(dword_10116128 + 2) = 67;
    result = sub_10018B10((int)&off_10067378);
  }
  else
  {
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 2504, 1, 0);
    result = sub_10018B10((int)&off_10067378);
  }
  return result;
}
// 10067378: using guessed type char *off_10067378;
// 10116128: using guessed type int dword_10116128;

//----- (10003280) --------------------------------------------------------
void *sub_10003280()
{
  void *result; // eax@1

  result = (void *)(sub_100181D0() - dword_10116138);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10002F90(0);
  return result;
}
// 10116138: using guessed type int dword_10116138;

//----- (100032A0) --------------------------------------------------------
void *sub_100032A0()
{
  void *result; // eax@1

  result = (void *)(sub_100181D0() - dword_10110920);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10002F90(0);
  return result;
}
// 10110920: using guessed type int dword_10110920;

//----- (100032C0) --------------------------------------------------------
void *sub_100032C0()
{
  void *result; // eax@1

  result = (void *)(sub_100181D0() - dword_10116134);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10002F90(0);
  return result;
}
// 10116134: using guessed type int dword_10116134;

//----- (100032E0) --------------------------------------------------------
char __cdecl sub_100032E0(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@5
  char result; // al@9

  if ( *(_BYTE *)dword_10116128 == 11 )
    sub_1001D010();
  if ( *(_BYTE *)dword_10116128 )
    sub_10002F90(0);
  *(_BYTE *)(dword_10116128 + 3) = a3;
  v7 = dword_10116128 + 5;
  *(_WORD *)v7 = *(_WORD *)a5;
  *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  if ( a7 >= 0x27100 )
  {
    *(_DWORD *)(dword_10116128 + 160008) = 0;
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1198, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_10116128 + 8), a6, a7);
    *(_DWORD *)(dword_10116128 + 160008) = a7;
    *(_BYTE *)(dword_10116128 + a7 + 8) = 0;
  }
  *(_BYTE *)(dword_10116128 + 4) = a4;
  *(_BYTE *)(dword_10116128 + 2) = a2;
  *(_BYTE *)(dword_10116128 + 1) = a1;
  dword_1011612C = 0;
  dword_10110924 = 0;
  byte_10116130 = 0;
  switch ( a1 )
  {
    case 0:
      result = (unsigned int)sub_10002F90(9);
      break;
    case 1:
      result = (unsigned int)sub_10002F90(5);
      byte_10116130 = 1;
      break;
    case 2:
      result = (unsigned int)sub_10002F90(2);
      break;
    case 3:
      result = (unsigned int)sub_10002F90(1);
      break;
    case 4:
    case 6:
      result = (unsigned int)sub_10002F90(6);
      break;
    case 5:
      if ( a3 )
        goto LABEL_16;
      result = (unsigned int)sub_10002F90(6);
      goto LABEL_17;
    case 7:
LABEL_16:
      result = (unsigned int)sub_10002F90(2);
LABEL_17:
      if ( a4 == 11 )
        byte_10116130 = 1;
      break;
    default:
      result = sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1301, 0, 0);
      break;
  }
  return result;
}
// 10110924: using guessed type int dword_10110924;
// 10116128: using guessed type int dword_10116128;
// 1011612C: using guessed type int dword_1011612C;
// 10116130: using guessed type char byte_10116130;

//----- (10003480) --------------------------------------------------------
void *sub_10003480()
{
  void *result; // eax@1

  dword_10116128 = -15;
  sub_10003230();
  result = memset(&unk_102229C0, 0, 0x200u);
  word_10222BC0 = 0;
  dword_10116138 = 0;
  dword_10110920 = 0;
  dword_10116134 = 0;
  dword_1011613C = 0;
  return result;
}
// 10110920: using guessed type int dword_10110920;
// 10116128: using guessed type int dword_10116128;
// 10116134: using guessed type int dword_10116134;
// 10116138: using guessed type int dword_10116138;
// 1011613C: using guessed type int dword_1011613C;
// 10222BC0: using guessed type __int16 word_10222BC0;

//----- (100034D0) --------------------------------------------------------
char __usercall sub_100034D0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4)
{
  char *v4; // esi@1
  signed int v5; // eax@1
  unsigned int v6; // eax@2
  _DWORD *v7; // ecx@2
  char *v8; // edx@2
  int v9; // esi@6
  int v10; // eax@7
  _BYTE *v11; // ecx@7
  _BYTE *v12; // edx@7
  int v13; // eax@9
  _BYTE *v14; // ecx@9
  _BYTE *v15; // edx@9
  _BYTE *v16; // ecx@11
  _BYTE *v17; // edx@11
  signed int v18; // eax@13
  unsigned __int16 v20; // [sp+0h] [bp-8h]@0

  v4 = a1;
  v5 = sub_10003050(a4, a2, a1, v20);
  if ( !v5 )
  {
    v6 = a3;
    v7 = (_DWORD *)a2;
    v8 = v4;
    if ( a3 < 4u )
    {
LABEL_5:
      if ( !v6 )
        goto LABEL_15;
    }
    else
    {
      while ( *(_DWORD *)v8 == *v7 )
      {
        v6 -= 4;
        ++v7;
        v8 += 4;
        if ( v6 < 4 )
          goto LABEL_5;
      }
    }
    v9 = (unsigned __int8)*v8 - *(_BYTE *)v7;
    if ( (unsigned __int8)*v8 != *(_BYTE *)v7
      || (v10 = v6 - 1, v11 = (char *)v7 + 1, v12 = v8 + 1, v10)
      && ((v9 = *v12 - *v11, *v12 != *v11)
       || (v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, v13)
       && ((v9 = *v15 - *v14, *v15 != *v14)
        || (v16 = v14 + 1, v17 = v15 + 1, v13 != 1) && (v9 = *v17 - *v16, *v17 != *v16))) )
    {
      v18 = 1;
      if ( v9 <= 0 )
        v18 = -1;
      goto LABEL_16;
    }
LABEL_15:
    v18 = 0;
LABEL_16:
    if ( v18 )
    {
      if ( a4 > 0x1B31 )
        LOBYTE(v5) = sub_10018670(a4, a2, a3);
      else
        LOBYTE(v5) = sub_10018690(a4, a2, a3);
    }
    else
    {
      LOBYTE(v5) = 0;
    }
  }
  return v5;
}

//----- (100035A0) --------------------------------------------------------
char __cdecl sub_100035A0(int a1)
{
  char *v1; // ecx@0
  int v2; // edi@1
  char v3; // al@1
  int v4; // esi@1
  _WORD *v5; // esi@2
  int v6; // ebp@3
  int v7; // esi@4
  int v8; // edi@4
  char v9; // bl@4
  int v10; // eax@4
  __int16 v11; // di@4
  int v12; // eax@6
  int v13; // eax@11
  bool v14; // sf@17
  unsigned __int8 v15; // of@17
  char v17; // bl@25
  char v18; // ST10_1@29
  char v19; // al@29
  char v20; // [sp+13h] [bp-99h]@1
  unsigned __int16 v21; // [sp+14h] [bp-98h]@1
  _WORD *v22; // [sp+18h] [bp-94h]@2
  char *v23; // [sp+1Ch] [bp-90h]@1
  int v24; // [sp+20h] [bp-8Ch]@1
  int v25; // [sp+24h] [bp-88h]@1
  char v26[4]; // [sp+28h] [bp-84h]@1
  int v27; // [sp+2Ch] [bp-80h]@4
  int v28; // [sp+30h] [bp-7Ch]@4
  unsigned int v29; // [sp+34h] [bp-78h]@4
  char v30; // [sp+3Ch] [bp-70h]@6
  char v31; // [sp+44h] [bp-68h]@8

  v2 = (int)v1;
  v25 = a1;
  v3 = *v1;
  v23 = v1;
  v20 = 0;
  v26[0] = v3;
  v4 = sub_10003C60(v3, &v21);
  sub_10018540(9171, (int)&word_10222BC0, 2);
  sub_10018540(6451, (int)&unk_102229C0, 512);
  v24 = 0;
  if ( v21 )
  {
    v5 = (_WORD *)(v4 + 2);
    v22 = v5;
    while ( 1 )
    {
      v6 = 0;
      if ( !*v5 )
        goto LABEL_16;
      while ( 1 )
      {
        v7 = v6 + *(v22 - 1);
        v27 = 0;
        v28 = 0;
        v29 = 0;
        j_reg_get_tag_hdr(&v27, v7, v7);
        v8 = *(unsigned int *)((char *)&v29 + 2);
        memset(&dword_10116140, 0, HIWORD(v29));
        v9 = 0;
        v10 = sub_10018540(v7, (int)&dword_10116140, v8);
        v11 = HIWORD(v29);
        if ( v10 )
        {
          v9 = 1;
          memset(&dword_10116140, 0, HIWORD(v29));
        }
        memcpy(&dword_10110928, &dword_10116140, (unsigned __int16)v11);
        v12 = sub_10018560(v7, (int)&dword_10116140, v11, v25, (int)&v30);
        if ( !v12 )
          break;
        if ( v12 != -24 )
        {
          sub_1001F8F0(&v31, 0x64u, "error %i reading reg %i from xml\n", v12, v7);
          sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1946, 0, &v31);
          goto LABEL_15;
        }
LABEL_12:
        if ( ++v6 >= *v22 )
          goto LABEL_16;
      }
      v20 = 1;
      if ( v9 )
        dword_10110928 = ~dword_10116140;
      v13 = (unsigned __int8)sub_100034D0((char *)&dword_10110928, (int)&dword_10116140, HIWORD(v29), v7);
      if ( !(_BYTE)v13 )
        goto LABEL_12;
      sub_1001F8F0(&v31, 0x64u, "error %i writing reg %i oem_id %i\n", v13, v7, (unsigned __int16)word_10222BC0);
      sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1967, 0, &v31);
LABEL_15:
      v20 = 0;
LABEL_16:
      if ( v6 == *v22 )
      {
        v5 = v22 + 2;
        v15 = __OFSUB__(v24 + 1, v21);
        v14 = v24++ + 1 - v21 < 0;
        v22 += 2;
        if ( v14 ^ v15 )
          continue;
      }
      v2 = (int)v23;
      break;
    }
  }
  if ( !sub_10019500(v25) )
  {
    v20 = 0;
    sub_10018A40(
      "..\\lib\\adl\\iop_cnfg_mngr.c",
      1996,
      0,
      "The file being loaded was deleted during the upload process.");
LABEL_21:
    sub_10002F90(8);
    return v20;
  }
  if ( v20 != 1 )
    goto LABEL_21;
  if ( *(_BYTE *)v2 == 31 )
  {
    v17 = sub_10021730(&v31, 0x64u);
    v20 = v17;
    if ( !v17 )
      sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 2070, 0, &v31);
    if ( v17 != 1 )
      goto LABEL_21;
  }
  if ( *(_DWORD *)(v2 + 8) )
  {
    sub_10002F90(1);
    v18 = v26[0];
    v19 = sub_10002E80();
    sub_10002EE0(v19, v18, 0, 11, 0, 0, 0);
    sub_1000DC70();
  }
  else
  {
    sub_10002F90(7);
    sub_1000DC70();
  }
  return v20;
}
// 10018520: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 10110928: using guessed type int dword_10110928;
// 10116140: using guessed type int dword_10116140;
// 10222BC0: using guessed type __int16 word_10222BC0;

//----- (10003890) --------------------------------------------------------
int sub_10003890()
{
  char v0; // bl@1
  int v1; // esi@1
  int v2; // ecx@2
  int (__cdecl *v3)(int, int, char, int, int, int); // esi@3
  char v4; // al@5
  void (__cdecl *v5)(_DWORD); // ecx@12
  int result; // eax@14
  int (__cdecl *v7)(_DWORD, _DWORD, int); // esi@17
  int (__cdecl *v8)(_DWORD, _DWORD, _DWORD, int); // esi@21
  int v9; // edi@23
  char *v10; // eax@23
  int v11; // edx@23
  char v12; // cl@24
  int v13; // ebp@25
  int (__cdecl *v14)(_DWORD, _DWORD, _DWORD, int, int, _DWORD); // esi@29
  char v15; // [sp+8h] [bp-68h]@11

  v0 = 0;
  v1 = sub_1001E7B0((_DWORD *)(dword_10116128 + 2), 1u, (int)byte_10067110, 44, 14, 57);
  if ( v1 < 57 )
  {
    v2 = dword_10116128;
    switch ( *(_BYTE *)dword_10116128 )
    {
      case 1:
        v3 = off_10067118[11 * v1];
        goto LABEL_4;
      case 0:
        break;
      case 2:
        v7 = (int (__cdecl *)(_DWORD, _DWORD, int))*(&off_10067114 + 11 * v1);
        goto LABEL_18;
      case 3:
        v7 = (int (__cdecl *)(_DWORD, _DWORD, int))*(&off_10067124 + 11 * v1);
LABEL_18:
        if ( !v7 )
          goto LABEL_9;
        v4 = v7(*(_BYTE *)(dword_10116128 + 2), *(_BYTE *)(dword_10116128 + 4), dword_10116128 + 5);
        goto LABEL_6;
      case 4:
        v8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int))*(&off_10067128 + 11 * v1);
        if ( !v8 )
          goto LABEL_9;
        v4 = v8(
               *(_BYTE *)(dword_10116128 + 2),
               *(_BYTE *)(dword_10116128 + 3),
               *(_BYTE *)(dword_10116128 + 4),
               dword_10116128 + 5);
        goto LABEL_6;
      case 5:
        v9 = dword_10116128 + 8;
        v10 = (char *)(dword_10116128 + 8);
        v11 = dword_10116128 + 9;
        do
          v12 = *v10++;
        while ( v12 );
        v13 = (int)&v10[-v11];
        if ( sub_1001F810(&v10[v9 - 4] - v11, ".ini", 5) && !sub_1001F810((_BYTE *)(v9 + v13 - 5), ".greg", 6) )
          v0 = sub_100035A0(v9);
        j_FIL_vfs_sync_all();
        goto LABEL_7;
      case 6:
        v14 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))*(&off_1006711C + 11 * v1);
        if ( !v14 )
          goto LABEL_9;
        v4 = v14(
               *(_BYTE *)(dword_10116128 + 2),
               *(_BYTE *)(dword_10116128 + 3),
               *(_BYTE *)(dword_10116128 + 4),
               dword_10116128 + 5,
               dword_10116128 + 8,
               *(_DWORD *)(dword_10116128 + 160008));
        goto LABEL_6;
      case 0xB:
        v3 = (int (__cdecl *)(int, int, char, int, int, int))dword_10067120[11 * v1];
        goto LABEL_4;
      case 7:
        sub_100032A0();
        break;
      case 8:
        sub_100032C0();
        break;
      case 0xA:
        v3 = (int (__cdecl *)(int, int, char, int, int, int))dword_1006712C[11 * v1];
LABEL_4:
        if ( !v3 )
          goto LABEL_9;
        v4 = v3(
               *(_BYTE *)(dword_10116128 + 2),
               *(_BYTE *)(dword_10116128 + 3),
               *(_BYTE *)(dword_10116128 + 4),
               dword_10116128 + 5,
               dword_10116128 + 8,
               *(_DWORD *)(dword_10116128 + 160008));
LABEL_6:
        v0 = v4;
LABEL_7:
        if ( v0 != 1 )
          goto LABEL_8;
        break;
      case 9:
        sub_10003280();
        break;
      default:
        sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 972, 0, 0);
LABEL_8:
        v2 = dword_10116128;
LABEL_9:
        if ( (unsigned int)++dword_1011612C > 0x32 || (unsigned int)sub_10002E70() > 0x32 )
        {
          sprintf(&v15, "EXCEEDED RETRIES CNFG_PROD %d STATE %d\n", *(_BYTE *)(v2 + 2), *(_BYTE *)v2);
          sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr.c", 1009, 0, &v15);
          sub_10002F90(8);
        }
        break;
    }
  }
  v5 = (void (__cdecl *)(_DWORD))dword_10067134[11 * dword_1011613C];
  if ( v5 )
    v5((unsigned __int8)byte_10067110[44 * dword_1011613C]);
  result = dword_1011613C++ + 1;
  if ( (unsigned int)dword_1011613C >= 0xE )
    dword_1011613C = 0;
  return result;
}
// 100194A0: using guessed type int j_FIL_vfs_sync_all(void);
// 10067114: using guessed type int (__cdecl *off_10067114)(int);
// 10067118: using guessed type int (__cdecl *off_10067118[2])(int, int, char, int, int, int);
// 1006711C: using guessed type int (__cdecl *off_1006711C)(int, int, char, int, int, int);
// 10067120: using guessed type int dword_10067120[];
// 10067124: using guessed type int (__cdecl *off_10067124)(int);
// 10067128: using guessed type int (*off_10067128)();
// 1006712C: using guessed type int dword_1006712C[];
// 10067134: using guessed type int dword_10067134[];
// 10116128: using guessed type int dword_10116128;
// 1011612C: using guessed type int dword_1011612C;
// 1011613C: using guessed type int dword_1011613C;

//----- (10003B50) --------------------------------------------------------
int __cdecl sub_10003B50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_10068F10, 8, 67, 0);
  if ( v1 )
  {
    result = dword_10068F14[2 * v1];
  }
  else
  {
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 10068F14: using guessed type int dword_10068F14[];

//----- (10003BA0) --------------------------------------------------------
char __cdecl sub_10003BA0(char a1)
{
  int v1; // eax@1
  char result; // al@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_10068F10, 8, 67, 176);
  if ( v1 == 176 )
  {
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1991, 0, 0);
    result = -80;
  }
  else
  {
    result = byte_10068F11[8 * v1];
  }
  return result;
}

//----- (10003BF0) --------------------------------------------------------
char __cdecl sub_10003BF0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1001E7B0(&a1, 1u, (int)&unk_10068B70, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_10068B74[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 10068B74: using guessed type int dword_10068B74[];

//----- (10003C60) --------------------------------------------------------
int __cdecl sub_10003C60(char a1, _WORD *a2)
{
  int v2; // eax@1
  int v3; // ecx@1

  v2 = 8 * sub_1001E7B0(&a1, 1u, (int)&unk_10068B70, 16, 58, 67);
  v3 = *(int *)((char *)&off_10068B78 + v2 * 2);
  *a2 = word_10068B7C[v2];
  return v3;
}
// 10068B78: using guessed type void *off_10068B78;
// 10068B7C: using guessed type __int16 word_10068B7C[];

//----- (10003CA0) --------------------------------------------------------
char __cdecl sub_10003CA0(unsigned int a1)
{
  bool v1; // zf@2
  char result; // al@2
  unsigned int v3; // [sp+4h] [bp-4h]@1

  v3 = sub_100184F0(a1);
  if ( sub_1001E7B0(&v3, 4u, (int)&unk_10069128, 4, 16, -1) == -1
    || (v1 = sub_1001E7B0(&a1, 4u, (int)&unk_10068B64, 4, 3, -1) == -1, result = 1, !v1) )
  {
    result = 0;
  }
  return result;
}

//----- (10003D00) --------------------------------------------------------
signed int sub_10003D00()
{
  signed int result; // eax@1

  result = -15;
  dword_1011B940 = -15;
  dword_1011B944 = -15;
  return result;
}
// 1011B940: using guessed type int dword_1011B940;
// 1011B944: using guessed type int dword_1011B944;

//----- (10003D10) --------------------------------------------------------
signed int sub_10003D10()
{
  return sub_10018EB0((int)&off_10069168);
}
// 10069168: using guessed type char *off_10069168;

//----- (10003D20) --------------------------------------------------------
signed int sub_10003D20()
{
  return sub_10018EB0((int)&off_1006917C);
}
// 1006917C: using guessed type char *off_1006917C;

//----- (10003D30) --------------------------------------------------------
char __usercall sub_10003D30@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_10021140((int)&v9);
}

//----- (10003E90) --------------------------------------------------------
char __cdecl sub_10003E90(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_10003D10() == 1 )
  {
    *a1 = *(_BYTE *)dword_1011B940;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1011B940: using guessed type int dword_1011B940;

//----- (10003EC0) --------------------------------------------------------
char __cdecl sub_10003EC0(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@3

  if ( (unsigned __int8)sub_10003D20() != 1 || a1 >= 0x43u )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_BYTE *)(a1 + dword_1011B944);
    result = 1;
  }
  return result;
}
// 1011B944: using guessed type int dword_1011B944;

//----- (10003EF0) --------------------------------------------------------
char __cdecl sub_10003EF0(char a1, char a2, int a3)
{
  return sub_10003D30(2, a3, 0, a1, 0, a2, 0);
}

//----- (10003F20) --------------------------------------------------------
char __cdecl sub_10003F20(unsigned __int8 a1, char a2)
{
  char result; // al@3
  char v3; // [sp+7h] [bp-Dh]@3
  int v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( a1 >= 0x43u )
    sub_10018A40("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2085, 0, 0);
  result = sub_10003EC0(a1, &v3);
  if ( result == 1 )
  {
    result = a2;
    if ( v3 != a2 )
    {
      LOWORD(v4) = -32748;
      LOBYTE(v5) = a1;
      HIBYTE(v5) = a2;
      result = sub_10021140((int)&v4);
    }
  }
  return result;
}

//----- (10003FA0) --------------------------------------------------------
char __cdecl sub_10003FA0(char a1)
{
  char v1; // si@1
  char v2; // bl@1
  unsigned int v3; // eax@6
  _DWORD *v4; // ecx@6
  char *v5; // edx@6
  int v6; // esi@10
  int v7; // eax@11
  _BYTE *v8; // ecx@11
  _BYTE *v9; // edx@11
  int v10; // eax@13
  _BYTE *v11; // ecx@13
  _BYTE *v12; // edx@13
  _BYTE *v13; // ecx@15
  _BYTE *v14; // edx@15
  signed int v15; // eax@17
  unsigned int v16; // eax@21
  _DWORD *v17; // ecx@21
  char *v18; // edx@21
  int v19; // esi@25
  int v20; // eax@26
  _BYTE *v21; // ecx@26
  _BYTE *v22; // edx@26
  int v23; // eax@28
  _BYTE *v24; // ecx@28
  _BYTE *v25; // edx@28
  _BYTE *v26; // ecx@30
  _BYTE *v27; // edx@30
  signed int v28; // eax@32
  char v30; // [sp+10h] [bp-A4h]@1
  float v31; // [sp+34h] [bp-80h]@3
  float v32; // [sp+38h] [bp-7Ch]@3
  char v33; // [sp+64h] [bp-50h]@21

  v1 = sub_1001E610(a1);
  v2 = sub_1001E660(v1, &v30);
  if ( v2 != 1 )
    goto LABEL_37;
  if ( word_1011B952 )
  {
    flt_1011B974 = v31;
    flt_1011B978 = v32;
  }
  if ( sub_10002D10(v1, (int)&v30) )
    v2 = 0;
  v3 = 44;
  v4 = &unk_1011B950;
  v5 = &v30;
  do
  {
    if ( *(_DWORD *)v5 != *v4 )
      goto LABEL_10;
    v3 -= 4;
    ++v4;
    v5 += 4;
  }
  while ( v3 >= 4 );
  if ( !v3 )
  {
LABEL_19:
    v15 = 0;
    goto LABEL_20;
  }
LABEL_10:
  v6 = (unsigned __int8)*v5 - *(_BYTE *)v4;
  if ( (unsigned __int8)*v5 == *(_BYTE *)v4 )
  {
    v7 = v3 - 1;
    v8 = (char *)v4 + 1;
    v9 = v5 + 1;
    if ( !v7 )
      goto LABEL_19;
    v6 = *v9 - *v8;
    if ( *v9 == *v8 )
    {
      v10 = v7 - 1;
      v11 = v8 + 1;
      v12 = v9 + 1;
      if ( !v10 )
        goto LABEL_19;
      v6 = *v12 - *v11;
      if ( *v12 == *v11 )
      {
        v13 = v11 + 1;
        v14 = v12 + 1;
        if ( v10 == 1 )
          goto LABEL_19;
        v6 = *v14 - *v13;
        if ( *v14 == *v13 )
          goto LABEL_19;
      }
    }
  }
  v15 = 1;
  if ( v6 <= 0 )
    v15 = -1;
LABEL_20:
  if ( v15 )
    goto LABEL_36;
  v16 = 36;
  v17 = &unk_1011B9A4;
  v18 = &v33;
  do
  {
    if ( *(_DWORD *)v18 != *v17 )
      goto LABEL_25;
    v16 -= 4;
    ++v17;
    v18 += 4;
  }
  while ( v16 >= 4 );
  if ( !v16 )
  {
LABEL_34:
    v28 = 0;
    goto LABEL_35;
  }
LABEL_25:
  v19 = (unsigned __int8)*v18 - *(_BYTE *)v17;
  if ( (unsigned __int8)*v18 == *(_BYTE *)v17 )
  {
    v20 = v16 - 1;
    v21 = (char *)v17 + 1;
    v22 = v18 + 1;
    if ( !v20 )
      goto LABEL_34;
    v19 = *v22 - *v21;
    if ( *v22 == *v21 )
    {
      v23 = v20 - 1;
      v24 = v21 + 1;
      v25 = v22 + 1;
      if ( !v23 )
        goto LABEL_34;
      v19 = *v25 - *v24;
      if ( *v25 == *v24 )
      {
        v26 = v24 + 1;
        v27 = v25 + 1;
        if ( v23 == 1 )
          goto LABEL_34;
        v19 = *v27 - *v26;
        if ( *v27 == *v26 )
          goto LABEL_34;
      }
    }
  }
  v28 = 1;
  if ( v19 <= 0 )
    v28 = -1;
LABEL_35:
  if ( v28 )
  {
LABEL_36:
    v2 = 0;
    goto LABEL_37;
  }
  if ( v2 == 1 )
  {
    sub_10002F90(7);
    return v2;
  }
LABEL_37:
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() <= 5 )
    sub_10002F90(1);
  else
    sub_10002F90(8);
  return v2;
}
// 1011B952: using guessed type __int16 word_1011B952;
// 1011B974: using guessed type float flt_1011B974;
// 1011B978: using guessed type float flt_1011B978;

//----- (10004170) --------------------------------------------------------
char sub_10004170()
{
  if ( (unsigned int)(sub_100181D0() - dword_1011B9F0) > 0x3E8 )
    sub_10002F90((unsigned __int8)byte_1011B948);
  return 1;
}
// 1011B948: using guessed type char byte_1011B948;
// 1011B9F0: using guessed type int dword_1011B9F0;

//----- (100041A0) --------------------------------------------------------
char __cdecl sub_100041A0(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  int v6; // esi@1
  char v7; // al@2
  char result; // al@2

  v6 = sub_1001E7B0(&a5, 1u, (int)&unk_100699B8, 201, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    v7 = sub_1001E610(a1);
    strncpy(a6, &byte_100699B9[201 * v6] + 100 * (unsigned __int8)v7, 0x64u);
    result = 1;
  }
  return result;
}

//----- (10004200) --------------------------------------------------------
__int16 __usercall sub_10004200@<ax>(unsigned __int8 a1@<al>)
{
  return word_1006A194[a1];
}
// 1006A194: using guessed type __int16 word_1006A194[];

//----- (10004210) --------------------------------------------------------
__int16 __usercall sub_10004210@<ax>(unsigned __int8 a1@<al>)
{
  return word_1006A198[a1];
}
// 1006A198: using guessed type __int16 word_1006A198[];

//----- (10004220) --------------------------------------------------------
char __usercall sub_10004220@<al>(const void *a1@<edx>, int *a2@<ecx>, unsigned __int8 a3)
{
  int *v3; // edi@1
  const void *v4; // esi@1
  __int16 v5; // ax@1
  int v6; // ebx@1
  int v7; // eax@1
  int v9; // [sp+10h] [bp-150h]@1
  char v10; // [sp+14h] [bp-14Ch]@1

  v3 = a2;
  v4 = a1;
  memset(&v9, 0, 0x148u);
  v5 = sub_10004210(a3);
  v9 = *v3;
  v6 = (unsigned __int16)v5;
  qmemcpy(&v10, v4, 0x144u);
  v7 = sub_100181D0();
  sub_1000D150(v6, HIWORD(v9) + 4, 1, (int)&byte_10222BE0, &v9, v7);
  return sub_1000D440(v6, 0xFFFFFFF, (int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (100042C0) --------------------------------------------------------
char __cdecl sub_100042C0(unsigned __int8 a1)
{
  const void *v1; // ecx@0
  const void *v2; // esi@1
  int v3; // eax@1
  char result; // al@1
  int v5; // ST24_4@2
  unsigned __int16 v6; // ST14_2@2
  int v7; // eax@2
  char v8; // [sp+8h] [bp-150h]@1
  char v9; // [sp+9h] [bp-14Fh]@2
  int v10; // [sp+Ah] [bp-14Eh]@2

  v2 = v1;
  memset(&v8, 0, 0x148u);
  v3 = sub_1001E7B0(&a1, 1u, (int)&unk_1006A19C, 2, 2, 0);
  result = sub_1001DFD0(byte_1006A19D[2 * v3]);
  if ( result )
  {
    v8 = 12;
    v9 = 3;
    qmemcpy((char *)&v10 + 2, v2, 0xA0u);
    LOWORD(v10) = 160;
    v5 = sub_100181D0();
    v6 = v10 + 4;
    LOWORD(v7) = sub_10004200(a1);
    result = sub_1000D150(v7, v6, 1, (int)&byte_10222BE0, &v8, v5);
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10004380) --------------------------------------------------------
char sub_10004380()
{
  unsigned __int8 v0; // bl@1
  int v1; // eax@1
  unsigned __int8 v3; // [sp+4h] [bp-4h]@2

  v0 = 0;
  byte_1011B948 = 0;
  dword_1011B9F0 = 0;
  memset(&unk_1011B950, 0, 0xA0u);
  v1 = j_HWM_pvg_read_reg(1);
  if ( v1 == 1 )
  {
    v3 = 0;
    do
    {
      sub_100213A0(v3, (int)&unk_1011B950);
      LOBYTE(v1) = sub_100042C0(v3);
      v3 = ++v0;
    }
    while ( v0 < 2u );
  }
  return v1;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011B948: using guessed type char byte_1011B948;
// 1011B9F0: using guessed type int dword_1011B9F0;

//----- (100043F0) --------------------------------------------------------
char __cdecl sub_100043F0(unsigned __int8 a1)
{
  int v2; // [sp+0h] [bp-14Ch]@1
  char v3; // [sp+4h] [bp-148h]@1

  memset(&v3, 0, 0x144u);
  v2 = 524;
  sub_10004220(&v3, &v2, a1);
  return 1;
}

//----- (10004460) --------------------------------------------------------
char __cdecl sub_10004460(unsigned __int8 a1, const void *a2)
{
  __int16 v2; // ax@1
  int v3; // ebx@1
  unsigned __int8 v4; // dl@1
  int v6; // [sp+Ch] [bp-154h]@1
  char v7; // [sp+10h] [bp-150h]@1

  memset(&v7, 0, 0x144u);
  v2 = sub_10004200(a1);
  qmemcpy(&v7, a2, 0xA0u);
  v3 = (unsigned __int16)v2;
  v6 = 10486796;
  sub_10004220(&v7, &v6, v4);
  sub_1000C020(v3, (int)&byte_10222BE0);
  return 1;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10004510) --------------------------------------------------------
char __cdecl sub_10004510(char a1)
{
  unsigned __int8 v1; // si@1
  char v2; // bl@1
  char result; // al@4

  v1 = sub_1001E610(a1);
  v2 = sub_100043F0(v1);
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_100042C0(v1);
  if ( sub_10002E80() == 2 )
  {
    sub_10002F90(7);
    result = v2;
  }
  else
  {
    sub_10002F90(4);
    byte_1011B948 = 3;
    dword_1011B9F0 = sub_100181D0();
    result = v2;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011B948: using guessed type char byte_1011B948;
// 1011B9F0: using guessed type int dword_1011B9F0;

//----- (10004590) --------------------------------------------------------
char __cdecl sub_10004590(char a1, int a2, char a3, int a4, const void *a5, int a6)
{
  char v6; // bl@1
  char result; // al@6
  char v8; // [sp+Ch] [bp-ACh]@1
  char v9; // [sp+10h] [bp-A8h]@1

  memset(&v9, 0, 0xA0u);
  v6 = 0;
  v8 = sub_1001E610(a1);
  if ( a3 != 11
    || (a6 ? qmemcpy(&v9, a5, 0xA0u) : sub_100213A0(v8, (int)&v9),
        qmemcpy(&unk_1011B950, &v9, 0xA0u),
        v6 = sub_10004460(v8, &v9),
        v6 != 1) )
  {
    sub_10002F90(8);
    result = v6;
  }
  else
  {
    sub_10002F90(4);
    byte_1011B948 = 2;
    dword_1011B9F0 = sub_100181D0();
    result = 1;
  }
  return result;
}
// 1011B948: using guessed type char byte_1011B948;
// 1011B9F0: using guessed type int dword_1011B9F0;

//----- (10004680) --------------------------------------------------------
char __cdecl sub_10004680(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  char result; // al@2

  switch ( a5 )
  {
    case 0:
      sprintf(a6, &byte_10065A71);
      result = 1;
      break;
    case 1:
    case 4:
    case 5:
    case 6:
      sprintf(a6, "CONFIGURING GDL59");
      result = 1;
      break;
    case 2:
      sprintf(a6, "REQUESTING GDL59 CONFIG");
      result = 1;
      break;
    case 3:
      sprintf(a6, "VERIFYING GDL59 CONFIG");
      result = 1;
      break;
    case 7:
      sprintf(a6, "GDL59 CONFIGURED");
      result = 1;
      break;
    case 8:
      sprintf(a6, "GDL59 CONFIG FAILED");
      result = 1;
      break;
    case 9:
      sprintf(a6, "GDL59 CONFIG CANCELLED");
      result = 1;
      break;
    case 0xA:
      sprintf(a6, "STORING GDL59 CONFIG");
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10004780) --------------------------------------------------------
char __cdecl sub_10004780(int a1, char a2)
{
  char v2; // bl@1
  unsigned int v3; // eax@5
  _DWORD *v4; // ecx@5
  char *v5; // edx@5
  int v6; // esi@9
  int v7; // eax@10
  _BYTE *v8; // ecx@10
  _BYTE *v9; // edx@10
  int v10; // eax@12
  _BYTE *v11; // ecx@12
  _BYTE *v12; // edx@12
  _BYTE *v13; // ecx@14
  _BYTE *v14; // edx@14
  signed int v15; // eax@16
  unsigned int v16; // eax@25
  _DWORD *v17; // ecx@25
  char *v18; // edx@25
  int v19; // esi@29
  int v20; // eax@30
  _BYTE *v21; // ecx@30
  _BYTE *v22; // edx@30
  int v23; // eax@32
  _BYTE *v24; // ecx@32
  _BYTE *v25; // edx@32
  _BYTE *v26; // ecx@34
  _BYTE *v27; // edx@34
  signed int v28; // eax@36
  __int16 v30; // [sp+Ch] [bp-39FCh]@1
  char v31; // [sp+534h] [bp-34D4h]@4

  memset(&v30, 0, 0x528u);
  v2 = 0;
  switch ( a2 )
  {
    case 0xB:
      if ( j_HWM_pvg_read_reg(1) == 1 )
      {
        v30 = -32721;
        sub_10021180((int)&v30);
      }
      if ( !sub_100214E0(&v31) )
        goto LABEL_40;
      v3 = 13520;
      v4 = &unk_1011BA08;
      v5 = &v31;
      do
      {
        if ( *(_DWORD *)v5 != *v4 )
          goto LABEL_9;
        v3 -= 4;
        ++v4;
        v5 += 4;
      }
      while ( v3 >= 4 );
      if ( !v3 )
        goto LABEL_18;
LABEL_9:
      v6 = (unsigned __int8)*v5 - *(_BYTE *)v4;
      if ( (unsigned __int8)*v5 != *(_BYTE *)v4
        || (v7 = v3 - 1, v8 = (char *)v4 + 1, v9 = v5 + 1, v7)
        && ((v6 = *v9 - *v8, *v9 != *v8)
         || (v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, v10)
         && ((v6 = *v12 - *v11, *v12 != *v11)
          || (v13 = v11 + 1, v14 = v12 + 1, v10 != 1) && (v6 = *v14 - *v13, *v14 != *v13))) )
      {
        v15 = 1;
        if ( v6 <= 0 )
          v15 = -1;
      }
      else
      {
LABEL_18:
        v15 = 0;
      }
      if ( v15 )
        goto LABEL_40;
      v2 = 1;
      goto LABEL_21;
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x2B:
      if ( j_HWM_pvg_read_reg(1) == 1 )
      {
        v30 = -32721;
        sub_10021180((int)&v30);
      }
      v2 = sub_100214E0(&v31);
      if ( v2 != 1 )
        goto LABEL_41;
      v16 = 13520;
      v17 = &unk_1011BA08;
      v18 = &v31;
      break;
    default:
      goto LABEL_41;
  }
  do
  {
    if ( *(_DWORD *)v18 != *v17 )
      goto LABEL_29;
    v16 -= 4;
    ++v17;
    v18 += 4;
  }
  while ( v16 >= 4 );
  if ( !v16 )
  {
LABEL_38:
    v28 = 0;
    goto LABEL_39;
  }
LABEL_29:
  v19 = (unsigned __int8)*v18 - *(_BYTE *)v17;
  if ( (unsigned __int8)*v18 == *(_BYTE *)v17 )
  {
    v20 = v16 - 1;
    v21 = (char *)v17 + 1;
    v22 = v18 + 1;
    if ( !v20 )
      goto LABEL_38;
    v19 = *v22 - *v21;
    if ( *v22 == *v21 )
    {
      v23 = v20 - 1;
      v24 = v21 + 1;
      v25 = v22 + 1;
      if ( !v23 )
        goto LABEL_38;
      v19 = *v25 - *v24;
      if ( *v25 == *v24 )
      {
        v26 = v24 + 1;
        v27 = v25 + 1;
        if ( v23 == 1 )
          goto LABEL_38;
        v19 = *v27 - *v26;
        if ( *v27 == *v26 )
          goto LABEL_38;
      }
    }
  }
  v28 = 1;
  if ( v19 <= 0 )
    v28 = -1;
LABEL_39:
  if ( v28 )
  {
LABEL_40:
    v2 = 0;
LABEL_41:
    sub_10002EA0();
    if ( (unsigned int)sub_10002E70() <= 0x18 )
      sub_10002F90(1);
    else
      sub_10002F90(8);
  }
  else
  {
LABEL_21:
    sub_10002F90(10);
  }
  return v2;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100049E0) --------------------------------------------------------
char sub_100049E0()
{
  if ( (unsigned int)(sub_100181D0() - dword_1011EED8) > 0x1388 )
    sub_10002F90((unsigned __int8)byte_1011B9F8);
  return 1;
}
// 1011B9F8: using guessed type char byte_1011B9F8;
// 1011EED8: using guessed type int dword_1011EED8;

//----- (10004A10) --------------------------------------------------------
char __cdecl sub_10004A10(_BYTE *a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  BYTE3(v3) = 0;
  result = sub_1000F100(2, 365, (char *)&v3 + 3);
  if ( result == 1 )
    *a1 = BYTE3(v3);
  return result;
}

//----- (10004A40) --------------------------------------------------------
int __thiscall sub_10004A40(void *this)
{
  int result; // eax@3

  byte_1011B9F9 = sub_1001FDE0(this);
  if ( byte_1011B9F9 == 4 )
    byte_1011B9F9 = 1;
  result = 0;
  dword_1011BA04 = 0;
  dword_1011BA00 = 0;
  dword_1011B9FC = 0;
  return result;
}
// 1011B9F9: using guessed type char byte_1011B9F9;
// 1011B9FC: using guessed type int dword_1011B9FC;
// 1011BA00: using guessed type int dword_1011BA00;
// 1011BA04: using guessed type int dword_1011BA04;

//----- (10004A70) --------------------------------------------------------
char __cdecl sub_10004A70(char a1)
{
  char result; // al@1

  result = a1;
  byte_1011B9F9 = a1;
  return result;
}
// 1011B9F9: using guessed type char byte_1011B9F9;

//----- (10004A80) --------------------------------------------------------
char __cdecl sub_10004A80(char a1)
{
  char v1; // cl@1
  void *v2; // ecx@6
  int v3; // esi@6
  void *v4; // ecx@6
  bool v5; // bl@6
  char result; // al@7
  int v7; // [sp+0h] [bp-4h]@1

  v7 = 0;
  sub_10004A70(a1);
  switch ( v1 )
  {
    case 1:
      v7 = 2;
      goto LABEL_6;
    case 2:
      v7 = 3;
      goto LABEL_6;
    case 8:
      v7 = 4;
      goto LABEL_6;
    case 0x10:
      v7 = 5;
LABEL_6:
      sub_1000EA90(0, 5, &v7, 0, 4, 1);
      v3 = sub_100206D0(v2);
      v5 = (j_HWM_pvg_hsdb_get_lrus_online() & 4) == 4;
      if ( v3 == 1 || (result = sub_1001FDC0(v4), !(result & 1)) && (v3 == 4 || v3 == 2 && !v5) )
        result = sub_1000ED50(0, 5, 0x8000);
      break;
    default:
      result = sub_10018A40("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg.c", 1218, 0, 0);
      break;
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10004B70) --------------------------------------------------------
char __cdecl sub_10004B70(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  int v4; // [sp+4h] [bp-10h]@0
  int v5; // [sp+8h] [bp-Ch]@1
  int v6; // [sp+Ch] [bp-8h]@1

  v2 = 0;
  LOBYTE(v4) = 0;
  v5 = 0;
  v6 = sub_100206D0(v1);
  if ( a1 == 17 )
  {
    LOWORD(v5) = 364;
    goto LABEL_5;
  }
  if ( a1 == 24 )
  {
    LOWORD(v5) = 363;
LABEL_5:
    v2 = 1;
    LOBYTE(v4) = 1;
  }
  sub_1000EA90(2, 0, &v5, 0, 8, v4);
  sub_1000ED50(2, 0, 0x8000);
  return v2;
}

//----- (10004C00) --------------------------------------------------------
char __usercall sub_10004C00@<al>(void *a1@<esi>)
{
  int v1; // eax@1

  sub_1000EA90(0, 321, a1, 0, 4, 1);
  sub_1000ED50(0, 321, 0x8000);
  memcpy(&unk_1011BA08, a1, 0x34D0u);
  v1 = j_HWM_pvg_read_reg(1);
  if ( !v1 )
    LOBYTE(v1) = sub_1000EC40(2, 363);
  return v1;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10004C60) --------------------------------------------------------
char __usercall sub_10004C60@<al>(void *a1@<esi>)
{
  sub_1000EA90(0, 321, a1, 0, 13520, 1);
  return sub_10002D40((int)a1);
}

//----- (10004C90) --------------------------------------------------------
char sub_10004C90()
{
  char v0; // bl@1

  v0 = sub_10004B70(24);
  if ( sub_10002E80() == 5 )
    sub_10002F90(10);
  else
    sub_10002F90(0);
  return v0;
}

//----- (10004CD0) --------------------------------------------------------
char __cdecl sub_10004CD0(int a1, int a2, char a3, int a4, void *a5, size_t a6)
{
  char v6; // bl@1
  char v8[12040]; // [sp+Ch] [bp-34D4h]@1
  char v9[1280]; // [sp+2F14h] [bp-5CCh]@12
  char v10[168]; // [sp+3414h] [bp-CCh]@5
  char v11; // [sp+34BCh] [bp-24h]@8

  memset(v8, 0, 0x34D0u);
  v6 = 0;
  switch ( a3 )
  {
    case 0xB:
      sub_10021500(v8);
      goto LABEL_13;
    case 0x1B:
      if ( !a6 )
        goto LABEL_4;
      sub_10021500(v8);
      v10[*(_BYTE *)a4] = *(_BYTE *)a5;
      goto LABEL_13;
    case 0x2B:
      if ( !a6 )
        goto LABEL_7;
      sub_10021500(v8);
      v11 = *(_BYTE *)a5;
      goto LABEL_13;
    case 0x19:
      if ( a6 )
      {
        sub_10021500(v8);
        memcpy(&v8[56 * *(_BYTE *)a4], a5, a6);
      }
      else
      {
LABEL_7:
        sub_10021500(v8);
      }
      goto LABEL_13;
    case 0x1A:
      if ( a6 )
      {
        sub_10021500(v8);
        memcpy(&v9[40 * *(_BYTE *)a4], a5, a6);
      }
      else
      {
LABEL_4:
        sub_10021500(v8);
      }
LABEL_13:
      sub_10004C00(v8);
      v6 = 1;
      sub_10002F90(4);
      byte_1011B9F8 = 3;
      dword_1011EED8 = sub_100181D0();
      break;
    default:
      sub_10002F90(8);
      break;
  }
  return v6;
}
// 1011B9F8: using guessed type char byte_1011B9F8;
// 1011EED8: using guessed type int dword_1011EED8;
// 10004CD0: using guessed type char var_34D4[12040];
// 10004CD0: using guessed type char var_CC[168];
// 10004CD0: using guessed type char var_5CC[1280];

//----- (10004EA0) --------------------------------------------------------
char __cdecl sub_10004EA0(int a1, char a2, char a3)
{
  char v3; // bl@1
  char v4; // al@4
  char v6; // [sp+8h] [bp-34D4h]@4

  v3 = 0;
  switch ( a3 )
  {
    case 0xB:
      if ( !a2 )
        goto LABEL_3;
      v4 = sub_100214E0(&v6);
      goto LABEL_7;
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x2B:
      if ( a2 )
      {
        v4 = sub_100214E0(&v6);
LABEL_7:
        v3 = v4;
        if ( v4 )
          sub_10004C60(&v6);
        if ( v3 == 1 )
        {
          sub_1000DC70();
          sub_10002F90(7);
        }
        else
        {
LABEL_11:
          sub_10002F90(8);
        }
      }
      else
      {
LABEL_3:
        sub_10004C60(&unk_1011BA08);
        v3 = 1;
        sub_1000DC70();
        sub_10002F90(7);
      }
      return v3;
    default:
      goto LABEL_11;
  }
}

//----- (10004F90) --------------------------------------------------------
char sub_10004F90()
{
  void *v0; // ecx@1
  char v1; // al@1
  void *v2; // ecx@1
  char v3; // al@2
  char v5; // [sp+3h] [bp-52Dh]@1
  __int16 v6; // [sp+4h] [bp-52Ch]@1

  v5 = 0;
  memset(&v6, 0, 0x528u);
  sub_100206D0(v0);
  v1 = sub_10004A10(&v5);
  LOBYTE(v2) = byte_1011B9F9;
  if ( v1 == 1 )
    v3 = v5;
  else
    v3 = byte_1011B9F9 == 0;
  if ( byte_1011B9F9 != v3 )
  {
    if ( sub_1001FDE0(v2) == 2 )
    {
      if ( (unsigned int)dword_1011BA00 <= 3 )
      {
        sub_10004A80(byte_1011B9F9);
        ++dword_1011BA00;
      }
    }
    else
    {
      sub_10004A80(byte_1011B9F9);
    }
  }
  v6 = -32716;
  return sub_10021180((int)&v6);
}
// 1011B9F9: using guessed type char byte_1011B9F9;
// 1011BA00: using guessed type int dword_1011BA00;

//----- (10005050) --------------------------------------------------------
char sub_10005050()
{
  int v0; // edi@1
  int v1; // esi@1
  void *v2; // ecx@1
  int v3; // eax@1
  void *v4; // ecx@1
  char v6; // [sp+Bh] [bp-34F5h]@14
  int v7; // [sp+Ch] [bp-34F4h]@9
  int v8; // [sp+10h] [bp-34F0h]@8
  char v9; // [sp+14h] [bp-34ECh]@17
  char v10; // [sp+15h] [bp-34EBh]@18
  char v11; // [sp+2Ch] [bp-34D4h]@10

  v0 = sub_100181D0();
  v1 = j_HWM_pvg_hsdb_get_lrus_online();
  LOWORD(v3) = sub_1001FDC0(v2);
  if ( v3 & 0x8000 && v1 & 0x8000 )
  {
    if ( !(dword_1011B9FC & 0x8000) && (dword_1011B9FC & 0x8000u) < 0x8000 )
      sub_10004F90();
    if ( dword_1011BA04 != 1 && sub_1001F430(v4) )
    {
      if ( sub_10021AD0(31, (unsigned int *)&v8) && sub_10021650(31, (unsigned int *)&v7) )
      {
        sub_10021500(&v11);
        if ( v8 != v7 )
        {
          sub_1001E570(0xD0u);
          sub_10003F20(0x1Fu, 0);
          sub_1001E460(209);
          sub_1001E460(210);
          sub_1001E460(211);
        }
        dword_1011BA04 = 1;
      }
      else if ( (unsigned int)(v0 - dword_1011EEDC) > 0x3E8 )
      {
        dword_1011EEDC = v0;
        if ( !sub_10003E90(&v6) || !v6 )
          sub_10004B70(17);
      }
    }
    LOBYTE(v3) = sub_1000E940(2, 0x16Bu, (int)&v9);
    if ( (_BYTE)v3 != 1 || v10 != 1 )
      LOBYTE(v3) = sub_10004B70(24);
  }
  dword_1011B9FC = v1;
  return v3;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1011B9FC: using guessed type int dword_1011B9FC;
// 1011BA04: using guessed type int dword_1011BA04;
// 1011EEDC: using guessed type int dword_1011EEDC;

//----- (100051C0) --------------------------------------------------------
char sub_100051C0()
{
  if ( j_HWM_pvg_read_reg(1) == 1 && (unsigned int)(sub_100181D0() - dword_1011FD78) > 0xA
    || (unsigned int)(sub_100181D0() - dword_1011FD78) > 0x3E8 )
  {
    sub_10002F90((unsigned __int8)byte_1011FD74);
  }
  return 1;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FD74: using guessed type char byte_1011FD74;
// 1011FD78: using guessed type int dword_1011FD78;

//----- (10005210) --------------------------------------------------------
char __cdecl sub_10005210(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  int v6; // esi@1
  char v7; // bl@2
  __int16 v8; // bp@2
  char *v9; // ST14_4@2
  char *v10; // eax@2
  char result; // al@2
  char v12[4]; // [sp+8h] [bp-4h]@1

  *(_DWORD *)v12 = 0;
  v6 = sub_1001E7B0(&a5, 1u, (int)&unk_1006B780, 401, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    v7 = sub_10024B60(a1);
    v8 = sub_10024D00(*(_BYTE *)(a4 + 1));
    sub_10024D40(*(_BYTE *)a4, *(_BYTE *)(a4 + 2), v12);
    v9 = sub_10024B20(word_100A4282[22 * *(_BYTE *)a4]);
    v10 = sub_10024B20(v8);
    sprintf(a6, &byte_1006B781[401 * v6] + 100 * (unsigned __int8)v7, v10, v12, v9);
    result = 1;
  }
  return result;
}
// 100A4282: using guessed type __int16 word_100A4282[];

//----- (100052D0) --------------------------------------------------------
char __fastcall sub_100052D0(char a1)
{
  char result; // al@1

  result = 44;
  switch ( a1 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      result = 5;
      break;
    case 5:
      result = 4;
      break;
    case 6:
      result = 10;
      break;
    case 7:
      result = 3;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10005310) --------------------------------------------------------
int __cdecl sub_10005310(char a1)
{
  return dword_1006B744[2 * sub_1001E7B0(&a1, 1u, (int)&unk_1006B740, 8, 8, 8)];
}
// 1006B744: using guessed type int dword_1006B744[];

//----- (10005340) --------------------------------------------------------
char __usercall sub_10005340@<al>(unsigned __int8 a1@<dl>, unsigned __int8 a2@<cl>, _BYTE *a3)
{
  char result; // al@1

  result = 0;
  if ( *(&byte_100A4284[44 * a1] + 5 * a2) )
  {
    *a3 = 0;
    result = 1;
  }
  return result;
}

//----- (10005360) --------------------------------------------------------
int __usercall sub_10005360@<eax>(int a1@<esi>, int a2)
{
  char *v2; // eax@2
  char v3; // cl@3
  int result; // eax@5
  char v5; // [sp+4h] [bp-78h]@1
  char v6; // [sp+1Ch] [bp-60h]@2
  _BYTE v7[3]; // [sp+1Dh] [bp-5Fh]@4

  memset(&v5, 0, 0x74u);
  if ( sub_100083A0(a2, &v5) != 1 )
    goto LABEL_9;
  v2 = &v6;
  do
    v3 = *v2++;
  while ( v3 );
  if ( v2 == v7 )
  {
LABEL_9:
    sprintf((char *)a1, "%s", "UNKNOWN");
    result = 0;
    *(_DWORD *)(a1 + 7) = 0;
    *(_BYTE *)(a1 + 11) = 0;
  }
  else
  {
    strncpy((char *)a1, &v6, 0xCu);
    result = 0;
    *(_DWORD *)(a1 + 6) = 0;
    *(_WORD *)(a1 + 10) = 0;
  }
  return result;
}

//----- (10005410) --------------------------------------------------------
char __usercall sub_10005410@<al>(_BYTE *a1@<edi>, int a2, unsigned __int8 a3)
{
  int v3; // eax@1
  int v4; // ecx@3
  char *v5; // eax@4
  char result; // al@7
  int v7; // [sp+8h] [bp-1Ch]@1
  int v8; // [sp+Ch] [bp-18h]@1
  int v9; // [sp+10h] [bp-14h]@1
  char v10[4]; // [sp+14h] [bp-10h]@1
  int v11; // [sp+18h] [bp-Ch]@1
  int v12; // [sp+1Ch] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  *(_DWORD *)v10 = 0;
  v11 = 0;
  v12 = 0;
  sub_10005360((int)&v7, a2);
  v3 = sub_1001E7B0(&v7, 0xCu, (int)"GEA 70", 15, 3, 3);
  if ( v3 == 3 )
  {
    sprintf(v10, "GEA 72");
    v3 = sub_1001E7B0((_DWORD *)v10, 0xCu, (int)"GEA 70", 15, 3, 3);
  }
  v4 = a3 + 1;
  if ( v4 >= 3 )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    v5 = (char *)&unk_100A4AAC + 15 * v3;
    while ( v5[v4] == 3 )
    {
      if ( ++v4 >= 3 )
        goto LABEL_7;
    }
    *a1 = v4;
    result = 1;
  }
  return result;
}

//----- (100054F0) --------------------------------------------------------
char __usercall sub_100054F0@<al>(unsigned __int8 a1@<dl>, char a2@<cl>, unsigned __int8 a3, unsigned __int8 *a4)
{
  unsigned __int8 v4; // cl@1
  char result; // al@1

  v4 = a2 + 1;
  result = 0;
  if ( v4 < (unsigned __int8)*(&byte_100A4284[44 * a3] + 5 * a1) )
  {
    result = 1;
    *a4 = v4;
  }
  return result;
}

//----- (10005520) --------------------------------------------------------
char __usercall sub_10005520@<al>(unsigned __int8 a1@<al>, char a2@<dl>, unsigned __int8 a3@<cl>, unsigned __int8 *a4@<esi>, int a5, unsigned __int8 *a6, char *a7)
{
  char v7; // bl@1

  *a6 = a1;
  *a4 = a3;
  v7 = 0;
  *a7 = a2;
  while ( v7 != 1 )
  {
    if ( sub_100054F0(*a4, *a7, *a6, (unsigned __int8 *)a7) == 1 )
      return 1;
    if ( *a4 + 1 >= 8 )
    {
      *a4 = 0;
      if ( *a6 >= 3u || sub_10005410(a6, a5, *a6) == 1 )
        goto LABEL_6;
      v7 = 1;
    }
    else
    {
      ++*a4;
LABEL_6:
      if ( !v7 && sub_10005340(*a6, *a4, a7) == 1 )
        return 1;
    }
  }
  return 0;
}

//----- (100055B0) --------------------------------------------------------
void *__cdecl sub_100055B0(int a1)
{
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() > 0xA )
    a1 = 8;
  return sub_10002F90(a1);
}

//----- (100055D0) --------------------------------------------------------
bool __usercall sub_100055D0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100A42A7[44 * a1] - (unsigned __int8)byte_100A42A2[44 * a1];
}

//----- (10005600) --------------------------------------------------------
bool __usercall sub_10005600@<al>(char a1@<bl>, unsigned __int16 a2@<si>)
{
  return a2 && a2 < (unsigned __int16)sub_1000E330(a1) && (unsigned __int8)a1 <= 6u;
}

//----- (10005620) --------------------------------------------------------
char __usercall sub_10005620@<al>(char a1@<al>, int a2, void *a3)
{
  int v3; // esi@1

  v3 = 369;
  switch ( a1 )
  {
    case 1:
      v3 = 371;
      break;
    case 2:
      v3 = 373;
      break;
    case 3:
      v3 = 503;
      break;
    case 0:
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg.c", 3882, 1, 0);
      break;
  }
  sub_1000EA90(0, v3, a3, 1, a2, 1);
  return sub_1000ED50(0, v3, 0xFFFFFFF);
}

//----- (100056A0) --------------------------------------------------------
void *__usercall sub_100056A0@<eax>(size_t a1@<eax>, int a2@<esi>, char a3)
{
  void *result; // eax@1

  result = memset((void *)a2, 0, a1);
  if ( a3 == 10 )
  {
    *(_BYTE *)(a2 + 1) = 0;
    *(_BYTE *)(a2 + 2) = 5;
    *(_BYTE *)(a2 + 3) = 2;
  }
  return result;
}

//----- (100056C0) --------------------------------------------------------
char __usercall sub_100056C0@<al>(char a1@<al>, unsigned __int8 a2@<dl>, unsigned __int8 a3@<cl>, char a4)
{
  char result; // al@2

  switch ( a4 )
  {
    case 5:
      result = sub_10024C60(a2, a3, a1, (unsigned __int8 *)&dword_1011FD44);
      byte_1011FD70 = 0;
      goto LABEL_6;
    case 4:
      result = sub_10024C60(a2, a3, a1, (unsigned __int8 *)&dword_1011FD44);
      byte_1011FD70 = 1;
      goto LABEL_6;
    case 0xA:
      result = sub_10024C60(a2, a3, a1, (unsigned __int8 *)&dword_1011FD44);
      byte_1011FD70 = 2;
      goto LABEL_6;
    case 3:
      result = sub_10024C60(a2, a3, a1, (unsigned __int8 *)&dword_1011FD44);
      byte_1011FD70 = 3;
LABEL_6:
      if ( result != 1 )
        goto LABEL_7;
      break;
    default:
LABEL_7:
      result = sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg.c", 4035, 0, 0);
      break;
  }
  return result;
}
// 1011FD44: using guessed type int dword_1011FD44;
// 1011FD70: using guessed type char byte_1011FD70;

//----- (10005770) --------------------------------------------------------
char __cdecl sub_10005770(char a1, char a2, int a3)
{
  char v3; // bl@3
  unsigned int v4; // eax@7
  int *v5; // ecx@7
  char *v6; // edx@7
  int v7; // eax@13
  signed int v8; // ecx@16
  bool v9; // zf@17
  int v10; // esi@32
  int v11; // eax@33
  _BYTE *v12; // ecx@33
  _BYTE *v13; // edx@33
  int v14; // eax@35
  _BYTE *v15; // ecx@35
  _BYTE *v16; // edx@35
  _BYTE *v17; // ecx@37
  _BYTE *v18; // edx@37
  signed int v19; // eax@39
  char v20; // ST14_1@47
  char v21; // ST10_1@47
  char v22; // al@47
  char v23; // al@47
  unsigned __int8 v24; // dl@47
  char result; // al@47
  char v26; // al@48
  int v27; // [sp+Ch] [bp-38h]@1
  int v28; // [sp+10h] [bp-34h]@1
  unsigned __int8 v29; // [sp+14h] [bp-30h]@1
  unsigned __int8 v30; // [sp+15h] [bp-2Fh]@14
  unsigned __int8 v31; // [sp+16h] [bp-2Eh]@15
  char v32; // [sp+40h] [bp-4h]@6

  memset(&v29, 0, 0x30u);
  LOWORD(v27) = 0;
  BYTE2(v27) = 0;
  LOBYTE(v28) = sub_10024B60(a1);
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_100078E0(v28, &dword_1011FD44);
  v3 = sub_10008A10(v28, (int)&v29);
  if ( v3 != 1 )
  {
    if ( sub_10002E80() != 7 )
    {
      sub_100055B0(1);
      return v3;
    }
    return v3;
  }
  switch ( a2 )
  {
    case 5:
      if ( v29 != (_BYTE)dword_1011FD44 || v32 )
        goto LABEL_51;
      v4 = 44;
      v5 = &dword_1011FD44;
      v6 = (char *)&v29;
      do
      {
        if ( *(_DWORD *)v6 != *v5 )
          goto LABEL_32;
        v4 -= 4;
        ++v5;
        v6 += 4;
      }
      while ( v4 >= 4 );
      goto LABEL_31;
    case 4:
      if ( v29 != (_BYTE)dword_1011FD44 || v32 != 1 )
        goto LABEL_51;
      v7 = v29 - (unsigned __int8)dword_1011FD44;
      if ( v29 == (unsigned __int8)dword_1011FD44
        && (v7 = v30 - BYTE1(dword_1011FD44), v30 == BYTE1(dword_1011FD44))
        && (v7 = v31 - BYTE2(dword_1011FD44), v31 == BYTE2(dword_1011FD44)) )
      {
        v8 = 0;
      }
      else
      {
        v8 = 1;
        if ( v7 <= 0 )
        {
          v9 = 0;
          goto LABEL_43;
        }
      }
      v9 = v8 == 0;
      goto LABEL_43;
    case 0xA:
      if ( v29 != (_BYTE)dword_1011FD44 || v32 != 2 )
        goto LABEL_51;
      v4 = 36;
      v5 = &dword_1011FD44;
      v6 = (char *)&v29;
      while ( *(_DWORD *)v6 == *v5 )
      {
        v4 -= 4;
        ++v5;
        v6 += 4;
        if ( v4 < 4 )
          goto LABEL_31;
      }
      goto LABEL_32;
    case 3:
      if ( v29 != (_BYTE)dword_1011FD44 || v32 != 3 )
        goto LABEL_51;
      v4 = 12;
      v5 = &dword_1011FD44;
      v6 = (char *)&v29;
      break;
    default:
      goto LABEL_51;
  }
  do
  {
    if ( *(_DWORD *)v6 != *v5 )
      goto LABEL_32;
    v4 -= 4;
    ++v5;
    v6 += 4;
  }
  while ( v4 >= 4 );
LABEL_31:
  if ( !v4 )
  {
LABEL_41:
    v19 = 0;
    goto LABEL_42;
  }
LABEL_32:
  v10 = (unsigned __int8)*v6 - *(_BYTE *)v5;
  if ( (unsigned __int8)*v6 == *(_BYTE *)v5 )
  {
    v11 = v4 - 1;
    v12 = (char *)v5 + 1;
    v13 = v6 + 1;
    if ( !v11 )
      goto LABEL_41;
    v10 = *v13 - *v12;
    if ( *v13 == *v12 )
    {
      v14 = v11 - 1;
      v15 = v12 + 1;
      v16 = v13 + 1;
      if ( !v14 )
        goto LABEL_41;
      v10 = *v16 - *v15;
      if ( *v16 == *v15 )
      {
        v17 = v15 + 1;
        v18 = v16 + 1;
        if ( v14 == 1 )
          goto LABEL_41;
        v10 = *v18 - *v17;
        if ( *v18 == *v17 )
          goto LABEL_41;
      }
    }
  }
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_42:
  v9 = v19 == 0;
LABEL_43:
  if ( !v9 )
  {
LABEL_51:
    if ( sub_10002E80() != 7 )
    {
      sub_100055B0(1);
      return 1;
    }
    sub_100055B0(2);
    return v3;
  }
  if ( sub_10002E80() == 7 )
  {
    if ( sub_10002E90() == 1 )
    {
      if ( sub_10005520(
             *(_BYTE *)a3,
             *(_BYTE *)(a3 + 2),
             *(_BYTE *)(a3 + 1),
             (unsigned __int8 *)&v27 + 1,
             v28,
             (unsigned __int8 *)&v27,
             (char *)&v27 + 2) == 1 )
      {
        v20 = sub_100052D0(SBYTE1(v27));
        v21 = sub_10002E60();
        v22 = sub_10002E80();
        sub_10002EE0(v22, a1, v21, v20, (int)&v27, 0, 0);
        v23 = sub_100052D0(SBYTE1(v27));
        sub_100056C0(SBYTE2(v27), v27, v24, v23);
        sub_10002F90(2);
        sub_10002E50();
        result = 1;
      }
      else
      {
        v26 = sub_10002E80();
        sub_10002EE0(v26, a1, 1, 17, 0, 0, 0);
        sub_10002F90(2);
        result = 1;
      }
    }
    else
    {
      sub_10002F90(7);
      result = 1;
    }
  }
  else
  {
    sub_10002F90(10);
    result = 1;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FD44: using guessed type int dword_1011FD44;

//----- (10005AF0) --------------------------------------------------------
char __cdecl sub_10005AF0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v4; // bl@1
  char v6; // [sp+7h] [bp-20Dh]@1
  char v7; // [sp+8h] [bp-20Ch]@1
  char v8; // [sp+9h] [bp-20Bh]@1
  int v9; // [sp+Ah] [bp-20Ah]@1

  v6 = 0;
  memset(&v7, 0, 0x208u);
  v7 = 12;
  v8 = 9;
  LOWORD(v9) = 1;
  v4 = sub_10024C60(a2, a3, a4, (unsigned __int8 *)&v6);
  if ( v4 == 1 )
  {
    BYTE2(v9) = v6;
    sub_10005620(a1, v9 + 4, &v7);
  }
  return v4;
}

//----- (10005BA0) --------------------------------------------------------
char __cdecl sub_10005BA0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v4; // bl@1
  char v6; // [sp+7h] [bp-20Dh]@1
  char v7; // [sp+8h] [bp-20Ch]@1
  char v8; // [sp+9h] [bp-20Bh]@1
  int v9; // [sp+Ah] [bp-20Ah]@1

  v6 = 0;
  memset(&v7, 0, 0x208u);
  v7 = 12;
  v8 = 10;
  LOWORD(v9) = 1;
  v4 = sub_10024C60(a2, a3, a4, (unsigned __int8 *)&v6);
  if ( v4 == 1 )
  {
    BYTE2(v9) = v6;
    sub_10005620(a1, v9 + 4, &v7);
  }
  return v4;
}

//----- (10005C50) --------------------------------------------------------
char __cdecl sub_10005C50(char a1)
{
  char v2; // [sp+0h] [bp-20Ch]@1
  char v3; // [sp+1h] [bp-20Bh]@1
  __int16 v4; // [sp+2h] [bp-20Ah]@1

  memset(&v2, 0, 0x208u);
  v2 = 12;
  v3 = 13;
  v4 = 0;
  sub_10005620(a1, 4, &v2);
  return 1;
}

//----- (10005CC0) --------------------------------------------------------
char __cdecl sub_10005CC0(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v4; // bl@1
  char v6; // [sp+7h] [bp-20Dh]@1
  char v7; // [sp+8h] [bp-20Ch]@1
  char v8; // [sp+9h] [bp-20Bh]@1
  int v9; // [sp+Ah] [bp-20Ah]@1

  v6 = 0;
  memset(&v7, 0, 0x208u);
  v7 = 12;
  v8 = 12;
  LOWORD(v9) = 1;
  v4 = sub_10024C60(a2, a3, a4, (unsigned __int8 *)&v6);
  if ( v4 == 1 )
  {
    BYTE2(v9) = v6;
    sub_10005620(a1, v9 + 4, &v7);
  }
  return v4;
}

//----- (10005D70) --------------------------------------------------------
char __cdecl sub_10005D70(char a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v4; // bl@1
  char v6; // [sp+7h] [bp-20Dh]@1
  char v7; // [sp+8h] [bp-20Ch]@1
  char v8; // [sp+9h] [bp-20Bh]@1
  int v9; // [sp+Ah] [bp-20Ah]@1

  v6 = 0;
  memset(&v7, 0, 0x208u);
  v7 = 12;
  v8 = 11;
  LOWORD(v9) = 1;
  v4 = sub_10024C60(a2, a3, a4, (unsigned __int8 *)&v6);
  if ( v4 == 1 )
  {
    BYTE2(v9) = v6;
    sub_10005620(a1, v9 + 4, &v7);
  }
  return v4;
}

//----- (10005E20) --------------------------------------------------------
char __cdecl sub_10005E20(int a1, int a2)
{
  char v2; // bl@1
  unsigned int v3; // eax@1
  char v4; // bl@16
  char *v5; // edi@18
  signed int v6; // ebp@20
  unsigned int v7; // edi@26
  int v8; // eax@27
  unsigned __int16 v9; // si@27
  char v10; // bl@27
  __int16 *v11; // ebp@27
  int v12; // eax@31
  unsigned __int16 v13; // si@31
  char v14; // bl@31
  __int16 *v15; // ebp@31
  int v16; // eax@35
  unsigned __int16 v17; // si@35
  char v18; // bl@35
  __int16 *v19; // ebp@35
  int v20; // eax@39
  unsigned __int16 v21; // si@39
  char v22; // bl@39
  __int16 *v23; // ebp@39
  bool v24; // cf@43
  unsigned __int8 v26; // [sp+Ch] [bp-F80h]@1
  int v27; // [sp+Ch] [bp-F80h]@18
  int v28; // [sp+10h] [bp-F7Ch]@1
  char *v29; // [sp+14h] [bp-F78h]@27
  int v30; // [sp+18h] [bp-F74h]@1
  int v31; // [sp+1Ch] [bp-F70h]@18
  char *v32; // [sp+20h] [bp-F6Ch]@18
  char v33[2]; // [sp+24h] [bp-F68h]@16
  __int16 v34[155]; // [sp+26h] [bp-F66h]@27
  char v35[2]; // [sp+15Ch] [bp-E30h]@35
  __int16 v36[115]; // [sp+15Eh] [bp-E2Eh]@35
  char v37[2]; // [sp+244h] [bp-D48h]@31
  __int16 v38[23]; // [sp+246h] [bp-D46h]@31
  char v39[2]; // [sp+274h] [bp-D18h]@39
  __int16 v40[1159]; // [sp+276h] [bp-D16h]@39
  char v41[1024]; // [sp+B84h] [bp-408h]@1
  int v42; // [sp+F84h] [bp-8h]@44

  v30 = 0;
  memset(v41, 0, 0x404u);
  v26 = -80;
  v28 = 146;
  v2 = 0;
  v3 = sub_1000C2A0(a1, a2);
  if ( v3 > 0x1000 )
  {
    if ( v3 == 0x2000 )
    {
      v26 = 80;
      goto LABEL_12;
    }
    if ( v3 == 0x80000 )
    {
      v26 = -117;
      goto LABEL_12;
    }
  }
  else
  {
    if ( v3 == 4096 )
    {
      v26 = 79;
      goto LABEL_12;
    }
    if ( v3 == 256 )
    {
      v26 = 0;
      goto LABEL_12;
    }
    if ( v3 == 512 )
    {
      v26 = 6;
LABEL_12:
      v2 = 1;
      goto LABEL_13;
    }
  }
LABEL_13:
  if ( (_WORD)a1 == 737 )
  {
    if ( v2 )
    {
      LOBYTE(v3) = sub_100209E0(v26, 67, &v30);
      if ( (_BYTE)v3 )
      {
        v4 = sub_1000F100(0, 737, v33);
        v3 = sub_1004C560((unsigned int *)v33, 2912, 0xFFFFFFFF);
        if ( v4 )
        {
          if ( v30 == v3 )
          {
            v27 = 0;
            v5 = v33;
            LOBYTE(v31) = 0;
            v32 = v33;
            do
            {
              if ( (unsigned __int8)(sub_10024C00(v31) - 12) > 0x1Eu )
              {
                v7 = 0;
                do
                {
                  v8 = 2 * (v27 + v7);
                  v9 = v34[2 * (v27 + v7)];
                  v10 = v33[4 * (v27 + v7)];
                  v11 = &v34[v8];
                  v29 = &v33[v8 * 2];
                  if ( sub_10005600(v10, v9) && sub_10024E30(*v29, *v11, (unsigned __int16 *)&v28) )
                    v41[(unsigned __int16)v28] = 1;
                  if ( v7 < 0xC )
                  {
                    v12 = 2 * (v27 + v7);
                    v13 = v38[2 * (v27 + v7)];
                    v14 = v37[4 * (v27 + v7)];
                    v15 = &v38[v12];
                    v29 = &v37[v12 * 2];
                    if ( sub_10005600(v14, v13) )
                    {
                      if ( sub_10024E30(*v29, *v15, (unsigned __int16 *)&v28) )
                        v41[(unsigned __int16)v28] = 1;
                    }
                  }
                  if ( v7 < 0x3A )
                  {
                    v16 = 2 * (v27 + v7);
                    v17 = v36[2 * (v27 + v7)];
                    v18 = v35[4 * (v27 + v7)];
                    v19 = &v36[v16];
                    v29 = &v35[v16 * 2];
                    if ( sub_10005600(v18, v17) )
                    {
                      if ( sub_10024E30(*v29, *v19, (unsigned __int16 *)&v28) )
                        v41[(unsigned __int16)v28] = 1;
                    }
                  }
                  if ( v7 < 0x22 )
                  {
                    v20 = 2 * (v27 + v7);
                    v21 = v40[2 * (v27 + v7)];
                    v22 = v39[4 * (v27 + v7)];
                    v23 = &v40[v20];
                    v29 = &v39[v20 * 2];
                    if ( sub_10005600(v22, v21) )
                    {
                      if ( sub_10024E30(*v29, *v23, (unsigned __int16 *)&v28) )
                        v41[(unsigned __int16)v28] = 1;
                    }
                  }
                  ++v7;
                }
                while ( v7 < 0x4E );
              }
              else
              {
                v6 = 146;
                do
                {
                  if ( sub_10005600(*v5, *((_WORD *)v5 + 1))
                    && sub_10024E30(*v5, *((_WORD *)v5 + 1), (unsigned __int16 *)&v28) )
                  {
                    v41[(unsigned __int16)v28] = 1;
                  }
                  v5 += 4;
                  --v6;
                }
                while ( v6 );
              }
              v27 += 182;
              v5 = v32 + 728;
              v24 = (unsigned __int8)(v31 + 1) < 4u;
              LOBYTE(v31) = v31 + 1;
              v32 += 728;
            }
            while ( v24 );
            v42 = v30;
            LOBYTE(v3) = sub_10018670(6943, (int)v41, 1028);
          }
        }
      }
    }
  }
  return v3;
}
// 10005E20: using guessed type char var_408[1024];
// 10005E20: using guessed type char var_F68[2];
// 10005E20: using guessed type __int16 var_F66[155];
// 10005E20: using guessed type __int16 var_D46[23];
// 10005E20: using guessed type char var_D48[2];
// 10005E20: using guessed type __int16 var_E2E[115];
// 10005E20: using guessed type char var_E30[2];
// 10005E20: using guessed type __int16 var_D16[1159];
// 10005E20: using guessed type char var_D18[2];

//----- (100061A0) --------------------------------------------------------
char __cdecl sub_100061A0(char a1, int a2, int a3, int a4, int a5)
{
  char v5; // al@1
  char v6; // dl@1
  __int16 v7; // cx@1
  char v8; // al@1
  __int16 v9; // dx@1
  int v10; // eax@1
  __int16 v11; // cx@1
  int v12; // edx@1
  int v13; // ecx@1
  int v14; // eax@1
  int v15; // edx@1
  int v16; // ecx@1
  int v17; // eax@1
  int v18; // ecx@1
  char v20; // [sp+4h] [bp-20Ch]@1
  char v21; // [sp+5h] [bp-20Bh]@1
  __int16 v22; // [sp+6h] [bp-20Ah]@1
  char v23; // [sp+8h] [bp-208h]@1
  char v24; // [sp+9h] [bp-207h]@1
  __int16 v25; // [sp+Ah] [bp-206h]@1
  int v26; // [sp+Ch] [bp-204h]@1
  int v27; // [sp+10h] [bp-200h]@1
  int v28; // [sp+14h] [bp-1FCh]@1
  int v29; // [sp+18h] [bp-1F8h]@1
  int v30; // [sp+1Ch] [bp-1F4h]@1
  int v31; // [sp+20h] [bp-1F0h]@1
  int v32; // [sp+24h] [bp-1ECh]@1
  int v33; // [sp+28h] [bp-1E8h]@1

  memset(&v20, 0, 0x208u);
  v5 = *(_BYTE *)(a5 + 3);
  v6 = *(_BYTE *)(a5 + 1);
  v23 = *(_BYTE *)a5;
  v7 = v5 & 7;
  v8 = *(_BYTE *)(a5 + 4);
  v24 = v6;
  v9 = v8 & 1;
  v10 = *(_DWORD *)(a5 + 12);
  v11 = *(_BYTE *)(a5 + 9) & 1 | 2
                               * (*(_BYTE *)(a5 + 8) & 1 | 2
                                                         * (*(_BYTE *)(a5 + 7) & 1 | 2
                                                                                   * (*(_BYTE *)(a5 + 6) & 1 | 2 * (*(_BYTE *)(a5 + 5) & 7 | 8 * (v9 | 2 * (16 * *(_BYTE *)(a5 + 2) | v7))))));
  v12 = *(_DWORD *)(a5 + 20);
  v25 = v11;
  v13 = *(_DWORD *)(a5 + 16);
  v26 = v10;
  v14 = *(_DWORD *)(a5 + 24);
  v28 = v12;
  v15 = *(_DWORD *)(a5 + 32);
  v27 = v13;
  v16 = *(_DWORD *)(a5 + 28);
  v29 = v14;
  v17 = *(_DWORD *)(a5 + 36);
  v31 = v15;
  v30 = v16;
  v18 = *(_DWORD *)(a5 + 40);
  v32 = v17;
  v20 = 12;
  v21 = 2;
  v22 = 36;
  v33 = v18;
  return sub_10005620(a1, 40, &v20);
}

//----- (100062D0) --------------------------------------------------------
char __cdecl sub_100062D0(char a1, int a2, int a3, int a4, int a5)
{
  char v5; // al@1
  char v6; // dl@1
  char v8; // [sp+4h] [bp-20Ch]@1
  char v9; // [sp+5h] [bp-20Bh]@1
  __int16 v10; // [sp+6h] [bp-20Ah]@1
  char v11; // [sp+8h] [bp-208h]@1
  char v12; // [sp+9h] [bp-207h]@1
  char v13; // [sp+Ah] [bp-206h]@1

  memset(&v8, 0, 0x208u);
  v5 = *(_BYTE *)(a5 + 2);
  v6 = *(_BYTE *)(a5 + 1);
  v11 = *(_BYTE *)a5;
  v13 = v5;
  v8 = 12;
  v9 = 4;
  v10 = 3;
  v12 = v6;
  return sub_10005620(a1, 7, &v8);
}

//----- (10006350) --------------------------------------------------------
char __cdecl sub_10006350(char a1, int a2, int a3, int a4, int a5)
{
  char v5; // al@1
  char v6; // dl@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // eax@1
  int v11; // ecx@1
  int v12; // edx@1
  int v13; // eax@1
  int v14; // edx@1
  char v16; // [sp+4h] [bp-20Ch]@1
  char v17; // [sp+5h] [bp-20Bh]@1
  __int16 v18; // [sp+6h] [bp-20Ah]@1
  char v19; // [sp+8h] [bp-208h]@1
  char v20; // [sp+9h] [bp-207h]@1
  char v21; // [sp+Ah] [bp-206h]@1
  int v22; // [sp+Bh] [bp-205h]@1
  int v23; // [sp+Fh] [bp-201h]@1
  int v24; // [sp+13h] [bp-1FDh]@1
  int v25; // [sp+17h] [bp-1F9h]@1
  int v26; // [sp+1Bh] [bp-1F5h]@1
  int v27; // [sp+1Fh] [bp-1F1h]@1
  int v28; // [sp+23h] [bp-1EDh]@1
  int v29; // [sp+27h] [bp-1E9h]@1

  memset(&v16, 0, 0x208u);
  v5 = *(_BYTE *)(a5 + 3);
  v6 = *(_BYTE *)(a5 + 1);
  v19 = *(_BYTE *)a5;
  v7 = *(_DWORD *)(a5 + 12);
  v21 = 16 * *(_BYTE *)(a5 + 2) | v5 & 7;
  v8 = *(_DWORD *)(a5 + 8);
  v20 = v6;
  v9 = *(_DWORD *)(a5 + 4);
  v23 = v8;
  v10 = *(_DWORD *)(a5 + 20);
  v24 = v7;
  v11 = *(_DWORD *)(a5 + 24);
  v22 = v9;
  v12 = *(_DWORD *)(a5 + 16);
  v26 = v10;
  v13 = *(_DWORD *)(a5 + 32);
  v27 = v11;
  v25 = v12;
  v14 = *(_DWORD *)(a5 + 28);
  v29 = v13;
  v16 = 12;
  v17 = 8;
  v18 = 35;
  v28 = v14;
  return sub_10005620(a1, 39, &v16);
}

//----- (10006420) --------------------------------------------------------
char __cdecl sub_10006420(char a1, int a2, int a3, int a4, int a5)
{
  char v5; // cl@1
  char v6; // dl@1
  int v7; // ecx@1
  int v8; // edx@1
  char v10; // [sp+4h] [bp-20Ch]@1
  char v11; // [sp+5h] [bp-20Bh]@1
  __int16 v12; // [sp+6h] [bp-20Ah]@1
  char v13; // [sp+8h] [bp-208h]@1
  char v14; // [sp+9h] [bp-207h]@1
  char v15; // [sp+Ah] [bp-206h]@1
  int v16; // [sp+Ch] [bp-204h]@1
  int v17; // [sp+10h] [bp-200h]@1

  memset(&v10, 0, 0x208u);
  v5 = *(_BYTE *)a5;
  v6 = *(_BYTE *)(a5 + 1);
  v10 = 12;
  v12 = 12;
  v15 = *(_BYTE *)(a5 + 2);
  v13 = v5;
  v7 = *(_DWORD *)(a5 + 4);
  v14 = v6;
  v8 = *(_DWORD *)(a5 + 8);
  v11 = 6;
  v16 = v7;
  v17 = v8;
  return sub_10005620(a1, 16, &v10);
}

//----- (100064B0) --------------------------------------------------------
char __cdecl sub_100064B0(int a1)
{
  int v1; // eax@1
  int v2; // ecx@3
  char *v3; // eax@3
  int v5; // [sp+8h] [bp-1Ch]@1
  int v6; // [sp+Ch] [bp-18h]@1
  int v7; // [sp+10h] [bp-14h]@1
  char v8[4]; // [sp+14h] [bp-10h]@1
  int v9; // [sp+18h] [bp-Ch]@1
  int v10; // [sp+1Ch] [bp-8h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  *(_DWORD *)v8 = 0;
  v9 = 0;
  v10 = 0;
  sub_10005360((int)&v5, a1);
  v1 = sub_1001E7B0(&v5, 0xCu, (int)"GEA 70", 15, 3, 3);
  if ( v1 == 3 )
  {
    sprintf(v8, "GEA 72");
    v1 = sub_1001E7B0((_DWORD *)v8, 0xCu, (int)"GEA 70", 15, 3, 3);
  }
  v2 = 0;
  v3 = (char *)&unk_100A4AAC + 15 * v1;
  while ( v3[v2] == 3 )
  {
    if ( ++v2 >= 3 )
      return 3;
  }
  return v2;
}

//----- (10006580) --------------------------------------------------------
int __cdecl sub_10006580(unsigned __int8 a1, char a2, unsigned __int8 a3, int a4)
{
  char v4; // di@1
  char v5; // bl@1
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@5

  v4 = a2;
  v5 = 0;
  if ( sub_100055D0(a1, a2, a3) )
  {
    a3 += byte_100A42A2[44 * a1] - byte_100A42A7[44 * a1];
    v4 = 6;
    v5 = 1;
  }
  v6 = a4 + sub_10007240(a1, v4);
  v7 = a3 * sub_10005310(v4) + v6;
  if ( v5 )
  {
    if ( *(_BYTE *)(v7 + 2) != 6 )
    {
      v8 = v7 + 4;
      sub_100056A0(0xCu, v8, 3);
      return v8;
    }
    v7 += 4;
  }
  return v7;
}

//----- (10006620) --------------------------------------------------------
char __usercall sub_10006620@<al>(unsigned __int8 *a1@<eax>, _BYTE *a2@<ebx>, unsigned __int8 *a3@<esi>, int a4)
{
  unsigned __int8 *v4; // edi@1
  unsigned __int8 v5; // al@1
  char result; // al@1

  v4 = a1;
  *a1 = 0;
  *a3 = 0;
  *a2 = 0;
  v5 = sub_100064B0(a4);
  *v4 = v5;
  for ( result = sub_10005340(v5, *a3, a2); result != 1; result = sub_10005340(*v4, *a3, a2) )
  {
    if ( *a3 + 1 >= 8 )
    {
      if ( *v4 < 3u && sub_10005410(v4, a4, *v4) != 1 )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg.c", 3750, 1, 0);
    }
    else
    {
      ++*a3;
    }
    *a2 = 0;
  }
  return result;
}

//----- (100066B0) --------------------------------------------------------
char __cdecl sub_100066B0(int a1, int a2, int a3)
{
  int v3; // esi@1
  char v4; // bl@1
  int v5; // edi@1
  char v6; // ST10_1@7
  char v7; // ST0C_1@7
  char v8; // al@7
  char v9; // al@7
  unsigned __int8 v10; // dl@7
  int v11; // eax@16
  int v12; // eax@18
  size_t v13; // ST1C_4@39
  void *v14; // ST18_4@39
  char v15; // al@39
  char result; // al@39
  char v17; // ST0C_1@43
  char v18; // al@43
  int *v19; // edi@44
  char v20; // [sp+13h] [bp-81h]@1
  int v21; // [sp+14h] [bp-80h]@1
  int v22; // [sp+18h] [bp-7Ch]@1
  size_t v23; // [sp+1Ch] [bp-78h]@1
  void *v24; // [sp+20h] [bp-74h]@1
  int *v25; // [sp+24h] [bp-70h]@1
  int v26; // [sp+28h] [bp-6Ch]@1
  int v27; // [sp+2Ch] [bp-68h]@1
  int v28; // [sp+30h] [bp-64h]@1
  char v29; // [sp+34h] [bp-60h]@1
  char v30; // [sp+60h] [bp-34h]@28
  int v31; // [sp+64h] [bp-30h]@1
  int v32; // [sp+68h] [bp-2Ch]@18
  int v33; // [sp+6Ch] [bp-28h]@18
  char v34; // [sp+90h] [bp-4h]@15

  memset(&v29, 0, 0x30u);
  v24 = 0;
  v23 = 0;
  v27 = 0;
  v28 = 0;
  v25 = 0;
  v20 = 0;
  LOWORD(v21) = 0;
  BYTE2(v21) = 0;
  memset(&v31, 0, 0x30u);
  v3 = a1;
  v4 = 0;
  LOBYTE(v22) = sub_10024B60(a1);
  v5 = (unsigned __int8)a2 - 3;
  v26 = (unsigned __int8)a2 - 3;
  switch ( (unsigned __int8)a2 )
  {
    case 5u:
      v4 = sub_10005AF0(v22, *(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2));
      break;
    case 4u:
      v4 = sub_10005BA0(v22, *(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2));
      break;
    case 0xAu:
      v4 = sub_10005CC0(v22, *(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2));
      break;
    case 3u:
      v4 = sub_10005D70(v22, *(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2));
      break;
    case 0x11u:
      v4 = sub_10005C50(v22);
      break;
    case 0xBu:
      sub_10006620((unsigned __int8 *)&v21, (_BYTE *)&v21 + 2, (unsigned __int8 *)&v21 + 1, v22);
      v6 = sub_100052D0(SBYTE1(v21));
      v7 = sub_10002E60();
      v8 = sub_10002E80();
      sub_10002EE0(v8, a1, v7, v6, (int)&v21, 0, 0);
      v9 = sub_100052D0(SBYTE1(v21));
      sub_100056C0(SBYTE2(v21), v21, v10, v9);
      v3 = a1;
      v4 = 1;
      break;
    default:
      break;
  }
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    if ( sub_10002E80() == 2 || sub_10002E80() == 5 )
    {
      sub_10007350(v22, (int)&unk_1011EEE0);
      switch ( (unsigned __int8)a2 )
      {
        case 5u:
          qmemcpy(
            &v31,
            (const void *)sub_10006580(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2), (int)&unk_1011EEE0),
            0x2Cu);
          v5 = v26;
          v3 = a1;
          v34 = 0;
          break;
        case 4u:
          v11 = sub_10006580(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2), (int)&unk_1011EEE0);
          LOWORD(v31) = *(_WORD *)v11;
          BYTE2(v31) = *(_BYTE *)(v11 + 2);
          v34 = 1;
          break;
        case 0xAu:
          qmemcpy(
            &v31,
            (const void *)sub_10006580(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2), (int)&unk_1011EEE0),
            0x24u);
          v5 = v26;
          v3 = a1;
          v34 = 2;
          break;
        case 3u:
          v12 = sub_10006580(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2), (int)&unk_1011EEE0);
          v31 = *(_DWORD *)v12;
          v32 = *(_DWORD *)(v12 + 4);
          v33 = *(_DWORD *)(v12 + 8);
          v34 = 3;
          break;
        default:
          break;
      }
      sub_100078E0(v22, &v31);
    }
    else if ( (_BYTE)a2 == 17 )
    {
      sub_100078C0(v22);
    }
    else
    {
      sub_100078E0(v22, &dword_1011FD44);
    }
  }
  if ( sub_10002E80() != 2
    && (sub_10008A10(v22, (int)&v29) == 1 && (_BYTE)a2 != 17 || sub_10008D00(v22, (int)&v27) == 1 && (_BYTE)a2 == 17) )
  {
    switch ( v5 )
    {
      case 2:
        v23 = 44;
        goto LABEL_27;
      case 1:
        v23 = 3;
        goto LABEL_27;
      case 7:
        v23 = 36;
        goto LABEL_27;
      case 0:
        v23 = 12;
LABEL_27:
        v24 = &v29;
        if ( v29 == (_BYTE)dword_1011FD44 && v30 == byte_1011FD70 )
          v20 = 1;
        v25 = &dword_1011FD44;
        break;
      case 14:
        v20 = 1;
        break;
      default:
        break;
    }
  }
  if ( v4 == 1 )
  {
    if ( sub_10002E80() == 5 && sub_10002E60() == 1 )
    {
      if ( v20 == 1 )
      {
        v13 = v23;
        v14 = v24;
        v15 = sub_10002E60();
        sub_10002EE0(5, v3, v15, a2, a3, v14, v13);
        sub_10002F90(10);
        return 1;
      }
      goto LABEL_58;
    }
    if ( sub_10002E80() == 7 )
    {
      if ( v20 == 1 )
      {
        if ( (_BYTE)a2 == 17 )
        {
LABEL_43:
          v17 = sub_10002E60();
          v18 = sub_10002E80();
          sub_10002EE0(v18, v3, v17, 17, a3, &v27, 8u);
          sub_10002F90(10);
          return 1;
        }
        v19 = v25;
        if ( sub_10003BF0(v3, 1, a2, a3, (int)v25, v23) )
        {
          if ( (_BYTE)a2 != 10 || *((_BYTE *)v19 + 2) != 6 )
            goto LABEL_51;
          sub_100056A0(0x24u, (int)v19, 10);
          goto LABEL_50;
        }
        if ( sub_100055D0(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2)) )
        {
          sub_100056A0(0xCu, (int)v19, a2);
LABEL_50:
          sub_10024C60(*(_BYTE *)a3, *(_BYTE *)(a3 + 1), *(_BYTE *)(a3 + 2), (unsigned __int8 *)v19);
        }
LABEL_51:
        sub_10002F90(3);
        return 1;
      }
    }
    else
    {
      if ( sub_10002E80() == 1 && (_BYTE)a2 == 17 && v20 == 1 )
        goto LABEL_43;
      if ( sub_10002E80() == 2 )
      {
        sub_10002F90(7);
        return 1;
      }
      if ( v20 == 1 )
        goto LABEL_51;
    }
  }
LABEL_58:
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() <= 0xA )
  {
    sub_10002F90(4);
    byte_1011FD74 = 2;
    dword_1011FD78 = sub_100181D0();
    result = v4;
  }
  else
  {
    sub_10002F90(8);
    result = v4;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FD44: using guessed type int dword_1011FD44;
// 1011FD70: using guessed type char byte_1011FD70;
// 1011FD74: using guessed type char byte_1011FD74;
// 1011FD78: using guessed type int dword_1011FD78;

//----- (10006CB0) --------------------------------------------------------
char __cdecl sub_10006CB0(char a1, char a2, char a3, int a4, int a5, size_t a6)
{
  unsigned __int8 v6; // bp@2
  int v7; // ST20_4@14
  void *v8; // ST1C_4@14
  char v9; // ST14_1@14
  char v10; // al@14
  char result; // al@16
  char v12; // [sp+13h] [bp-Dh]@4
  int v13; // [sp+14h] [bp-Ch]@0
  int v14; // [sp+18h] [bp-8h]@1

  LOWORD(v14) = 0;
  BYTE2(v14) = 0;
  LOBYTE(v13) = sub_10024B60(a1);
  switch ( a3 )
  {
    case 5:
      sub_10024C60(*(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), (unsigned __int8 *)a5);
      qmemcpy(&dword_1011FD44, (const void *)a5, 0x2Cu);
      byte_1011FD70 = 0;
      v6 = v13;
      sub_100061A0(v13, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_15;
    case 4:
      sub_10024C60(*(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), (unsigned __int8 *)a5);
      v6 = v13;
      LOWORD(dword_1011FD44) = *(_WORD *)a5;
      BYTE2(dword_1011FD44) = *(_BYTE *)(a5 + 2);
      byte_1011FD70 = 1;
      sub_100062D0(v13, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_15;
    case 0xA:
      v12 = 0;
      if ( *(_BYTE *)(a5 + 2) == 6 )
      {
        v12 = 1;
        sub_100056A0(a6, a5, a3);
      }
      sub_10024C60(*(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), (unsigned __int8 *)a5);
      qmemcpy(&dword_1011FD44, (const void *)a5, 0x24u);
      byte_1011FD70 = 2;
      v6 = v13;
      sub_10006350(v13, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      if ( v12 )
        *(_BYTE *)(a5 + 2) = 6;
      goto LABEL_15;
    case 3:
      sub_10024C60(*(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), (unsigned __int8 *)a5);
      v6 = v13;
      dword_1011FD44 = *(_DWORD *)a5;
      dword_1011FD48 = *(_DWORD *)(a5 + 4);
      dword_1011FD4C = *(_DWORD *)(a5 + 8);
      byte_1011FD70 = 3;
      sub_10006420(v13, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_15;
    case 0xB:
      v6 = v13;
      if ( a6 )
      {
        if ( a6 != 3684 )
        {
LABEL_20:
          sub_10002F90(8);
          return 0;
        }
        qmemcpy(&unk_1011EEE0, (const void *)a5, 0xE64u);
      }
      else
      {
        sub_10007350(v13, (int)&unk_1011EEE0);
      }
      sub_10006620((unsigned __int8 *)&v14, (_BYTE *)&v14 + 2, (unsigned __int8 *)&v14 + 1, v13);
      v7 = sub_10005310(SBYTE1(v14));
      v8 = (void *)sub_10006580(v14, SBYTE1(v14), BYTE2(v14), (int)&unk_1011EEE0);
      v9 = sub_100052D0(SBYTE1(v14));
      v10 = sub_10002E80();
      sub_10002EE0(v10, a1, a2, v9, (int)&v14, v8, v7);
LABEL_15:
      if ( sub_10002E80() == 3 )
      {
        sub_10002F90(7);
        result = 1;
      }
      else if ( a3 == 11 )
      {
        sub_10002F90(1);
        result = 1;
      }
      else
      {
        sub_10002F90(4);
        byte_1011FD74 = 2;
        dword_1011FD78 = sub_100181D0();
        sub_10007880(v6);
        result = 1;
      }
      return result;
    default:
      goto LABEL_20;
  }
}
// 1011FD44: using guessed type int dword_1011FD44;
// 1011FD48: using guessed type int dword_1011FD48;
// 1011FD4C: using guessed type int dword_1011FD4C;
// 1011FD70: using guessed type char byte_1011FD70;
// 1011FD74: using guessed type char byte_1011FD74;
// 1011FD78: using guessed type int dword_1011FD78;

//----- (10006FD0) --------------------------------------------------------
char __cdecl sub_10006FD0(char a1, char a2, char a3, int a4, void *a5)
{
  int v5; // ebp@2
  int v6; // ST20_4@10
  void *v7; // ST1C_4@10
  char v8; // ST14_1@10
  char v9; // al@10
  char result; // al@10
  char v11; // dl@11
  char v12; // ST14_1@11
  char v13; // ST10_1@11
  char v14; // al@11
  char v15; // al@11
  unsigned __int8 v16; // dl@11
  char v17; // al@14
  int v18; // [sp+Ch] [bp-Ch]@0
  int v19; // [sp+10h] [bp-8h]@1

  LOWORD(v19) = 0;
  BYTE2(v19) = 0;
  LOBYTE(v18) = sub_10024B60(a1);
  switch ( a3 )
  {
    case 5:
      v5 = v18;
      sub_10007790(v18, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_7;
    case 4:
      v5 = v18;
      sub_100077C0(v18, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_7;
    case 0xA:
      v5 = v18;
      sub_100077F0(v18, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_7;
    case 3:
      v5 = v18;
      sub_10007820(v18, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      goto LABEL_7;
    case 0x11:
      v5 = v18;
      sub_10007380(v18, (int)a5);
LABEL_7:
      if ( sub_10002E90() != 1
        || sub_10005520(
             *(_BYTE *)a4,
             *(_BYTE *)(a4 + 2),
             *(_BYTE *)(a4 + 1),
             (unsigned __int8 *)&v19 + 1,
             v5,
             (unsigned __int8 *)&v19,
             (char *)&v19 + 2) != 1 )
      {
        if ( sub_10002E80() != 1 || a3 == 17 )
        {
          sub_10002F90(7);
          result = 1;
        }
        else
        {
          v17 = sub_10002E80();
          sub_10002EE0(v17, a1, a2, 17, 0, 0, 0);
          sub_10002F90(2);
          sub_10007850(v5);
          result = 1;
        }
      }
      else if ( a2 )
      {
        v12 = sub_100052D0(SBYTE1(v19));
        v13 = v11;
        v14 = sub_10002E80();
        sub_10002EE0(v14, a1, v13, v12, (int)&v19, 0, 0);
        v15 = sub_100052D0(SBYTE1(v19));
        sub_100056C0(SBYTE2(v19), v19, v16, v15);
        sub_10002F90(2);
        sub_10002E50();
        result = 1;
      }
      else
      {
        v6 = sub_10005310(SBYTE1(v19));
        v7 = (void *)sub_10006580(v19, SBYTE1(v19), BYTE2(v19), (int)&unk_1011EEE0);
        v8 = sub_100052D0(SBYTE1(v19));
        v9 = sub_10002E80();
        sub_10002EE0(v9, a1, 0, v8, (int)&v19, v7, v6);
        sub_10002F90(1);
        sub_10002E50();
        result = 1;
      }
      break;
    default:
      sub_10002F90(8);
      result = 0;
      break;
  }
  return result;
}

//----- (10007240) --------------------------------------------------------
int __cdecl sub_10007240(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_1006CF74[2 * sub_1001E7B0(&a1, 1u, (int)&unk_1006CF70, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_1006CFB4[2 * sub_1001E7B0(&a2, 1u, (int)&unk_1006CFB0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_1006CFE4[2 * sub_1001E7B0(&a2, 1u, (int)&unk_1006CFE0, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1006CF8C[2 * sub_1001E7B0(&a2, 1u, (int)&unk_1006CF88, 8, 5, 5)];
  }
  return result;
}
// 1006CF74: using guessed type int dword_1006CF74[];
// 1006CF8C: using guessed type int dword_1006CF8C[];
// 1006CFB4: using guessed type int dword_1006CFB4[];
// 1006CFE4: using guessed type int dword_1006CFE4[];

//----- (100072F0) --------------------------------------------------------
int __cdecl sub_100072F0(char a1, int a2)
{
  int v2; // eax@1
  int result; // eax@1
  int v4; // edx@1
  char v5; // [sp+0h] [bp-E64h]@1
  int v6; // [sp+E5Ch] [bp-8h]@1
  int v7; // [sp+E60h] [bp-4h]@1

  memset(&v5, 0, 0xE64u);
  v2 = sub_100230E0(a1);
  sub_100185C0(v2, (int)&v5, 3684);
  result = a2;
  v4 = v7;
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v4;
  return result;
}

//----- (10007350) --------------------------------------------------------
char __cdecl sub_10007350(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100230E0(a1);
  return sub_100185C0(v2, a2, 3684);
}

//----- (10007380) --------------------------------------------------------
int __cdecl sub_10007380(char a1, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // eax@1
  char v6; // [sp+4h] [bp-E64h]@1
  int v7; // [sp+E60h] [bp-8h]@1
  int v8; // [sp+E64h] [bp-4h]@1

  v2 = sub_100230E0(a1);
  sub_100185C0(v2, (int)&v6, 3684);
  v3 = *(_DWORD *)(a2 + 4);
  v7 = *(_DWORD *)a2;
  v8 = v3;
  v4 = sub_100230E0(a1);
  return sub_100186F0(v4, (int)&v6, 3684);
}

//----- (100073F0) --------------------------------------------------------
char __usercall sub_100073F0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_100055D0(a1, a4, a5) )
  {
    v6 = a3
       + sub_10007240(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100A42A2[44 * a1] - (unsigned __int8)byte_100A42A7[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10007240(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10007490) --------------------------------------------------------
int __usercall sub_10007490@<eax>(unsigned __int8 a1@<bl>, size_t a2@<edi>, char a3, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@1
  char *v7; // eax@2
  int v8; // eax@4
  int v9; // eax@5
  char v11[3684]; // [sp+8h] [bp-E64h]@1

  memset(v11, 0, 0xE64u);
  v6 = sub_100230E0(a3);
  sub_100185C0(v6, (int)v11, 3684);
  if ( sub_100055D0(a1, a4, a5) )
  {
    v7 = &v11[36 * (a5 + (unsigned __int8)byte_100A42A2[44 * a1] - (unsigned __int8)byte_100A42A7[44 * a1])]
       + sub_10007240(a1, 6);
    if ( v7[2] == 6 )
      memcpy(v7 + 4, a6, a2);
  }
  else
  {
    v8 = sub_10007240(a1, a4);
    memcpy(&v11[a2 * a5] + v8, a6, a2);
  }
  v9 = sub_100230E0(a3);
  return sub_100186F0(v9, (int)v11, 3684);
}
// 10007490: using guessed type char var_E64[3684];

//----- (10007590) --------------------------------------------------------
char __cdecl sub_10007590(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100230E0(a1);
  sub_100185C0(v5, (int)&v7, 3684);
  return sub_100073F0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10007610) --------------------------------------------------------
char __cdecl sub_10007610(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100230E0(a1);
  sub_100185C0(v5, (int)&v7, 3684);
  return sub_100073F0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10007690) --------------------------------------------------------
char __cdecl sub_10007690(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100230E0(a1);
  sub_100185C0(v5, (int)&v7, 3684);
  return sub_100073F0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10007710) --------------------------------------------------------
char __cdecl sub_10007710(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100230E0(a1);
  sub_100185C0(v5, (int)&v7, 3684);
  return sub_100073F0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10007790) --------------------------------------------------------
int __cdecl sub_10007790(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  return sub_10007490(a2, 0x2Cu, a1, a3, a4, a5);
}

//----- (100077C0) --------------------------------------------------------
int __cdecl sub_100077C0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  return sub_10007490(a2, 3u, a1, a3, a4, a5);
}

//----- (100077F0) --------------------------------------------------------
int __cdecl sub_100077F0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  return sub_10007490(a2, 0x24u, a1, a3, a4, a5);
}

//----- (10007820) --------------------------------------------------------
int __cdecl sub_10007820(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  return sub_10007490(a2, 0xCu, a1, a3, a4, a5);
}

//----- (10007850) --------------------------------------------------------
int __cdecl sub_10007850(unsigned __int8 a1)
{
  int result; // eax@1
  int v2; // edx@1

  result = a1;
  v2 = dword_102229B4 + 8 * a1 + 196;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_BYTE *)(a1 + dword_102229B4 + 692) = 0;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007880) --------------------------------------------------------
void *__cdecl sub_10007880(unsigned __int8 a1)
{
  void *result; // eax@1

  result = memset((void *)(dword_102229B4 + 48 * a1), 255, 0x30u);
  *(_BYTE *)(a1 + dword_102229B4 + 192) = 0;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (100078C0) --------------------------------------------------------
int __cdecl sub_100078C0(unsigned __int8 a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + dword_102229B4 + 692) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (100078E0) --------------------------------------------------------
int __cdecl sub_100078E0(unsigned __int8 a1, const void *a2)
{
  int result; // eax@1

  result = a1;
  qmemcpy((void *)(dword_102229B4 + 48 * a1), a2, 0x30u);
  *(_BYTE *)(a1 + dword_102229B4 + 192) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007910) --------------------------------------------------------
char __usercall sub_10007910@<al>(unsigned __int8 a1@<bl>)
{
  int v1; // edi@1
  char v2; // al@14
  char v4; // [sp+Dh] [bp-Fh]@21
  char v5; // [sp+Eh] [bp-Eh]@1
  char v6; // [sp+Fh] [bp-Dh]@12
  int v7; // [sp+10h] [bp-Ch]@4
  int v8; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  v5 = 0;
  v8 = 0;
  v9 = 0;
  v1 = sub_100181D0();
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      LOBYTE(v7) = 2;
    }
    else if ( a1 == 2 )
    {
      LOBYTE(v7) = 3;
    }
    else
    {
      LOBYTE(v7) = 21;
    }
  }
  else
  {
    LOBYTE(v7) = 1;
  }
  if ( sub_1001DD70(0, v7) || sub_1001DD70(1, v7) )
  {
    if ( *(_BYTE *)(a1 + dword_102229B4 + 692) )
    {
      sub_100072F0(a1, (int)&v8);
      if ( v8 == __PAIR__(*(_WORD *)(dword_102229B4 + 8 * a1 + 198), *(_WORD *)(dword_102229B4 + 8 * a1 + 196))
        && v9 == __PAIR__(*(_WORD *)(dword_102229B4 + 8 * a1 + 202), *(_WORD *)(dword_102229B4 + 8 * a1 + 200)) )
      {
        v5 = 1;
        return 1;
      }
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          if ( sub_10003EC0(0xDu, &v4) == 1 && v4 == 1 )
          {
            sub_10003F20(0xDu, 0);
            sub_1001E570(0x64u);
            return v5;
          }
        }
        else if ( a1 == 2 )
        {
          if ( sub_10003EC0(0xEu, &v4) == 1 && v4 == 1 )
          {
            sub_10003F20(0xEu, 0);
            sub_1001E570(0x65u);
            return v5;
          }
        }
        else if ( sub_10003EC0(0x2Au, &v4) == 1 && v4 == 1 )
        {
          sub_10003F20(0x2Au, 0);
          sub_1001E570(0x66u);
          return v5;
        }
      }
      else if ( sub_10003EC0(0xCu, &v4) == 1 && v4 == 1 )
      {
        sub_10003F20(0xCu, 0);
        sub_1001E570(0x63u);
      }
    }
    else if ( (unsigned int)(v1 - dword_1011FD80[a1]) > 0x64 )
    {
      dword_1011FD80[a1] = v1;
      if ( !sub_10003E90(&v6) || !v6 )
      {
        v2 = sub_10024C00(a1);
        sub_10003EF0(v2, 17, 0);
        return v5;
      }
    }
  }
  return v5;
}
// 1011FD80: using guessed type int dword_1011FD80[];
// 102229B4: using guessed type int dword_102229B4;

//----- (10007B50) --------------------------------------------------------
char __usercall sub_10007B50@<al>(unsigned __int16 a1@<ax>)
{
  int v1; // eax@1
  int v2; // eax@2
  char result; // al@4

  v1 = a1 - 368;
  if ( v1 )
  {
    v2 = v1 - 2;
    if ( v2 )
    {
      if ( v2 == 2 )
        result = 2;
      else
        result = 3;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10007BB0) --------------------------------------------------------
int __usercall sub_10007BB0@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  char v4; // dl@1
  unsigned __int8 v5; // cl@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // edx@1
  int v9; // eax@1
  int v10; // ecx@1
  int v11; // edx@1
  int v12; // eax@1
  int v13; // ecx@1
  int v14; // eax@1
  int result; // eax@1
  char v16; // [sp+8h] [bp-2Ch]@1
  char v17; // [sp+9h] [bp-2Bh]@1
  char v18; // [sp+Ah] [bp-2Ah]@1
  char v19; // [sp+Bh] [bp-29h]@1
  char v20; // [sp+Ch] [bp-28h]@1
  char v21; // [sp+Dh] [bp-27h]@1
  char v22; // [sp+Eh] [bp-26h]@1
  char v23; // [sp+Fh] [bp-25h]@1
  char v24; // [sp+10h] [bp-24h]@1
  char v25; // [sp+11h] [bp-23h]@1
  int v26; // [sp+14h] [bp-20h]@1
  int v27; // [sp+18h] [bp-1Ch]@1
  int v28; // [sp+1Ch] [bp-18h]@1
  int v29; // [sp+20h] [bp-14h]@1
  int v30; // [sp+24h] [bp-10h]@1
  int v31; // [sp+28h] [bp-Ch]@1
  int v32; // [sp+2Ch] [bp-8h]@1
  int v33; // [sp+30h] [bp-4h]@1

  v2 = a1;
  memset(&v16, 0, 0x2Cu);
  v3 = *(_WORD *)(v2 + 6);
  v4 = *(_BYTE *)(v2 + 5);
  v16 = *(_BYTE *)(v2 + 4);
  v17 = v4;
  v18 = (v3 >> 12) & 0xF;
  v19 = BYTE1(v3) & 7;
  v20 = ((unsigned __int8)v3 >> 7) & 1;
  v21 = ((unsigned __int8)v3 >> 4) & 7;
  v22 = ((unsigned __int8)v3 >> 3) & 1;
  v5 = v3;
  v23 = ((unsigned __int8)v3 >> 2) & 1;
  v6 = *(_DWORD *)(v2 + 8);
  v25 = v3 & 1;
  v7 = *(_DWORD *)(v2 + 12);
  v26 = v6;
  v8 = *(_DWORD *)(v2 + 20);
  v27 = v7;
  v9 = *(_DWORD *)(v2 + 24);
  v24 = (v5 >> 1) & 1;
  v10 = *(_DWORD *)(v2 + 16);
  v29 = v8;
  v11 = *(_DWORD *)(v2 + 32);
  v30 = v9;
  v12 = *(_DWORD *)(v2 + 36);
  v28 = v10;
  v13 = *(_DWORD *)(v2 + 28);
  v32 = v11;
  v33 = v12;
  v31 = v13;
  v14 = 48 * a2;
  qmemcpy((void *)(v14 + dword_102229B4), &v16, 0x2Cu);
  *(_BYTE *)(v14 + dword_102229B4 + 44) = 0;
  result = dword_102229B4;
  *(_BYTE *)(a2 + dword_102229B4 + 192) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007CB0) --------------------------------------------------------
int __usercall sub_10007CB0@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  __int16 v2; // ST08_2@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // esi@1
  int result; // eax@1

  LOBYTE(v2) = *(_BYTE *)(a1 + 4);
  HIBYTE(v2) = *(_BYTE *)(a1 + 5);
  v3 = *(_BYTE *)(a1 + 6);
  v4 = 48 * a2;
  v5 = v4 + dword_102229B4;
  *(_WORD *)v5 = v2;
  *(_BYTE *)(v5 + 2) = v3;
  *(_BYTE *)(v4 + dword_102229B4 + 44) = 1;
  result = dword_102229B4;
  *(_BYTE *)(a2 + dword_102229B4 + 192) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007D10) --------------------------------------------------------
int __usercall sub_10007D10@<eax>(int result@<eax>, int a2@<ecx>)
{
  result = (unsigned __int8)result;
  *(_WORD *)(dword_102229B4 + 8 * result + 196) = *(_WORD *)(a2 + 4);
  *(_WORD *)(dword_102229B4 + 8 * result + 198) = *(_WORD *)(a2 + 6);
  *(_WORD *)(dword_102229B4 + 8 * result + 202) = *(_WORD *)(a2 + 8);
  *(_WORD *)(dword_102229B4 + 8 * result + 200) = *(_WORD *)(a2 + 10);
  *(_BYTE *)(result + dword_102229B4 + 692) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007D70) --------------------------------------------------------
int __usercall sub_10007D70@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  char v2; // dl@1
  unsigned __int8 v3; // cl@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // edx@1
  int v11; // ecx@1
  int v12; // eax@1
  int result; // eax@1
  __int64 v14; // [sp+8h] [bp-24h]@1
  int v15; // [sp+10h] [bp-1Ch]@1
  int v16; // [sp+14h] [bp-18h]@1
  int v17; // [sp+18h] [bp-14h]@1
  int v18; // [sp+1Ch] [bp-10h]@1
  int v19; // [sp+20h] [bp-Ch]@1
  int v20; // [sp+24h] [bp-8h]@1
  int v21; // [sp+28h] [bp-4h]@1

  v2 = *(_BYTE *)(a1 + 5);
  v14 = 0i64;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v14 = *(_BYTE *)(a1 + 4);
  v3 = *(_BYTE *)(a1 + 6);
  BYTE1(v14) = v2;
  *(_DWORD *)((char *)&v14 + 2) = v3 >> 4;
  v4 = *(_DWORD *)(a1 + 11);
  *(_WORD *)((char *)&v14 + 3) = v3 & 7;
  v5 = *(_DWORD *)(a1 + 7);
  v15 = v4;
  v6 = *(_DWORD *)(a1 + 19);
  HIDWORD(v14) = v5;
  v7 = *(_DWORD *)(a1 + 15);
  v17 = v6;
  v8 = *(_DWORD *)(a1 + 27);
  v16 = v7;
  v9 = *(_DWORD *)(a1 + 23);
  v19 = v8;
  v10 = *(_DWORD *)(a1 + 35);
  v18 = v9;
  v11 = *(_DWORD *)(a1 + 31);
  v21 = v10;
  v20 = v11;
  v12 = 48 * a2;
  qmemcpy((void *)(v12 + dword_102229B4), &v14, 0x24u);
  *(_BYTE *)(v12 + dword_102229B4 + 44) = 2;
  result = dword_102229B4;
  *(_BYTE *)(a2 + dword_102229B4 + 192) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007E40) --------------------------------------------------------
int __usercall sub_10007E40@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // ST0C_4@1
  int v3; // esi@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // esi@1
  int result; // eax@1

  LOBYTE(v2) = *(_BYTE *)(a1 + 4);
  BYTE1(v2) = *(_BYTE *)(a1 + 5);
  v3 = dword_102229B4;
  HIWORD(v2) = *(_BYTE *)(a1 + 6);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 12);
  v6 = 48 * a2;
  *(_DWORD *)(dword_102229B4 + v6) = v2;
  v7 = v6 + v3;
  *(_DWORD *)(v7 + 4) = v4;
  *(_DWORD *)(v7 + 8) = v5;
  result = dword_102229B4;
  *(_BYTE *)(v6 + dword_102229B4 + 44) = 3;
  *(_BYTE *)(a2 + dword_102229B4 + 192) = 1;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007EB0) --------------------------------------------------------
char __usercall sub_10007EB0@<al>(int a1@<eax>, unsigned __int8 a2@<bl>, int a3@<esi>)
{
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // edi@2
  unsigned __int8 v6; // dl@3

  v3 = a1 + 5;
  v4 = *(_BYTE *)(a1 + 4);
  if ( v4 > 0 )
  {
    v5 = v4;
    do
    {
      v6 = *(_BYTE *)v3;
      if ( *(_BYTE *)(v3 + 1) )
      {
        LOBYTE(v4) = v6 + 36;
        if ( (unsigned __int8)(v6 + 36) <= 0x1Cu )
        {
          v4 = v6 + 28 * a2;
          *(_DWORD *)(dword_102229B4 + 4 * v4 + 244) = *(_DWORD *)(v3 + 2);
          *(_DWORD *)(dword_102229B4 + 4 * v4 + 712) = a3;
        }
      }
      v3 += 6;
      --v5;
    }
    while ( v5 );
  }
  return v4;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007F10) --------------------------------------------------------
int __usercall sub_10007F10@<eax>(int a1@<eax>, unsigned __int8 a2, int a3)
{
  unsigned __int16 v3; // cx@1
  int result; // eax@1

  v3 = *(_WORD *)(a1 + 4);
  result = a2;
  *(_DWORD *)(dword_102229B4 + 4 * result + 228) = v3;
  *(_DWORD *)(dword_102229B4 + 4 * result + 696) = a3;
  return result;
}
// 102229B4: using guessed type int dword_102229B4;

//----- (10007F70) --------------------------------------------------------
char __cdecl sub_10007F70(int a1, int a2)
{
  int v2; // eax@1
  unsigned __int8 v3; // bl@2
  void *v4; // ecx@2
  int v5; // eax@14
  int v6; // eax@15
  char v8; // [sp+Bh] [bp-279h]@3
  int v9; // [sp+Ch] [bp-278h]@2
  int v10; // [sp+10h] [bp-274h]@1
  unsigned __int8 v11; // [sp+14h] [bp-270h]@1
  unsigned __int8 v12; // [sp+15h] [bp-26Fh]@8
  char v13; // [sp+21Ch] [bp-68h]@1

  memset(&v13, 0, 0x64u);
  memset(&v11, 0, 0x208u);
  v10 = 0;
  LOBYTE(v2) = sub_1000DA70(a1, a2, &v11, (unsigned __int16 *)&v10);
  if ( (_BYTE)v2 )
  {
    v3 = sub_10007B50(a1);
    LOBYTE(v9) = v3;
    if ( sub_1001FDE0(v4) == 1 && sub_1001F2F0((bool *)&v8) && v8 && !*((_BYTE *)&dword_1011FD7C + v3) )
      *((_BYTE *)&dword_1011FD7C + v3) = sub_10007910(v3);
    LOBYTE(v2) = v11;
    switch ( v11 )
    {
      case 0xCu:
        v2 = v12;
        switch ( v12 )
        {
          case 2u:
            LOBYTE(v2) = sub_10007BB0((int)&v11, v9);
            break;
          case 4u:
            LOBYTE(v2) = sub_10007CB0((int)&v11, v9);
            break;
          case 6u:
            LOBYTE(v2) = sub_10007E40((int)&v11, v9);
            break;
          case 8u:
            LOBYTE(v2) = sub_10007D70((int)&v11, v9);
            break;
          case 0xEu:
            LOBYTE(v2) = v3;
            LOBYTE(v2) = sub_10007D10(v2, (int)&v11);
            break;
          default:
            return v2;
        }
        break;
      case 0x37u:
        v5 = sub_1000C2F0(a1, a2);
        LOBYTE(v2) = sub_10007EB0((int)&v11, v3, v5);
        break;
      case 0x39u:
        v6 = sub_1000C2F0(a1, a2);
        LOBYTE(v2) = sub_10007F10((int)&v11, v9, v6);
        break;
      default:
        sprintf(&v13, "INVALID GEA PKT ID %d\n", v11);
        LOBYTE(v2) = sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_inst_frmt.c", 538, 0, &v13);
        break;
      case 1u:
      case 2u:
      case 5u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xDu:
      case 0x32u:
      case 0x33u:
      case 0x35u:
      case 0x36u:
      case 0xFFu:
        return v2;
    }
  }
  return v2;
}
// 1011FD7C: using guessed type int dword_1011FD7C;

//----- (10008280) --------------------------------------------------------
char __cdecl sub_10008280(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10024DD0(a1, v4, &v6) == 1 )
  {
    v2 = sub_1000E330(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_1000F100(v4[0], v6, &v5) && !sub_10024EE0((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100083A0) --------------------------------------------------------
bool __cdecl sub_100083A0(int a1, void *a2)
{
  bool result; // al@2

  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      LOBYTE(a1) = 27;
      result = sub_10025350(a1, a2);
      break;
    case 1u:
      LOBYTE(a1) = 28;
      result = sub_10025350(a1, a2);
      break;
    case 2u:
      LOBYTE(a1) = 29;
      result = sub_10025350(a1, a2);
      break;
    case 3u:
      LOBYTE(a1) = -122;
      result = sub_10025350(a1, a2);
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 741, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10008430) --------------------------------------------------------
void sub_10008430()
{
  dword_1011FD90 = -15;
}
// 1011FD90: using guessed type int dword_1011FD90;

//----- (10008440) --------------------------------------------------------
double __cdecl sub_10008440(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (100084A0) --------------------------------------------------------
bool sub_100084A0()
{
  dword_1011FD90 = dword_102229B4;
  return (unsigned int)dword_102229B4 < 0xFFFFFFC2 && dword_102229B4;
}
// 1011FD90: using guessed type int dword_1011FD90;
// 102229B4: using guessed type int dword_102229B4;

//----- (100084D0) --------------------------------------------------------
char __usercall sub_100084D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_10018540(6091, (int)&v23, 16) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_10018540(6115, (int)&v25, 16) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_10018540(6090, (int)&v31, 40) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_10018540(6114, (int)&v27, 40) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_10018540(6092, (int)&v29, 40) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_10018540(6116, (int)&v33, 40) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_10018600(6355, &v22, 4, &v19) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_10019570(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_10018600(6356, &v21, 4, &v19) )
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_10019570(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_10018540(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_10018540(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_10018540(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_10018540(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_10008280(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_10008440(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 100084D0: using guessed type int var_AC[3];
// 100084D0: using guessed type int var_BC[3];
// 100084D0: using guessed type float var_22C[76];
// 100084D0: using guessed type float var_27C[19];

//----- (10008A10) --------------------------------------------------------
char __cdecl sub_10008A10(unsigned __int8 a1, int a2)
{
  char v2; // bl@1
  char result; // al@2
  unsigned __int8 v4; // dl@3
  int v5; // ebx@4
  int v6; // edx@10
  int v7; // edx@11
  int v8; // edx@12
  int v9; // edx@13
  int v10; // edx@14
  int v11; // edx@15
  int v12; // edx@16
  int v13; // edx@25
  int v14; // edx@26
  int v15; // edx@27
  int v16; // edx@28
  int v17; // edx@29
  int v18; // edx@30
  int v19; // edx@31
  int v20; // edx@36

  v2 = 0;
  if ( a1 < 4u )
  {
    if ( sub_100084A0() == 1
      && (v5 = dword_1011FD90,
          qmemcpy((void *)a2, (const void *)(dword_1011FD90 + 48 * v4), 0x30u),
          (v2 = *(_BYTE *)(v4 + v5 + 192)) != 0) )
    {
      switch ( *(_BYTE *)(a2 + 44) )
      {
        case 0:
          if ( *(_BYTE *)(a2 + 1) < 0xAEu
            && *(_BYTE *)(a2 + 2) < 7u
            && *(_BYTE *)(a2 + 3) <= 5u
            && *(_BYTE *)(a2 + 5) < 6u
            && sub_100112E0(*(float *)(a2 + 12))
            && sub_100112E0(*(float *)(v6 + 16))
            && sub_100112E0(*(float *)(v7 + 20))
            && sub_100112E0(*(float *)(v8 + 24))
            && sub_100112E0(*(float *)(v9 + 28))
            && sub_100112E0(*(float *)(v10 + 32))
            && sub_100112E0(*(float *)(v11 + 36))
            && sub_100112E0(*(float *)(v12 + 40)) )
          {
            goto LABEL_42;
          }
          sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 406, 0, 0);
          result = 0;
          break;
        case 1:
          if ( *(_BYTE *)(a2 + 1) < 0xAEu && *(_BYTE *)(a2 + 2) < 2u )
            goto LABEL_42;
          sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 416, 0, 0);
          result = 0;
          break;
        case 2:
          if ( *(_BYTE *)(a2 + 1) < 0xAEu
            && *(_BYTE *)(a2 + 2) == 5
            && *(_BYTE *)(a2 + 3) <= 5u
            && sub_100112E0(*(float *)(a2 + 4))
            && sub_100112E0(*(float *)(v13 + 8))
            && sub_100112E0(*(float *)(v14 + 12))
            && sub_100112E0(*(float *)(v15 + 16))
            && sub_100112E0(*(float *)(v16 + 20))
            && sub_100112E0(*(float *)(v17 + 24))
            && sub_100112E0(*(float *)(v18 + 28))
            && sub_100112E0(*(float *)(v19 + 32)) )
          {
            goto LABEL_42;
          }
          sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 435, 0, 0);
          result = 0;
          break;
        case 3:
          if ( *(_BYTE *)(a2 + 1) < 0xAEu
            && *(_BYTE *)(a2 + 2) < 2u
            && sub_100112E0(*(float *)(a2 + 4))
            && sub_100112E0(*(float *)(v20 + 8)) )
          {
            goto LABEL_42;
          }
          sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 447, 0, 0);
          result = 0;
          break;
        default:
          if ( *(_BYTE *)(a2 + 44) != -1 )
            sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 460, 0, 0);
          v2 = 0;
          goto LABEL_42;
      }
    }
    else
    {
LABEL_42:
      result = v2;
    }
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 374, 0, 0);
    result = 0;
  }
  return result;
}
// 1011FD90: using guessed type int dword_1011FD90;

//----- (10008D00) --------------------------------------------------------
char __cdecl sub_10008D00(unsigned __int8 a1, int a2)
{
  unsigned __int8 v3; // dl@4
  int v4; // ecx@5

  if ( a1 >= 4u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 509, 0, 0);
    return 0;
  }
  if ( sub_100084A0() != 1 )
    return 0;
  v4 = dword_1011FD90;
  *(_DWORD *)a2 = *(_DWORD *)(dword_1011FD90 + 8 * v3 + 196);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 8 * v3 + 200);
  return *(_BYTE *)(v3 + v4 + 692);
}
// 1011FD90: using guessed type int dword_1011FD90;

//----- (10008D60) --------------------------------------------------------
char __cdecl sub_10008D60(float a1, int a2, int a3)
{
  unsigned __int8 v3; // dl@3
  int v4; // esi@4
  char v5; // dl@5
  char result; // al@6
  float v7; // [sp+10h] [bp+4h]@5

  if ( LOBYTE(a1) >= 4u || (unsigned __int16)(a2 - 220) > 0x1Cu )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 655, 0, 0);
    return 0;
  }
  if ( !sub_100084A0() )
    return 0;
  v4 = (unsigned __int16)a2 + 28 * v3;
  if ( *(_DWORD *)(dword_1011FD90 + 4 * v4 + 712) + 4000 <= (unsigned int)sub_100181D0() )
    return 0;
  v7 = *(float *)(dword_1011FD90 + 4 * v4 + 244);
  *(float *)a3 = v7;
  if ( sub_100112E0(v7) )
  {
    result = v5;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 672, 0, 0);
    result = 0;
  }
  return result;
}
// 1011FD90: using guessed type int dword_1011FD90;

//----- (10008E20) --------------------------------------------------------
char __cdecl sub_10008E20(unsigned __int8 a1, _DWORD *a2)
{
  char result; // al@3
  unsigned __int8 v3; // dl@4
  int v4; // esi@5

  if ( a1 >= 4u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 795, 0, 0);
    return 0;
  }
  if ( sub_100084A0() != 1 )
    return 0;
  v4 = v3;
  if ( *(_DWORD *)(dword_1011FD90 + 4 * v3 + 696) + 4000 <= (unsigned int)sub_100181D0() )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(dword_1011FD90 + 4 * v4 + 228);
    result = 1;
  }
  return result;
}
// 1011FD90: using guessed type int dword_1011FD90;

//----- (10008E90) --------------------------------------------------------
char __usercall sub_10008E90@<al>(int a1@<ecx>, _BYTE *a2@<edi>, _BYTE *a3@<esi>)
{
  char result; // al@1
  char v4; // cl@3
  char v5; // al@5
  char v6; // dl@8
  char v7; // cl@10
  int v8; // [sp-2h] [bp-4h]@1

  v8 = a1;
  result = 0;
  if ( a1 & 0x100 )
  {
    result = sub_1000F100(6, 13, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v4 = BYTE3(v8);
      *a2 = 6;
      *a3 = v4;
      return result;
    }
    if ( sub_1000F100(0, 14, (char *)&v8 + 3) == 1 )
    {
      v5 = BYTE3(v8);
      *a2 = 0;
      *a3 = v5;
      return 1;
    }
  }
  else
  {
    if ( !(a1 & 0x200) )
      return result;
    result = sub_1000F100(6, 16, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v6 = BYTE3(v8);
      *a2 = 6;
      *a3 = v6;
      return result;
    }
    result = sub_1000F100(0, 17, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v7 = BYTE3(v8);
      *a2 = 0;
      *a3 = v7;
      return result;
    }
  }
  result = 0;
  *a3 = 0;
  return result;
}

//----- (10008F30) --------------------------------------------------------
char __usercall sub_10008F30@<al>(unsigned __int8 a1@<al>, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v2 = a1 - 1;
  v5 = 0;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 != 14 )
        return sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_upld.c", 542, 1, 0);
      v5 = 5;
    }
    else
    {
      v5 = 3;
    }
  }
  else
  {
    v5 = 2;
  }
  sub_1000EA90(0, 5, &v5, 0, 4, 1);
  return sub_1000ED50(0, 5, a2);
}

//----- (10008FB0) --------------------------------------------------------
char __cdecl sub_10008FB0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  void *v5; // ecx@1
  int v6; // ebp@1
  char result; // al@4
  unsigned __int8 v8; // bl@5
  char v9; // [sp+Bh] [bp-5h]@1
  int v10; // [sp+Ch] [bp-4h]@3

  v9 = 0;
  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  v6 = a1;
  if ( (a1 & v4) == a1 )
  {
    if ( a4 == 68 )
    {
      v10 = 1;
      sub_1000EA90(0, 5, &v10, 0, 4, 1);
      sub_1000ED50(0, 5, v6);
      return 1;
    }
    v8 = sub_1001FDE0(v5);
    if ( sub_10008E90(v6, &a1, &v9) == 1 )
    {
      if ( v9 == v8 )
        return 1;
      sub_10008F30(v8, v6);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10009040) --------------------------------------------------------
char __cdecl sub_10009040(int a1, char a2, int a3, __int16 a4)
{
  void *v4; // ecx@1
  unsigned __int8 v5; // bl@2
  char result; // al@9
  char v7; // [sp+Ah] [bp-2h]@1
  char v8; // [sp+Bh] [bp-1h]@1

  v8 = 0;
  v7 = 6;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    v5 = sub_1001FDE0(v4);
    if ( !a2 )
    {
      switch ( a4 )
      {
        case 0:
        case 1:
        case 0xF:
        case 0x39:
        case 0x3A:
          v5 = 16;
          break;
        default:
          break;
      }
    }
    if ( sub_10008E90(a1, &v7, &v8) == 1 )
    {
      if ( v7 == 6 )
        sub_1000FA00(6);
      if ( v8 == v5 )
        return 1;
      sub_10008F30(v5, a1);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10009120) --------------------------------------------------------
char __cdecl sub_10009120(char a1, _BYTE *a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = 0;
  BYTE3(v4) = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      goto LABEL_7;
    result = sub_1000F100(0, 603, (char *)&v4 + 3);
  }
  else
  {
    result = sub_1000F100(0, 602, (char *)&v4 + 3);
  }
  if ( result == 1 )
  {
    *a2 = BYTE3(v4);
    return result;
  }
LABEL_7:
  *a2 = 0;
  return result;
}

//----- (10009170) --------------------------------------------------------
char __cdecl sub_10009170(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  unsigned __int8 v6; // bl@1
  int v7; // eax@2
  char result; // al@3

  v6 = sub_10021B20(a1);
  if ( v6 >= 2u || (v7 = sub_1001E7B0(&a5, 1u, (int)&unk_1006EE30, 101, 10, 10), v7 >= 10) )
  {
    result = 0;
  }
  else
  {
    sub_1001F8F0(a6, 0x64u, &byte_1006EE31[101 * v7], v6 + 1);
    result = 1;
  }
  return result;
}

//----- (100091D0) --------------------------------------------------------
char __cdecl sub_100091D0(int a1)
{
  char v1; // bl@1
  char result; // al@3

  v1 = 1;
  if ( sub_10002E80() != 5 || (v1 = sub_10021B60(a1, &dword_1011FD9C)) != 0 )
  {
    sub_10021C20(a1, (int)&dword_1011FD9C);
    sub_10002F90(7);
    result = v1;
  }
  else
  {
    sub_10002EA0();
    if ( (unsigned int)sub_10002E70() <= 0x14 )
    {
      sub_10002F90(2);
      result = 0;
    }
    else
    {
      sub_10002F90(8);
      result = 0;
    }
  }
  return result;
}
// 1011FD9C: using guessed type int dword_1011FD9C;

//----- (10009240) --------------------------------------------------------
char __cdecl sub_10009240(int a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@2
  int *v3; // ecx@2
  int *v4; // edx@2
  int v5; // esi@6
  int v6; // eax@7
  _BYTE *v7; // ecx@7
  _BYTE *v8; // edx@7
  int v9; // eax@9
  _BYTE *v10; // ecx@9
  _BYTE *v11; // edx@9
  _BYTE *v12; // ecx@11
  _BYTE *v13; // edx@11
  signed int v14; // eax@13
  char result; // al@19
  int v16; // [sp+8h] [bp-4h]@0

  v1 = sub_10002E80();
  if ( !(unsigned __int8)sub_10021B60(a1, &dword_1011FD9C) )
  {
    LOBYTE(v16) = 2;
    goto LABEL_23;
  }
  v2 = 16;
  v3 = &dword_1011FDAC;
  v4 = &dword_1011FD9C;
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_6;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_15:
    v14 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_15;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_15;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_15;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_15;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_16:
  if ( !v14 )
  {
    if ( v1 == 1 || v1 == 5 )
    {
      LOBYTE(v16) = 7;
      sub_10002F90(v16);
      result = 1;
    }
    else
    {
      LOBYTE(v16) = 10;
      sub_10002F90(v16);
      result = 1;
    }
    return result;
  }
  LOBYTE(v16) = 1;
LABEL_23:
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() > 0x14 )
    LOBYTE(v16) = 8;
  sub_10002F90(v16);
  return 0;
}
// 1011FD9C: using guessed type int dword_1011FD9C;
// 1011FDAC: using guessed type int dword_1011FDAC;

//----- (10009380) --------------------------------------------------------
char sub_10009380()
{
  if ( j_HWM_pvg_read_reg(1) || (unsigned int)(sub_100181D0() - dword_1011FDBC) > 0x1F4 )
    sub_10002F90((unsigned __int8)byte_1011FD94);
  return 1;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FD94: using guessed type char byte_1011FD94;
// 1011FDBC: using guessed type int dword_1011FDBC;

//----- (100093C0) --------------------------------------------------------
char __cdecl sub_100093C0(unsigned __int8 a1, char a2)
{
  char result; // al@1

  result = a2;
  if ( a2 == 4 )
    result = 1;
  if ( a1 < 2u )
    byte_1011FDC8[a1] = result;
  return result;
}

//----- (100093E0) --------------------------------------------------------
BOOL __usercall sub_100093E0@<eax>(char a1@<al>, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10003B50(a1);
  return sub_1000F100(0, 613, a2) && sub_1000E940(0, 0x265u, (int)&v4) && (v2 & v5) == v2;
}

//----- (10009440) --------------------------------------------------------
char __cdecl sub_10009440(unsigned int *a1)
{
  char v1; // cl@0
  char v2; // bl@1
  char v4; // [sp+4h] [bp-10h]@1

  v2 = sub_10021BF0(v1, (int)&v4);
  if ( v2 )
    *a1 = sub_1004C560((unsigned int *)&v4, 16, 0xFFFFFFFF);
  return v2;
}

//----- (10009480) --------------------------------------------------------
char __usercall sub_10009480@<al>(char a1@<bl>, unsigned __int8 a2)
{
  int v2; // eax@1
  int v3; // edi@1
  char v5; // [sp+Bh] [bp-Dh]@8
  int v6; // [sp+Ch] [bp-Ch]@2
  int v7; // [sp+10h] [bp-8h]@3

  v2 = sub_100181D0();
  v3 = v2;
  if ( !byte_1011FD98[a2] )
  {
    LOBYTE(v2) = sub_100093E0(a1, &v6);
    if ( (_BYTE)v2 && (LOBYTE(v2) = sub_10009440((unsigned int *)&v7), (_BYTE)v2) )
    {
      if ( v6 != v7 )
      {
        sub_1001E570(word_1006F224[2 * a2]);
        sub_10003F20(a1, 0);
        LOBYTE(v2) = sub_1001E460(word_1006F226[2 * a2]);
      }
      byte_1011FD98[a2] = 1;
    }
    else if ( (unsigned int)(v3 - dword_1011FDC0[a2]) > 0x3E8 )
    {
      dword_1011FDC0[a2] = v3;
      LOBYTE(v2) = sub_10003E90(&v5);
      if ( (_BYTE)v2 )
      {
        if ( !v5 )
          LOBYTE(v2) = sub_10003EF0(a1, 17, 0);
      }
    }
  }
  return v2;
}
// 1006F224: using guessed type __int16 word_1006F224[];
// 1006F226: using guessed type __int16 word_1006F226[];
// 1011FDC0: using guessed type int dword_1011FDC0[];

//----- (10009570) --------------------------------------------------------
char __cdecl sub_10009570(char a1)
{
  char result; // al@1

  sub_10002F90(4);
  dword_1011FDBC = sub_100181D0();
  result = a1;
  byte_1011FD94 = a1;
  return result;
}
// 1011FD94: using guessed type char byte_1011FD94;
// 1011FDBC: using guessed type int dword_1011FDBC;

//----- (10009590) --------------------------------------------------------
char __usercall sub_10009590@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5, int a6)
{
  sub_1000EA90(0, a4, a5, a2, a1, a3);
  return sub_1000ED50(0, a4, a6);
}

//----- (100095C0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100095C0(char a1)
{
  unsigned __int8 result; // al@1
  int v2; // esi@2
  void *v3; // ecx@2
  char v4; // al@2
  unsigned __int8 v5; // [sp+0h] [bp-4h]@1

  result = sub_10021B20(a1);
  v5 = result;
  if ( result < 2u )
  {
    v2 = result;
    dword_1011FDC0[v2] = sub_100181D0();
    byte_1011FD98[v2] = 0;
    v4 = sub_1001FDE0(v3);
    result = sub_100093C0(v5, v4);
  }
  return result;
}
// 1011FDC0: using guessed type int dword_1011FDC0[];

//----- (10009610) --------------------------------------------------------
char __cdecl sub_10009610(char a1, char a2)
{
  char v2; // bl@1
  int v3; // edi@1
  void *v4; // ecx@1
  __int64 *v5; // eax@1
  __int64 v7; // [sp+Ch] [bp-Ch]@1

  v2 = 0;
  v3 = sub_10003B50(a1);
  HIDWORD(v7) = sub_100206D0(v4);
  LODWORD(v7) = (unsigned __int16)(a2 != 17 ? 604 : 613);
  sub_1000C020(v7, (int)&byte_10222BE0);
  v5 = &v7;
  LOBYTE(v5) = 1;
  sub_10009590(8, 0, (int)v5, 3, &v7, v3);
  switch ( sub_10002E80() )
  {
    case 1:
    case 4:
      sub_10009570(3);
      v2 = 1;
      break;
    case 5:
      if ( sub_10002E60() )
      {
        sub_10009570(10);
        v2 = 1;
      }
      else
      {
        sub_10009570(3);
        v2 = 1;
      }
      break;
    case 2:
      sub_10002F90(0);
      v2 = 1;
      break;
    default:
      sub_10002F90(8);
      break;
  }
  if ( a2 == 11 && j_HWM_pvg_read_reg(1) == 1 )
  {
    dword_10222C28 |= v3;
    sub_1000EA90(0, 604, &dword_1011FDAC, 0, 16, 1);
    dword_10222C28 &= ~v3;
  }
  return v2;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FDAC: using guessed type int dword_1011FDAC;
// 10222BE0: using guessed type char byte_10222BE0;
// 10222C24: using guessed type int dword_10222C24;
// 10222C28: using guessed type int dword_10222C28;

//----- (10009740) --------------------------------------------------------
char __cdecl sub_10009740(int a1, int a2, int a3, int a4, void *a5, size_t a6)
{
  char v6; // bl@2
  int v7; // eax@3
  int v8; // ST08_4@3

  if ( a6 )
  {
    memcpy(&dword_1011FD9C, a5, a6);
    v6 = 1;
    goto LABEL_3;
  }
  v6 = sub_10021BF0(a1, (int)&dword_1011FD9C);
  if ( v6 )
  {
LABEL_3:
    v7 = sub_10003B50(a1);
    v8 = v7;
    LOBYTE(v7) = 1;
    sub_10009590(16, 0, v7, 604, &dword_1011FD9C, v8);
    dword_1011FDAC = dword_1011FD9C;
    dword_1011FDB0 = dword_1011FDA0;
    dword_1011FDB4 = dword_1011FDA4;
    dword_1011FDB8 = dword_1011FDA8;
    sub_10009570(2);
    return v6;
  }
  sub_10002F90(8);
  return 0;
}
// 1011FD9C: using guessed type int dword_1011FD9C;
// 1011FDA0: using guessed type int dword_1011FDA0;
// 1011FDA4: using guessed type int dword_1011FDA4;
// 1011FDA8: using guessed type int dword_1011FDA8;
// 1011FDAC: using guessed type int dword_1011FDAC;
// 1011FDB0: using guessed type int dword_1011FDB0;
// 1011FDB4: using guessed type int dword_1011FDB4;
// 1011FDB8: using guessed type int dword_1011FDB8;

//----- (100097F0) --------------------------------------------------------
char __cdecl sub_100097F0(unsigned __int8 a1, signed int a2)
{
  void *v2; // ecx@0
  char result; // al@1
  void *v4; // ecx@7
  int v5; // eax@9
  int v6; // ST04_4@9

  result = a2;
  switch ( (unsigned __int8)a2 )
  {
    case 1u:
      a2 = 2;
      goto LABEL_6;
    case 2u:
      a2 = 3;
      goto LABEL_6;
    case 8u:
      a2 = 4;
      goto LABEL_6;
    case 0x10u:
      a2 = 5;
LABEL_6:
      if ( a1 < 2u )
      {
        if ( sub_100206D0(v2) == 1 || (result = sub_1001FDC0(v4), !(result & 1)) )
        {
          v5 = sub_100254D0(a1);
          v6 = v5;
          LOBYTE(v5) = 1;
          result = sub_10009590(4, 0, v5, 5, &a2, v6);
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (100098A0) --------------------------------------------------------
char __usercall sub_100098A0@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>)
{
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  BYTE3(v3) = 0;
  result = sub_10009120(a2, (_BYTE *)&v3 + 3);
  if ( result )
  {
    result = byte_1011FDC8[a2];
    if ( result != BYTE3(v3) )
      result = sub_100097F0(a2, (unsigned __int8)byte_1011FDC8[a2]);
  }
  return result;
}

//----- (100098E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100098E0(char a1)
{
  unsigned __int8 result; // al@1
  unsigned __int8 v2; // bl@1
  int v3; // ecx@2
  void *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-4h]@1

  result = sub_10021B20(a1);
  v2 = result;
  v5 = result;
  if ( result < 2u )
  {
    result = sub_10025510(result);
    if ( result )
    {
      sub_100098A0(v3, v2);
      result = sub_1001F430(v4);
      if ( result )
        result = sub_10009480(a1, v5);
    }
  }
  return result;
}

//----- (10009930) --------------------------------------------------------
char __usercall sub_10009930@<al>(int a1@<eax>, char a2)
{
  char v2; // si@1
  char result; // al@3
  char v4; // [sp+Bh] [bp-5h]@1
  unsigned int v5; // [sp+Ch] [bp-4h]@2

  v2 = a1;
  v4 = 0;
  if ( !sub_1001FD00(a1)
    || (LOBYTE(v5) = sub_100254F0(v2), sub_100093C0(v5, a2), !sub_10009120(v5, &v4))
    || (result = 1, a2 != v4) )
  {
    result = 0;
  }
  return result;
}

//----- (10009990) --------------------------------------------------------
char __cdecl sub_10009990(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_1001FDE0(v1);
  return sub_10009930(a1, v2);
}

//----- (100099B0) --------------------------------------------------------
char __cdecl sub_100099B0(int a1)
{
  return sub_10009930(a1, 16);
}

//----- (100099C0) --------------------------------------------------------
char sub_100099C0()
{
  char result; // al@1

  result = 0;
  byte_1011FDCA = 0;
  byte_1011FDCB = 0;
  return result;
}
// 1011FDCA: using guessed type char byte_1011FDCA;
// 1011FDCB: using guessed type char byte_1011FDCB;

//----- (100099D0) --------------------------------------------------------
char __cdecl sub_100099D0(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // bl@1
  int v4; // eax@7
  char v6; // [sp+8h] [bp-14h]@1
  float v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  int v9; // [sp+14h] [bp-8h]@1

  v7 = 0.0;
  v8 = 0;
  v9 = 0;
  v6 = 0;
  v3 = sub_100255A0(v2);
  if ( v3 )
  {
    if ( !sub_1001A020() && !sub_100255D0((unsigned __int8)(v3 + 2)) )
    {
      v6 = sub_10025540((v3 == 2) + 3, &v8);
      if ( v6 == 1 )
      {
        v6 = (v8 & 8) != 8;
        if ( (v8 & 8) != 8 )
          v7 = (double)(signed __int16)v9 * 0.00002441406286379788;
      }
    }
  }
  v4 = sub_100181D0();
  return sub_1000CE40(a1, v6, a2, &v7, v4);
}

//----- (10009AA0) --------------------------------------------------------
char __fastcall sub_10009AA0(char a1)
{
  char result; // al@1
  int v2; // esi@3
  int v3; // eax@4
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1

  result = 0;
  v4 = 0;
  v5 = 0;
  if ( !a1 )
  {
    if ( byte_1011FDCA )
      return result;
    sub_1001E570(0x3Bu);
    sub_1001E460(60);
    v2 = 170;
    byte_1011FDCA = 1;
    goto LABEL_4;
  }
  if ( a1 == 1 && !byte_1011FDCB )
  {
    sub_1001E570(0x3Du);
    sub_1001E460(62);
    v2 = 171;
    byte_1011FDCB = 1;
LABEL_4:
    sub_1000DA50(v2, (int)&byte_10222BE0, &v4);
    LOWORD(v4) = v4 | 8;
    LOWORD(v5) = 0;
    v3 = sub_100181D0();
    result = sub_1000CE40(v2, 0, (int)&byte_10222BE0, &v4, v3);
  }
  return result;
}
// 1011FDCA: using guessed type char byte_1011FDCA;
// 1011FDCB: using guessed type char byte_1011FDCB;
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10009B60) --------------------------------------------------------
char __usercall sub_10009B60@<al>(__int16 *a1@<eax>, char a2@<cl>)
{
  __int16 v2; // ax@1

  v2 = *a1;
  if ( v2 & 1 && v2 & 2 )
  {
    if ( !(v2 & 4) )
    {
      if ( a2 == 1 )
        LOBYTE(v2) = sub_1001E570(0x3Eu);
      else
        LOBYTE(v2) = sub_1001E570(0x3Cu);
    }
  }
  else
  {
    LOBYTE(v2) = sub_10009AA0(a2);
  }
  return v2;
}

//----- (10009B90) --------------------------------------------------------
char __cdecl sub_10009B90(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  result = sub_1000DA50(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10009B60((__int16 *)&v3, (_WORD)a1 == 171);
  return result;
}

//----- (10009BF0) --------------------------------------------------------
char __cdecl sub_10009BF0(char a1, char *a2)
{
  char result; // al@2
  int v3; // [sp+8h] [bp-89Ch]@1
  int v4; // [sp+Ch] [bp-898h]@1
  char v5; // [sp+10h] [bp-894h]@1

  memset(&v5, 0, 0x890u);
  v3 = 0;
  v4 = 0;
  if ( sub_100259F0(a1, &v3) )
  {
    result = sub_1000DA50(*(int *)((char *)&v3 + 2), (int)&byte_10222BE0, &v5);
    if ( result == 1 )
      qmemcpy(a2, &v5, 0x890u);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10009CA0) --------------------------------------------------------
char __cdecl sub_10009CA0(char a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+7h] [bp-9h]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  if ( sub_10025A50(a1, &v4) )
  {
    result = sub_1000DA50(*(int *)((char *)&v4 + 2), (int)&byte_10222BE0, &v3);
    if ( result == 1 )
      *a2 = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10009D00) --------------------------------------------------------
unsigned int __cdecl sub_10009D00(char a1)
{
  memset(&unk_10120680, 0, 0x890u);
  sub_10021450(a1, (int)&unk_10120680);
  return sub_1004C560((unsigned int *)&unk_10120680, 2192, 0xFFFFFFFF);
}

//----- (10009D40) --------------------------------------------------------
char __cdecl sub_10009D40(char a1, int a2, int a3, int a4, char a5, int a6)
{
  int v6; // esi@1
  char v7; // al@2
  char result; // al@2

  v6 = sub_1001E7B0(&a5, 1u, (int)&unk_10070770, 301, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    v7 = sub_10025830(a1);
    sub_1001F7C0(a6, &byte_10070771[301 * v6] + 100 * (unsigned __int8)v7, 100);
    result = 1;
  }
  return result;
}

//----- (10009DA0) --------------------------------------------------------
char sub_10009DA0()
{
  if ( (unsigned int)(sub_100181D0() - dword_1012066C) > 0x7D0 )
    sub_10002F90((unsigned __int8)byte_1011FDD3);
  return 1;
}
// 1011FDD3: using guessed type char byte_1011FDD3;
// 1012066C: using guessed type int dword_1012066C;

//----- (10009DD0) --------------------------------------------------------
char __cdecl sub_10009DD0(char a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char result; // al@11
  unsigned int v4; // [sp+4h] [bp-78h]@1
  unsigned int v5; // [sp+8h] [bp-74h]@1
  unsigned int v6; // [sp+Ch] [bp-70h]@1
  char v7; // [sp+10h] [bp-6Ch]@1
  char v8; // [sp+4Fh] [bp-2Dh]@10
  char v9; // [sp+52h] [bp-2Ah]@4
  char v10; // [sp+53h] [bp-29h]@7

  v4 = 0;
  v5 = 0;
  LOWORD(v6) = 0;
  memset(&v7, 0, 0x68u);
  v1 = sub_1001E7B0(&a1, 2u, (int)&unk_10071334, 4, 3, -1);
  v2 = v1;
  if ( v1 != -1 && sub_100227C0(byte_10071336[4 * v1], &v7) && sub_10025990(byte_10071336[4 * v2], &v4) )
  {
    if ( v9 )
      sub_1001E570(HIWORD(v4));
    else
      sub_1001E460(SHIWORD(v4));
    if ( v10 )
      sub_1001E570(v5);
    else
      sub_1001E460(v5);
    if ( v8 )
      result = sub_1001E570(v6);
    else
      result = sub_1001E460(v6);
  }
  else
  {
    result = sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg.c", 1133, 0, 0);
  }
  return result;
}

//----- (10009F10) --------------------------------------------------------
char __cdecl sub_10009F10(char a1)
{
  void *v1; // ecx@1
  int v2; // eax@2
  char result; // al@2
  int v4; // [sp+8h] [bp-14h]@1
  int v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  int v7; // [sp+14h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( sub_100259F0(a1, &v4) )
  {
    v7 = sub_100206D0(v1);
    LOWORD(v6) = HIWORD(v4);
    v2 = sub_100258B0(a1);
    result = sub_1000D700(3, v2, &v6, 1, (int)&byte_10222BE0);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10009FB0) --------------------------------------------------------
char __cdecl sub_10009FB0(char a1, const void *a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+2h] [bp-6h]@2

  result = sub_100259F0(a1, &v4);
  if ( result )
  {
    v3 = sub_100181D0();
    result = sub_1000CE40(v5, 1, (int)&byte_10222BE0, a2, v3);
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10009FF0) --------------------------------------------------------
int __cdecl sub_10009FF0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = a1;
  byte_10120668[a1] = a2;
  return result;
}

//----- (1000A000) --------------------------------------------------------
char __cdecl sub_1000A000(char a1, char a2)
{
  char v2; // dl@1
  int v3; // eax@6
  void *v4; // ecx@6
  int v5; // eax@6
  int v6; // eax@7
  int v8; // [sp+4h] [bp-4h]@1

  v8 = 0;
  sub_10009FF0(a1, a2);
  switch ( v2 )
  {
    case 1:
      v8 = 2;
      goto LABEL_6;
    case 2:
      v8 = 3;
      goto LABEL_6;
    case 8:
      v8 = 4;
      goto LABEL_6;
    case 0x10:
      v8 = 5;
LABEL_6:
      v3 = sub_100181D0();
      sub_1000CE40(5, 1, (int)&byte_10222BE0, &v8, v3);
      v5 = sub_100206D0(v4);
      if ( v5 == 1 )
      {
        v6 = sub_100258B0(a1);
        LOBYTE(v5) = sub_1000D440(5, v6, (int)&byte_10222BE0);
      }
      break;
    default:
      LOBYTE(v5) = sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg.c", 1957, 0, 0);
      break;
  }
  return v5;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000A0E0) --------------------------------------------------------
char __cdecl sub_1000A0E0(const void *a1)
{
  char v1; // cl@0
  char result; // al@2
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  if ( sub_100259F0(v1, &v3) )
  {
    qmemcpy(&unk_1011FDD8, a1, 0x890u);
    sub_1000D700(v4, 0xFFFFFFF, (void *)a1, 1, (int)&byte_10222BE0);
    sub_1000C020(*(int *)((char *)&v3 + 2), (int)&byte_10222BE0);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000A160) --------------------------------------------------------
char __usercall sub_1000A160@<al>(const void *a1@<edi>, char a2)
{
  int v2; // eax@2
  char result; // al@2
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  if ( sub_100259F0(a2, &v4) )
  {
    v2 = sub_100181D0();
    sub_1000CE40(v5, 1, (int)&byte_10222BE0, a1, v2);
    sub_10002E20(a2, (int)a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000A1C0) --------------------------------------------------------
void __usercall sub_1000A1C0(int a1@<ecx>, char a2@<bl>)
{
  void *v2; // ecx@2
  unsigned __int8 v3; // al@3
  int v4; // [sp-2h] [bp-4h]@1

  v4 = a1;
  if ( (unsigned __int8)a2 < 3u )
  {
    sub_10021450(a2, (int)&unk_10120680);
    BYTE3(v4) = sub_1001FC80(v2);
    if ( byte_10120A70 == byte_10071341[2 * sub_1001E7B0((int *)((char *)&v4 + 3), 1u, (int)&unk_10071340, 2, 5, 4)]
      && (v3 = sub_10025900(a2), sub_10022EA0(v3)) )
    {
      *((_BYTE *)&word_1011FDD0 + (unsigned __int8)a2) = 1;
    }
    else
    {
      *((_BYTE *)&word_1011FDD0 + (unsigned __int8)a2) = 2;
    }
  }
}
// 1011FDD0: using guessed type __int16 word_1011FDD0;
// 10120A70: using guessed type char byte_10120A70;

//----- (1000A230) --------------------------------------------------------
char __usercall sub_1000A230@<al>(char a1@<bl>)
{
  unsigned int v1; // eax@1
  void *v2; // ecx@2
  int v3; // eax@6
  int v5; // [sp+0h] [bp-1Ch]@1
  int v6; // [sp+4h] [bp-18h]@1
  int v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  int v9; // [sp+14h] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v5 = 0;
  LOBYTE(v1) = sub_100259F0(a1, &v6);
  if ( (_BYTE)v1 )
  {
    if ( sub_1000DA50(*(int *)((char *)&v7 + 2), (int)&byte_10222BE0, &v5) == 1 )
    {
      v1 = sub_10009D00(a1);
      if ( v5 == v1 )
      {
        *((_BYTE *)&word_1011FDD0 + (unsigned __int8)a1) = 3;
      }
      else
      {
        LOBYTE(v1) = a1;
        *((_BYTE *)&word_1011FDD0 + (unsigned __int8)a1) = 2;
      }
    }
    else
    {
      v9 = sub_100206D0(v2);
      LOWORD(v8) = HIWORD(v7);
      v3 = sub_100258B0(a1);
      LOBYTE(v1) = sub_1000D700(3, v3, &v8, 1, (int)&byte_10222BE0);
    }
  }
  return v1;
}
// 1011FDD0: using guessed type __int16 word_1011FDD0;
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000A310) --------------------------------------------------------
char __cdecl sub_1000A310(char a1)
{
  char v1; // ST0C_1@1
  char v2; // bl@1
  char result; // al@4

  v1 = sub_10025830(a1);
  v2 = sub_10009F10(v1);
  if ( sub_10002E80() != 5 || sub_10002E60() != 1 )
  {
    sub_10002F90(3);
    result = v2;
  }
  else if ( v2 == 1 )
  {
    sub_10002F90(10);
    result = 1;
  }
  else
  {
    sub_10002EA0();
    if ( (unsigned int)sub_10002E70() <= 0xA )
    {
      sub_10002F90(4);
      byte_1011FDD3 = 2;
      dword_1012066C = sub_100181D0();
      result = v2;
    }
    else
    {
      sub_10002F90(8);
      result = v2;
    }
  }
  return result;
}
// 1011FDD3: using guessed type char byte_1011FDD3;
// 1012066C: using guessed type int dword_1012066C;

//----- (1000A3B0) --------------------------------------------------------
char __cdecl sub_1000A3B0(char a1, char a2)
{
  char v2; // bl@2
  char result; // al@6
  char v4; // [sp+8h] [bp-4h]@1

  v4 = sub_10025830(a1);
  if ( a2 )
  {
    v2 = sub_10009BF0(v4, (char *)&unk_10120680);
    if ( v2 )
      v2 = sub_1000A160(&unk_10120680, v4);
  }
  else
  {
    v2 = sub_1000A160(&unk_1011FDD8, v4);
  }
  if ( v2 == 1 )
  {
    sub_1000DC70();
    sub_10002F90(7);
    result = 1;
  }
  else
  {
    sub_10002F90(8);
    result = v2;
  }
  return result;
}

//----- (1000A440) --------------------------------------------------------
char __cdecl sub_1000A440(char a1)
{
  char v1; // bl@3
  unsigned int v2; // eax@4
  _DWORD *v3; // ecx@4
  _DWORD *v4; // edx@4
  int v5; // esi@8
  int v6; // eax@9
  _BYTE *v7; // ecx@9
  _BYTE *v8; // edx@9
  int v9; // eax@11
  _BYTE *v10; // ecx@11
  _BYTE *v11; // edx@11
  _BYTE *v12; // ecx@13
  _BYTE *v13; // edx@13
  signed int v14; // eax@15
  char result; // al@21
  char v16; // [sp+8h] [bp-4h]@1

  v16 = sub_10025830(a1);
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_10009FB0(v16, &unk_1011FDD8);
  v1 = sub_10009BF0(v16, (char *)&unk_10120680);
  if ( v1 != 1 )
    goto LABEL_20;
  v2 = 2192;
  v3 = &unk_1011FDD8;
  v4 = &unk_10120680;
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_17;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_18:
  if ( !v14 )
  {
    sub_10002F90(10);
    return 1;
  }
  v1 = 0;
LABEL_20:
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() <= 0xA )
  {
    sub_10002F90(1);
    result = v1;
  }
  else
  {
    sub_10002F90(8);
    result = v1;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1000A560) --------------------------------------------------------
char sub_1000A560()
{
  void *v0; // ecx@1
  char v1; // bl@1
  int *v2; // edi@1
  int v3; // esi@1
  char v4; // al@2
  int v5; // eax@4
  char v7; // [sp+10h] [bp-4h]@1

  memset(&unk_10120680, 0, 0x890u);
  v1 = 0;
  word_1011FDD0 = 0;
  byte_1011FDD2 = 0;
  v7 = 0;
  v2 = dword_10120670;
  v3 = 0;
  do
  {
    v4 = sub_1001FDE0(v0);
    byte_10120668[v3] = v4;
    if ( v4 == 4 )
      byte_10120668[v3] = 1;
    *v2 = 0;
    sub_10021450(v7, (int)&unk_10120680);
    v5 = j_HWM_pvg_read_reg(1);
    if ( v5 == 1 )
      LOBYTE(v5) = sub_10009FB0(v7, &unk_10120680);
    ++v1;
    byte_1011FDD4[v3] = 0;
    ++v2;
    ++v3;
    v7 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return v5;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011FDD0: using guessed type __int16 word_1011FDD0;
// 1011FDD2: using guessed type char byte_1011FDD2;
// 10120670: using guessed type int dword_10120670[];

//----- (1000A600) --------------------------------------------------------
char __cdecl sub_1000A600(int a1)
{
  char v1; // al@1
  char v2; // bl@1
  char v3; // di@1
  char result; // al@1
  void *v5; // ecx@2
  char v6; // al@3
  char v7; // al@10
  char v8; // [sp+Fh] [bp-19h]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v12 = 0;
  v13 = 0;
  v1 = sub_10025940(a1);
  v2 = v1;
  LOBYTE(v11) = v1;
  v3 = v1;
  result = sub_100259F0(v1, &v9);
  if ( result )
  {
    if ( sub_10009CA0(v3, &v8) == 1 )
      v6 = v8;
    else
      v6 = byte_10120668[(unsigned __int8)v2] == 0;
    if ( byte_10120668[(unsigned __int8)v2] != v6 )
    {
      if ( sub_1001FDE0(v5) == 2 )
      {
        if ( (unsigned int)dword_10120670[(unsigned __int8)v2] <= 3 )
        {
          sub_1000A000(v3, byte_10120668[(unsigned __int8)v2]);
          ++dword_10120670[(unsigned __int8)v2];
        }
      }
      else
      {
        sub_1000A000(v3, byte_10120668[(unsigned __int8)v2]);
      }
    }
    v7 = sub_10020560(v5);
    v13 = sub_10020160(v7);
    LOWORD(v12) = HIWORD(v10);
    sub_1000D700(3, a1, &v12, 1, (int)&byte_10222BE0);
    LOWORD(v12) = HIWORD(v9);
    result = sub_1000D700(3, a1, &v12, 1, (int)&byte_10222BE0);
  }
  return result;
}
// 10120670: using guessed type int dword_10120670[];
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000A730) --------------------------------------------------------
char __cdecl sub_1000A730(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // al@3
  _BYTE *v4; // eax@9
  char result; // al@13

  memset(&unk_10120680, 0, 0x890u);
  if ( a2 > 0x37u
    || a2 + 1 < 17
    || (v3 = *(_BYTE *)(a3 + 1), v3 >= 0x23u) && (v3 < 0x64u || v3 > 0x81u) && (v3 < 0x96u || v3 > 0x9Bu) )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg.c", 1467, 0, 0);
    result = 0;
  }
  else
  {
    sub_10021450(a1, (int)&unk_10120680);
    if ( *(_BYTE *)(a3 + 1) )
    {
      v4 = &unk_10120681;
      do
      {
        if ( *v4 == *(_BYTE *)(a3 + 1) )
        {
          *v4 = 0;
          *(v4 - 1) = 0;
        }
        v4 += 4;
      }
      while ( (signed int)v4 < (signed int)&unk_10120721 );
    }
    byte_10120641[4 * a2] = *(_BYTE *)(a3 + 1);
    byte_10120640[4 * a2] = *(_BYTE *)a3;
    sub_1000A0E0(&unk_10120680);
    result = 1;
  }
  return result;
}

//----- (1000A800) --------------------------------------------------------
char __cdecl sub_1000A800(char a1, const void *a2)
{
  return sub_1000A0E0(a2);
}

//----- (1000A820) --------------------------------------------------------
char __cdecl sub_1000A820(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  char *v4; // eax@3

  memset(&unk_10120680, 0, 0x890u);
  result = 0;
  if ( a2 < 0x2Du && *(_WORD *)(a3 + 2) < 0x319u )
  {
    sub_10021450(a1, (int)&unk_10120680);
    v4 = (char *)&unk_10120720 + 16 * a2;
    *(_DWORD *)v4 = *(_DWORD *)a3;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 4);
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a3 + 8);
    *((_DWORD *)v4 + 3) = *(_DWORD *)(a3 + 12);
    sub_1000A0E0(&unk_10120680);
    result = 1;
  }
  return result;
}

//----- (1000A8A0) --------------------------------------------------------
char __cdecl sub_1000A8A0(char a1, char *a2)
{
  char result; // al@1

  memset(&unk_10120680, 0, 0x890u);
  result = 0;
  if ( (unsigned __int8)a1 < 3u && (unsigned __int8)*a2 < 4u )
  {
    sub_10021450(a1, (int)&unk_10120680);
    byte_10120A70 = *a2;
    sub_1000A0E0(&unk_10120680);
    result = 1;
  }
  return result;
}
// 10120A70: using guessed type char byte_10120A70;

//----- (1000A8F0) --------------------------------------------------------
char __cdecl sub_1000A8F0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  unsigned __int8 v4; // al@5
  int v5; // ecx@5
  int v6; // ebp@5
  char v7; // dl@6
  char v8; // al@13
  char v9; // al@14
  char v10; // cl@18
  char v11; // bl@26
  char *v12; // eax@33
  char v13; // [sp+12h] [bp-Eh]@1
  int v14; // [sp+14h] [bp-Ch]@5

  memset(&unk_10120680, 0, 0x890u);
  result = 0;
  v13 = 4;
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x10u || *(_BYTE *)a3 >= 2u || *(_BYTE *)(a3 + 1) >= 0x21u )
    return result;
  sub_10021450(a1, (int)&unk_10120680);
  v4 = *(_BYTE *)(a3 + 1);
  v5 = dword_101209F0[2 * a2];
  v6 = dword_101209F4[2 * a2];
  v14 = dword_101209F0[2 * a2];
  if ( v4 || (v7 = *(_BYTE *)a3) == 0 && (unsigned __int8)v5 >= 0x21u || v7 == 1 && BYTE1(v5) >= 0x21u )
  {
    v9 = sub_10025C30(v4);
    goto LABEL_16;
  }
  if ( !v7 )
  {
    v9 = sub_10025C30(v5);
LABEL_16:
    v13 = v9;
    goto LABEL_17;
  }
  if ( v7 != 1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg.c", 1709, 1, 0);
LABEL_17:
    v8 = v13;
    goto LABEL_18;
  }
  v8 = sub_10025C30(BYTE1(v14));
LABEL_18:
  v10 = *(_BYTE *)a3;
  if ( *(_BYTE *)a3 && v10 != 1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg.c", 1726, 0, 0);
    result = 0;
  }
  else
  {
    if ( !v8 || v8 == 2 )
      LOBYTE(v14) = *(_BYTE *)(a3 + 1);
    if ( v8 != 1 && v8 != 2 )
    {
      v11 = BYTE1(v14);
    }
    else
    {
      v11 = *(_BYTE *)(a3 + 1);
      BYTE1(v14) = *(_BYTE *)(a3 + 1);
    }
    if ( v8 == 3 )
    {
      if ( v10 )
      {
        v11 = *(_BYTE *)(a3 + 1);
        BYTE1(v14) = *(_BYTE *)(a3 + 1);
      }
      else
      {
        LOBYTE(v14) = *(_BYTE *)(a3 + 1);
      }
    }
    BYTE2(v14) = sub_10025C00(*(_BYTE *)(a3 + 1));
    BYTE3(v14) = sub_10025C60(*(_BYTE *)(a3 + 1));
    if ( *(_BYTE *)(a3 + 1) )
    {
      v12 = (char *)dword_101209F0 + 1;
      do
      {
        if ( *(v12 - 1) == (_BYTE)v14 )
          *(v12 - 1) = 0;
        if ( *v12 == v11 )
          *v12 = 0;
        v12 += 8;
      }
      while ( (signed int)v12 < (signed int)&unk_10120A71 );
    }
    dword_101209F0[2 * a2] = v14;
    dword_101209F4[2 * a2] = v6;
    sub_1000A0E0(&unk_10120680);
    result = 1;
  }
  return result;
}
// 101209F0: using guessed type int dword_101209F0[];
// 101209F4: using guessed type int dword_101209F4[];

//----- (1000AAF0) --------------------------------------------------------
void __cdecl sub_1000AAF0(char a1)
{
  char v1; // bl@1
  int v2; // edi@2
  void *v3; // ecx@2
  void *v4; // ecx@3
  int v5; // ecx@7
  int v6; // [sp+10h] [bp-Ch]@1
  int v7; // [sp+14h] [bp-8h]@1
  __int16 v8; // [sp+18h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v1 = sub_10025830(a1);
  if ( sub_10025990(v1, &v6) )
  {
    v2 = sub_100258B0(v1);
    if ( (v2 & sub_1001FDC0(v3)) == v2 )
    {
      if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2 )
      {
        if ( !byte_1011FDD4[(unsigned __int8)v1] )
        {
          sub_1000A600(v2);
          byte_1011FDD4[(unsigned __int8)v1] = 1;
        }
        if ( *((_BYTE *)&word_1011FDD0 + (unsigned __int8)v1) < 3u && sub_1001F430(v4) )
        {
          if ( *((_BYTE *)&word_1011FDD0 + (unsigned __int8)v1) )
            sub_1000A230(v1);
          else
            sub_1000A1C0(v5, v1);
          if ( *((_BYTE *)&word_1011FDD0 + (unsigned __int8)v1) == 2 )
          {
            sub_1001E570(HIWORD(v7));
            sub_10003F20(a1, 0);
            *((_BYTE *)&word_1011FDD0 + (unsigned __int8)v1) = 3;
          }
        }
      }
      else
      {
        byte_1011FDD4[(unsigned __int8)v1] = 0;
      }
    }
  }
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1011FDD0: using guessed type __int16 word_1011FDD0;

//----- (1000ABE0) --------------------------------------------------------
char __cdecl sub_1000ABE0(char a1, int a2, char a3, unsigned __int8 *a4, char *a5, int a6)
{
  char v6; // bl@1
  char v7; // al@2
  char result; // al@10
  char v9; // [sp+4h] [bp-4h]@1

  memset(&unk_10120680, 0, 0x890u);
  v6 = 0;
  v9 = sub_10025830(a1);
  switch ( a3 )
  {
    case 2:
      v7 = sub_1000A730(v9, *a4, (int)a5);
      goto LABEL_9;
    case 3:
      v7 = sub_1000A820(v9, *a4, (int)a5);
      goto LABEL_9;
    case 0xD:
      v7 = sub_1000A8F0(v9, *a4, (int)a5);
      goto LABEL_9;
    case 0x17:
      v7 = sub_1000A8A0(v9, a5);
      goto LABEL_9;
    case 0xB:
      if ( a6 )
      {
        v7 = sub_1000A800(v9, a5);
      }
      else
      {
        sub_10021450(v9, (int)&unk_10120680);
        v7 = sub_1000A800(v9, &unk_10120680);
      }
LABEL_9:
      v6 = v7;
      if ( v7 != 1 )
        goto LABEL_11;
      sub_10002F90(4);
      byte_1011FDD3 = 3;
      dword_1012066C = sub_100181D0();
      result = v6;
      break;
    default:
LABEL_11:
      sub_10002F90(8);
      result = v6;
      break;
  }
  return result;
}
// 1011FDD3: using guessed type char byte_1011FDD3;
// 1012066C: using guessed type int dword_1012066C;

//----- (1000AD30) --------------------------------------------------------
char __cdecl sub_1000AD30(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@2
  char v3; // di@2
  char v4; // bl@4
  char v6; // [sp+6h] [bp-6h]@1
  char v7; // [sp+7h] [bp-5h]@1
  int v8; // [sp+8h] [bp-4h]@2

  v6 = 0;
  v7 = 0;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    v2 = sub_1001FDE0(v1);
    LOBYTE(v8) = v2;
    v3 = sub_10025940(a1);
    if ( sub_10009CA0(v3, &v6) == 1 )
    {
      if ( v6 != v2 )
      {
        v4 = v8;
        sub_10009FF0(v3, v8);
        sub_1000A000(v3, v4);
        sub_1000DD40(a1);
        return v7;
      }
      v7 = 1;
    }
  }
  sub_1000DD40(a1);
  return v7;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000ADD0) --------------------------------------------------------
char __cdecl sub_1000ADD0(int a1, char a2, int a3, __int16 a4)
{
  int v4; // esi@1
  void *v5; // ecx@1
  char v6; // si@5
  char result; // al@7
  char v8; // [sp+Bh] [bp-5h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@5
  char v10; // [sp+14h] [bp+4h]@2

  v4 = a1;
  v8 = 0;
  sub_1000DC80(a1);
  if ( (v4 & j_HWM_pvg_hsdb_get_lrus_online()) == v4 )
  {
    v10 = sub_1001FDE0(v5);
    if ( !a2 && a4 != 74 )
      v10 = 16;
    LOBYTE(v9) = sub_10025940(v4);
    v6 = v9;
    sub_10009FF0(v9, v10);
    if ( sub_10009CA0(v9, &v8) )
    {
      if ( v8 == v10 )
        return 1;
      sub_1000A000(v6, v10);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000AE70) --------------------------------------------------------
char __cdecl sub_1000AE70(int a1)
{
  char result; // al@1
  unsigned int v2; // [sp+8h] [bp-4h]@1

  v2 = 0;
  result = sub_1000F100(0, a1, &v2);
  if ( result )
  {
    if ( (_WORD)a1 == 491 )
    {
      result = sub_10025E40(v2, 6);
    }
    else if ( (_WORD)a1 == 589 )
    {
      result = sub_10025E40(v2, 7);
    }
    else
    {
      result = sub_10025E40(v2, (_WORD)a1 != 590 ? 5 : 8);
    }
  }
  return result;
}

//----- (1000AEE0) --------------------------------------------------------
char __cdecl sub_1000AEE0(char a1, int a2, int a3, int a4, char a5, int a6)
{
  char v6; // bl@1
  char v7; // al@2

  v6 = 0;
  switch ( a5 )
  {
    case 5:
      v6 = 1;
      v7 = sub_10025E60(a1);
      sub_1001F8F0(byte_10120F18, 0x64u, "LOADING GTX %d CONFIG DATA", (unsigned __int8)v7 + 1);
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      v6 = 1;
      break;
    case 0:
    case 7:
      v6 = 1;
      goto LABEL_5;
    default:
LABEL_5:
      sub_1001F7C0((int)byte_10120F18, &byte_10065A71, 100);
      break;
  }
  sub_1001F7C0(a6, byte_10120F18, 100);
  return v6;
}

//----- (1000AF70) --------------------------------------------------------
char sub_1000AF70()
{
  char v0; // bl@1
  __int16 *v1; // esi@1
  char result; // al@2
  char v3; // [sp+8h] [bp-4h]@1

  v0 = 0;
  byte_10120F12 = 0;
  dword_10120F7C = 0;
  word_10120F10 = 0;
  memset(&unk_10120F80, 0, 0x80u);
  memset(byte_10120F18, 0, 0x64u);
  v3 = 0;
  v1 = &word_10120F10;
  do
  {
    result = sub_1001C2F0(v3);
    if ( !result )
      *(_BYTE *)v1 = 1;
    ++v0;
    v1 = (__int16 *)((char *)v1 + 1);
    v3 = v0;
  }
  while ( (unsigned __int8)v0 < 2u );
  return result;
}
// 10120F10: using guessed type __int16 word_10120F10;
// 10120F12: using guessed type char byte_10120F12;
// 10120F7C: using guessed type int dword_10120F7C;

//----- (1000AFE0) --------------------------------------------------------
char __cdecl sub_1000AFE0(void *a1)
{
  char result; // al@1
  void *v2; // ecx@1
  int v3; // esi@2
  char v4; // [sp+4h] [bp-4h]@1

  result = sub_10025E60((char)a1);
  v4 = result;
  if ( (unsigned __int8)result < 2u )
  {
    v3 = (unsigned __int8)result;
    if ( !*((_BYTE *)&word_10120F10 + (unsigned __int8)result) )
    {
      result = sub_1001F430(v2);
      if ( result )
      {
        result = sub_10025FC0(a1);
        if ( !result )
        {
          sub_10003F20((unsigned __int8)a1, 0);
          result = sub_1001B330(v4);
        }
        *((_BYTE *)&word_10120F10 + v3) = 1;
      }
    }
  }
  return result;
}
// 10120F10: using guessed type __int16 word_10120F10;

//----- (1000B040) --------------------------------------------------------
char sub_1000B040()
{
  if ( j_HWM_pvg_read_reg(1) || (unsigned int)(sub_100181D0() - dword_10120F7C) > 0x1F4 )
    sub_10002F90((unsigned __int8)byte_10120F12);
  return 1;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10120F12: using guessed type char byte_10120F12;
// 10120F7C: using guessed type int dword_10120F7C;

//----- (1000B080) --------------------------------------------------------
BOOL __usercall sub_1000B080@<eax>(char a1@<al>, _BYTE *a2@<ecx>, unsigned __int8 a3)
{
  return a3 < 2u && *a2 < 3u && (a1 == 11 || a1 == 28 || a1 == 24 || a1 == 18 || a1 == 17);
}

//----- (1000B0B0) --------------------------------------------------------
char __cdecl sub_1000B0B0(char a1, char a2, _BYTE *a3)
{
  unsigned __int8 v3; // ST1C_1@1
  char v4; // bl@1
  unsigned __int8 v5; // dl@1
  int v6; // ST10_4@3
  unsigned __int8 v7; // al@3
  __int16 v9; // [sp+Ch] [bp-Ch]@3
  __int16 v10; // [sp+Eh] [bp-Ah]@3
  __int16 v11; // [sp+10h] [bp-8h]@3

  v3 = sub_10025E60(a1);
  v4 = 0;
  if ( (unsigned __int8)sub_1000B080(a2, a3, v3) && a2 == 17 )
  {
    v6 = dword_100721D8[v5];
    v4 = 1;
    v9 = 64;
    v10 = 62;
    v11 = 65;
    v7 = sub_10003BA0(a1);
    sub_100207C0(v7, 3u, (int)&v9, v6);
    byte_10120F12 = 3;
    dword_10120F7C = sub_100181D0();
    sub_10002F90(4);
  }
  return v4;
}
// 100721D8: using guessed type int dword_100721D8[];
// 10120F12: using guessed type char byte_10120F12;
// 10120F7C: using guessed type int dword_10120F7C;

//----- (1000B160) --------------------------------------------------------
char __cdecl sub_1000B160(char a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  unsigned __int8 v6; // al@1
  unsigned __int8 *v7; // esi@1
  char v8; // bl@1
  char v9; // dl@1
  size_t v10; // edi@2
  unsigned __int8 v11; // dl@6
  unsigned int v12; // eax@10
  unsigned int v13; // ST28_4@10
  __int16 v14; // ST20_2@10
  char v15; // al@10
  __int16 v16; // ST20_2@13
  char v17; // al@13
  char *v18; // ST18_4@13
  char *v19; // ST2C_4@14
  char *v20; // ST2C_4@15
  size_t v21; // ST2C_4@20
  char v22; // ST20_1@20
  char v23; // al@20
  int v25; // [sp+Ch] [bp-Ch]@2
  int v26; // [sp+10h] [bp-8h]@1
  int v27; // [sp+14h] [bp-4h]@1

  v6 = sub_10025E60(a1);
  v7 = (unsigned __int8 *)a4;
  LOBYTE(v26) = v6;
  LOBYTE(v27) = 8;
  v8 = 0;
  if ( (unsigned __int8)sub_1000B080(a3, (_BYTE *)a4, v6) )
  {
    v10 = a6;
    LOBYTE(v25) = 3;
    if ( v9 == 11 )
    {
      if ( a6 )
        LOBYTE(v25) = *v7;
    }
    else
    {
      LOBYTE(v25) = sub_1001E7B0(&a3, 1u, (int)&unk_100721A8, 16, 3, 3);
    }
    v11 = *v7;
    if ( (_BYTE)v25 != *v7 || v10 != (unsigned __int16)word_100721B0[8 * v11] || (unsigned int)a5 >= 0xFFFFFFC2 || !a5 )
    {
      if ( (_BYTE)v25 == 3 )
        LOBYTE(v25) = 0;
      if ( v10 )
      {
        if ( (unsigned int)a5 >= 0xFFFFFFC2 || !a5 || v10 != (unsigned __int16)word_100721B0[8 * (unsigned __int8)v25] )
          goto LABEL_21;
        memcpy(&unk_10120F80, a5, (unsigned __int16)word_100721B0[8 * v11]);
        v8 = 1;
      }
      else
      {
        v8 = sub_10021CE0(v26, dword_100721AC[4 * (unsigned __int8)v25], (unsigned int)&unk_10120F80);
        if ( !v8 )
          goto LABEL_21;
      }
      v21 = (unsigned __int16)word_100721B0[8 * (unsigned __int8)v25];
      v22 = a3;
      v23 = sub_10002E80();
      sub_10002EE0(v23, a1, a2, v22, (int)&v25, &unk_10120F80, v21);
      sub_1001F8F0(
        byte_10120F18,
        0x64u,
        "PREPARINING GTX %d %s CONFIG UPLOAD",
        (unsigned __int8)v26 + 1,
        off_100721B4[4 * (unsigned __int8)v25]);
      LOBYTE(v27) = 1;
      goto LABEL_21;
    }
    memcpy(&unk_10120F80, a5, v10);
    v12 = 16 * *v7;
    v13 = (unsigned __int16)word_100721B0[v12 / 2];
    v14 = dword_100721AC[v12 / 4];
    v15 = sub_10003BA0(a1);
    v8 = sub_10026220(v15, v14, (unsigned int *)&unk_10120F80, v13, 1);
    if ( !v8 )
      goto LABEL_28;
    if ( a2 == 1 || j_HWM_pvg_read_reg(1) )
    {
      v20 = (char *)off_100721B4[4 * *v7];
      v8 = 1;
      LOBYTE(v27) = 10;
      sub_1001F8F0(byte_10120F18, 0x64u, "STORING GTX %d %s CONFIG", (unsigned __int8)v26 + 1, v20);
      goto LABEL_21;
    }
    v16 = dword_100721AC[4 * *v7];
    v17 = sub_10003BA0(a1);
    v8 = sub_10026280(v17, v16, (unsigned int)&unk_10120F80, v10, 1000);
    v18 = (char *)off_100721B4[4 * *v7];
    LOBYTE(v27) = 11;
    sub_1001F8F0(byte_10120F18, 0x64u, "UPLOADING GTX %d %s CONFIG", (unsigned __int8)v26 + 1, v18);
    if ( !v8 )
    {
LABEL_28:
      v19 = (char *)off_100721B4[4 * *v7];
      LOBYTE(v27) = 8;
      sub_1001F8F0(
        byte_10120F18,
        0x64u,
        "FAILED: UNABLE TO START GTX %d %s CONFIG UPLOAD",
        (unsigned __int8)v26 + 1,
        v19);
    }
  }
LABEL_21:
  sub_10002F90(v27);
  return v8;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100721AC: using guessed type int dword_100721AC[];
// 100721B0: using guessed type __int16 word_100721B0[];

//----- (1000B430) --------------------------------------------------------
bool __cdecl sub_1000B430(char a1, char a2, char a3, _BYTE *a4)
{
  bool v4; // bl@1
  char v5; // dl@1
  size_t v6; // ST30_4@6
  char v7; // al@6
  bool result; // al@6
  int v9; // [sp+10h] [bp-8h]@5
  int v10; // [sp+14h] [bp-4h]@1

  LOBYTE(v10) = sub_10025E60(a1);
  v4 = 0;
  if ( (unsigned __int8)sub_1000B080(a3, a4, v10)
    && v5 != 17
    && (v4 = sub_10021DF0(v10, dword_100721AC[4 * *a4], &unk_10120F80)) != 0 )
  {
    if ( a3 != 11 || (LOBYTE(v9) = *a4 + 1, (unsigned __int8)v9 >= 3u) )
    {
      if ( a2 == 1 || j_HWM_pvg_read_reg(1) )
      {
        sub_10002F90(7);
        result = v4;
      }
      else
      {
        sub_10002F90(2);
        sub_10002EE0(7, a1, a2, 17, 0, 0, 0);
        sub_1001F8F0(byte_10120F18, 0x64u, "REQUESTING GTX %d CONFIG CRC DATA", (unsigned __int8)v10 + 1);
        sub_10002E50();
        result = v4;
      }
    }
    else
    {
      sub_10021CE0(v10, dword_100721AC[4 * (unsigned __int8)v9], (unsigned int)&unk_10120F80);
      v6 = (unsigned __int16)word_100721B0[8 * (unsigned __int8)v9];
      v7 = sub_10002E80();
      sub_10002EE0(v7, a1, a2, 11, (int)&v9, &unk_10120F80, v6);
      sub_1001F8F0(
        byte_10120F18,
        0x64u,
        "PREPARINING GTX %d %s CONFIG UPLOAD",
        (unsigned __int8)v10 + 1,
        off_100721B4[4 * (unsigned __int8)v9]);
      sub_10002F90(1);
      result = v4;
    }
  }
  else
  {
    sub_10002F90(8);
    sub_1001F8F0(byte_10120F18, 0x64u, "UNABLE TO STORE GTX %d CONFIGURATION", (unsigned __int8)v10 + 1);
    result = v4;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100721AC: using guessed type int dword_100721AC[];
// 100721B0: using guessed type __int16 word_100721B0[];

//----- (1000B5E0) --------------------------------------------------------
char __cdecl sub_1000B5E0(char a1, int a2, char a3, _BYTE *a4)
{
  unsigned __int8 v4; // bl@1
  char result; // al@2
  int v6; // ST10_4@6
  int v7; // ST10_4@7
  int v8; // ST10_4@8
  char v9; // [sp+Ah] [bp-6h]@1
  char v10; // [sp+Bh] [bp-5h]@2
  int v11; // [sp+Ch] [bp-4h]@1

  v4 = sub_10025E60(a1);
  LOBYTE(v11) = v4;
  v9 = 0;
  if ( (unsigned __int8)sub_1000B080(a3, a4, v4) )
  {
    result = sub_1001D150(&v10);
    v9 = result;
    if ( !result )
      return result;
    if ( v10 == 5 )
    {
      v8 = off_100721B4[4 * *a4];
      LOBYTE(v11) = 9;
      sub_1001F8F0(byte_10120F18, 0x64u, "GTX %d %s CONFIG UPLOAD CANCELED", v4 + 1, v8);
    }
    else if ( v10 == 6 )
    {
      v7 = off_100721B4[4 * *a4];
      LOBYTE(v11) = 10;
      sub_1001F8F0(byte_10120F18, 0x64u, "STORING GTX %d %s CONFIG", v4 + 1, v7);
    }
    else
    {
      if ( v10 != 7 )
        return result;
      v6 = off_100721B4[4 * *a4];
      LOBYTE(v11) = 8;
      sub_1001F8F0(byte_10120F18, 0x64u, "GTX %d %s CONFIG UPLOAD FAILED", v4 + 1, v6);
    }
  }
  else
  {
    LOBYTE(v11) = 8;
    sub_1001F7C0((int)byte_10120F18, "GTX CONFIG UPLOAD FAILED", 100);
  }
  sub_10002F90(v11);
  sub_10026200();
  return v9;
}

//----- (1000B710) --------------------------------------------------------
char __cdecl sub_1000B710(char a1, char a2, _BYTE *a3)
{
  signed int v3; // edi@1
  char v4; // dl@1
  unsigned __int8 v5; // al@3
  signed int v6; // edx@3
  int *v7; // esi@4
  signed int v8; // eax@5
  char *v9; // ecx@6
  unsigned __int8 v11; // [sp+10h] [bp-2D8h]@1
  char v12[2]; // [sp+14h] [bp-2D4h]@3
  char v13; // [sp+16h] [bp-2D2h]@6

  v11 = sub_10025E60(a1);
  v3 = 3;
  if ( (unsigned __int8)sub_1000B080(a2, a3, v11) )
  {
    if ( v4 == 17 )
    {
      v5 = sub_10003BA0(a1);
      v6 = sub_10020910(v5, (int)v12, 6u);
      if ( v6 >= 3 )
      {
        v3 = 0;
        v7 = dword_100721AC;
        while ( 1 )
        {
          v8 = 0;
          if ( v6 > 0 )
          {
            v9 = &v13;
            while ( *v7 != *(_WORD *)v9 )
            {
              ++v8;
              v9 += 120;
              if ( v8 >= v6 )
                goto LABEL_11;
            }
            if ( v12[120 * v8] != 3 )
              break;
          }
LABEL_11:
          if ( v8 >= v6 )
            break;
          v7 += 4;
          ++v3;
          if ( (signed int)v7 >= (signed int)&unk_100721DC )
          {
            sub_10002F90(7);
            return 1;
          }
        }
      }
    }
  }
  sub_10002EA0();
  if ( (unsigned int)sub_10002E70() <= 0x14 )
  {
    sub_1001F8F0(byte_10120F18, 0x64u, "REQUESTING GTX %d CONFIG CRC DATA", v11 + 1);
    sub_10002F90(2);
  }
  else if ( v3 >= 3 )
  {
    sub_1001F8F0(byte_10120F18, 0x64u, "FAILED: UNABLE TO VERIFY GTX %d CONFIG CRC DATA", v11 + 1);
    sub_10002F90(8);
  }
  else
  {
    sub_1001F8F0(byte_10120F18, 0x64u, "FAILED: UNABLE TO VERIFY GTX %d %s CONFIG CRC", v11 + 1, off_100721B4[4 * v3]);
    sub_10002F90(8);
  }
  return 0;
}
// 100721AC: using guessed type int dword_100721AC[];
// 1000B710: using guessed type char var_2D4[2];

//----- (1000B8E0) --------------------------------------------------------
void __cdecl sub_1000B8E0(__int16 a1)
{
  switch ( a1 )
  {
    case 0x1A2:
    case 0x1A3:
      sub_1001B460(0);
      break;
    case 0x1A5:
    case 0x1A6:
      sub_1001B460(1u);
      break;
    default:
      return;
  }
}

//----- (1000B920) --------------------------------------------------------
bool sub_1000B920()
{
  int v0; // esi@1
  void *v1; // ecx@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  unsigned __int8 v5; // cl@1

  v0 = j_HWM_pvg_hsdb_get_lrus_online();
  v2 = sub_1001FDC0(v1);
  v4 = sub_100206D0(v3);
  v5 = 0;
  while ( !((v0 | v4) & dword_10072BB0[v5] & v2) )
  {
    if ( ++v5 >= 3u )
      return 1;
  }
  return v4 == dword_10072BB0[v5];
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10072BB0: using guessed type int dword_10072BB0[];

//----- (1000B980) --------------------------------------------------------
signed int __cdecl sub_1000B980(unsigned __int8 a1)
{
  signed int result; // eax@5

  if ( sub_1001FCE0(30000)
    || !sub_1000B920()
    || (unsigned int)(sub_1001DB30() - dword_10121000) < 0x3E8
    || !BYTE2(dword_10121004)
    || (result = 1, !(dword_10121020 & 1))
    || !*((_BYTE *)&dword_10121004 + a1) )
  {
    result = 0;
  }
  return result;
}
// 1001DB30: using guessed type int sub_1001DB30(void);
// 10121000: using guessed type int dword_10121000;
// 10121004: using guessed type int dword_10121004;
// 10121020: using guessed type int dword_10121020;

//----- (1000B9E0) --------------------------------------------------------
char __usercall sub_1000B9E0@<al>(int a1@<ecx>, __int16 a2@<di>, int a3)
{
  char v3; // bl@1
  __int16 v4; // ax@8
  void *v5; // esi@10
  signed int v6; // ebx@10
  __int16 v7; // cx@11
  char v8; // al@12
  bool v10; // [sp+7h] [bp-5h]@12
  int v11; // [sp+8h] [bp-4h]@1

  v3 = sub_1001C0E0(a1);
  LOBYTE(v11) = v3;
  if ( v3 != BYTE3(dword_10121004) )
  {
    BYTE3(dword_10121004) = v3;
    LOWORD(dword_10121004) = 0;
    BYTE2(dword_10121004) = 0;
  }
  if ( !sub_1001FCE0(30000)
    && sub_1000B920()
    && (unsigned int)(sub_1001DB30() - dword_10121000) >= 0x3E8
    && (~(_BYTE)a2 & 1) == ((_BYTE)a3 == v3) )
  {
    sub_1001CDE0(v11);
  }
  LOBYTE(v4) = a3;
  if ( (_BYTE)a3 == BYTE3(dword_10121004) )
  {
    BYTE2(dword_10121004) = 1;
    LOWORD(dword_10121020) = a2;
  }
  else
  {
    LOBYTE(v4) = sub_1000B980(2u);
    if ( (_BYTE)v4 )
    {
      v5 = &unk_10072BA0;
      v6 = 4;
      do
      {
        v7 = dword_10121020 & *(_WORD *)v5;
        v4 = a2 & *(_WORD *)v5;
        if ( v4 != v7 )
        {
          v8 = *((_BYTE *)v5 + 2);
          v10 = v7 != 0;
          LOBYTE(v4) = sub_10021F50(a3, v8, &v10);
        }
        v5 = (char *)v5 + 4;
        --v6;
      }
      while ( v6 );
    }
  }
  return v4;
}
// 1001DB30: using guessed type int sub_1001DB30(void);
// 10121000: using guessed type int dword_10121000;
// 10121004: using guessed type int dword_10121004;
// 10121020: using guessed type int dword_10121020;

//----- (1000BAE0) --------------------------------------------------------
char __usercall sub_1000BAE0@<al>(char a1@<bl>, const char *a2@<esi>)
{
  int v2; // eax@2

  if ( a1 == BYTE3(dword_10121004) )
  {
    LOBYTE(dword_10121004) = 1;
    LOBYTE(v2) = (unsigned int)strncpy(dword_10121008, a2, 0xCu);
  }
  else
  {
    LOBYTE(v2) = sub_1000B980(0);
    if ( (_BYTE)v2 )
    {
      v2 = strncmp(dword_10121008, a2, 0xCu);
      if ( v2 )
        LOBYTE(v2) = sub_10021F50(a1, 4, dword_10121008);
    }
  }
  return v2;
}
// 10121004: using guessed type int dword_10121004;

//----- (1000BB40) --------------------------------------------------------
char __usercall sub_1000BB40@<al>(char a1@<bl>, int a2@<esi>)
{
  int v2; // eax@2

  if ( a1 == BYTE3(dword_10121004) )
  {
    BYTE1(dword_10121004) = 1;
    dword_10121014 = *(_DWORD *)a2;
    dword_10121018 = *(_DWORD *)(a2 + 4);
    v2 = *(_DWORD *)(a2 + 8);
    dword_1012101C = *(_DWORD *)(a2 + 8);
  }
  else
  {
    LOBYTE(v2) = sub_1000B980(1u);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = BYTE2(dword_10121014);
      if ( HIWORD(dword_10121014) != *(_WORD *)(a2 + 2) )
        LOBYTE(v2) = sub_10021F50(a1, 3, (char *)&dword_10121014 + 2);
    }
  }
  return v2;
}
// 10121004: using guessed type int dword_10121004;
// 10121014: using guessed type int dword_10121014;
// 10121018: using guessed type int dword_10121018;
// 1012101C: using guessed type int dword_1012101C;

//----- (1000BBA0) --------------------------------------------------------
void __cdecl sub_1000BBA0(int a1)
{
  int v1; // ecx@0
  char v2; // bl@1
  int v3; // [sp+Ch] [bp-14h]@0
  int v4; // [sp+10h] [bp-10h]@2

  v2 = 0;
  LOBYTE(v3) = 2;
  switch ( (unsigned __int16)a1 )
  {
    case 0x1A2u:
    case 0x1A3u:
    case 0x1A4u:
      v2 = sub_1000F100(0, a1, &v4);
      LOBYTE(v3) = 0;
      break;
    case 0x1A5u:
    case 0x1A6u:
    case 0x1A7u:
      v2 = sub_1000F100(0, a1, &v4);
      LOBYTE(v3) = 1;
      break;
    case 0x1A1u:
      dword_10121000 = sub_1001DB30();
      LOWORD(dword_10121004) = 0;
      BYTE2(dword_10121004) = 0;
      break;
    default:
      v2 = 0;
      break;
  }
  if ( (_WORD)a1 != 417 )
    sub_1001B460(v3);
  if ( v2 )
  {
    switch ( (unsigned __int16)a1 )
    {
      case 0x1A2u:
      case 0x1A5u:
        sub_1000B9E0(v1, v4, v3);
        break;
      case 0x1A3u:
      case 0x1A6u:
        sub_1000BB40(v3, (int)&v4);
        break;
      case 0x1A4u:
      case 0x1A7u:
        sub_1000BAE0(v3, (const char *)&v4);
        break;
      default:
        return;
    }
  }
}
// 1001DB30: using guessed type int sub_1001DB30(void);
// 10121000: using guessed type int dword_10121000;
// 10121004: using guessed type int dword_10121004;

//----- (1000BCE0) --------------------------------------------------------
signed __int16 __usercall sub_1000BCE0@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 result; // ax@2

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a2 + 4) )
    result = -1;
  else
    result = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * a1);
  return result;
}

//----- (1000BD00) --------------------------------------------------------
int __usercall sub_1000BD00@<eax>(int a1@<esi>, signed int a2)
{
  int v2; // edx@1
  char v3; // cl@1
  int v4; // ebp@1
  signed int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@2
  int v8; // ecx@3
  bool v9; // zf@3
  int v10; // edi@5
  signed int v11; // ebx@5
  int v12; // ebp@8
  int v13; // edx@9
  int v14; // eax@11
  __int16 v15; // cx@11
  char v16; // dl@11
  int v17; // edx@11
  int v18; // eax@11
  int v19; // ecx@11
  unsigned int v20; // eax@15
  int v21; // ecx@15
  char v23; // [sp+7h] [bp-29h]@5
  int v24; // [sp+8h] [bp-28h]@1
  int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@8
  int v27; // [sp+14h] [bp-1Ch]@3
  int v28; // [sp+18h] [bp-18h]@3
  int v29; // [sp+1Ch] [bp-14h]@1
  char v30; // [sp+20h] [bp-10h]@1
  char v31; // [sp+21h] [bp-Fh]@1
  __int16 v32; // [sp+22h] [bp-Eh]@16
  int v33; // [sp+24h] [bp-Ch]@11
  int v34; // [sp+28h] [bp-8h]@11

  v2 = *(_DWORD *)(a1 + 60);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = ~*(_DWORD *)(a1 + 72);
  v29 = *(_DWORD *)(a1 + 16);
  v30 = v3;
  v31 = 1;
  v25 = v4;
  sub_100182A0(v2, -1);
  v5 = a2;
  v6 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a1 + 48);
      if ( *(_BYTE *)(v7 + 20 * v6) != 1 )
      {
        v8 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v9 = *(_BYTE *)(a1 + 1) == 6;
        v27 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v28 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        if ( v9 || !(v8 & *(_DWORD *)(a1 + 84)) )
        {
          v23 = 1;
          v10 = *(_DWORD *)(a1 + 16) + 12;
          v11 = 12;
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 16);
          v23 = 0;
          v11 = 0;
        }
        if ( v6 < v5 )
        {
          v12 = 20 * v6;
          v26 = v5 - v6;
          do
          {
            v13 = *(_DWORD *)(a1 + 48);
            if ( !*(_BYTE *)(v13 + v12) && v8 == (v25 & (*(_DWORD *)(v13 + v12 + 12) | 0xC00000)) )
            {
              v14 = v13 + v12;
              v15 = *(_WORD *)(v13 + v12 + 6);
              LOWORD(v33) = *(_WORD *)(v13 + v12 + 4);
              v16 = *(_BYTE *)(v13 + v12 + 1);
              BYTE1(v34) = *(_BYTE *)(v14 + 2);
              HIWORD(v33) = v15;
              LOBYTE(v34) = v16;
              v17 = v34;
              *(_DWORD *)v10 = v33;
              *(_DWORD *)(v10 + 4) = v17;
              memcpy(
                (void *)(v10 + 8),
                *(const void **)(*(_DWORD *)(a1 + 48) + v12 + 8),
                *(_WORD *)(*(_DWORD *)(a1 + 48) + v12 + 6));
              v18 = *(_DWORD *)(a1 + 48) + v12;
              v19 = *(_WORD *)(v18 + 6);
              v10 += v19 + 8;
              v11 += v19 + 8;
              v8 = v27;
              *(_BYTE *)v18 = 1;
            }
            v12 += 20;
            --v26;
          }
          while ( v26 );
          v4 = v25;
        }
        if ( v23 )
        {
          v20 = sub_1004C560((unsigned int *)(*(_DWORD *)(a1 + 16) + 12), v11 - 12, 0xFFFFFFFF);
          v21 = *(_DWORD *)(a1 + 16);
          v33 = 327678;
          LOWORD(v34) = 1;
          *(_DWORD *)v21 = 327678;
          *(_DWORD *)(v21 + 4) = v34;
          *(_DWORD *)(v21 + 8) = v20;
        }
        v32 = v11;
        if ( j_HWM_pvg_hsdb_put(&v28) == -100 )
          sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 4355, 0, 0);
        v5 = a2;
      }
      v6 = v24 + 1;
      v24 = v6;
      v6 = (unsigned __int16)v6;
    }
    while ( (unsigned __int16)v6 < v5 );
  }
  return sub_10018280(*(_DWORD *)(a1 + 60));
}
// 10019240: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000BF00) --------------------------------------------------------
int __usercall sub_1000BF00@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  signed __int16 v5; // ax@3
  int v6; // ebx@3
  int v7; // ebp@3
  int v8; // eax@3
  int v9; // ecx@3
  int v11; // [sp+4h] [bp-8h]@2
  int v12; // [sp+8h] [bp-4h]@3

  v3 = a1;
  sub_100182A0(*(_DWORD *)(a2 + 60), -1);
  if ( v3 )
  {
    v4 = 0;
    v11 = v3;
    do
    {
      v12 = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 4);
      v5 = sub_1000BCE0(v12, a2);
      v6 = (unsigned __int16)v5;
      v7 = 52 * (unsigned __int16)v5;
      memcpy(
        (void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v7 + 4)),
        *(const void **)(v4 + *(_DWORD *)(a2 + 48) + 8),
        *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6));
      v8 = 24 * v6;
      *(_WORD *)(v8 + *(_DWORD *)(a2 + 64) + 4) = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 1);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 20) = *(_DWORD *)(v4 + *(_DWORD *)(a2 + 48) + 16);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 2);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 16) = a3;
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64)) = 0;
      v9 = v7 + *(_DWORD *)(a2 + 32);
      if ( *(_DWORD *)(v9 + 36) && !*(_DWORD *)(v9 + 12) && !(*(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 6) & 1) )
      {
        sub_10018280(*(_DWORD *)(a2 + 60));
        (*(void (__cdecl **)(int, int))(*(_DWORD *)(a2 + 32) + v7 + 36))(v12, a2);
        sub_100182A0(*(_DWORD *)(a2 + 60), -1);
      }
      v4 += 20;
      --v11;
    }
    while ( v11 );
  }
  return sub_10018280(*(_DWORD *)(a2 + 60));
}

//----- (1000C020) --------------------------------------------------------
char __cdecl sub_1000C020(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  char result; // al@2

  LOWORD(v2) = sub_1000BCE0(a1, a2);
  if ( (_WORD)v2 == -1 )
  {
    result = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 670, 0, 0);
  }
  else
  {
    sub_100182A0(*(_DWORD *)(a2 + 60), -1);
    v2 = (unsigned __int16)v2;
    v3 = 52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32);
    memset((void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(v3 + 4)), 0, *(_WORD *)v3);
    result = sub_10018280(*(_DWORD *)(a2 + 60));
    *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v2 + 1) = 0;
  }
  return result;
}

//----- (1000C0A0) --------------------------------------------------------
signed __int16 __cdecl sub_1000C0A0(int a1, int a2)
{
  return sub_1000BCE0(a2, a1);
}

//----- (1000C0B0) --------------------------------------------------------
char __cdecl sub_1000C0B0(int a1, int a2, void *a3, unsigned __int16 a4)
{
  signed __int16 v4; // di@1
  int v5; // ebp@2
  int v6; // eax@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // edx@4
  int v11; // ecx@4
  unsigned __int16 v12; // di@4
  int v13; // ecx@6
  int v14; // ST2C_4@16
  int v15; // ST28_4@16
  const char *v16; // eax@16
  char v17; // [sp+13h] [bp-75h]@4
  unsigned __int16 v18; // [sp+18h] [bp-70h]@1
  unsigned int v19; // [sp+1Ch] [bp-6Ch]@1
  char v20; // [sp+20h] [bp-68h]@3

  v4 = sub_1000BCE0(a1, a2);
  v18 = v4;
  v19 = sub_100181D0();
  if ( v4 == -1 )
  {
    v17 = 0;
    sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 943, 0, 0);
  }
  else
  {
    v5 = 52 * (unsigned __int16)v4;
    v6 = *(_DWORD *)(a2 + 32) + v5;
    if ( *(_BYTE *)(v6 + 8) )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_1000F160(a2, v4);
      _snprintf(&v20, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 874, 0, &v20);
      return 0;
    }
    v10 = *(_DWORD *)(a2 + 64);
    v11 = 24 * (unsigned __int16)v4;
    v12 = *(_WORD *)(v10 + v11 + 4);
    v17 = *(_BYTE *)(v10 + v11 + 1);
    if ( *(_BYTE *)(v11 + v10)
      || *(_DWORD *)(v6 + 12)
      && ((v13 = *(_DWORD *)(v11 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v19 > v13 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v6 + 16)) )
    {
      v17 = 0;
    }
    if ( v12 && v12 <= a4 && v12 == *(_WORD *)v6 )
    {
      sub_100182A0(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v5 + 4)), v12);
      sub_10018280(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v17 = 0;
    }
    if ( v12 > a4 || v12 != *(_WORD *)(*(_DWORD *)(a2 + 32) + v5) )
    {
      v14 = *(_BYTE *)(a2 + 1);
      v15 = *(_WORD *)(*(_DWORD *)(a2 + 32) + v5);
      v16 = sub_1000F160(a2, v18);
      _snprintf(&v20, 0x64u, "%d-%s by=%d sz=%d pi=%d bsz=%d", (unsigned __int16)a1, v16, v12, v15, v14, a4);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 936, 0, &v20);
    }
  }
  return v17;
}

//----- (1000C2A0) --------------------------------------------------------
int __cdecl sub_1000C2A0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_1000BCE0(a1, a2);
  if ( v2 == -1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 992, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 20);
  }
  return result;
}

//----- (1000C2F0) --------------------------------------------------------
int __cdecl sub_1000C2F0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_1000BCE0(a1, a2);
  if ( v2 == -1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1092, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 16);
  }
  return result;
}

//----- (1000C340) --------------------------------------------------------
char __cdecl sub_1000C340(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5)
{
  signed __int16 v5; // bp@1
  int v6; // edi@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // ecx@4
  unsigned __int16 v11; // bp@4
  int v12; // eax@4
  int v13; // eax@5
  int v14; // ecx@6
  unsigned __int16 v15; // ax@14
  unsigned __int16 v16; // cx@14
  int v17; // ST2C_4@16
  int v18; // ST28_4@16
  int v19; // ST24_4@16
  const char *v20; // eax@16
  char v21; // [sp+13h] [bp-75h]@4
  unsigned __int16 v22; // [sp+18h] [bp-70h]@1
  unsigned int v23; // [sp+1Ch] [bp-6Ch]@1
  char v24; // [sp+20h] [bp-68h]@3

  v5 = sub_1000BCE0(a1, a2);
  v22 = v5;
  v23 = sub_100181D0();
  if ( v5 == -1 )
  {
    v21 = 0;
    *a4 = 0;
    sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1267, 0, 0);
  }
  else
  {
    v6 = 52 * (unsigned __int16)v5;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 32) + v6 + 8) != 1 )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_1000F160(a2, v5);
      _snprintf(&v24, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1189, 0, &v24);
      return 0;
    }
    v10 = 24 * (unsigned __int16)v5;
    v11 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 64) + 4);
    *a4 = v11;
    v12 = *(_DWORD *)(a2 + 64);
    v21 = *(_BYTE *)(v10 + v12 + 1);
    if ( *(_BYTE *)(v10 + v12)
      || (v13 = *(_DWORD *)(a2 + 32) + v6, *(_DWORD *)(v13 + 12))
      && ((v14 = *(_DWORD *)(v10 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v23 > v14 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v13 + 16)) )
    {
      v21 = 0;
    }
    if ( v11 && v11 <= *(_WORD *)(v6 + *(_DWORD *)(a2 + 32)) && v11 <= a5 )
    {
      sub_100182A0(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v6 + 4)), *a4);
      sub_10018280(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v21 = 0;
    }
    v15 = *a4;
    v16 = *(_WORD *)(v6 + *(_DWORD *)(a2 + 32));
    if ( *a4 > v16 || v15 > a5 )
    {
      v17 = *(_BYTE *)(a2 + 1);
      v18 = v16;
      v19 = v15;
      v20 = sub_1000F160(a2, v22);
      _snprintf(&v24, 0x64u, "%d-%s by=%d sz=%d pipe=%d bsz=%d", (unsigned __int16)a1, v20, v19, v18, v17, a5);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1260, 0, &v24);
    }
  }
  return v21;
}

//----- (1000C550) --------------------------------------------------------
int __cdecl sub_1000C550(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // ecx@3
  signed int v5; // ebx@7
  unsigned __int16 v6; // cx@7
  int v7; // eax@8
  int v8; // ecx@14

  v1 = *(_DWORD *)(a1 + 8);
  sub_100182A0(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      LOWORD(v3) = sub_1000BCE0(v2, a1);
      if ( (_WORD)v3 != -1 )
      {
        v3 = (unsigned __int16)v3;
        v4 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3;
        if ( *(_BYTE *)(v4 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v3 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v4 + 12)
            && *(_DWORD *)(v4 + 24) & *(_DWORD *)(a1 + 72) )
          {
            v5 = *(_DWORD *)(a1 + 8);
            v6 = 0;
            if ( v5 > 0 )
            {
              v7 = 0;
              do
              {
                if ( *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v7) == (_WORD)v2 )
                  break;
                v7 = ++v6;
              }
              while ( v6 < v5 );
            }
            if ( v6 == v5 )
              *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 8) = v1;
  return sub_10018280(v8);
}

//----- (1000C600) --------------------------------------------------------
int __cdecl sub_1000C600(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  signed __int16 v3; // ax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@12

  v1 = 0;
  sub_100182A0(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      v3 = sub_1000BCE0(v2, a1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3 + *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(v5 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v4 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v5 + 12)
            && *(_DWORD *)(v5 + 20) & *(_DWORD *)(a1 + 72)
            && *(_DWORD *)(v5 + 24) )
          {
            if ( (unsigned int)*(_WORD *)v5 + 20 > *(_DWORD *)(a1 + 20) )
              sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1622, 0, 0);
            else
              *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v6 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 12) = v1;
  return sub_10018280(v6);
}

//----- (1000C6B0) --------------------------------------------------------
char __cdecl sub_1000C6B0(int a1)
{
  char v1; // cl@1
  int v2; // eax@2
  int v3; // ebx@3
  signed int v4; // ebp@3
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  bool v7; // zf@3
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // edx@15
  int v11; // eax@15
  int v12; // edi@15
  int v13; // edx@15
  int v14; // ebp@15
  int v15; // ebx@15
  int v16; // eax@15
  int v17; // eax@19
  char v18; // cl@19
  int v19; // ecx@24
  int v20; // edi@25
  int v21; // ecx@30
  int v22; // edx@30
  unsigned int v23; // edi@38
  int v24; // ebp@44
  int v25; // eax@45
  int v26; // edx@45
  int v27; // ecx@45
  void (__cdecl *v28)(int, int); // edi@45
  unsigned int v30; // [sp+10h] [bp-90h]@3
  int v31; // [sp+14h] [bp-8Ch]@3
  int v32; // [sp+18h] [bp-88h]@20
  unsigned int v33; // [sp+18h] [bp-88h]@44
  int v34; // [sp+1Ch] [bp-84h]@1
  int v35; // [sp+20h] [bp-80h]@2
  int v36; // [sp+24h] [bp-7Ch]@1
  char v37; // [sp+28h] [bp-78h]@1
  unsigned __int16 v38; // [sp+2Ah] [bp-76h]@3
  unsigned int v39; // [sp+2Ch] [bp-74h]@1
  int v40; // [sp+30h] [bp-70h]@15
  int v41; // [sp+34h] [bp-6Ch]@3
  char v42; // [sp+38h] [bp-68h]@9

  v1 = *(_BYTE *)(a1 + 1);
  v36 = *(_DWORD *)(a1 + 16);
  v37 = v1;
  v39 = sub_100181D0();
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v2 = j_HWM_pvg_hsdb_get(&v35, *(_DWORD *)(a1 + 20));
    if ( v2 <= 0 )
      break;
    v3 = *(_DWORD *)(a1 + 16);
    v4 = v38;
    v5 = *(_DWORD *)v3;
    v6 = 0;
    v7 = (unsigned __int16)*(_DWORD *)v3 == -2;
    v31 = v38;
    v30 = 0;
    v41 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      v8 = v5 >> 16;
      v4 = -8 - (unsigned __int16)v8 + v38;
      v31 = -8 - (unsigned __int16)v8 + v38;
      v3 += (unsigned __int16)v8 + 8;
      if ( (unsigned __int16)v8 < 4u || v4 <= 0 )
      {
        v31 = 0;
        v4 = 0;
        v9 = ~v34;
      }
      else
      {
        v34 = *(_DWORD *)(v3 - 4);
        v9 = sub_1004C560((unsigned int *)v3, v4, 0xFFFFFFFF);
      }
      if ( v34 != v9 )
      {
        _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1796, 0, &v42);
        continue;
      }
    }
    else if ( *(_BYTE *)(a1 + 1) == 6 )
    {
      _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1817, 0, &v42);
      continue;
    }
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)v3;
        v11 = *(_DWORD *)(v3 + 4);
        v12 = 20 * v6;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v3;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6) = HIWORD(v10);
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 1) = v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 2) = BYTE1(v11);
        v40 = v10;
        LOWORD(v14) = sub_1000BCE0(v10, a1);
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16) = v35;
        v15 = v3 + 8;
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 8) = v15;
        v16 = *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6);
        v3 = v16 + v15;
        v31 += -8 - v16;
        if ( v31 < 0 )
        {
          _snprintf(
            &v42,
            0x64u,
            "error with pkt id %d rxsz=%d pipe=%d",
            (unsigned __int16)v13,
            HIWORD(v40),
            *(_BYTE *)(a1 + 1));
          sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1877, 0, &v42);
          goto LABEL_2;
        }
        if ( *(_DWORD *)(a1 + 80) )
          (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 80))(
            a1,
            v13,
            *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6),
            *(_DWORD *)(*(_DWORD *)(a1 + 48) + v12 + 8));
        if ( (_WORD)v14 == -1 )
        {
LABEL_39:
          v23 = v30;
          goto LABEL_40;
        }
        v14 = (unsigned __int16)v14;
        v17 = 52 * (unsigned __int16)v14 + *(_DWORD *)(a1 + 32);
        v18 = *(_BYTE *)(v17 + 8);
        if ( v18 )
        {
          v32 = v12 + *(_DWORD *)(a1 + 48);
          if ( *(_WORD *)(v32 + 6) <= *(_WORD *)v17 )
            goto LABEL_23;
          if ( v18 )
            goto LABEL_39;
        }
        v32 = v12 + *(_DWORD *)(a1 + 48);
        if ( *(_WORD *)(v32 + 6) != *(_WORD *)v17 )
          goto LABEL_39;
LABEL_23:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 24) + v14) != 1 )
          goto LABEL_39;
        v19 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
        if ( (v19 & *(_DWORD *)(v17 + 20)) != v19 )
        {
          v20 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
          if ( (v20 & 0xC00000) != v20 && !(*(_BYTE *)a1 & 4) )
            goto LABEL_39;
        }
        if ( !(*(_DWORD *)(v17 + 24) & *(_DWORD *)(a1 + 72)) || !(*(_BYTE *)(v17 + 28) & *(_BYTE *)a1) )
          goto LABEL_39;
        if ( *(_DWORD *)(v17 + 12) )
        {
          v21 = *(_DWORD *)(a1 + 64) + 24 * v14;
          v22 = *(_DWORD *)(v21 + 16);
          if ( v22 )
          {
            if ( v39 <= v22 + *(_DWORD *)(a1 + 36) + (*(_DWORD *)(v17 + 16) >> 1)
              && (*(_BYTE *)(v32 + 1) != 1 || *(_BYTE *)(v21 + 1) == 1 && *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && (*(_BYTE *)(v21 + 1) == 1 || *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && *(_BYTE *)(v32 + 2) != *(_BYTE *)(v21 + 2) )
            {
              goto LABEL_39;
            }
          }
        }
        v23 = v30++ + 1;
LABEL_40:
        if ( !v31 || v23 >= *(_DWORD *)(a1 + 52) )
        {
          if ( v23 )
          {
            sub_1000BF00(v23, a1, v39);
            if ( v23 )
            {
              v24 = 0;
              v33 = v23;
              do
              {
                v25 = (unsigned __int16)sub_1000BCE0(*(_WORD *)(*(_DWORD *)(a1 + 48) + v24 + 4), a1);
                v27 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v25;
                v28 = *(void (__cdecl **)(int, int))(v27 + 36);
                if ( v28 && *(_DWORD *)(v27 + 12) && !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + 24 * v25 + 6) & 1) )
                  v28(v26, a1);
                v24 += 20;
                --v33;
              }
              while ( v33 );
            }
          }
          v30 = 0;
        }
        if ( v31 <= 0 )
          goto LABEL_2;
        v6 = v30;
      }
    }
  }
  if ( v2 == -95 )
    LOBYTE(v2) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2094, 0, 0);
  return v2;
}
// 10019220: using guessed type int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD);

//----- (1000CAB0) --------------------------------------------------------
int __cdecl sub_1000CAB0(int a1)
{
  int result; // eax@1
  signed __int16 v2; // ax@2
  int v3; // ebx@2
  int v4; // edi@2
  unsigned int *v5; // edx@2
  int v6; // ebp@3
  unsigned int v7; // ecx@3
  unsigned int v8; // ebx@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // eax@5
  int v12; // edx@8
  int v13; // ecx@8
  int v14; // edx@8
  unsigned int v15; // eax@12
  int v16; // edx@16
  int v17; // ST24_4@19
  const char *v18; // eax@19
  int v19; // eax@20
  int v20; // ecx@21
  int v21; // ebx@24
  int v22; // edx@26
  int v23; // eax@27
  int v24; // eax@29
  int v25; // eax@31
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // ebp@32
  void (__cdecl *v30)(int, int); // ebp@33
  unsigned int v31; // [sp+8h] [bp-8Ch]@1
  signed int v32; // [sp+Ch] [bp-88h]@1
  unsigned int v33; // [sp+10h] [bp-84h]@1
  int v34; // [sp+14h] [bp-80h]@1
  int v35; // [sp+18h] [bp-7Ch]@2
  int v36; // [sp+1Ch] [bp-78h]@1
  unsigned __int16 v37; // [sp+24h] [bp-70h]@2
  int v38; // [sp+28h] [bp-6Ch]@2
  char v39; // [sp+2Ch] [bp-68h]@19

  v33 = 12;
  v36 = j_HWM_pvg_hsdb_get_lrus_online();
  v32 = 0;
  result = sub_100181D0();
  v31 = result;
  v34 = 0;
  if ( *(_DWORD *)(a1 + 12) > 0 )
  {
    do
    {
      v35 = *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v34);
      v2 = sub_1000BCE0(v35, a1);
      v3 = (unsigned __int16)v2;
      v4 = 24 * (unsigned __int16)v2;
      v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
      v37 = v2;
      v38 = (unsigned __int16)v2;
      if ( v31 >= *v5 - *(_DWORD *)(a1 + 36) )
      {
        v6 = 52 * (unsigned __int16)v2;
        v7 = *v5 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v2 + 12);
        if ( v31 >= v7 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12);
          v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
          v9 = v8 * ((*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) - v7 + v31 - 1) / v8);
          v3 = v38;
          v7 += v9;
        }
        *v5 = v7;
        v10 = v36;
        v11 = v6 + *(_DWORD *)(a1 + 32);
        if ( v36 & *(_DWORD *)(v11 + 24) || v10 & 0xC00000 || (*(_DWORD *)(v11 + 32) >> 3) & 1 )
        {
          v15 = *(_WORD *)v11 + v33 + 8;
          if ( v32 > 0 && (v15 > *(_DWORD *)(a1 + 20) || v15 > 0x5B0) )
          {
            sub_1000BD00(a1, v32);
            v32 = 0;
            v33 = 12;
          }
          v16 = *(_DWORD *)(a1 + 32);
          if ( !*(_DWORD *)(v16 + v6 + 44) || *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 4 )
            goto LABEL_42;
          if ( (*(_DWORD *)(v16 + v6 + 32) >> 1) & 1 )
          {
            v17 = *(_BYTE *)(a1 + 1);
            v18 = sub_1000F160(a1, v37);
            _snprintf(&v39, 0x64u, "%d-%s is TX_ON_PUT, pipe=%d", (unsigned __int16)v35, v18, v17);
            sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2279, 0, &v39);
          }
          v19 = v4 + *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(*(_BYTE *)(a1 + 3) + v3 * *(_BYTE *)(a1 + 2) + *(_DWORD *)(a1 + 56)) > *(_BYTE *)(v19 + 2)
            && (v20 = *(_DWORD *)(v19 + 16)) != 0
            && v31 <= *(_DWORD *)(a1 + 36) + v20 + (*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 16) >> 1)
            && *(_BYTE *)(v19 + 1) == 1 )
          {
LABEL_42:
            v21 = v35;
          }
          else
          {
            v21 = v35;
            (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 32) + v6 + 44))(v35, a1);
          }
          v22 = *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(v4 + v22 + 3) == 1 )
          {
            v23 = *(_DWORD *)(v4 + v22 + 16);
            if ( v23 )
            {
              if ( v31 <= *(_DWORD *)(a1 + 36) + v23 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) )
              {
                *(_DWORD *)(v4 + *(_DWORD *)(a1 + 64) + 12) = v31;
                *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
                v24 = *(_DWORD *)(a1 + 64);
                if ( *(_DWORD *)(v4 + v24 + 20) & *(_DWORD *)(a1 + 72) )
                {
                  if ( *(_WORD *)(v4 + v24 + 4) )
                  {
                    v25 = 20 * v32;
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 8) = *(_DWORD *)(a1 + 28)
                                                                + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 4);
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 12) = v36 & *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 24);
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 4) = v21;
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 6) = *(_WORD *)(v4 + *(_DWORD *)(a1 + 64) + 4);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48)) = 0;
                    ++v32;
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 2);
                    v26 = *(_DWORD *)(a1 + 32);
                    v33 += *(_WORD *)(v26 + v6) + 8;
                    if ( (*(_DWORD *)(v26 + v6 + 32) >> 2) & 1 )
                    {
                      v27 = *(_DWORD *)(a1 + 32);
                      v28 = *(_DWORD *)(v6 + v27 + 24);
                      v29 = v27 + v6;
                      if ( v28 & *(_DWORD *)(a1 + 72) )
                      {
                        v30 = *(void (__cdecl **)(int, int))(v29 + 36);
                        if ( v30 )
                        {
                          if ( !(*(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 1) )
                            v30(v21, a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 64);
          v13 = *(_DWORD *)(v12 + v4 + 16);
          v14 = v4 + v12;
          if ( (!v13 || v31 > *(_DWORD *)(a1 + 36) + v13 + *(_DWORD *)(v11 + 16)) && *(_BYTE *)(v14 + 1) == 1 )
          {
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1) = 0;
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
          }
        }
      }
      ++v34;
    }
    while ( v34 < *(_DWORD *)(a1 + 12) );
    result = v32;
    if ( v32 > 0 && v33 <= *(_DWORD *)(a1 + 20) )
      result = sub_1000BD00(a1, v32);
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000CE40) --------------------------------------------------------
char __cdecl sub_1000CE40(int a1, char a2, int a3, const void *a4, int a5)
{
  signed __int16 v5; // ax@1
  int v6; // ebx@2
  int v7; // ebp@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ST2C_4@4
  const char *v11; // eax@4
  int v12; // eax@5
  int v13; // edx@5
  int v14; // ecx@7
  int v15; // edx@7
  int v16; // ecx@7
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@15
  int v20; // edx@16
  int (__cdecl *v21)(int, int); // ebp@18
  int v22; // ST2C_4@23
  int v23; // ST28_4@23
  int v24; // ST24_4@23
  const char *v25; // eax@23
  unsigned int v26; // eax@4
  unsigned int v28; // [sp+10h] [bp-70h]@5
  char v29; // [sp+18h] [bp-68h]@4

  v5 = sub_1000BCE0(a1, a3);
  if ( v5 == -1
    || (v6 = (unsigned __int16)v5,
        v7 = 52 * (unsigned __int16)v5,
        v8 = 24 * (unsigned __int16)v5,
        v9 = v7 + *(_DWORD *)(a3 + 32),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4) != *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a3 + 4) || v5 == -1 )
    {
      _snprintf(&v29, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v5, *(_BYTE *)(a3 + 1));
      LOBYTE(v26) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2645, 0, &v29);
    }
    else
    {
      v22 = *(_BYTE *)(a3 + 1);
      v23 = *(_WORD *)(52 * (unsigned __int16)v5 + *(_DWORD *)(a3 + 32));
      v24 = *(_WORD *)(*(_DWORD *)(a3 + 64) + 24 * (unsigned __int16)v5 + 4);
      v25 = sub_1000F160(a3, v5);
      _snprintf(&v29, 0x64u, "%d-%s stssz=%d infsz=%d pipe=%d", (unsigned __int16)a1, v25, v24, v23, v22);
      LOBYTE(v26) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2660, 0, &v29);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) )
  {
    v10 = *(_BYTE *)(a3 + 1);
    v11 = sub_1000F160(a3, v5);
    _snprintf(&v29, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v26) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2511, 0, &v29);
  }
  else
  {
    v12 = sub_100181D0();
    v13 = *(_DWORD *)(a3 + 32);
    v28 = v12;
    if ( !*(_DWORD *)(v13 + v7 + 12)
      || (v26 = *(_DWORD *)(v13 + v7 + 16), v28 <= a5 + v26 + *(_DWORD *)(a3 + 36))
      && ((v14 = *(_DWORD *)(a3 + 64), v15 = *(_DWORD *)(v14 + v8 + 16), v16 = v8 + v14, !v15)
       || v28 > *(_DWORD *)(a3 + 36) + v15 + (v26 >> 1)
       || a2
       && (*(_BYTE *)(v16 + 1) != 1
        || *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2))
       || *(_BYTE *)(v16 + 1) != 1
       && *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2)
       || (v26 = *(_DWORD *)(a3 + 56),
           *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + v26) == *(_BYTE *)(v16 + 2))) )
    {
      sub_100182A0(*(_DWORD *)(a3 + 60), -1);
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 1) = a2;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 16) = a5;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 2) = *(_BYTE *)(*(_BYTE *)(a3 + 3)
                                                           + v6 * *(_BYTE *)(a3 + 2)
                                                           + *(_DWORD *)(a3 + 56));
      *(_BYTE *)(v8 + *(_DWORD *)(a3 + 64)) = 0;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 3) = 1;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 20) = *(_DWORD *)(a3 + 72);
      v17 = *(_DWORD *)(a3 + 32);
      v18 = *(_DWORD *)(v17 + v7 + 32);
      v19 = v7 + v17;
      if ( (v18 >> 1) & 1 )
      {
        v20 = *(_DWORD *)(a3 + 64);
        if ( v28 < *(_DWORD *)(v20 + v8 + 8) )
          *(_DWORD *)(v20 + v8 + 8) -= *(_DWORD *)(v19 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v7 + 4)),
        a4,
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4));
      LOBYTE(v26) = sub_10018280(*(_DWORD *)(a3 + 60));
      v21 = *(int (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v7 + 48);
      if ( v21 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 6) & 8) )
        LOBYTE(v26) = v21(a1, a3);
    }
  }
  return v26;
}

//----- (1000D150) --------------------------------------------------------
char __cdecl sub_1000D150(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6)
{
  signed __int16 v6; // ax@1
  int v7; // ebp@2
  int v8; // ebx@2
  int v9; // ecx@2
  int v10; // ST28_4@4
  const char *v11; // eax@4
  unsigned int v12; // edx@5
  int v13; // ecx@5
  unsigned int v14; // ecx@6
  int v15; // edx@7
  int v16; // edi@7
  int v17; // edi@14
  int v18; // eax@14
  int v19; // ecx@15
  int (__cdecl *v20)(int, int); // ebx@17
  int v21; // ST28_4@22
  const char *v22; // eax@22
  int v23; // eax@4
  unsigned int v25; // [sp+10h] [bp-70h]@5
  char v26; // [sp+18h] [bp-68h]@4

  v6 = sub_1000BCE0(a1, a4);
  if ( v6 == -1
    || (v7 = (unsigned __int16)v6, v8 = 52 * (unsigned __int16)v6, v9 = v8 + *(_DWORD *)(a4 + 32), a2 > *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a4 + 4) || v6 == -1 )
    {
      _snprintf(&v26, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v6, *(_BYTE *)(a4 + 1));
      LOBYTE(v23) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2939, 0, &v26);
    }
    else
    {
      v21 = *(_BYTE *)(a4 + 1);
      v22 = sub_1000F160(a4, v6);
      _snprintf(&v26, 0x64u, "%d-%s >max sz sz=%d pipe=%d", (unsigned __int16)a1, v22, a2, v21);
      LOBYTE(v23) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2953, 0, &v26);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) == 1 )
  {
    v12 = sub_100181D0();
    v13 = *(_DWORD *)(a4 + 32) + v8;
    v25 = v12;
    if ( !*(_DWORD *)(v13 + 12)
      || (v14 = *(_DWORD *)(v13 + 16), v23 = *(_DWORD *)(a4 + 36), v12 <= a6 + v23 + v14)
      && ((v15 = *(_DWORD *)(a4 + 64) + 24 * v7, (v16 = *(_DWORD *)(v15 + 16)) == 0)
       || v25 > v23 + v16 + (v14 >> 1)
       || a3
       && (*(_BYTE *)(v15 + 1) != 1
        || (LOBYTE(v23) = *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + *(_DWORD *)(a4 + 56)),
            (unsigned __int8)v23 <= *(_BYTE *)(v15 + 2)))
       || *(_BYTE *)(v15 + 1) != 1
       && (v23 = *(_DWORD *)(a4 + 56),
           *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + v23) <= *(_BYTE *)(v15 + 2))) )
    {
      sub_100182A0(*(_DWORD *)(a4 + 60), -1);
      v17 = 24 * v7;
      *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4) = a2;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 1) = a3;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 16) = a6;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 2) = *(_BYTE *)(*(_BYTE *)(a4 + 3)
                                                            + v7 * *(_BYTE *)(a4 + 2)
                                                            + *(_DWORD *)(a4 + 56));
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64)) = 0;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 3) = 1;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 20) = *(_DWORD *)(a4 + 72);
      v18 = *(_DWORD *)(a4 + 32) + v8;
      if ( (*(_DWORD *)(v18 + 32) >> 1) & 1 )
      {
        v19 = *(_DWORD *)(a4 + 64);
        if ( v25 < *(_DWORD *)(v17 + v19 + 8) )
          *(_DWORD *)(v17 + v19 + 8) -= *(_DWORD *)(v18 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a4 + 28) + *(_DWORD *)(*(_DWORD *)(a4 + 32) + v8 + 4)),
        a5,
        *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4));
      sub_10018280(*(_DWORD *)(a4 + 60));
      v23 = *(_DWORD *)(a4 + 32);
      v20 = *(int (__cdecl **)(int, int))(v23 + v8 + 48);
      if ( v20 && !(*(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 6) & 8) )
        LOBYTE(v23) = v20(a1, a4);
    }
  }
  else
  {
    v10 = *(_BYTE *)(a4 + 1);
    v11 = sub_1000F160(a4, v6);
    _snprintf(&v26, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v23) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2802, 0, &v26);
  }
  return v23;
}

//----- (1000D440) --------------------------------------------------------
char __cdecl sub_1000D440(int a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  char result; // al@2
  int v5; // ecx@3
  int v6; // ebp@3
  int v7; // eax@3
  int v8; // edi@3
  int v9; // ebx@3
  int v10; // ST24_4@5
  const char *v11; // eax@5
  int v12; // eax@7
  int v13; // ebp@10
  void (__cdecl *v14)(int, int); // eax@10
  char v15; // cl@13
  int v16; // edx@13
  __int16 v17; // ax@13
  bool v18; // cf@13
  bool v19; // zf@13
  int v20; // ebx@17
  int v21; // eax@19
  char v22; // dl@19
  __int16 v23; // cx@19
  unsigned int v24; // eax@20
  int v25; // ecx@20
  int v26; // edi@21
  char v27; // [sp+6h] [bp-7Eh]@3
  char v28; // [sp+7h] [bp-7Dh]@17
  int v29; // [sp+8h] [bp-7Ch]@13
  int v30; // [sp+Ch] [bp-78h]@13
  char v31; // [sp+10h] [bp-74h]@13
  char v32; // [sp+11h] [bp-73h]@15
  __int16 v33; // [sp+12h] [bp-72h]@13
  int v34; // [sp+14h] [bp-70h]@1
  int v35; // [sp+18h] [bp-6Ch]@19
  char v36; // [sp+1Ch] [bp-68h]@5

  v3 = sub_1000BCE0(a1, a3);
  v34 = (unsigned __int16)v3;
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 72);
    v6 = (unsigned __int16)v3;
    v7 = *(_DWORD *)(a3 + 32);
    v8 = 52 * v6;
    v9 = a2 & ~v5 & (*(_DWORD *)(v7 + 52 * v6 + 24) | 0xC00000);
    v27 = 1;
    if ( !*(_DWORD *)(52 * v6 + v7 + 12) || (*(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 32) >> 6) & 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6) != 1 )
        goto LABEL_26;
      v12 = v8 + *(_DWORD *)(a3 + 32);
      if ( !(v5 & *(_DWORD *)(v12 + 20)) || !(*(_BYTE *)(v12 + 28) & *(_BYTE *)a3) || !v9 )
        goto LABEL_26;
      v13 = 24 * v6;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v13 + 12) = sub_100181D0();
      v14 = *(void (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v8 + 44);
      if ( v14 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v13 + 6) & 4) )
        v14(a1, a3);
      v15 = *(_BYTE *)(a3 + 1);
      v16 = *(_DWORD *)(a3 + 64);
      v30 = *(_DWORD *)(a3 + 16);
      v31 = v15;
      v29 = v9;
      v17 = *(_WORD *)(v16 + v13 + 4) + 20;
      v18 = (unsigned int)(unsigned __int16)v17 < *(_DWORD *)(a3 + 20);
      v19 = (unsigned __int16)v17 == *(_DWORD *)(a3 + 20);
      v33 = *(_WORD *)(v16 + v13 + 4) + 20;
      if ( !v18 && !v19 )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3198, 1, 0);
        v17 = v33;
      }
      v19 = *(_BYTE *)(a3 + 1) == 6;
      v32 = *(_BYTE *)(*(_DWORD *)(a3 + 32) + v8 + 32) & 1;
      if ( v19 || !(a2 & *(_DWORD *)(a3 + 84)) )
      {
        v28 = 1;
        v20 = *(_DWORD *)(a3 + 16) + 12;
      }
      else
      {
        v20 = *(_DWORD *)(a3 + 16);
        v28 = 0;
        v33 = v17 - 12;
      }
      sub_100182A0(*(_DWORD *)(a3 + 60), -1);
      v21 = *(_DWORD *)(a3 + 64) + v13;
      v22 = *(_BYTE *)(v21 + 1);
      LOWORD(v34) = a1;
      v23 = *(_WORD *)(v21 + 4);
      BYTE1(v35) = *(_BYTE *)(v21 + 2);
      HIWORD(v34) = v23;
      *(_DWORD *)v20 = v34;
      LOBYTE(v35) = v22;
      *(_DWORD *)(v20 + 4) = v35;
      memcpy(
        (void *)(v20 + 8),
        (const void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 4)),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4));
      if ( v28 )
      {
        v24 = sub_1004C560(
                (unsigned int *)(*(_DWORD *)(a3 + 16) + 12),
                *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4) + 8,
                0xFFFFFFFF);
        v25 = *(_DWORD *)(a3 + 16);
        v34 = 327678;
        LOWORD(v35) = 1;
        *(_DWORD *)v25 = 327678;
        *(_DWORD *)(v25 + 4) = v35;
        *(_DWORD *)(v25 + 8) = v24;
      }
      v26 = j_HWM_pvg_hsdb_put(&v29);
      sub_10018280(*(_DWORD *)(a3 + 60));
      if ( v26 < 0 )
LABEL_26:
        v27 = 0;
      result = v27;
    }
    else
    {
      v10 = *(_BYTE *)(a3 + 1);
      v11 = sub_1000F160(a3, v34);
      _snprintf(&v36, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v11, v10);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3123, 0, &v36);
      result = 0;
    }
  }
  return result;
}
// 10019240: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000D700) --------------------------------------------------------
char __cdecl sub_1000D700(int a1, int a2, void *a3, char a4, int a5)
{
  signed __int16 v5; // ax@1
  char result; // al@2
  int v7; // ebp@3
  int v8; // ebx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ST24_4@4
  const char *v13; // eax@4
  int v14; // eax@6
  int v15; // ebp@9
  char v16; // cl@9
  int v17; // edx@9
  __int16 v18; // ax@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  char v22; // bl@13
  int v23; // eax@15
  __int16 v24; // cx@15
  int v25; // ecx@15
  void *v26; // edx@15
  unsigned int v27; // eax@16
  int v28; // ecx@16
  int v29; // edi@17
  char v30; // [sp+7h] [bp-81h]@3
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a3;
  v5 = sub_1000BCE0(a1, a5);
  v37 = (unsigned __int16)v5;
  if ( v5 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = (unsigned __int16)v5;
    v8 = 52 * (unsigned __int16)v5;
    v9 = *(_DWORD *)(a5 + 32) + v8;
    v10 = *(_DWORD *)(a5 + 72);
    v11 = a2 & ~v10 & (*(_DWORD *)(v9 + 24) | 0xC00000);
    v30 = 0;
    if ( *(_DWORD *)(v9 + 12) )
    {
      v12 = *(_BYTE *)(a5 + 1);
      v13 = sub_1000F160(a5, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v13, v12);
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3486, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a5 + 24) + v7) == 1
        && (v14 = v8 + *(_DWORD *)(a5 + 32), v10 & *(_DWORD *)(v14 + 20))
        && *(_BYTE *)(v14 + 28) & *(_BYTE *)a5
        && v11 )
      {
        v15 = 24 * v7;
        *(_DWORD *)(*(_DWORD *)(a5 + 64) + v15 + 12) = sub_100181D0();
        v16 = *(_BYTE *)(a5 + 1);
        v17 = *(_DWORD *)(a5 + 64);
        v32 = *(_DWORD *)(a5 + 16);
        v33 = v16;
        v31 = v11;
        v18 = *(_WORD *)(v17 + v15 + 4) + 20;
        v19 = (unsigned int)(unsigned __int16)v18 < *(_DWORD *)(a5 + 20);
        v20 = (unsigned __int16)v18 == *(_DWORD *)(a5 + 20);
        v35 = *(_WORD *)(v17 + v15 + 4) + 20;
        if ( !v19 && !v20 )
        {
          sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3535, 1, 0);
          v18 = v35;
        }
        v20 = *(_BYTE *)(a5 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a5 + 32) + v8 + 32) & 1;
        if ( v20 || !(a2 & *(_DWORD *)(a5 + 84)) )
        {
          v22 = 1;
          v21 = *(_DWORD *)(a5 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a5 + 16);
          v22 = 0;
          v35 = v18 - 12;
        }
        sub_100182A0(*(_DWORD *)(a5 + 60), -1);
        v23 = *(_DWORD *)(a5 + 64) + v15;
        LOWORD(v37) = a1;
        v24 = *(_WORD *)(v23 + 4);
        LOBYTE(v23) = *(_BYTE *)(v23 + 2);
        HIWORD(v37) = v24;
        v25 = v37;
        LOBYTE(v38) = a4;
        BYTE1(v38) = v23;
        *(_DWORD *)(v21 + 4) = v38;
        v26 = v36;
        *(_DWORD *)v21 = v25;
        memcpy((void *)(v21 + 8), v26, *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4));
        if ( v22 )
        {
          v27 = sub_1004C560(
                  (unsigned int *)(*(_DWORD *)(a5 + 16) + 12),
                  *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4) + 8,
                  0xFFFFFFFF);
          v28 = *(_DWORD *)(a5 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v28 = 327678;
          *(_DWORD *)(v28 + 4) = v38;
          *(_DWORD *)(v28 + 8) = v27;
        }
        v29 = j_HWM_pvg_hsdb_put(&v31);
        sub_10018280(*(_DWORD *)(a5 + 60));
        if ( v29 >= 0 )
          v30 = 1;
      }
      else
      {
        v30 = 0;
      }
      result = v30;
    }
  }
  return result;
}
// 10019240: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000D990) --------------------------------------------------------
int __cdecl sub_1000D990(int a1)
{
  int result; // eax@1
  int v2; // edi@2
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // edx@3
  void (__cdecl *v7)(int, int); // eax@5
  int i; // [sp+4h] [bp-8h]@1
  unsigned int v9; // [sp+8h] [bp-4h]@1

  v9 = sub_100181D0();
  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * result);
    v3 = (unsigned __int16)sub_1000BCE0(v2, a1);
    v4 = 24 * (unsigned __int16)v3;
    v5 = v4 + *(_DWORD *)(a1 + 64);
    if ( !*(_BYTE *)v5 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      if ( !v6 || v9 > v6 + *(_DWORD *)(a1 + 36) + *(_DWORD *)(52 * v3 + *(_DWORD *)(a1 + 32) + 16) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 1) = 0;
        *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64)) = 1;
        v7 = *(void (__cdecl **)(int, int))(52 * v3 + *(_DWORD *)(a1 + 32) + 40);
        if ( v7 )
        {
          if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 6) & 2) )
            v7(v2, a1);
        }
      }
    }
    result = i + 1;
  }
  return result;
}

//----- (1000DA50) --------------------------------------------------------
char __cdecl sub_1000DA50(int a1, int a2, void *a3)
{
  return sub_1000C0B0(a1, a2, a3, 0xFFFFu);
}

//----- (1000DA70) --------------------------------------------------------
char __cdecl sub_1000DA70(int a1, int a2, void *a3, unsigned __int16 *a4)
{
  return sub_1000C340(a1, a2, a3, a4, 0xFFFFu);
}

//----- (1000DAA0) --------------------------------------------------------
int __cdecl sub_1000DAA0(int a1)
{
  int v1; // esi@1
  int v2; // ecx@3
  signed __int16 v3; // ax@5
  int v4; // ebp@6
  int v5; // edi@6
  int v6; // ecx@6
  unsigned int v7; // edi@6
  int v8; // ST10_4@10
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@4
  int v12; // [sp+14h] [bp+4h]@3

  v1 = a1;
  v10 = sub_100181D0();
  if ( *(_BYTE *)(a1 + 3) >= 4u )
    sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1321, 1, 0);
  sub_100182A0(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  v12 = 0;
  if ( *(_DWORD *)(v1 + 4) > 0 )
  {
    v11 = 0;
    do
    {
      v3 = sub_1000BCE0(v2, v1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3;
        memset(
          (void *)(*(_DWORD *)(v1 + 28) + *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 4)),
          0,
          *(_WORD *)(*(_DWORD *)(v1 + 32) + v5));
        v6 = 24 * v4;
        *(_BYTE *)(v6 + *(_DWORD *)(v1 + 64)) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 1) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 2) = -1;
        *(_WORD *)(*(_DWORD *)(v1 + 64) + v6 + 4) = *(_WORD *)(v5 + *(_DWORD *)(v1 + 32));
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 12) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 3) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 6) = 0;
        v7 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 12);
        if ( v7 )
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10 + 25 * (v11 % (v7 / 0x19));
        else
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10;
      }
      v2 = v12++ + 1;
      v11 = (unsigned __int16)v12;
    }
    while ( (signed int)(unsigned __int16)v12 < *(_DWORD *)(v1 + 4) );
  }
  v8 = *(_DWORD *)(v1 + 60);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  sub_10018280(v8);
  sub_1000C550(v1);
  return sub_1000C600(v1);
}

//----- (1000DBF0) --------------------------------------------------------
char __cdecl sub_1000DBF0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int v4; // esi@2
  int v5; // edi@2
  int v6; // eax@2
  int v7; // edx@2

  v2 = sub_1000BCE0(a1, a2);
  if ( v2 == -1 )
  {
    LOBYTE(v6) = sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3035, 0, 0);
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(v3 + 32) + 4);
    v5 = *(_WORD *)v4;
    LOWORD(v6) = sub_1000BCE0(v5, v3);
    if ( (_WORD)v6 != -1 )
    {
      v6 = 3 * (unsigned __int16)v6;
      if ( *(_BYTE *)(*(_DWORD *)(v7 + 64) + 8 * v6 + 1) == 1 )
        LOBYTE(v6) = sub_1000D440(v5, *(_DWORD *)(v4 + 4), v7);
    }
  }
  return v6;
}

//----- (1000DC70) --------------------------------------------------------
char sub_1000DC70()
{
  return sub_1000F2B0(0);
}

//----- (1000DC80) --------------------------------------------------------
int __cdecl sub_1000DC80(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10222C34 |= a1;
  return result;
}
// 10222C34: using guessed type int dword_10222C34;

//----- (1000DC90) --------------------------------------------------------
int __cdecl sub_1000DC90(int a1, int a2, unsigned __int16 a3, char a4, char a5)
{
  unsigned __int16 v5; // di@1
  _WORD *v6; // edx@2
  int v7; // esi@2
  unsigned __int16 v8; // ax@3
  int v9; // eax@4

  v5 = 0;
  if ( a3 )
  {
    v6 = dword_10121028;
    v7 = a1;
    do
    {
      v8 = *(_WORD *)(a2 + 2 * v5);
      if ( v8 >= 0x344u )
        break;
      LOWORD(v9) = v6[v8 + 142332];
      if ( (unsigned __int16)v9 < 0x211u )
      {
        v9 = (unsigned __int16)v9;
        if ( (a1 & (*(_DWORD *)&v6[26 * (unsigned __int16)v9 + 128588] | *(_DWORD *)&v6[26 * (unsigned __int16)v9
                                                                                      + 128590])) == a1
          || v7 & 0xC00000 )
        {
          sub_10026310(a4, (_BYTE *)v6 + v9, &byte_10121030[v9], a5);
          v6 = dword_10121028;
        }
      }
      ++v5;
    }
    while ( v5 < a3 );
  }
  sub_1000C550((int)&byte_10222BE0);
  return sub_1000C600((int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000DD40) --------------------------------------------------------
int __cdecl sub_1000DD40(int a1)
{
  int result; // eax@1

  result = ~a1;
  dword_10222C34 &= ~a1;
  return result;
}
// 10222C34: using guessed type int dword_10222C34;

//----- (1000DD50) --------------------------------------------------------
char __cdecl sub_1000DD50(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@2
  int v4; // ebp@2
  unsigned __int16 v5; // di@2
  unsigned __int16 v6; // cx@3
  int v7; // edi@8
  unsigned __int16 v8; // di@9
  int v9; // eax@10
  int v11; // [sp+4h] [bp-530h]@2
  __int16 v12; // [sp+8h] [bp-52Ch]@9
  int v13; // [sp+Ch] [bp-528h]@10
  int v14; // [sp+10h] [bp-524h]@12

  LOWORD(v2) = sub_1000C0A0(a2, a1);
  if ( (_WORD)v2 != -1 )
  {
    v3 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32) + 4);
    v4 = 24 * (unsigned __int16)v2;
    v5 = *(_WORD *)(*(_DWORD *)(a2 + 64) + v4 + 4);
    v2 = sub_100195C0(*(_BYTE *)v3);
    v11 = v2;
    if ( v5 > 4u )
    {
      v6 = *(_WORD *)(v3 + 2);
      if ( v6 <= 0x1F4u && 2 * (unsigned int)v6 <= (unsigned int)v5 - 4 && v2 != -1 )
      {
        if ( *(_BYTE *)v3 )
        {
          v7 = sub_1001E7B0((_DWORD *)(a2 + 1), 1u, (int)&unk_1007D19C, 1, 4, -1);
          v2 = sub_1001E7B0((_DWORD *)v3, 1u, (int)&unk_1007D19C, 1, 4, 4);
          if ( v2 >= v7 )
          {
            LOBYTE(v2) = sub_10018A40("..\\lib\\adl\\iop_hsdb_pkt.c", 787, 0, 0);
          }
          else
          {
            v8 = 0;
            v12 = -32705;
            if ( *(_WORD *)(v3 + 2) )
            {
              do
              {
                v13 = *(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20);
                v9 = *(_WORD *)(v3 + 2) - v8;
                if ( v9 >= 100 )
                  LOWORD(v9) = 100;
                LOWORD(v14) = v9;
                memcpy((char *)&v14 + 2, (const void *)(v3 + 2 * v8 + 4), 2 * (unsigned __int16)v9);
                LOBYTE(v2) = sub_10018300(v11, (int)&v12, 50000, 0);
                v8 += v14;
              }
              while ( v8 < *(_WORD *)(v3 + 2) );
            }
          }
        }
        else
        {
          LOBYTE(v2) = sub_1000DC90(*(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20), v3 + 4, v6, 1, 1);
        }
      }
    }
  }
  return v2;
}

//----- (1000DEF0) --------------------------------------------------------
char sub_1000DEF0()
{
  memset(byte_10121030, 0, 0x344u);
  memset(dword_10121028, 0, 0x211u);
  sub_100264F0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_100276D0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10026BA0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_100274C0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10026A70(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10026AD0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_100278F0(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10027950(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10027350(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  sub_10026B20(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
  return sub_10027430(0, 0x344u, (int)dword_10121028, (int)byte_10121030, (int)dword_10121028 + 284664);
}

//----- (1000E070) --------------------------------------------------------
signed int sub_1000E070()
{
  void *v0; // ecx@4
  char *v1; // ecx@6
  unsigned int v2; // eax@6
  signed int result; // eax@11
  int v4; // edi@12
  void **v5; // esi@12
  size_t v6; // eax@13

  if ( sub_10018F80((LONG)&off_1007E06C) )
  {
    memcpy((char *)dword_10121028 + 257156, &unk_10076628, 0x6B74u);
    qmemcpy((char *)dword_10121028 + 284664, &unk_1007D1A0, 0x688u);
  }
  else
  {
    sub_10018A40("..\\lib\\adl\\iop_hsdb_pkt.c", 1037, 1, 0);
  }
  if ( sub_100279E0() == 1 && sub_1001FDE0(v0) == 4 )
  {
    v1 = (char *)dword_10121028;
    v2 = 0;
    do
    {
      if ( *(_DWORD *)&v1[v2 + 257172] )
      {
        *(_DWORD *)&v1[v2 + 257172] += 1500;
        v1 = (char *)dword_10121028;
      }
      v2 += 52;
    }
    while ( v2 < 0x6B74 );
  }
  sub_10018B10((int)&off_1007E06C);
  if ( sub_10018F80((LONG)&off_1007E6B4) )
  {
    v4 = 0;
    v5 = (void **)off_1007D828;
    do
    {
      v6 = sub_1001F880(*v5, 0x28u);
      memcpy((void *)(v4 + dword_1012102C), *v5, v6);
      ++v5;
      v4 += 40;
    }
    while ( (signed int)v5 < (signed int)&off_1007E06C );
    result = sub_10018B10((int)&off_1007E6B4);
  }
  else
  {
    sub_10018A40("..\\lib\\adl\\iop_hsdb_pkt.c", 1087, 1, 0);
    result = sub_10018B10((int)&off_1007E6B4);
  }
  return result;
}
// 1007D828: using guessed type char *off_1007D828[530];
// 1007E06C: using guessed type char *off_1007E06C;
// 1007E6B4: using guessed type char *off_1007E6B4;
// 1012102C: using guessed type int dword_1012102C;

//----- (1000E1A0) --------------------------------------------------------
int sub_1000E1A0()
{
  sub_1000DEF0();
  sub_1000C550((int)&byte_10222BE0);
  return sub_1000C600((int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000E1C0) --------------------------------------------------------
void *sub_1000E1C0()
{
  void *v0; // ecx@1
  char *v1; // ecx@1
  char v2; // al@4
  void *v3; // ecx@4
  void *result; // eax@8

  dword_10121028 = (void *)-15;
  dword_1012102C = -15;
  sub_1000E070();
  dword_10222BF8 = (int)dword_10121028;
  dword_10222BF0 = (int)&unk_1021A820;
  dword_10222BF4 = 22568;
  dword_10222BFC = (int)dword_10121028 + 13228;
  dword_10222C00 = (int)&unk_10076628;
  dword_10222C04 = 12;
  dword_10222C08 = (int)&unk_1007D1A0;
  byte_10222BE1 = 0;
  dword_10222BE4 = 836;
  dword_10222C0C = (int)off_1007D828;
  dword_10222C10 = (int)&unk_10220060;
  dword_10222C14 = 529;
  dword_10222C18 = (int)&unk_1007E080;
  byte_10222BE2 = 3;
  byte_10222BE3 = sub_10026350(v0);
  dword_10222C30 = 0;
  dword_10222C1C = 88;
  dword_10222C20 = (int)dword_10121028 + 532;
  dword_10222C24 = (int)&unk_1021A3E0;
  dword_10222C34 = 0;
  if ( sub_100279E0() == 1 && sub_1001FDE0(v1) == 4 )
  {
    v1 = (char *)dword_10121028 + 257156;
    dword_10222C00 = (int)dword_10121028 + 257156;
  }
  v2 = sub_1001FDE0(v1);
  byte_10222BE0 = v2;
  if ( v2 == 8 )
  {
    byte_10222BE0 = 11;
  }
  else if ( v2 == 4 )
  {
    byte_10222BE0 = 5;
  }
  dword_10222C28 = sub_100206D0(v3);
  dword_10222C2C = (int)dword_10121028 + 286336;
  sub_1000DEF0();
  sub_1000DAA0((int)&byte_10222BE0);
  result = dword_10121028;
  *((_DWORD *)dword_10121028 + 71849) = dword_10222BEC;
  return result;
}
// 1007D828: using guessed type char *off_1007D828[530];
// 1012102C: using guessed type int dword_1012102C;
// 10222BE0: using guessed type char byte_10222BE0;
// 10222BE1: using guessed type char byte_10222BE1;
// 10222BE2: using guessed type char byte_10222BE2;
// 10222BE3: using guessed type char byte_10222BE3;
// 10222BE4: using guessed type int dword_10222BE4;
// 10222BEC: using guessed type int dword_10222BEC;
// 10222BF0: using guessed type int dword_10222BF0;
// 10222BF4: using guessed type int dword_10222BF4;
// 10222BF8: using guessed type int dword_10222BF8;
// 10222BFC: using guessed type int dword_10222BFC;
// 10222C00: using guessed type int dword_10222C00;
// 10222C04: using guessed type int dword_10222C04;
// 10222C08: using guessed type int dword_10222C08;
// 10222C0C: using guessed type int dword_10222C0C;
// 10222C10: using guessed type int dword_10222C10;
// 10222C14: using guessed type int dword_10222C14;
// 10222C18: using guessed type int dword_10222C18;
// 10222C1C: using guessed type int dword_10222C1C;
// 10222C20: using guessed type int dword_10222C20;
// 10222C24: using guessed type int dword_10222C24;
// 10222C28: using guessed type int dword_10222C28;
// 10222C2C: using guessed type int dword_10222C2C;
// 10222C30: using guessed type int dword_10222C30;
// 10222C34: using guessed type int dword_10222C34;

//----- (1000E330) --------------------------------------------------------
int __cdecl sub_1000E330(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1007F51C[a1];
  return result;
}
// 1007F51C: using guessed type __int16 word_1007F51C[];

//----- (1000E350) --------------------------------------------------------
signed int sub_1000E350()
{
  signed int result; // eax@1

  result = -15;
  dword_10121390 = -15;
  dword_1012139C = -15;
  dword_10121378 = -15;
  dword_101213A0 = -15;
  dword_1012138C = -15;
  dword_1012137C = -15;
  dword_10121374 = -15;
  dword_10121388 = -15;
  dword_10121398 = -15;
  dword_10121394 = -15;
  dword_10121384 = -15;
  dword_10121380 = -15;
  return result;
}
// 10121374: using guessed type int dword_10121374;
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 10121380: using guessed type int dword_10121380;
// 10121384: using guessed type int dword_10121384;
// 10121388: using guessed type int dword_10121388;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 10121394: using guessed type int dword_10121394;
// 10121398: using guessed type int dword_10121398;
// 1012139C: using guessed type int dword_1012139C;
// 101213A0: using guessed type int dword_101213A0;

//----- (1000E3A0) --------------------------------------------------------
signed int __usercall sub_1000E3A0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_10018EB0((int)&off_1007F53C);
      break;
    case 0:
      result = sub_10018EB0((int)&off_1007F550);
      break;
    case 1:
      result = sub_10018EB0((int)&off_1007F564);
      break;
    case 2:
      result = sub_10018EB0((int)&off_1007F58C);
      break;
    case 3:
      result = sub_10018EB0((int)&off_1007F578);
      break;
    case 5:
      result = sub_10018EB0((int)&off_1007F5A0);
      break;
    default:
      result = sub_10018EB0(a2);
      break;
  }
  return result;
}
// 1007F53C: using guessed type char *off_1007F53C;
// 1007F550: using guessed type char *off_1007F550;
// 1007F564: using guessed type char *off_1007F564;
// 1007F578: using guessed type char *off_1007F578;
// 1007F58C: using guessed type char *off_1007F58C;
// 1007F5A0: using guessed type char *off_1007F5A0;

//----- (1000E440) --------------------------------------------------------
int __usercall sub_1000E440@<eax>(char a1@<al>)
{
  return sub_10018280(dword_1007F06C[a1]);
}
// 1007F06C: using guessed type int dword_1007F06C[];

//----- (1000E460) --------------------------------------------------------
int __usercall sub_1000E460@<eax>(char a1@<al>)
{
  return sub_100182A0(dword_1007F06C[a1], 10);
}
// 1007F06C: using guessed type int dword_1007F06C[];

//----- (1000E480) --------------------------------------------------------
signed __int16 __usercall sub_1000E480@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_1000E3A0(a1, a1) )
        {
          sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_10121390 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_29;
      }
      sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      result = *(_WORD *)(dword_10222C08 + 2 * a2);
      v3 = (unsigned __int16)result < 0x211u;
      goto LABEL_29;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000E3A0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_10121378 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_29;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000E3A0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101213A0 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_29;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000E3A0(a1, a1) )
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1012138C + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_29;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1000E3A0(a1, a1) )
        {
          result = *(_WORD *)(dword_1012137C + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_29:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 101213A0: using guessed type int dword_101213A0;
// 10222C08: using guessed type int dword_10222C08;

//----- (1000E680) --------------------------------------------------------
char __cdecl sub_1000E680(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@8

  v3 = sub_1000E480(a1, a2);
  if ( v3 != -1 && !sub_1000E460(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10121390);
        sub_1000E440(a1);
        return 1;
      case 0:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10222BF8);
        sub_1000E440(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_10121378;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101213A0);
        sub_1000E440(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1012138C);
        sub_1000E440(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_1012137C;
LABEL_15:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_1000E440(a1);
        return 1;
      default:
LABEL_16:
        sub_1000E440(a1);
        break;
    }
  }
  return 0;
}
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 101213A0: using guessed type int dword_101213A0;
// 10222BF8: using guessed type int dword_10222BF8;

//----- (1000E7D0) --------------------------------------------------------
char __cdecl sub_1000E7D0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_1000E480(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000E3A0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10121390 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        qmemcpy(a3, (const void *)(dword_10222C00 + 52 * (unsigned __int16)v4), 0x34u);
        result = 1;
        break;
      case 1:
        if ( (unsigned __int8)sub_1000E3A0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10121378 + 321708), 0x34u);
        result = 1;
        break;
      case 2:
        result = sub_1000E3A0(a1, v3);
        if ( result != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101213A0 + 326220), 0x34u);
        break;
      case 3:
        if ( (unsigned __int8)sub_1000E3A0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012138C + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_1000E3A0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012137C + 1596), 0x34u);
        result = 1;
        break;
      default:
LABEL_15:
        result = 0;
        break;
    }
  }
  return result;
}
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 101213A0: using guessed type int dword_101213A0;
// 10222C00: using guessed type int dword_10222C00;

//----- (1000E940) --------------------------------------------------------
char __cdecl sub_1000E940(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_1000E480(a1, a2);
  if ( v3 != -1 && !sub_1000E460(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10121390 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_15;
      case 0:
        v5 = dword_10222C20 + 24 * (unsigned __int16)v3;
        goto LABEL_15;
      case 1:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10121378 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_101213A0 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_15;
      case 3:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012138C + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_15;
      case 5:
        if ( (unsigned __int8)sub_1000E3A0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012137C + 24 * (unsigned __int16)v3 + 4;
LABEL_15:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_1000E440(a1);
        return 1;
      default:
LABEL_16:
        sub_1000E440(a1);
        break;
    }
  }
  return 0;
}
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 101213A0: using guessed type int dword_101213A0;
// 10222C20: using guessed type int dword_10222C20;

//----- (1000EA90) --------------------------------------------------------
char __cdecl sub_1000EA90(int a1, int a2, void *a3, char a4, int a5, int a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // ebp@2
  __int16 v9; // si@10
  int v11; // [sp-8h] [bp-570h]@16
  __int16 v12; // [sp+8h] [bp-560h]@12
  __int16 v13; // [sp+3Ch] [bp-52Ch]@9
  char v14; // [sp+40h] [bp-528h]@15
  char v15; // [sp+41h] [bp-527h]@9
  __int16 v16; // [sp+42h] [bp-526h]@9
  char v17; // [sp+44h] [bp-524h]@9
  __int16 v18; // [sp+46h] [bp-522h]@14
  int v19; // [sp+48h] [bp-520h]@15
  char v20; // [sp+4Ch] [bp-51Ch]@14

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_7;
    case 1:
      v8 = 30;
      goto LABEL_7;
    case 2:
      v8 = 31;
      goto LABEL_7;
    case 3:
      v8 = 32;
      goto LABEL_7;
    case 5:
      v8 = 33;
LABEL_7:
      LOBYTE(v7) = sub_1000E3A0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_1000E480(a1, a2);
      if ( v7 == -1 )
        return v7;
      v15 = a6;
      LOBYTE(v7) = a4;
      v13 = -32768;
      v16 = a2;
      v17 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_1000E7D0(a1, a2, &v12) != 1 )
          goto LABEL_15;
        v9 = v12;
      }
      memcpy(&v20, a3, (unsigned __int16)v9);
      v18 = v9;
LABEL_15:
      v19 = sub_100181D0();
      v14 = 0;
      LOBYTE(v7) = sub_10021010(v8, (int)&v13);
      return v7;
    default:
      return v7;
    case 0:
      v11 = sub_100181D0();
      if ( a4 == 1 )
        LOBYTE(v7) = sub_1000D150(a2, a5, a6, (int)&byte_10222BE0, a3, v11);
      else
        LOBYTE(v7) = sub_1000CE40(a2, a6, (int)&byte_10222BE0, a3, v11);
      return v7;
  }
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000EC40) --------------------------------------------------------
char __cdecl sub_1000EC40(char a1, int a2)
{
  unsigned __int16 v2; // ax@1
  int v3; // edi@4
  __int16 v5; // [sp+8h] [bp-52Ch]@1
  __int16 v6; // [sp+Ch] [bp-528h]@10

  memset(&v5, 0, 0x528u);
  v2 = sub_1000E330(a1);
  if ( (unsigned __int16)a2 < v2 )
  {
    v2 = sub_1000E480(a1, a2);
    if ( v2 != -1 )
    {
      LOBYTE(v2) = a1;
      switch ( a1 )
      {
        case 6:
          v3 = 28;
          goto LABEL_10;
        case 0:
          LOBYTE(v2) = sub_1000C020(a2, (int)&byte_10222BE0);
          return v2;
        case 1:
          v3 = 30;
          goto LABEL_10;
        case 2:
          v3 = 31;
          goto LABEL_10;
        case 3:
          v3 = 32;
          goto LABEL_10;
        case 5:
          v3 = 33;
LABEL_10:
          memset(&v5, 0, 0x528u);
          v5 = -32720;
          v6 = a2;
          LOBYTE(v2) = sub_10021010(v3, (int)&v5);
          break;
        default:
          return v2;
      }
    }
  }
  return v2;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000ED50) --------------------------------------------------------
char __cdecl sub_1000ED50(char a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      LOBYTE(v3) = sub_1000D440(a2, a3, (int)&byte_10222BE0);
      return v3;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_1000E480(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10021010(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000EE60) --------------------------------------------------------
char __cdecl sub_1000EE60(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@8
  int v15; // eax@10
  int v16; // eax@12
  int v17; // eax@14
  int v18; // eax@16
  int v19; // eax@24
  char v20; // [sp+7h] [bp-9h]@18
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_100181D0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_1000E480(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_1000E3A0(a1, v7) )
            goto LABEL_29;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_10121390 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_10121390 + 210116;
          v12 = dword_10121390 + 8 * v9;
          v13 = 195164;
          goto LABEL_17;
        case 0:
          v10 = dword_10222BFC;
          v14 = (unsigned __int16)v8;
          v11 = dword_10222C00 + 52 * (unsigned __int16)v8;
          v12 = dword_10222C20 + 24 * v14;
          v13 = 243928;
          goto LABEL_17;
        case 1:
          if ( !(unsigned __int8)sub_1000E3A0(a1, v7) )
            goto LABEL_29;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_10121378 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_10121378 + 321708;
          v12 = dword_10121378 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_17;
        case 2:
          if ( !(unsigned __int8)sub_1000E3A0(a1, v7) )
            goto LABEL_29;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_101213A0 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_101213A0 + 326220;
          v12 = dword_101213A0 + 8 * v16;
          v13 = 311892;
          goto LABEL_17;
        case 3:
          if ( !(unsigned __int8)sub_1000E3A0(a1, v7) )
            goto LABEL_29;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_1012138C + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1012138C + 18832;
          v12 = dword_1012138C + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_17;
        case 5:
          if ( !(unsigned __int8)sub_1000E3A0(a1, v7) )
            goto LABEL_29;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_1012137C + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1012137C + 1596;
          v12 = dword_1012137C + 8 * v18 + 4;
          v13 = 1496;
LABEL_17:
          if ( sub_1000E460(a1) )
            goto LABEL_29;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_32;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_32:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_1000E440(a1);
          result = v20;
          break;
        default:
LABEL_29:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10121374: using guessed type int dword_10121374;
// 10121378: using guessed type int dword_10121378;
// 1012137C: using guessed type int dword_1012137C;
// 10121388: using guessed type int dword_10121388;
// 1012138C: using guessed type int dword_1012138C;
// 10121390: using guessed type int dword_10121390;
// 1012139C: using guessed type int dword_1012139C;
// 101213A0: using guessed type int dword_101213A0;
// 10222BFC: using guessed type int dword_10222BFC;
// 10222C00: using guessed type int dword_10222C00;
// 10222C20: using guessed type int dword_10222C20;

//----- (1000F0D0) --------------------------------------------------------
char __cdecl sub_1000F0D0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_1000EE60(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (1000F100) --------------------------------------------------------
char __cdecl sub_1000F100(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_1000EE60(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (1000F130) --------------------------------------------------------
char __cdecl sub_1000F130(char a1, int a2, void *a3, int a4)
{
  return sub_1000EE60(a1, a2, 0, 0, a3, a4);
}

//----- (1000F160) --------------------------------------------------------
const char *__cdecl sub_1000F160(int a1, unsigned __int16 a2)
{
  int v2; // ecx@1
  const char *result; // eax@1

  v2 = *(_DWORD *)(a1 + 44);
  result = "UNKNOWN";
  if ( v2 )
  {
    if ( a2 <= *(_WORD *)(*(_DWORD *)(a1 + 40) + 2 * *(_DWORD *)(a1 + 4)) )
      result = *(const char **)(v2 + 4 * a2);
  }
  return result;
}

//----- (1000F190) --------------------------------------------------------
int __cdecl sub_1000F190(char a1, int a2)
{
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // ecx@16

  sub_100182A0(*(_DWORD *)(a2 + 60), -1);
  *(_BYTE *)a2 = sub_1001FDE0(v2) | 1;
  if ( a1 == 1 )
  {
    if ( sub_10027A10(2048) )
      v5 = sub_100206D0(v4) | 0x300;
    else
      v5 = sub_100206D0(v4) | 0x83B00;
    *(_DWORD *)(a2 + 72) = v5;
    if ( !sub_10027A10(0x10000) )
      *(_DWORD *)(a2 + 72) |= 0x110000u;
    if ( !sub_10027A10(0x20000) )
      *(_DWORD *)(a2 + 72) |= 0x220000u;
    if ( !sub_10027A10(1024) )
      *(_DWORD *)(a2 + 72) |= 0x400u;
    if ( !sub_10027A10(0x1000000) )
      *(_DWORD *)(a2 + 72) |= 0x3000000u;
    if ( !sub_10027A10(0x4000000) )
      *(_DWORD *)(a2 + 72) |= 0x4000000u;
    if ( !sub_10027A10(0x8000000) )
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 72) |= 0x8000000u;
      sub_10018280(v6);
      return sub_1000DAA0(a2);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 72) = sub_100206D0(v3);
  }
  sub_10018280(*(_DWORD *)(a2 + 60));
  return sub_1000DAA0(a2);
}

//----- (1000F2B0) --------------------------------------------------------
char __cdecl sub_1000F2B0(char a1)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
      result = sub_1000F320();
  }
  else
  {
    LOWORD(v2) = -32757;
    sub_10021140((int)&v2);
    sub_10021150((int)&v2);
    sub_10021160((int)&v2);
    sub_10021180((int)&v2);
    sub_10021170((int)&v2);
    result = sub_10021130((int)&v2);
  }
  return result;
}

//----- (1000F320) --------------------------------------------------------
int sub_1000F320()
{
  return sub_100182D0(2, 0x80000);
}

//----- (1000F330) --------------------------------------------------------
char __thiscall sub_1000F330(void *this)
{
  char result; // al@1
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  dword_101213A4 = 0;
  sub_10019570(75, (_BYTE *)&v2 + 3);
  result = BYTE3(v2);
  if ( BYTE3(v2) == 2 || BYTE3(v2) == 3 )
    result = sub_10018A40("..\\lib\\adl\\iop_stall_warn.c", 123, 0, 0);
  return result;
}
// 101213A4: using guessed type int dword_101213A4;

//----- (1000F370) --------------------------------------------------------
int sub_1000F370()
{
  int result; // eax@1

  result = sub_100181D0();
  if ( (unsigned int)(result - dword_101213A4) > 0xBB8 )
  {
    dword_101213A4 = result;
    result = sub_1001F2C0(7u);
  }
  return result;
}
// 101213A4: using guessed type int dword_101213A4;

//----- (1000F3A0) --------------------------------------------------------
char __thiscall sub_1000F3A0(void *this)
{
  char result; // al@1
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  result = sub_100205A0((bool *)&v2 + 2, (unsigned int)&v2 + 3);
  if ( result )
  {
    if ( BYTE2(v2) )
      result = sub_1000F370();
  }
  return result;
}

//----- (1000F3D0) --------------------------------------------------------
_BYTE *__usercall sub_1000F3D0@<eax>(char a1@<bl>, int a2@<esi>)
{
  signed int v2; // ecx@4
  int v3; // eax@5
  _BYTE *result; // eax@9
  unsigned int v5; // eax@11
  unsigned int v6; // eax@14

  if ( !*(_WORD *)(a2 + 10) && a1 == 3 )
    *(_DWORD *)(a2 + 16) = sub_100181D0();
  v2 = 0;
  if ( *(_BYTE *)(a2 + 184) )
  {
    v3 = a2 + 29;
    do
    {
      *(_BYTE *)(v3 + 7) = a1;
      if ( **(_BYTE **)(a2 + 12) != 3 )
        *(_BYTE *)v3 = 0;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *(_BYTE *)(a2 + 184) );
  }
  result = *(_BYTE **)(a2 + 12);
  if ( *result != a1 )
  {
    if ( !a1 )
    {
      v5 = *(_DWORD *)(a2 + 188);
      if ( v5 < 0xFFFFFFC2 && v5 )
      {
        sub_10019290(*(_DWORD *)(a2 + 188));
        *(_DWORD *)(a2 + 188) = -15;
      }
      v6 = *(_DWORD *)(a2 + 49276);
      if ( v6 < 0xFFFFFFC2 )
      {
        if ( v6 )
        {
          sub_10028650((void *)(a2 + 49160));
          *(_DWORD *)(a2 + 49276) = -15;
        }
      }
    }
    result = *(_BYTE **)(a2 + 12);
    *(_BYTE *)(a2 + 8) = *result;
    *result = a1;
  }
  return result;
}

//----- (1000F470) --------------------------------------------------------
_DWORD *__usercall sub_1000F470@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edx@1
  _DWORD *result; // eax@1
  _DWORD *v4; // ecx@2

  v2 = *(_BYTE *)(a1 + 184);
  result = 0;
  if ( v2 > 0 )
  {
    v4 = (_DWORD *)(a1 + 24);
    do
    {
      if ( *v4 == a2 )
        result = v4;
      v4 += 8;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (1000F490) --------------------------------------------------------
signed int __usercall sub_1000F490@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>)
{
  return sub_10019360(*(_DWORD *)(a2 + 188), a3, a1);
}

//----- (1000F4B0) --------------------------------------------------------
signed int sub_1000F4B0()
{
  if ( !sub_10018F80((LONG)&off_10080FE0) )
    sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 1938, 1, 0);
  *(_BYTE *)dword_10133028 = 0;
  byte_101213A8 = 0;
  return sub_10018B10((int)&off_10080FE0);
}
// 10080FE0: using guessed type char *off_10080FE0;
// 101213A8: using guessed type char byte_101213A8;
// 10133028: using guessed type int dword_10133028;

//----- (1000F530) --------------------------------------------------------
char __usercall sub_1000F530@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10)
{
  int v10; // edi@1
  unsigned int v11; // eax@1
  _DWORD *v12; // edx@5
  unsigned int v13; // eax@5
  const char *v14; // ecx@5
  int v15; // edi@9
  int v16; // eax@10
  _BYTE *v17; // ecx@10
  _BYTE *v18; // edx@10
  int v19; // eax@12
  _BYTE *v20; // ecx@12
  _BYTE *v21; // edx@12
  _BYTE *v22; // ecx@14
  _BYTE *v23; // edx@14
  signed int v24; // eax@17
  unsigned int v25; // eax@20
  char *v26; // ecx@22
  _BYTE *v27; // eax@22
  char v28; // dl@23
  signed int v29; // edx@24
  bool v30; // zf@35
  bool v31; // sf@35

  v10 = a3;
  *(_DWORD *)(a1 + 188) = -15;
  *(_DWORD *)(a1 + 49276) = -15;
  memset((void *)(a1 + 50024), 0, 0x34u);
  v11 = j_FIL_vfs_open(a6, 4, 1792);
  *(_DWORD *)(a1 + 188) = v11;
  if ( (v11 >= 0xFFFFFFC2 || !v11)
    && sub_10019500((int)"/mnt/card0/avtn_rgn.gca")
    && !sub_100286B0(
          (int)"/mnt/card0/avtn_rgn.gca",
          4,
          (void *)(a1 + 49160),
          (int)"Garmin Dont Give Out sYsTem lOader 1543krats&$*%(dh)#2654/*-") )
  {
    v12 = (_DWORD *)a6;
    v13 = 10;
    v14 = "/mnt/card0";
    do
    {
      if ( *v12 != *(_DWORD *)v14 )
        goto LABEL_9;
      v13 -= 4;
      v14 += 4;
      ++v12;
    }
    while ( v13 >= 4 );
    if ( !v13 )
    {
LABEL_17:
      v24 = 0;
      goto LABEL_18;
    }
LABEL_9:
    v15 = *(_BYTE *)v12 - *v14;
    if ( *(_BYTE *)v12 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = (char *)v12 + 1;
      if ( !v16
        || (v15 = *v18 - *v17, *v18 == *v17)
        && ((v19 = v16 - 1, v20 = v17 + 1, v21 = v18 + 1, !v19)
         || (v15 = *v21 - *v20, *v21 == *v20)
         && ((v22 = v20 + 1, v23 = v21 + 1, v19 == 1) || (v15 = *v23 - *v22, *v23 == *v22))) )
      {
        v10 = a3;
        goto LABEL_17;
      }
    }
    v30 = v15 == 0;
    v31 = v15 < 0;
    v10 = a3;
    v24 = 1;
    if ( v31 || v30 )
      v24 = -1;
LABEL_18:
    if ( !v24 )
    {
      *(_DWORD *)(a1 + 50048) = a1 + 192;
      *(_DWORD *)(a1 + 50056) = a1 + 2240;
      *(_DWORD *)(a1 + 50024) = 0;
      *(_DWORD *)(a1 + 50028) = 0;
      *(_WORD *)(a1 + 50032) = 0;
      *(_DWORD *)(a1 + 50040) = 0;
      *(_WORD *)(a1 + 50044) = 0;
      *(_DWORD *)(a1 + 50052) = 2048;
      *(_DWORD *)(a1 + 50060) = 46920;
      *(_DWORD *)(a1 + 50064) = 15;
      *(_BYTE *)(a1 + 50068) = -2;
      *(_DWORD *)(a1 + 50072) = 0xFFFF;
      *(_DWORD *)(a1 + 188) = sub_10029650(a1 + 49160, (char *)(a6 + 11), 4, (void *)(a1 + 49288), a1 + 50024);
    }
  }
  v25 = *(_DWORD *)(a1 + 188);
  if ( v25 < 0xFFFFFFC2 && v25 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 4) = a2;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 144) = v10;
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5) = a4;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140) = a5;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 136) = a9;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 138) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) = a7;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 148) = a8;
    v26 = (char *)a6;
    v27 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 7);
    do
    {
      v28 = *v26;
      *v27++ = *v26++;
    }
    while ( v28 );
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 156) = a10;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 160) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 164) = 1000;
    sub_10019530(
      *(_DWORD *)(a1 + 188),
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168),
      0);
    *(_WORD *)(a1 + 10) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    dword_1012D74C = sub_100181D0();
    **(_BYTE **)(a1 + 12) = 1;
    memset((void *)(a1 + 24), 0, 0xA0u);
    *(_BYTE *)(a1 + 184) = 0;
    v29 = 2;
    do
    {
      v25 = 1 << (v29 - 2);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 - 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      if ( (1 << v29) & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = 1 << v29;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 + 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v29 += 4;
      LOBYTE(v25) = v29 - 2;
    }
    while ( (unsigned int)(v29 - 2) < 0x20 );
  }
  return v25;
}
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1012D74C: using guessed type int dword_1012D74C;

//----- (1000F970) --------------------------------------------------------
char __usercall sub_1000F970@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4)
{
  const void *v4; // edi@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // ecx@5
  int v8; // edi@5
  char result; // al@6
  int v10; // eax@8

  v4 = a1;
  *(_DWORD *)(a2 + 20) = sub_100181D0();
  if ( a3 == 1 )
  {
    v5 = 1;
  }
  else
  {
    if ( a3 == 2 )
    {
      v5 = 0xFFFF;
      v10 = sub_100181D0();
      sub_1000D150(0xFFFF, a4, 1, (int)&byte_10222BE0, v4, v10);
      goto LABEL_5;
    }
    v5 = 0;
  }
  v6 = sub_100181D0();
  sub_1000CE40(v5, 1, (int)&byte_10222BE0, v4, v6);
LABEL_5:
  v7 = *(_DWORD *)(a2 + 12);
  v8 = *(_DWORD *)(v7 + 144);
  if ( v8 == sub_100206D0((void *)v7) || (result = sub_1000D440(v5, v8, (int)&byte_10222BE0)) != 0 )
    result = 1;
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (1000FA00) --------------------------------------------------------
char __cdecl sub_1000FA00(char a1)
{
  char result; // al@3
  __int16 v2; // [sp+8h] [bp-A4h]@1
  char v3; // [sp+Ch] [bp-A0h]@1
  __int16 v4; // [sp+Eh] [bp-9Eh]@1
  int v5; // [sp+10h] [bp-9Ch]@1
  int v6; // [sp+14h] [bp-98h]@1
  char v7; // [sp+18h] [bp-94h]@1
  int v8; // [sp+98h] [bp-14h]@1
  int v9; // [sp+9Ch] [bp-10h]@1
  int v10; // [sp+A0h] [bp-Ch]@1

  memset(&v2, 0, 0xA0u);
  v2 = -32762;
  v5 = *(_DWORD *)(dword_101213BC + 144);
  v3 = *(_BYTE *)(dword_101213BC + 5);
  v6 = *(_DWORD *)(dword_101213BC + 140);
  v4 = *(_WORD *)(dword_101213BC + 136);
  sub_1001F7C0((int)&v7, (_BYTE *)(dword_101213BC + 7), 128);
  v8 = *(_DWORD *)(dword_101213BC + 152);
  v9 = *(_DWORD *)(dword_101213BC + 148);
  v10 = *(_DWORD *)(dword_101213BC + 156);
  sub_1000F3D0(0, (int)&dword_101213B0);
  if ( a1 )
  {
    if ( a1 == 6 )
      result = sub_10021140((int)&v2);
    else
      result = sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 712, 1, 0);
  }
  else
  {
    result = sub_10021150((int)&v2);
  }
  return result;
}
// 101213B0: using guessed type int dword_101213B0;
// 101213BC: using guessed type int dword_101213BC;

//----- (1000FB30) --------------------------------------------------------
int sub_1000FB30()
{
  unsigned int v0; // esi@1
  void (__cdecl *v1)(int); // eax@2
  int result; // eax@5

  dword_10133028 = -15;
  sub_1000F4B0();
  memset(&dword_101213B0, 0, 0xC39Cu);
  dword_10133020 = 0;
  dword_10133024 = 0;
  v0 = 0;
  do
  {
    v1 = (void (__cdecl *)(int))dword_10080F74[v0];
    if ( v1 )
      v1(dword_10080F70[v0]);
    v0 += 4;
  }
  while ( v0 < 28 );
  result = sub_100181D0();
  dword_10133020 = result;
  LOBYTE(dword_10133024) = 0;
  dword_101213BC = dword_10133028;
  dword_1012146C = -15;
  dword_1012D42C = -15;
  byte_101213AA = 0;
  byte_101213A9 = 0;
  return result;
}
// 10080F70: using guessed type int dword_10080F70[];
// 10080F74: using guessed type int dword_10080F74[];
// 101213A9: using guessed type char byte_101213A9;
// 101213AA: using guessed type char byte_101213AA;
// 101213B0: using guessed type int dword_101213B0;
// 101213BC: using guessed type int dword_101213BC;
// 1012146C: using guessed type int dword_1012146C;
// 1012D42C: using guessed type int dword_1012D42C;
// 10133020: using guessed type int dword_10133020;
// 10133024: using guessed type int dword_10133024;
// 10133028: using guessed type int dword_10133028;

//----- (1000FBD0) --------------------------------------------------------
char __cdecl sub_1000FBD0(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9)
{
  if ( strlen(a5) >= 0x80 )
    sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 1375, 1, 0);
  return sub_1000F530((int)&dword_101213B0, a1, a2, a3, a4, (int)a5, a6, a7, a8, a9);
}
// 101213B0: using guessed type int dword_101213B0;

//----- (1000FC40) --------------------------------------------------------
_BYTE *__cdecl sub_1000FC40(char a1)
{
  void *v1; // ecx@4
  char v2; // bl@5
  int v4; // [sp+8h] [bp-18h]@1
  int v5; // [sp+Ch] [bp-14h]@1
  int v6; // [sp+10h] [bp-10h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  int v8; // [sp+18h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( (unsigned __int8)byte_101213B8 >= 2u && *(_BYTE *)dword_101213BC == 5 || *(_BYTE *)dword_101213BC >= 2u )
  {
    LOBYTE(v4) = 2;
    v1 = *(void **)(dword_101213BC + 140);
    v6 = *(_DWORD *)(dword_101213BC + 140);
    v7 = *(_DWORD *)(dword_101213BC + 148);
    LOWORD(v5) = *(_WORD *)(dword_101213BC + 136);
    LOWORD(v1) = v5;
    BYTE1(v4) = *(_BYTE *)(dword_101213BC + 5);
    v8 = sub_100206D0(v1);
    sub_1000F970(&v4, (int)&dword_101213B0, 0, 0x14u);
  }
  dword_101213B0 = sub_100181D0();
  v2 = 5;
  if ( !a1 )
    v2 = 7;
  return sub_1000F3D0(v2, (int)&dword_101213B0);
}
// 101213B0: using guessed type int dword_101213B0;
// 101213B8: using guessed type char byte_101213B8;
// 101213BC: using guessed type int dword_101213BC;

//----- (1000FD00) --------------------------------------------------------
_BYTE *__usercall sub_1000FD00@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  char v4; // bl@1
  int v5; // ecx@3
  signed int v6; // eax@3
  int v7; // edi@4
  _BYTE *v8; // ecx@9

  v3 = a3;
  v4 = (char)result;
  if ( *(_BYTE *)(a2 + 12) != (_BYTE)result )
  {
    *(_BYTE *)(a2 + 12) = (_BYTE)result;
    if ( (_BYTE)result == 7 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 12) + 144) &= ~*(_DWORD *)a2;
      v5 = *(_BYTE *)(a3 + 184);
      v6 = 0;
      if ( v5 > 0 )
      {
        v7 = v3 + 24;
        do
        {
          ++v6;
          if ( v7 == a2 )
            break;
          v7 += 32;
        }
        while ( v6 < *(_BYTE *)(v3 + 184) );
      }
      memcpy_0((void *)a2, (const void *)(a2 + 32), 32 * (v5 - v6));
      v4 = *(_BYTE *)(v3 + 36);
      --*(_BYTE *)(v3 + 184);
    }
    result = 0;
    if ( *(_BYTE *)(v3 + 184) )
    {
      v8 = (_BYTE *)(v3 + 36);
      while ( *v8 == v4 )
      {
        ++result;
        v8 += 32;
        if ( (signed int)result >= *(_BYTE *)(v3 + 184) )
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      if ( v4 == 7 )
        result = sub_1000FC40(0);
      else
        result = sub_1000F3D0(v4, v3);
    }
  }
  return result;
}

//----- (10010020) --------------------------------------------------------
__int16 __usercall sub_10010020@<ax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int v4; // edx@12
  unsigned int v5; // ecx@18
  unsigned int v6; // ebp@18
  unsigned int v7; // edi@27
  int v8; // ecx@27

  v1 = dword_101213BC;
  v2 = a1;
  LOWORD(a1) = *(_WORD *)(a1 + 2);
  if ( (_WORD)a1 == *(_WORD *)(dword_101213BC + 136) )
  {
    LODWORD(a1) = sub_1000F470((int)&dword_101213B0, *(_DWORD *)(v2 + 28));
    v3 = a1;
    if ( (_DWORD)a1 )
    {
      if ( *(_BYTE *)v2 != 1 )
      {
        HIDWORD(a1) = a1;
        LOBYTE(a1) = 7;
        LOWORD(a1) = (unsigned int)sub_1000FD00((_BYTE *)a1, SHIDWORD(a1), (int)&dword_101213B0);
        return a1;
      }
      if ( *(_BYTE *)v1 != 3
        || (LODWORD(a1) = *(_DWORD *)(v1 + 168), *(_DWORD *)(v2 + 4) != (_DWORD)a1)
        || (LODWORD(a1) = *(_DWORD *)(v2 + 8), (_DWORD)a1) )
      {
        if ( *(_BYTE *)(v2 + 1) < 2u )
          return a1;
        LODWORD(a1) = *(_DWORD *)(v2 + 8);
        v5 = *(_DWORD *)(v3 + 20);
        HIDWORD(a1) = *(_DWORD *)(v2 + 4);
        v6 = *(_DWORD *)(v3 + 16);
        if ( (unsigned int)a1 <= v5 && ((unsigned int)a1 < v5 || HIDWORD(a1) <= v6) )
        {
          if ( (unsigned int)a1 < v5 || (unsigned int)a1 <= v5 && HIDWORD(a1) < v6 )
            return a1;
          *(_DWORD *)(v1 + 168) = HIDWORD(a1);
          sub_10019530(dword_1012146C, *(_DWORD *)(dword_101213BC + 152) + *(_DWORD *)(dword_101213BC + 168), 0);
          if ( (unsigned __int8)++byte_1012146A > 5u )
            byte_1012146A = 5;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v3 + 28) = sub_100181D0();
        LOWORD(a1) = *(_WORD *)(v2 + 24);
        *(_WORD *)(v3 + 24) = a1;
        if ( *(_BYTE *)dword_101213BC == 3 )
        {
          v7 = *(_DWORD *)(dword_101213BC + 168);
          v8 = *(_DWORD *)(dword_101213BC + 148);
          if ( v7 != v8 || *(_DWORD *)(v3 + 16) == v8 && !*(_DWORD *)(v3 + 20) )
          {
            a1 = *(_QWORD *)(v3 + 16) + (unsigned __int16)a1;
            if ( v7 < a1 )
            {
              LOBYTE(a1) = byte_101213B8;
              LOWORD(a1) = (unsigned int)sub_1000FD00((_BYTE *)a1, v3, (int)&dword_101213B0);
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(v3 + 5) = 1;
        word_101213BA = 0;
        dword_101213C4 = 0;
        if ( *(_BYTE *)(v2 + 1) >= 1u && byte_101213B8 == 4 )
        {
          *(_WORD *)(dword_101213BC + 138) = *(_WORD *)(v2 + 16);
          LODWORD(a1) = *(_DWORD *)(v2 + 12);
          *(_DWORD *)(dword_101213BC + 160) = a1;
        }
        if ( *(_BYTE *)(v2 + 1) < 2u )
        {
          byte_1012146B = 1;
          byte_10121469 = 1;
          byte_1012146A = 0;
          *(_WORD *)(v3 + 24) = 1000;
        }
        else
        {
          v4 = *(_DWORD *)(v2 + 8) | *(_DWORD *)(v2 + 4);
          if ( !*(_QWORD *)(v2 + 4) )
          {
            byte_1012146B = *(_BYTE *)(v2 + 8) | *(_BYTE *)(v2 + 4);
            byte_10121469 = 25;
            byte_1012146A = v4;
          }
          LODWORD(a1) = sub_100181D0();
          *(_DWORD *)(v3 + 28) = a1;
          LOWORD(a1) = *(_WORD *)(v2 + 24);
          *(_WORD *)(v3 + 24) = a1;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        LOBYTE(a1) = byte_101213B8;
        LOWORD(a1) = (unsigned int)sub_1000FD00((_BYTE *)a1, v3, (int)&dword_101213B0);
      }
    }
  }
  return a1;
}
// 101213B0: using guessed type int dword_101213B0;
// 101213B8: using guessed type char byte_101213B8;
// 101213BA: using guessed type __int16 word_101213BA;
// 101213BC: using guessed type int dword_101213BC;
// 101213C4: using guessed type int dword_101213C4;
// 10121469: using guessed type char byte_10121469;
// 1012146A: using guessed type char byte_1012146A;
// 1012146B: using guessed type char byte_1012146B;
// 1012146C: using guessed type int dword_1012146C;

//----- (10010230) --------------------------------------------------------
char __thiscall sub_10010230(void *this)
{
  int v1; // esi@1
  signed int v2; // eax@1
  int v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@8
  int v6; // ecx@10
  char result; // al@11
  int v8; // eax@13
  unsigned int v9; // ebp@13
  int v10; // eax@13
  unsigned int v11; // ebx@14
  int v12; // eax@16
  int v13; // ecx@18
  int v14; // [sp+10h] [bp-7FCh]@2
  int v15; // [sp+14h] [bp-7F8h]@1
  __int16 v16; // [sp+18h] [bp-7F4h]@1
  char v17; // [sp+1Ah] [bp-7F2h]@25
  int v18; // [sp+1Ch] [bp-7F0h]@18
  char v19; // [sp+20h] [bp-7ECh]@16
  size_t v20; // [sp+408h] [bp-404h]@16
  int v21; // [sp+40Ch] [bp-400h]@12
  __int16 v22; // [sp+410h] [bp-3FCh]@1
  char v23; // [sp+412h] [bp-3FAh]@25
  int v24; // [sp+414h] [bp-3F8h]@25
  size_t v25; // [sp+418h] [bp-3F4h]@25
  int v26; // [sp+41Ch] [bp-3F0h]@25
  char v27; // [sp+420h] [bp-3ECh]@25

  v1 = (int)this;
  memset(&v16, 0, 0x3F8u);
  memset(&v22, 0, 0x3F8u);
  v15 = sub_100181D0();
  v2 = *(_BYTE *)(v1 + 184);
  byte_101213A8 = 0;
  v3 = v1 + 24;
  if ( v2 > 1 )
  {
    v4 = v1 + 72;
    v14 = v2 - 1;
    do
    {
      if ( *(_QWORD *)v4 + (unsigned __int64)*(_WORD *)(v4 + 8) < *(_QWORD *)(v3 + 16)
                                                                + (unsigned __int64)*(_WORD *)(v3 + 24) )
        v3 = v4 - 16;
      v4 += 32;
      --v14;
    }
    while ( v14 );
  }
  if ( *(_WORD *)(v1 + 10) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) = *(_DWORD *)(v3 + 16);
    sub_10019530(
      *(_DWORD *)(v1 + 188),
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
      0);
    if ( *(_WORD *)(v1 + 10) > 1u )
    {
      v5 = *(_DWORD *)(v1 + 12);
      if ( *(_DWORD *)(v5 + 164) < 0x3E8u )
        *(_DWORD *)(v5 + 164) = 1000;
    }
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( *(_DWORD *)(v6 + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
    return (unsigned int)sub_1000F3D0(3, v1);
  v16 = *(_WORD *)(v6 + 136);
  v21 = sub_100206D0((void *)v6);
  while ( 1 )
  {
    v8 = sub_100181D0();
    dword_101213AC = v8;
    v9 = v8 - v15;
    v10 = *(_DWORD *)(v1 + 12);
    if ( *(_DWORD *)(v10 + 168) < *(_DWORD *)(v10 + 148) )
      break;
    result = (unsigned int)sub_1000F3D0(4, v1);
LABEL_31:
    if ( **(_BYTE **)(v1 + 12) != 2 || v9 >= 0x23 )
      return result;
  }
  v11 = *(_DWORD *)(v10 + 148) - *(_DWORD *)(v10 + 168);
  if ( v11 > *(_DWORD *)(v10 + 164) )
    v11 = *(_DWORD *)(v10 + 164);
  v12 = sub_1000F490(v11, v1, &v19);
  v20 = v12;
  if ( v12 != v11 )
  {
    v20 = 0;
    sub_1000FC40(1);
    v12 = v20;
  }
  v13 = *(_DWORD *)(v1 + 12);
  v18 = *(_DWORD *)(v13 + 168);
  if ( (unsigned int)(v18 + v12) > *(_DWORD *)(v13 + 148) )
  {
    v12 = *(_DWORD *)(v13 + 148) - v18;
    v20 = *(_DWORD *)(v13 + 148) - v18;
  }
  *(_DWORD *)(v13 + 168) += v12;
  if ( *(_BYTE *)(v1 + 187)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_DWORD *)(*(_DWORD *)(v1 + 12) + 148)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
  {
    sub_1000F3D0(3, v1);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v1 + 12) + 164) >= 0x3E8u )
  {
    result = sub_1000F970(&v16, v1, 1, 0x3F8u);
  }
  else
  {
    v22 = v16;
    v24 = v18;
    v25 = v20;
    v23 = v17;
    v26 = v21;
    memcpy(&v27, &v19, v20);
    result = sub_1000F970(&v22, v1, 2, v25 + 16);
  }
  if ( result )
    goto LABEL_31;
  *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) -= v20;
  return sub_10019530(
           *(_DWORD *)(v1 + 188),
           *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
           0);
}
// 101213A8: using guessed type char byte_101213A8;
// 101213AC: using guessed type int dword_101213AC;

//----- (10010550) --------------------------------------------------------
_BYTE *__usercall sub_10010550@<eax>(int a1@<esi>)
{
  _BYTE *result; // eax@1
  bool v2; // zf@1
  int v3; // edi@4
  int v4; // eax@8
  int v5; // eax@8
  void *v6; // ecx@8
  _BYTE *v7; // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int (__cdecl *v10)(int, _DWORD, _DWORD, _DWORD); // edx@10
  signed int v11; // [sp+0h] [bp-20h]@3
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  _BYTE *v16; // [sp+18h] [bp-8h]@1

  result = 0;
  v2 = *(_BYTE *)(a1 + 184) == 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
    result = sub_1000FC40(0);
  v11 = 0;
  if ( *(_BYTE *)(a1 + 184) )
  {
    v3 = a1 + 24;
    do
    {
      if ( *(_BYTE *)(v3 + 4) == 1 )
      {
        if ( *(_BYTE *)(v3 + 5) == 1 )
        {
          LOBYTE(result) = 2;
          sub_1000FD00(result, v3, a1);
        }
        else
        {
          byte_101213A8 = 1;
          v4 = sub_100181D0();
          LOBYTE(v12) = 0;
          dword_101213AC = v4;
          v5 = *(_DWORD *)(a1 + 12);
          v6 = *(void **)(v5 + 140);
          v14 = *(_DWORD *)(v5 + 140);
          v15 = *(_DWORD *)(v5 + 148);
          LOWORD(v13) = *(_WORD *)(v5 + 136);
          LOWORD(v6) = v13;
          BYTE1(v12) = *(_BYTE *)(v5 + 5);
          v7 = (_BYTE *)sub_100206D0(v6);
          v16 = v7;
          LOBYTE(v7) = 3;
          sub_1000FD00(v7, v3, a1);
          sub_1000F970(&v12, a1, 0, 0x14u);
        }
      }
      else
      {
        v8 = sub_1001E7B0((_DWORD *)v3, 4u, (int)dword_10080F70, 16, 7, 8);
        if ( v8 < 8 )
        {
          v9 = 4 * v8;
          v10 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_10080F78 + v9 * 4);
          if ( v10 )
            *(_BYTE *)(v3 + 4) = v10(
                                   dword_10080F70[v9],
                                   *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5),
                                   *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140),
                                   *(_WORD *)(*(_DWORD *)(a1 + 12) + 136));
        }
      }
      if ( (double)(unsigned int)(sub_100181D0() - dword_1012D74C) > 600000.0 )
        sub_1000FC40(0);
      result = (_BYTE *)(v11 + 1);
      v3 += 32;
      ++v11;
    }
    while ( v11 < *(_BYTE *)(a1 + 184) );
  }
  return result;
}
// 10080F70: using guessed type int dword_10080F70[];
// 10080F78: using guessed type int (__cdecl *off_10080F78)(int, char, int, __int16);
// 101213A8: using guessed type char byte_101213A8;
// 101213AC: using guessed type int dword_101213AC;
// 1012D74C: using guessed type int dword_1012D74C;

//----- (100107D0) --------------------------------------------------------
char __thiscall sub_100107D0(int this)
{
  int v1; // esi@1
  unsigned __int8 v2; // cl@1
  char v3; // dl@1
  _BYTE *v4; // eax@2
  int v5; // edi@2
  int v6; // eax@6
  void *v7; // ecx@7
  __int16 v9; // cx@9
  signed int v10; // eax@11
  _DWORD *v11; // ecx@12
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  int v16; // [sp+18h] [bp-8h]@1

  v1 = this;
  v2 = *(_BYTE *)(this + 184);
  v3 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
  {
    v4 = (_BYTE *)(v1 + 29);
    v5 = v2;
    do
    {
      if ( *v4 == 1 )
        ++v3;
      v4 += 32;
      --v5;
    }
    while ( v5 );
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( v2 != v3 )
  {
    LOBYTE(v12) = 1;
    v7 = *(void **)(v6 + 140);
    v14 = *(_DWORD *)(v6 + 140);
    v15 = *(_DWORD *)(v6 + 148);
    LOWORD(v13) = *(_WORD *)(v6 + 136);
    LOWORD(v7) = v13;
    BYTE1(v12) = *(_BYTE *)(v6 + 5);
    v16 = sub_100206D0(v7);
    sub_1000F3D0(3, v1);
    return sub_1000F970(&v12, v1, 0, 0x14u);
  }
  if ( *(_WORD *)(v6 + 136) == 74 )
  {
    v9 = *(_WORD *)(v6 + 138);
    if ( v9 == -1 )
    {
      sub_1000FC40(0);
      return sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 2939, 0, 0);
    }
    sub_10020890(*(_BYTE *)(v6 + 4), v9, *(_DWORD *)(v6 + 160));
  }
  v10 = 0;
  if ( *(_BYTE *)(v1 + 184) )
  {
    v11 = (_DWORD *)(v1 + 32);
    do
    {
      *v11 = 0;
      ++v10;
      v11 += 8;
    }
    while ( v10 < *(_BYTE *)(v1 + 184) );
  }
  *(_DWORD *)(v1 + 4) = sub_100181D0();
  return (unsigned int)sub_1000F3D0(6, v1);
}

//----- (10010940) --------------------------------------------------------
char __cdecl sub_10010940(int a1, int a2)
{
  char result; // al@2
  unsigned __int64 v3; // rax@6
  void *v4; // ecx@6
  void *v5; // ecx@8
  int v6; // [sp+8h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  int v13; // [sp+24h] [bp-Ch]@1
  int v14; // [sp+28h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v6 = 0;
  if ( (_WORD)a1 == 2 )
  {
    result = sub_1000DA50(2, a2, &v7);
    if ( !result )
      return result;
    BYTE2(v11) = BYTE1(v7);
    BYTE1(v7) = 0;
  }
  else
  {
    result = sub_1000DA70(a1, a2, &v7, (unsigned __int16 *)&v6);
  }
  if ( result )
  {
    LODWORD(v3) = sub_1000C2A0(a1, a2);
    LOBYTE(v4) = BYTE1(v7);
    if ( BYTE1(v7) <= 1u )
      goto LABEL_10;
    if ( BYTE1(v7) == 2 )
    {
      v14 = v3;
      LODWORD(v3) = sub_100206D0(v4);
      if ( !((unsigned int)v3 & v14) )
      {
LABEL_11:
        LODWORD(v3) = &v7;
        return sub_10010020(v3);
      }
      LODWORD(v3) = sub_100206D0(v5);
LABEL_10:
      v14 = v3;
      goto LABEL_11;
    }
    result = sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 1177, 0, 0);
  }
  return result;
}

//----- (10010A40) --------------------------------------------------------
void __thiscall sub_10010A40(int *this)
{
  char v1; // bl@9
  signed int v2; // ebp@9
  int *v3; // edi@10
  unsigned int v4; // eax@11
  bool v5; // zf@19
  int v6; // eax@35
  int v7; // eax@36
  int (__cdecl *v8)(int, _DWORD, _DWORD, _DWORD); // edx@36
  int v9; // eax@47
  int v10; // edi@47
  int *v11; // [sp+0h] [bp-4h]@9

  switch ( *(_BYTE *)dword_101213BC )
  {
    case 1:
      sub_10010550((int)&dword_101213B0);
      return;
    case 2:
      sub_10010230(&dword_101213B0);
      return;
    case 3:
      v9 = sub_100181D0();
      v10 = v9;
      if ( byte_101213A8 == 1 )
      {
        if ( (double)(unsigned int)(v9 - dword_101213AC) <= 12000.0 )
        {
          if ( (double)(unsigned int)(v9 - *(&dword_101213B0 + 4)) > 360000.0 )
            sub_1000FC40(0);
        }
        else
        {
          sub_1000F3D0(1, (int)&dword_101213B0);
        }
      }
      if ( (double)(unsigned int)(v10 - dword_101213AC) <= 360000.0 )
      {
        if ( *((_BYTE *)&dword_101213B0 + 8) == 2
          && *(_DWORD *)(*(&dword_101213B0 + 3) + 164) < 0x3E8u
          && (unsigned int)(v10 - *(&dword_101213B0 + 5)) >= 0x3E8 )
        {
          sub_1000F3D0(2, (int)&dword_101213B0);
          ++*((_WORD *)&dword_101213B0 + 5);
        }
      }
      else
      {
        sub_1000FC40(0);
      }
      return;
    case 4:
      sub_100107D0((int)&dword_101213B0);
      return;
    case 6:
      v11 = this;
      v1 = 0;
      v2 = 0;
      if ( *((_BYTE *)&dword_101213B0 + 184) )
      {
        v3 = &dword_101213B0 + 6;
        while ( 1 )
        {
          v4 = *v3;
          v11 = v3;
          if ( (unsigned int)*v3 > 0x4000 )
            break;
          if ( *v3 == 0x4000 )
            goto LABEL_35;
          if ( v4 > 0x200 )
          {
            if ( v4 > 0x1000 )
            {
              v5 = v4 == 0x2000;
            }
            else
            {
              if ( v4 == 4096 || v4 == 1024 )
                goto LABEL_35;
              v5 = v4 == 2048;
            }
LABEL_34:
            if ( !v5 )
              goto LABEL_39;
            goto LABEL_35;
          }
          if ( v4 != 512 )
          {
            switch ( v4 )
            {
              case 0x10u:
              case 0x20u:
              case 0x40u:
              case 0x80u:
              case 0x100u:
                goto LABEL_35;
              default:
                break;
            }
LABEL_39:
            v1 = 1;
            goto LABEL_40;
          }
LABEL_35:
          v6 = sub_1001E7B0(v3, 4u, (int)dword_10080F70, 16, 7, 8);
          if ( v6 < 8 )
          {
            v7 = 4 * v6;
            v8 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_10080F7C + v7 * 4);
            if ( v8 )
            {
              v1 = v8(
                     dword_10080F70[v7],
                     *(_BYTE *)(*(&dword_101213B0 + 3) + 5),
                     *(_DWORD *)(*(&dword_101213B0 + 3) + 140),
                     *(_WORD *)(*(&dword_101213B0 + 3) + 136));
              if ( v1 != 1 )
                ++v3[2];
              goto LABEL_40;
            }
            goto LABEL_39;
          }
LABEL_40:
          ++v2;
          v3 += 8;
          if ( v2 >= *((_BYTE *)&dword_101213B0 + 184) )
            goto LABEL_41;
        }
        if ( v4 > 0x200000 )
        {
          if ( v4 > 0x4000000 )
          {
            v5 = v4 == 0x8000000;
          }
          else
          {
            if ( v4 == 0x4000000 || v4 == 0x1000000 )
              goto LABEL_35;
            v5 = v4 == 0x2000000;
          }
        }
        else
        {
          if ( v4 == 0x200000 )
            goto LABEL_35;
          if ( v4 > 0x20000 )
          {
            if ( v4 == 0x80000 )
              goto LABEL_35;
            v5 = v4 == 0x100000;
          }
          else
          {
            if ( v4 == 0x20000 || v4 == 0x8000 )
              goto LABEL_35;
            v5 = v4 == 0x10000;
          }
        }
        goto LABEL_34;
      }
LABEL_41:
      if ( v11[2] > 500 )
        sub_1000FC40(0);
      if ( v1 == 1
        && (unsigned int)(sub_100181D0() - *(&dword_101213B0 + 1)) >= *(_DWORD *)(*(&dword_101213B0 + 3) + 156) )
      {
        sub_1000F3D0(0, (int)&dword_101213B0);
      }
      return;
    case 5:
    case 7:
      if ( (unsigned int)(sub_100181D0() - dword_101213B0) >= 0x1388 )
      {
        byte_101213A8 = 0;
        dword_1012D74C = 0;
        sub_1000F3D0(0, (int)&dword_101213B0);
      }
      return;
    case 0:
      return;
    default:
      sub_10018A40("..\\lib\\adl\\iop_upld_mngr.c", 1268, 1, 0);
      return;
  }
}
// 10080F70: using guessed type int dword_10080F70[];
// 10080F7C: using guessed type int (__cdecl *off_10080F7C)(int, int, int, __int16);
// 101213A8: using guessed type char byte_101213A8;
// 101213AC: using guessed type int dword_101213AC;
// 101213B0: using guessed type int dword_101213B0;
// 101213BC: using guessed type int dword_101213BC;
// 1012D74C: using guessed type int dword_1012D74C;

//----- (10010AD0) --------------------------------------------------------
char sub_10010AD0()
{
  char result; // al@1

  result = 0;
  dword_101330B4 = (int)&byte_101330B8;
  byte_101330B8 = 0;
  byte_101330B9 = 0;
  return result;
}
// 101330B4: using guessed type int dword_101330B4;
// 101330B8: using guessed type char byte_101330B8;
// 101330B9: using guessed type char byte_101330B9;

//----- (10010AF0) --------------------------------------------------------
char __cdecl sub_10010AF0(int a1, int a2)
{
  char v2; // al@2
  int v3; // ecx@6
  signed int v4; // eax@6
  int v5; // eax@16
  int v7; // [sp-30h] [bp-44h]@4
  char *v8; // [sp-2Ch] [bp-40h]@4
  char v9; // [sp+Bh] [bp-9h]@1
  char v10; // [sp+Ch] [bp-8h]@4
  char v11; // [sp+10h] [bp-4h]@4

  v9 = 0;
  if ( sub_1000DA50(a1, a2, &v9) == 1 )
  {
    v2 = v9;
    if ( (v9 & 0x27) == 39 )
    {
      if ( (_WORD)a1 == 174 )
      {
        sub_10018540(10024, (int)&v10, 4);
        sub_10018540(10020, (int)&v11, 4);
        sub_10018670(10020, (int)&v10, 4);
        v8 = &v11;
        v7 = 10024;
      }
      else
      {
        sub_10018540(10025, (int)&v10, 4);
        sub_10018540(10021, (int)&v11, 4);
        sub_10018670(10021, (int)&v10, 4);
        v8 = &v11;
        v7 = 10025;
      }
      sub_10018670(v7, (int)v8, 4);
      LOBYTE(v4) = sub_1001D380(v3);
      sub_1001D2C0(v4, 1);
      v2 = v9;
    }
    if ( (v2 & 0x2C) == 44 )
    {
      if ( (_WORD)a1 == 174 )
        sub_1001E460(57);
      else
        sub_1001E460(58);
      v2 = v9;
    }
    if ( (v2 & 0x2D) == 45 )
    {
      if ( (_WORD)a1 == 174 )
        sub_1001E570(0x39u);
      else
        sub_1001E570(0x3Au);
    }
  }
  v5 = sub_100181D0();
  return sub_1000CE40(a1, 0, a2, &v9, v5);
}

//----- (10010C30) --------------------------------------------------------
char __cdecl sub_10010C30(unsigned int a1)
{
  int v1; // esi@1
  int v2; // eax@7
  int v4; // [sp-10h] [bp-18h]@2
  unsigned int *v5; // [sp-Ch] [bp-14h]@2
  int *v6; // [sp-4h] [bp-Ch]@2
  unsigned int v7; // [sp+4h] [bp-4h]@1

  v1 = a1;
  v7 = 117950;
  if ( (_WORD)a1 == 185 )
  {
    v6 = (int *)&v7;
    v5 = &a1;
    v4 = 10021;
  }
  else
  {
    v6 = (int *)&v7;
    v5 = &a1;
    v4 = 10020;
  }
  sub_10018600(v4, v5, 4, v6);
  if ( a1 < 0x1A5E0 || a1 > 0x1CCBE )
    a1 = v7;
  v2 = sub_100181D0();
  return sub_1000CE40(v1, 1, (int)&byte_10222BE0, &a1, v2);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10010CB0) --------------------------------------------------------
char __cdecl sub_10010CB0(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  bool v4; // bl@2
  __int16 v5; // ax@3
  char v6; // al@6
  int v7; // edx@11
  int *v8; // eax@15
  void *v9; // ecx@20
  int v10; // ST10_4@21
  int v11; // eax@22
  int v12; // ST10_4@23
  int v13; // ecx@24
  int v15; // [sp-Ch] [bp-40h]@15
  char v16; // [sp+4h] [bp-30h]@1
  bool v17; // [sp+4h] [bp-30h]@2
  int v18; // [sp+8h] [bp-2Ch]@1
  float v19; // [sp+Ch] [bp-28h]@1
  char v20; // [sp+10h] [bp-24h]@24
  int v21; // [sp+1Ch] [bp-18h]@1
  unsigned int v22; // [sp+20h] [bp-14h]@1
  int v23; // [sp+24h] [bp-10h]@1
  int v24; // [sp+28h] [bp-Ch]@1
  int v25; // [sp+2Ch] [bp-8h]@1

  v19 = 0.0;
  v16 = 0;
  v18 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v3 = sub_100255A0(v2);
  if ( !v3 )
  {
    v4 = 0;
    v17 = 0;
LABEL_3:
    v5 = v21;
    goto LABEL_4;
  }
  if ( v3 == 1 )
  {
    v6 = sub_10029870(3, &v21);
  }
  else
  {
    if ( v3 == 2 )
      v16 = 4;
    v6 = sub_10029870(v16, &v21);
  }
  v4 = v6;
  v17 = v6;
  if ( v6 != 1 )
    goto LABEL_3;
  v5 = v21;
  v7 = v21 & 0x100;
  v4 = v7 != 256;
  v17 = v7 != 256;
LABEL_4:
  switch ( (unsigned __int16)a1 )
  {
    case 0xBEu:
    case 0xBFu:
      if ( v4 == 1 )
      {
        v17 = (v5 & 0x200) == 512;
        if ( v17 )
        {
          if ( sub_10029840(v22) == 1 )
          {
            v18 = 0;
            v17 = 0;
            v15 = sub_100181D0();
            v8 = &v18;
            goto LABEL_33;
          }
          v18 = (SHIWORD(v23) - 0x8000) << 16;
          v17 = 1;
        }
      }
      v15 = sub_100181D0();
      v8 = &v18;
      goto LABEL_33;
    case 0xC0u:
    case 0xC1u:
      if ( v4 != 1 )
        goto LABEL_23;
      v17 = (v5 & 0x200) == 512;
      if ( !v17 )
        goto LABEL_23;
      if ( sub_10029840(v22) == 1 )
      {
        v18 = 0;
        v10 = sub_100181D0();
        LOBYTE(v5) = sub_1000CE40(a1, 0, a2, &v18, v10);
      }
      else
      {
        v11 = sub_1001D3C0(v9);
        v18 = ((SHIWORD(v23) - 0x8000) << 16) - v11;
        v17 = 1;
LABEL_23:
        v12 = sub_100181D0();
        LOBYTE(v5) = sub_1000CE40(a1, v17, a2, &v18, v12);
      }
      return v5;
    case 0xBCu:
    case 0xBDu:
      sub_10025810((int)&v20);
      if ( !sub_1001D380(v13) && !v20 )
        goto LABEL_31;
      if ( v4 == 1 )
      {
        v17 = (v21 & 0x200) != 512;
        if ( v17 )
        {
          if ( sub_10029840(v22) == 1 )
          {
            v17 = 1;
            v19 = (double)SHIWORD(v23) * 0.00001220703143189894;
          }
          else
          {
            v19 = 0.0;
LABEL_31:
            v17 = 0;
          }
        }
      }
      v15 = sub_100181D0();
      v8 = (int *)&v19;
LABEL_33:
      LOBYTE(v5) = sub_1000CE40(a1, v17, a2, v8, v15);
      break;
    default:
      return v5;
  }
  return v5;
}

//----- (10010F20) --------------------------------------------------------
char __cdecl sub_10010F20(char a1)
{
  int v1; // ecx@0
  char result; // al@2
  int v3; // eax@3
  int v4; // eax@4
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v1;
  BYTE3(v5) = 35;
  if ( a1 == 3 )
  {
    v4 = sub_100181D0();
    sub_1000CE40(175, 1, (int)&byte_10222BE0, (char *)&v5 + 3, v4);
    result = sub_1000D440(175, 0xFFFFFFF, (int)&byte_10222BE0);
  }
  else
  {
    result = a1 - 4;
    if ( a1 == 4 )
    {
      v3 = sub_100181D0();
      sub_1000CE40(182, 1, (int)&byte_10222BE0, (char *)&v5 + 3, v3);
      result = sub_1000D440(182, 0xFFFFFFF, (int)&byte_10222BE0);
    }
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10010FA0) --------------------------------------------------------
char __cdecl sub_10010FA0(char a1)
{
  int v1; // ecx@0
  char result; // al@2
  int v3; // eax@3
  int v4; // eax@4
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v1;
  BYTE3(v5) = 43;
  if ( a1 == 3 )
  {
    v4 = sub_100181D0();
    sub_1000CE40(175, 1, (int)&byte_10222BE0, (char *)&v5 + 3, v4);
    result = sub_1000D440(175, 0xFFFFFFF, (int)&byte_10222BE0);
  }
  else
  {
    result = a1 - 4;
    if ( a1 == 4 )
    {
      v3 = sub_100181D0();
      sub_1000CE40(182, 1, (int)&byte_10222BE0, (char *)&v5 + 3, v3);
      result = sub_1000D440(182, 0xFFFFFFF, (int)&byte_10222BE0);
    }
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10011020) --------------------------------------------------------
char __cdecl sub_10011020(__int16 a1)
{
  char result; // al@2
  bool v2; // bl@5
  int v3; // ecx@6
  unsigned __int8 v4; // dl@7
  signed int v5; // ebx@7
  char v6; // al@8
  unsigned __int8 v7; // [sp+1h] [bp-Bh]@3
  unsigned __int8 v8; // [sp+2h] [bp-Ah]@3
  char v9; // [sp+3h] [bp-9h]@3
  int v10; // [sp+4h] [bp-8h]@5
  int v11; // [sp+8h] [bp-4h]@5

  if ( sub_10029A40() )
  {
    result = 0;
  }
  else
  {
    v9 = 53;
    sub_10018600(2012, &v7, 1, &v9);
    sub_10018600(2013, &v8, 1, &v9);
    if ( (sub_100299F0(552) || sub_100299F0(557))
      && (v2 = sub_10018540(10020, (int)&v10, 4) == 0, (sub_10018540(10021, (int)&v11, 4) == 0 && v2) == 1)
      && (v3 = v10, v10 == v11) )
    {
      v4 = v8;
      LOBYTE(v3) = v7;
      v5 = (v7 - v8 - ((v7 - (unsigned int)v8) >> 31)) ^ ((signed int)(v7 - v8 - ((v7 - (unsigned int)v8) >> 31)) >> 31);
      if ( v5 < 6 )
      {
        v6 = sub_1001D380(v3);
        v4 = v8;
        LOBYTE(v3) = v7;
        if ( v6 == 2 )
        {
          if ( v8 >= v7 )
            LOBYTE(v3) = v5 - 6 + v7;
          else
            LOBYTE(v3) = 6 - v5 + v7;
        }
        else if ( v7 >= v8 )
        {
          v4 = v5 - 6 + v8;
        }
        else
        {
          v4 = 6 - v5 + v8;
        }
      }
    }
    else
    {
      LOBYTE(v3) = v7;
      v4 = v8;
    }
    result = v3;
    if ( a1 == 834 )
      result = v4;
  }
  return result;
}

//----- (10011140) --------------------------------------------------------
char __usercall sub_10011140@<al>(__int16 a1@<si>)
{
  char result; // al@1
  void *v2; // ecx@3
  int v3; // eax@9
  char v4; // [sp+0h] [bp-1Ch]@3
  int v5; // [sp+4h] [bp-18h]@1
  int v6; // [sp+8h] [bp-14h]@1
  int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  int v9; // [sp+14h] [bp-8h]@1

  result = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a1 == 176 )
  {
    result = dword_101330B4;
    if ( *(_BYTE *)dword_101330B4 )
      return result;
    sub_1001E460(55);
    v4 = 3;
    *(_BYTE *)dword_101330B4 = 1;
  }
  else
  {
    if ( a1 != 183 || *(_BYTE *)(dword_101330B4 + 1) )
      return result;
    sub_1001E460(56);
    v4 = 4;
    *(_BYTE *)(dword_101330B4 + 1) = 1;
  }
  if ( sub_1001FDE0(v2) != 8 )
  {
    sub_10010F20(v4);
    sub_10010FA0(v4);
  }
  v3 = sub_100181D0();
  return sub_1000CE40(a1, 0, (int)&byte_10222BE0, &v5, v3);
}
// 101330B4: using guessed type int dword_101330B4;
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10011200) --------------------------------------------------------
char __cdecl sub_10011200(int a1)
{
  int v1; // eax@3
  char v3; // [sp+7h] [bp-1h]@1

  v3 = sub_10011020(a1);
  if ( (unsigned __int8)v3 > 0x3Fu )
    v3 = 53;
  v1 = sub_100181D0();
  return sub_1000CE40(a1, 1, (int)&byte_10222BE0, &v3, v1);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10011240) --------------------------------------------------------
char __usercall sub_10011240@<al>(__int16 *a1@<eax>, __int16 a2@<cx>)
{
  __int16 v2; // ax@1

  v2 = *a1;
  if ( v2 & 1 && v2 & 2 )
  {
    if ( !(v2 & 8) || !(v2 & 4) )
    {
      if ( a2 == 176 )
        LOBYTE(v2) = sub_1001E570(0x37u);
      else
        LOBYTE(v2) = sub_1001E570(0x38u);
    }
  }
  else
  {
    LOBYTE(v2) = sub_10011140(a2);
  }
  return v2;
}

//----- (10011280) --------------------------------------------------------
char __cdecl sub_10011280(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1
  int v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  int v7; // [sp+14h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  result = sub_1000DA50(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10011240((__int16 *)&v3, a1);
  return result;
}

//----- (100112E0) --------------------------------------------------------
BOOL __cdecl sub_100112E0(float a1)
{
  return (LODWORD(a1) & 0x7F800000) != 2139095040;
}

//----- (10011300) --------------------------------------------------------
int sub_10011300()
{
  int result; // eax@1

  result = sub_100181D0();
  dword_1021A3D0 = result;
  return result;
}
// 1021A3D0: using guessed type int dword_1021A3D0;

//----- (10011310) --------------------------------------------------------
__int16 __usercall sub_10011310@<ax>(int a1@<esi>, unsigned __int8 a2, int a3)
{
  __int16 v3; // bx@1
  _BYTE *v4; // edi@1
  signed int v5; // ebp@1
  double v6; // st7@5
  bool v7; // zf@5
  __int64 v9; // [sp+14h] [bp-Ch]@5
  float v10; // [sp+1Ch] [bp-4h]@5

  v3 = 0;
  v4 = &unk_100820B1;
  v5 = 8;
  do
  {
    if ( *(v4 - 1) )
    {
      if ( *(v4 - 1) == 1 )
      {
        v7 = (*(_BYTE *)(a1 + 2) & *v4) == 0;
      }
      else if ( *(v4 - 1) == 3 )
      {
        v7 = (unsigned __int8)sub_1001F990(*(float *)(a1 + 16), *(float *)(a1 + 36)) == 1;
      }
      else
      {
        *((float *)&v9 + 1) = *(float *)(a1 + 4);
        v6 = *(float *)(a1 + 28);
        LODWORD(v9) = 0;
        v10 = v6;
        LODWORD(v9) = *(_BYTE *)(a1 + 3);
        v7 = sub_1001B4E0(a2, (int)&v9) == 1;
      }
    }
    else
    {
      v7 = (*(_BYTE *)(a3 + 1) & *v4) == 0;
    }
    v4 += 2;
    --v5;
    v3 = v7 | (unsigned __int16)(2 * v3);
  }
  while ( v5 );
  return v3;
}

//----- (100113C0) --------------------------------------------------------
char __usercall sub_100113C0@<al>(__int16 a1@<ax>)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0x94:
    case 0x96:
    case 0x9C:
      result = 0;
      break;
    case 0x95:
    case 0x97:
    case 0x9D:
      result = 1;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_waas.c", 582, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10011420) --------------------------------------------------------
bool __cdecl sub_10011420(char a1, __int16 a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // bl@1

  v3 = sub_1001EAF0(v2);
  v4 = sub_1001EA70(v3, 2);
  return sub_10029A90(a1, 0, a2) == v4;
}

//----- (10011450) --------------------------------------------------------
char __usercall sub_10011450@<al>(__int16 a1@<si>)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@1
  int v3; // eax@5
  int v5; // [sp+Ch] [bp-34h]@1
  float v6; // [sp+10h] [bp-30h]@1
  float v7; // [sp+14h] [bp-2Ch]@1
  char v8; // [sp+18h] [bp-28h]@1
  char v9; // [sp+1Bh] [bp-25h]@1
  float v10; // [sp+1Ch] [bp-24h]@1
  float v11; // [sp+20h] [bp-20h]@7
  float v12; // [sp+24h] [bp-1Ch]@8
  float v13; // [sp+28h] [bp-18h]@9
  float v14; // [sp+2Ch] [bp-14h]@10
  float v15; // [sp+30h] [bp-10h]@11
  float v16; // [sp+34h] [bp-Ch]@1
  float v17; // [sp+38h] [bp-8h]@13
  float v18; // [sp+3Ch] [bp-4h]@14

  v1 = sub_1000DA50(a1, (int)&byte_10222BE0, &v8);
  v6 = v10;
  v5 = 0;
  v7 = v16;
  LOBYTE(v5) = v9;
  v2 = sub_100113C0(a1);
  if ( v1 && v2 < 2u && !sub_1001B4E0(v2, (int)&v5) )
    sub_1001B7E0();
  LOBYTE(v3) = sub_10011420(36, a1);
  if ( (_BYTE)v3 )
  {
    LOBYTE(v3) = 0;
    if ( (LODWORD(v10) & 0x7F800000) != 2139095040
      && (LODWORD(v11) & 0x7F800000) != 2139095040
      && (LODWORD(v12) & 0x7F800000) != 2139095040 )
    {
      LOBYTE(v3) = 0;
      if ( (LODWORD(v13) & 0x7F800000) != 2139095040 )
      {
        v3 = sub_100112E0(v14);
        if ( v3 )
        {
          v3 = sub_100112E0(v15);
          if ( v3 )
          {
            v3 = sub_100112E0(v16);
            if ( v3 )
            {
              v3 = sub_100112E0(v17);
              if ( v3 )
              {
                v3 = sub_100112E0(v18);
                if ( v3 )
                {
                  if ( v1 )
                    LOBYTE(v3) = sub_1001B760();
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (100115C0) --------------------------------------------------------
void __usercall sub_100115C0(int a1@<esi>)
{
  double v1; // ST10_8@2
  char v2; // dl@10
  __int16 v3; // [sp+Ch] [bp-4Ch]@0
  char v4; // [sp+18h] [bp-40h]@2
  float v5; // [sp+28h] [bp-30h]@7
  float v6; // [sp+2Ch] [bp-2Ch]@8
  float v7; // [sp+30h] [bp-28h]@9
  float v8; // [sp+34h] [bp-24h]@10
  float v9; // [sp+38h] [bp-20h]@6
  double v10; // [sp+3Ch] [bp-1Ch]@2

  if ( sub_10011420(35, v3) )
  {
    sub_1000DA50(a1, (int)&byte_10222BE0, &v4);
    v1 = v10;
    if ( (HIDWORD(v1) & 0x7FF00000) != 2146435072
      && v10 <= 6.2831853071796
      && v10 >= -6.2831853071796
      && sub_1001D550(6.2831853071796, -6.2831853071796)
      && (LODWORD(v9) & 0x7F800000) != 2139095040
      && (LODWORD(v5) & 0x7F800000) != 2139095040
      && sub_100112E0(v6)
      && sub_100112E0(v7)
      && sub_100112E0(v8) )
    {
      if ( v2 )
        sub_1001B770();
    }
  }
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10011700) --------------------------------------------------------
char __usercall sub_10011700@<al>(__int16 a1@<si>)
{
  char result; // al@1
  char v2; // [sp+0h] [bp-38h]@1

  memset(&v2, 0, 0x34u);
  result = sub_10011420(39, a1);
  if ( result == 1 )
  {
    result = sub_1000DA50(a1, (int)&byte_10222BE0, &v2);
    if ( result == 1 )
      result = sub_1001B780(&v2);
  }
  return result;
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10011760) --------------------------------------------------------
unsigned __int8 __usercall sub_10011760@<al>(__int16 a1@<si>)
{
  unsigned __int8 result; // al@1
  int v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  result = sub_1000DA50(a1, (int)&byte_10222BE0, &v2);
  if ( result )
  {
    result = sub_100113C0(a1);
    if ( result < 2u )
    {
      if ( v4 & 0x107 )
        sub_1001E570(word_100820C0[result]);
      result = sub_10011420(42, a1);
      if ( result )
        result = sub_1001B7D0();
    }
  }
  return result;
}
// 100820C0: using guessed type __int16 word_100820C0[];
// 10222BE0: using guessed type char byte_10222BE0;

//----- (100117F0) --------------------------------------------------------
char __usercall sub_100117F0@<al>(char a1@<al>)
{
  return sub_1001EA90(2, a1);
}

//----- (10011800) --------------------------------------------------------
char __usercall sub_10011800@<al>(char a1@<dl>, __int16 a2@<cx>, int a3@<edi>)
{
  __int16 v3; // si@1
  char v4; // bl@1
  int v5; // eax@11
  unsigned int v6; // ebp@15
  int v7; // edx@17
  int v8; // ecx@17
  int v9; // ecx@18
  int v10; // esi@18
  int v11; // ebx@18
  int v12; // ecx@19
  int v13; // ecx@20
  unsigned __int8 v14; // al@21
  int v15; // eax@24
  int v16; // edx@24
  int v17; // ecx@24
  int v18; // ebx@25
  int v19; // esi@25
  int v20; // ecx@26
  int v21; // ecx@27
  unsigned __int8 v22; // al@28
  char v23; // bl@29
  char result; // al@29
  char v25; // al@34
  char v26; // [sp+Fh] [bp-EDh]@1
  int v27; // [sp+10h] [bp-ECh]@1
  int v28; // [sp+14h] [bp-E8h]@1
  int v29; // [sp+18h] [bp-E4h]@1
  int v30; // [sp+1Ch] [bp-E0h]@1
  int v31; // [sp+20h] [bp-DCh]@15
  int v32; // [sp+24h] [bp-D8h]@15
  unsigned int v33; // [sp+28h] [bp-D4h]@15
  int v34; // [sp+30h] [bp-CCh]@1
  int v35; // [sp+34h] [bp-C8h]@1
  int v36; // [sp+38h] [bp-C4h]@1
  int v37; // [sp+3Ch] [bp-C0h]@1
  int v38; // [sp+40h] [bp-BCh]@1
  int v39; // [sp+44h] [bp-B8h]@1
  int v40; // [sp+48h] [bp-B4h]@1
  int v41; // [sp+4Ch] [bp-B0h]@1
  int v42; // [sp+50h] [bp-ACh]@1
  int v43; // [sp+54h] [bp-A8h]@1
  int v44; // [sp+58h] [bp-A4h]@1
  int v45; // [sp+5Ch] [bp-A0h]@1
  int v46; // [sp+60h] [bp-9Ch]@1
  int v47; // [sp+64h] [bp-98h]@1
  int v48; // [sp+68h] [bp-94h]@1
  int v49; // [sp+6Ch] [bp-90h]@1
  int v50; // [sp+70h] [bp-8Ch]@1
  int v51; // [sp+74h] [bp-88h]@1
  int v52; // [sp+78h] [bp-84h]@1
  int v53; // [sp+7Ch] [bp-80h]@1
  char v54; // [sp+80h] [bp-7Ch]@1
  char v55; // [sp+BCh] [bp-40h]@1

  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v3 = a2;
  v4 = a1;
  memset(&v55, 0, 0x3Cu);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  memset(&v54, 0, 0x3Cu);
  sub_10029AD0(35, 0, &v26, &v28);
  sub_10029AD0(36, 0, &v26, &v30);
  sub_10029AD0(35, 1u, &v26, &v29);
  sub_10029AD0(36, 1u, &v26, &v27);
  if ( v3 != (_WORD)v28 && v3 != (_WORD)v30 && v3 != (_WORD)v29 && v3 != (_WORD)v27
    || v4 != 35 && v4 != 36
    || (unsigned __int16)v28 >= 0x344u
    || (unsigned __int16)v30 >= 0x344u
    || (unsigned __int16)v29 >= 0x344u
    || (unsigned __int16)v27 >= 0x344u
    || (v5 = *(_DWORD *)(a3 + 40), *(_WORD *)(v5 + 2 * (unsigned __int16)v28) == -1)
    || *(_WORD *)(v5 + 2 * (unsigned __int16)v30) == -1
    || *(_WORD *)(v5 + 2 * (unsigned __int16)v29) == -1
    || *(_WORD *)(v5 + 2 * (unsigned __int16)v27) == -1 )
  {
    result = sub_10018A40("..\\lib\\adl\\iop_waas.c", 481, 0, 0);
  }
  else
  {
    v6 = sub_100181D0();
    v33 = v6;
    v32 = 0;
    v31 = 0;
    if ( sub_1000DA50(v28, a3, &v54) )
    {
      if ( sub_1000DA50(v30, a3, &v34) )
      {
        v7 = *(_DWORD *)(a3 + 64);
        v8 = 2 * (unsigned __int16)v28;
        if ( *(_DWORD *)(v7 + 24 * *(_WORD *)(*(_DWORD *)(a3 + 40) + v8) + 16) )
        {
          v9 = *(_WORD *)(v8 + *(_DWORD *)(a3 + 40));
          v10 = *(_DWORD *)(a3 + 32);
          v11 = *(_DWORD *)(a3 + 36);
          if ( v6 <= v11 + *(_DWORD *)(v7 + 24 * v9 + 16) + (*(_DWORD *)(52 * v9 + v10 + 16) >> 1) )
          {
            v12 = 2 * (unsigned __int16)v30;
            if ( *(_DWORD *)(v7 + 24 * *(_WORD *)(v12 + *(_DWORD *)(a3 + 40)) + 16) )
            {
              v13 = *(_WORD *)(v12 + *(_DWORD *)(a3 + 40));
              if ( v6 <= v11 + *(_DWORD *)(v7 + 24 * v13 + 16) + (*(_DWORD *)(52 * v13 + v10 + 16) >> 1) )
              {
                v14 = sub_100113C0(v28);
                v32 = (unsigned __int16)sub_10011310((int)&v34, v14, (int)&v54);
              }
            }
          }
        }
      }
    }
    if ( sub_1000DA50(v29, a3, &v55) )
    {
      if ( sub_1000DA50(v27, a3, &v44) )
      {
        v15 = *(_DWORD *)(a3 + 40);
        v16 = *(_DWORD *)(a3 + 64);
        v17 = 2 * (unsigned __int16)v29;
        if ( *(_DWORD *)(v16 + 24 * *(_WORD *)(v17 + v15) + 16) )
        {
          v18 = *(_DWORD *)(a3 + 36);
          v19 = *(_DWORD *)(a3 + 32);
          v6 = v33;
          if ( v33 <= v18
                    + *(_DWORD *)(v16 + 24 * *(_WORD *)(v17 + v15) + 16)
                    + (*(_DWORD *)(v19 + 52 * *(_WORD *)(v17 + v15) + 16) >> 1) )
          {
            v20 = 2 * (unsigned __int16)v27;
            if ( *(_DWORD *)(v16 + 24 * *(_WORD *)(v20 + v15) + 16) )
            {
              v21 = *(_WORD *)(v20 + *(_DWORD *)(a3 + 40));
              if ( v33 <= v18 + *(_DWORD *)(v16 + 24 * v21 + 16) + (*(_DWORD *)(52 * v21 + v19 + 16) >> 1) )
              {
                v22 = sub_100113C0(v29);
                v31 = (unsigned __int16)sub_10011310((int)&v44, v22, (int)&v55);
              }
            }
          }
        }
      }
    }
    v23 = sub_1001EB00();
    result = v31;
    if ( (unsigned __int16)v31 >= (unsigned __int16)v32 )
    {
      if ( (unsigned __int16)v31 > (unsigned __int16)v32 )
        v23 = 1;
    }
    else
    {
      v23 = 0;
    }
    if ( v6 - dword_1021A3D0 > 0x3E8 )
    {
      v25 = sub_1001EAF0((void *)(v6 - dword_1021A3D0));
      result = sub_1001EA70(v25, 2);
      if ( v23 != result )
      {
        dword_1021A3D0 = v6;
        result = sub_100117F0(v23);
      }
    }
  }
  return result;
}
// 1021A3D0: using guessed type int dword_1021A3D0;

//----- (10011BF0) --------------------------------------------------------
void __cdecl sub_10011BF0(int a1, int a2)
{
  switch ( (unsigned __int16)a1 )
  {
    case 0x94u:
    case 0x95u:
      sub_10011800(35, a1, a2);
      sub_100115C0(a1);
      break;
    case 0x96u:
    case 0x97u:
      sub_10011800(36, a1, a2);
      sub_10011450(a1);
      break;
    case 0x8Eu:
    case 0x8Fu:
      sub_10011700(a1);
      break;
    case 0x9Cu:
    case 0x9Du:
      sub_10011760(a1);
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_waas.c", 257, 0, 0);
      break;
  }
}

//----- (10011C90) --------------------------------------------------------
bool __usercall sub_10011C90@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  bool v2; // bl@3
  bool result; // al@7
  char v4; // [sp+17h] [bp-9h]@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1

  v1 = sub_1000F0D0(6, 660, 0, 4, &v5);
  v4 = sub_1000F0D0(6, 661, 0, 4, &v6);
  v2 = v1 && !sub_10024EE0((int)&v5, -3.1415927, 3.1415927, COERCE_INT(0.0), 0);
  result = v4 && !sub_10024EE0((int)&v6, -3.1415927, 3.1415927, COERCE_INT(0.0), 0);
  if ( v2 )
  {
    if ( result )
    {
      result = 1;
      *a1 = (*(float *)&v6 + *(float *)&v5) * 0.5;
    }
    else
    {
      result = v2;
      *a1 = *(float *)&v5;
    }
  }
  else if ( result )
  {
    *a1 = *(float *)&v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10011D80) --------------------------------------------------------
char __usercall sub_10011D80@<al>(int a1@<esi>)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-8h]@0
  char v3; // [sp+7h] [bp-1h]@1

  v3 = 4;
  sub_10029B10((int)&v3, v2);
  if ( a1 == 1 )
    result = sub_1000EA90(0, 611, &v3, 0, 1, 1);
  else
    result = sub_1000EA90(0, 647, &v3, 0, 1, 1);
  return result;
}

//----- (10011DD0) --------------------------------------------------------
int __usercall sub_10011DD0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@2

  if ( a1 == 1 )
    result = sub_10018670(9929, a2, 1);
  else
    result = sub_10018670(9930, a2, 1);
  return result;
}

//----- (10011E00) --------------------------------------------------------
int __usercall sub_10011E00@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@2

  if ( a1 == 1 )
    result = sub_10018670(9921, a2, 1);
  else
    result = sub_10018670(9922, a2, 1);
  return result;
}

//----- (10011E30) --------------------------------------------------------
char __thiscall sub_10011E30(void *this)
{
  char v1; // al@3
  bool v2; // zf@7
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = this;
  BYTE3(v4) = 3;
  sub_10029B10((int)&byte_101330C6, dword_101330D0);
  sub_10029B10((int)&byte_101330C4, dword_101330E0);
  if ( sub_1001FD00(dword_101330E0) )
  {
    if ( (unsigned __int8)byte_101330C4 >= 5u )
    {
      v1 = byte_101330C4;
      if ( (unsigned __int8)byte_101330C6 > (unsigned int)(unsigned __int8)byte_101330C4 )
        v1 = byte_101330C6;
    }
    else
    {
      v1 = byte_101330C6;
    }
    BYTE3(v4) = v1;
    sub_10011DD0(dword_101330D0, (int)&v4 + 3);
    if ( byte_101330C6 != 4 )
      return sub_1001E460(227);
    v2 = byte_101330C4 == 4;
  }
  else
  {
    BYTE3(v4) = byte_101330C6;
    sub_10011DD0(dword_101330D0, (int)&v4 + 3);
    v2 = byte_101330C6 == 4;
  }
  if ( v2 )
    return sub_1001E570(0xE3u);
  return sub_1001E460(227);
}
// 101330C4: using guessed type char byte_101330C4;
// 101330C6: using guessed type char byte_101330C6;
// 101330D0: using guessed type int dword_101330D0;
// 101330E0: using guessed type int dword_101330E0;

//----- (10011EF0) --------------------------------------------------------
char sub_10011EF0()
{
  char result; // al@1
  char v1; // bl@14
  int v2; // esi@24
  double v3; // st7@24
  float v4; // ST54_4@24
  int v5; // eax@24
  int v6; // eax@24
  int v7; // esi@24
  int v8; // eax@24
  int v9; // eax@24
  int v10; // esi@24
  int v11; // eax@24
  int v12; // eax@24
  int v13; // eax@24
  int v14; // esi@24
  int v15; // eax@24
  int v16; // esi@24
  int v17; // eax@24
  int v18; // eax@24
  float v19; // ST54_4@26
  double v20; // st6@26
  float v21; // ST54_4@26
  int v22; // eax@26
  int v23; // esi@26
  int v24; // eax@26
  float v25; // ST54_4@26
  double v26; // st7@26
  int v27; // eax@29
  float v28; // ST54_4@29
  double v29; // st7@31
  double v30; // st6@34
  char v31; // cl@47
  void *v32; // ecx@50
  double v33; // rtt@55
  double v34; // st6@55
  double v35; // st7@55
  char v36; // [sp+13h] [bp-81h]@14
  float v37; // [sp+14h] [bp-80h]@28
  float v38; // [sp+18h] [bp-7Ch]@16
  int v39; // [sp+1Ch] [bp-78h]@24
  int v40; // [sp+20h] [bp-74h]@24
  int v41; // [sp+24h] [bp-70h]@24
  int v42; // [sp+28h] [bp-6Ch]@24
  int v43; // [sp+2Ch] [bp-68h]@24
  float v44; // [sp+30h] [bp-64h]@20
  float v45; // [sp+34h] [bp-60h]@23
  float v46; // [sp+38h] [bp-5Ch]@14
  int v47; // [sp+3Ch] [bp-58h]@24
  int v48; // [sp+40h] [bp-54h]@24
  int v49; // [sp+44h] [bp-50h]@24
  int v50; // [sp+48h] [bp-4Ch]@24
  int v51; // [sp+4Ch] [bp-48h]@24
  float v52; // [sp+50h] [bp-44h]@1
  float v53; // [sp+54h] [bp-40h]@24
  double v54; // [sp+58h] [bp-3Ch]@24
  float v55; // [sp+60h] [bp-34h]@1
  int v56; // [sp+64h] [bp-30h]@24
  int v57; // [sp+68h] [bp-2Ch]@19
  int v58; // [sp+6Ch] [bp-28h]@17
  float v59; // [sp+70h] [bp-24h]@21
  float v60; // [sp+74h] [bp-20h]@22
  int v61; // [sp+78h] [bp-1Ch]@24
  int v62; // [sp+7Ch] [bp-18h]@18
  char v63; // [sp+80h] [bp-14h]@23
  char v64; // [sp+84h] [bp-10h]@24
  char v65; // [sp+88h] [bp-Ch]@24
  double v66; // [sp+8Ch] [bp-8h]@26

  result = dword_101330D0;
  v55 = 0.0;
  v52 = 0.0;
  if ( dword_101330D0 == 1 || dword_101330D0 == 2 )
  {
    if ( !byte_101330C5 )
    {
      byte_101330C6 = 2;
      goto LABEL_50;
    }
    if ( dword_101330E4 )
      --dword_101330E4;
    if ( dword_10133414 )
      --dword_10133414;
    if ( dword_10133408 )
      --dword_10133408;
    if ( dword_10133410 )
      --dword_10133410;
    if ( dword_1013340C )
    {
      --dword_1013340C;
      return result;
    }
    sub_10029B10((int)&byte_101330C6, dword_101330D0);
    sub_10029B10((int)&byte_101330C4, dword_101330E0);
    v36 = 0;
    v1 = sub_10029CF0(&v52);
    v46 = v52;
    if ( v1 || (v1 = sub_10029C80(&v55), v46 = v55, v1) )
    {
      if ( sub_10011C90(&v38)
        && sub_10029B90(&v58)
        && sub_10029B80(&v62)
        && sub_10029BD0(1, &v57)
        && sub_1001EEB0(&v44)
        && sub_1001D950(&v59)
        && sub_1001DA60(&v60)
        && sub_1001DAC0((float *)&v63, &v45) )
      {
        v45 = -v45;
        v36 = 1;
        sub_10029B50((int)&v49, v59);
        v2 = v57 - v49;
        sub_1004C8B0(v58, &v56, &v47);
        sub_1004C8B0(v62, &v42, &v40);
        sub_1004C8B0(v2, (int *)&v64, (int *)&v65);
        sub_10029B50((int)&v61, v38);
        sub_1004C8B0(v61, &v39, &v41);
        sub_1004C8B0(v57, &v48, &v43);
        sub_1004C8B0(v49, &v50, &v51);
        v3 = v60 * 4.656612873077393e-10;
        v38 = (double)v51 * v3;
        v4 = v3 * (double)v50;
        v5 = sub_1004C690(v47, v39);
        v6 = sub_1004C690(v42, v5);
        v7 = sub_1004C690(v43, v6);
        v8 = sub_1004C690(v56, v39);
        v9 = sub_1004C690(v48, v8);
        v54 = v38;
        v10 = v9 + v7;
        v11 = sub_1004C690(v40, v41);
        LODWORD(v38) = v10 + sub_1004C690(v43, v11);
        v53 = v54 - (double)SLODWORD(v38) * 4.656612873077393e-10 * v44;
        v54 = v4;
        v12 = sub_1004C690(v47, v39);
        v13 = sub_1004C690(v42, v12);
        v14 = sub_1004C690(v48, v13);
        v15 = sub_1004C690(v56, v39);
        v16 = v14 - sub_1004C690(v43, v15);
        v17 = sub_1004C690(v40, v41);
        v18 = sub_1004C690(v48, v17);
        v38 = v54 - (double)(v18 + v16) * 4.656612873077393e-10 * v44;
        if ( v44 < 1.0 || (unsigned int)dword_101330DC < 2 )
        {
          v26 = 0.0;
        }
        else
        {
          v19 = (v38 * 3.0 - flt_101330C8 * 4.0 + flt_101330CC) / 0.1000000014901161;
          v20 = -v19 * 4.656612873077393e-10 * (double)v50;
          v21 = (3.0 * v53 - 4.0 * flt_101330D4 + flt_101330D8) / 0.1000000014901161;
          *(float *)&v54 = 4.656612873077393e-10 * -v21 * (double)v51 + v20;
          v66 = v45;
          v22 = sub_1004C690(v40, v39);
          v23 = sub_1004C690(v47, v22);
          v24 = sub_1004C690(-v42, v41);
          dword_10133410 = 60;
          v25 = v66 - (double)(v24 + v23) * 4.656612873077393e-10 * v44;
          v26 = *(float *)&v54 / 9.806650161743164 - v25 / v44;
        }
        v37 = v26;
        flt_101330D8 = flt_101330D4;
        flt_101330D4 = v53;
        flt_101330CC = flt_101330C8;
        flt_101330C8 = v38;
        if ( (unsigned int)dword_101330DC < 2 )
          ++dword_101330DC;
LABEL_29:
        v27 = dword_101330C0;
        v28 = v37 * 2.248739242553711;
        flt_10133418 = flt_10133418
                     + (v28 - flt_10133418) * 0.0029411765281111
                     - flt_101330E8[dword_101330C0] * 0.001633254112675786;
        flt_101330E8[dword_101330C0] = v28;
        dword_101330C0 = v27 + 1;
        if ( (unsigned int)(v27 + 1) >= 0xC8 )
          dword_101330C0 = 0;
        v29 = v46;
        if ( v36 && v29 >= 10.0 && v29 <= 320.0 )
        {
          v30 = flt_10133418;
          if ( flt_10133418 < -0.1049000024795532 )
          {
            if ( byte_101330C6 != 6 && byte_101330C4 != 6 )
              sub_1001F230(0x2Bu);
            dword_101330E4 = 60;
            byte_101330C6 = 6;
            goto LABEL_50;
          }
          if ( dword_101330E4 )
            goto LABEL_50;
          if ( v30 <= 0.1049000024795532 )
          {
            v31 = byte_101330C6;
            goto LABEL_53;
          }
          if ( byte_101330C6 != 5 && byte_101330C4 != 5 )
          {
            sub_1001F230(0x2Cu);
            v29 = v46;
            v30 = flt_10133418;
          }
          v31 = 5;
          dword_10133414 = 60;
          byte_101330C6 = 5;
        }
        else
        {
          v31 = byte_101330C6;
          v30 = flt_10133418;
        }
        if ( dword_101330E4 )
          goto LABEL_50;
LABEL_53:
        if ( dword_10133414 )
          goto LABEL_50;
        if ( v1 )
        {
          v33 = v30;
          v34 = v29;
          v35 = v33;
          if ( v34 > 460.0 || v36 || dword_10133410 )
          {
LABEL_58:
            if ( !dword_10133408 )
            {
              if ( v31 == 6 )
              {
                if ( v35 <= -0.039999999 )
                  goto LABEL_50;
              }
              else if ( v31 == 5 )
              {
                if ( v35 >= 0.039999999 )
                  goto LABEL_50;
              }
              else if ( v31 != 4 && v31 != 1 )
              {
                goto LABEL_50;
              }
              byte_101330C6 = 3;
            }
LABEL_50:
            sub_10011E00(dword_101330D0, (int)&byte_101330C6);
            sub_10011E30(v32);
            return sub_10011D80(dword_101330D0);
          }
        }
        else
        {
          v35 = v30;
          if ( dword_10133410 )
            goto LABEL_58;
        }
        dword_10133408 = 60;
        byte_101330C6 = 4;
        goto LABEL_50;
      }
      v36 = 0;
    }
    dword_101330DC = 0;
    v37 = 0.0;
    goto LABEL_29;
  }
  return result;
}
// 101330C0: using guessed type int dword_101330C0;
// 101330C4: using guessed type char byte_101330C4;
// 101330C5: using guessed type char byte_101330C5;
// 101330C6: using guessed type char byte_101330C6;
// 101330C8: using guessed type float flt_101330C8;
// 101330CC: using guessed type float flt_101330CC;
// 101330D0: using guessed type int dword_101330D0;
// 101330D4: using guessed type float flt_101330D4;
// 101330D8: using guessed type float flt_101330D8;
// 101330DC: using guessed type int dword_101330DC;
// 101330E0: using guessed type int dword_101330E0;
// 101330E4: using guessed type int dword_101330E4;
// 101330E8: using guessed type float flt_101330E8[];
// 10133408: using guessed type int dword_10133408;
// 1013340C: using guessed type int dword_1013340C;
// 10133410: using guessed type int dword_10133410;
// 10133414: using guessed type int dword_10133414;
// 10133418: using guessed type float flt_10133418;

//----- (10012650) --------------------------------------------------------
char __thiscall sub_10012650(void *this)
{
  void *v1; // ecx@6
  void *v2; // ecx@1
  int v3; // eax@3
  int v5; // [sp-2h] [bp-4h]@6

  if ( sub_100206D0(this) == 1 )
  {
    dword_101330D0 = 1;
    dword_101330E0 = 2;
  }
  else
  {
    v3 = sub_100206D0(v2);
    if ( v3 != 2 )
    {
      dword_101330D0 = 0;
      dword_101330E0 = 0;
      return v3;
    }
    dword_101330D0 = 2;
    dword_101330E0 = 1;
  }
  LOBYTE(v3) = sub_10018540(6801, (int)&byte_101330C5, 1);
  if ( byte_101330C5 )
  {
    flt_10133418 = 0.0;
    memset(flt_101330E8, 0, 0x320u);
    dword_101330C0 = 0;
    dword_101330DC = 0;
    dword_101330E4 = 0;
    dword_10133414 = 0;
    dword_10133408 = 0;
    dword_10133410 = 0;
    v5 = 0;
    BYTE3(v5) = 1;
    dword_1013340C = 300;
    sub_10011E00(dword_101330D0, (int)&v5 + 3);
    sub_10011E30(v1);
    LOBYTE(v3) = sub_10011D80(dword_101330D0);
  }
  return v3;
}
// 101330C0: using guessed type int dword_101330C0;
// 101330C5: using guessed type char byte_101330C5;
// 101330D0: using guessed type int dword_101330D0;
// 101330DC: using guessed type int dword_101330DC;
// 101330E0: using guessed type int dword_101330E0;
// 101330E4: using guessed type int dword_101330E4;
// 101330E8: using guessed type float flt_101330E8[];
// 10133408: using guessed type int dword_10133408;
// 1013340C: using guessed type int dword_1013340C;
// 10133410: using guessed type int dword_10133410;
// 10133414: using guessed type int dword_10133414;
// 10133418: using guessed type float flt_10133418;

//----- (10012700) --------------------------------------------------------
char sub_10012700()
{
  char *v0; // eax@1
  char *v1; // ecx@1
  signed int v2; // edx@1
  void *v3; // ecx@3
  char result; // al@3
  char v5; // [sp+4h] [bp-28h]@1
  char v6; // [sp+Ch] [bp-20h]@1

  v0 = &v5;
  v1 = &v6;
  v2 = 7;
  do
  {
    *v0 = 0;
    *(_DWORD *)v1 = 42066;
    ++v0;
    v1 += 4;
    --v2;
  }
  while ( v2 );
  sub_10018670(41102, (int)&v5, 36);
  dword_10138C40 = 0;
  dword_10138C48 = 0;
  dword_10138C44 = 0;
  byte_10133421 = 0;
  dword_10133424 = 0;
  dword_10138C3C = 0;
  result = sub_1001FDE0(v3);
  byte_10133420 = result;
  return result;
}
// 10133420: using guessed type char byte_10133420;
// 10133421: using guessed type char byte_10133421;
// 10133424: using guessed type int dword_10133424;
// 10138C3C: using guessed type int dword_10138C3C;
// 10138C40: using guessed type int dword_10138C40;
// 10138C44: using guessed type int dword_10138C44;
// 10138C48: using guessed type int dword_10138C48;

//----- (10012790) --------------------------------------------------------
char __cdecl sub_10012790(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  LOBYTE(v3) = sub_1000DA70(a1, a2, &dword_10133428, (unsigned __int16 *)&v5);
  if ( (_BYTE)v3 == 1 )
  {
    v3 = j_REG_pvg_xfil_write_data(&dword_10133428, (unsigned __int16)v5);
    if ( v3 != (unsigned __int16)v5 )
      LOBYTE(v3) = sub_10018A40("..\\lib\\adl\\iop_xfil_reg_frmt.c", 345, 0, 0);
  }
  return v3;
}
// 10018790: using guessed type int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD);
// 10133428: using guessed type int dword_10133428;

//----- (100127F0) --------------------------------------------------------
char __cdecl sub_100127F0(int a1, int a2, __int16 a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v6 = 0;
  v4 = a2;
  LOWORD(v6) = a3;
  v5 = sub_100206D0((void *)a3);
  return sub_1000D700(130, a1, &v4, 1, (int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10012840) --------------------------------------------------------
int __cdecl sub_10012840(int a1, int a2)
{
  int v2; // ebx@1
  void *v3; // ecx@1
  int result; // eax@1

  v2 = sub_1000C2A0(a1, a2);
  result = sub_1001FDC0(v3);
  if ( v2 & result )
  {
    sub_1001E570(0x3Fu);
    result = *(_DWORD *)(a2 + 32);
    dword_10138C40 |= *(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + result + 20);
  }
  return result;
}
// 10138C3C: using guessed type int dword_10138C3C;
// 10138C40: using guessed type int dword_10138C40;

//----- (10012890) --------------------------------------------------------
char __cdecl sub_10012890(int a1)
{
  unsigned int v1; // eax@2
  char v2; // bl@3
  int v3; // eax@5
  int v4; // ecx@5
  __int16 v5; // si@8
  int v6; // eax@8
  char v8; // [sp+0h] [bp-150h]@8

  if ( !dword_10133424 || (v1 = sub_100181D0(), dword_10133424 <= v1) )
  {
    v2 = byte_10133421;
    if ( (unsigned __int8)byte_10133421 >= 0x32u )
    {
      v2 = 0;
      byte_10133421 = 0;
    }
    v3 = 28 * (unsigned __int8)v2;
    v4 = 28;
    if ( v3 + 28 > 1377 )
    {
      v4 = 1377 - v3;
      if ( 1377 - v3 <= 0 )
      {
        v2 = 0;
        v4 = 28;
        byte_10133421 = 0;
      }
    }
    v5 = j_reg_get_xfil_tag_data(&v8, 28 * (unsigned __int8)v2, v4);
    v6 = sub_100181D0();
    LOBYTE(v1) = sub_1000D150(a1, 12 * v5, 1, (int)&byte_10222BE0, &v8, v6);
    ++byte_10133421;
  }
  return v1;
}
// 10018530: using guessed type int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD);
// 10133421: using guessed type char byte_10133421;
// 10133424: using guessed type int dword_10133424;
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10012960) --------------------------------------------------------
__int16 __thiscall sub_10012960(void *this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = sub_100206D0(this);
  return word_10082EBC[4 * sub_1001E7B0(&v2, 4u, (int)&unk_10082EB8, 8, 7, 0)];
}
// 10082EBC: using guessed type __int16 word_10082EBC[];

//----- (10012990) --------------------------------------------------------
char __cdecl sub_10012990(int a1, int a2, unsigned __int16 a3)
{
  signed int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@8
  unsigned int v7; // ebp@8
  unsigned int v8; // edi@9
  int v9; // edi@15
  int v10; // ecx@20
  char v12; // [sp+13h] [bp-29h]@1
  char v13[8]; // [sp+14h] [bp-28h]@2
  int v14[7]; // [sp+1Ch] [bp-20h]@15

  v3 = a3 / 0xCu;
  LOBYTE(v4) = sub_10020300(a1);
  v5 = v4;
  v12 = 0;
  if ( byte_10133420 == 2 )
    LOBYTE(v4) = sub_10018540(41102, (int)v13, 36);
  if ( (unsigned int)(v3 - 1) <= 0x4D && !(a3 % 0xCu) )
  {
    if ( !dword_10133424 || (v4 = sub_100181D0(), dword_10133424 <= v4) )
    {
      if ( v3 > 0 )
      {
        v6 = a2 + 2;
        v7 = a3 / 0xCu;
        while ( 1 )
        {
          v4 = j_REG_pvg_xfil_shld_rqst_tag(v6 - 2);
          v8 = v4;
          if ( v4 == 2 )
            LOBYTE(v4) = sub_100127F0(a1, *(_WORD *)v6, *(_WORD *)(v6 + 8));
          if ( byte_10133420 != 2 )
            goto LABEL_22;
          if ( v5 == 7 )
            goto LABEL_22;
          LOBYTE(v4) = sub_10003CA0(*(_WORD *)v6);
          if ( !(_BYTE)v4 )
            goto LABEL_22;
          if ( v8 != 1 )
          {
            v10 = *(_WORD *)v6;
            v4 = v5;
            v13[v4] = 0;
            v14[v4] = v10;
            goto LABEL_21;
          }
          v4 = *(_WORD *)v6;
          v9 = v14[v5];
          if ( v4 == v9 )
          {
            v4 = (unsigned int)&v13[v5];
            if ( v13[v5] != 1 )
            {
              *(_BYTE *)v4 = 1;
LABEL_21:
              v12 = 1;
              goto LABEL_22;
            }
          }
          else if ( v9 == 42066 )
          {
            v14[v5] = v4;
            goto LABEL_21;
          }
LABEL_22:
          v6 += 12;
          if ( !--v7 )
          {
            if ( v12 )
              LOBYTE(v4) = sub_10018670(41102, (int)v13, 36);
            return v4;
          }
        }
      }
    }
  }
  return v4;
}
// 10018780: using guessed type int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD);
// 10133420: using guessed type char byte_10133420;
// 10133424: using guessed type int dword_10133424;
// 10012990: using guessed type char var_28[8];
// 10012990: using guessed type int var_20[7];

//----- (10012AF0) --------------------------------------------------------
char __cdecl sub_10012AF0(const void *a1, unsigned __int16 a2, int a3)
{
  void *v3; // ecx@0
  int v4; // esi@1
  int v5; // eax@1

  v4 = (unsigned __int16)sub_10012960(v3);
  v5 = sub_100181D0();
  sub_1000D150(v4, a2, 1, (int)&byte_10222BE0, a1, v5);
  return sub_1000D440(v4, a3, (int)&byte_10222BE0);
}
// 10222BE0: using guessed type char byte_10222BE0;

//----- (10012B30) --------------------------------------------------------
char __cdecl sub_10012B30(int a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@4
  int v5; // [sp+8h] [bp-4h]@1

  memset(&unk_10138C50, 0, 0x3A8u);
  if ( sub_1000DA70(a1, a2, &unk_10138C50, (unsigned __int16 *)&v5) == 1 )
  {
    v2 = sub_10012D10(a1);
    sub_10012990(v2, (int)&unk_10138C50, v5);
  }
  if ( dword_10138C40 || (LOBYTE(v3) = sub_1001E3D0(63), (_BYTE)v3) )
  {
    v3 = ~*(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 20);
    dword_10138C40 &= v3;
    if ( !dword_10138C40 )
      LOBYTE(v3) = sub_1001E460(63);
  }
  return v3;
}
// 10138C40: using guessed type int dword_10138C40;

//----- (10012BC0) --------------------------------------------------------
int __cdecl sub_10012BC0(int a1, __int16 a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@5
  bool v6; // zf@6

  dword_10133428 = 0;
  dword_1013342C = 0;
  dword_10133430 = 0;
  dword_10133434 = 0;
  byte_10133438 = 0;
  result = j_REG_pvg_xfil_read_data(a1, &dword_10133428, 22545, 1436);
  v4 = result;
  if ( result >= 0 && result )
  {
    if ( a1 == -1 || a2 == (_WORD)dword_1013342C )
    {
      sub_10012AF0(&dword_10133428, result, a3);
      v5 = 0;
      while ( 1 )
      {
        v6 = *(int *)((char *)&dword_10133430 + v5) == 3134;
        v5 += *(_WORD *)((char *)&dword_1013342C + v5) + 17;
        if ( v6 )
          break;
        if ( v5 >= v4 )
          return v4;
      }
      dword_10133424 = sub_100181D0() + 7000;
    }
    result = v4;
  }
  return result;
}
// 10018770: using guessed type int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 10133424: using guessed type int dword_10133424;
// 10133428: using guessed type int dword_10133428;
// 1013342C: using guessed type int dword_1013342C;
// 10133430: using guessed type int dword_10133430;
// 10133434: using guessed type int dword_10133434;
// 10133438: using guessed type char byte_10133438;

//----- (10012C70) --------------------------------------------------------
char __cdecl sub_10012C70(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_1000DA50(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10012BC0(v3, v5, v4);
  return result;
}

//----- (10012CC0) --------------------------------------------------------
int sub_10012CC0()
{
  signed int v0; // esi@1
  int result; // eax@2

  v0 = 0;
  do
  {
    result = sub_10012BC0(-1, 0, 0xFFFFFFF);
    if ( result <= 0 )
      break;
    ++v0;
  }
  while ( v0 < 10 );
  if ( v0 <= 0 || dword_10138C3C > 50 )
  {
    result = j_REG_pvg_flush_que(1, 1, 12);
    dword_10138C3C = 0;
  }
  else
  {
    ++dword_10138C3C;
  }
  return result;
}
// 100184E0: using guessed type int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD);
// 10138C3C: using guessed type int dword_10138C3C;

//----- (10012D10) --------------------------------------------------------
int __cdecl sub_10012D10(char a1)
{
  return dword_10083474[2 * sub_1001E7B0(&a1, 2u, (int)&unk_10083470, 8, 7, 0)];
}
// 10083474: using guessed type int dword_10083474[];

//----- (10012D40) --------------------------------------------------------
char __cdecl sub_10012D40(int a1, void *a2)
{
  char result; // al@1
  unsigned __int8 v3; // dl@1

  memset(a2, 0, 0x48u);
  result = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    if ( a1 & *(_DWORD *)(dword_1021A3CC + 72 * v3 + 1704) )
    {
      qmemcpy(a2, (const void *)(dword_1021A3CC + 72 * v3 + 1660), 0x48u);
      result = 1;
    }
    ++v3;
  }
  while ( v3 < 0x1Eu );
  return result;
}
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (10012DA0) --------------------------------------------------------
void *__usercall sub_10012DA0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10018540(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_100186F0(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10012DF0) --------------------------------------------------------
signed int sub_10012DF0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1021A3CC = 0;
  v4 = 0;
  sub_10019570(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10018670(3201, (int)&v4, 1);
    sub_100195A0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10018670(3201, (int)&v4, 1);
    sub_100195A0(94, (int)&v4);
  }
  sub_10012DA0(1u, 6011, &unk_10138FF8);
  sub_10012DA0(0x16u, 6194, &unk_10138FF9);
  sub_10012DA0(1u, 6012, &unk_1013900F);
  sub_10012DA0(1u, 6013, &unk_10139010);
  sub_10012DA0(1u, 6014, &unk_10139011);
  sub_10012DA0(1u, 6015, &unk_10139012);
  sub_10012DA0(4u, 6078, &unk_10139014);
  sub_10012DA0(4u, 6104, &unk_10139018);
  sub_10012DA0(0x20u, 6016, &unk_1013901C);
  sub_10012DA0(0x20u, 6017, &unk_1013903C);
  sub_10012DA0(0x20u, 6018, &unk_1013905C);
  sub_10012DA0(0x20u, 6019, &unk_1013907C);
  sub_10012DA0(0x20u, 6020, &unk_1013909C);
  sub_10012DA0(0x20u, 6021, &unk_101390BC);
  sub_10012DA0(0x20u, 6022, &unk_101390DC);
  sub_10012DA0(0x20u, 6023, &unk_101390FC);
  sub_10012DA0(0x20u, 6024, &unk_1013911C);
  sub_10012DA0(0x20u, 6025, &unk_1013913C);
  sub_10012DA0(0x20u, 6026, &unk_1013915C);
  sub_10012DA0(0x20u, 6027, &unk_1013917C);
  sub_10012DA0(0x20u, 6028, &unk_1013919C);
  sub_10012DA0(0x20u, 6029, &unk_101391BC);
  sub_10012DA0(0x20u, 6030, &unk_101391DC);
  sub_10012DA0(0x20u, 6031, &unk_101391FC);
  sub_10012DA0(0x20u, 6032, &unk_1013921C);
  sub_10012DA0(0x20u, 6033, &unk_1013923C);
  sub_10012DA0(0x20u, 6034, &unk_1013925C);
  sub_10012DA0(0x20u, 6035, &unk_1013927C);
  sub_10012DA0(0x20u, 6036, &unk_1013929C);
  sub_10012DA0(0x20u, 6037, &unk_101392BC);
  sub_10012DA0(0x20u, 6038, &unk_101392DC);
  sub_10012DA0(0x20u, 6039, &unk_101392FC);
  sub_10012DA0(0x20u, 6040, &unk_1013931C);
  sub_10012DA0(0x20u, 6041, &unk_1013933C);
  sub_10012DA0(0x20u, 6042, &unk_1013935C);
  sub_10012DA0(0x20u, 6043, &unk_1013937C);
  sub_10012DA0(4u, 6044, &unk_1013939C);
  sub_10012DA0(4u, 6045, &unk_101393A0);
  sub_10012DA0(4u, 6046, &unk_101393A4);
  sub_10012DA0(4u, 6357, &unk_101393A8);
  sub_10012DA0(4u, 6358, &unk_101393AC);
  sub_10012DA0(4u, 6359, &unk_101393B0);
  sub_10012DA0(0x20u, 6047, &unk_101393B4);
  sub_10012DA0(0x20u, 6048, &unk_101393D4);
  sub_10012DA0(0x20u, 6049, &unk_101393F4);
  sub_10012DA0(0x20u, 6050, &unk_10139414);
  sub_10012DA0(0x20u, 6051, &unk_10139434);
  sub_10012DA0(0x20u, 6052, &unk_10139454);
  sub_10012DA0(0x20u, 6053, &unk_10139474);
  sub_10012DA0(0x20u, 6054, &unk_10139494);
  sub_10012DA0(1u, 6511, &unk_101394B4);
  sub_10012DA0(1u, 6522, &unk_101394B5);
  sub_10012DA0(1u, 6057, &unk_101394B6);
  sub_10012DA0(0x20u, 6075, &unk_10139508);
  sub_10012DA0(0x20u, 6076, &unk_10139528);
  sub_10012DA0(1u, 6077, &unk_10139548);
  sub_10012DA0(4u, 6079, &unk_1013954C);
  sub_10012DA0(4u, 6080, &unk_10139550);
  sub_10012DA0(0x20u, 6082, &unk_10139554);
  sub_10012DA0(0x20u, 6083, &unk_10139574);
  sub_10012DA0(0x20u, 6084, &unk_10139594);
  sub_10012DA0(0x20u, 6085, &unk_101395B4);
  sub_10012DA0(0x20u, 6086, &unk_101395D4);
  sub_10012DA0(0x20u, 6087, &unk_101395F4);
  sub_10012DA0(0x20u, 6088, &unk_10139614);
  sub_10012DA0(0x20u, 6089, &unk_10139634);
  sub_10012DA0(0x20u, 6123, &unk_10139654);
  sub_10012DA0(0x48u, 6906, &unk_10139674);
  sub_10012DA0(0x48u, 6907, &unk_101396BC);
  sub_10012DA0(0x48u, 6908, &unk_10139704);
  sub_10012DA0(0x48u, 6909, &unk_1013974C);
  sub_10012DA0(0x48u, 6910, &unk_10139794);
  sub_10012DA0(0x48u, 6911, &unk_101397DC);
  sub_10012DA0(0x48u, 6912, &unk_10139824);
  sub_10012DA0(0x48u, 6913, &unk_1013986C);
  sub_10012DA0(0x48u, 6914, &unk_101398B4);
  sub_10012DA0(0x48u, 6915, &unk_101398FC);
  sub_10012DA0(0x48u, 6916, &unk_10139944);
  sub_10012DA0(0x48u, 6917, &unk_1013998C);
  sub_10012DA0(0x48u, 6918, &unk_101399D4);
  sub_10012DA0(0x48u, 6919, &unk_10139A1C);
  sub_10012DA0(0x48u, 6920, &unk_10139A64);
  sub_10012DA0(0x48u, 6921, &unk_10139AAC);
  sub_10012DA0(0x48u, 6922, &unk_10139AF4);
  sub_10012DA0(0x48u, 6923, &unk_10139B3C);
  sub_10012DA0(0x48u, 6924, &unk_10139B84);
  sub_10012DA0(0x48u, 6925, &unk_10139BCC);
  sub_10012DA0(0x48u, 6926, &unk_10139C14);
  sub_10012DA0(0x48u, 6927, &unk_10139C5C);
  sub_10012DA0(0x48u, 6928, &unk_10139CA4);
  sub_10012DA0(0x48u, 6929, &unk_10139CEC);
  sub_10012DA0(0x48u, 6930, &unk_10139D34);
  sub_10012DA0(0x48u, 6931, &unk_10139D7C);
  sub_10012DA0(0x48u, 6932, &unk_10139DC4);
  sub_10012DA0(0x48u, 6933, &unk_10139E0C);
  sub_10012DA0(0x48u, 6934, &unk_10139E54);
  sub_10012DA0(0x48u, 6935, &unk_10139E9C);
  sub_10012DA0(0x18u, 6163, &unk_10139EE4);
  sub_10012DA0(0x20u, 6164, &unk_10139EFC);
  sub_10012DA0(0x20u, 6165, &unk_10139F1C);
  sub_10012DA0(2u, 6166, &unk_10139F3C);
  sub_10012DA0(0xA4u, 40100, &unk_10139F40);
  sub_10012DA0(0xA4u, 40101, &unk_10139FE4);
  sub_10012DA0(0xA4u, 40102, &unk_1013A088);
  sub_10012DA0(0xA4u, 40103, &unk_1013A12C);
  sub_10012DA0(0xA4u, 40104, &unk_1013A1D0);
  sub_10012DA0(0xA4u, 40105, &unk_1013A274);
  sub_10012DA0(0xA4u, 40106, &unk_1013A318);
  sub_10012DA0(0xA4u, 40107, &unk_1013A3BC);
  sub_10012DA0(0xA4u, 40108, &unk_1013A460);
  sub_10012DA0(0xA4u, 40109, &unk_1013A504);
  sub_10012DA0(0xA4u, 40110, &unk_1013A5A8);
  sub_10012DA0(0xA4u, 40111, &unk_1013A64C);
  sub_10012DA0(0xA4u, 40112, &unk_1013A6F0);
  sub_10012DA0(0xA4u, 40113, &unk_1013A794);
  sub_10012DA0(0xA4u, 40114, &unk_1013A838);
  sub_10012DA0(0xA4u, 40115, &unk_1013A8DC);
  sub_10012DA0(0xA4u, 40116, &unk_1013A980);
  sub_10012DA0(0xA4u, 40117, &unk_1013AA24);
  sub_10012DA0(0xA4u, 40118, &unk_1013AAC8);
  sub_10012DA0(0xA4u, 40119, &unk_1013AB6C);
  sub_10012DA0(0xA4u, 40120, &unk_1013AC10);
  sub_10012DA0(0xA4u, 40121, &unk_1013ACB4);
  sub_10012DA0(0xA4u, 40122, &unk_1013AD58);
  sub_10012DA0(0xA4u, 40123, &unk_1013ADFC);
  sub_10012DA0(0xA4u, 40124, &unk_1013AEA0);
  sub_10012DA0(0xA4u, 40125, &unk_1013AF44);
  sub_10012DA0(0xA4u, 40126, &unk_1013AFE8);
  sub_10012DA0(0xA4u, 40127, &unk_1013B08C);
  sub_10012DA0(0xA4u, 40128, &unk_1013B130);
  sub_10012DA0(0xA4u, 40129, &unk_1013B1D4);
  sub_10012DA0(0xA4u, 40130, &unk_1013B278);
  sub_10012DA0(0xA4u, 40131, &unk_1013B31C);
  sub_10012DA0(0xA4u, 40132, &unk_1013B3C0);
  sub_10012DA0(0xA4u, 40133, &unk_1013B464);
  sub_10012DA0(0xA4u, 40134, &unk_1013B508);
  sub_10012DA0(0xA4u, 40135, &unk_1013B5AC);
  sub_10012DA0(0xA4u, 40136, &unk_1013B650);
  sub_10012DA0(0xA4u, 40137, &unk_1013B6F4);
  sub_10012DA0(0xA4u, 40138, &unk_1013B798);
  sub_10012DA0(0xA4u, 40139, &unk_1013B83C);
  sub_10012DA0(0xA4u, 40140, &unk_1013B8E0);
  sub_10012DA0(0xA4u, 40141, &unk_1013B984);
  sub_10012DA0(0xA4u, 40142, &unk_1013BA28);
  sub_10012DA0(0xA4u, 40143, &unk_1013BACC);
  sub_10012DA0(0xA4u, 40144, &unk_1013BB70);
  sub_10012DA0(0xA4u, 40145, &unk_1013BC14);
  sub_10012DA0(0xA4u, 40146, &unk_1013BCB8);
  sub_10012DA0(0xA4u, 40147, &unk_1013BD5C);
  sub_10012DA0(0xA4u, 40148, &unk_1013BE00);
  sub_10012DA0(0xA4u, 40149, &unk_1013BEA4);
  sub_10012DA0(0xA4u, 40150, &unk_1013BF48);
  sub_10012DA0(0xA4u, 40151, &unk_1013BFEC);
  sub_10012DA0(0xA4u, 40152, &unk_1013C090);
  sub_10012DA0(0xA4u, 40153, &unk_1013C134);
  sub_10012DA0(0xA4u, 40154, &unk_1013C1D8);
  sub_10012DA0(0xA4u, 40155, &unk_1013C27C);
  sub_10012DA0(0xA4u, 40156, &unk_1013C320);
  sub_10012DA0(0xA4u, 40157, &unk_1013C3C4);
  sub_10012DA0(0xA4u, 40158, &unk_1013C468);
  sub_10012DA0(0xA4u, 40159, &unk_1013C50C);
  sub_10012DA0(0xA4u, 40160, &unk_1013C5B0);
  sub_10012DA0(0xA4u, 40161, &unk_1013C654);
  sub_10012DA0(0xA4u, 40162, &unk_1013C6F8);
  sub_10012DA0(0xA4u, 40163, &unk_1013C79C);
  sub_10012DA0(0xA4u, 40164, &unk_1013C840);
  sub_10012DA0(0xA4u, 40165, &unk_1013C8E4);
  sub_10012DA0(0xA4u, 40166, &unk_1013C988);
  sub_10012DA0(0xA4u, 40167, &unk_1013CA2C);
  sub_10012DA0(0xA4u, 40168, &unk_1013CAD0);
  sub_10012DA0(0xA4u, 40169, &unk_1013CB74);
  sub_10012DA0(0xA4u, 40170, &unk_1013CC18);
  sub_10012DA0(0xA4u, 40171, &unk_1013CCBC);
  sub_10012DA0(0xA4u, 40172, &unk_1013CD60);
  sub_10012DA0(0xA4u, 40173, &unk_1013CE04);
  sub_10012DA0(0xA4u, 40174, &unk_1013CEA8);
  sub_10012DA0(0xA4u, 40175, &unk_1013CF4C);
  sub_10012DA0(0xA4u, 40176, &unk_1013CFF0);
  sub_10012DA0(0xA4u, 40177, &unk_1013D094);
  sub_10012DA0(0xA4u, 40178, &unk_1013D138);
  sub_10012DA0(0xA4u, 40179, &unk_1013D1DC);
  sub_10012DA0(0xA4u, 40180, &unk_1013D280);
  sub_10012DA0(0xA4u, 40181, &unk_1013D324);
  sub_10012DA0(0xA4u, 40182, &unk_1013D3C8);
  sub_10012DA0(0xA4u, 40183, &unk_1013D46C);
  sub_10012DA0(0xA4u, 40184, &unk_1013D510);
  sub_10012DA0(0xA4u, 40185, &unk_1013D5B4);
  sub_10012DA0(0xA4u, 40186, &unk_1013D658);
  sub_10012DA0(0xA4u, 40187, &unk_1013D6FC);
  sub_10012DA0(0xA4u, 40188, &unk_1013D7A0);
  sub_10012DA0(0xA4u, 40189, &unk_1013D844);
  sub_10012DA0(0xA4u, 40190, &unk_1013D8E8);
  sub_10012DA0(0xA4u, 40191, &unk_1013D98C);
  sub_10012DA0(0xA4u, 40192, &unk_1013DA30);
  sub_10012DA0(0xA4u, 40193, &unk_1013DAD4);
  sub_10012DA0(0xA4u, 40194, &unk_1013DB78);
  sub_10012DA0(0xA4u, 40195, &unk_1013DC1C);
  sub_10012DA0(0xA4u, 40196, &unk_1013DCC0);
  sub_10012DA0(0xA4u, 40197, &unk_1013DD64);
  sub_10012DA0(0xA4u, 40198, &unk_1013DE08);
  sub_10012DA0(0xA4u, 40199, &unk_1013DEAC);
  sub_10012DA0(0x20u, 6190, &unk_1013DF50);
  sub_10012DA0(0x20u, 6191, &unk_1013DF70);
  sub_10012DA0(0x20u, 6192, &unk_1013DF90);
  sub_10012DA0(0x20u, 6199, &unk_1013DFB0);
  sub_10012DA0(0x28u, 6207, &unk_1013DFD0);
  sub_10012DA0(4u, 6231, &unk_1013EAE8);
  sub_10012DA0(4u, 6232, &unk_1013EAEC);
  sub_10012DA0(4u, 6233, &unk_1013EAF0);
  sub_10012DA0(4u, 6234, &unk_1013EAF4);
  sub_10012DA0(0x1Cu, 40000, &unk_1013DFF8);
  sub_10012DA0(0x1Cu, 40001, &unk_1013E014);
  sub_10012DA0(0x1Cu, 40002, &unk_1013E030);
  sub_10012DA0(0x1Cu, 40003, &unk_1013E04C);
  sub_10012DA0(0x1Cu, 40004, &unk_1013E068);
  sub_10012DA0(0x1Cu, 40005, &unk_1013E084);
  sub_10012DA0(0x1Cu, 40006, &unk_1013E0A0);
  sub_10012DA0(0x1Cu, 40007, &unk_1013E0BC);
  sub_10012DA0(0x1Cu, 40008, &unk_1013E0D8);
  sub_10012DA0(0x1Cu, 40009, &unk_1013E0F4);
  sub_10012DA0(0x1Cu, 40010, &unk_1013E110);
  sub_10012DA0(0x1Cu, 40011, &unk_1013E12C);
  sub_10012DA0(0x1Cu, 40012, &unk_1013E148);
  sub_10012DA0(0x1Cu, 40013, &unk_1013E164);
  sub_10012DA0(0x1Cu, 40014, &unk_1013E180);
  sub_10012DA0(0x1Cu, 40015, &unk_1013E19C);
  sub_10012DA0(0x1Cu, 40016, &unk_1013E1B8);
  sub_10012DA0(0x1Cu, 40017, &unk_1013E1D4);
  sub_10012DA0(0x1Cu, 40018, &unk_1013E1F0);
  sub_10012DA0(0x1Cu, 40019, &unk_1013E20C);
  sub_10012DA0(0x1Cu, 40020, &unk_1013E228);
  sub_10012DA0(0x1Cu, 40021, &unk_1013E244);
  sub_10012DA0(0x1Cu, 40022, &unk_1013E260);
  sub_10012DA0(0x1Cu, 40023, &unk_1013E27C);
  sub_10012DA0(0x1Cu, 40024, &unk_1013E298);
  sub_10012DA0(0x1Cu, 40025, &unk_1013E2B4);
  sub_10012DA0(0x1Cu, 40026, &unk_1013E2D0);
  sub_10012DA0(0x1Cu, 40027, &unk_1013E2EC);
  sub_10012DA0(0x1Cu, 40028, &unk_1013E308);
  sub_10012DA0(0x1Cu, 40029, &unk_1013E324);
  sub_10012DA0(0x1Cu, 40030, &unk_1013E340);
  sub_10012DA0(0x1Cu, 40031, &unk_1013E35C);
  sub_10012DA0(0x1Cu, 40032, &unk_1013E378);
  sub_10012DA0(0x1Cu, 40033, &unk_1013E394);
  sub_10012DA0(0x1Cu, 40034, &unk_1013E3B0);
  sub_10012DA0(0x1Cu, 40035, &unk_1013E3CC);
  sub_10012DA0(0x1Cu, 40036, &unk_1013E3E8);
  sub_10012DA0(0x1Cu, 40037, &unk_1013E404);
  sub_10012DA0(0x1Cu, 40038, &unk_1013E420);
  sub_10012DA0(0x1Cu, 40039, &unk_1013E43C);
  sub_10012DA0(0x1Cu, 40040, &unk_1013E458);
  sub_10012DA0(0x1Cu, 40041, &unk_1013E474);
  sub_10012DA0(0x1Cu, 40042, &unk_1013E490);
  sub_10012DA0(0x1Cu, 40043, &unk_1013E4AC);
  sub_10012DA0(0x1Cu, 40044, &unk_1013E4C8);
  sub_10012DA0(0x1Cu, 40045, &unk_1013E4E4);
  sub_10012DA0(0x1Cu, 40046, &unk_1013E500);
  sub_10012DA0(0x1Cu, 40047, &unk_1013E51C);
  sub_10012DA0(0x1Cu, 40048, &unk_1013E538);
  sub_10012DA0(0x1Cu, 40049, &unk_1013E554);
  sub_10012DA0(0x1Cu, 40050, &unk_1013E570);
  sub_10012DA0(0x1Cu, 40051, &unk_1013E58C);
  sub_10012DA0(0x1Cu, 40052, &unk_1013E5A8);
  sub_10012DA0(0x1Cu, 40053, &unk_1013E5C4);
  sub_10012DA0(0x1Cu, 40054, &unk_1013E5E0);
  sub_10012DA0(0x1Cu, 40055, &unk_1013E5FC);
  sub_10012DA0(0x1Cu, 40056, &unk_1013E618);
  sub_10012DA0(0x1Cu, 40057, &unk_1013E634);
  sub_10012DA0(0x1Cu, 40058, &unk_1013E650);
  sub_10012DA0(0x1Cu, 40059, &unk_1013E66C);
  sub_10012DA0(0x1Cu, 40060, &unk_1013E688);
  sub_10012DA0(0x1Cu, 40061, &unk_1013E6A4);
  sub_10012DA0(0x1Cu, 40062, &unk_1013E6C0);
  sub_10012DA0(0x1Cu, 40063, &unk_1013E6DC);
  sub_10012DA0(0x1Cu, 40064, &unk_1013E6F8);
  sub_10012DA0(0x1Cu, 40065, &unk_1013E714);
  sub_10012DA0(0x1Cu, 40066, &unk_1013E730);
  sub_10012DA0(0x1Cu, 40067, &unk_1013E74C);
  sub_10012DA0(0x1Cu, 40068, &unk_1013E768);
  sub_10012DA0(0x1Cu, 40069, &unk_1013E784);
  sub_10012DA0(0x1Cu, 40070, &unk_1013E7A0);
  sub_10012DA0(0x1Cu, 40071, &unk_1013E7BC);
  sub_10012DA0(0x1Cu, 40072, &unk_1013E7D8);
  sub_10012DA0(0x1Cu, 40073, &unk_1013E7F4);
  sub_10012DA0(0x1Cu, 40074, &unk_1013E810);
  sub_10012DA0(0x1Cu, 40075, &unk_1013E82C);
  sub_10012DA0(0x1Cu, 40076, &unk_1013E848);
  sub_10012DA0(0x1Cu, 40077, &unk_1013E864);
  sub_10012DA0(0x1Cu, 40078, &unk_1013E880);
  sub_10012DA0(0x1Cu, 40079, &unk_1013E89C);
  sub_10012DA0(0x1Cu, 40080, &unk_1013E8B8);
  sub_10012DA0(0x1Cu, 40081, &unk_1013E8D4);
  sub_10012DA0(0x1Cu, 40082, &unk_1013E8F0);
  sub_10012DA0(0x1Cu, 40083, &unk_1013E90C);
  sub_10012DA0(0x1Cu, 40084, &unk_1013E928);
  sub_10012DA0(0x1Cu, 40085, &unk_1013E944);
  sub_10012DA0(0x1Cu, 40086, &unk_1013E960);
  sub_10012DA0(0x1Cu, 40087, &unk_1013E97C);
  sub_10012DA0(0x1Cu, 40088, &unk_1013E998);
  sub_10012DA0(0x1Cu, 40089, &unk_1013E9B4);
  sub_10012DA0(0x1Cu, 40090, &unk_1013E9D0);
  sub_10012DA0(0x1Cu, 40091, &unk_1013E9EC);
  sub_10012DA0(0x1Cu, 40092, &unk_1013EA08);
  sub_10012DA0(0x1Cu, 40093, &unk_1013EA24);
  sub_10012DA0(0x1Cu, 40094, &unk_1013EA40);
  sub_10012DA0(0x1Cu, 40095, &unk_1013EA5C);
  sub_10012DA0(0x1Cu, 40096, &unk_1013EA78);
  sub_10012DA0(0x1Cu, 40097, &unk_1013EA94);
  sub_10012DA0(0x1Cu, 40098, &unk_1013EAB0);
  sub_10012DA0(0x1Cu, 40099, &unk_1013EACC);
  sub_10012DA0(4u, 6238, &unk_1013EAF8);
  sub_10012DA0(4u, 6239, &unk_1013EAFC);
  sub_10012DA0(4u, 6240, &unk_1013EB00);
  sub_10012DA0(4u, 6242, &unk_1013EB04);
  sub_10012DA0(4u, 6244, &unk_1013EB08);
  sub_10012DA0(4u, 6245, &unk_1013EB0C);
  sub_10012DA0(4u, 6246, &unk_1013EB10);
  sub_10012DA0(4u, 6251, &unk_1013EB14);
  sub_10012DA0(4u, 6252, &unk_1013EB18);
  sub_10012DA0(4u, 6253, &unk_1013EB1C);
  sub_10012DA0(4u, 6254, &unk_1013EB20);
  sub_10012DA0(1u, 6255, &unk_1013EB24);
  sub_10012DA0(4u, 6256, &unk_1013EB28);
  sub_10012DA0(4u, 6257, &unk_1013EB2C);
  sub_10012DA0(0xE2u, 6286, &unk_1013EB30);
  v0 = 18000;
  v1 = &unk_1013EC14;
  v2 = 16;
  do
  {
    sub_10012DA0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10012DA0(4u, 6262, &unk_1013FDD4);
  sub_10012DA0(0x28u, 6263, &unk_1013FDD8);
  sub_10012DA0(0x28u, 6264, &unk_1013FE00);
  sub_10012DA0(0x40u, 6268, &unk_1013FE28);
  sub_10012DA0(4u, 6272, &unk_1013FEE8);
  sub_10012DA0(4u, 6273, &unk_1013FEEC);
  sub_10012DA0(1u, 6274, &unk_1013FEF0);
  sub_10012DA0(2u, 6275, &unk_1013FEF2);
  sub_10012DA0(1u, 6276, &unk_1013FEF4);
  sub_10012DA0(1u, 6277, &unk_1013FEF5);
  sub_10012DA0(1u, 6278, &unk_1013FEF6);
  sub_10012DA0(0x40u, 6279, &unk_1013FEF8);
  sub_10012DA0(0x28u, 6753, &unk_10140DAD);
  sub_10012DA0(0x30u, 6754, &unk_10140DD8);
  sub_10012DA0(0x28u, 6958, &unk_10140E08);
  sub_10012DA0(0x80u, 6802, &unk_1013FE68);
  sub_10012DA0(1u, 6760, &unk_10140E30);
  sub_10012DA0(0x10u, 6312, &unk_1014027C);
  sub_10012DA0(0x10u, 6313, &unk_1014028C);
  sub_10012DA0(0x10u, 6314, &unk_1014029C);
  sub_10012DA0(1u, 6307, &unk_101402AC);
  sub_10012DA0(1u, 6308, &unk_101402AD);
  sub_10012DA0(1u, 6309, &unk_101402AE);
  sub_10012DA0(4u, 6285, &unk_101402B0);
  sub_10012DA0(0xA8u, 6318, &unk_101402B4);
  sub_10012DA0(4u, 6319, &unk_1014035C);
  sub_10012DA0(1u, 6350, &unk_10140360);
  sub_10012DA0(0x50u, 6351, &unk_10140364);
  sub_10012DA0(4u, 6352, &unk_101403B4);
  sub_10012DA0(4u, 6353, &unk_101403B8);
  sub_10012DA0(0x54u, 6448, &unk_10140604);
  sub_10012DA0(0x54u, 6449, &unk_10140658);
  sub_10012DA0(8u, 6287, &unk_1013FF5C);
  sub_10012DA0(8u, 6288, &unk_1013FF64);
  sub_10012DA0(8u, 6289, &unk_1013FF6C);
  sub_10012DA0(8u, 6290, &unk_1013FF74);
  sub_10012DA0(8u, 6291, &unk_1013FF7C);
  sub_10012DA0(8u, 6292, &unk_1013FF84);
  sub_10012DA0(8u, 6293, &unk_1013FF8C);
  sub_10012DA0(8u, 6294, &unk_1013FF94);
  sub_10012DA0(8u, 6295, &unk_1013FF9C);
  sub_10012DA0(8u, 6296, &unk_1013FFA4);
  sub_10012DA0(8u, 6297, &unk_1013FFAC);
  sub_10012DA0(8u, 6298, &unk_1013FFB4);
  sub_10012DA0(8u, 6299, &unk_1013FFBC);
  sub_10012DA0(8u, 6300, &unk_1013FFC4);
  sub_10012DA0(8u, 6301, &unk_1013FFCC);
  sub_10012DA0(8u, 6302, &unk_1013FFD4);
  sub_10012DA0(8u, 6303, &unk_1013FFDC);
  sub_10012DA0(8u, 6304, &unk_1013FFE4);
  sub_10012DA0(8u, 6305, &unk_1013FFEC);
  sub_10012DA0(8u, 6306, &unk_1013FFF4);
  sub_10012DA0(8u, 6409, &unk_1013FFFC);
  sub_10012DA0(8u, 6410, &unk_10140004);
  sub_10012DA0(8u, 6411, &unk_1014000C);
  sub_10012DA0(8u, 6412, &unk_10140014);
  sub_10012DA0(8u, 6413, &unk_1014001C);
  sub_10012DA0(8u, 6414, &unk_10140024);
  sub_10012DA0(8u, 6415, &unk_1014002C);
  sub_10012DA0(8u, 6416, &unk_10140034);
  sub_10012DA0(8u, 6417, &unk_1014003C);
  sub_10012DA0(8u, 6418, &unk_10140044);
  sub_10012DA0(8u, 6419, &unk_1014004C);
  sub_10012DA0(8u, 6420, &unk_10140054);
  sub_10012DA0(8u, 6421, &unk_1014005C);
  sub_10012DA0(8u, 6422, &unk_10140064);
  sub_10012DA0(8u, 6423, &unk_1014006C);
  sub_10012DA0(8u, 6424, &unk_10140074);
  sub_10012DA0(8u, 6425, &unk_1014007C);
  sub_10012DA0(8u, 6426, &unk_10140084);
  sub_10012DA0(8u, 6427, &unk_1014008C);
  sub_10012DA0(8u, 6428, &unk_10140094);
  sub_10012DA0(4u, 6429, &unk_1014059C);
  sub_10012DA0(8u, 6430, &unk_101405A0);
  sub_10012DA0(8u, 6431, &unk_101405A8);
  sub_10012DA0(8u, 6432, &unk_101405B0);
  sub_10012DA0(8u, 6433, &unk_101405B8);
  sub_10012DA0(8u, 6434, &unk_101405C0);
  sub_10012DA0(8u, 6435, &unk_101405C8);
  sub_10012DA0(8u, 6436, &unk_101405D0);
  sub_10012DA0(8u, 6437, &unk_101405D8);
  sub_10012DA0(8u, 6438, &unk_101405E0);
  sub_10012DA0(8u, 6439, &unk_101405E8);
  sub_10012DA0(8u, 6440, &unk_101405F0);
  sub_10012DA0(0xAu, 6519, &unk_10140A5C);
  sub_10012DA0(4u, 6442, &unk_101405F8);
  sub_10012DA0(4u, 6443, &unk_101405FC);
  sub_10012DA0(0xF0u, 6367, &unk_101403BC);
  sub_10012DA0(0xF0u, 6368, &unk_101404AC);
  sub_10012DA0(1u, 6446, &unk_10140600);
  sub_10012DA0(6u, 6452, &unk_101406AC);
  sub_10012DA0(4u, 6457, &unk_101406B4);
  sub_10012DA0(4u, 6458, &unk_101406B8);
  sub_10012DA0(4u, 6459, &unk_101406BC);
  sub_10012DA0(4u, 6460, &unk_101406C0);
  sub_10012DA0(0x208u, 6515, &unk_101406C4);
  sub_10012DA0(0x160u, 6516, &unk_101408CC);
  sub_10012DA0(0x18u, 6517, &unk_10140A2C);
  sub_10012DA0(0x18u, 6518, &unk_10140A44);
  sub_10012DA0(1u, 6520, &unk_10140A66);
  sub_10012DA0(0x10u, 6521, &unk_10140A68);
  sub_10012DA0(4u, 6523, &unk_10140A78);
  sub_10012DA0(4u, 6524, &unk_10140A7C);
  sub_10012DA0(4u, 6525, &unk_10140A80);
  sub_10012DA0(1u, 6526, &unk_10140A84);
  sub_10012DA0(1u, 6527, &unk_10140A85);
  sub_10012DA0(0x50u, 6528, &unk_10140A88);
  sub_10012DA0(4u, 6529, &unk_10140AD8);
  sub_10012DA0(1u, 6530, &unk_10140ADC);
  sub_10012DA0(1u, 6531, &unk_10140ADD);
  sub_10012DA0(1u, 6532, &unk_10140ADE);
  sub_10012DA0(0x14u, 6533, &unk_10140ADF);
  sub_10012DA0(0xAu, 6883, &unk_101411F8);
  sub_10012DA0(0xAu, 6884, &unk_10141202);
  sub_10012DA0(0xAu, 6885, &unk_1014120C);
  sub_10012DA0(1u, 6664, &unk_10140AF3);
  sub_10012DA0(1u, 6666, &unk_10140AF4);
  sub_10012DA0(1u, 6667, &unk_10140AF5);
  sub_10012DA0(1u, 6668, &unk_10140AF6);
  sub_10012DA0(0xA0u, 6669, &unk_10140AF8);
  sub_10012DA0(2u, 6670, &unk_10140BE8);
  sub_10012DA0(4u, 6671, &unk_10140BEC);
  sub_10012DA0(4u, 6672, &unk_10140BF0);
  sub_10012DA0(4u, 6673, &unk_10140BF4);
  sub_10012DA0(4u, 6674, &unk_10140BF8);
  sub_10012DA0(4u, 6675, &unk_10140BFC);
  sub_10012DA0(4u, 6676, &unk_10140C04);
  sub_10012DA0(4u, 6677, &unk_10140C0C);
  sub_10012DA0(4u, 6678, &unk_10140C10);
  sub_10012DA0(1u, 6679, &unk_10140C14);
  sub_10012DA0(0x140u, 6680, &unk_10140C18);
  sub_10012DA0(4u, 6882, &unk_101411F4);
  sub_10012DA0(0xCu, 6652, &unk_10140D58);
  sub_10012DA0(0x48u, 6653, &unk_10140D64);
  sub_10012DA0(1u, 6688, &unk_10140DAC);
  sub_10012DA0(4u, 6771, &unk_10140E34);
  sub_10012DA0(4u, 6772, &unk_10140E38);
  sub_10012DA0(8u, 6787, &unk_10140E3C);
  sub_10012DA0(1u, 6832, &unk_10140E6C);
  sub_10012DA0(1u, 6833, &unk_10140E6D);
  sub_10012DA0(1u, 6834, &unk_10140E6E);
  sub_10012DA0(4u, 6835, &unk_10140E70);
  sub_10012DA0(4u, 6836, &unk_10140E74);
  sub_10012DA0(4u, 6837, &unk_10140E78);
  sub_10012DA0(4u, 6838, &unk_10140E7C);
  sub_10012DA0(1u, 6839, &unk_10140E80);
  sub_10012DA0(0x50u, 6840, &unk_10140B98);
  sub_10012DA0(4u, 6841, &unk_10140E84);
  sub_10012DA0(4u, 6842, &unk_10140E88);
  sub_10012DA0(4u, 6843, &unk_10140E8C);
  sub_10012DA0(1u, 6844, &unk_10140E90);
  sub_10012DA0(0x360u, 6845, &unk_10140E94);
  sub_10012DA0(4u, 6846, &unk_10140C00);
  sub_10012DA0(4u, 6847, &unk_10140C08);
  result = 1;
  dword_1021A3CC = (int)&unk_10138FF8;
  return result;
}
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (10014BF0) --------------------------------------------------------
char **sub_10014BF0()
{
  return off_100871E8;
}
// 100871E8: using guessed type char *off_100871E8[3];

//----- (10014C00) --------------------------------------------------------
char **sub_10014C00()
{
  return off_100871FC;
}
// 100871FC: using guessed type char *off_100871FC[3];

//----- (10014C10) --------------------------------------------------------
char **sub_10014C10()
{
  return off_10087350;
}
// 10087350: using guessed type char *off_10087350[3];

//----- (10014C20) --------------------------------------------------------
char **sub_10014C20()
{
  return off_10087364;
}
// 10087364: using guessed type char *off_10087364[3];

//----- (10014C30) --------------------------------------------------------
char **sub_10014C30()
{
  return off_100875B8;
}
// 100875B8: using guessed type char *off_100875B8[3];

//----- (10014C40) --------------------------------------------------------
char **sub_10014C40()
{
  return off_100875CC;
}
// 100875CC: using guessed type char *off_100875CC[3];

//----- (10014C50) --------------------------------------------------------
char **sub_10014C50()
{
  return off_10087680;
}
// 10087680: using guessed type char *off_10087680[3];

//----- (10014C60) --------------------------------------------------------
bool sub_10014C60()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // ST50_1@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"156", (int)"R00028727");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"157", (int)"R00134253");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"158", (int)"R00134254");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"159", (int)"R00134255");
  v0 = sub_10024B60(12);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"163",
    (int)"For GEA 1, selected data is IOP_GEA_1_DATA",
    v0,
    0,
    0,
    0);
  v1 = sub_10024B60(13);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"167",
    (int)"For GEA 2, selected data is IOP_GEA_2_DATA",
    v1,
    1u,
    0,
    0);
  v2 = sub_10024B60(14);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"171",
    (int)"For GEA 3, selected data is IOP_GEA_3_DATA",
    v2,
    2u,
    0,
    0);
  v3 = sub_10024B60(4);
  return sub_1002DAE0(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)&unk_10087EA0,
           (int)"For invalid case, selected data defaults to IOP_GEA_1_DATA",
           v3,
           0,
           0,
           0);
}

//----- (10014D90) --------------------------------------------------------
bool sub_10014D90()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // ST50_1@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"205", (int)"R00023188");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"206", (int)"R00023329");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"207", (int)"R00023351");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"208", (int)"R00023367");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"209", (int)"R00023376");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"210", (int)"R00023988");
  v0 = sub_10024C00(0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"214",
    (int)"For GEA 1 data, configured product is IOP_GEA_1_DATA",
    v0,
    0xCu,
    0,
    0);
  v1 = sub_10024C00(1u);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"218",
    (int)"For GEA 2 data, configured product is IOP_GEA_2_DATA",
    v1,
    0xDu,
    0,
    0);
  v2 = sub_10024C00(2u);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"222",
    (int)"For GEA 3 data, configured product is IOP_GEA_3_DATA",
    v2,
    0xEu,
    0,
    0);
  v3 = sub_10024C00(0x43u);
  return sub_1002DAE0(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"226",
           (int)"For invalid data, configured product is IOP_NMBR_CNFG_PROD_TYPES",
           v3,
           0x43u,
           0,
           0);
}

//----- (10014F00) --------------------------------------------------------
bool sub_10014F00()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // ST54_1@1
  int v8; // [sp+4h] [bp-4h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"256", (int)"R00028727");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"257", (int)"R00134253");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"258", (int)"R00134254");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"259", (int)"R00134255");
  v0 = sub_10024C60(0, 1u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"272", (int)"Successfully completed lookup.", v0, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"274",
    (int)"First channel of the main board's analogs is returned.",
    v8,
    1u,
    0,
    0);
  v1 = sub_10024C60(1u, 0, 1, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"287", (int)"Successfully completed lookup.", v1, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"289",
    (int)"Second channel of the I/O A board's current monitors is returned.",
    v8,
    0x28u,
    0,
    0);
  v2 = sub_10024C60(2u, 7u, 2, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"302", (int)"Successfully completed lookup.", v2, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"304",
    (int)"Third channel of the I/O B board's discretes is returned.",
    v8,
    0x29u,
    0,
    0);
  v3 = sub_10024C60(3u, 1u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"317",
    (int)"Invalid board caused invalid channel conversion.",
    v3,
    0,
    0);
  v4 = sub_10024C60(2u, 8u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"331",
    (int)"Invalid channel type caused invalid channel conversion.",
    v4,
    0,
    0);
  v5 = sub_10024C60(0, 0, -1, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"345",
    (int)"Misconfigured channel caused invalid channel conversion.",
    v5,
    0,
    0);
  v6 = sub_10024C60(2u, 1u, 10, (unsigned __int8 *)&v8);
  return sub_1002A360(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"358",
           (int)"Out-of-range channel index caused invalid channel conversion.",
           v6,
           0,
           0);
}

//----- (10015180) --------------------------------------------------------
bool sub_10015180()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // ST58_1@1
  int v8; // [sp+4h] [bp-4h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"388", (int)"R00023203");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"389", (int)"R00023976");
  v0 = sub_10024CB0(0, 1u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"403", (int)"Successfully completed lookup.", v0, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"405",
    (int)"First channel of the main board's analogs is returned.",
    v8,
    1u,
    0,
    0);
  v1 = sub_10024CB0(1u, 0, 1, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"419", (int)"Successfully completed lookup.", v1, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"421",
    (int)"Second channel of the I/O A board's current monitors is returned.",
    v8,
    0x25u,
    0,
    0);
  v2 = sub_10024CB0(2u, 7u, 2, (unsigned __int8 *)&v8);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"435", (int)"Successfully completed lookup.", v2, 1u, 0);
  sub_1002DAE0(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"437",
    (int)"Third channel of the I/O B board's discretes is returned.",
    v8,
    0x74u,
    0,
    0);
  v3 = sub_10024CB0(3u, 1u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"450",
    (int)"Invalid board caused invalid type conversion.",
    v3,
    0,
    0);
  v4 = sub_10024CB0(2u, 8u, 0, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"464",
    (int)"Invalid channel type caused invalid type conversion.",
    v4,
    0,
    0);
  v5 = sub_10024CB0(0, 0, -1, (unsigned __int8 *)&v8);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"477",
    (int)"Misconfigured GEA type caused invalid type conversion.",
    v5,
    0,
    0);
  v6 = sub_10024CB0(2u, 1u, 10, (unsigned __int8 *)&v8);
  return sub_1002A360(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"490",
           (int)"Out-of-range channel index caused invalid type conversion.",
           v6,
           0,
           0);
}

//----- (100153D0) --------------------------------------------------------
bool sub_100153D0()
{
  unsigned __int8 v0; // ST54_1@1
  __int16 v1; // ax@2
  unsigned __int8 v2; // bl@3
  bool result; // al@3
  __int16 v4; // ax@4
  int v5; // [sp+8h] [bp-4h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"522", (int)"R00028727");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"523", (int)"R00134253");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"524", (int)"R00134254");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"525", (int)"R00134255");
  v0 = sub_10024CB0(0, 1u, 0, (unsigned __int8 *)&v5);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"538", (int)"Type lookup successful.", v0, 1u, 0);
  if ( v0 )
  {
    v1 = sub_10024D00(v5);
    sub_1002CD60(
      0,
      0,
      (int)".\\test\\tst_iop_gea.c",
      (int)"545",
      (int)"Main board's first analog channel label is ANALOG IN.",
      v1,
      0x2D3u,
      0,
      0);
  }
  v2 = sub_10024CB0(3u, 1u, 0, (unsigned __int8 *)&v5);
  result = sub_1002A360(
             1,
             0,
             (int)".\\test\\tst_iop_gea.c",
             (int)"559",
             (int)"Type lookup unsuccessful due to out-of-range board index.",
             v2,
             0,
             0);
  if ( !v2 )
  {
    v4 = sub_10024D00(-82);
    result = sub_1002CD60(
               1,
               0,
               (int)".\\test\\tst_iop_gea.c",
               (int)"570",
               (int)"Invalid lookup operation defaults to a space string.",
               v4,
               0,
               0,
               0);
  }
  return result;
}

//----- (10015530) --------------------------------------------------------
bool sub_10015530()
{
  char *v0; // eax@1
  char *v1; // eax@1
  char *v2; // eax@1
  char *v3; // eax@1
  char *v4; // eax@1
  char v6; // [sp+0h] [bp-Ch]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"604", (int)"R00028727");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"605", (int)"R00134253");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"606", (int)"R00134254");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"607", (int)"R00134255");
  sub_10024D40(0, 0, &v6);
  v0 = sub_1002A000("Main board string channel idx 0 is \"1\".");
  sub_1002EB60(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"610", (int)v0, &v6, "1", 0);
  sub_10024D40(0, 1, &v6);
  v1 = sub_1002A000("Main board string channel idx 1 is \"2\".");
  sub_1002EB60(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"612", (int)v1, &v6, "2", 0);
  sub_10024D40(0, 16, &v6);
  v2 = sub_1002A000("Main board string channel idx 16 is \"17\".");
  sub_1002EB60(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"614", (int)v2, &v6, "17", 0);
  sub_10024D40(1, 5, &v6);
  v3 = sub_1002A000("I/O A board string channel idx 5 is \"6A\".");
  sub_1002EB60(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"616", (int)v3, &v6, "6A", 0);
  sub_10024D40(2, 10, &v6);
  v4 = sub_1002A000("I/O B board string channel idx 10 is \"11B\".");
  sub_1002EB60(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"618", (int)v4, &v6, "11B", 0);
  sub_10024D40(8, 0, &v6);
  return sub_1002EB60(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"620",
           (int)"Invalid board index results in empty string.",
           &v6,
           &byte_10065A71,
           0);
}

//----- (10015730) --------------------------------------------------------
bool sub_10015730()
{
  int v0; // eax@1

  v0 = sub_10007240(3, 0);
  return sub_1002D160(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"648", (int)"Offset:", v0, 0, 0, 0);
}

//----- (10015760) --------------------------------------------------------
bool __usercall sub_10015760@<al>(int a1@<esi>)
{
  char v2; // [sp+13h] [bp-9h]@1
  float v3; // [sp+14h] [bp-8h]@1
  int v4; // [sp+18h] [bp-4h]@1

  v3 = 9.8999998e24;
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"683", (int)"R00028699");
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"685",
    (int)"FUEL QTY C 1 - val: 1, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Au, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"687", (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"688", (int)"Value:", v3, 1.0, 0.0, 0);
  sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_iop_gea.c", (int)"690", (int)"FUEL QTY C 2 - invalid data");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Bu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"692", (int)"Status:", v4, 0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"694",
    (int)"FUEL QTY L 1 - val: 3, high: 200, low: 5, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Cu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"696", (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"697", (int)"Value:", v3, 5.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"699",
    (int)"FUEL QTY L 2 - val: 4, high: 1, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Du, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"701", (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"702", (int)"Value:", v3, 1.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088C18,
    (int)"FUEL QTY L 3 - val: 5, high: 200, low: 0, slope: 5, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Eu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088C14, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"707", (int)"Value:", v3, 25.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088BC8,
    (int)"FUEL QTY L 4 - val: 6, high: 200, low: 0, slope: 1, offset: 50");
  LOBYTE(v4) = sub_100084D0(a1, 0x3Fu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088BC4, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"712", (int)"Value:", v3, 56.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088B78,
    (int)"FUEL QTY L 5 - val: 7, high: 200, low: 0, slope: 1, offset: -5");
  LOBYTE(v4) = sub_100084D0(a1, 0x40u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088B74, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"717", (int)"Value:", v3, 2.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088B28,
    (int)"FUEL QTY R 1 - val: 8, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x41u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088B24, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"722", (int)"Value:", v3, 8.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088AD8,
    (int)"FUEL QTY R 2 - val: 9, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x42u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088AD4, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"727", (int)"Value:", v3, 9.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088A88,
    (int)"FUEL QTY R 3 - val: 10, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x43u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088A84, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"732", (int)"Value:", v3, 10.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088A38,
    (int)"FUEL QTY R 4 - val: 11, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x44u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088A34, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"737", (int)"Value:", v3, 11.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100889E8,
    (int)"FUEL QTY R 5 - val: 12, high: 200, low: 0, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x45u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_100889E4, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"742", (int)"Value:", v3, 12.0, 0.0, 0);
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"744", (int)"R00028700");
  v2 = 4;
  sub_100195A0(14, (int)&v2);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100889A4,
    (int)"FUEL TEMP L - val: 13, offset: 10");
  LOBYTE(v4) = sub_100084D0(a1, 0x4Eu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_100889A0, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"751", (int)"Value:", v3, 23.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088970,
    (int)"FUEL TEMP R - val: 14, offset: 20");
  LOBYTE(v4) = sub_100084D0(a1, 0x4Fu, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_1008896C, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"756", (int)"Value:", v3, 34.0, 0.0, 0);
  v2 = 10;
  sub_100195A0(14, (int)&v2);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_10088934,
    (int)"FUEL TEMP L (deg F) - val: 13, offset: 10");
  sub_100084D0(a1, 0x4Eu, &v3);
  sub_1002ACA0(0, 6, (int)".\\test\\tst_iop_gea.c", (int)"767", (int)"Value:", v3, 18.555, 0.0099999998, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100888F8,
    (int)"FUEL TEMP R (deg F) - val: 14, offset: 20");
  sub_100084D0(a1, 0x4Fu, &v3);
  sub_1002ACA0(0, 6, (int)".\\test\\tst_iop_gea.c", (int)"771", (int)"Value:", v3, 25.111, 0.0099999998, 0);
  v2 = 4;
  sub_100195A0(14, (int)&v2);
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"776", (int)"R00028701");
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100888B4,
    (int)"FUEL ALT L - val: 15, no calibration");
  LOBYTE(v4) = sub_100084D0(a1, 0x98u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_100888B0, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"780", (int)"Value:", v3, 15.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_1008887C,
    (int)"FUEL ALT R - val: 16, no calibration");
  LOBYTE(v4) = sub_100084D0(a1, 0x99u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088878, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"785", (int)"Value:", v3, 16.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"Tested Requirement:",
    (int)".\\test\\tst_iop_gea.c",
    (int)"787",
    (int)"R00028702, R00028703, R00028704, R00028705");
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100887F8,
    (int)"RUDDER TRIM - val: 17, high: 100, low: 0, slope: 1.2, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x67u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_100887F4, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 6, (int)".\\test\\tst_iop_gea.c", (int)"791", (int)"Value:", v3, 20.4, 0.001, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100887A0,
    (int)"ELEVATOR TRIM - val: 18, high: 100, low: 19.1, slope: 1, offset: 1");
  LOBYTE(v4) = sub_100084D0(a1, 0x68u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_1008879C, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"796", (int)"Value:", v3, 19.1, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_1008874C,
    (int)"RH ELEV TRIM - val: 19, high: 100, low: 19.1, slope: 1, offset: 1");
  LOBYTE(v4) = sub_100084D0(a1, 0xC0u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_10088748, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"801", (int)"Value:", v3, 20.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"803",
    (int)"FLAPS POS - val: 20, high: 20.1, low: 19.9, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x69u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"805", (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"806", (int)"Value:", v3, 20.0, 0.0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)&unk_100886AC,
    (int)"AILERON TRIM - val: 21, high: 20.9, low: 20, slope: 1, offset: 0");
  LOBYTE(v4) = sub_100084D0(a1, 0x70u, &v3);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)&unk_100886A8, (int)"Status:", v4, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"811", (int)"Value:", v3, 20.9, 0.0, 0);
  sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_iop_gea.c", (int)"813", (int)"NON CAL DATA - N1");
  LOBYTE(v4) = sub_100084D0(a1, 0x19u, &v3);
  return sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"815", (int)"Status:", v4, 0, 0);
}

//----- (100163F0) --------------------------------------------------------
bool sub_100163F0()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // ST58_1@1

  v0 = sub_10022FD0(0, 0, 5, 0, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1191", (int)"Active analog in data.", v0, 0, 0);
  v1 = sub_10022FD0(0, 0, 4, 0, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1194", (int)"Active discrete out data.", v1, 0, 0);
  v2 = sub_10022FD0(0, 0, 10, 0, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1197", (int)"Active digital in data.", v2, 0, 0);
  v3 = sub_10022FD0(0, 0, 3, 0, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1200", (int)"Active discrete in data.", v3, 0, 0);
  v4 = sub_10022FD0(0, 0, 23, 0, 0);
  return sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1203", (int)"Invalid configuration type.", v4, 0, 0);
}

//----- (10016510) --------------------------------------------------------
bool sub_10016510()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // al@1
  unsigned __int8 v7; // al@1
  unsigned __int8 v8; // ST58_1@1
  float v10; // [sp+14h] [bp-4h]@1

  v10 = 9.8999998e24;
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1281", (int)"R00028710");
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"1285",
    (int)"Get input data for an invalid input (IOP_EAU_NMBR_INPUT_TYPES)");
  v0 = sub_10008280(0x1D8u, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1287", (int)"Status:", v0, 0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"1292",
    (int)"Get input data for a disabled input (IOP_EAU_INPUT_TYPE_CRNT_MNTR)");
  v1 = sub_10008280(0x62u, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1294", (int)"Status:", v1, 0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"1299",
    (int)"Get input data for an input that is off (IOP_EAU_INPUT_TYPE_OFF)");
  v2 = sub_10008280(0, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1301", (int)"Status:", v2, 0, 0);
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"1306",
    (int)"Get input data for an input with invalid data (IOP_EAU_INPUT_TYPE_ENG_1_N2)");
  v3 = sub_10008280(0x1Au, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1308", (int)"Status:", v3, 0, 0);
  v4 = sub_10008280(0x17u, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1315", (int)"Out of range ITT data. Status:", v4, 0, 0);
  v5 = sub_10008280(0x19u, &v10);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1321", (int)"Valid N1 data. Status:", v5, 1u, 0);
  sub_1002ACA0(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1322", (int)"Value:", v10, 0.5, 0.0, 0);
  v6 = sub_10024E30(0, 0, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1328", (int)"Invalid data type output. Status:", v6, 0, 0);
  v7 = sub_10024DD0(0, (_BYTE *)1, 0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1334", (int)"Invalid pkt ID. Status:", v7, 0, 0);
  v8 = sub_10024DD0(0, 0, (_WORD *)1);
  return sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1340", (int)"Invalid pipe. Status:", v8, 0, 0);
}

//----- (100167B0) --------------------------------------------------------
bool sub_100167B0()
{
  bool v0; // ST50_1@1
  char v2; // [sp+4h] [bp-78h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1372", (int)"R00028715");
  sub_1002F1B0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_gea.c",
    (int)"1373",
    (int)"Attempting to access product data for an invalid GEA");
  v0 = sub_100083A0(4, &v2);
  return sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1375", (int)"Valid:", v0, 0, 0);
}

//----- (10016840) --------------------------------------------------------
bool sub_10016840()
{
  int v0; // eax@1

  v0 = sub_100230E0(4);
  return sub_1002D160(
           0,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"1403",
           (int)"Attempt to get config for invalid GEA.",
           v0,
           0xA452u,
           0,
           0);
}

//----- (10016870) --------------------------------------------------------
bool sub_10016870()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // ST4C_1@1

  v0 = sub_10022F30(0x1D8u);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1485",
    (int)"Attempt to get config for invalid GEA input type.",
    v0,
    0,
    0);
  v1 = sub_10008A10(4u, 0);
  return sub_1002A360(
           0,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"1488",
           (int)"Attempt to get active channel config for invalid GEA.",
           v1,
           0,
           0);
}

//----- (100168E0) --------------------------------------------------------
bool sub_100168E0()
{
  int v0; // eax@1
  int v1; // eax@1
  int v3; // [sp+0h] [bp-E74h]@1
  int v4; // [sp+4h] [bp-E70h]@1
  char v5; // [sp+Ch] [bp-E68h]@1
  int v6; // [sp+E68h] [bp-Ch]@1
  int v7; // [sp+E6Ch] [bp-8h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1516", (int)"R00028727");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1517", (int)"R00134253");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1518", (int)"R00134254");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1519", (int)"R00134255");
  v0 = sub_100230E0(0);
  v1 = sub_10018540(v0, (int)&v5, 3684);
  sub_1002B160(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1528",
    (int)"Read configuration CRC successfully",
    v1,
    0,
    0,
    0);
  sub_100072F0(0, (int)&v3);
  sub_1002CD60(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1531",
    (int)"Received correct analog config CRC",
    v3,
    v6,
    0,
    0);
  sub_1002CD60(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1532",
    (int)"Received correct annunciator config CRC",
    HIWORD(v3),
    HIWORD(v6),
    0,
    0);
  sub_1002CD60(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1533",
    (int)"Received correct digital config CRC",
    v4,
    v7,
    0,
    0);
  return sub_1002CD60(
           0,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"1534",
           (int)"Received correct discrete config CRC",
           HIWORD(v4),
           HIWORD(v7),
           0,
           0);
}

//----- (10016A50) --------------------------------------------------------
char __cdecl sub_10016A50(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( dword_102229B4 == -24 && (unsigned int)dword_1021A3C8 < 0xFFFFFFC2 && dword_1021A3C8 )
    {
      dword_102229B4 = dword_1021A3C8;
      result = 1;
    }
  }
  else
  {
    if ( (unsigned int)dword_102229B4 < 0xFFFFFFC2 )
    {
      if ( dword_102229B4 )
      {
        dword_1021A3C8 = dword_102229B4;
        result = 1;
      }
    }
    dword_102229B4 = -24;
  }
  return result;
}
// 1021A3C8: using guessed type int dword_1021A3C8;
// 102229B4: using guessed type int dword_102229B4;

//----- (10016AA0) --------------------------------------------------------
bool sub_10016AA0()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // al@1
  unsigned __int8 v7; // ST58_1@1
  int v9; // [sp+4h] [bp-4h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"849", (int)"R00028710");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"850", (int)"R00028712");
  v0 = sub_10008D60(0.0, 240, (int)&v9);
  sub_1002A360(1, 0, (int)".\\test\\tst_iop_gea.c", (int)"853", (int)"Successfully retrieved 2.5V Ref", v0, 1u, 0);
  v1 = sub_10008D60(COERCE_FLOAT(4), 240, (int)&v9);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"855",
    (int)"Out-of-range GEA index caused invalid internal data",
    v1,
    0,
    0);
  v2 = sub_10008D60(0.0, 219, (int)&v9);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"857",
    (int)"Above-maximum internal data index caused invalid internal data",
    v2,
    0,
    0);
  v3 = sub_10008D60(0.0, 249, (int)&v9);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"859",
    (int)"Below-minimum internal data index caused invalid internal data",
    v3,
    0,
    0);
  v4 = sub_10016A50(0);
  sub_1002A360(1, 0, (int)".\\test\\tst_iop_gea.c", (int)"861", (int)"Disabled shared memory interface", v4, 1u, 0);
  v5 = sub_10008D60(0.0, 240, (int)&v9);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"863",
    (int)"Invalid GEA shared memory interface caused invalid 2.5V Ref",
    v5,
    0,
    0);
  v6 = sub_10016A50(1);
  sub_1002A360(1, 0, (int)".\\test\\tst_iop_gea.c", (int)"865", (int)"Re-enabled shared memory interface", v6, 1u, 0);
  v7 = sub_10008D60(0.0, 240, (int)&v9);
  return sub_1002A360(
           1,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"867",
           (int)"Successfully retrieved 2.5V Ref",
           v7,
           1u,
           0);
}

//----- (10016C90) --------------------------------------------------------
bool sub_10016C90()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // al@1
  unsigned __int8 v7; // al@1
  unsigned __int8 v8; // al@1
  unsigned __int8 v9; // al@1
  unsigned __int8 v10; // al@1
  unsigned __int8 v11; // al@1
  unsigned __int8 v12; // al@1
  unsigned __int8 v13; // al@1
  unsigned __int8 v14; // al@1
  unsigned __int8 v15; // al@1
  unsigned __int8 v16; // al@1
  unsigned __int8 v17; // al@1
  unsigned __int8 v18; // al@1
  unsigned __int8 v19; // al@1
  unsigned __int8 v20; // al@1
  unsigned __int8 v21; // al@1
  unsigned __int8 v22; // al@1
  unsigned __int8 v23; // al@1
  unsigned __int8 v24; // al@1
  unsigned __int8 v25; // al@1
  unsigned __int8 v26; // al@1
  unsigned __int8 v27; // al@1
  unsigned __int8 v28; // al@1
  unsigned __int8 v29; // al@1
  unsigned __int8 v30; // al@1
  unsigned __int8 v31; // al@1
  unsigned __int8 v32; // al@1
  unsigned __int8 v33; // ST64_1@1
  char v35; // [sp+Ch] [bp-30h]@1
  char v36; // [sp+Dh] [bp-2Fh]@1
  char v37; // [sp+Eh] [bp-2Eh]@1
  char v38; // [sp+Fh] [bp-2Dh]@1
  signed int v39; // [sp+10h] [bp-2Ch]@1
  char v40; // [sp+11h] [bp-2Bh]@1
  int v41; // [sp+14h] [bp-28h]@1
  int v42; // [sp+18h] [bp-24h]@1
  int v43; // [sp+1Ch] [bp-20h]@1
  int v44; // [sp+20h] [bp-1Ch]@1
  int v45; // [sp+24h] [bp-18h]@1
  int v46; // [sp+28h] [bp-14h]@1
  int v47; // [sp+2Ch] [bp-10h]@1
  int v48; // [sp+30h] [bp-Ch]@1
  int v49; // [sp+34h] [bp-8h]@1
  char v50; // [sp+38h] [bp-4h]@1

  memset(&v35, 0, 0x30u);
  v50 = 0;
  v36 = -82;
  sub_100078E0(0, &v35);
  v0 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"905",
    (int)"Attempt to get config for invalid analog input type.",
    v0,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v37 = 7;
  sub_100078E0(0, &v35);
  v1 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"912",
    (int)"Attempt to get config for invalid analog sensor type.",
    v1,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v38 = 6;
  sub_100078E0(0, &v35);
  v2 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"919",
    (int)"Attempt to get config for invalid analog update rate.",
    v2,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v40 = 6;
  sub_100078E0(0, &v35);
  v3 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"926",
    (int)"Attempt to get config for invalid analog gain level.",
    v3,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v42 = 2139095040;
  sub_100078E0(0, &v35);
  v4 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"934",
    (int)"Attempt to get config for invalid analog param_1.",
    v4,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v43 = 2139095040;
  sub_100078E0(0, &v35);
  v5 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"942",
    (int)"Attempt to get config for invalid analog param_2.",
    v5,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v44 = 2139095040;
  sub_100078E0(0, &v35);
  v6 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"950",
    (int)"Attempt to get config for invalid analog param_3.",
    v6,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v45 = 2139095040;
  sub_100078E0(0, &v35);
  v7 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"958",
    (int)"Attempt to get config for invalid param_4.",
    v7,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v46 = 2139095040;
  sub_100078E0(0, &v35);
  v8 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"966",
    (int)"Attempt to get config for invalid analog param_5.",
    v8,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v47 = 2139095040;
  sub_100078E0(0, &v35);
  v9 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"974",
    (int)"Attempt to get config for invalid analog param_6.",
    v9,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v48 = 2139095040;
  sub_100078E0(0, &v35);
  v10 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"982",
    (int)"Attempt to get config for invalid analog filter.",
    v10,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  v49 = 2139095040;
  sub_100078E0(0, &v35);
  v11 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"990",
    (int)"Attempt to get config for invalid analog hysteresis.",
    v11,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 1;
  v36 = -82;
  sub_100078E0(0, &v35);
  v12 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1000",
    (int)"Attempt to get config for invalid annunciator discrete type.",
    v12,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 1;
  v37 = 2;
  sub_100078E0(0, &v35);
  v13 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1007",
    (int)"Attempt to get config for invalid annunciator active type.",
    v13,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v36 = -82;
  sub_100078E0(0, &v35);
  v14 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1017",
    (int)"Attempt to get config for invalid digital input type.",
    v14,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 0;
  sub_100078E0(0, &v35);
  v15 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1024",
    (int)"Attempt to get config for invalid digital sensor type.",
    v15,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v38 = 6;
  sub_100078E0(0, &v35);
  v16 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1032",
    (int)"Attempt to get config for invalid digital update rate.",
    v16,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v39 = 2139095040;
  sub_100078E0(0, &v35);
  v17 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1041",
    (int)"Attempt to get config for invalid digital param_1.",
    v17,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v41 = 2139095040;
  sub_100078E0(0, &v35);
  v18 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1050",
    (int)"Attempt to get config for invalid digital param_2.",
    v18,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v42 = 2139095040;
  sub_100078E0(0, &v35);
  v19 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1059",
    (int)"Attempt to get config for invalid digital param_3.",
    v19,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v43 = 2139095040;
  sub_100078E0(0, &v35);
  v20 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1068",
    (int)"Attempt to get config for invalid digital param_4.",
    v20,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v44 = 2139095040;
  sub_100078E0(0, &v35);
  v21 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1077",
    (int)"Attempt to get config for invalid digital param_5.",
    v21,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v45 = 2139095040;
  sub_100078E0(0, &v35);
  v22 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1086",
    (int)"Attempt to get config for invalid digital param_6.",
    v22,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v46 = 2139095040;
  sub_100078E0(0, &v35);
  v23 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1095",
    (int)"Attempt to get config for invalid digital filter.",
    v23,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 2;
  v37 = 5;
  v47 = 2139095040;
  sub_100078E0(0, &v35);
  v24 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1104",
    (int)"Attempt to get config for invalid digital hysteresis.",
    v24,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 3;
  v36 = -82;
  sub_100078E0(0, &v35);
  v25 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1114",
    (int)"Attempt to get config for invalid discrete type.",
    v25,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 3;
  v37 = 2;
  sub_100078E0(0, &v35);
  v26 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1121",
    (int)"Attempt to get config for invalid discrete active type.",
    v26,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 3;
  v39 = 2139095040;
  sub_100078E0(0, &v35);
  v27 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1129",
    (int)"Attempt to get config for invalid discrete active debounce time.",
    v27,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 3;
  v41 = 2139095040;
  sub_100078E0(0, &v35);
  v28 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1137",
    (int)"Attempt to get config for invalid discrete inactive debounce time.",
    v28,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = -1;
  sub_100078E0(0, &v35);
  v29 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1146",
    (int)"Attempt to get config for out of range channel config type.",
    v29,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 4;
  sub_100078E0(0, &v35);
  v30 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1152",
    (int)"Attempt to get config for invalid channel config type.",
    v30,
    0,
    0);
  memset(&v35, 0, 0x30u);
  v50 = 0;
  sub_100078E0(0, &v35);
  v31 = sub_10016A50(0);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1161", (int)"Disabled shared memory interface", v31, 1u, 0);
  v32 = sub_10008A10(0, (int)&v35);
  sub_1002A360(
    0,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1163",
    (int)"Attempt to get config when shared memory interface is closed.",
    v32,
    0,
    0);
  v33 = sub_10016A50(1);
  return sub_1002A360(
           0,
           0,
           (int)".\\test\\tst_iop_gea.c",
           (int)"1165",
           (int)"Enabled shared memory interface",
           v33,
           1u,
           0);
}

//----- (10017710) --------------------------------------------------------
char sub_10017710()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // ST50_1@1
  char v4; // [sp+4h] [bp-8h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1235", (int)"R00028697");
  sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_iop_gea.c", (int)"1236", (int)"Retrieve a valid CRC for GEA 1");
  v0 = sub_10008D00(0, (int)&v4);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1238", (int)"valid:", v0, 1u, 0);
  sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_iop_gea.c", (int)"1239", (int)"Attempt to get CRC for invalid GEA");
  v1 = sub_10008D00(4u, (int)&v4);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1241", (int)"valid:", v1, 0, 0);
  sub_10016A50(0);
  v2 = sub_10008D00(0, (int)&v4);
  sub_1002A360(0, 0, (int)".\\test\\tst_iop_gea.c", (int)"1245", (int)"valid:", v2, 0, 0);
  return sub_10016A50(1);
}

//----- (10017810) --------------------------------------------------------
bool sub_10017810()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // ST50_1@1
  char v6; // [sp+4h] [bp-4h]@1

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1433", (int)"R00028717");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1434", (int)"R00028718");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1435", (int)"R00028719");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1436", (int)"R00028720");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1437", (int)"R00028721");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1438", (int)"R00028722");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1439", (int)"R00028723");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1440", (int)"R00028724");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gea.c", (int)"1441", (int)"R00028725");
  v0 = sub_10008E20(4u, &v6);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1444",
    (int)"Out-of-range GEA index caused invalid system status",
    v0,
    0,
    0);
  v1 = sub_10016A50(0);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1447",
    (int)"Disabled GEA shared memory interface.",
    v1,
    1u,
    0);
  v2 = sub_10008E20(0, &v6);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1450",
    (int)"Invalid shared memory interface caused get system status to fail.",
    v2,
    0,
    0);
  v3 = sub_10016A50(1);
  sub_1002A360(
    1,
    0,
    (int)".\\test\\tst_iop_gea.c",
    (int)"1453",
    (int)"Re-enabled GEA shared memory interface.",
    v3,
    1u,
    0);
  v4 = sub_10008E20(0, &v6);
  return sub_1002A360(1, 0, (int)".\\test\\tst_iop_gea.c", (int)"1456", (int)"Get system status succeeded.", v4, 1u, 0);
}

//----- (10017A10) --------------------------------------------------------
bool sub_10017A10()
{
  signed int v0; // esi@1
  char **v1; // edi@3
  signed int v2; // esi@4
  unsigned __int8 v3; // ST34_1@5
  unsigned __int8 v4; // al@5
  bool result; // al@5
  char v6[4]; // [sp+8h] [bp-4h]@2

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"181", (int)"R00029911");
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"182", (int)"R00029913");
  v0 = 0;
  do
  {
    v6[v0] = sub_1001E3D0(word_1008A800[4 * v0]);
    ++v0;
  }
  while ( v0 < 4 );
  v1 = &off_1008A824;
  do
  {
    ((void (__cdecl *)(signed int, char *))*(v1 - 1))(836, &byte_10222BE0);
    v2 = 0;
    do
    {
      sub_1001F7C0((int)&unk_1021A300, "Verify no change in ", 200);
      sub_1001F920((const char *)&unk_1021A300, *(_BYTE **)&off_1008A804[8 * v2], 200);
      sub_1001F920((const char *)&unk_1021A300, " alert after ", 200);
      sub_1001F920((const char *)&unk_1021A300, *v1, 200);
      sub_1001F920((const char *)&unk_1021A300, " call with invalid inputs", 200);
      v3 = v6[v2];
      v4 = sub_1001E3D0(word_1008A800[4 * v2]);
      result = sub_1002A360(1, 0, (int)".\\test\\tst_iop_gtx.c", (int)"209", (int)&unk_1021A300, v4, v3, 0);
      ++v2;
    }
    while ( v2 < 4 );
    v1 += 2;
  }
  while ( (signed int)v1 < (signed int)&off_1008A834 );
  return result;
}
// 10017A10: too many cbuild loops
// 1008A800: using guessed type __int16 word_1008A800[];
// 1008A824: using guessed type char *off_1008A824;
// 1008A834: using guessed type char *off_1008A834;
// 10222BE0: using guessed type char byte_10222BE0;
// 10017A10: using guessed type char var_4[4];

//----- (10017B50) --------------------------------------------------------
bool sub_10017B50()
{
  void *v0; // esi@1
  bool v1; // al@2
  bool result; // al@2
  char v3; // [sp+4h] [bp-10h]@2

  v0 = &unk_1008A831;
  do
  {
    sub_1001F7C0(
      (int)&unk_1021A300,
      "Verify the return value is invalid after a iop_get_gtx_status_data() call with an invalid ",
      200);
    sub_1001F920((const char *)&unk_1021A300, *(_BYTE **)((char *)v0 + 3), 200);
    v1 = sub_10021D70(*((char *)v0 - 1), *(_BYTE *)v0, &v3);
    result = sub_1002A360(1, 0, (int)".\\test\\tst_iop_gtx.c", (int)"272", (int)&unk_1021A300, v1, 0, 0);
    v0 = (char *)v0 + 8;
  }
  while ( (signed int)v0 < (signed int)&unk_1008A841 );
  return result;
}

//----- (10017BF0) --------------------------------------------------------
bool __thiscall sub_10017BF0(void *this)
{
  char v1; // al@1
  char v2; // bl@1
  char v3; // ST4C_1@1
  bool v4; // bl@1
  void *v5; // ecx@1
  bool v6; // ST50_1@1
  unsigned __int8 v7; // ST4C_1@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  int v11; // [sp+18h] [bp-8h]@1

  v1 = sub_1001C0E0((int)this);
  v2 = v1;
  v3 = v1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"311", (int)"R00071959");
  sub_1000EA90(0, (unsigned __int16)word_1008A7FA[2 * (unsigned __int8)v2], &v9, 0, 2, 0);
  v4 = sub_10021D70(v3, 2, &v9);
  v6 = sub_1001C9F0(v5);
  v7 = sub_10021D70(v3, 2, &v9) || v4;
  sub_1002A360(1, 0, (int)".\\test\\tst_iop_gtx.c", (int)"326", (int)"Verify the GTX 3000 data is  invalid", v7, 0, 0);
  return sub_1002A360(
           1,
           0,
           (int)".\\test\\tst_iop_gtx.c",
           (int)"327",
           (int)"Retrieve the ADS-B transmit state with invalid GTX 3000 data",
           v6,
           0,
           0);
}
// 1008A7FA: using guessed type __int16 word_1008A7FA[];

//----- (10017CE0) --------------------------------------------------------
bool sub_10017CE0()
{
  unsigned __int8 v0; // bl@1
  void *v1; // esi@1
  unsigned __int8 v2; // ST5C_1@2
  bool result; // al@2
  char v4; // [sp+10h] [bp-2Ch]@1
  char v5; // [sp+24h] [bp-18h]@2

  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"477", (int)"R00134008");
  v0 = sub_1000F100(0, 417, &v4);
  v1 = &unk_1008A840;
  do
  {
    sub_10021F50(*(_BYTE *)v1, *((_BYTE *)v1 + 1), 0);
    sub_1001F7C0(
      (int)&unk_1021A300,
      "Verify no change in the GTX command packet after a iop_send_gtx_cmd() call with an invalid ",
      200);
    sub_1001F920((const char *)&unk_1021A300, *((_BYTE **)v1 + 1), 200);
    v2 = sub_1000F100(0, 417, &v5);
    result = sub_1002A360(1, 0, (int)".\\test\\tst_iop_gtx.c", (int)"498", (int)&unk_1021A300, v2, v0, 0);
    if ( v0 )
      result = sub_1002E980(1, 0, (int)".\\test\\tst_iop_gtx.c", (int)"508", (int)&unk_1021A300, &v5, &v4, 0x14u, 0);
    v1 = (char *)v1 + 8;
  }
  while ( (signed int)v1 < (signed int)byte_1008A858 );
  return result;
}

//----- (10017DF0) --------------------------------------------------------
bool __thiscall sub_10017DF0(void *this)
{
  char v1; // bl@1
  unsigned int v2; // esi@1
  int v3; // ST20_4@5
  bool v4; // al@7
  bool result; // al@9
  int v6; // [sp+Ch] [bp-18h]@1
  int v7; // [sp+10h] [bp-14h]@1
  int v8; // [sp+14h] [bp-10h]@1
  char v9; // [sp+18h] [bp-Ch]@5
  int v10; // [sp+20h] [bp-4h]@6

  v1 = sub_1001C0E0((int)this);
  v6 = 0;
  v8 = 0;
  HIWORD(v6) = 668;
  v7 = 41944795;
  LOBYTE(v6) = 8;
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"587", (int)"R00028968");
  v2 = 0;
  do
  {
    sub_1001F7C0((int)&unk_1021A300, "Verify that the ", 200);
    sub_1001F920((const char *)&unk_1021A300, *(_BYTE **)&off_1008A85C[v2], 200);
    if ( byte_1008A859[v2] )
      sub_1001F920((const char *)&unk_1021A300, " error ", 200);
    else
      sub_1001F920((const char *)&unk_1021A300, " warning ", 200);
    sub_1001F920((const char *)&unk_1021A300, "bit is retrieved as expected.", 200);
    v3 = (unsigned __int16)word_1008A7F8[2 * (unsigned __int8)v1];
    v8 = 1 << byte_1008A858[v2];
    sub_1000EA90(0, v3, &v6, 0, 12, 1);
    v4 = sub_1000F100(0, (unsigned __int16)word_1008A7F8[2 * (unsigned __int8)v1], &v9) && v10 == v8;
    sub_1002A360(0, 0, (int)".\\test\\tst_iop_gtx.c", (int)"611", (int)&unk_1021A300, v4, 1u, 0);
    result = sub_1002A360(
               0,
               0,
               (int)".\\test\\tst_iop_gtx.c",
               (int)"618",
               (int)&unk_1021A300,
               (v10 & 0xFFF) == v8,
               byte_1008A859[v2],
               0);
    v2 += 8;
  }
  while ( v2 < 0x78 );
  return result;
}
// 1008A7F8: using guessed type __int16 word_1008A7F8[];

//----- (10017F80) --------------------------------------------------------
bool __thiscall sub_10017F80(void *this)
{
  char v1; // bl@1
  int v2; // edi@1
  unsigned int v3; // esi@1
  char v4; // bl@2
  int v5; // ST30_4@5
  bool result; // al@6
  unsigned __int8 v7; // [sp+Ch] [bp-28h]@5
  int v8; // [sp+10h] [bp-24h]@1
  int v9; // [sp+14h] [bp-20h]@2
  int v10; // [sp+18h] [bp-1Ch]@1
  int v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  int v13; // [sp+24h] [bp-10h]@1
  int v14; // [sp+28h] [bp-Ch]@1
  int v15; // [sp+2Ch] [bp-8h]@1
  int v16; // [sp+30h] [bp-4h]@1

  v1 = sub_1001C0E0((int)this);
  v10 = 0;
  v8 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  HIWORD(v10) = 668;
  v11 = 41944795;
  sub_1002F1B0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gtx.c", (int)"693", (int)"R00028967");
  v2 = 2 * (unsigned __int8)v1;
  v3 = 0;
  do
  {
    LOBYTE(v9) = (unsigned __int8)byte_1008A8D1[v3] < 5u;
    v4 = v9;
    if ( (_BYTE)v9 )
    {
      sub_1001F7C0((int)&unk_1021A300, "Verify that the transponder ", 200);
      sub_1001F920((const char *)&unk_1021A300, *(_BYTE **)&off_1008A8D4[v3], 200);
      sub_1001F920((const char *)&unk_1021A300, " mode value is correctly retrieved.", 200);
    }
    else
    {
      sub_1001F7C0((int)&unk_1021A300, "Verify that the invalid transponder mode value is not retrieved.", 200);
    }
    v5 = (unsigned __int16)word_1008A7F8[v2];
    LOBYTE(v10) = byte_1008A8D0[v3];
    sub_1000EA90(0, v5, &v10, 0, 12, 1);
    sub_1000EA90(0, (unsigned __int16)word_1008A7FA[v2], &v8, 0, 2, 1);
    v7 = sub_1001C9D0(&v13);
    if ( v4 )
    {
      sub_1002A360(0, 0, (int)".\\test\\tst_iop_gtx.c", (int)"722", (int)&unk_1021A300, v7, v9, 0);
      result = sub_1002DAE0(
                 0,
                 0,
                 (int)".\\test\\tst_iop_gtx.c",
                 (int)&unk_10088A88,
                 (int)&unk_1021A300,
                 BYTE3(v13),
                 byte_1008A8D1[v3],
                 0,
                 0);
    }
    else
    {
      result = sub_1002A360(0, 0, (int)".\\test\\tst_iop_gtx.c", (int)"738", (int)&unk_1021A300, v7, 0, 0);
    }
    v3 += 8;
  }
  while ( v3 < 0x30 );
  return result;
}
// 1008A7F8: using guessed type __int16 word_1008A7F8[];
// 1008A7FA: using guessed type __int16 word_1008A7FA[];

//----- (10018130) --------------------------------------------------------
int (**sub_10018130())()
{
  return off_1008ABC8;
}
// 1008ABC8: using guessed type int (*off_1008ABC8[3])();

//----- (10018140) --------------------------------------------------------
int __cdecl sub_10018140(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDD8: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10018160) --------------------------------------------------------
int sub_10018160()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDDE: using guessed type int TSK_pvg_get_id(void);

//----- (10018180) --------------------------------------------------------
int __cdecl sub_10018180(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDE4: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (100181B0) --------------------------------------------------------
__int16 __cdecl sub_100181B0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDEA: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (100181D0) --------------------------------------------------------
int sub_100181D0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDF0: using guessed type int TSK_pvg_get_timer(void);

//----- (100181F0) --------------------------------------------------------
int __cdecl sub_100181F0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CDF6: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018230) --------------------------------------------------------
int __cdecl sub_10018230(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE02: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018260) --------------------------------------------------------
int __cdecl sub_10018260(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE08: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10018280) --------------------------------------------------------
int __cdecl sub_10018280(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE0E: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (100182A0) --------------------------------------------------------
int __cdecl sub_100182A0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE14: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (100182D0) --------------------------------------------------------
int __cdecl sub_100182D0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE1A: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10018300) --------------------------------------------------------
int __cdecl sub_10018300(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE20: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018330) --------------------------------------------------------
int __cdecl sub_10018330(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE26: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10018360) --------------------------------------------------------
int __cdecl sub_10018360(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE2C: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10018380) --------------------------------------------------------
int __cdecl sub_10018380(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE32: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (100183A0) --------------------------------------------------------
char __cdecl sub_100183A0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_100181D0();
  if ( sub_10018260(a1) == 5 )
    goto LABEL_4;
  while ( sub_100181D0() < v2 )
  {
    sub_10018380(20);
    if ( sub_10018260(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10018260(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10018410) --------------------------------------------------------
int __cdecl sub_10018410(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10018160();
    sub_100181F0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CE38: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10018450) --------------------------------------------------------
int __cdecl sub_10018450(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10018280(a2);
  return result;
}
// 100609DC: using guessed type void *tsk_app_hdr_ptr;

//----- (10018480) --------------------------------------------------------
int __cdecl sub_10018480(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_100182A0(a1, a2);
  return result;
}
// 100609DC: using guessed type void *tsk_app_hdr_ptr;

//----- (100184A0) --------------------------------------------------------
int __cdecl sub_100184A0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_1008E568[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1008E56C[2 * v1];
}
// 1008E568: using guessed type int dword_1008E568[];
// 1008E56C: using guessed type int dword_1008E56C[];

//----- (100184F0) --------------------------------------------------------
unsigned int __cdecl sub_100184F0(unsigned int a1)
{
  unsigned int result; // eax@1

  result = 43;
  if ( a1 < 0xA452 )
    result = (unsigned __int16)a1 / 0x3E8u;
  return result;
}

//----- (10018540) --------------------------------------------------------
int __cdecl sub_10018540(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1004CE50: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018560) --------------------------------------------------------
int __cdecl sub_10018560(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+8h] [bp-8h]@1

  v7 = 0;
  *(_DWORD *)a5 = 0;
  LOWORD(v7) = a3;
  *(_DWORD *)(a5 + 4) = -1;
  return reg_read_from_xml(a1, &v6, a4, a2, v7, a5);
}
// 1004CE56: using guessed type int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100185C0) --------------------------------------------------------
char __cdecl sub_100185C0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10018540(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10018A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10018600) --------------------------------------------------------
int __cdecl sub_10018600(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10018540(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10018640) --------------------------------------------------------
int __cdecl sub_10018640(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10018540(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10018670) --------------------------------------------------------
int __cdecl sub_10018670(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1004CE5C: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018690) --------------------------------------------------------
int __cdecl sub_10018690(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10018670(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10019690() )
  {
    v4 = sub_100184A0(a1);
    if ( v4 != 42066 )
      v3 = sub_10018670(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10019690: using guessed type int sub_10019690(void);

//----- (100186F0) --------------------------------------------------------
int __cdecl sub_100186F0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10018690(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10018A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10018730) --------------------------------------------------------
char __cdecl sub_10018730(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10018670(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10018A40("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (100187A0) --------------------------------------------------------
int __cdecl sub_100187A0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10018540(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10018670(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10018800) --------------------------------------------------------
char *__cdecl sub_10018800(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10018160();
  *(_DWORD *)(a5 + 596) = sub_100181D0();
  sub_100181F0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1001F7C0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10020FE0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10018930) --------------------------------------------------------
char sub_10018930()
{
  char result; // al@1

  result = 0;
  byte_101745A0 = 0;
  byte_101745A1 = 0;
  return result;
}
// 101745A0: using guessed type char byte_101745A0;
// 101745A1: using guessed type char byte_101745A1;

//----- (10018940) --------------------------------------------------------
char __cdecl sub_10018940(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10018800(-5, a1, a2, a4, a5);
  else
    sub_10018800(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1001F920((const char *)(a5 + 485), " DBGA", 100);
  sub_100181F0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_101745A0 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_101745A1 )
LABEL_15:
      result = sub_10018230(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10019260: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 101745A0: using guessed type char byte_101745A0;
// 101745A1: using guessed type char byte_101745A1;

//----- (10018A40) --------------------------------------------------------
char __cdecl sub_10018A40(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10018940(a1, a2, a3, a4, (int)&v5);
}

//----- (10018AB0) --------------------------------------------------------
int __cdecl sub_10018AB0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 100196A0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10018B10) --------------------------------------------------------
signed int __cdecl sub_10018B10(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10018B90) --------------------------------------------------------
int __usercall sub_10018B90@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10019530(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10019550(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10018AB0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_100181D0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10019360(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100194E0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10019290(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10019290(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10019340: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10019420: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (10018E90) --------------------------------------------------------
int __usercall sub_10018E90@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 100196A0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10018EB0) --------------------------------------------------------
signed int __cdecl sub_10018EB0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10018480(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10018450(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_10018E90(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10018B90((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10018450(v6, 81);
  return (unsigned __int8)v2;
}

//----- (10018F80) --------------------------------------------------------
int __cdecl sub_10018F80(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_10018B90((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10018A40("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_10018E90(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (10019010) --------------------------------------------------------
int __cdecl sub_10019010(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100206D0(v1);
  a1 = v2;
  v3 = sub_1001E7B0(&a1, 4u, (int)&unk_1008B698, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1008B69C[2 * v3];
}
// 1008B69C: using guessed type int dword_1008B69C[];

//----- (10019050) --------------------------------------------------------
int __cdecl sub_10019050(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100206D0(v1);
  a1 = v2;
  v3 = sub_1001E7B0(&a1, 4u, (int)&unk_1008B6D0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1008B6D4[2 * v3];
}
// 1008B6D4: using guessed type int dword_1008B6D4[];

//----- (10019090) --------------------------------------------------------
int __cdecl sub_10019090(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100206D0(v1);
  a1 = v2;
  v3 = sub_1001E7B0(&a1, 4u, (int)&unk_1008B708, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1008B70C[2 * v3];
}
// 1008B70C: using guessed type int dword_1008B70C[];

//----- (100190D0) --------------------------------------------------------
int __cdecl sub_100190D0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100206D0(v1);
  a1 = v2;
  v3 = sub_1001E7B0(&a1, 4u, (int)&unk_1008B740, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1008B744[2 * v3];
}
// 1008B744: using guessed type int dword_1008B744[];

//----- (10019110) --------------------------------------------------------
int __cdecl sub_10019110(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10019050(a4);
    result = sub_10018540(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10018540(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10019010(a4);
      result = sub_10018540(v6, a3, 6);
    }
  }
  return result;
}

//----- (10019180) --------------------------------------------------------
int __cdecl sub_10019180(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_100190D0(a3);
    result = sub_10018540(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10018380(100);
      v5 = sub_100190D0(a3);
      result = sub_10018540(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10019090(a3);
    result = sub_10018540(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10018380(100);
      v7 = sub_10019090(a3);
      result = sub_10018540(v7, a2, 8);
    }
  }
  return result;
}

//----- (10019290) --------------------------------------------------------
signed int __cdecl sub_10019290(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_10037320(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_10181610 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_10181618[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_10181610 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_100196B0(
        v2,
        *(_DWORD *)(dword_10181618[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_10019290(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 1004CE9E: using guessed type int FIL_vfs_close(void);
// 10181610: using guessed type int dword_10181610;
// 10181618: using guessed type int dword_10181618[];

//----- (100192F0) --------------------------------------------------------
int __cdecl sub_100192F0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1004CEB0: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019360) --------------------------------------------------------
signed int __cdecl sub_10019360(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10027A50(a1);
    return sub_10029460(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10019530(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10019A50(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1004CEC2: using guessed type int FIL_vfs_read(void);

//----- (100193A0) --------------------------------------------------------
signed int __cdecl sub_100193A0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10037360(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10019A50(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1004CEC8: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019430) --------------------------------------------------------
signed int __cdecl sub_10019430(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_100373C0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1004CED4: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019480) --------------------------------------------------------
__int64 __cdecl sub_10019480(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1004CEDA: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100194B0) --------------------------------------------------------
int __cdecl sub_100194B0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1004CEE6: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100194E0) --------------------------------------------------------
int __cdecl sub_100194E0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1004CEF2: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019500) --------------------------------------------------------
char __cdecl sub_10019500(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10019290(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10019530) --------------------------------------------------------
signed int __cdecl sub_10019530(unsigned int a1, int a2, int a3)
{
  return sub_10019430(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10019550) --------------------------------------------------------
int __cdecl sub_10019550(int a1, int a2, int a3)
{
  return sub_100194B0(a1, a2, a3);
}

//----- (10019570) --------------------------------------------------------
void __cdecl sub_10019570(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10019BA0(a1, a2);
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CEF8: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (100195A0) --------------------------------------------------------
int __cdecl sub_100195A0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CEFE: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (100195C0) --------------------------------------------------------
int __cdecl sub_100195C0(char a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = -1;
  v2 = 0;
  while ( byte_1008C1D0[8 * v2] != a1 )
  {
    if ( (unsigned int)++v2 >= 8 )
      return result;
  }
  return dword_1008C1D4[2 * v2];
}
// 1008C1D4: using guessed type int dword_1008C1D4[];

//----- (100195F0) --------------------------------------------------------
__int16 __cdecl sub_100195F0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CF04: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019630) --------------------------------------------------------
__int16 __cdecl sub_10019630(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 10019620: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (100196B0) --------------------------------------------------------
unsigned int __cdecl sub_100196B0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10181618[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_101815D0[a1];
  dword_101815D0[a1] = a3 + v9;
  dword_10181590[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10181590[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 101815D0: using guessed type int dword_101815D0[];
// 10181618: using guessed type int dword_10181618[];

//----- (10019860) --------------------------------------------------------
int __usercall sub_10019860@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10181618[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10181618[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10181618: using guessed type int dword_10181618[];

//----- (10019910) --------------------------------------------------------
int __cdecl sub_10019910(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10019860(a1);
  v3 = &dword_10181618[a1];
  v4 = sub_100193A0(
         *(_DWORD *)dword_10181618[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10181618[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_101815D0[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 101815D0: using guessed type int dword_101815D0[];
// 10181618: using guessed type int dword_10181618[];

//----- (100199C0) --------------------------------------------------------
int __usercall sub_100199C0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10181618[a1];
  v3 = (int *)(dword_101815D0[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10181618[a1] + 32)) % *(_WORD *)(dword_10181618[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10019910(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 101815D0: using guessed type int dword_101815D0[];
// 10181618: using guessed type int dword_10181618[];

//----- (10019A50) --------------------------------------------------------
unsigned int __cdecl sub_10019A50(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10181610 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10181618[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10181610 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_100182A0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10181618[v6] + 28);
        v12 = sub_100199C0(v6, (unsigned int)v7 & *(_DWORD *)(dword_10181618[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10181618[v6] + 4) != 138 )
        sub_10018280(*(_DWORD *)(dword_10181618[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10181618[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10018280(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10181610: using guessed type int dword_10181610;
// 10181618: using guessed type int dword_10181618[];

//----- (10019BA0) --------------------------------------------------------
void __cdecl sub_10019BA0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1001FDA0(v2) && sub_1001FE00(v3) != 1 )
    *a2 = 0;
}

//----- (10019BD0) --------------------------------------------------------
int __cdecl sub_10019BD0(float a1, float a2, float a3)
{
  float *v3; // ecx@0
  int result; // eax@4

  if ( (COERCE_UNSIGNED_INT(*v3) & 0x7F800000) == 2139095040 || a1 < (double)*v3 || a2 > (double)*v3 )
  {
    result = 0;
    *v3 = a3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10019C20) --------------------------------------------------------
double __cdecl sub_10019C20(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_1001D4B0() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_102234FC + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_102234FC + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_102234FC + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (10019CB0) --------------------------------------------------------
signed int __cdecl sub_10019CB0(char a1)
{
  return (signed int)(sub_10019C20(a1) * 683565248.0);
}

//----- (10019CD0) --------------------------------------------------------
char __cdecl sub_10019CD0(_BYTE *a1)
{
  char result; // al@2

  if ( sub_1001D4B0() )
  {
    result = *(_BYTE *)(dword_102234F0 + 239);
    if ( a1 )
      *a1 = *(_BYTE *)(dword_102234FC + 930);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102234F0: using guessed type int dword_102234F0;
// 102234FC: using guessed type int dword_102234FC;

//----- (10019D10) --------------------------------------------------------
char __cdecl sub_10019D10(float *a1)
{
  float v1; // ST18_4@6
  char result; // al@6
  float v3; // ST18_4@6
  char v4; // [sp+1Bh] [bp-2Dh]@6
  float v5; // [sp+1Ch] [bp-2Ch]@6
  char v6; // [sp+20h] [bp-28h]@2
  char v7; // [sp+2Eh] [bp-1Ah]@2

  *a1 = 0.0;
  if ( !sub_1001D4B0()
    || (sub_1001ABC0((int)&v6), v7)
    || *(_BYTE *)(dword_102234FC + 661)
    && (!*(_BYTE *)(dword_102234FC + 64)
     || (unsigned int)(*(_DWORD *)(dword_102234FC + 36) - *(_DWORD *)(dword_102234FC + 740)) >= 0x124F80) )
  {
    result = 0;
  }
  else
  {
    sub_10037470();
    sub_1001A9D0(*(_BYTE *)(dword_102234FC + 1201), &v4, &v5);
    *a1 = *(float *)(dword_102234FC + 340);
    v1 = *(float *)(dword_102234FC + 336);
    sub_1003EF50(12756274.0, -12756274.0);
    sub_10019BD0(514.44446, -514.44446, 0.0);
    sub_10037450(*(_DWORD *)(dword_102234FC + 296));
    *a1 = 514.44446 * v1 + *a1;
    sub_10037460();
    sub_1003EF50(10.0, 0.043196544);
    result = 1;
    v3 = *a1 * 0.0005399567889980972;
    *a1 = v3 / v5;
  }
  return result;
}
// 10037450: using guessed type _DWORD __cdecl sub_10037450(_DWORD);
// 102234FC: using guessed type int dword_102234FC;

//----- (10019E80) --------------------------------------------------------
char sub_10019E80()
{
  char result; // al@2

  if ( sub_1001D4B0() )
    result = *(_BYTE *)(dword_102234FC + 661);
  else
    result = 0;
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (10019EA0) --------------------------------------------------------
bool __cdecl sub_10019EA0(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6)
{
  bool v6; // bl@1
  float *v7; // eax@4
  float v9; // [sp+18h] [bp-38h]@1
  _BYTE *v10; // [sp+1Ch] [bp-34h]@1
  _BYTE *v11; // [sp+20h] [bp-30h]@1
  _BYTE *v12; // [sp+24h] [bp-2Ch]@1
  char v13; // [sp+28h] [bp-28h]@1
  char v14; // [sp+36h] [bp-1Ah]@2

  *a1 = 0.0;
  *a2 = 9.9999996e24;
  v6 = 0;
  v12 = a4;
  *a3 = 0.0;
  *a4 = 0;
  v10 = a5;
  v11 = a6;
  sub_1001ABC0((int)&v13);
  sub_10019D10(&v9);
  if ( sub_1001D4B0() )
  {
    sub_10037470();
    if ( !v14 )
    {
      if ( sub_1003EF50(300.0, 1.0) )
      {
        sub_10037450(*(_DWORD *)(dword_102234FC + 296));
        *a1 = 300.0 * *(float *)(dword_102234FC + 1220) + *(float *)(dword_102234FC + 1216);
        v7 = (float *)(dword_102234FC + 1224);
        *a2 = *(float *)(dword_102234FC + 1224);
        *a3 = *a1 / *v7;
        v6 = *(_BYTE *)(dword_102234FC + 1211) == 0;
        if ( !*(_BYTE *)(dword_102234FC + 1211) )
        {
          LODWORD(v9) &= 0x7FFFFFFFu;
          if ( v9 <= 1.0 )
          {
            if ( *(_BYTE *)(dword_102234FC + 288) )
              *v12 = 1;
          }
        }
      }
    }
    if ( v10 )
      *v10 = *(_BYTE *)(dword_102234FC + 1212);
    if ( v11 )
      *v11 = *(_BYTE *)(dword_102234FC + 821);
    sub_10037460();
  }
  return v6;
}
// 10037450: using guessed type _DWORD __cdecl sub_10037450(_DWORD);
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A020) --------------------------------------------------------
char sub_1001A020()
{
  char result; // al@2

  if ( sub_1001D4B0() )
    result = *(_BYTE *)(dword_102234FC + 11);
  else
    result = 0;
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A0E0) --------------------------------------------------------
bool __cdecl sub_1001A0E0(void *a1)
{
  bool result; // al@2

  if ( sub_1001D4B0() )
  {
    sub_10037470();
    qmemcpy(a1, (const void *)(dword_102234FC + 1356), 0x94u);
    result = sub_10037460();
  }
  else
  {
    memset(a1, 0, 0x94u);
    result = (char)a1;
    *((float *)a1 + 11) = 9.9999996e24;
    *((float *)a1 + 12) = 9.9999996e24;
    *((_BYTE *)a1 + 1) = 0;
    *((float *)a1 + 14) = 9.9999996e24;
    *((_BYTE *)a1 + 25) = 0;
    *((float *)a1 + 15) = 9.9999996e24;
    *((_BYTE *)a1 + 7) = 1;
    *((float *)a1 + 18) = 9.9999996e24;
    *((_BYTE *)a1 + 10) = 0;
    *((float *)a1 + 17) = 9.9999996e24;
    *((_DWORD *)a1 + 9) = -1;
    *((float *)a1 + 20) = 9.9999996e24;
    *((_BYTE *)a1 + 19) = -1;
    *((float *)a1 + 24) = 9.9999996e24;
    *((_DWORD *)a1 + 10) = -1;
    *((float *)a1 + 26) = 9.9999996e24;
    *((_BYTE *)a1 + 20) = -1;
    *((float *)a1 + 27) = 9.9999996e24;
    *((_BYTE *)a1 + 8) = 0;
    *((float *)a1 + 31) = 9.9999996e24;
    *((_BYTE *)a1 + 9) = 0;
    *((float *)a1 + 32) = 9.9999996e24;
    *((_BYTE *)a1 + 13) = 0;
    *((float *)a1 + 33) = 9.9999996e24;
    *((_BYTE *)a1 + 15) = 0;
    *((float *)a1 + 34) = 9.9999996e24;
    *((_BYTE *)a1 + 14) = 0;
    *((float *)a1 + 16) = 9.9999996e24;
    *((_BYTE *)a1 + 16) = 0;
    *((float *)a1 + 35) = 9.9999996e24;
    *((_BYTE *)a1 + 17) = 0;
    *((float *)a1 + 36) = 9.9999996e24;
    *((_BYTE *)a1 + 24) = 0;
    *((float *)a1 + 19) = 9.9999996e24;
    *((float *)a1 + 21) = 9.9999996e24;
    *((float *)a1 + 22) = 9.9999996e24;
    *((float *)a1 + 23) = 9.9999996e24;
    *((float *)a1 + 25) = 9.9999996e24;
    *((float *)a1 + 28) = 9.9999996e24;
    *((float *)a1 + 29) = 0.0;
    *((float *)a1 + 30) = 9.9999996e24;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A130) --------------------------------------------------------
double __cdecl sub_1001A130(_BYTE *a1)
{
  _BYTE *v1; // esi@1
  bool v2; // al@1
  int v3; // edx@1
  double v4; // st7@5
  double v5; // st7@8
  float v6; // ST00_4@11
  double result; // st7@13
  double v8; // st7@14
  float v9; // [sp+4h] [bp-10h]@5
  float v10; // [sp+Ch] [bp-8h]@1
  float v11; // [sp+10h] [bp-4h]@5
  float v12; // [sp+18h] [bp+4h]@2
  float v13; // [sp+18h] [bp+4h]@4
  float v14; // [sp+18h] [bp+4h]@10
  float v15; // [sp+18h] [bp+4h]@14

  v1 = a1;
  *a1 = 0;
  v2 = sub_1001AEF0(*(_BYTE *)(dword_102234F0 + 244), &v10);
  v3 = dword_102234FC;
  if ( !v2 )
  {
    v12 = 0.30000001;
    goto LABEL_13;
  }
  if ( *(_BYTE *)(dword_102234FC + 929) )
  {
    v13 = *(float *)(dword_102234FC + 948) + v10;
    if ( *(float *)(dword_102234FC + 964) + 305.0 >= v13 )
    {
      v12 = 0.30000001;
      goto LABEL_13;
    }
    v12 = v13 * 0.0005399567889980972 * *(float *)(dword_102234FC + 976);
    v11 = 0.0005399567889980972 * *(float *)(dword_102234FC + 944);
    v9 = v11;
    v4 = 1.0;
  }
  else
  {
    if ( *(_BYTE *)(dword_102234F0 + 237) )
      v5 = 1.0;
    else
      v5 = 0.30000001;
    v11 = v5;
    v14 = v10 + 3048.0;
    v12 = v14 * 0.0005399567889980972 * 0.03492077067494392;
    v9 = 0.057602592;
    v4 = v11;
  }
  v6 = v4;
  if ( sub_1003EF50(v6, v9) )
  {
    *v1 = 1;
    v3 = dword_102234FC;
  }
LABEL_13:
  result = v12;
  if ( *(float *)(v3 + 84) < (double)v12 )
  {
    v8 = *(float *)(v3 + 84);
    *v1 = 0;
    v15 = v8;
    result = v15;
  }
  return result;
}
// 102234F0: using guessed type int dword_102234F0;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A270) --------------------------------------------------------
char __cdecl sub_1001A270(float *a1)
{
  int v1; // ST10_4@1
  double v2; // st7@1
  int v3; // ST14_4@1
  int v4; // ST1C_4@1
  int v5; // ST24_4@1
  double v6; // st7@6
  double v7; // st7@10
  double v8; // st7@15
  float v9; // ST04_4@26
  char v10; // dl@28
  char result; // al@31
  float v12; // [sp+0h] [bp-24h]@1
  float v13; // [sp+4h] [bp-20h]@1
  float v14; // [sp+14h] [bp-10h]@1
  float v15; // [sp+1Ch] [bp-8h]@1

  v12 = *(float *)(dword_102234FC + 304);
  v1 = *(_DWORD *)(dword_102234FC + 64);
  v13 = *(float *)(dword_102234FC + 320);
  v2 = v12;
  v14 = *(float *)(dword_102234FC + 72);
  v3 = *(_DWORD *)(dword_102234FC + 68);
  v15 = *(float *)(dword_102234FC + 80);
  v4 = *(_DWORD *)(dword_102234FC + 76);
  v5 = *(_DWORD *)(dword_102234FC + 84);
  if ( (LODWORD(v12) & 0x7F800000) == 2139095040 || v2 > 25512548.0 )
  {
    v12 = 25512548.0;
  }
  else if ( v2 < -25512548.0 )
  {
    v12 = -25512548.0;
  }
  v6 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v6 > 1028.8889 || v6 < -1028.8889 )
    v13 = 0.0;
  v7 = v15;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v7 > 2.0 )
  {
    v15 = 2.0;
  }
  else if ( v7 < -2.0 )
  {
    v15 = -2.0;
  }
  v8 = 1.0;
  if ( *(_BYTE *)(dword_102234FC + 929) )
  {
    if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 1.0 )
      goto LABEL_25;
    v8 = v14;
  }
  else
  {
    v8 = v14;
    if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v8 > 0.30000001 )
    {
      v8 = 0.30000001;
      goto LABEL_25;
    }
  }
  if ( v8 >= 0.05760259181261063 )
    goto LABEL_26;
  v8 = 0.057602592;
LABEL_25:
  v14 = v8;
LABEL_26:
  sub_10037450(*(_DWORD *)(dword_102234FC + 296));
  v9 = v8 * v13 + v12;
  *a1 = v14 - v15 * v9;
  if ( v9 > 3704.0 )
    *a1 = 1.0;
  v10 = 0;
  if ( v14 + 0.009999999776482582 >= *a1 || *(_BYTE *)(dword_102234FC + 812) > *(_BYTE *)(dword_102234F0 + 241) )
  {
    *a1 = v14;
    v10 = 1;
  }
  result = 1;
  if ( !*(_BYTE *)(dword_102234F0 + 237) )
    result = v10;
  return result;
}
// 10037450: using guessed type _DWORD __cdecl sub_10037450(_DWORD);
// 102234F0: using guessed type int dword_102234F0;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A4A0) --------------------------------------------------------
char __cdecl sub_1001A4A0(float *a1)
{
  float v1; // ST00_4@1
  double v2; // st7@1
  int v3; // ST04_4@1
  int v4; // ST0C_4@1
  int v5; // ST08_4@1
  int v6; // ST18_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st4@11
  float v10; // ST14_4@15
  float v11; // ST00_4@16
  float v12; // ST00_4@16
  char result; // al@17
  float v14; // [sp+10h] [bp-Ch]@1
  float v15; // [sp+10h] [bp-Ch]@8
  float v16; // [sp+14h] [bp-8h]@1

  v1 = *(float *)(dword_102234FC + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102234FC + 64);
  v4 = *(_DWORD *)(dword_102234FC + 72);
  v5 = *(_DWORD *)(dword_102234FC + 68);
  v16 = *(float *)(dword_102234FC + 80);
  v14 = *(float *)(dword_102234FC + 76);
  v6 = *(_DWORD *)(dword_102234FC + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 2.0 )
  {
    v8 = 2.0;
    v15 = 2.0;
    goto LABEL_10;
  }
  v7 = v14;
  v8 = 2.0;
  if ( v14 < 0.05760259181261063 )
  {
    v15 = 0.057602592;
LABEL_10:
    v7 = v15;
  }
  v9 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v9 > v8 )
  {
    v10 = v8;
    v9 = v10;
  }
  else if ( v9 < -2.0 )
  {
    v9 = (float)-2.0;
  }
  v11 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_102234FC + 36) - *(_DWORD *)(dword_102234FC + 68))
       / (double)1000);
  v12 = v7 + v11;
  *a1 = v12;
  if ( v12 < 1.990000009536743 )
  {
    result = 0;
  }
  else
  {
    *a1 = v8;
    result = 1;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A610) --------------------------------------------------------
double __cdecl sub_1001A610(float a1)
{
  double v1; // st7@1
  double result; // st7@4
  float v3; // [sp+4h] [bp-4h]@1

  v1 = a1;
  v3 = *(float *)(dword_102234FC + 48);
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v1 > 10.0 )
  {
    result = (float)10.0;
  }
  else if ( v3 <= v1 )
  {
    result = a1;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A680) --------------------------------------------------------
char __cdecl sub_1001A680(float *a1)
{
  float v1; // ST08_4@1
  double v2; // st7@1
  int v3; // ST10_4@1
  int v4; // ST18_4@1
  int v5; // ST14_4@1
  int v6; // ST24_4@1
  double v7; // st6@5
  double v8; // st5@5
  float v9; // ST1C_4@8
  double v10; // st5@9
  double v11; // st4@9
  float v12; // ST20_4@12
  float v13; // ST0C_4@13
  double v14; // st7@13
  char result; // al@17
  float v16; // [sp+0h] [bp-20h]@13
  float v17; // [sp+4h] [bp-1Ch]@5
  float v18; // [sp+14h] [bp-Ch]@1
  float v19; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_102234FC + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102234FC + 64);
  v4 = *(_DWORD *)(dword_102234FC + 72);
  v5 = *(_DWORD *)(dword_102234FC + 68);
  v19 = *(float *)(dword_102234FC + 80);
  v18 = *(float *)(dword_102234FC + 76);
  v6 = *(_DWORD *)(dword_102234FC + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  v17 = *(float *)(dword_102234FC + 48);
  v7 = v18;
  v8 = 10.0;
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 || v7 > 10.0 || (v8 = v17, v17 > v7) )
  {
    v9 = v8;
    v7 = v9;
  }
  v10 = v19;
  v11 = 2.0;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v10 > 2.0 || (v11 = -2.0, v10 < -2.0) )
  {
    v12 = v11;
    v10 = v12;
  }
  v16 = v2
      * v10
      * ((double)(unsigned int)(*(_DWORD *)(dword_102234FC + 36) - *(_DWORD *)(dword_102234FC + 68))
       / (double)1000);
  v13 = v7 + v16;
  v14 = v13;
  *a1 = v13;
  if ( (LODWORD(v16) >> 31) & 1 && *(float *)(dword_102234FC + 72) >= v14 )
  {
    result = 1;
    *a1 = *(float *)(dword_102234FC + 72);
  }
  else if ( (LODWORD(v16) >> 31) & 1 || *(float *)(dword_102234FC + 72) > v14 )
  {
    result = 0;
  }
  else
  {
    *a1 = *(float *)(dword_102234FC + 72);
    result = 1;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A820) --------------------------------------------------------
char __cdecl sub_1001A820(float *a1)
{
  float v1; // ST04_4@1
  double v2; // st7@1
  int v3; // ST0C_4@1
  int v4; // ST14_4@1
  int v5; // ST10_4@1
  int v6; // ST20_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st6@13
  float v10; // ST1C_4@15
  float v11; // ST08_4@16
  double v12; // st7@16
  char result; // al@20
  float v14; // [sp+0h] [bp-20h]@16
  float v15; // [sp+14h] [bp-Ch]@1
  float v16; // [sp+14h] [bp-Ch]@8
  float v17; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_102234FC + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102234FC + 64);
  v4 = *(_DWORD *)(dword_102234FC + 72);
  v5 = *(_DWORD *)(dword_102234FC + 68);
  v17 = *(float *)(dword_102234FC + 80);
  v15 = *(float *)(dword_102234FC + 76);
  v6 = *(_DWORD *)(dword_102234FC + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 2.0 )
  {
    v8 = 2.0;
    v16 = 2.0;
    goto LABEL_10;
  }
  v7 = v15;
  v8 = 2.0;
  if ( v15 < 0.05760259181261063 )
  {
    v16 = 0.057602592;
LABEL_10:
    v7 = v16;
  }
  if ( (LODWORD(v17) & 0x7F800000) != 2139095040 && v17 <= v8 )
  {
    v9 = v17;
    if ( v17 >= -2.0 )
      goto LABEL_16;
    v8 = -2.0;
  }
  v10 = v8;
  v9 = v10;
LABEL_16:
  v14 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_102234FC + 36) - *(_DWORD *)(dword_102234FC + 68))
       / (double)1000);
  v11 = v7 + v14;
  v12 = v11;
  *a1 = v11;
  if ( (LODWORD(v14) >> 31) & 1 && v12 <= 1.01 )
  {
    result = 1;
    *a1 = 1.0;
  }
  else if ( (LODWORD(v14) >> 31) & 1 || v12 < 0.9900000095367432 )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = 1.0;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001A9D0) --------------------------------------------------------
unsigned int __cdecl sub_1001A9D0(char a1, _BYTE *a2, float *a3)
{
  _BYTE *v3; // esi@1
  float *v4; // edi@1
  int v5; // edx@1
  int v6; // ST14_4@1
  int v7; // ST18_4@1
  int v8; // ST1C_4@1
  int v9; // ST20_4@1
  double v10; // st7@3
  char v11; // bl@6
  unsigned int result; // eax@33
  float v13; // [sp+24h] [bp-4h]@1

  v3 = a2;
  *a2 = 1;
  v4 = a3;
  *a3 = 2.0;
  v5 = *(_DWORD *)(dword_102234FC + 64);
  v6 = *(_DWORD *)(dword_102234FC + 68);
  v7 = *(_DWORD *)(dword_102234FC + 72);
  v8 = *(_DWORD *)(dword_102234FC + 76);
  v9 = *(_DWORD *)(dword_102234FC + 80);
  v13 = *(float *)(dword_102234FC + 84);
  *(float *)&a2 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v13 > 4.0 )
  {
    v13 = 4.0;
    v10 = 4.0;
  }
  else
  {
    v10 = 4.0;
    if ( v13 < 0.30000001 )
      v13 = 0.30000001;
  }
  v11 = a1;
  if ( !a1 && *(_BYTE *)(dword_102234FC + 99) == a1 )
    v11 = 1;
  if ( BYTE3(v5) == 6 )
  {
    if ( (unsigned __int8)v11 < *(_BYTE *)(dword_102234FC + 94) && *(_BYTE *)(dword_102234FC + 816) )
      v11 = *(_BYTE *)(dword_102234FC + 94);
    if ( -1.0 != *(float *)(dword_102234FC + 116) )
      v11 = 5;
    switch ( v11 )
    {
      case 4:
        *v4 = sub_1001A130(&a1);
        *v3 = 4;
        break;
      case 3:
        *v4 = 0.30000001;
        *v3 = 3;
        break;
      case 2:
        *v4 = 1.0;
        *v3 = 2;
        break;
      case 0:
        *v4 = v10;
        *v3 = 0;
        break;
      case 5:
        *v4 = sub_1001A610(*(float *)(dword_102234FC + 116));
        *v3 = 5;
        break;
      default:
        break;
    }
LABEL_30:
    if ( v11 == 5 )
      goto LABEL_33;
    goto LABEL_31;
  }
  if ( BYTE3(v5) == 2 )
  {
    sub_1001A820(v4);
    *v3 = 2;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 4 )
  {
    sub_1001A270(v4);
    *v3 = 4;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 5 )
  {
    sub_1001A680(v4);
    *v3 = 5;
    goto LABEL_30;
  }
  sub_1001A4A0(v4);
  if ( v11 )
  {
    *v3 = 1;
    goto LABEL_30;
  }
  *v3 = 0;
LABEL_31:
  if ( v13 + 0.009999999776482582 < *v4 )
  {
    *v4 = v13;
    *v3 = *(_BYTE *)(dword_102234FC + 1201);
  }
LABEL_33:
  result = *v3;
  if ( result >= 6 )
    result = 1;
  *v3 = result;
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (1001ABC0) --------------------------------------------------------
char __cdecl sub_1001ABC0(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_1001D4B0();
  if ( result )
  {
    sub_10037470();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_102234FC + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_102234FC + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_102234FC + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_102234F0 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_102234FC + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_102234FC + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_102234FC + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_102234FC;
    if ( *(_BYTE *)(dword_102234FC + 669) && !*(_BYTE *)(dword_102234FC + 667)
      || (v3 = *(_BYTE *)(dword_102234FC + 159)) != 0
      && *(_BYTE *)(dword_102234FC + 667)
      && !*(_BYTE *)(dword_102234FC + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_102234FC + 116))
      || !*(_BYTE *)(dword_102234FC + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_102234FC;
    }
    else if ( *(_BYTE *)(dword_102234FC + 101) == 4
           && *(_BYTE *)(dword_102234FC + 812) >= *(_BYTE *)(dword_102234F0 + 241)
           && !*(_BYTE *)(dword_102234FC + 89)
           && -1.0 == *(float *)(dword_102234FC + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_102234FC;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_102234F0 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_102234F0 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10037460();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_102234FC + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_102234FC + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_102234FC + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_102234FC + 825);
      if ( *(_DWORD *)(dword_102234FC + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_102234FC + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_102234FC + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_102234FC + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_102234F0 + 4);
      result = sub_10037460();
    }
  }
  return result;
}
// 102234F0: using guessed type int dword_102234F0;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001AE10) --------------------------------------------------------
void __cdecl sub_1001AE10(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_1004CC30(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_1004CBD0(v10) * v12;
}

//----- (1001AED0) --------------------------------------------------------
double __cdecl sub_1001AED0(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (1001AEF0) --------------------------------------------------------
bool __cdecl sub_1001AEF0(unsigned __int8 a1, float *a2)
{
  unsigned __int16 v2; // di@1
  double v3; // st7@5
  int v4; // ecx@5
  __int16 i; // ax@5
  int v6; // eax@6
  bool v7; // cf@7
  bool result; // al@10

  *a2 = 0.0;
  v2 = 0;
  if ( *(_BYTE *)(dword_102234FC + 812) == -1
    || *(_WORD *)(dword_102234FC + 828) == -1
    || 9.9999996e24 == *(float *)(dword_102234FC + 552)
    || 9.9999996e24 == *(float *)(dword_102234FC + 568) )
  {
    result = 0;
  }
  else
  {
    v3 = *(float *)(dword_102234FC + 552);
    *a2 = *(float *)(dword_102234FC + 552);
    sub_10037450(*(_DWORD *)(dword_102234FC + 544));
    *a2 = v3 * *(float *)(dword_102234FC + 568) + *a2;
    v4 = dword_102234F4;
    for ( i = *(_WORD *)(44 * *(_WORD *)(dword_102234FC + 828) + dword_102234F4 + 332);
          i != -1;
          i = *(_WORD *)(v6 + dword_102234F4 + 332) )
    {
      v6 = 44 * i;
      if ( *(_BYTE *)(v6 + v4 + 324) > a1 )
        break;
      v7 = v2 < 0x1F4u;
      if ( v2 >= 0x1F4u )
        goto LABEL_10;
      ++v2;
      *a2 = *(float *)(v6 + v4 + 336) + *a2;
      v4 = dword_102234F4;
    }
    v7 = v2 < 0x1F4u;
LABEL_10:
    result = v7;
  }
  return result;
}
// 10037450: using guessed type _DWORD __cdecl sub_10037450(_DWORD);
// 102234F4: using guessed type int dword_102234F4;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001AFF0) --------------------------------------------------------
char *__cdecl sub_1001AFF0(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_10222C80[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_10222C88];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_10222C84];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_10222C88];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_10222C4C)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 10222C80: using guessed type int dword_10222C80[];
// 10222C84: using guessed type __int16 word_10222C84[];
// 10222C88: using guessed type int dword_10222C88[];
// 1001AFF0: using guessed type char var_20[28];

//----- (1001B0B0) --------------------------------------------------------
signed int sub_1001B0B0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_10222C50 = 0;
  dword_10222C54 = 0xFFFFFF;
  byte_10222C40 = 0;
  dword_10222C44 = 0xFFFFFF;
  return result;
}
// 10222C40: using guessed type char byte_10222C40;
// 10222C44: using guessed type int dword_10222C44;
// 10222C50: using guessed type char byte_10222C50;
// 10222C54: using guessed type int dword_10222C54;

//----- (1001B0D0) --------------------------------------------------------
int sub_1001B0D0()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_10222C4C + 16))();
  byte_10222C48 = (_BYTE)result == 0;
  return result;
}
// 10222C48: using guessed type char byte_10222C48;
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1001B130) --------------------------------------------------------
int sub_1001B130()
{
  int result; // eax@1

  *(_DWORD *)(dword_102234D0 + 20812) = 1000;
  *(_DWORD *)(dword_102234D0 + 20816) = dword_10222CE8 + *(_DWORD *)(dword_102234D0 + 20812);
  *(_DWORD *)(dword_102234D0 + 20820) = dword_10222D48 + *(_DWORD *)(dword_102234D0 + 20816);
  *(_DWORD *)(dword_102234D0 + 20824) = dword_10222D78 + *(_DWORD *)(dword_102234D0 + 20820);
  result = dword_102234D0;
  *(_DWORD *)(dword_102234D0 + 20828) = dword_10222DC0 + *(_DWORD *)(dword_102234D0 + 20824);
  return result;
}
// 10222CE8: using guessed type int dword_10222CE8;
// 10222D48: using guessed type int dword_10222D48;
// 10222D78: using guessed type int dword_10222D78;
// 10222DC0: using guessed type int dword_10222DC0;
// 102234D0: using guessed type int dword_102234D0;

//----- (1001B1A0) --------------------------------------------------------
char *sub_1001B1A0()
{
  sub_1001AFF0(0x40u);
  sub_1001AFF0(0x39u);
  sub_1001AFF0(0x33u);
  sub_1001AFF0(0x31u);
  sub_1001AFF0(0x32u);
  sub_1001AFF0(0x4Eu);
  sub_1001AFF0(0x4Fu);
  sub_1001AFF0(0x3Du);
  sub_1001AFF0(0x3Eu);
  sub_1001AFF0(0x45u);
  return sub_1001AFF0(0x38u);
}
// 102234D0: using guessed type int dword_102234D0;

//----- (1001B270) --------------------------------------------------------
int __cdecl sub_1001B270(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_10181658, a1, 0x1Cu);
  dword_10222C4C = (int)dword_10181658;
  dword_102234D0 = (int)&unk_10181678;
  memset(&unk_10181678, 0, 0x516Cu);
  dword_10181658[5](dword_102234D0 + 20832, dword_102234D0 + 20833, dword_102234D0 + 20836);
  (*(void (__cdecl **)(int))(dword_10222C4C + 24))(dword_102234D0 + 20840);
  sub_100378D0();
  sub_10037560();
  sub_10037710();
  sub_10037630();
  sub_1001B1A0();
  sub_1001B0B0();
  sub_1001BBB0();
  sub_1001B800();
  sub_1001B0D0();
  sub_1001B130();
  *(_DWORD *)(dword_102234D0 + 20800) = 0;
  *(_DWORD *)(dword_102234D0 + 20804) = dword_10222E68;
  result = dword_102234D0;
  *(_DWORD *)(dword_102234D0 + 20808) = dword_10222E74 + *(_DWORD *)(dword_102234D0 + 20804);
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 10222E68: using guessed type int dword_10222E68;
// 10222E74: using guessed type int dword_10222E74;
// 102234D0: using guessed type int dword_102234D0;

//----- (1001B320) --------------------------------------------------------
void sub_1001B320()
{
  dword_10222C38 = -15;
}
// 10222C38: using guessed type int dword_10222C38;

//----- (1001B330) --------------------------------------------------------
char __cdecl sub_1001B330(char a1)
{
  char result; // al@1

  result = a1;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1001E570(word_10090004[(unsigned __int8)a1]);
  return result;
}
// 10090004: using guessed type __int16 word_10090004[];

//----- (1001B350) --------------------------------------------------------
void __usercall sub_1001B350(unsigned __int8 a1@<bl>, char a2, char a3, char a4)
{
  int v4; // esi@3
  int v5; // esi@6

  if ( a1 < 2u )
  {
    if ( !sub_1001C820(a1) || (v4 = 5 * a1, sub_1001E3D0(word_10090158[5 * a1])) )
    {
      v5 = 5 * a1;
      sub_1001E460(word_10090156[5 * a1]);
      if ( a2 )
      {
        if ( a3 )
          sub_1001E570(word_10090154[v5]);
        else
          sub_1001E460(word_10090154[v5]);
        if ( a4 )
          sub_1001E570(word_1009015C[v5]);
        else
          sub_1001E460(word_1009015C[v5]);
      }
      else
      {
        sub_1001E460(word_10090154[v5]);
        sub_1001E460(word_1009015C[v5]);
      }
    }
    else if ( !sub_1001E3D0(word_1009015A[v4]) )
    {
      sub_1001E460(word_10090154[v4]);
      sub_1001E460(word_1009015C[v4]);
      sub_1001E570(word_10090156[v4]);
    }
  }
}
// 10090154: using guessed type __int16 word_10090154[];
// 10090156: using guessed type __int16 word_10090156[];
// 10090158: using guessed type __int16 word_10090158[];
// 1009015A: using guessed type __int16 word_1009015A[];
// 1009015C: using guessed type __int16 word_1009015C[];

//----- (1001B460) --------------------------------------------------------
void __cdecl sub_1001B460(unsigned __int8 a1)
{
  char v1; // al@3
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1
  unsigned int v5; // [sp+10h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v2 = 0;
  if ( !a1 )
  {
    v1 = sub_1000F100(0, 419, &v3);
    goto LABEL_5;
  }
  if ( a1 == 1 )
  {
    v1 = sub_1000F100(0, 422, &v3);
LABEL_5:
    v2 = v1;
  }
  sub_1001B350(a1, v2, (v5 & 0xFFF) != 0, (v5 >> 30) & 1);
}

//----- (1001B4E0) --------------------------------------------------------
bool __cdecl sub_1001B4E0(unsigned __int8 a1, int a2)
{
  bool v2; // bl@1
  int v3; // eax@2
  float v4; // ST24_4@5
  float v5; // ST24_4@6
  unsigned int v6; // ebp@7

  v2 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 60000);
    v3 = sub_1001E7B0((_DWORD *)(dword_102234E8 + 1220), 1u, (int)&unk_10090690, 8, 7, -1);
    if ( v3 >= 0 )
    {
      if ( *(_BYTE *)(dword_102234E8 + 1454) == 1 )
      {
        if ( *(_BYTE *)a2 != byte_10090692[8 * v3]
          || (v4 = *(float *)(dword_102234E8 + 1224) - *(float *)(a2 + 4), COERCE_FLOAT(LODWORD(v4) & 0x7FFFFFFF) > 0.5)
          || (v5 = *(float *)(dword_102234E8 + 1228) - *(float *)(a2 + 8), COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) > 0.5) )
        {
          v2 = 0;
          v6 = 1000;
        }
        else
        {
          v2 = 1;
          v6 = 1000;
        }
      }
      else
      {
        v6 = 1500;
        v2 = *(_WORD *)a2 == (unsigned __int8)byte_10090691[8 * v3];
      }
      if ( a1 < 2u && *(_BYTE *)(a1 + dword_102234E8) )
      {
        if ( !v2 && sub_100181D0() - *(_DWORD *)(dword_102234E8 + 4 * a1 + 4) >= v6 )
        {
          sub_10018280(101);
          return 0;
        }
        v2 = 1;
      }
    }
    sub_10018280(101);
  }
  return v2;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001B600) --------------------------------------------------------
char __cdecl sub_1001B600(__int16 a1)
{
  void *v1; // ecx@0
  size_t v2; // esi@1
  int v3; // eax@4
  __int16 *v5; // [sp+4h] [bp-BCh]@4
  size_t v6; // [sp+8h] [bp-B8h]@4
  int v7; // [sp+Ch] [bp-B4h]@4
  int v8; // [sp+10h] [bp-B0h]@4
  int v9; // [sp+14h] [bp-ACh]@4
  __int16 v10; // [sp+18h] [bp-A8h]@1
  __int16 v11; // [sp+1Ch] [bp-A4h]@1
  char v12; // [sp+20h] [bp-A0h]@3

  v10 = a1;
  v11 = a1;
  v2 = 0;
  switch ( a1 )
  {
    case 0x8001:
      v2 = 156;
      goto LABEL_3;
    case 0x8002:
      v2 = 32;
      goto LABEL_3;
    case 0x8003:
      v2 = 56;
      goto LABEL_3;
    case 0x8004:
      v2 = 1;
      goto LABEL_3;
    case 0x8006:
      v2 = 16;
      goto LABEL_3;
    case 0x8009:
      v2 = 40;
      goto LABEL_3;
    case 0x800A:
      v2 = 60;
      goto LABEL_3;
    case 0x800B:
      v2 = 2;
LABEL_3:
      memcpy_0(&v12, v1, v2);
      break;
    default:
      sub_10018A40("..\\lib\\adl\\pvt_io_prj.c", 2075, 0, 0);
      break;
  }
  v9 = 1;
  v5 = &v10;
  v6 = v2 + 8;
  v7 = 0;
  v8 = 200;
  v3 = sub_10018330(44, (int)&v5);
  if ( v3 )
    LOBYTE(v3) = sub_10018A40("..\\lib\\adl\\pvt_io_prj.c", 2102, 0, 0);
  return v3;
}

//----- (1001B760) --------------------------------------------------------
char __cdecl sub_1001B760()
{
  return sub_1001B600(-32759);
}

//----- (1001B770) --------------------------------------------------------
char __cdecl sub_1001B770()
{
  return sub_1001B600(-32758);
}

//----- (1001B780) --------------------------------------------------------
char __cdecl sub_1001B780(const void *a1)
{
  char v2; // [sp+Ch] [bp-38h]@1

  qmemcpy(&v2, a1, 0x34u);
  return sub_1001B600(-32765);
}

//----- (1001B7D0) --------------------------------------------------------
char __cdecl sub_1001B7D0()
{
  return sub_1001B600(-32757);
}

//----- (1001B7E0) --------------------------------------------------------
char sub_1001B7E0()
{
  return sub_1001B600(-32764);
}

//----- (1001B800) --------------------------------------------------------
int sub_1001B800()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10037A00(0x4Du, 1u) )
  {
    result = dword_1022301C;
    dword_10186878 = dword_1022301C;
    if ( dword_1022301C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_10222C4C)(dword_1022301C, 8, &v1);
      word_10186870 = v1;
      result = v3 & 0x1FF;
      dword_10186878 += (unsigned __int16)word_10223020;
      word_10186874 = v2 & 0x1FF;
      word_1018686C = v3 & 0x1FF;
    }
  }
  else
  {
    word_10186870 = 6;
    word_10186874 = 6;
    result = dword_10222E9C;
    word_1018686C = 60;
    dword_10186878 = dword_10222E9C;
  }
  return result;
}
// 1018686C: using guessed type __int16 word_1018686C;
// 10186870: using guessed type __int16 word_10186870;
// 10186874: using guessed type __int16 word_10186874;
// 10186878: using guessed type int dword_10186878;
// 10222C4C: using guessed type int dword_10222C4C;
// 10222E9C: using guessed type int dword_10222E9C;
// 1022301C: using guessed type int dword_1022301C;
// 10223020: using guessed type __int16 word_10223020;

//----- (1001B8A0) --------------------------------------------------------
int __cdecl sub_1001B8A0(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10037A40(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (1001B8D0) --------------------------------------------------------
int sub_1001B8D0()
{
  return (*(int (**)(void))(dword_10222C4C + 8))();
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1001B8E0) --------------------------------------------------------
int __fastcall sub_1001B8E0(unsigned __int8 a1)
{
  return dword_10222E84 + a1 * (unsigned __int16)word_10222E88;
}
// 10222E84: using guessed type int dword_10222E84;
// 10222E88: using guessed type __int16 word_10222E88;

//----- (1001B900) --------------------------------------------------------
int __fastcall sub_1001B900(unsigned __int8 a1)
{
  return dword_10222E90 + a1 * (unsigned __int16)word_10222E94;
}
// 10222E90: using guessed type int dword_10222E90;
// 10222E94: using guessed type __int16 word_10222E94;

//----- (1001B920) --------------------------------------------------------
void *__cdecl sub_1001B920(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_1001B8A0(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_1001B8E0(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_10222C4C)(v3, 22, &v7);
      result = (void *)sub_10037690(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1001B9F0) --------------------------------------------------------
int __cdecl sub_1001B9F0(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_1001B8E0(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10222C4C)(v2, 22, &v22);
    sub_10037690((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_1001B900(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_10222C4C)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10037690((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_10222C4C + 12))(a1);
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1001BBB0) --------------------------------------------------------
char sub_1001BBB0()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_1001B8D0();
  sub_1001B8A0(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_1001B920(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10037A40(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_1001B920(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_1001B9F0((int)&v8);
  }
  return v0;
}

//----- (1001BD10) --------------------------------------------------------
BOOL __cdecl sub_1001BD10(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_100181D0();
  for ( i = sub_100195F0(6, 0, 1, (int)&v4); i == 12; i = sub_100195F0(6, 0, 1, (int)&v4) )
  {
    if ( sub_100181D0() - v1 >= a1 )
      break;
    sub_10018380(100);
  }
  return i == 12;
}

//----- (1001BD80) --------------------------------------------------------
char __thiscall sub_1001BD80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019570(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001BDA0) --------------------------------------------------------
void __cdecl sub_1001BDA0(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10019570(120, a1);
  sub_10019570(124, a2);
  sub_10019570(121, a3);
}

//----- (1001BDD0) --------------------------------------------------------
int __cdecl sub_1001BDD0(int a1)
{
  return sub_10018540(3025, a1, 84);
}

//----- (1001BDF0) --------------------------------------------------------
signed int sub_1001BDF0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_10019630(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (1001BE20) --------------------------------------------------------
void __cdecl sub_1001BE20(_BYTE *a1)
{
  sub_10019570(129, a1);
}

//----- (1001BE40) --------------------------------------------------------
char __cdecl sub_1001BE40(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_100195F0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001BE80) --------------------------------------------------------
int __cdecl sub_1001BE80(int a1)
{
  return sub_10018670(3025, a1, 84);
}

//----- (1001BEA0) --------------------------------------------------------
char __fastcall sub_1001BEA0(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_102234D4 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_1001BE40(147, 0xCu, &v38);
  sub_1001BE40(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_10018600(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_100206A0(a1);
  if ( !result || result == 3 )
    result = sub_1001FE20(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10018670(2000, (int)&v20, 29);
  }
  return result;
}
// 102234D4: using guessed type char byte_102234D4;

//----- (1001C0C0) --------------------------------------------------------
char sub_1001C0C0()
{
  int *v0; // ecx@1

  sub_1001BD10(0x9C40u);
  sub_1001B270(&off_10092138);
  return sub_1001BEA0(v0);
}
// 10092138: using guessed type int (__cdecl *off_10092138)(int, size_t, void *);

//----- (1001C0E0) --------------------------------------------------------
char __fastcall sub_1001C0E0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_10018540(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_10018670(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (1001C130) --------------------------------------------------------
BOOL __cdecl sub_1001C130(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  int v4; // esi@3
  int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v10; // esi@4
  int v11; // esi@4
  int v12; // esi@4
  int v13; // esi@4
  int v14; // esi@4
  int v15; // esi@4
  int v16; // esi@4

  v1 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v2 = (unsigned __int8)sub_1001DFD0(11);
      v3 = (unsigned __int8)sub_1001DFD0(12) + v2;
      v4 = (unsigned __int8)sub_1001DFD0(13) + v3;
      v5 = (unsigned __int8)sub_1001DFD0(28) + v4;
      v6 = (unsigned __int8)sub_1001DFD0(29) + v5;
      v7 = (unsigned __int8)sub_1001DFD0(34) + v6;
      v8 = (unsigned __int8)sub_1001EE10(0x1EDu) + v7;
      return (unsigned __int8)sub_1001E000(19) + v8 == 1;
    }
  }
  else
  {
    v10 = (unsigned __int8)sub_1001DFD0(5);
    v11 = (unsigned __int8)sub_1001DFD0(6) + v10;
    v12 = (unsigned __int8)sub_1001DFD0(7) + v11;
    v13 = (unsigned __int8)sub_1001DFD0(26) + v12;
    v14 = (unsigned __int8)sub_1001DFD0(27) + v13;
    v15 = (unsigned __int8)sub_1001DFD0(33) + v14;
    v16 = (unsigned __int8)sub_1001EE10(0x1ECu) + v15;
    v1 = (unsigned __int8)sub_1001E000(17) + v16;
  }
  return v1 == 1;
}

//----- (1001C230) --------------------------------------------------------
char __cdecl sub_1001C230(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = a1 / 0x3E8;
  v2 = a1 % 0x3E8;
  v7 = a1 % 0x3E8 / 0x64;
  v3 = -100 * v7 + v2;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (1001C2A0) --------------------------------------------------------
char __cdecl sub_1001C2A0(char a1)
{
  char v1; // al@4

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    if ( sub_1001DFD0(28) )
      return 1;
    v1 = sub_1001DFD0(29);
  }
  else
  {
    if ( sub_1001DFD0(26) )
      return 1;
    v1 = sub_1001DFD0(27);
  }
  if ( v1 )
    return 1;
  return 0;
}

//----- (1001C2F0) --------------------------------------------------------
char __cdecl sub_1001C2F0(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_1001DFD0(33) || sub_1001E000(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_1001DFD0(34) && !sub_1001E000(19) )
    return 0;
  return 1;
}

//----- (1001C340) --------------------------------------------------------
char __cdecl sub_1001C340(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001DFD0(11);
  }
  else
  {
    result = sub_1001DFD0(5);
  }
  return result;
}

//----- (1001C370) --------------------------------------------------------
BOOL __cdecl sub_1001C370(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  char v4; // al@3
  int v5; // esi@4
  char v7; // [sp-10h] [bp-14h]@3

  v1 = 0;
  if ( !a1 )
  {
    v5 = (unsigned __int8)sub_1001DFD0(6);
    v3 = (unsigned __int8)sub_1001DFD0(7) + v5;
    v4 = sub_1001DFD0(26);
    v7 = 27;
    goto LABEL_5;
  }
  if ( a1 == 1 )
  {
    v2 = (unsigned __int8)sub_1001DFD0(12);
    v3 = (unsigned __int8)sub_1001DFD0(13) + v2;
    v4 = sub_1001DFD0(28);
    v7 = 29;
LABEL_5:
    v1 = (unsigned __int8)sub_1001DFD0(v7) + (unsigned __int8)v4 + v3;
  }
  return v1 == 1;
}

//----- (1001C3E0) --------------------------------------------------------
char __cdecl sub_1001C3E0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001EE10(0x1EDu);
  }
  else
  {
    result = sub_1001EE10(0x1ECu);
  }
  return result;
}

//----- (1001C410) --------------------------------------------------------
void sub_1001C410()
{
  dword_10223504 = -15;
}
// 10223504: using guessed type int dword_10223504;

//----- (1001C420) --------------------------------------------------------
char __cdecl sub_1001C420(char a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  int v7; // [sp+0h] [bp-20h]@1
  int v8; // [sp+4h] [bp-1Ch]@1
  int v9; // [sp+8h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-14h]@1
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  LOBYTE(v8) = a1;
  v2 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 8);
  v10 = v2;
  v4 = *(_DWORD *)(a2 + 12);
  v5 = *(_DWORD *)(a2 + 16);
  v11 = v3;
  LOWORD(v7) = -32759;
  v12 = v4;
  v13 = v5;
  return sub_10021130((int)&v7);
}

//----- (1001C4A0) --------------------------------------------------------
char __usercall sub_1001C4A0@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_10092FE8[2 * v2]) != byte_10092FE8[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_10092FE9[2 * v2];
  return 1;
}

//----- (1001C4D0) --------------------------------------------------------
char __usercall sub_1001C4D0@<al>(bool *a1@<esi>)
{
  bool v1; // bl@1
  char result; // al@2

  v1 = *a1 == 0;
  if ( (unsigned __int8)sub_1001C130(v1) )
  {
    *a1 = v1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001C500) --------------------------------------------------------
char __cdecl sub_1001C500(char a1)
{
  int v1; // ecx@0
  int v2; // edx@1
  __int64 v3; // rax@1
  int v5; // [sp+0h] [bp-1Ch]@1
  int v6; // [sp+4h] [bp-18h]@1
  __int64 v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  __int16 v9; // [sp+14h] [bp-8h]@1

  v2 = *(_DWORD *)v1;
  v6 = 0;
  v7 = 0i64;
  v8 = 0;
  v5 = 0;
  v9 = 0;
  LOBYTE(v6) = a1;
  LODWORD(v3) = *(_DWORD *)(v1 + 4);
  *(int *)((char *)&v6 + 2) = v2;
  HIDWORD(v3) = *(_DWORD *)(v1 + 8);
  *(__int64 *)((char *)&v7 + 2) = v3;
  LODWORD(v3) = *(_DWORD *)(v1 + 12);
  LOWORD(v5) = -32758;
  *(int *)((char *)&v8 + 2) = v3;
  return sub_10021130((int)&v5);
}

//----- (1001C570) --------------------------------------------------------
char __cdecl sub_1001C570(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_1001C3E0(a2) )
  {
    if ( !sub_1001C2F0(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_1000F100(1, 1221, a1);
      else
        v11 = sub_1000F100(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_10021D70(a2, 1, &v17)
      && sub_10025EE0(v18, &v15)
      && sub_10025EE0(HIWORD(v18), &v16)
      && sub_1001C4A0(v17, (_BYTE *)a1 + 3)
      && sub_10021D70(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_1001E7B0(&a2, 1u, (int)&unk_10092FD8, 4, 2, 0);
  if ( !sub_1001EE80((unsigned __int16)word_10092FDA[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_100396E0(&v19) || (v3 = sub_10025EE0(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_10039730();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_10039290((unsigned __int8 *)a1)
    || !sub_1001C230(*((_DWORD *)a1 + 2))
    || !sub_1001C230(*((_DWORD *)a1 + 3))
    || sub_1001C340(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_10018540(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_10018670(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 10092FDA: using guessed type __int16 word_10092FDA[];

//----- (1001C820) --------------------------------------------------------
bool __cdecl sub_1001C820(int a1)
{
  char v1; // al@1
  bool v2; // bl@1
  int v3; // ecx@3
  bool result; // al@5
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Bh] [bp-Dh]@2

  v1 = sub_1001C570(&v5, a1);
  v2 = v1 == 0;
  if ( v1 )
    v2 = v6 == 4;
  if ( sub_1001C3E0(a1) && sub_10039690(v3) )
    result = 0;
  else
    result = v2;
  return result;
}

//----- (1001C870) --------------------------------------------------------
char __cdecl sub_1001C870(int a1, void *a2)
{
  char result; // al@2
  int v3; // esi@3
  void *v4; // ecx@5

  if ( (_BYTE)a1 )
  {
    result = a1 - 1;
    if ( (unsigned __int8)a1 != 1 )
      return result;
    v3 = 1212;
  }
  else
  {
    v3 = 1200;
  }
  sub_1000EA90(1, v3, a2, 0, 2, 1);
  sub_1000ED50(1, v3, 0xFFFFFFF);
  result = sub_1001FDE0(v4);
  if ( result == 4 )
    result = sub_1001C420(a1, (int)a2);
  return result;
}

//----- (1001C8D0) --------------------------------------------------------
char __cdecl sub_1001C8D0(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 27401;
    result = sub_1001C870(a1, &v3);
  }
  return result;
}

//----- (1001C900) --------------------------------------------------------
char __cdecl sub_1001C900(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 12809;
    result = sub_1001C870(a1, &v3);
  }
  return result;
}

//----- (1001C930) --------------------------------------------------------
char __cdecl sub_1001C930(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 27145;
    result = sub_1001C870(a1, &v3);
  }
  return result;
}

//----- (1001C960) --------------------------------------------------------
char __usercall sub_1001C960@<al>(void *a1@<esi>, int a2)
{
  char v2; // al@4

  *(_BYTE *)a1 = 0;
  if ( sub_1001C2A0(a2) )
  {
    if ( (_BYTE)a2 )
    {
      if ( (unsigned __int8)a2 != 1 )
      {
LABEL_9:
        *(_BYTE *)a1 = 0;
        sub_1001C8D0(a2);
        return 0;
      }
      v2 = sub_1000F100(1, 1389, a1);
    }
    else
    {
      v2 = sub_1000F100(1, 1388, a1);
    }
    if ( v2 && !sub_10038AB0((unsigned __int8 *)a1) )
      return 1;
    goto LABEL_9;
  }
  return 0;
}

//----- (1001C9D0) --------------------------------------------------------
char __cdecl sub_1001C9D0(void *a1)
{
  int v1; // ecx@0
  int v2; // ST08_4@1

  v2 = v1;
  LOBYTE(v2) = sub_1001C0E0(v1);
  return sub_1001C570(a1, v2);
}

//----- (1001C9F0) --------------------------------------------------------
bool __thiscall sub_1001C9F0(void *this)
{
  bool result; // al@4
  char v2; // [sp+7h] [bp-15h]@6
  char v3[4]; // [sp+8h] [bp-14h]@1
  int v4; // [sp+Ch] [bp-10h]@3

  v3[0] = sub_1001C0E0((int)this);
  if ( v3[0] >= 2u )
  {
    result = 0;
  }
  else
  {
    if ( sub_1001C2F0(v3[0]) )
    {
      if ( sub_10021D70(v3[0], 2, &v4) )
        return (v4 & 0x100) == 256;
    }
    else if ( !sub_1001C3E0(v3[0]) && sub_1001C960(&v2, *(int *)v3) && (v2 == 3 || v2 == 2) )
    {
      return 1;
    }
    result = 0;
  }
  return result;
}

//----- (1001CAC0) --------------------------------------------------------
bool __cdecl sub_1001CAC0(int a1)
{
  bool result; // al@4
  unsigned __int8 v2; // [sp+Bh] [bp-49h]@1
  char v3; // [sp+Ch] [bp-48h]@6
  char v4; // [sp+4Bh] [bp-9h]@6

  v2 = 0;
  if ( !sub_1001C2A0(a1) )
    goto LABEL_10;
  if ( sub_1001C960(&v2, a1) && v2 > 0u )
    return 1;
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10023130(a1, (int)&v3);
    result = v4 != 0;
  }
  else
  {
LABEL_10:
    result = 0;
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1001CB60) --------------------------------------------------------
char __cdecl sub_1001CB60(int a1, void *a2)
{
  char v2; // bl@1
  char v3; // al@3
  bool v4; // al@16
  char result; // al@19
  __int16 v6; // kr00_2@21
  char v7; // [sp+Ah] [bp-12h]@1
  char v8; // [sp+Bh] [bp-11h]@6
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@1
  int v12; // [sp+18h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v2 = 0;
  v7 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      goto LABEL_6;
    v2 = sub_1000F100(1, 1215, a2);
    v3 = sub_1000F100(1, 1221, &v9);
  }
  else
  {
    v2 = sub_1000F100(1, 1203, a2);
    v3 = sub_1000F100(1, 1209, &v9);
  }
  v7 = v3;
LABEL_6:
  v8 = sub_1001C340(a1);
  if ( sub_10039040((int)a2)
    || !sub_1001C230(*((_WORD *)a2 + 6))
    || !sub_1001C230(*((_WORD *)a2 + 7))
    || *((_BYTE *)a2 + 11) >= 8u && !v8
    || *(_BYTE *)a2 == 3 && v8 )
  {
    v2 = 0;
  }
  v4 = v7 && !sub_10039290((unsigned __int8 *)&v9);
  if ( v2 )
  {
    if ( v4 )
    {
      v6 = *(_WORD *)((char *)&v9 + 1);
      *((_WORD *)a2 + 6) = v12;
      *(_BYTE *)a2 = v6;
      *((_BYTE *)a2 + 1) = HIBYTE(v6);
    }
    result = v2;
  }
  else
  {
    sub_1001C900(a1);
    result = 0;
  }
  return result;
}

//----- (1001CC90) --------------------------------------------------------
bool __cdecl sub_1001CC90(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // eax@1
  bool v5; // bl@1
  int v7; // esi@15
  void *v8; // ecx@18
  int v9; // [sp+8h] [bp-24h]@1
  int v10; // [sp+Ch] [bp-20h]@1
  int v11; // [sp+10h] [bp-1Ch]@1
  int v12; // [sp+14h] [bp-18h]@1
  int v13; // [sp+18h] [bp-14h]@1
  int v14; // [sp+1Ch] [bp-10h]@1
  int v15; // [sp+20h] [bp-Ch]@1
  int v16; // [sp+24h] [bp-8h]@1

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v4 = *(_DWORD *)a2;
  v10 = v2;
  v11 = v3;
  v9 = v4;
  v5 = 0;
  v12 = *(_DWORD *)(a2 + 12);
  if ( sub_1001CB60(a1, &v13) )
    BYTE3(v11) = BYTE3(v15);
  if ( sub_1001C230(*(_WORD *)(a2 + 12)) && sub_1001C230(*(_WORD *)(a2 + 14)) && (unsigned __int8)a1 < 2u )
  {
    if ( sub_1001C340(a1) )
      v5 = (unsigned __int8)v9 < 6u && (_BYTE)v9 != 3;
    else
      v5 = (unsigned __int8)v9 < 4u;
  }
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      return 0;
    v7 = 1214;
  }
  else
  {
    v7 = 1202;
  }
  if ( v5 == 1 )
  {
    sub_1000EA90(1, v7, &v9, 0, 16, 1);
    sub_1000ED50(1, v7, 0xFFFFFFF);
    if ( sub_1001FDE0(v8) == 4 )
      sub_1001C500(a1);
    sub_1001C900(a1);
  }
  return v5;
}

//----- (1001CDE0) --------------------------------------------------------
char __cdecl sub_1001CDE0(int a1)
{
  char result; // al@1
  int v2; // esi@4
  char v3; // [sp+3h] [bp-1Dh]@5
  __int16 v4; // [sp+4h] [bp-1Ch]@1
  int v5; // [sp+8h] [bp-18h]@3
  int v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@1

  result = 0;
  v4 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  LOBYTE(v4) = 9;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10018670(2018, (int)&a1, 1);
    result = sub_1001C3E0(a1);
    if ( !result )
    {
      LOBYTE(v5) = a1;
      if ( sub_1001C4D0((bool *)&v5) )
      {
        v2 = v5;
        if ( sub_1001C2F0(v5) )
        {
          v3 = 0;
          sub_10021F50(v2, 6, &v3);
        }
        else if ( (unsigned __int8)sub_1001C370(v2) )
        {
          HIBYTE(v4) = 104;
          sub_1001C870(v2, &v4);
          sub_1001C930(v2);
        }
        else if ( sub_1001CB60(v2, &v6) )
        {
          LOBYTE(v6) = 4;
          sub_1001CC90(v2, (int)&v6);
        }
      }
      if ( sub_1001C2F0(a1) )
      {
        v3 = 1;
        result = sub_10021F50(a1, 6, &v3);
      }
      else if ( (unsigned __int8)sub_1001C370(a1) )
      {
        HIBYTE(v4) = 105;
        sub_1001C870(a1, &v4);
        sub_1001C930(a1);
        result = sub_1001CAC0(a1);
        if ( result )
          result = sub_1001C8D0(a1);
      }
      else
      {
        result = sub_1001CB60(a1, &v6);
        if ( result )
        {
          LOBYTE(v6) = 5;
          result = sub_1001CC90(a1, (int)&v6);
        }
      }
    }
  }
  return result;
}

//----- (1001CFA0) --------------------------------------------------------
void sub_1001CFA0()
{
  dword_10186884 = -15;
}
// 10186884: using guessed type int dword_10186884;

//----- (1001CFB0) --------------------------------------------------------
signed int sub_1001CFB0()
{
  return sub_10018EB0((int)&off_10093080);
}
// 10093080: using guessed type char *off_10093080;

//----- (1001CFC0) --------------------------------------------------------
double sub_1001CFC0()
{
  float v1; // [sp+0h] [bp-4h]@1

  v1 = 9.9999996e24;
  if ( (unsigned __int8)sub_1001CFB0() )
    v1 = *(float *)(dword_10186884 + 4);
  return v1;
}
// 10186884: using guessed type int dword_10186884;

//----- (1001CFF0) --------------------------------------------------------
char sub_1001CFF0()
{
  char result; // al@2

  if ( (unsigned __int8)sub_1001CFB0() )
    result = *(_BYTE *)(dword_10186884 + 13);
  else
    result = 0;
  return result;
}
// 10186884: using guessed type int dword_10186884;

//----- (1001D010) --------------------------------------------------------
char sub_1001D010()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  LOWORD(v1) = -32761;
  return sub_10021140((int)&v1);
}

//----- (1001D030) --------------------------------------------------------
void sub_1001D030()
{
  dword_10186888 = -15;
}
// 10186888: using guessed type int dword_10186888;

//----- (1001D040) --------------------------------------------------------
signed int sub_1001D040()
{
  return sub_10018EB0((int)&off_10093198);
}
// 10093198: using guessed type char *off_10093198;

//----- (1001D050) --------------------------------------------------------
char __usercall sub_1001D050@<al>(const char *a1@<esi>, int a2, int a3, char a4, int a5, int a6, __int16 a7, char a8, int a9)
{
  __int16 v10; // [sp+0h] [bp-A4h]@1
  char v11; // [sp+4h] [bp-A0h]@3
  __int16 v12; // [sp+6h] [bp-9Eh]@3
  int v13; // [sp+8h] [bp-9Ch]@3
  int v14; // [sp+Ch] [bp-98h]@3
  char v15; // [sp+10h] [bp-94h]@3
  int v16; // [sp+90h] [bp-14h]@3
  int v17; // [sp+94h] [bp-10h]@3
  int v18; // [sp+98h] [bp-Ch]@3
  char v19; // [sp+9Ch] [bp-8h]@3

  memset(&v10, 0, 0xA0u);
  if ( strlen(a1) >= 0x80 )
    sub_10018A40("..\\lib\\adl\\iop_upld_mngr_intf.c", 711, 1, 0);
  v11 = a8;
  v13 = a5;
  v10 = -32762;
  v14 = a6;
  v12 = a7;
  sub_1001F7C0((int)&v15, a1, 128);
  v17 = a3;
  v16 = a2;
  v18 = a9;
  v19 = a4;
  return sub_10021140((int)&v10);
}

//----- (1001D150) --------------------------------------------------------
char __cdecl sub_1001D150(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_1001D040() == 1 )
  {
    *a1 = *(_BYTE *)dword_10186888;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10186888: using guessed type int dword_10186888;

//----- (1001D180) --------------------------------------------------------
char __cdecl sub_1001D180(const char *a1, int a2, int a3, char a4, __int16 a5, int a6)
{
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  LOBYTE(v7) = 7;
  sub_10039770(a4, &v8, (int)&v9, &v7);
  return sub_1001D050(a1, a2, a3, a4, v8, v9, a5, v7, a6);
}

//----- (1001D1E0) --------------------------------------------------------
char __thiscall sub_1001D1E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10018640(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (1001D200) --------------------------------------------------------
char sub_1001D200()
{
  char result; // al@1

  byte_1018688C = 2;
  result = sub_1001E000(4);
  if ( result )
  {
    byte_1018688C = 0;
  }
  else
  {
    result = sub_1001E000(7);
    if ( result )
      byte_1018688C = 1;
  }
  return result;
}
// 1018688C: using guessed type char byte_1018688C;

//----- (1001D240) --------------------------------------------------------
double __cdecl sub_1001D240(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_1001EAF0(v1);
  if ( sub_1001D1E0(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10018640(2015, (int)&v5, 12);
      return v6;
    }
    sub_10018640(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10018640(2015, (int)&v5, 12);
      return v6;
    }
    sub_10018640(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (1001D2C0) --------------------------------------------------------
char __cdecl sub_1001D2C0(signed int a1, char a2)
{
  void *v2; // ecx@0
  char result; // al@1
  char v4; // bl@2
  int v5; // eax@2
  int v6; // esi@6
  void *v7; // [sp-2h] [bp-4h]@1

  v7 = v2;
  result = a1;
  BYTE3(v7) = 5;
  if ( (_BYTE)a1 )
  {
    v4 = ((_BYTE)a1 == 2) + 3;
    LOBYTE(a1) = ((_BYTE)a1 == 2) + 3;
    v5 = sub_10039E60(a1, 1);
    if ( sub_10029840(v5) == 1 )
      result = (v4 != 3) + 3;
    else
      result = (v4 != 3) + 1;
  }
  BYTE3(v7) = result;
  if ( a2 )
  {
    v6 = 27 - (sub_100206D0(v2) != 2);
    sub_1000EA90(1, v6, (char *)&v7 + 3, 0, 1, 1);
    sub_1000ED50(1, v6, 0xFFFFFFF);
    result = BYTE3(v7);
  }
  return result;
}

//----- (1001D350) --------------------------------------------------------
int __cdecl sub_1001D350(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_10094040[(unsigned __int8)sub_1001EAF0(v1) + 2 * a1];
}
// 10094040: using guessed type int dword_10094040[];

//----- (1001D370) --------------------------------------------------------
void sub_1001D370()
{
  sub_1001D240(0);
}

//----- (1001D380) --------------------------------------------------------
char __fastcall sub_1001D380(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_1001D350(0);
  sub_10018600(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (1001D3C0) --------------------------------------------------------
int __thiscall sub_1001D3C0(void *this)
{
  int v1; // eax@1
  int v2; // eax@2
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v1 = (unsigned __int8)sub_1001D380((int)this);
  if ( (_BYTE)v1 )
  {
    v2 = v1 - 1;
    if ( !v2 )
    {
      sub_100187A0(2064, &v4, 4, &v5);
      return v4;
    }
    if ( v2 == 1 )
    {
      sub_100187A0(2065, &v4, 4, &v5);
      return v4;
    }
  }
  else
  {
    sub_100187A0(2016, &v4, 4, &v5);
  }
  return v4;
}

//----- (1001D450) --------------------------------------------------------
int __cdecl sub_1001D450(int a1, int a2, int a3)
{
  byte_102234D5[0] = 0;
  return nullsub_1(a1, a2, a3);
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1001D460) --------------------------------------------------------
void sub_1001D460()
{
  dword_10223500 = -15;
}
// 10223500: using guessed type int dword_10223500;

//----- (1001D470) --------------------------------------------------------
signed int sub_1001D470()
{
  return sub_10018EB0((int)&off_10094084);
}
// 10094084: using guessed type char *off_10094084;

//----- (1001D480) --------------------------------------------------------
int sub_1001D480()
{
  int result; // eax@1

  result = 0;
  dword_10186890 = -15;
  dword_102234FC = 0;
  dword_102234F0 = 0;
  dword_102234F4 = 0;
  dword_102234F8 = 0;
  return result;
}
// 10186890: using guessed type int dword_10186890;
// 102234F0: using guessed type int dword_102234F0;
// 102234F4: using guessed type int dword_102234F4;
// 102234F8: using guessed type int dword_102234F8;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001D4B0) --------------------------------------------------------
char sub_1001D4B0()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_10018EB0((int)&off_100940B0);
  if ( v0 )
  {
    dword_102234FC = dword_10186890;
    v1 = *(_BYTE *)(dword_10186890 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_102234FC + 36) < (unsigned int)sub_100181D0() )
      v0 = 0;
    dword_102234F8 = dword_10186890 + 56116;
    result = v0;
    dword_102234F0 = dword_10186890 + 1516;
    dword_102234F4 = dword_10186890 + 20484;
  }
  else
  {
    dword_102234FC = 0;
    dword_102234F0 = 0;
    dword_102234F4 = 0;
    dword_102234F8 = 0;
    result = 0;
  }
  return result;
}
// 100940B0: using guessed type char *off_100940B0;
// 10186890: using guessed type int dword_10186890;
// 102234F0: using guessed type int dword_102234F0;
// 102234F4: using guessed type int dword_102234F4;
// 102234F8: using guessed type int dword_102234F8;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001D550) --------------------------------------------------------
int __cdecl sub_1001D550(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001D5A0) --------------------------------------------------------
void sub_1001D5A0()
{
  dword_102234E8 = -15;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D5B0) --------------------------------------------------------
signed int sub_1001D5B0()
{
  return sub_10018EB0((int)&off_100940DC);
}
// 100940DC: using guessed type char *off_100940DC;

//----- (1001D5C0) --------------------------------------------------------
char __usercall sub_1001D5C0@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_102234E8;
  v3 = *(_WORD *)(dword_102234E8 + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_102234E8 + 1296) )
    {
      v4 = sub_1003A020(*(_DWORD *)(dword_102234E8 + 1292));
      v2 = dword_102234E8;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D630) --------------------------------------------------------
signed int sub_1001D630()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_1001D5B0() )
    v0 = *(_BYTE *)(dword_102234E8 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D660) --------------------------------------------------------
bool __cdecl sub_1001D660(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_10018540(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 10000);
    v3 = 0.0;
    v4 = dword_102234E8;
    v2 = *(_WORD *)(dword_102234E8 + 1456) > 1u;
    if ( *(_BYTE *)(dword_102234E8 + 1296) )
    {
      v14 = sub_1003A020(*(_DWORD *)(dword_102234E8 + 1292));
      v4 = dword_102234E8;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_1001D550(6.2831853071796, -6.2831853071796);
      sub_1001D550(6.2831853071796, -6.2831853071796);
      sub_1004CDA0(v14, dword_102234E8 + 1512, (int)&v17);
      v4 = dword_102234E8;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_1004CD70((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_102234E8;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_102234E8 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10018280(101);
    sub_100392B0(a2);
  }
  return v2;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D880) --------------------------------------------------------
char __cdecl sub_1001D880(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 60000);
    v1 = sub_1001D5C0(a1);
    if ( v1 )
      *a1 = *(float *)(dword_102234E8 + 1440) + *a1;
    sub_10018280(101);
  }
  return v1;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D8E0) --------------------------------------------------------
char sub_1001D8E0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 10000);
    if ( !*(_BYTE *)(dword_102234E8 + 1444)
      || !*(_BYTE *)(dword_102234E8 + 1451)
      || (v0 = 1, *(_WORD *)(dword_102234E8 + 1456) <= 1u)
      || *(float *)(dword_102234E8 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_10018280(101);
  }
  return v0;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001D950) --------------------------------------------------------
bool __cdecl sub_1001D950(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 10000);
    if ( *(_BYTE *)(dword_102234E8 + 1444) )
      v2 = (double)(unsigned int)(sub_100181D0() - *(_DWORD *)(dword_102234E8 + 1292))
         / 1000.0
         * *(float *)(dword_102234E8 + 1488)
         + *(float *)(dword_102234E8 + 1484);
    else
      v2 = *(float *)(dword_102234E8 + 1484);
    *a1 = v2;
    *a1 = sub_1004CBD0(*a1);
    v1 = *(_WORD *)(dword_102234E8 + 1456) > 1u;
    sub_10018280(101);
  }
  return v1;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001DA00) --------------------------------------------------------
char sub_1001DA00()
{
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 60000);
    if ( *(_BYTE *)(dword_102234E8 + 1451) && *(float *)(dword_102234E8 + 1480) > 0.447 )
    {
      sub_10018280(101);
      return 1;
    }
    sub_10018280(101);
  }
  return 0;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001DA60) --------------------------------------------------------
bool __cdecl sub_1001DA60(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 60000);
    v2 = dword_102234E8;
    if ( *(_BYTE *)(dword_102234E8 + 1451) )
    {
      *a1 = *(float *)(dword_102234E8 + 1480);
      v2 = dword_102234E8;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10018280(101);
  }
  return v1;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001DAC0) --------------------------------------------------------
char __cdecl sub_1001DAC0(float *a1, float *a2)
{
  char v2; // bl@1
  __int16 v3; // cx@2
  float *v4; // eax@4

  *a1 = 9.9999996e24;
  *a2 = 9.9999996e24;
  v2 = 0;
  if ( (unsigned __int8)sub_1001D5B0() )
  {
    sub_100182A0(101, 60000);
    v3 = *(_WORD *)(dword_102234E8 + 1456);
    if ( v3 == 3 || v3 == 5 )
    {
      v4 = (float *)(dword_102234E8 + 1520);
      *a1 = *(float *)(dword_102234E8 + 1520);
      v2 = 1;
      *a2 = *v4;
    }
    sub_10018280(101);
  }
  return v2;
}
// 102234E8: using guessed type int dword_102234E8;

//----- (1001DB40) --------------------------------------------------------
signed int sub_1001DB40()
{
  return 1000;
}

//----- (1001DB60) --------------------------------------------------------
int sub_1001DB60()
{
  return sub_1003A070((int)off_10094630);
}
// 10094630: using guessed type int (*off_10094630[4])();

//----- (1001DB70) --------------------------------------------------------
char __thiscall sub_1001DB70(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_10186898 = sub_1001FDE0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101868A0, 0, 0x1540u);
  memset(&unk_10187DE0, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_101868A0;
  do
  {
    sub_100213D0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_10187DE0 );
  v3 = 0;
  v4 = &unk_10187DE0;
  do
  {
    result = sub_10021450(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)byte_10189790 );
  return result;
}
// 10186898: using guessed type int dword_10186898;

//----- (1001DC00) --------------------------------------------------------
char __cdecl sub_1001DC00(char a1)
{
  char v1; // bp@1
  int v2; // edi@1
  void *v3; // esi@1
  unsigned __int8 v4; // cl@3
  int v5; // eax@4
  char v7; // [sp+13h] [bp-5h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v7 = 0;
  v8 = sub_10018480(86, 10);
  memset(&unk_10187DE0, 0, 0x19B0u);
  v1 = 0;
  v2 = 0;
  v3 = &unk_10187DE0;
  do
  {
    if ( v7 )
      break;
    sub_10021450(v1, (int)v3);
    v4 = 0;
    while ( 1 )
    {
      v5 = 8 * (v2 + v4);
      if ( byte_10188150[v5] == a1 || byte_10188151[v5] == a1 )
        break;
      if ( ++v4 >= 0x10u )
        goto LABEL_9;
    }
    v7 = 1;
LABEL_9:
    v3 = (char *)v3 + 2192;
    ++v1;
    v2 += 274;
  }
  while ( (signed int)v3 < (signed int)byte_10189790 );
  sub_10018450(v8, 86);
  return v7;
}

//----- (1001DCB0) --------------------------------------------------------
char __cdecl sub_1001DCB0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10186898 != 1379255385;
  v7 = 0;
  v8 = dword_10186898 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10018480(86, 10);
      memset((char *)&unk_101868A0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100213D0(a1, (int)&unk_101868A0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10186B78[v6] == a2 || byte_10186B79[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10018450(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10186898: using guessed type int dword_10186898;

//----- (1001DD70) --------------------------------------------------------
char __cdecl sub_1001DD70(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10186898 != 1379255385;
  v7 = 0;
  v8 = dword_10186898 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10018480(86, 10);
      memset((char *)&unk_101868A0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100213D0(a1, (int)&unk_101868A0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_10186B98[v6] == a2 || byte_10186B99[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10018450(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10186898: using guessed type int dword_10186898;

//----- (1001DE30) --------------------------------------------------------
char __cdecl sub_1001DE30(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_100247B0(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (1001DE80) --------------------------------------------------------
char __cdecl sub_1001DE80(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_10094C0C;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001DCB0((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 0x18 );
  return result;
}

//----- (1001DF00) --------------------------------------------------------
char __cdecl sub_1001DF00(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_100247B0(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 2;
  }
  return v2;
}

//----- (1001DF50) --------------------------------------------------------
char __cdecl sub_1001DF50(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_10094BDC;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001DCB0((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 8 );
  return result;
}

//----- (1001DFD0) --------------------------------------------------------
char __cdecl sub_1001DFD0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001DCB0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001E000) --------------------------------------------------------
char __cdecl sub_1001E000(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001DD70(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001E030) --------------------------------------------------------
char __cdecl sub_1001E030(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_10094BE4;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001DCB0((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 8 );
  return result;
}

//----- (1001E0B0) --------------------------------------------------------
char __cdecl sub_1001E0B0(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001DE30(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (1001E0F0) --------------------------------------------------------
char __cdecl sub_1001E0F0(char a1, _BYTE *a2)
{
  int v2; // esi@1

  *a2 = 19;
  v2 = 0;
  while ( a1 != 3 && a1 != byte_10094BED[2 * v2] || !sub_1001E0B0(byte_10094BEC[2 * v2]) )
  {
    if ( (unsigned int)++v2 >= 0xF )
      return 0;
  }
  *a2 = byte_10094BEC[2 * v2];
  return 1;
}

//----- (1001E140) --------------------------------------------------------
char __cdecl sub_1001E140(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_1001E7B0(&a1, 2u, (int)&unk_100DB232, 8, 415, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = *(&dword_100DB234 + 2 * v2);
    result = 1;
  }
  return result;
}

//----- (1001E180) --------------------------------------------------------
signed __int16 __usercall sub_1001E180@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_100206D0(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_1001F920(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_100206D0(v4);
        sub_1001F8F0(byte_10189790, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_10018A40("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_10189790);
        break;
    }
  }
  if ( a3 )
    sub_1001F920(a3, &v7, 51);
  return v3;
}

//----- (1001E3D0) --------------------------------------------------------
char __cdecl sub_1001E3D0(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_1001E180(v1, a1, 0);
  v2 = sub_1001E7B0(&v6, 2u, (int)&unk_100DB232, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_10018A40("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_100187A0(*(&dword_100DB234 + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (1001E460) --------------------------------------------------------
int __cdecl sub_1001E460(signed __int16 a1)
{
  void *v1; // ecx@1
  signed __int16 v2; // ax@1
  int v3; // esi@2
  int result; // eax@6
  char v5; // [sp+Ah] [bp-42h]@1
  char v6; // [sp+Bh] [bp-41h]@1
  int v7; // [sp+Ch] [bp-40h]@1
  int v8; // [sp+10h] [bp-3Ch]@1
  char v9; // [sp+14h] [bp-38h]@1

  memset(&v9, 0, 0x33u);
  v5 = 0;
  v6 = 0;
  v2 = sub_1001E180(v1, a1, 0);
  v8 = (unsigned __int16)v2;
  if ( sub_1001E140(v2, &v7) )
  {
    v3 = v7;
    if ( !sub_100187A0(v7, &v5, 1, &v6) && v5 )
    {
      v5 = 0;
      sub_10018670(v3, (int)&v5, 1);
    }
  }
  else
  {
    sub_1001F8F0(
      byte_10189790,
      0x64u,
      "An attempt to clear a system trigger was performed with an invalid trigger id (%u)",
      (unsigned __int16)a1);
    sub_10018A40("..\\lib\\adl\\sys_updt_alrt_data.c", 522, 0, byte_10189790);
  }
  result = (unsigned __int16)sub_1001E7B0(&v8, 2u, (int)&unk_100DBF30, 12, 32, -1);
  if ( (_WORD)result != -1 )
    result = sub_10018670(dword_100DBF2C[3 * (signed __int16)result], (int)&v9, 51);
  return result;
}
// 100DBF2C: using guessed type int dword_100DBF2C[];

//----- (1001E570) --------------------------------------------------------
char __cdecl sub_1001E570(unsigned __int16 a1)
{
  int v1; // esi@2
  int v2; // eax@2
  char v4; // [sp+6h] [bp-6h]@1
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 1;
  if ( sub_1001E140(a1, &v6) )
  {
    v1 = v6;
    v2 = sub_100187A0(v6, &v4, 1, &v5);
    if ( !v2 && !v4 )
    {
      v4 = 1;
      LOBYTE(v2) = sub_10018670(v1, (int)&v4, 1);
    }
  }
  else
  {
    sub_1001F8F0(
      byte_10189790,
      0x64u,
      "An attempt to set a system trigger was performed with an invalid trigger id (%u)",
      a1);
    LOBYTE(v2) = sub_10018A40("..\\lib\\adl\\sys_updt_alrt_data.c", 666, 0, byte_10189790);
  }
  return v2;
}

//----- (1001E610) --------------------------------------------------------
char __cdecl sub_1001E610(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1001E650) --------------------------------------------------------
__int16 __usercall sub_1001E650@<ax>(unsigned __int8 a1@<al>)
{
  return word_100952A8[a1];
}
// 100952A8: using guessed type __int16 word_100952A8[];

//----- (1001E660) --------------------------------------------------------
char __cdecl sub_1001E660(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1001E650(a1);
    if ( sub_1000F130(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1001E730) --------------------------------------------------------
char __cdecl sub_1001E730(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1001E610(a1);
  if ( a3 != 11 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1001E660(v7, a5);
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1001E7B0) --------------------------------------------------------
int __cdecl sub_1001E7B0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1001E940) --------------------------------------------------------
int __cdecl sub_1001E940(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (1001E950) --------------------------------------------------------
int __usercall sub_1001E950@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1003A0B0(a2, a1);
}

//----- (1001E960) --------------------------------------------------------
char __usercall sub_1001E960@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_1001E950((char *)&v5, a2);
  v2 = sub_1001E940(a1);
  if ( sub_10018540(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 1001E960: using guessed type char var_48[68];

//----- (1001EA20) --------------------------------------------------------
char __usercall sub_1001EA20@<al>(char a1@<dl>, char a2@<cl>, char a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  __int16 v5; // [sp+4h] [bp-8h]@1
  char v6; // [sp+6h] [bp-6h]@1

  v4 = 0;
  LOBYTE(v5) = a3;
  LOWORD(v4) = -32706;
  HIBYTE(v5) = a2;
  v6 = a1;
  return sub_10021140((int)&v4);
}

//----- (1001EA70) --------------------------------------------------------
char __cdecl sub_1001EA70(char a1, char a2)
{
  return sub_1001E960(a1, a2);
}

//----- (1001EA90) --------------------------------------------------------
char __cdecl sub_1001EA90(char a1, char a2)
{
  void *v2; // ecx@1
  char v3; // al@1

  sub_1001EA20(0, a2, a1);
  v3 = sub_1001EAF0(v2);
  return sub_1001EA70(v3, a1);
}

//----- (1001EAC0) --------------------------------------------------------
char __cdecl sub_1001EAC0(char a1)
{
  char result; // al@1

  result = sub_1003A100();
  if ( result == 2 )
    result = byte_10095D64[8 * sub_1001E7B0(&a1, 4u, (int)&unk_10095D60, 8, 7, 7)];
  return result;
}

//----- (1001EAF0) --------------------------------------------------------
char __thiscall sub_1001EAF0(void *this)
{
  char v1; // al@1

  v1 = sub_100206D0(this);
  return sub_1001EAC0(v1);
}

//----- (1001EB00) --------------------------------------------------------
char sub_1001EB00()
{
  char result; // al@1
  void *v1; // ecx@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  result = sub_1003A110();
  if ( result == 3 )
  {
    v2 = sub_100206D0(v1);
    result = byte_10095D2C[8 * sub_1001E7B0(&v2, 4u, (int)&unk_10095D28, 8, 7, 7)];
  }
  return result;
}

//----- (1001EB40) --------------------------------------------------------
void __cdecl sub_1001EB40(float a1, int a2)
{
  double v2; // st7@1

  v2 = a1;
  if ( a1 < 11000.232 )
    *(float *)a2 = pow(v2 * -0.0065 / 288.1499938964844 + 1.0, 5.255880147586614) * 101325.0;
  else
    *(float *)a2 = exp((v2 - 11000.232421875) * -0.0001576885406393558) * 22631.953125;
}

//----- (1001EBA0) --------------------------------------------------------
void __cdecl sub_1001EBA0(float a1, float a2, int a3)
{
  float v3; // ecx@0
  float v4; // [sp+8h] [bp-4h]@1

  v4 = v3;
  sub_1001EB40(a2, (int)&v4);
  *(float *)a3 = sqrt((pow(
                         (pow(a1 * a1 * 0.199999988079071 + 1.0, 3.500000238418579) - 1.0) * (v4 / 101325.0) + 1.0,
                         0.2857142686843872)
                     - 1.0) * 579000.0625);
}

//----- (1001EC10) --------------------------------------------------------
double __cdecl sub_1001EC10(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_1004CA30(a1, a4);
  *(float *)&v16 = sub_1004C950(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (1001ECF0) --------------------------------------------------------
char __cdecl sub_1001ECF0(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_10018540(9190, (int)v3, 67);
  return sub_1001FFA0(a1, v3[(unsigned __int8)a1], a2);
}
// 1001ECF0: using guessed type char var_48[68];

//----- (1001ED40) --------------------------------------------------------
char __cdecl sub_1001ED40(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_10018540(9189, (int)v3, 67);
  return sub_1001FFA0(a1, v3[(unsigned __int8)a1], a2);
}
// 1001ED40: using guessed type char var_48[68];

//----- (1001ED90) --------------------------------------------------------
bool __cdecl sub_1001ED90(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_1003A120(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_1000E330(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_1000F100(v5[0], v6, a2) && !sub_10024E90(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (1001EE10) --------------------------------------------------------
char __cdecl sub_1001EE10(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_1003A120(a1, 0, &v4, &v3) != 1 && sub_1003A120(a1, 1u, &v4, &v3) != 1
    || (result = sub_1000E680(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (1001EE80) --------------------------------------------------------
bool __cdecl sub_1001EE80(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_1001EAF0(v2) != 0;
  return sub_1001ED90(a1, a2, v3);
}

//----- (1001EEB0) --------------------------------------------------------
bool __cdecl sub_1001EEB0(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1001FDC0(v1);
  v10 = 0;
  v5 = &unk_10096490;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_1001EA70(v10, 0);
      if ( sub_1001FFA0(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (1001EF50) --------------------------------------------------------
int sub_1001EF50()
{
  int result; // eax@1

  sub_10018640(6361, (int)&flt_101897F4, 4);
  result = sub_10018640(6362, (int)&flt_101897F8, 4);
  dword_101897FC = 1379255385;
  return result;
}
// 101897F4: using guessed type float flt_101897F4;
// 101897F8: using guessed type float flt_101897F8;
// 101897FC: using guessed type int dword_101897FC;

//----- (1001EF80) --------------------------------------------------------
char __usercall sub_1001EF80@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4)
{
  char v4; // cl@1
  char result; // al@5
  void *v6; // [sp+0h] [bp-8h]@0

  v4 = sub_10020020(a1, v6);
  if ( v4 && ((COERCE_UNSIGNED_INT(*a2) & 0x7F800000) == 2139095040 || a3 < (double)*a2 || a4 > (double)*a2) )
  {
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (1001EFE0) --------------------------------------------------------
char __cdecl sub_1001EFE0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_10020020(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_10020020(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_1003EF50(flt_101897F4, 0.0);
        result = v1;
        v5 = flt_101897F8 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 101897F4: using guessed type float flt_101897F4;
// 101897F8: using guessed type float flt_101897F8;

//----- (1001F0E0) --------------------------------------------------------
char __cdecl sub_1001F0E0(void *a1)
{
  char v1; // bl@1
  int v2; // eax@7
  char result; // al@9
  float v4; // [sp+14h] [bp-10h]@1
  float v5; // [sp+18h] [bp-Ch]@1
  float v6; // [sp+1Ch] [bp-8h]@1
  float v7; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v4 = 0.0;
  v6 = 0.0;
  v1 = sub_10020020(57, a1);
  if ( v1 )
  {
    v7 = *(float *)a1;
    if ( (LODWORD(v7) & 0x7F800000) == 2139095040 || *(float *)a1 > 166.46144 || *(float *)a1 < -166.46144 )
    {
      v1 = 0;
      *(float *)a1 = 0.0;
    }
  }
  sub_10018640(6950, (int)&v4, 4);
  if ( 0.0 != v4 && sub_10020020(66, &v5) && (LOBYTE(v2) = 58, sub_1001EF80(v2, &v6, 166.46144, -166.46144)) )
  {
    result = 1;
    *(float *)a1 = v4 * v5 + v6;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (1001F1C0) --------------------------------------------------------
char __cdecl sub_1001F1C0(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32746;
  qmemcpy(&v3, a1, 0x11Cu);
  return sub_10021150((int)&v2);
}

//----- (1001F230) --------------------------------------------------------
int __cdecl sub_1001F230(unsigned __int8 a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  char v4; // [sp+8h] [bp-120h]@1
  char v5; // [sp+27h] [bp-101h]@1

  memset(&v4, 0, 0x11Cu);
  sub_10021360(a1, (int)&v4);
  v5 = 0;
  sub_1001F1C0(&v4);
  v2 = sub_1001FC40(v1);
  sub_1003A1E0(a1, SIM_intf + 24);
  *(_BYTE *)(SIM_intf + 320) = v2;
  return SIM_proc_rqst(49);
}
// 1003A1E0: using guessed type _DWORD __cdecl sub_1003A1E0(_DWORD, _DWORD);
// 1004CDC6: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (1001F2C0) --------------------------------------------------------
int __cdecl sub_1001F2C0(unsigned __int8 a1)
{
  char v1; // bl@1
  void *v2; // ecx@1
  int result; // eax@1

  v1 = j_HWM_pvg_hsdb_get_lrus_online();
  result = sub_100206D0(v2);
  if ( result == 1 )
    return sub_1001F230(a1);
  if ( result == 4 )
  {
    if ( v1 & 1 )
      return result;
    return sub_1001F230(a1);
  }
  if ( result == 2 && !(v1 & 5) )
    return sub_1001F230(a1);
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001F2F0) --------------------------------------------------------
char __cdecl sub_1001F2F0(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_1001D630() > 1u;
  v1 = 0;
  v12 = sub_1001EEB0(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_10097300;
  if ( sub_1001EE10(0x2E6u) || sub_1001EE10(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_100972F8;
  v3 = 4;
  do
  {
    if ( sub_1001EE10(*v2) && sub_1001EE80(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_10097308[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_1001D8E0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1001FDE0(v4) == 2 || sub_1001FDE0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (1001F430) --------------------------------------------------------
bool __thiscall sub_1001F430(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return sub_1001FDE0(this) == 1 && sub_1001F2F0((bool *)&v2 + 3) && BYTE3(v2);
}

//----- (1001F460) --------------------------------------------------------
char __cdecl sub_1001F460(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CF16: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (1001F4D0) --------------------------------------------------------
char __cdecl sub_1001F4D0(int a1, int a2, void *a3)
{
  char v3; // bl@1
  int v4; // eax@1
  unsigned __int16 v5; // bp@1
  int v6; // esi@4
  int v7; // eax@6
  char v8; // al@7
  unsigned __int8 v9; // dl@10
  __int16 v10; // cx@10
  char v11; // dl@12
  char v12; // ST2C_1@13
  char v13; // bl@14
  float v14; // ST30_4@16
  double v15; // st7@16
  char v16; // ST2C_1@16
  char v18; // [sp+18h] [bp-5Ch]@10
  char v19; // [sp+18h] [bp-5Ch]@14
  unsigned __int8 v20; // [sp+1Bh] [bp-59h]@1
  unsigned __int16 v21; // [sp+1Ch] [bp-58h]@14
  unsigned int v22; // [sp+20h] [bp-54h]@12
  int v23; // [sp+24h] [bp-50h]@1
  int v24; // [sp+28h] [bp-4Ch]@1
  unsigned __int64 v25; // [sp+2Ch] [bp-48h]@13
  char v26[8]; // [sp+34h] [bp-40h]@14
  char v27[8]; // [sp+3Ch] [bp-38h]@15
  char v28[44]; // [sp+44h] [bp-30h]@7

  v3 = 0;
  v24 = a1;
  v4 = a2;
  *(_BYTE *)a3 = 0;
  v5 = *(_WORD *)(a2 + 16);
  v23 = a2;
  v20 = 0;
  while ( v20 < *(_BYTE *)(v4 + 18) )
  {
    v6 = v24 + 10 * v5 + 22534;
    if ( *(_BYTE *)v6 == 1 )
    {
      v14 = (double)*(_WORD *)(v24 + 10 * v5 + 22542) * 0.125;
      v15 = sub_1004CA30(v14, 1.0);
      v16 = *(_WORD *)(v6 + 8) % 8;
      v3 = sub_10020770(*(_BYTE *)(v6 + 4), *(_WORD *)(v6 + 6), (signed int)v15, 1, a3);
      v11 = ((unsigned __int8)(1 << v16) & *(_BYTE *)a3) != 0;
LABEL_17:
      *(_BYTE *)a3 = v11;
    }
    else if ( *(_BYTE *)v6 == 2 )
    {
      v7 = *(_BYTE *)(v24 + 10 * v5 + 22538);
      switch ( v7 )
      {
        case 0:
        case 1:
          v3 = sub_10020770(6, (unsigned __int16)word_10097884[v7], 0, 44, v28);
          v8 = v28[*(_BYTE *)(v6 + 5)];
          *(_BYTE *)a3 = v8 == 1;
          if ( !v8 || v8 == 3 )
            v3 = 0;
          break;
        case 2:
        case 3:
        case 4:
          v9 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v10 = 0;
          v18 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          if ( v9 >= 0x18u )
          {
            v10 = 4;
            v18 = v9 - 24;
          }
          v3 = sub_10020770(0, (unsigned __int16)word_10097884[v7], v10, 4, &v22);
          v11 = (v22 >> v18) & 1;
          goto LABEL_17;
        case 5:
        case 6:
        case 7:
        case 8:
          v12 = *(_BYTE *)(v24 + 10 * v5 + 22539) - 79;
          v3 = sub_10020770(0, (unsigned __int16)word_10097884[v7], 0, 8, &v25);
          *(_BYTE *)a3 = (v25 >> v12) & 1;
          break;
        case 9:
        case 10:
        case 11:
        case 12:
          v13 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v21 = sub_1004C9F0((unsigned int)*(_BYTE *)(v24 + 10 * v5 + 22539) >> 3, 1);
          v19 = v13 - 8 * v21;
          v3 = sub_10020770(6, (unsigned __int16)word_10097884[*(_BYTE *)(v6 + 4)], 0, 16, v26);
          if ( !v3 )
            break;
          v3 = ((unsigned __int8)v26[v21] >> v19) & 1;
          v11 = ((unsigned __int8)v27[v21] >> v19) & 1;
          goto LABEL_17;
        default:
          break;
      }
    }
    ++v20;
    ++v5;
    if ( v3 )
      break;
    v4 = v23;
  }
  return v3;
}
// 10097884: using guessed type __int16 word_10097884[];
// 1001F4D0: using guessed type char var_30[44];
// 1001F4D0: using guessed type char var_40[8];
// 1001F4D0: using guessed type char var_38[8];

//----- (1001F770) --------------------------------------------------------
char __cdecl sub_1001F770(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(_BYTE *)a2 = 0;
  v2 = sub_1003A2B0(a1);
  v3 = sub_10020790();
  if ( v2 && v3 && !*(_WORD *)(v2 + 12) )
    result = sub_1001F4D0(v3, v2, a2);
  else
    result = 0;
  return result;
}

//----- (1001F7C0) --------------------------------------------------------
int __cdecl sub_1001F7C0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1001F810) --------------------------------------------------------
signed int __cdecl sub_1001F810(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (1001F880) --------------------------------------------------------
int __cdecl sub_1001F880(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1001F8B0) --------------------------------------------------------
int __cdecl sub_1001F8B0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1001F8F0) --------------------------------------------------------
int sub_1001F8F0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1001F8B0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1001F920) --------------------------------------------------------
int __cdecl sub_1001F920(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1001F7C0((int)&a1[v3], a2, a3 - v3);
}

//----- (1001F960) --------------------------------------------------------
int __cdecl sub_1001F960(void *a1)
{
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  return sub_10018600(2102, a1, 4, &v2);
}

//----- (1001F990) --------------------------------------------------------
BOOL __cdecl sub_1001F990(float a1, float a2)
{
  double v2; // st5@7
  double v3; // st7@7
  float v4; // ST00_4@9
  double v5; // st4@10
  float v6; // ST04_4@13
  double v7; // st3@14
  double v8; // st2@18
  double v9; // st6@19
  double v10; // rt1@20
  double v11; // st3@20
  double v12; // st7@20
  double v13; // st6@21
  double v14; // rtt@23
  double v15; // st4@23
  double v16; // st7@23
  float v18; // [sp+0h] [bp-8h]@1
  float v19; // [sp+4h] [bp-4h]@1

  v18 = 3704.0;
  v19 = 32767.0;
  if ( sub_1001D4B0() )
  {
    sub_10037470();
    v18 = *(float *)(dword_102234FC + 180);
    if ( *(_BYTE *)(dword_102234F0 + 239) > 3u )
    {
      v19 = *(float *)(dword_102234FC + 184);
      if ( *(_BYTE *)(dword_102234FC + 160) >= 3u )
      {
        v18 = *(float *)(dword_102234FC + 960);
        v19 = *(float *)(dword_102234FC + 980);
      }
    }
    sub_10037460();
  }
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 )
  {
    v3 = 0.0;
LABEL_9:
    v4 = v3;
    v2 = v4;
    goto LABEL_10;
  }
  v2 = v18;
  v3 = 0.0;
  if ( v18 > 32767.0 || v2 < 0.0 )
    goto LABEL_9;
LABEL_10:
  v5 = v19;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v5 > 32767.0 || v5 < v3 )
  {
    v6 = v3;
    v5 = v6;
  }
  v7 = a1;
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v7 > 32767.0 || v7 < v3 )
    v7 = (float)32767.0;
  v8 = a2;
  if ( (LODWORD(a2) & 0x7F800000) == 2139095040 )
  {
    v12 = v7;
    goto LABEL_21;
  }
  v9 = a2;
  if ( v8 > 32767.0 )
  {
    v12 = v7;
    v13 = v5;
    goto LABEL_22;
  }
  v10 = v7;
  v11 = v3;
  v12 = v10;
  if ( v11 > v8 )
  {
LABEL_21:
    v13 = v5;
LABEL_22:
    v5 = v13;
    v9 = (float)32767.0;
  }
  v14 = v5;
  v15 = v12;
  v16 = v14;
  return v15 <= v2 && v9 <= v16;
}
// 102234F0: using guessed type int dword_102234F0;
// 102234FC: using guessed type int dword_102234FC;

//----- (1001FB40) --------------------------------------------------------
char __cdecl sub_1001FB40(int a1, int a2, float *a3)
{
  float *v3; // esi@1
  int v4; // eax@3
  double v5; // st7@5
  double v6; // st7@5
  double v7; // st7@6
  char result; // al@7

  v3 = a3;
  if ( 9.9999996e24 == *a3 )
  {
    result = 0;
    *(_BYTE *)a2 = 0;
  }
  else if ( sub_1001F0E0(&a3) )
  {
    v4 = sub_100181D0();
    if ( *(_BYTE *)a2 && *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a2 + 12) )
    {
      v5 = *(float *)&a3 - *(float *)(a1 + 136);
      a3 = (float *)(v4 - *(_DWORD *)(a2 + 8));
      *(float *)&a3 = v5 * (double)(unsigned int)a3 / 1000.0;
      v6 = *(float *)&a3 + *(float *)(a2 + 4);
    }
    else
    {
      v7 = *(float *)&a3 - *(float *)(a1 + 136);
      a3 = (float *)(v4 - *(_DWORD *)(a1 + 32));
      *(float *)&a3 = v7 * (double)(unsigned int)a3 / 1000.0;
      v6 = *(float *)&a3 + *v3;
    }
    *(float *)(a2 + 4) = v6;
    *v3 = *(float *)(a2 + 4);
    *(_DWORD *)(a2 + 8) = v4;
    *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 32);
    result = 1;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    result = 1;
  }
  return result;
}

//----- (1001FC20) --------------------------------------------------------
void sub_1001FC20()
{
  float v0; // ST00_4@1

  v0 = sub_1001D370();
  sub_1005F870(v0);
}
// 1001D370: using guessed type double sub_1001D370(void);

//----- (1001FC40) --------------------------------------------------------
char __thiscall sub_1001FC40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10018540(3137, (int)&v2 + 3, 1) )
  {
    sub_10019570(86, (_BYTE *)&v2 + 3);
    sub_10018670(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (1001FC80) --------------------------------------------------------
char __thiscall sub_1001FC80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_100187A0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001FCB0) --------------------------------------------------------
int sub_1001FCB0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_100187A0(3012, &v2, 4, &v1);
  return v2;
}

//----- (1001FCE0) --------------------------------------------------------
char __cdecl sub_1001FCE0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CF1C: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (1001FD00) --------------------------------------------------------
bool __cdecl sub_1001FD00(int a1)
{
  int v1; // esi@1
  void *v2; // ecx@1

  v1 = j_HWM_pvg_hsdb_get_lrus_online();
  return (a1 & (sub_100206D0(v2) | v1)) == a1;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001FD20) --------------------------------------------------------
int __cdecl sub_1001FD20(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10018A40("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10018A40("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1004CF22: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1001FD80) --------------------------------------------------------
char __thiscall sub_1001FD80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001FDA0) --------------------------------------------------------
char __thiscall sub_1001FDA0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001FDC0) --------------------------------------------------------
int __thiscall sub_1001FDC0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(29, (char *)&v2);
  return (int)v2;
}

//----- (1001FDE0) --------------------------------------------------------
char __thiscall sub_1001FDE0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001FE00) --------------------------------------------------------
char __thiscall sub_1001FE00(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001FE20) --------------------------------------------------------
int __cdecl sub_1001FE20(char a1)
{
  return sub_1001FD20(56, &a1);
}

//----- (1001FE30) --------------------------------------------------------
int __cdecl sub_1001FE30(char a1)
{
  return sub_1001FD20(80, &a1);
}

//----- (1001FE40) --------------------------------------------------------
void sub_1001FE40()
{
  dword_102234E0 = -15;
}
// 102234E0: using guessed type int dword_102234E0;

//----- (1001FE50) --------------------------------------------------------
char __cdecl sub_1001FE50(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_1001EAF0(v1);
  v3 = sub_1001E940(v2);
  if ( sub_10018540(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 1001FE50: using guessed type char var_48[68];

//----- (1001FEB0) --------------------------------------------------------
signed int sub_1001FEB0()
{
  return sub_10018EB0((int)&off_100985AC);
}
// 100985AC: using guessed type char *off_100985AC;

//----- (1001FEC0) --------------------------------------------------------
char __usercall sub_1001FEC0@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_1001FEB0()
    || sub_100182A0(33, 10) )
  {
    sub_10018A40("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_100181D0()
                         - *(_DWORD *)(dword_102234E0 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_102234E0 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_102234E0 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_102234E0 + 2 * v3 + 62));
    sub_10018280(33);
    result = 1;
  }
  else
  {
    sub_10018280(33);
    result = 0;
  }
  return result;
}
// 102234E0: using guessed type int dword_102234E0;

//----- (1001FFA0) --------------------------------------------------------
char __cdecl sub_1001FFA0(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_1001FEC0(a1, a2, a3);
    }
    else
    {
      v4 = sub_10029A80(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_1000E330(*(_BYTE *)v5)) )
      {
        result = sub_1000F100(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10029A80: using guessed type _DWORD __cdecl sub_10029A80(char);

//----- (10020020) --------------------------------------------------------
char __cdecl sub_10020020(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_1001FE50(a1);
  return sub_1001FFA0(a1, v2, a2);
}

//----- (10020040) --------------------------------------------------------
char __cdecl sub_10020040(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10020080) --------------------------------------------------------
char __cdecl sub_10020080(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (100200F0) --------------------------------------------------------
char __cdecl sub_100200F0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10020160) --------------------------------------------------------
signed int __cdecl sub_10020160(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100201E0) --------------------------------------------------------
char __cdecl sub_100201E0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10020250) --------------------------------------------------------
char __cdecl sub_10020250(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10020300) --------------------------------------------------------
char __cdecl sub_10020300(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10020410) --------------------------------------------------------
char __cdecl sub_10020410(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10020510) --------------------------------------------------------
char __usercall sub_10020510@<al>(int a1@<edi>, char a2, unsigned __int8 a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char result; // al@2

  v3 = a3;
  v4 = sub_1001E7B0(&a2, 1u, a1, 2, a3, a3);
  if ( v4 >= v3 )
    result = -80;
  else
    result = *(_BYTE *)(a1 + 2 * v4 + 1);
  return result;
}

//----- (10020540) --------------------------------------------------------
char __cdecl sub_10020540(char a1)
{
  return sub_10020510((int)&unk_10098B00, a1, 0xBu);
}

//----- (10020560) --------------------------------------------------------
char __thiscall sub_10020560(void *this)
{
  int v1; // eax@1

  v1 = sub_100206D0(this);
  return sub_10020410(v1);
}

//----- (10020570) --------------------------------------------------------
char __cdecl sub_10020570(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10020540(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1003A400(v2);
  return result;
}

//----- (100205A0) --------------------------------------------------------
char __cdecl sub_100205A0(bool *a1, unsigned int a2)
{
  bool *v2; // esi@1
  _BYTE *v3; // edi@1
  char v4; // bl@1
  bool v5; // al@8
  char result; // al@14
  unsigned int v7; // [sp+Ch] [bp-4h]@6

  v2 = a1;
  v3 = (_BYTE *)a2;
  v4 = 0;
  *a1 = 0;
  *v3 = 0;
  sub_10018540(6612, (int)&a1, 1);
  if ( (_BYTE)a1 == 4 || (_BYTE)a1 == 5 || (_BYTE)a1 == 8 )
  {
    v4 = 1;
    v5 = sub_1000F0D0(6, 95, 0, 4, &a2) && (a2 >> 18) & 1 || sub_1000F0D0(6, 96, 0, 4, &v7) && (v7 >> 18) & 1;
    *v2 = v5;
    if ( sub_1000F0D0(6, 95, 0, 4, &a2) && (a2 >> 21) & 1 || sub_1000F0D0(6, 96, 0, 4, &v7) && (v7 >> 21) & 1 )
    {
      result = 1;
      *v3 = 1;
      return result;
    }
    *v3 = 0;
  }
  return v4;
}

//----- (100206A0) --------------------------------------------------------
char __thiscall sub_100206A0(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_1001FD20(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 1004CDC6: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (100206D0) --------------------------------------------------------
int __thiscall sub_100206D0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1001FD20(46, (char *)&v2);
  return (int)v2;
}

//----- (100206F0) --------------------------------------------------------
bool __cdecl sub_100206F0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_1003A4F0(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_100206D0(v1) & 3 || sub_1001FE00(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_1001FE00(v1) != 1;
      break;
    default:
      result = sub_1001FE00(v1) == 1;
      break;
  }
  return result;
}

//----- (10020760) --------------------------------------------------------
void sub_10020760()
{
  dword_10189830 = -15;
}
// 10189830: using guessed type int dword_10189830;

//----- (10020780) --------------------------------------------------------
signed int sub_10020780()
{
  return sub_10018EB0((int)&off_100996DC);
}
// 100996DC: using guessed type char *off_100996DC;

//----- (10020790) --------------------------------------------------------
int sub_10020790()
{
  return (unsigned __int8)sub_10020780() != 0 ? dword_10189830 : 0;
}
// 10189830: using guessed type int dword_10189830;

//----- (100207A0) --------------------------------------------------------
signed int sub_100207A0()
{
  signed int result; // eax@1

  result = -15;
  dword_102234DC = -15;
  dword_102234D8 = -15;
  return result;
}
// 102234D8: using guessed type int dword_102234D8;
// 102234DC: using guessed type int dword_102234DC;

//----- (100207B0) --------------------------------------------------------
void sub_100207B0()
{
  dword_10189834 = -15;
}
// 10189834: using guessed type int dword_10189834;

//----- (100207C0) --------------------------------------------------------
char __cdecl sub_100207C0(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // eax@4
  __int16 v6; // di@4
  char result; // al@8
  char v8; // [sp+4h] [bp-30h]@1
  char v9[2]; // [sp+8h] [bp-2Ch]@4
  __int16 v10[19]; // [sp+Ah] [bp-2Ah]@4

  memset(&v8, 0, 0x2Cu);
  if ( a1 >= 0xB0u )
  {
    LOBYTE(v4) = v8;
  }
  else
  {
    LOBYTE(v4) = 0;
    if ( a2 )
    {
      do
      {
        if ( (unsigned __int8)v4 >= 0xAu )
          break;
        v5 = (unsigned __int8)v4;
        v6 = *(_WORD *)(a3 + 2 * (unsigned __int8)v4);
        LOBYTE(v4) = v4 + 1;
        v9[4 * v5] = a1;
        v10[2 * v5] = v6;
      }
      while ( (unsigned __int8)v4 < a2 );
    }
    v8 = v4;
  }
  if ( (_BYTE)v4 )
  {
    LOWORD(v4) = 4 * ((unsigned __int8)v4 + 1);
    sub_1000EA90(2, 570, &v8, 1, v4, 1);
    sub_1000ED50(2, 570, a4);
    result = v8;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100207C0: using guessed type char var_2C[2];
// 100207C0: using guessed type __int16 var_2A[19];

//----- (10020890) --------------------------------------------------------
int __cdecl sub_10020890(char a1, __int16 a2, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  char v5; // [sp+4h] [bp-528h]@1
  __int16 v6; // [sp+6h] [bp-526h]@1
  int v7; // [sp+8h] [bp-524h]@1

  v5 = a1;
  v4 = -32710;
  v6 = a2;
  v7 = a3;
  return sub_10018300(28, (int)&v4, 50000, 0);
}

//----- (10020900) --------------------------------------------------------
signed int sub_10020900()
{
  return sub_10018EB0((int)&off_1009A4A0);
}
// 1009A4A0: using guessed type char *off_1009A4A0;

//----- (10020910) --------------------------------------------------------
unsigned __int8 __cdecl sub_10020910(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // ebp@5
  int v5; // eax@7
  int v6; // edx@7

  v3 = 0;
  if ( (unsigned __int8)sub_10020900() && a1 < 0xB0u && !sub_100182A0(97, 100) )
  {
    if ( a3 > 0u )
    {
      v4 = 4 * a1;
      do
      {
        if ( v3 >= *(_BYTE *)(dword_10189834 + v4) )
          break;
        v5 = 136 * (v3 + *(_WORD *)(dword_10189834 + v4 + 2));
        v6 = a2 + 120 * v3;
        *(_BYTE *)v6 = *(_BYTE *)(v5 + dword_10189834 + 705);
        *(_BYTE *)(v6 + 1) = *(_BYTE *)(v5 + dword_10189834 + 706);
        qmemcpy((void *)(v6 + 4), (const void *)(v5 + dword_10189834 + 724), 0x74u);
        ++v3;
        *(_WORD *)(v6 + 2) = *(_WORD *)(v5 + dword_10189834 + 710);
      }
      while ( v3 < a3 );
    }
    sub_10018280(97);
  }
  return v3;
}
// 10189834: using guessed type int dword_10189834;

//----- (100209E0) --------------------------------------------------------
char __cdecl sub_100209E0(unsigned __int8 a1, __int16 a2, _DWORD *a3)
{
  int v3; // edx@4
  unsigned __int8 v4; // cl@4
  char result; // al@8
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 0;
  if ( (unsigned __int8)sub_10020900() )
  {
    if ( a1 < 0xB0u && !sub_100182A0(97, 100) )
    {
      v3 = dword_10189834 + 4 * a1;
      v4 = 0;
      while ( v4 < *(_BYTE *)(dword_10189834 + 4 * a1) )
      {
        if ( *(_WORD *)(dword_10189834 + 136 * (v4 + *(_WORD *)(v3 + 2)) + 710) == a2 )
        {
          *a3 = *(_DWORD *)(136 * (v4 + *(_WORD *)(v3 + 2)) + dword_10189834 + 716);
          v6 = 1;
          break;
        }
        if ( ++v4 >= 0x78u )
        {
          sub_10018280(97);
          return 0;
        }
      }
      sub_10018280(97);
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10189834: using guessed type int dword_10189834;

//----- (10020AA0) --------------------------------------------------------
int __cdecl sub_10020AA0(int *a1)
{
  int result; // eax@1

  result = sub_1003C450((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_100181D0();
    result = sub_1003C290();
  }
  return result;
}

//----- (10020AD0) --------------------------------------------------------
char __usercall sub_10020AD0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_100182A0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1002A000("%i %i\r\n", 13, v2);
    sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1009A870, (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10018280(*(_DWORD *)(a1 + 4));
    v6 = sub_1002A000("%i %i\r\n", 14, v5);
    sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1009A86C, (int)v6);
    result = 1;
  }
  else
  {
    sub_10018A40(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10020B70) --------------------------------------------------------
int __cdecl sub_10020B70(const char *a1)
{
  int result; // eax@1

  result = sub_1003A5B0();
  if ( a1 )
    result = sub_1003C480(dword_10189838[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 10189838: using guessed type int dword_10189838[];

//----- (10020BB0) --------------------------------------------------------
char __cdecl sub_10020BB0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1003C3D0((char *)a1 + 4);
  v1 = sub_10018130();
  sub_1003C370((int)v1, 0, 0);
  dword_10189838[sub_1003A5B0()] = (int)a1;
  v2 = sub_1003D310((int)sub_10020B70);
  return sub_1002EBA0(v2);
}
// 10189838: using guessed type int dword_10189838[];

//----- (10020C00) --------------------------------------------------------
signed int __cdecl sub_10020C00(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_100181D0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10018380(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_100181D0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10018410(&v23);
          }
          while ( sub_100181D0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100181B0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_100181F0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1002A000("The %s task is loaded.", &v24);
            sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1002A000("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1002A000("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1002A000(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10018140(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1002A000("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1002A000("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1002F1B0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1002F1B0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10018230(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1003D310((int)sub_10020B70);
        sub_1002F280((int)v15);
        v16 = sub_1003E6E0((int)sub_10020B70);
        sub_1002F280((int)v16);
        v17 = sub_1003E6E0((int)sub_10020B70);
        sub_1002EBA0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1003D310((int)sub_10020B70);
        sub_1002F280((int)v18);
        v19 = sub_1003E6E0((int)sub_10020B70);
        sub_1002F280((int)v19);
        v20 = sub_1003D310((int)sub_10020B70);
        sub_1002EBA0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10020AD0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10020FA0) --------------------------------------------------------
char **sub_10020FA0()
{
  return off_1009A858;
}
// 1009A858: using guessed type char *off_1009A858[3];

//----- (10020FB0) --------------------------------------------------------
#error "10020FB5: call analysis failed (funcsize=28)"

//----- (10020FE0) --------------------------------------------------------
char __cdecl sub_10020FE0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1001FD20(13, (char *)&v3 + 3);
  sub_1001FD20(12, a1);
  return BYTE3(v3);
}

//----- (10021010) --------------------------------------------------------
char __cdecl sub_10021010(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1001E7B0((_DWORD *)a2, 2u, (int)&unk_1009B460, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_1009B464[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10018330(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10018160();
        sub_1001F8F0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10018A40("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 1009B464: using guessed type int dword_1009B464[];

//----- (10021130) --------------------------------------------------------
char __cdecl sub_10021130(int a1)
{
  return sub_10021010(34, a1);
}

//----- (10021140) --------------------------------------------------------
char __cdecl sub_10021140(int a1)
{
  return sub_10021010(28, a1);
}

//----- (10021150) --------------------------------------------------------
char __cdecl sub_10021150(int a1)
{
  return sub_10021010(29, a1);
}

//----- (10021160) --------------------------------------------------------
char __cdecl sub_10021160(int a1)
{
  return sub_10021010(30, a1);
}

//----- (10021170) --------------------------------------------------------
char __cdecl sub_10021170(int a1)
{
  return sub_10021010(32, a1);
}

//----- (10021180) --------------------------------------------------------
char __cdecl sub_10021180(int a1)
{
  return sub_10021010(31, a1);
}

//----- (10021190) --------------------------------------------------------
signed int __cdecl sub_10021190(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1009B7F8;
    v6 = &unk_1009B7F8;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_1009B810;
    v6 = &unk_1009B810;
    v5 = &a1;
  }
  v3 = sub_1001E7B0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (100211F0) --------------------------------------------------------
int __cdecl sub_100211F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_1009B848, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009B84C[2 * v1];
  return result;
}
// 1009B84C: using guessed type int dword_1009B84C[];

//----- (10021230) --------------------------------------------------------
int __cdecl sub_10021230(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_1009B858, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009B85C[2 * v1];
  return result;
}
// 1009B85C: using guessed type int dword_1009B85C[];

//----- (10021270) --------------------------------------------------------
signed int __cdecl sub_10021270(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_1009B868;
    v7 = &unk_1009B868;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_1009B880;
    v7 = &unk_1009B880;
    v6 = &a1;
  }
  v4 = sub_1001E7B0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100212E0) --------------------------------------------------------
int __cdecl sub_100212E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_1009B898, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1009B89C[2 * v1];
  return result;
}
// 1009B89C: using guessed type int dword_1009B89C[];

//----- (10021320) --------------------------------------------------------
int __cdecl sub_10021320(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_1009B8B0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009B8B4[2 * v1];
  return result;
}
// 1009B8B4: using guessed type int dword_1009B8B4[];

//----- (10021360) --------------------------------------------------------
char __cdecl sub_10021360(int a1, int a2)
{
  return sub_100185C0(a1 + 37000, a2, 284);
}

//----- (10021380) --------------------------------------------------------
char __cdecl sub_10021380(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10021190(a1, 11);
  return sub_100185C0(v2, a2, 24);
}

//----- (100213A0) --------------------------------------------------------
int __cdecl sub_100213A0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100211F0(a1);
  return sub_10018540(v2, a2, 160);
}

//----- (100213D0) --------------------------------------------------------
char __cdecl sub_100213D0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10021230(a1);
  return sub_100185C0(v2, a2, 2720);
}

//----- (10021400) --------------------------------------------------------
char __cdecl sub_10021400(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10021270(a1, 11, 1);
  sub_100185C0(v2, a2, 36);
  v3 = sub_10021270(a1, 11, 0);
  return sub_100185C0(v3, a2 + 36, 32);
}

//----- (10021450) --------------------------------------------------------
char __cdecl sub_10021450(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100212E0(a1);
  return sub_100185C0(v2, a2, 2192);
}

//----- (10021480) --------------------------------------------------------
char __cdecl sub_10021480(int a1)
{
  return sub_100185C0(6005, a1, 4);
}

//----- (100214A0) --------------------------------------------------------
char __cdecl sub_100214A0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10021320(a1);
  return sub_100185C0(v2, a2, 60);
}

//----- (100214C0) --------------------------------------------------------
char __cdecl sub_100214C0(int a1)
{
  return sub_100185C0(6453, a1, 5);
}

//----- (100214E0) --------------------------------------------------------
char __cdecl sub_100214E0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_1000F100(2, 363, a1);
}

//----- (10021500) --------------------------------------------------------
char __cdecl sub_10021500(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10018540(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10021650) --------------------------------------------------------
char __cdecl sub_10021650(int a1, unsigned int *a2)
{
  char v2; // bl@1

  memset(&unk_10189850, 0, 0x34D0u);
  v2 = sub_10021500(&unk_10189850);
  if ( v2 )
    *a2 = sub_1004C560((unsigned int *)&unk_10189850, 13520, 0xFFFFFFFF);
  return v2;
}

//----- (100216A0) --------------------------------------------------------
bool __thiscall sub_100216A0(void *this)
{
  return (sub_1001FDC0(this) & 0x8000) == 0x8000;
}

//----- (100216C0) --------------------------------------------------------
char __cdecl sub_100216C0(unsigned __int8 a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-208h]@1
  char v3[453]; // [sp+3Fh] [bp-1C9h]@2

  if ( sub_10018540(6444, (int)&v2, 514) == 0 )
    result = v3[a1];
  else
    result = 0;
  return result;
}
// 100216C0: using guessed type char var_1C9[453];

//----- (10021730) --------------------------------------------------------
char __cdecl sub_10021730(char *a1, size_t a2)
{
  signed int v2; // eax@8
  char *v4; // [sp-4h] [bp-210h]@2
  char v5; // [sp+4h] [bp-208h]@1
  char v6; // [sp+43h] [bp-1C9h]@3
  char v7; // [sp+44h] [bp-1C8h]@4
  char v8; // [sp+45h] [bp-1C7h]@5
  char v9; // [sp+46h] [bp-1C6h]@8
  char v10; // [sp+49h] [bp-1C3h]@10
  char v11; // [sp+4Ah] [bp-1C2h]@31
  char v12; // [sp+4Bh] [bp-1C1h]@32
  char v13; // [sp+5Ch] [bp-1B0h]@13
  char v14; // [sp+5Dh] [bp-1AFh]@16
  char v15; // [sp+5Eh] [bp-1AEh]@12
  char v16; // [sp+6Ah] [bp-1A2h]@15
  char v17; // [sp+76h] [bp-196h]@33
  char v18; // [sp+8Ah] [bp-182h]@37
  char v19; // [sp+9Eh] [bp-16Eh]@39

  if ( sub_10018540(6444, (int)&v5, 514) )
  {
    v4 = "Could not verify GDL59 config, config data could not be read";
LABEL_43:
    sub_1001F8F0(a1, a2, v4);
    return 0;
  }
  if ( v6 )
  {
    if ( !v7 )
      goto LABEL_24;
  }
  else if ( v7 == v6 )
  {
    if ( v8 == v6 )
    {
      sub_1001F8F0(a1, a2, "Invalid function settings for GDL59; no major feature (reports, voice, wi-fi) was enabled");
      return 0;
    }
    goto LABEL_31;
  }
  v2 = 0;
  if ( v9 )
    v2 = 1;
  if ( v10 )
    ++v2;
  if ( v15 && v13 & 1 )
    ++v2;
  if ( v16 && v14 & 1 )
    ++v2;
  if ( v2 < 2 )
  {
    sub_1001F8F0(a1, a2, "Invalid function setting for GDL59 voice feature; need at least two phones configured");
    return 0;
  }
  if ( v2 == 2 && !v9 && !v10 )
  {
    v4 = "Invalid function setting for GDL59 voice feature; must have an internal phone";
    goto LABEL_43;
  }
LABEL_24:
  if ( v6 )
  {
    if ( !v8 )
    {
      if ( (!v15 || !(v13 & 2)) && (!v16 || !(v14 & 2)) )
      {
        sub_1001F8F0(
          a1,
          a2,
          "Invalid function setting for GDL59 data logging feature; need at least one data tx available");
        return 0;
      }
      if ( v12 )
      {
        sub_1001F8F0(a1, a2, "Invalid function setting for Wi-Fi PC data transfer; Wi-Fi is not enabled");
        return 0;
      }
    }
    goto LABEL_33;
  }
LABEL_31:
  if ( v11 || v12 )
  {
    v4 = "Invalid function setting for PC data transfer; data logging feature is not enabled";
    goto LABEL_43;
  }
LABEL_33:
  if ( sub_1003EB70(&v17, 20, 20, 0) )
  {
    if ( !sub_1003EB70(&v18, 20, 20, 0) )
    {
      v4 = "Invalid direct number for Iridium";
      goto LABEL_43;
    }
    if ( sub_1003EB70(&v19, 20, 20, 0) )
      return 1;
    sub_1001F8F0(a1, a2, "Invalid direct number for SMS service number");
  }
  else
  {
    sub_1001F8F0(a1, a2, "Invalid RUDICS number for Iridium");
  }
  return 0;
}

//----- (10021930) --------------------------------------------------------
char __cdecl sub_10021930(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10021500(a5);
      else
        result = sub_100214E0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10021500(&unk_10189850);
      else
        v7 = sub_100214E0(&unk_10189850);
      v8 = v7;
      memcpy(a5, (char *)&unk_10189850 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10021500(&unk_10189850);
      else
        v9 = sub_100214E0(&unk_10189850);
      v10 = v9;
      memcpy(a5, (char *)&unk_1018C758 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10021500(&unk_10189850);
      else
        v11 = sub_100214E0(&unk_10189850);
      v12 = v11;
      memcpy(a5, (char *)&unk_1018CC58 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10021500(&unk_10189850);
      else
        v13 = sub_100214E0(&unk_10189850);
      v14 = v13;
      memcpy(a5, &unk_1018CD00, a6);
      result = v14;
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021AD0) --------------------------------------------------------
char __cdecl sub_10021AD0(int a1, unsigned int *a2)
{
  int v2; // ecx@0
  char result; // al@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( j_HWM_pvg_read_reg(1) != 1 || j_HWM_pvg_hsdb_get_lrus_online() & 0x8000 )
  {
    result = sub_1000F100(2, 364, &v4);
    if ( result )
      *a2 = v4;
  }
  else
  {
    result = sub_10021650(31, a2);
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10021B20) --------------------------------------------------------
int __cdecl sub_10021B20(char a1)
{
  return sub_1001E7B0(&a1, 1u, (int)byte_1009CA10, 8, 2, 2);
}

//----- (10021B40) --------------------------------------------------------
char __cdecl sub_10021B40(unsigned __int8 a1)
{
  char result; // al@1

  result = 67;
  if ( a1 < 2u )
    result = byte_1009CA10[8 * a1];
  return result;
}

//----- (10021B60) --------------------------------------------------------
BOOL __cdecl sub_10021B60(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10003B50(a1);
  return sub_1000F100(0, 604, a2) && sub_1000E940(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10021BC0) --------------------------------------------------------
int __usercall sub_10021BC0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10021B20(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_1009CA14[2 * v1];
  return result;
}
// 1009CA14: using guessed type int dword_1009CA14[];

//----- (10021BF0) --------------------------------------------------------
BOOL __cdecl sub_10021BF0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10021BC0(a1);
  return sub_10018540(v2, a2, 16) == 0;
}

//----- (10021C20) --------------------------------------------------------
char __cdecl sub_10021C20(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10021BC0(a1);
  return sub_10018730(v2, a2, 16);
}

//----- (10021C40) --------------------------------------------------------
int __cdecl sub_10021C40(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10021BF0(a1, (int)a5);
  else
    result = sub_10021B60(a1, a5);
  return result;
}

//----- (10021C70) --------------------------------------------------------
char __cdecl sub_10021C70(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_1000F130(1, 1947, a1, (int)&v3);
}

//----- (10021C90) --------------------------------------------------------
BOOL __cdecl sub_10021C90(int a1)
{
  return sub_10018540(6792, a1, 284) == 0;
}

//----- (10021CB0) --------------------------------------------------------
char __cdecl sub_10021CB0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_10021C90((int)a5);
  else
    result = sub_10021C70(a5);
  return result;
}

//----- (10021CE0) --------------------------------------------------------
bool __cdecl sub_10021CE0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1001E7B0(&a2, 4u, (int)&dword_1009D888, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10018540((unsigned __int16)word_1009D88C[a1 + 6 * v3], a3, (unsigned __int16)word_1009D890[6 * v3]) == 0;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 1009D888: using guessed type int dword_1009D888;
// 1009D88C: using guessed type __int16 word_1009D88C[];
// 1009D890: using guessed type __int16 word_1009D890[];

//----- (10021D70) --------------------------------------------------------
bool __cdecl sub_10021D70(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_1001E7B0(&a1, 1u, (int)&unk_1009D8C4, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_1000F100(0, (unsigned __int16)word_1009D8C6[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_1009D8D4[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 1009D8C6: using guessed type __int16 word_1009D8C6[];
// 1009D8D4: using guessed type int dword_1009D8D4[];

//----- (10021DF0) --------------------------------------------------------
bool __cdecl sub_10021DF0(unsigned __int8 a1, int a2, _DWORD *a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  bool result; // al@5

  v3 = sub_1001E7B0(&a2, 4u, (int)&dword_1009D888, 12, 3, 3);
  v4 = (int)a3;
  if ( (unsigned int)a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    *a3 = a2;
    result = sub_10018690((unsigned __int16)word_1009D88C[a1 + 6 * v3], v4, (unsigned __int16)word_1009D890[6 * v3]) == 0;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 536, 0, 0);
    result = 0;
  }
  return result;
}
// 1009D888: using guessed type int dword_1009D888;
// 1009D88C: using guessed type __int16 word_1009D88C[];
// 1009D890: using guessed type __int16 word_1009D890[];

//----- (10021E80) --------------------------------------------------------
char __usercall sub_10021E80@<al>(void *a1@<eax>, int a2)
{
  sub_1000EA90(0, 417, a1, 0, 20, 1);
  return sub_1000ED50(0, 417, a2);
}

//----- (10021EB0) --------------------------------------------------------
bool __cdecl sub_10021EB0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10025E60(a1);
  v6 = sub_1001E7B0(&a3, 1u, (int)&unk_1009D8AC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1001E7B0(&dword_1009D8B0[2 * v6], 4u, (int)&dword_1009D888, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_1009D890[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10021CE0(v11, *(int *)((char *)&dword_1009D888 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009D888: using guessed type int dword_1009D888;
// 1009D890: using guessed type __int16 word_1009D890[];

//----- (10021F50) --------------------------------------------------------
char __cdecl sub_10021F50(int a1, char a2, void *a3)
{
  void *v3; // esi@1
  int v4; // eax@1
  __int16 v5; // cx@3
  void *v6; // ecx@7
  signed int v7; // esi@9
  int v9; // [sp+4h] [bp-18h]@5
  int v10; // [sp+8h] [bp-14h]@5
  int v11; // [sp+Ch] [bp-10h]@5
  int v12; // [sp+10h] [bp-Ch]@5
  int v13; // [sp+14h] [bp-8h]@5

  v3 = a3;
  v4 = sub_1001E7B0(&a2, 1u, (int)&unk_1009D8E0, 4, 9, -1);
  if ( v4 >= 0 && (unsigned __int8)a1 <= 2u )
  {
    v5 = word_1009D8E2[2 * v4];
    if ( !v5 || v3 )
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      BYTE1(v9) = 45;
      BYTE2(v9) = a2;
      LOBYTE(v9) = a1;
      LOWORD(v10) = v5;
      if ( v5 )
        memcpy(&v11, v3, (unsigned __int16)v5);
      sub_10021E80(&v9, 0xFFFFFFF);
      LOBYTE(v4) = sub_1001FDE0(v6);
      if ( (_BYTE)v4 == 4 )
      {
        if ( (unsigned __int8)a1 < 2u )
        {
          LOBYTE(v4) = sub_1001C420(a1, (int)&v9);
        }
        else
        {
          v7 = 0;
          do
          {
            LOBYTE(v4) = sub_1001C2F0(v7);
            if ( (_BYTE)v4 )
              LOBYTE(v4) = sub_1001C420(v7, (int)&v9);
            ++v7;
          }
          while ( v7 < 2 );
        }
      }
    }
  }
  return v4;
}
// 1009D8E2: using guessed type __int16 word_1009D8E2[];

//----- (10022070) --------------------------------------------------------
bool __cdecl sub_10022070(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10018540((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (100220B0) --------------------------------------------------------
signed int __usercall sub_100220B0@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (100220D0) --------------------------------------------------------
bool __cdecl sub_100220D0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_100220B0(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_1000E940(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_1000F130(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10022070(a1, a2);
  }
  else
  {
    v9 = sub_100206D0(v4);
    v8 = 1708;
    sub_1000EA90(1, 0, &v8, 0, 8, 1);
    sub_1000ED50(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100221C0) --------------------------------------------------------
bool __cdecl sub_100221C0(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10022070(a1, a5);
  else
    result = sub_100220D0(a1, a5);
  return result;
}

//----- (100221F0) --------------------------------------------------------
BOOL __cdecl sub_100221F0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10022200) --------------------------------------------------------
BOOL __usercall sub_10022200@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_100221F0(a1) && *v2 < 3u && a2 == 24;
}

//----- (10022230) --------------------------------------------------------
bool __cdecl sub_10022230(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_100221F0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10025410((unsigned __int8)byte_1009ECC8[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_1000F100(1, (unsigned __int16)word_1009ECC0[v6], &Tm.tm_mon) || sub_10038D40((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1003ECC0(a1, &v15) || v15 != dword_1009ECE0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_1000F100(1, (unsigned __int16)word_1009ECC4[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 1009ECC0: using guessed type __int16 word_1009ECC0[];
// 1009ECC4: using guessed type __int16 word_1009ECC4[];
// 1009ECE0: using guessed type int dword_1009ECE0[];

//----- (100223E0) --------------------------------------------------------
bool __cdecl sub_100223E0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_100221F0(a1) )
    result = sub_10018540((unsigned __int16)word_1009ECCA[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1009ECCA: using guessed type __int16 word_1009ECCA[];

//----- (10022420) --------------------------------------------------------
bool __cdecl sub_10022420(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1003EC10(a1);
  if ( !(unsigned __int8)sub_10022200(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10022230(v9, a3, *a4, (int)a5);
  if ( sub_10025410((unsigned __int8)byte_1009ECC8[20 * v6], (bool *)&v8) && v8 && sub_100223E0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10022420: using guessed type int var_20[7];

//----- (10022510) --------------------------------------------------------
bool __thiscall sub_10022510(void *this)
{
  return (sub_1001FDC0(this) & 0x4000) == 0x4000;
}

//----- (10022530) --------------------------------------------------------
char sub_10022530()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_1000F100(1, 1309, &v1) )
    sub_10038E80((int)&v1);
  return 0;
}

//----- (100225D0) --------------------------------------------------------
BOOL __cdecl sub_100225D0(int a1, int a2)
{
  return sub_10018540(6455, a2, 252) == 0;
}

//----- (100225F0) --------------------------------------------------------
char __cdecl sub_100225F0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_100225D0(a1, a5);
  }
  else
  {
    result = sub_10022530();
  }
  return result;
}

//----- (10022630) --------------------------------------------------------
char __cdecl sub_10022630(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1018F5B0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10021450(a1, (int)byte_1018F5B0);
    v3 = 4 * a2 - 64;
    v4 = byte_1018F5B1[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1018F5B0[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (100226D0) --------------------------------------------------------
bool __cdecl sub_100226D0(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1018F5B0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10021450(a1, (int)byte_1018F5B0);
    v3 = (char *)&unk_1018F650 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10022750) --------------------------------------------------------
char __cdecl sub_10022750(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1018F5B0, 0, 0x890u);
  sub_10021450(a1, (int)byte_1018F5B0);
  if ( a2 > 0x10u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_1018F920[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1018F924[2 * a2];
    result = 1;
  }
  return result;
}
// 1018F920: using guessed type int dword_1018F920[];
// 1018F924: using guessed type int dword_1018F924[];

//----- (100227C0) --------------------------------------------------------
char __cdecl sub_100227C0(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1000F100(0, 223, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1000F100(0, 568, a2);
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 585, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1000F100(0, 218, a2);
  }
  return result;
}

//----- (10022840) --------------------------------------------------------
char __cdecl sub_10022840(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1000F100(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1000F100(0, 572, a2);
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1000F100(0, 226, a2);
  }
  return result;
}

//----- (100228C0) --------------------------------------------------------
char __cdecl sub_100228C0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1018F5B0, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10022840(a1, byte_1018F5B0);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1018F5B1[v4];
    *(_BYTE *)a3 = byte_1018F5B0[v4];
  }
  return result;
}

//----- (10022940) --------------------------------------------------------
char __cdecl sub_10022940(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1018F5B0, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10022840(a1, byte_1018F5B0);
    v4 = (char *)&unk_1018F650 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (100229C0) --------------------------------------------------------
char __cdecl sub_100229C0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1018F5B0, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10022840(a1, byte_1018F5B0);
    *(_DWORD *)a3 = dword_1018F920[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1018F924[2 * a2];
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 1018F920: using guessed type int dword_1018F920[];
// 1018F924: using guessed type int dword_1018F924[];

//----- (10022A30) --------------------------------------------------------
char __cdecl sub_10022A30(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10025830(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10022750(v6, *a4, a5);
    else
      result = sub_100229C0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_10022630(v6, *a4, a5);
    else
      result = sub_100228C0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_100226D0(v6, *a4, a5);
    else
      result = sub_10022940(v6, *a4, a5);
  }
  return result;
}

//----- (10022B40) --------------------------------------------------------
char __cdecl sub_10022B40(char a1, void *a2)
{
  return sub_1000F100(6, (unsigned __int16)word_100A0672[8 * (unsigned __int8)a1], a2);
}
// 100A0672: using guessed type __int16 word_100A0672[];

//----- (10022B60) --------------------------------------------------------
bool __cdecl sub_10022B60(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10018540(dword_100A0678[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100A0678: using guessed type int dword_100A0678[];

//----- (10022BA0) --------------------------------------------------------
char __cdecl sub_10022BA0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10025E20(a1);
  if ( a2 )
    result = sub_10022B60(v6, (char *)a5);
  else
    result = sub_10022B40(v6, a5);
  return result;
}

//----- (10022BE0) --------------------------------------------------------
BOOL sub_10022BE0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10025350(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10022C40) --------------------------------------------------------
char __cdecl sub_10022C40(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_1000F100(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10022BE0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_100388A0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10022D30) --------------------------------------------------------
BOOL __cdecl sub_10022D30(int a1, int a2)
{
  return sub_10018540(6200, a2, 60) == 0;
}

//----- (10022D50) --------------------------------------------------------
char __cdecl sub_10022D50(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10022D30(a1, (int)a5);
  }
  else
  {
    result = sub_10022C40(a1, a5);
  }
  return result;
}

//----- (10022D90) --------------------------------------------------------
char __cdecl sub_10022D90(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_1000F100(2, 284, &v6) || sub_10038AA0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10022E40) --------------------------------------------------------
BOOL __cdecl sub_10022E40(int a1, int a2)
{
  return sub_10018540(6169, a2, 40) == 0;
}

//----- (10022E60) --------------------------------------------------------
char __cdecl sub_10022E60(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10022E40(a1, a5);
  }
  else
  {
    result = sub_10022D90(a1, a5);
  }
  return result;
}

//----- (10022EA0) --------------------------------------------------------
bool __cdecl sub_10022EA0(unsigned __int8 a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-40Ch]@1
  char v3; // [sp+8h] [bp-408h]@2
  int v4; // [sp+408h] [bp-8h]@2

  if ( sub_100209E0(a1, 67, &v2) )
  {
    sub_10018640(6943, (int)&v3, 1028);
    result = v2 == v4;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10022F30) --------------------------------------------------------
char __cdecl sub_10022F30(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10024DD0(a1, &v5, &v4) && sub_1000E680(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10018640(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10022F30: using guessed type char var_408[1028];

//----- (10022FD0) --------------------------------------------------------
char __cdecl sub_10022FD0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10024B60(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10007590(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10007610(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10007690(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10007710(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (100230E0) --------------------------------------------------------
int __cdecl sub_100230E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_100A2B88, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A2B8C[2 * v1];
  }
  return result;
}
// 100A2B8C: using guessed type int dword_100A2B8C[];

//----- (10023130) --------------------------------------------------------
char __cdecl sub_10023130(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_100214A0(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10018540(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_100214C0((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (100232A0) --------------------------------------------------------
int __usercall sub_100232A0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10023130(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 100232A0: using guessed type int var_2C[10];

//----- (100232E0) --------------------------------------------------------
int __usercall sub_100232E0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10023130(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 100232E0: using guessed type int var_14[4];

//----- (10023320) --------------------------------------------------------
signed int sub_10023320()
{
  return sub_10018EB0((int)&off_100A3A38);
}
// 100A3A38: using guessed type char *off_100A3A38;

//----- (10023330) --------------------------------------------------------
char __cdecl sub_10023330(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_10023320() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10223504 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10223504 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_10223504);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10223504: using guessed type int dword_10223504;

//----- (10023390) --------------------------------------------------------
char __cdecl sub_10023390(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_10023320() )
  {
    if ( (sub_1001C340(a1)
       || *(_BYTE *)(dword_10223504 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_10223504 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_10223504 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 176))
      && *(_BYTE *)(dword_10223504 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_10223504 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10223504 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_10223504 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10223504: using guessed type int dword_10223504;

//----- (100234B0) --------------------------------------------------------
char __cdecl sub_100234B0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_10023320() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_10223504 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10223504 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10223504 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_10223504 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_10223504);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10223504: using guessed type int dword_10223504;

//----- (10023530) --------------------------------------------------------
char __cdecl sub_10023530(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_100232E0(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_100234B0(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_100232A0(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10023330(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10023130(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10023390(v6, a5);
        }
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100236E0) --------------------------------------------------------
char __cdecl sub_100236E0(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10018A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_1000F130(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_1000F130(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100392A0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1018FE48, (char *)&v6 + 1, 0x20u);
      byte_1018FE40 = 1;
      byte_1018FE41 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1018FE68, (char *)&v6 + 1, 0x20u);
    byte_1018FE41 = 1;
    byte_1018FE42 = 1;
    return result;
  }
  return 0;
}
// 1018FE40: using guessed type char byte_1018FE40;
// 1018FE41: using guessed type char byte_1018FE41;
// 1018FE42: using guessed type char byte_1018FE42;

//----- (10023810) --------------------------------------------------------
char __cdecl sub_10023810(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10021400(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10018A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10023890) --------------------------------------------------------
bool __cdecl sub_10023890(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1018FE40 == 0;
    qmemcpy(a1, &unk_1018FE48, 0x40u);
    result = !v1 && byte_1018FE42;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1018FE40: using guessed type char byte_1018FE40;
// 1018FE42: using guessed type char byte_1018FE42;

//----- (100238E0) --------------------------------------------------------
char __cdecl sub_100238E0(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10018A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1001DFD0(15);
    v3 = 555;
  }
  else
  {
    result = sub_1001DFD0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1018FE41 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_1000EA90(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1018FE41: using guessed type char byte_1018FE41;

//----- (100239C0) --------------------------------------------------------
__int16 __usercall sub_100239C0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100A3B58[a1];
}
// 100A3B58: using guessed type __int16 word_100A3B58[];

//----- (100239D0) --------------------------------------------------------
char __cdecl sub_100239D0(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  unsigned int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_100239C0(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_1000EA90(1, v3, &v5, 1, (v5 >> 16) + 4, 1);
  return sub_1000ED50(1, v3, 0xFFFFFFF);
}

//----- (10023A60) --------------------------------------------------------
char __cdecl sub_10023A60(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1018FE41 != 0 ? 25 : 11;
      sub_100239D0(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_100239D0(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1018FE41: using guessed type char byte_1018FE41;

//----- (10023B20) --------------------------------------------------------
bool __cdecl sub_10023B20(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10023810(a1, (int)a5);
    return 1;
  }
  if ( byte_1018FE41 )
  {
    if ( sub_100236E0(a1, &v6, 1) )
    {
LABEL_14:
      byte_1018FE43 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1018FE43 >= 5u )
    {
      byte_1018FE40 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_100236E0(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1018FE43 >= 5u )
    {
      byte_1018FE42 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10023810(a1, (int)&v6);
    sub_100238E0(a1, (int)&v6);
  }
  sub_10023A60(a1, 11);
  return sub_10023890(a5);
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1018FE40: using guessed type char byte_1018FE40;
// 1018FE41: using guessed type char byte_1018FE41;
// 1018FE42: using guessed type char byte_1018FE42;
// 1018FE43: using guessed type char byte_1018FE43;

//----- (10023C20) --------------------------------------------------------
char __thiscall sub_10023C20(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_1018FE88 = sub_1001FDE0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1018FE90, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_1018FE90;
  do
  {
    result = sub_100213D0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 1018FE88: using guessed type int dword_1018FE88;

//----- (10023C90) --------------------------------------------------------
char __usercall sub_10023C90@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_1000F0D0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_1000F0D0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10023CD0) --------------------------------------------------------
void *__usercall sub_10023CD0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_1018FE88 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10018480(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_1018FE90 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_100213D0(a1, (int)&unk_1018FE90 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_1018FE90 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_1018FE88 != 1379255385 )
    result = (void *)sub_10018450(v4, 86);
  return result;
}
// 1018FE88: using guessed type int dword_1018FE88;

//----- (10023D70) --------------------------------------------------------
char __cdecl sub_10023D70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10023C90(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10023DB0) --------------------------------------------------------
bool __cdecl sub_10023DB0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10023CD0(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10023E10) --------------------------------------------------------
char __cdecl sub_10023E10(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10023C90(a2, 1, a3, a1);
  return result;
}

//----- (10023E50) --------------------------------------------------------
char __cdecl sub_10023E50(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10023CD0(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10023E80) --------------------------------------------------------
char __cdecl sub_10023E80(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10023C90(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10023EC0) --------------------------------------------------------
char __cdecl sub_10023EC0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10023CD0(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10023F00) --------------------------------------------------------
char __cdecl sub_10023F00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10023C90(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10023F40) --------------------------------------------------------
bool __cdecl sub_10023F40(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10023CD0(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10023F90) --------------------------------------------------------
char __cdecl sub_10023F90(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10023C90(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10023FD0) --------------------------------------------------------
bool __cdecl sub_10023FD0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10023CD0(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10024010) --------------------------------------------------------
char __cdecl sub_10024010(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10023C90(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10024050) --------------------------------------------------------
bool __cdecl sub_10024050(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10023CD0(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10024090) --------------------------------------------------------
char __cdecl sub_10024090(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10023C90(1229, 1, a2, a1);
  return result;
}

//----- (100240C0) --------------------------------------------------------
char __cdecl sub_100240C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023CD0(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (100240F0) --------------------------------------------------------
char __cdecl sub_100240F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10023C90(1212, 16, a2, a1);
  return result;
}

//----- (10024120) --------------------------------------------------------
char __cdecl sub_10024120(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023CD0(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10024150) --------------------------------------------------------
char __cdecl sub_10024150(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10023C90(2400, 65, a2, a1);
  return result;
}

//----- (10024180) --------------------------------------------------------
char __cdecl sub_10024180(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023CD0(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100241B0) --------------------------------------------------------
char __cdecl sub_100241B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10023C90(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (100241F0) --------------------------------------------------------
char __cdecl sub_100241F0(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10023CD0(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10024240) --------------------------------------------------------
char __cdecl sub_10024240(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10023C90(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10024280) --------------------------------------------------------
char __cdecl sub_10024280(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10023CD0(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (100242B0) --------------------------------------------------------
char __cdecl sub_100242B0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10023C90(22, 1, a2, a1);
  return result;
}

//----- (100242E0) --------------------------------------------------------
char __cdecl sub_100242E0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10023C90(832, 4, a2, a1);
  return result;
}

//----- (10024310) --------------------------------------------------------
char __cdecl sub_10024310(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023CD0(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10024340) --------------------------------------------------------
char __cdecl sub_10024340(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10039450(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_100241F0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_100241B0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10024280(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10024240(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10023DB0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023D70(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10023FD0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023F90(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10024050(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10024010(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10023E50(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023E10(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10023EC0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023E80(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_100242B0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10024120(v6, a5);
        else
          result = sub_100240F0(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10023F40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023F00(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10024180(v6, a5);
        else
          result = sub_10024150(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100240C0(v6, a5);
        else
          result = sub_10024090(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10024310(v6, a5);
        else
          result = sub_100242E0(v6, a5);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100246E0) --------------------------------------------------------
bool __cdecl sub_100246E0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_101913D0 != 1379255385 )
    {
      sub_10021380(a1, (int)&byte_101913D8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_101913DD[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101913DC[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 101913D0: using guessed type int dword_101913D0;

//----- (10024750) --------------------------------------------------------
bool __cdecl sub_10024750(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_101913D0 != 1379255385 )
      sub_10021380(a1, (int)&byte_101913D8[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_101913EC[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101913D0: using guessed type int dword_101913D0;
// 101913EC: using guessed type int dword_101913EC[];

//----- (100247B0) --------------------------------------------------------
bool __cdecl sub_100247B0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_101913D0 != 1379255385 )
    {
      sub_10021380(a1, (int)&byte_101913D8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_101913E4[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 101913D0: using guessed type int dword_101913D0;
// 101913E4: using guessed type int dword_101913E4[];

//----- (10024820) --------------------------------------------------------
char __cdecl sub_10024820(char a1, _BYTE *a2)
{
  if ( dword_101913D0 != 1379255385 )
    sub_10021380(a1, (int)&byte_101913D8[24 * (unsigned __int8)a1]);
  *a2 = byte_101913D8[24 * (unsigned __int8)a1];
  return 1;
}
// 101913D0: using guessed type int dword_101913D0;

//----- (10024860) --------------------------------------------------------
char __thiscall sub_10024860(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101913D0 = sub_1001FDE0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_101913D8, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_101913D8;
  do
  {
    result = sub_10021380(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 101913D0: using guessed type int dword_101913D0;

//----- (100248D0) --------------------------------------------------------
char __cdecl sub_100248D0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10020160(a1);
  v3 = sub_10019110(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10024900) --------------------------------------------------------
char __cdecl sub_10024900(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10020160(a1);
  v3 = sub_10019180(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10024930) --------------------------------------------------------
char __cdecl sub_10024930(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10020250(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_100247B0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_100246E0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10024750(v7, *a4, (int)a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10024820(v7, a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10024900(v7, (int)a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_100248D0(v7, (int)a5);
      }
      else
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10024B00) --------------------------------------------------------
int __cdecl sub_10024B00(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10024B20) --------------------------------------------------------
char *__cdecl sub_10024B20(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_100A425B;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_102234D5[(unsigned __int16)sub_10024B00(a1)];
  return result;
}
// 1004C534: using guessed type int TXT_get_static_string(void);

//----- (10024B60) --------------------------------------------------------
char __cdecl sub_10024B60(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10024C00) --------------------------------------------------------
char __cdecl sub_10024C00(unsigned __int8 a1)
{
  int v1; // esi@2
  char v2; // bl@2
  char result; // al@4

  if ( a1 >= 4u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 226, 0, 0);
    result = 67;
  }
  else
  {
    v1 = 3 * a1;
    v2 = 0;
    if ( sub_1001E000(byte_100A4B3E[v1]) )
      v2 = 1;
    result = *(&byte_100A4B3C[(unsigned __int8)v2] + v1);
  }
  return result;
}

//----- (10024C60) --------------------------------------------------------
char __cdecl sub_10024C60(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int8 *a4)
{
  char result; // al@1
  int v5; // edx@3
  unsigned __int8 v6; // cl@3

  result = 0;
  if ( a1 < 3u && a2 < 8u )
  {
    v5 = 44 * a1 + 5 * a2;
    v6 = a3 + byte_100A4285[v5];
    if ( v6 != -1 && v6 <= (unsigned __int8)byte_100A4286[v5] )
    {
      *a4 = v6;
      result = 1;
    }
  }
  return result;
}

//----- (10024CB0) --------------------------------------------------------
char __cdecl sub_10024CB0(unsigned __int8 a1, unsigned __int8 a2, char a3, unsigned __int8 *a4)
{
  char result; // al@1
  int v5; // edx@3
  unsigned __int8 v6; // cl@3

  result = 0;
  if ( a1 < 3u && a2 < 8u )
  {
    v5 = 44 * a1 + 5 * a2;
    v6 = a3 + byte_100A4287[v5];
    if ( v6 < 0xAEu && v6 <= (unsigned __int8)byte_100A4288[v5] )
    {
      *a4 = v6;
      result = 1;
    }
  }
  return result;
}

//----- (10024D00) --------------------------------------------------------
__int16 __cdecl sub_10024D00(char a1)
{
  int v1; // eax@1
  __int16 result; // ax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_100A4260, 4, 8, 8);
  if ( v1 == 8 )
    result = 0;
  else
    result = word_100A4262[2 * v1];
  return result;
}
// 100A4262: using guessed type __int16 word_100A4262[];

//----- (10024D40) --------------------------------------------------------
char __cdecl sub_10024D40(char a1, char a2, char *a3)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sprintf(a3, "%dA", (unsigned __int8)a2 + 1);
    }
    else if ( a1 == 2 )
    {
      result = sprintf(a3, "%dB", (unsigned __int8)a2 + 1);
    }
    else
    {
      sprintf(a3, &byte_10065A71);
      result = sub_10018A40("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 454, 0, 0);
    }
  }
  else
  {
    result = sprintf(a3, "%d", (unsigned __int8)a2 + 1);
  }
  return result;
}

//----- (10024DD0) --------------------------------------------------------
char __cdecl sub_10024DD0(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100A4B80[4 * a1];
    *a3 = word_100A4B82[2 * a1];
    result = 1;
  }
  else
  {
    sub_10018A40("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100A4B82: using guessed type __int16 word_100A4B82[];

//----- (10024E30) --------------------------------------------------------
char __cdecl sub_10024E30(char a1, __int16 a2, unsigned __int16 *a3)
{
  char result; // al@1
  int v4; // ecx@3
  unsigned __int16 v5; // si@5

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    while ( 1 )
    {
      v4 = 2 * *a3;
      if ( word_100A4B82[v4] == a2 && byte_100A4B80[v4 * 2] == a1 )
        break;
      v5 = *a3 + 1;
      *a3 = v5;
      if ( v5 >= 0x1D8u )
        return result;
    }
    result = 1;
  }
  return result;
}
// 100A4B82: using guessed type __int16 word_100A4B82[];

//----- (10024E90) --------------------------------------------------------
signed int __cdecl sub_10024E90(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10024EE0) --------------------------------------------------------
int __cdecl sub_10024EE0(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10024FD0) --------------------------------------------------------
unsigned int __cdecl sub_10024FD0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10025020) --------------------------------------------------------
unsigned int __cdecl sub_10025020(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100250E0) --------------------------------------------------------
unsigned int __cdecl sub_100250E0(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1001F880(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10025140) --------------------------------------------------------
int __cdecl sub_10025140(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10025190) --------------------------------------------------------
int __cdecl sub_10025190(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10025230) --------------------------------------------------------
int __cdecl sub_10025230(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100252E0) --------------------------------------------------------
int __cdecl sub_100252E0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10019620: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10025350) --------------------------------------------------------
bool __cdecl sub_10025350(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10020560(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100A5850[(unsigned __int8)v4](v3) )
    {
      sub_100252E0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_1003A420(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1000E330(2) )
    result = 0;
  else
    result = sub_1000F100(2, v5, a2) == 1 && !sub_1003EEF0(a2);
  return result;
}
// 100A5850: using guessed type int (__cdecl *off_100A5850[3])(char);

//----- (10025410) --------------------------------------------------------
char __cdecl sub_10025410(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10025350(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_1003A400(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (100254D0) --------------------------------------------------------
int __cdecl sub_100254D0(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 2u )
    result = dword_100A5870[a1];
  return result;
}
// 100A5870: using guessed type int dword_100A5870[];

//----- (100254F0) --------------------------------------------------------
int __cdecl sub_100254F0(char a1)
{
  return sub_1001E7B0(&a1, 4u, (int)dword_100A5870, 4, 2, 2);
}
// 100A5870: using guessed type int dword_100A5870[];

//----- (10025510) --------------------------------------------------------
bool __cdecl sub_10025510(unsigned __int8 a1)
{
  int v1; // esi@1
  void *v2; // ecx@1

  v1 = sub_100254D0(a1);
  return (v1 & sub_1001FDC0(v2)) == v1;
}

//----- (10025540) --------------------------------------------------------
char __cdecl sub_10025540(char a1, void *a2)
{
  char result; // al@3

  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  if ( a1 == 3 )
  {
    result = sub_1000F100(0, 170, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_1000F100(0, 171, a2);
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\iop_gs_intf.c", 123, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100255A0) --------------------------------------------------------
char __thiscall sub_100255A0(void *this)
{
  char v1; // bl@1
  char result; // al@3

  v1 = sub_1001D380((int)this);
  if ( !sub_1001D4B0() || v1 )
    result = v1;
  else
    result = *(_BYTE *)(dword_102234FC + 141);
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (100255D0) --------------------------------------------------------
char __cdecl sub_100255D0(int a1)
{
  char result; // al@7
  float v2; // [sp+Ch] [bp-5Ch]@1
  float v3; // [sp+10h] [bp-58h]@6
  char v4; // [sp+14h] [bp-54h]@1
  float v5; // [sp+20h] [bp-48h]@6
  float v6; // [sp+30h] [bp-38h]@7
  int v7; // [sp+50h] [bp-18h]@4

  sub_1003F0B0(a1, (int)&v4);
  if ( !sub_1001D950(&v2)
    || !sub_1001DA00()
    || sub_10019E80()
    || v7 == 0x3FFFF
    || !sub_1003EFA0(3, a1, (int)&v4)
    || (v3 = v2 - v5, v2 = sub_1004CBD0(v3), LODWORD(v2) &= 0x7FFFFFFFu, v2 < 1.867502331733704)
    || (result = 1, v6 <= 926.0) )
  {
    result = 0;
  }
  return result;
}

//----- (100256A0) --------------------------------------------------------
int __cdecl sub_100256A0(char a1, int a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  int result; // eax@1
  bool v6; // cl@1
  double v7; // st7@4
  int v8; // ecx@6
  int v9; // ecx@6
  int v10; // [sp+14h] [bp-18h]@1
  __int16 v11; // [sp+1Eh] [bp-Eh]@6

  v3 = sub_10029870(a1 + 3, &v10);
  result = sub_1001D3C0(v4);
  v6 = (v10 & 0x200) == 512;
  *(_BYTE *)(a2 + 1) = (v10 & 0x100) == 256;
  *(_BYTE *)(a2 + 3) = v6;
  if ( !v3 )
    *(_BYTE *)(a2 + 1) = 1;
  if ( *(_BYTE *)(a2 + 1) )
  {
    v7 = 0.0;
    *(_DWORD *)(a2 + 8) = 0;
LABEL_11:
    *(float *)(a2 + 4) = v7;
    *(_BYTE *)(a2 + 2) = 2;
    *a3 = 0;
    return result;
  }
  if ( !v6 )
  {
    result = v11 << 16;
    v7 = (double)((signed int)v11 << 16) * 0.000000001201706512077294;
    goto LABEL_11;
  }
  v8 = (v11 - 0x8000) << 16;
  *(_DWORD *)(a2 + 8) = v8;
  v9 = v8 - result;
  result = v9 ^ 2 * v9;
  if ( (v9 ^ 2 * v9) >= 0 )
  {
    *(_BYTE *)(a2 + 2) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 2) = 1;
    v9 = -v9;
  }
  *(float *)(a2 + 4) = (double)(2 * v9) * 0.000000004190951585769653;
  *a3 = v9;
  return result;
}

//----- (100257A0) --------------------------------------------------------
int __cdecl sub_100257A0(char a1, int a2)
{
  int v2; // ecx@0
  int result; // eax@4
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( sub_1001D4B0() && (a1 == 1 || a1 == 2) )
  {
    sub_100256A0(a1 - 1, a2, &v4);
    result = dword_102234FC;
    *(_BYTE *)(a2 + 2) = *(_BYTE *)(dword_102234FC + 1229);
    *(_BYTE *)a2 = 1;
  }
  else
  {
    result = a2;
    *(float *)(a2 + 4) = 0.0;
    *(_BYTE *)(a2 + 1) = 1;
    *(_BYTE *)(a2 + 2) = 2;
    *(_BYTE *)(a2 + 3) = 1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}
// 102234FC: using guessed type int dword_102234FC;

//----- (10025810) --------------------------------------------------------
int __cdecl sub_10025810(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_100255A0(v1);
  return sub_100257A0(v2, a1);
}

//----- (10025830) --------------------------------------------------------
char __cdecl sub_10025830(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10025870) --------------------------------------------------------
char __cdecl sub_10025870(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 26;
    }
    else if ( a1 == 2 )
    {
      result = 43;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 259, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 25;
  }
  return result;
}

//----- (100258B0) --------------------------------------------------------
signed int __cdecl sub_100258B0(char a1)
{
  signed int result; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 0x2000;
    }
    else if ( a1 == 2 )
    {
      result = 0x80000;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 317, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 4096;
  }
  return result;
}

//----- (10025900) --------------------------------------------------------
char __cdecl sub_10025900(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 80;
    }
    else if ( a1 == 2 )
    {
      result = -117;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 375, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 79;
  }
  return result;
}

//----- (10025940) --------------------------------------------------------
char __cdecl sub_10025940(int a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 0x1000:
      result = 0;
      break;
    case 0x2000:
      result = 1;
      break;
    case 0x80000:
      result = 2;
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 432, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10025990) --------------------------------------------------------
char __cdecl sub_10025990(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2
  _DWORD *v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@3
  char *v7; // eax@3

  v2 = sub_1001E7B0(&a1, 1u, (int)&dword_100A58B8, 10, 3, -1);
  if ( v2 == -1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 486, 0, 0);
    result = 0;
  }
  else
  {
    v4 = a2;
    v5 = 5 * v2;
    v6 = *(int *)((char *)&dword_100A58B8 + 2 * v5);
    v7 = (char *)&dword_100A58B8 + 2 * v5;
    *a2 = v6;
    v4[1] = *((_DWORD *)v7 + 1);
    *((_WORD *)v4 + 4) = *((_WORD *)v7 + 4);
    result = 1;
  }
  return result;
}
// 100A58B8: using guessed type int dword_100A58B8;

//----- (100259F0) --------------------------------------------------------
char __cdecl sub_100259F0(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2
  _DWORD *v4; // ecx@3

  v2 = sub_1001E7B0(&a1, 1u, (int)dword_100A58D8, 8, 3, -1);
  if ( v2 == -1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 545, 0, 0);
    result = 0;
  }
  else
  {
    v4 = a2;
    *a2 = dword_100A58D8[2 * v2];
    v4[1] = dword_100A58DC[2 * v2];
    result = 1;
  }
  return result;
}
// 100A58D8: using guessed type int dword_100A58D8[];
// 100A58DC: using guessed type int dword_100A58DC[];

//----- (10025A50) --------------------------------------------------------
char __cdecl sub_10025A50(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_1001E7B0(&a1, 1u, (int)dword_100A58F0, 4, 3, -1);
  if ( v2 == -1 )
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 604, 0, 0);
    result = 0;
  }
  else
  {
    *a2 = dword_100A58F0[v2];
    result = 1;
  }
  return result;
}
// 100A58F0: using guessed type int dword_100A58F0[];

//----- (10025AA0) --------------------------------------------------------
int __cdecl sub_10025AA0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x23u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100A7DEC + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_100A7DF8 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_100A7E04 + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_100A7E10 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_100A7E1C + a1 + 16 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 209, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100A7DEC: using guessed type void *off_100A7DEC;
// 100A7DF8: using guessed type void *off_100A7DF8;
// 100A7E04: using guessed type void *off_100A7E04;
// 100A7E10: using guessed type void *off_100A7E10;
// 100A7E1C: using guessed type void *off_100A7E1C;

//----- (10025B70) --------------------------------------------------------
int __cdecl sub_10025B70(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100A7D70 + a1);
        break;
      case 0:
        result = (int)*(&off_100A7D7C + a1);
        break;
      case 1:
        result = (int)*(&off_100A7D88 + a1);
        break;
      case 2:
        result = (int)*(&off_100A7D94 + a1);
        break;
      case 3:
        result = (int)*(&off_100A7DA0 + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 313, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100A7D70: using guessed type void *off_100A7D70;
// 100A7D7C: using guessed type void *off_100A7D7C;
// 100A7D88: using guessed type void *off_100A7D88;
// 100A7D94: using guessed type void *off_100A7D94;
// 100A7DA0: using guessed type void *off_100A7DA0;

//----- (10025C00) --------------------------------------------------------
char __cdecl sub_10025C00(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x21u )
  {
    result = byte_100A86A8[64 * a1];
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 354, 0, 0);
    result = 16;
  }
  return result;
}

//----- (10025C30) --------------------------------------------------------
char __cdecl sub_10025C30(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x21u )
  {
    result = byte_100A86AA[64 * a1];
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 390, 0, 0);
    result = 4;
  }
  return result;
}

//----- (10025C60) --------------------------------------------------------
char __cdecl sub_10025C60(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x21u )
  {
    result = byte_100A86A9[64 * a1];
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 424, 0, 0);
    result = 5;
  }
  return result;
}

//----- (10025C90) --------------------------------------------------------
int __cdecl sub_10025C90(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x21u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100A86AC + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_100A86B8 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_100A86C4 + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_100A86D0 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_100A86DC + a1 + 16 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 504, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100A86AC: using guessed type void *off_100A86AC;
// 100A86B8: using guessed type void *off_100A86B8;
// 100A86C4: using guessed type void *off_100A86C4;
// 100A86D0: using guessed type void *off_100A86D0;
// 100A86DC: using guessed type void *off_100A86DC;

//----- (10025D60) --------------------------------------------------------
int __cdecl sub_10025D60(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 12);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 36);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 48);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 583, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10025E00) --------------------------------------------------------
int __cdecl sub_10025E00(unsigned __int8 a1, char a2)
{
  return sub_10025D60((int)&off_100A7DAC, a1, a2);
}
// 100A7DAC: using guessed type void *off_100A7DAC;

//----- (10025E20) --------------------------------------------------------
char __cdecl sub_10025E20(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10025E40) --------------------------------------------------------
unsigned __int8 __cdecl sub_10025E40(unsigned int a1, char a2)
{
  return sub_1003F650(a1, a1 >> 16, BYTE3(a1), a2);
}

//----- (10025E60) --------------------------------------------------------
char __cdecl sub_10025E60(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10018A40("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10025EE0) --------------------------------------------------------
char __cdecl sub_10025EE0(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_10038640(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (10025F40) --------------------------------------------------------
char __cdecl sub_10025F40(char *a1)
{
  char result; // al@4
  char v2; // [sp+8h] [bp-44h]@1

  memset(&v2, 0, 0x40u);
  if ( (unsigned int)a1 >= 0xFFFFFFC2 || !a1 || sub_10018540(6786, (int)&v2, 64) )
  {
    result = 0;
  }
  else
  {
    qmemcpy(a1, &v2, 0x40u);
    result = 1;
  }
  return result;
}

//----- (10025FC0) --------------------------------------------------------
bool __cdecl sub_10025FC0(void *a1)
{
  bool v1; // bl@1
  char v2; // si@4
  char v3; // si@10
  __int16 v5; // [sp+8h] [bp-144h]@5
  char v6; // [sp+Ch] [bp-140h]@1
  int v7; // [sp+Eh] [bp-13Eh]@5
  char v8; // [sp+14h] [bp-138h]@15
  char v9; // [sp+18h] [bp-134h]@14
  int v10; // [sp+20h] [bp-12Ch]@2
  char v11; // [sp+4Ch] [bp-100h]@6
  __int16 v12; // [sp+4Eh] [bp-FEh]@6
  int v13; // [sp+54h] [bp-F8h]@12
  char v14; // [sp+58h] [bp-F4h]@14
  char v15; // [sp+60h] [bp-ECh]@15
  int v16; // [sp+64h] [bp-E8h]@8
  int v17; // [sp+128h] [bp-24h]@19

  v1 = 0;
  if ( sub_10025F40(&v6) && v10 != 10485760 )
  {
    switch ( (unsigned __int8)a1 )
    {
      case 0xAu:
      case 0xBu:
        v2 = sub_10025E60((char)a1);
        if ( (unsigned __int8)sub_1001C130(v2) )
        {
          if ( sub_10025EE0(v7, &v5) )
          {
            memset(&v11, 0, 0x3Cu);
            sub_100214A0(v2, (int)&v11);
            v1 = v12 == v5;
            if ( (unsigned __int8)sub_1001C370(v2) )
            {
              if ( !v1 || v16 != v10 )
                goto LABEL_21;
              v1 = 1;
            }
          }
        }
        break;
      case 0x30u:
      case 0x31u:
        v3 = sub_10025E60((char)a1);
        if ( (unsigned __int8)sub_1001C130(v3) )
        {
          memset(&v11, 0, 0x80u);
          if ( !sub_10021CE0(v3, 65, (unsigned int)&v11)
            || v13 != v10
            || (_WORD)v16 != (_WORD)v7
            || strncmp(&v14, &v9, 7u)
            || strncmp(&v15, &v8, 2u) )
          {
            goto LABEL_21;
          }
          v1 = 1;
        }
        break;
      case 0x20u:
        if ( sub_10022510(a1) )
        {
          memset(&v11, 0, 0xFCu);
          if ( (unsigned __int8)sub_100225D0((int)a1, (int)&v11) && v17 == v10 )
            v1 = 1;
          else
LABEL_21:
            v1 = 0;
        }
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\iop_acft_data_intf.c", 194, 0, 0);
        break;
    }
  }
  return v1;
}

//----- (10026200) --------------------------------------------------------
BOOL sub_10026200()
{
  return j_FIL_vfs_delete("/mnt/sys_nand0/cnfg_rgn.bin") == 0;
}
// 100192D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10026220) --------------------------------------------------------
char __cdecl sub_10026220(char a1, __int16 a2, unsigned int *a3, unsigned int a4, char a5)
{
  char result; // al@1
  signed int v6; // edi@3
  int v7; // esi@6

  result = 0;
  if ( (unsigned int)a3 < 0xFFFFFFC2 )
  {
    if ( a3 )
    {
      v6 = a4;
      if ( a4 > 4 )
      {
        if ( a5 )
          v6 = a4 - 4;
        v7 = sub_1004C560(a3, v6, 0xFFFFFFFF);
        sub_10020890(a1, a2, v7);
        result = 1;
        if ( a5 )
          *(unsigned int *)((char *)a3 + v6) = v7;
      }
    }
  }
  return result;
}

//----- (10026280) --------------------------------------------------------
char __cdecl sub_10026280(char a1, __int16 a2, unsigned int a3, int a4, int a5)
{
  char v5; // bl@1
  unsigned int v6; // eax@1
  unsigned int v7; // esi@1
  int v8; // ebx@6
  signed int v9; // eax@6
  char result; // al@9

  v5 = 0;
  v6 = j_FIL_vfs_open("/mnt/sys_nand0/cnfg_rgn.bin", 10, 0);
  v7 = v6;
  if ( v6 < 0xFFFFFFC2 && v6 && a3 < 0xFFFFFFC2 && a3 )
  {
    if ( !a4 )
      return v5;
    v8 = j_FIL_vfs_write(v6, a3, a4);
    v9 = sub_10019290(v7);
    if ( v8 == a4 && !v9 )
    {
      v5 = 1;
      sub_1001D180("/mnt/sys_nand0/cnfg_rgn.bin", 0, a4, a1, a2, a5);
      return v5;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10026310) --------------------------------------------------------
char __cdecl sub_10026310(char a1, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax@2

  if ( a1 == 1 )
  {
    v4 = a2;
    *v4 |= a4;
  }
  else
  {
    LOBYTE(v4) = a1 - 2;
    if ( a1 == 2 )
    {
      *a2 = a4;
      if ( a4 )
      {
        LOBYTE(v4) = *a3 == 0;
        *a2 = (_BYTE)v4;
      }
      else
      {
        LOBYTE(v4) = (_BYTE)a3;
        *a3 = 1;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (10026350) --------------------------------------------------------
char __thiscall sub_10026350(void *this)
{
  char result; // al@2

  switch ( sub_100206D0(this) )
  {
    case 4:
    case 128:
      result = 1;
      break;
    case 2:
    case 16:
      result = 2;
      break;
    case 32:
      result = 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10026410) --------------------------------------------------------
void __usercall sub_10026410(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6)
{
  int v6; // esi@2
  int v7; // eax@3

  if ( a2 )
  {
    v6 = 0;
    if ( *a2 < a1 )
    {
      v7 = (int)a2;
      do
      {
        if ( *(_WORD *)(a6 + 2 * *(_WORD *)v7) < a1 )
          sub_10026310(
            *(_BYTE *)(v7 + 2),
            (_BYTE *)(a3 + *(_WORD *)(a6 + 2 * *(_WORD *)v7)),
            (_BYTE *)(*(_WORD *)v7 + a4),
            a5);
        v7 = (int)&a2[2 * ++v6];
      }
      while ( a2[2 * v6] < a1 );
    }
  }
}

//----- (10026470) --------------------------------------------------------
char __cdecl sub_10026470(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char result; // al@2
  bool v3; // zf@3
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  BYTE3(v4) = 1;
  if ( sub_1001FDE0(v1) == 2 )
  {
    result = 1;
  }
  else
  {
    v3 = sub_10003EC0(a1, (_BYTE *)&v4 + 3) == 1;
    result = 1;
    if ( v3 )
      result = BYTE3(v4);
  }
  return result;
}

//----- (100264B0) --------------------------------------------------------
char __usercall sub_100264B0@<al>(void *a1@<ecx>, int a2@<esi>)
{
  char v2; // bl@1
  char v3; // al@1

  v2 = 0;
  v3 = sub_1001FDE0(a1);
  if ( v3 == 2 || v3 == 4 )
  {
    if ( j_HWM_pvg_read_reg(1) )
    {
      v2 = 1;
      memset((void *)a2, 0, 0x74u);
      *(_DWORD *)(a2 + 108) = 5;
      *(_DWORD *)(a2 + 112) = 15;
    }
  }
  return v2;
}
// 10019270: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100264F0) --------------------------------------------------------
char __cdecl sub_100264F0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  signed int v7; // edi@1
  void *v8; // eax@3
  __int16 v9; // cx@8
  __int16 v10; // cx@11
  __int16 v11; // cx@14
  __int16 v12; // cx@17
  int v13; // esi@23
  signed int v14; // edi@23
  void *v15; // eax@25
  __int16 v16; // cx@30
  __int16 v17; // cx@33
  __int16 v18; // cx@36
  __int16 v19; // cx@39
  void *v20; // ecx@45
  int v21; // eax@45
  char v22; // si@46
  signed int v23; // eax@46
  void *v24; // ecx@46
  int v25; // ST18_4@48
  int v26; // ST10_4@48
  unsigned __int16 *v27; // eax@48
  int v28; // ST18_4@48
  int v29; // ST10_4@48
  unsigned __int16 *v30; // eax@48
  int v31; // ecx@48
  int v32; // ST18_4@49
  int v33; // ST10_4@49
  unsigned __int16 *v34; // eax@49
  int v35; // ST18_4@51
  int v36; // ST10_4@51
  unsigned __int16 *v37; // eax@51
  unsigned __int8 v38; // al@52
  char v39; // bp@52
  signed int v40; // ecx@52
  char v41; // al@53
  int v42; // ST18_4@54
  int v43; // ST10_4@54
  int v44; // ST0C_4@54
  unsigned __int16 *v45; // eax@54
  char v46; // al@55
  int v47; // ST18_4@56
  int v48; // ST10_4@56
  int v49; // ST0C_4@56
  unsigned __int16 *v50; // eax@56
  signed int v51; // ebp@58
  char v52; // di@60
  unsigned __int8 v53; // al@60
  int v54; // ST18_4@60
  char v55; // ST14_1@60
  int v56; // ST10_4@60
  int v57; // ST0C_4@60
  unsigned __int16 *v58; // eax@60
  signed int v59; // edi@66
  void *v60; // ecx@66
  int i; // edi@67
  unsigned __int16 v62; // ax@68
  unsigned __int8 v63; // al@75
  char v64; // al@75
  int v65; // ST18_4@75
  char v66; // ST14_1@75
  int v67; // ST10_4@75
  unsigned __int16 *v68; // eax@75
  char result; // al@75
  char v70; // [sp+13h] [bp-49h]@62
  int v71; // [sp+14h] [bp-48h]@1
  int v72; // [sp+18h] [bp-44h]@1
  int v73; // [sp+1Ch] [bp-40h]@1
  int v74; // [sp+20h] [bp-3Ch]@1
  int v75; // [sp+24h] [bp-38h]@52
  unsigned __int16 v76; // [sp+28h] [bp-34h]@62
  int v77; // [sp+2Ch] [bp-30h]@1
  int v78; // [sp+30h] [bp-2Ch]@52
  int v79; // [sp+34h] [bp-28h]@45
  int v80; // [sp+38h] [bp-24h]@60
  int v81; // [sp+3Ch] [bp-20h]@1
  int v82; // [sp+40h] [bp-1Ch]@1
  int v83; // [sp+44h] [bp-18h]@1
  int v84; // [sp+48h] [bp-14h]@1
  int v85; // [sp+4Ch] [bp-10h]@1
  int v86; // [sp+50h] [bp-Ch]@1

  v5 = a3;
  v73 = a4;
  v74 = a3;
  v72 = a5;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  memset(word_10191EF8, 0, 0xFA0u);
  v6 = 0;
  v71 = -1;
  v77 = 0;
  v7 = 0;
  do
  {
    if ( sub_10018540(v7 + 12000, (int)&unk_10192E98, 16004) )
    {
      v6 += 100;
    }
    else
    {
      v8 = &unk_10192F22;
      do
      {
        if ( *((char *)v8 - 136) && *(_WORD *)v8 )
        {
          word_10191EF8[v6] = *(_WORD *)v8;
          v71 = v6;
        }
        if ( *((_BYTE *)v8 + 24) )
        {
          v9 = *((_WORD *)v8 + 80);
          if ( v9 )
          {
            word_10191EFA[v6] = v9;
            v71 = v6 + 1;
          }
        }
        if ( *((_BYTE *)v8 + 184) )
        {
          v10 = *((_WORD *)v8 + 160);
          if ( v10 )
          {
            word_10191EFC[v6] = v10;
            v71 = v6 + 2;
          }
        }
        if ( *((_BYTE *)v8 + 344) )
        {
          v11 = *((_WORD *)v8 + 240);
          if ( v11 )
          {
            word_10191EFE[v6] = v11;
            v71 = v6 + 3;
          }
        }
        if ( *((_BYTE *)v8 + 504) )
        {
          v12 = *((_WORD *)v8 + 320);
          if ( v12 )
          {
            word_10191F00[v6] = v12;
            v71 = v6 + 4;
          }
        }
        v8 = (char *)v8 + 800;
        v6 += 5;
      }
      while ( (signed int)v8 < (signed int)&unk_10196DA2 );
    }
    ++v7;
  }
  while ( v7 < 10 );
  v13 = 0;
  v14 = 0;
  do
  {
    if ( sub_10018540(v14 + 14000, (int)&unk_10192E98, 16004) )
    {
      v13 += 100;
    }
    else
    {
      v15 = &unk_10192F22;
      do
      {
        if ( *((char *)v15 - 136) && *(_WORD *)v15 )
        {
          word_101926C8[v13] = *(_WORD *)v15;
          v71 = v13 + 1000;
        }
        if ( *((_BYTE *)v15 + 24) )
        {
          v16 = *((_WORD *)v15 + 80);
          if ( v16 )
          {
            word_101926CA[v13] = v16;
            v71 = v13 + 1001;
          }
        }
        if ( *((_BYTE *)v15 + 184) )
        {
          v17 = *((_WORD *)v15 + 160);
          if ( v17 )
          {
            word_101926CC[v13] = v17;
            v71 = v13 + 1002;
          }
        }
        if ( *((_BYTE *)v15 + 344) )
        {
          v18 = *((_WORD *)v15 + 240);
          if ( v18 )
          {
            word_101926CE[v13] = v18;
            v71 = v13 + 1003;
          }
        }
        if ( *((_BYTE *)v15 + 504) )
        {
          v19 = *((_WORD *)v15 + 320);
          if ( v19 )
          {
            word_101926D0[v13] = v19;
            v71 = v13 + 1004;
          }
        }
        v15 = (char *)v15 + 800;
        v13 += 5;
      }
      while ( (signed int)v15 < (signed int)&unk_10196DA2 );
    }
    ++v14;
  }
  while ( v14 < 10 );
  sub_10021480((int)&v77);
  v21 = sub_100206D0(v20);
  v77 |= v21;
  LOBYTE(v79) = 0;
  do
  {
    v22 = v79;
    v23 = sub_10020160(v79);
    if ( v23 & v77 || sub_1001FDE0(v24) == 4 )
    {
      v25 = v72;
      v26 = v73;
      v27 = (unsigned __int16 *)sub_1003FA00(v22, a1);
      sub_10026410(a2, v27, v5, v26, 1, v25);
      v28 = v72;
      v29 = v73;
      v30 = (unsigned __int16 *)sub_1003FBE0(*(_BYTE *)dword_1021A3CC, v22, a1);
      sub_10026410(a2, v30, v5, v29, 1, v28);
      if ( (unsigned __int8)sub_1003FE20(v31) )
      {
        v32 = v72;
        v33 = v73;
        v34 = (unsigned __int16 *)sub_1003F980(v22, a1);
        sub_10026410(a2, v34, v5, v33, 1, v32);
      }
      if ( sub_1003FE10() )
      {
        v35 = v72;
        v36 = v73;
        v37 = (unsigned __int16 *)sub_1003FA80(v22, a1);
        sub_10026410(a2, v37, v5, v36, 1, v35);
      }
      v38 = sub_10020080(v22);
      LOBYTE(v75) = sub_10026470(v38);
      sub_10021380(v22, (int)&v81);
      v39 = v75;
      v40 = 0;
      v78 = 0;
      do
      {
        v41 = *((_BYTE *)&v84 + 4 * v40);
        if ( v41 )
        {
          v42 = v72;
          v43 = v73;
          v44 = v74;
          v45 = (unsigned __int16 *)sub_1003FD40(v22, v41, a1);
          sub_10026410(a2, v45, v44, v43, v39, v42);
          v40 = v78;
        }
        v46 = *((_BYTE *)&v84 + 4 * v40 + 1);
        if ( v46 )
        {
          v47 = v72;
          v48 = v73;
          v49 = v74;
          v50 = (unsigned __int16 *)sub_1003FD40(v22, v46, a1);
          sub_10026410(a2, v50, v49, v48, v39, v47);
          v40 = v78;
        }
        v78 = ++v40;
      }
      while ( v40 <= 1 );
      v51 = 0;
      do
      {
        if ( *((_BYTE *)&v82 + 4 * v51 + 1) )
        {
          LOBYTE(v80) = *((_BYTE *)&v82 + 4 * v51 + 1);
          v52 = v80;
          v53 = sub_10020570(v80);
          LOBYTE(v75) = sub_10026470(v53);
          v54 = v72;
          v55 = v75;
          v56 = v73;
          v57 = v74;
          v58 = (unsigned __int16 *)sub_1003FCA0(v22, v52, a1);
          sub_10026410(a2, v58, v57, v56, v55, v54);
        }
        ++v51;
      }
      while ( v51 < 2 );
      if ( sub_1003A120(HIWORD(v86), 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
        *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
      v59 = sub_10020160(v22);
      if ( sub_100206D0(v60) == v59 )
      {
        for ( i = 0; i <= v71; ++i )
        {
          v62 = word_10191EF8[i];
          if ( v62 && sub_1003A180(v62, 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
            *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
        }
      }
      v5 = v74;
    }
    v63 = sub_10020080(v22);
    v64 = sub_10026470(v63);
    v65 = v72;
    LOBYTE(v75) = v64;
    v66 = v64;
    v67 = v73;
    v68 = (unsigned __int16 *)sub_1003FB00(v22, a1);
    sub_10026410(a2, v68, v5, v67, v66, v65);
    result = v79 + 1;
    LOBYTE(v79) = v79 + 1;
  }
  while ( (unsigned __int8)v79 < 3u );
  return result;
}
// 10191EF8: using guessed type __int16 word_10191EF8[];
// 10191EFA: using guessed type __int16 word_10191EFA[];
// 10191EFC: using guessed type __int16 word_10191EFC[];
// 10191EFE: using guessed type __int16 word_10191EFE[];
// 10191F00: using guessed type __int16 word_10191F00[];
// 101926C8: using guessed type __int16 word_101926C8[];
// 101926CA: using guessed type __int16 word_101926CA[];
// 101926CC: using guessed type __int16 word_101926CC[];
// 101926CE: using guessed type __int16 word_101926CE[];
// 101926D0: using guessed type __int16 word_101926D0[];
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (10026A70) --------------------------------------------------------
void __cdecl sub_10026A70(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // ST0C_1@2
  int *v6; // eax@2
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_10026470(0x1Fu);
  sub_10021480((int)&v7);
  if ( v7 & 0x8000 )
  {
    v5 = v8;
    v6 = sub_10040130(a1);
    sub_10026410(a2, (unsigned __int16 *)v6, a3, a4, v5, a5);
  }
}

//----- (10026AD0) --------------------------------------------------------
void __cdecl sub_10026AD0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // ST0C_1@2
  unsigned __int16 *v7; // eax@2

  if ( sub_10040190(v5) )
  {
    v6 = sub_10026470(0x11u);
    v7 = (unsigned __int16 *)sub_1003FE50(a1);
    sub_10026410(a2, v7, a3, a4, v6, a5);
  }
}

//----- (10026B20) --------------------------------------------------------
void __cdecl sub_10026B20(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  int v10; // [sp+0h] [bp-4h]@1

  v10 = v5;
  sub_10021480((int)&v10);
  if ( v10 & 0x1000000 || sub_1001FDE0(v6) == 4 )
  {
    v7 = sub_10026470(0x32u) && sub_10026470(0x3Eu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_100401B0(a1);
    sub_10026410(a2, v9, a3, a4, v8, a5);
  }
}

//----- (10026BA0) --------------------------------------------------------
char __cdecl sub_10026BA0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v6; // bp@3
  signed int v7; // eax@3
  void *v8; // ecx@3
  unsigned __int8 v9; // al@6
  char v10; // ST18_1@6
  int v11; // ST14_4@6
  unsigned __int16 *v12; // eax@6
  int v13; // ecx@6
  char v14; // ST18_1@7
  int v15; // ST14_4@7
  unsigned __int16 *v16; // eax@7
  char v17; // ST18_1@7
  int v18; // ST14_4@7
  unsigned __int16 *v19; // eax@7
  int v20; // eax@8
  void *v21; // ecx@8
  char v22; // al@9
  char v23; // al@12
  char v24; // ST18_1@14
  int v25; // ST14_4@14
  unsigned __int16 *v26; // eax@14
  unsigned __int16 *v27; // eax@17
  char v28; // al@22
  char v29; // ST18_1@24
  int v30; // ST14_4@24
  unsigned __int16 *v31; // eax@24
  char v32; // ST18_1@25
  int v33; // ST14_4@25
  unsigned __int16 *v34; // eax@25
  signed int v35; // ecx@25
  unsigned __int8 v36; // al@26
  char v37; // ST18_1@27
  int v38; // ST14_4@27
  unsigned __int16 *v39; // eax@27
  signed int v40; // eax@29
  char v41; // ST18_1@31
  int v42; // ST14_4@31
  unsigned __int16 *v43; // eax@31
  unsigned __int16 *v44; // edi@33
  unsigned __int16 *v45; // edi@39
  __int16 *v46; // ecx@45
  char v47; // ST18_1@48
  int v48; // ST14_4@48
  unsigned __int16 *v49; // eax@48
  unsigned __int8 v50; // al@49
  char v51; // ST18_1@52
  int v52; // ST14_4@52
  unsigned __int16 *v53; // eax@52
  __int16 *v54; // eax@55
  int v55; // edi@55
  bool v56; // cf@55
  int v57; // eax@57
  _BYTE *v58; // esi@61
  unsigned __int8 v59; // di@62
  unsigned __int8 v60; // al@62
  char v61; // ST18_1@62
  int v62; // ST14_4@62
  int v63; // ST10_4@62
  unsigned __int16 *v64; // eax@62
  _BYTE *v65; // esi@63
  unsigned __int8 v66; // di@64
  unsigned __int8 v67; // al@64
  char v68; // ST18_1@64
  int v69; // ST14_4@64
  int v70; // ST10_4@64
  unsigned __int16 *v71; // eax@64
  unsigned __int8 v72; // di@65
  unsigned __int8 v73; // al@65
  char v74; // ST18_1@65
  int v75; // ST14_4@65
  int v76; // ST10_4@65
  unsigned __int16 *v77; // eax@65
  char *v78; // eax@67
  unsigned __int8 v79; // di@68
  unsigned __int8 v80; // al@68
  char v81; // al@68
  int v82; // esi@72
  char v83; // ST18_1@72
  int v84; // ST14_4@72
  int v85; // ST10_4@72
  unsigned __int16 *v86; // eax@72
  unsigned __int8 v87; // di@73
  unsigned __int8 v88; // al@73
  char v89; // al@73
  char v90; // ST18_1@77
  int v91; // ST14_4@77
  unsigned __int16 *v92; // eax@77
  char result; // al@79
  int v94; // [sp-10h] [bp-D8h]@17
  int v95; // [sp-Ch] [bp-D4h]@17
  char v96; // [sp-8h] [bp-D0h]@17
  int v97; // [sp-4h] [bp-CCh]@17
  char v98; // [sp+17h] [bp-B1h]@1
  int v99; // [sp+18h] [bp-B0h]@12
  int v100; // [sp+1Ch] [bp-ACh]@6
  int v101; // [sp+20h] [bp-A8h]@1
  int v102; // [sp+24h] [bp-A4h]@25
  __int16 *v103; // [sp+28h] [bp-A0h]@45
  int v104; // [sp+2Ch] [bp-9Ch]@1
  int v105; // [sp+30h] [bp-98h]@1
  unsigned int v106; // [sp+34h] [bp-94h]@68
  unsigned int v107; // [sp+38h] [bp-90h]@64
  unsigned __int8 *v108; // [sp+3Ch] [bp-8Ch]@1
  unsigned __int16 v109[2]; // [sp+40h] [bp-88h]@56
  int v110; // [sp+44h] [bp-84h]@1
  int v111; // [sp+48h] [bp-80h]@1
  unsigned int v112; // [sp+4Ch] [bp-7Ch]@62
  char v113; // [sp+50h] [bp-78h]@1
  unsigned int v114; // [sp+BCh] [bp-Ch]@16
  char v115; // [sp+C0h] [bp-8h]@10

  v5 = a3;
  v101 = a4;
  v104 = a3;
  v98 = 0;
  v111 = 0;
  v105 = 0;
  memset(&v113, 0, 0x74u);
  sub_10021480((int)&v111);
  LOBYTE(v110) = 0;
  v108 = (unsigned __int8 *)":#;<";
  while ( 1 )
  {
    v6 = v110;
    v7 = sub_100394D0(v110);
    if ( !(v7 & v111) )
    {
      if ( sub_1001FDE0(v8) != 4 )
        goto LABEL_79;
      v5 = v104;
    }
    v9 = sub_10039490(v6);
    LOBYTE(v100) = sub_10026470(v9);
    memset(byte_10191458, 0, 0xAA0u);
    sub_100213D0(v6, (int)byte_10191458);
    v10 = v100;
    v11 = v101;
    v12 = (unsigned __int16 *)sub_10040910(v6, a1);
    sub_10026410(a2, v12, v5, v11, v10, a5);
    if ( (unsigned __int8)sub_1003FE20(v13) )
    {
      v14 = v100;
      v15 = v101;
      v16 = (unsigned __int16 *)sub_10040D20(v6, a1);
      sub_10026410(a2, v16, v5, v15, v14, a5);
      v17 = v100;
      v18 = v101;
      v19 = (unsigned __int16 *)sub_10040D00(v6, a1);
      sub_10026410(a2, v19, v5, v18, v17, a5);
    }
    LOBYTE(v20) = sub_10039510(v6);
    if ( sub_10025350(v20, &v113) || (v22 = sub_100264B0(v21, (int)&v113), v5 = v104, v22) )
    {
      if ( v115 & 1 )
      {
        if ( !(_BYTE)v100 || (v23 = sub_10026470(*(v108 - 1)), LOBYTE(v99) = 1, !v23) )
          LOBYTE(v99) = 0;
        v24 = v99;
        v25 = v101;
        v26 = (unsigned __int16 *)sub_100407F0(v6, a1);
        sub_10026410(a2, v26, v5, v25, v24, a5);
      }
      if ( v115 & 2 )
      {
        if ( v114 >= 3 )
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_10040BD0(v6, a1);
        }
        else
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_10040880(v6, a1);
        }
        sub_10026410(a2, v27, v94, v95, v96, v97);
      }
      if ( v115 & 8 )
      {
        if ( !(_BYTE)v100 || (v28 = sub_10026470(*v108), LOBYTE(v99) = 1, !v28) )
          LOBYTE(v99) = 0;
        v29 = v99;
        v30 = v101;
        v31 = (unsigned __int16 *)sub_10040B40(v6, a1);
        sub_10026410(a2, v31, v5, v30, v29, a5);
      }
    }
    v32 = v100;
    v33 = v101;
    v34 = (unsigned __int16 *)sub_10040720(v6, byte_10191924, a1);
    sub_10026410(a2, v34, v5, v33, v32, a5);
    v102 = 0;
    v35 = 0;
    do
    {
      v36 = byte_10191458[v35];
      if ( v36 )
      {
        v37 = v100;
        v38 = v101;
        v39 = (unsigned __int16 *)sub_100402E0(v6, v102, v36, a1);
        sub_10026410(a2, v39, v5, v38, v37, a5);
        v35 = v102;
      }
      v102 = ++v35;
    }
    while ( v35 < 10 );
    v40 = 0;
    v102 = 0;
    do
    {
      if ( byte_10191462[v40] == 1 )
      {
        v41 = v100;
        v42 = v101;
        v43 = (unsigned __int16 *)sub_10040580(v6, v102, a1);
        sub_10026410(a2, v43, v5, v42, v41, a5);
        v40 = v102;
      }
      v102 = ++v40;
    }
    while ( v40 < 11 );
    v44 = (unsigned __int16 *)&unk_1019149E;
    do
    {
      if ( sub_1003A120(*v44, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v44 += 6;
    }
    while ( (signed int)v44 < (signed int)&unk_1019168A );
    v45 = (unsigned __int16 *)&unk_1019168A;
    do
    {
      if ( sub_1003A180(*v45, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v45 += 2;
    }
    while ( (signed int)v45 < (signed int)&unk_10191732 );
    v46 = (__int16 *)&unk_10191778;
    v102 = 0;
    v103 = (__int16 *)&unk_10191778;
    do
    {
      if ( *(_BYTE *)v46 == 3 )
      {
        LOWORD(v102) = v46[1] | v102;
      }
      else
      {
        v47 = v100;
        v48 = v101;
        v49 = (unsigned __int16 *)sub_10040650(v6, *(_BYTE *)v46, a1);
        sub_10026410(a2, v49, v5, v48, v47, a5);
        v46 = v103;
      }
      v50 = *((_BYTE *)v46 + 1);
      if ( v50 != *(_BYTE *)v46 )
      {
        if ( v50 == 3 )
        {
          LOWORD(v102) = v46[1] | v102;
        }
        else
        {
          v51 = v100;
          v52 = v101;
          v53 = (unsigned __int16 *)sub_10040650(v6, v50, a1);
          sub_10026410(a2, v53, v5, v52, v51, a5);
          v46 = v103;
        }
      }
      v46 += 8;
      v103 = v46;
    }
    while ( (signed int)v46 < (signed int)&unk_10191798 );
    if ( (_WORD)v102 )
    {
      v54 = (__int16 *)sub_10040650(v6, 3u, a1);
      v55 = 0;
      v56 = (unsigned __int16)*v54 < a2;
      v103 = v54;
      if ( v56 )
      {
        do
        {
          v105 = (unsigned __int16)*v54;
          if ( !sub_10024E30(a1, *v54, v109)
            || (v57 = sub_1001E7B0((_DWORD *)v109, 2u, (int)"<", 4, 12, 12), v57 >= 12)
            || ((unsigned __int16)v102 & (unsigned __int16)word_100AB626[2 * v57]) != 0 )
          {
            *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
          }
          v54 = &v103[2 * ++v55];
        }
        while ( (unsigned __int16)v103[2 * v55] < a2 );
      }
    }
    v58 = &unk_10191471;
    do
    {
      LOBYTE(v112) = *v58;
      v59 = v112;
      v60 = sub_100395F0(v112);
      LOBYTE(v99) = sub_10026470(v60);
      v61 = v99;
      v62 = v101;
      v63 = v104;
      v64 = (unsigned __int16 *)sub_10040210(v6, v59, a1);
      sub_10026410(a2, v64, v63, v62, v61, a5);
      v58 += 4;
    }
    while ( (signed int)v58 <= (signed int)&unk_10191499 );
    v65 = &unk_10191731;
    do
    {
      LOBYTE(v107) = *(v65 - 1);
      v66 = v107;
      v67 = sub_10039620(v107);
      LOBYTE(v99) = sub_10026470(v67);
      v68 = v99;
      v69 = v101;
      v70 = v104;
      v71 = (unsigned __int16 *)sub_100409A0(v6, v66, a1);
      sub_10026410(a2, v71, v70, v69, v68, a5);
      if ( (_BYTE)v107 != *v65 )
      {
        LOBYTE(v107) = *v65;
        v72 = v107;
        v73 = sub_10039620(v107);
        LOBYTE(v99) = sub_10026470(v73);
        v74 = v99;
        v75 = v101;
        v76 = v104;
        v77 = (unsigned __int16 *)sub_100409A0(v6, v72, a1);
        sub_10026410(a2, v77, v76, v75, v74, a5);
      }
      v65 += 4;
    }
    while ( (signed int)v65 < (signed int)&unk_10191751 );
    v78 = (char *)&unk_10191751;
    v103 = (__int16 *)&unk_10191751;
    do
    {
      LOBYTE(v106) = *(v78 - 1);
      v79 = v106;
      v80 = sub_10039650(v106);
      v81 = sub_10026470(v80);
      LOBYTE(v99) = v81;
      if ( (_BYTE)v106 == 4 )
      {
        if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v81) )
          LOBYTE(v99) = 0;
      }
      v82 = v104;
      v83 = v99;
      v84 = v101;
      v85 = v104;
      v86 = (unsigned __int16 *)sub_10040A70(v6, v79, a1);
      sub_10026410(a2, v86, v85, v84, v83, a5);
      if ( (_BYTE)v106 != *(_BYTE *)v103 )
      {
        LOBYTE(v106) = *(_BYTE *)v103;
        v87 = v106;
        v88 = sub_10039650(v106);
        v89 = sub_10026470(v88);
        LOBYTE(v99) = v89;
        if ( (_BYTE)v106 == 4 )
        {
          if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v89) )
            LOBYTE(v99) = 0;
        }
        v90 = v99;
        v91 = v101;
        v92 = (unsigned __int16 *)sub_10040A70(v6, v87, a1);
        sub_10026410(a2, v92, v82, v91, v90, a5);
      }
      v78 = (char *)(v103 + 4);
      v103 += 4;
    }
    while ( (signed int)v103 < (signed int)&unk_10191779 );
LABEL_79:
    v108 += 2;
    result = v110 + 1;
    LOBYTE(v110) = v110 + 1;
    if ( (unsigned __int8)v110 >= 2u )
      return result;
    v5 = v104;
  }
}
// 100AB626: using guessed type __int16 word_100AB626[];
// 10191924: using guessed type char byte_10191924;

//----- (10027350) --------------------------------------------------------
void __cdecl sub_10027350(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  void *v6; // ecx@2
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  bool v10; // al@12
  char v11; // ST0C_1@14
  unsigned __int16 *v12; // eax@14
  int v13; // [sp+10h] [bp-4h]@1

  sub_10021480((int)&v13);
  if ( v13 & 0x10000 || sub_1001FDE0(v5) == 4 )
  {
    v7 = sub_10026470(0x24u) && sub_10026470(0x3Cu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10040D40(a1);
    sub_10026410(a2, v9, a3, a4, v8, a5);
  }
  if ( v13 & 0x20000 || sub_1001FDE0(v6) == 4 )
  {
    v10 = sub_10026470(0x25u) && sub_10026470(0x3Du);
    v11 = v10;
    v12 = (unsigned __int16 *)sub_10040D40(a1);
    sub_10026410(a2, v12, a3, a4, v11, a5);
  }
}

//----- (10027430) --------------------------------------------------------
char __cdecl sub_10027430(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@2
  void *v6; // ecx@2
  unsigned __int8 v7; // al@4
  char v8; // ST10_1@4
  unsigned __int16 *v9; // eax@4
  char result; // al@5
  unsigned __int8 v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  sub_10021480((int)&v12);
  v11 = 0;
  do
  {
    v5 = sub_100254D0(v11);
    if ( v5 & v12 || sub_1001FDE0(v6) == 4 )
    {
      v7 = sub_10021B40(v11);
      v8 = sub_10026470(v7);
      v9 = (unsigned __int16 *)sub_10040DA0(v11, a1);
      sub_10026410(a2, v9, a3, a4, v8, a5);
    }
    result = v11++ + 1;
  }
  while ( v11 < 2u );
  return result;
}

//----- (100274C0) --------------------------------------------------------
char __cdecl sub_100274C0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // si@2
  signed int v6; // eax@2
  unsigned __int8 v7; // al@3
  char v8; // ST14_1@3
  unsigned __int16 *v9; // eax@3
  int v10; // ecx@3
  char v11; // ST14_1@4
  unsigned __int16 *v12; // eax@4
  unsigned __int16 *v13; // edi@5
  unsigned __int16 *v14; // eax@12
  unsigned __int16 *v15; // eax@14
  unsigned __int8 v16; // al@14
  unsigned __int16 *v17; // eax@15
  char result; // al@17
  char v19; // [sp+13h] [bp-1Dh]@6
  unsigned __int16 v20; // [sp+14h] [bp-1Ch]@6
  int v21; // [sp+18h] [bp-18h]@14
  unsigned __int8 *v22; // [sp+1Ch] [bp-14h]@11
  int v23; // [sp+20h] [bp-10h]@3
  int v24; // [sp+24h] [bp-Ch]@1
  int v25; // [sp+28h] [bp-8h]@1
  int v26; // [sp+2Ch] [bp-4h]@12

  sub_10021480((int)&v25);
  LOBYTE(v24) = 0;
  do
  {
    v5 = v24;
    v6 = sub_100258B0(v24);
    if ( v6 & v25 )
    {
      memset(&unk_10196D20, 0, 0x890u);
      sub_10021450(v5, (int)&unk_10196D20);
      v7 = sub_10025870(v5);
      LOBYTE(v23) = sub_10026470(v7);
      v8 = v23;
      v9 = (unsigned __int16 *)sub_10025B70(v5, a1);
      sub_10026410(a2, v9, a3, a4, v8, a5);
      if ( (unsigned __int8)sub_1003FE20(v10) )
      {
        v11 = v23;
        v12 = (unsigned __int16 *)sub_10025E00(v5, a1);
        sub_10026410(a2, v12, a3, a4, v11, a5);
      }
      v13 = (unsigned __int16 *)&unk_10196DC2;
      do
      {
        if ( sub_1003A120(*v13, v5, &v19, &v20) == 1 && v19 == a1 && v20 < a2 )
          *(_BYTE *)(*(_WORD *)(a5 + 2 * v20) + a3) = v23;
        v13 += 8;
      }
      while ( (signed int)v13 < (signed int)&unk_10197092 );
      v22 = (unsigned __int8 *)&unk_10196D21;
      do
      {
        LOBYTE(v26) = *v22;
        v14 = (unsigned __int16 *)sub_10025AA0(v5, v26, a1);
        sub_10026410(a2, v14, a3, a4, 1, a5);
        v22 += 4;
      }
      while ( (signed int)v22 <= (signed int)&unk_10196DBD );
      v22 = (unsigned __int8 *)&unk_10197091;
      do
      {
        LOBYTE(v21) = *(v22 - 1);
        v15 = (unsigned __int16 *)sub_10025C90(v5, v21, a1);
        sub_10026410(a2, v15, a3, a4, 1, a5);
        v16 = *v22;
        if ( (_BYTE)v21 != *v22 )
        {
          LOBYTE(v21) = *v22;
          v17 = (unsigned __int16 *)sub_10025C90(v5, v16, a1);
          sub_10026410(a2, v17, a3, a4, 1, a5);
        }
        v22 += 8;
      }
      while ( (signed int)v22 < (signed int)&unk_10197111 );
    }
    result = v24 + 1;
    LOBYTE(v24) = v24 + 1;
  }
  while ( (unsigned __int8)v24 < 3u );
  return result;
}

//----- (100276D0) --------------------------------------------------------
char __cdecl sub_100276D0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  int v6; // eax@1
  void *v7; // ecx@1
  signed int v8; // eax@2
  void *v9; // ecx@2
  void *v10; // ecx@3
  unsigned __int8 v11; // al@4
  unsigned __int16 *v12; // eax@4
  char v13; // ST10_1@4
  unsigned __int16 *v14; // eax@4
  __int16 *v15; // eax@4
  int v16; // ecx@4
  unsigned __int16 *v17; // eax@5
  unsigned __int16 *v18; // eax@7
  int v19; // eax@9
  char v21; // [sp+13h] [bp-Dh]@1
  char v22; // [sp+14h] [bp-Ch]@1
  int v23; // [sp+18h] [bp-8h]@1
  int v24; // [sp+1Ch] [bp-4h]@4

  sub_10021480((int)&v23);
  v6 = sub_100206D0(v5);
  v23 |= v6;
  v21 = sub_1001FDE0(v7);
  v22 = 3;
  do
  {
    v8 = sub_10020160(v22);
    if ( v8 & v23 || sub_1001FDE0(v9) == 4 )
    {
      v11 = sub_10020080(v22);
      LOBYTE(v24) = sub_10026470(v11);
      v12 = (unsigned __int16 *)sub_10040E80(a1);
      sub_10026410(a2, v12, a3, a4, 1, a5);
      v13 = v24;
      v14 = (unsigned __int16 *)sub_10040F40(v22, a1);
      sub_10026410(a2, v14, a3, a4, v13, a5);
      v15 = sub_1003F710(a1, a2);
      sub_10026410(a2, (unsigned __int16 *)v15, a3, a4, 1, a5);
      if ( (unsigned __int8)sub_1003FE20(v16) )
      {
        v17 = (unsigned __int16 *)sub_10040E20(a1);
        sub_10026410(a2, v17, a3, a4, 1, a5);
      }
      if ( sub_1003FE10() )
      {
        v18 = (unsigned __int16 *)sub_10040EE0(a1);
        sub_10026410(a2, v18, a3, a4, 1, a5);
      }
    }
    ++v22;
  }
  while ( (unsigned __int8)v22 < 7u );
  LOBYTE(v19) = v21;
  if ( v21 == 2 || v21 == 8 )
  {
    LOBYTE(v19) = a1;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        LOBYTE(v19) = sub_100206D0(v10);
        if ( v19 & 0xF0 )
        {
          *(_BYTE *)(*(_WORD *)(a5 + 492) + a3) = 1;
          *(_BYTE *)(*(_WORD *)(a5 + 496) + a3) = 1;
          v19 = *(_WORD *)(a5 + 494);
          *(_BYTE *)(v19 + a3) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = 1;
      v19 = *(_WORD *)(a5 + 1180);
      *(_BYTE *)(v19 + a3) = 1;
    }
  }
  else if ( !a1 )
  {
    *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = sub_10026470(0x28u);
    *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = sub_10026470(0x29u);
    *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = sub_10026470(0x33u);
    LOBYTE(v19) = sub_10026470(0x34u);
    *(_BYTE *)(*(_WORD *)(a5 + 1180) + a3) = v19;
  }
  return v19;
}

//----- (100278F0) --------------------------------------------------------
void __cdecl sub_100278F0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10021480((int)&v9);
  if ( v9 & 0x4000 || sub_1001FDE0(v6) == 4 )
  {
    v7 = sub_10026470(0x20u);
    v8 = (unsigned __int16 *)sub_10040FE0(a1);
    sub_10026410(a2, v8, a3, a4, v7, a5);
  }
}

//----- (10027950) --------------------------------------------------------
void __cdecl sub_10027950(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10021480((int)&v9);
  if ( v9 & 0x400 || sub_1001FDE0(v6) == 4 )
  {
    v7 = sub_10026470(0x13u);
    v8 = (unsigned __int16 *)sub_10041040(a1);
    sub_10026410(a2, v8, a3, a4, v7, a5);
  }
}

//----- (100279B0) --------------------------------------------------------
void *__usercall sub_100279B0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_10018540(a4, v5, v6);
  if ( result )
  {
    sub_10018670(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (100279E0) --------------------------------------------------------
char sub_100279E0()
{
  char v1; // [sp+Fh] [bp-1h]@1

  sub_100279B0(&v1, &unk_100AB682, 1, 2119);
  return v1;
}

//----- (10027A10) --------------------------------------------------------
char __cdecl sub_10027A10(int a1)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@1

  v1 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  j_HWM_pvg_hsdb_set_sim_lrus_online(0);
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( (a1 & v3) == a1 )
    v1 = 1;
  j_HWM_pvg_hsdb_set_sim_lrus_online(v2 - v3);
  return v1;
}
// 10019230: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10019250: using guessed type int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD);

//----- (10027A50) --------------------------------------------------------
unsigned int __cdecl sub_10027A50(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10027A70) --------------------------------------------------------
int __cdecl sub_10027A70(int a1)
{
  return a1 | 1;
}

//----- (10027A80) --------------------------------------------------------
bool __cdecl sub_10027A80(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10027B50) --------------------------------------------------------
int __cdecl sub_10027B50(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10027B70) --------------------------------------------------------
int __cdecl sub_10027B70(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10027B50(a1 + 20);
  return result;
}

//----- (10027BB0) --------------------------------------------------------
bool __cdecl sub_10027BB0(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (10027C10) --------------------------------------------------------
signed int __cdecl sub_10027C10(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100193A0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100193A0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10027CD0) --------------------------------------------------------
signed int __cdecl sub_10027CD0(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_100193A0(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_10027B70(0, a3);
    sub_100193A0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_100193A0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10027D80) --------------------------------------------------------
int __cdecl sub_10027D80(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10027DA0) --------------------------------------------------------
signed int __cdecl sub_10027DA0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10027E00) --------------------------------------------------------
int __usercall sub_10027E00@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_10019480(v3);
  v10 = sub_100192F0(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_100194B0(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_100194B0(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_10019480(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (10027F10) --------------------------------------------------------
int __usercall sub_10027F10@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10044C70(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10019480(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100194B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10027FC0) --------------------------------------------------------
signed int __usercall sub_10027FC0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100194E0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100450C0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10027C10(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100193A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100193A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10044F90(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100194E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100194E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10028190) --------------------------------------------------------
char __usercall sub_10028190@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10044C20(a2, a3, a1 + 212);
}

//----- (100281A0) --------------------------------------------------------
int __usercall sub_100281A0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10027F10(result + 148, result);
  return result;
}

//----- (100281C0) --------------------------------------------------------
char __usercall sub_100281C0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100281E0) --------------------------------------------------------
int __usercall sub_100281E0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1004C540(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1004C540(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10028220) --------------------------------------------------------
int __cdecl sub_10028220(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_10019480(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_100193A0(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10028220: using guessed type char var_84[128];

//----- (100283D0) --------------------------------------------------------
int __fastcall sub_100283D0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (100283F0) --------------------------------------------------------
int __usercall sub_100283F0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (10028400) --------------------------------------------------------
int __usercall sub_10028400@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10019530(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100194B0(v4, v3, 0);
}
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10028440) --------------------------------------------------------
signed int __usercall sub_10028440@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_100283D0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1004C560(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10028190(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10047020(a2 + 28, 4);
      else
        v22 = sub_10047020(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10028190(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10028650) --------------------------------------------------------
int __cdecl sub_10028650(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_10027E00((int)a1, v2, 0);
        v3 = sub_10028400((int)a1) | v4;
      }
    }
    sub_10019290(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100286B0) --------------------------------------------------------
int __cdecl sub_100286B0(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_1001F7C0((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_10019290(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_10019480(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_10028220(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_100193A0(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10027BB0((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100287B0) --------------------------------------------------------
signed int __cdecl sub_100287B0(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10027BB0(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_100193A0(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_1001F7C0((int)v6, &byte_10065A71, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_100193A0(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_100193A0(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_10027B50(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100289B0) --------------------------------------------------------
signed int __cdecl sub_100289B0(int a1, int a2)
{
  return sub_10027CD0(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (100289D0) --------------------------------------------------------
int __cdecl sub_100289D0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100281A0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10020FE0(&v23);
    sub_1003E890((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10027B70(v1, (int)&v24);
  v13 = sub_10019480(v31);
  if ( v3 == v31 )
  {
    result = sub_100192F0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10019530(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100192F0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10019530(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10027B50(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10028400(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10019480(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10028C40) --------------------------------------------------------
int __cdecl sub_10028C40(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_10027D80((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_1001F7C0((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_100472E0(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_10048C40((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10028D10) --------------------------------------------------------
signed int __cdecl sub_10028D10(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10019530(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10028440(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10028DB0) --------------------------------------------------------
int __usercall sub_10028DB0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100281C0(a1);
  *v3 ^= v2;
  return sub_100281E0(v1, *v3);
}

//----- (10028DD0) --------------------------------------------------------
int __usercall sub_10028DD0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10028DB0(a2);
  return result;
}

//----- (10028E00) --------------------------------------------------------
signed int __usercall sub_10028E00@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100281E0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100193A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10028E70) --------------------------------------------------------
int __cdecl sub_10028E70(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10027BB0(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_100287B0(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_10027DA0(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10028FE0) --------------------------------------------------------
signed int __cdecl sub_10028FE0(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit(a1);
    sub_10048110(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10029040) --------------------------------------------------------
char __usercall sub_10029040@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10044BD0(a1, a2, a3 + 212);
  else
    result = sub_10028DD0(a2, a3 + 148);
  return result;
}

//----- (10029070) --------------------------------------------------------
signed int __usercall sub_10029070@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10027FC0(v3, v1);
  else
    result = sub_10028E00(v3, v1);
  return result;
}

//----- (100290A0) --------------------------------------------------------
BOOL __usercall sub_100290A0@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10028DB0(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (100290E0) --------------------------------------------------------
signed int __cdecl sub_100290E0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10027D80(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10048D30(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10029070(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10029130) --------------------------------------------------------
signed int __cdecl sub_10029130(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100193A0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10029040(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100193A0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10044C70(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_100283D0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1004A0F0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1004C560(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1004C560(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10029320) --------------------------------------------------------
bool __usercall sub_10029320@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_100290A0(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (10029350) --------------------------------------------------------
int __cdecl sub_10029350(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10027BB0(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10028C40(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_100287B0(a1, v6) )
      return -15;
    sub_100283F0(a1, (int)a4);
    if ( sub_100289B0((int)a4, (int)&v7) )
    {
      sub_10037320((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10027B70((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_100290E0((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_10029320((int)a4) )
    {
      result = sub_10027A70((int)a4);
    }
    else
    {
      sub_10028FE0((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10029460) --------------------------------------------------------
signed int __cdecl sub_10029460(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10029130(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10027A80(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100294C0) --------------------------------------------------------
signed int __cdecl sub_100294C0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100290E0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10027D80(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100290E0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10029460(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10029650) --------------------------------------------------------
int __cdecl sub_10029650(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10027BB0(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10028C40(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10027B70((int)a4, 0);
          sub_100283F0(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_10027B70((int)a4, 0);
          sub_100194E0(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_10029070((int)a4);
          result = sub_10027A70((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10028E70(a1, a2, 0);
      if ( result >= 0 )
        result = sub_10029350(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10029840) --------------------------------------------------------
bool __cdecl sub_10029840(unsigned int a1)
{
  return a1 - 108100 <= 0xF0A && a1 / 0x64 & 1;
}

//----- (10029870) --------------------------------------------------------
char __cdecl sub_10029870(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_1000F100(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_1000F100(0, 183, a2);
  }
  return result;
}

//----- (100298C0) --------------------------------------------------------
char __cdecl sub_100298C0(char a1, char *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  char v4; // [sp+10h] [bp-Ch]@2

  if ( sub_10029870(a1, &v3) != 1 || !v4 || v3 & 0x100 )
  {
    result = 0;
    if ( v3 & 0x200 )
      strcpy(a2, "___");
    else
      strcpy(a2, "____");
  }
  else
  {
    sub_1001F7C0((int)a2, &v4, 7);
    result = 1;
  }
  return result;
}

//----- (10029980) --------------------------------------------------------
char __cdecl sub_10029980(char a1, _WORD *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  __int16 v4; // [sp+Eh] [bp-Eh]@4

  if ( sub_10029870(a1, &v3) && !(v3 & 0x100) && v3 & 0x200 )
  {
    *a2 = v4;
    result = 1;
  }
  else
  {
    *a2 = v4;
    result = 0;
  }
  return result;
}

//----- (100299F0) --------------------------------------------------------
char __cdecl sub_100299F0(int a1)
{
  char result; // al@6

  if ( (_WORD)a1 != 552 && (_WORD)a1 != 557
    || !sub_1000F100(1, a1, &a1)
    || sub_10038300((int)&a1)
    || !(BYTE2(a1) & 0x10)
    || (result = 1, !(BYTE2(a1) & 0x20)) )
  {
    result = 0;
  }
  return result;
}

//----- (10029A40) --------------------------------------------------------
char sub_10029A40()
{
  return 0;
}

//----- (10029A50) --------------------------------------------------------
int __cdecl sub_10029A50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E7B0(&a1, 1u, (int)&unk_100ACD28, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100ACD2C + 2 * v1);
  return result;
}
// 100ACD2C: using guessed type void *off_100ACD2C;

//----- (10029A90) --------------------------------------------------------
char __cdecl sub_10029A90(char a1, char a2, __int16 a3)
{
  char v3; // bl@1
  int v4; // eax@1
  char result; // al@2
  char v6; // cl@3

  v3 = 3;
  v4 = sub_10029A80(a1);
  if ( v4 )
  {
    v6 = 0;
    do
    {
      if ( *(_BYTE *)v4 == a2 && *(_WORD *)(v4 + 2) == a3 )
        v3 = v6;
      ++v6;
      v4 += 4;
    }
    while ( (unsigned __int8)v6 < 3u );
    result = v3;
  }
  else
  {
    result = 3;
  }
  return result;
}
// 10029A80: using guessed type _DWORD __cdecl sub_10029A80(char);

//----- (10029AD0) --------------------------------------------------------
char __cdecl sub_10029AD0(char a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  int v4; // eax@1

  v4 = sub_10029A80(a1);
  if ( v4 && a2 < 3u )
  {
    *a3 = *(_BYTE *)(v4 + 4 * a2);
    *a4 = *(_WORD *)(v4 + 4 * a2 + 2);
  }
  return 0;
}
// 10029A80: using guessed type _DWORD __cdecl sub_10029A80(char);

//----- (10029B10) --------------------------------------------------------
int __cdecl sub_10029B10(int a1, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
    result = sub_10018640(9921, a1, 1);
  else
    result = sub_10018640(9922, a1, 1);
  return result;
}

//----- (10029B50) --------------------------------------------------------
int __cdecl sub_10029B50(int a1, float a2)
{
  int result; // eax@1

  result = (signed int)(sub_1004CBD0(a2) * 683565248.0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (10029B80) --------------------------------------------------------
char __cdecl sub_10029B80(void *a1)
{
  return sub_10020020(18, a1);
}

//----- (10029B90) --------------------------------------------------------
char __cdecl sub_10029B90(void *a1)
{
  return sub_10020020(19, a1);
}

//----- (10029BA0) --------------------------------------------------------
int __usercall sub_10029BA0@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_10019CB0(a1);
    result = v2 + sub_10019CB0(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10029BD0) --------------------------------------------------------
bool __cdecl sub_10029BD0(char a1, int *a2)
{
  void *v2; // ecx@0
  int *v3; // edi@1
  int v4; // esi@1
  char v5; // bl@1
  int *v6; // ebp@1
  char v7; // al@3
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@3
  int v11; // [sp+18h] [bp-8h]@1
  int v12; // [sp+1Ch] [bp-4h]@1
  char v13; // [sp+28h] [bp+8h]@1

  v3 = a2;
  v11 = 1;
  v12 = 2;
  *a2 = 0;
  v4 = 0;
  v5 = 0;
  v9 = sub_1001FDC0(v2);
  v13 = 0;
  v6 = &v11;
  do
  {
    if ( v9 & *v6 )
    {
      v7 = sub_1001EA70(v13, 1);
      if ( sub_1001FFA0(16, v7, &v10) )
        *v3 += (v10 - *v3) / ++v4;
    }
    ++v5;
    ++v6;
    v13 = v5;
  }
  while ( (unsigned __int8)v5 < 2u );
  if ( v4 > 0 )
    *v3 = sub_10029BA0(a1, *v3);
  return v4 > 0;
}

//----- (10029C80) --------------------------------------------------------
char __cdecl sub_10029C80(float *a1)
{
  char v1; // bl@1
  float v3; // [sp+4h] [bp-4h]@1

  v1 = 0;
  if ( sub_1001D880(&v3) && (unsigned __int8)sub_1001D470() )
  {
    sub_100182A0(100, 60000);
    if ( *(float *)(dword_10223500 + 1548) > -32767.0 )
    {
      v1 = 1;
      *a1 = v3 - *(float *)(dword_10223500 + 1548);
    }
    sub_10018280(100);
  }
  return v1;
}
// 10223500: using guessed type int dword_10223500;

//----- (10029CF0) --------------------------------------------------------
int __cdecl sub_10029CF0(void *a1)
{
  int result; // eax@6

  if ( !sub_1000F100(0, 196, a1) )
    return 0;
  if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 7620.0 )
  {
    result = 0;
    *(float *)a1 = 7620.0;
  }
  else
  {
    if ( *(float *)a1 < -3048.0 )
    {
      *(float *)a1 = -3048.0;
      return 0;
    }
    result = 1;
  }
  return result;
}

//----- (10029D60) --------------------------------------------------------
char *__cdecl sub_10029D60(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1004A150("CFG_ActDir", (int)&byte_10065A71);
      v10 = sub_1004A150("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1004A150("CFG_ExpDir", (int)&byte_10065A71);
      v10 = sub_1004A150("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1004A150("CFG_ActDir", (int)&byte_10065A71);
      break;
    case 4:
      v10 = sub_1004A150("CFG_ExpDir", (int)&byte_10065A71);
      break;
    default:
      v10 = &byte_10065A71;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = (char *)&unk_1008B778, v14) )
    v15 = &byte_10065A71;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 10029D60: using guessed type char var_104[256];

//----- (10029EE0) --------------------------------------------------------
int sub_10029EE0()
{
  return dword_1019C1A8[sub_1003A5B0()];
}
// 1019C1A8: using guessed type int dword_1019C1A8[];

//----- (10029EF0) --------------------------------------------------------
const char *__cdecl sub_10029EF0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_100AD5EC[a1];
  return result;
}
// 100AD5EC: using guessed type char *off_100AD5EC[7];

//----- (10029F10) --------------------------------------------------------
int __cdecl sub_10029F10(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1002F1F0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (10029FC0) --------------------------------------------------------
int __cdecl sub_10029FC0(int a1)
{
  int result; // eax@1

  result = sub_1003A5B0();
  dword_1019E2B4[result] = a1;
  return result;
}
// 1019E2B4: using guessed type int dword_1019E2B4[];

//----- (10029FE0) --------------------------------------------------------
int __cdecl sub_10029FE0(int a1)
{
  int result; // eax@1

  result = sub_1003A5B0();
  dword_1019C1A8[result] = a1;
  return result;
}
// 1019C1A8: using guessed type int dword_1019C1A8[];

//----- (1002A000) --------------------------------------------------------
char *sub_1002A000(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_1003A5B0() << 8;
  _vsnprintf(&byte_101975B8[v1], 0x100u, a1, va);
  result = &byte_101975B8[v1];
  byte_101976B6[v1] = 42;
  byte_101976B7[v1] = 0;
  return result;
}

//----- (1002A040) --------------------------------------------------------
char *__usercall sub_1002A040@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100AD600[a1 & 1];
  else
    result = off_100AD5F8[a2];
  return result;
}
// 100AD5F8: using guessed type char *off_100AD5F8[4];
// 100AD600: using guessed type char *off_100AD600[2];

//----- (1002A060) --------------------------------------------------------
char __usercall sub_1002A060@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_1003A5B0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_10029EE0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_1019F8A8[v6];
      v12 = dword_1019F8BC[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_1019C1BC[v6];
      v12 = dword_1019E2A0[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 1019C1BC: using guessed type int dword_1019C1BC[];
// 1019E2A0: using guessed type int dword_1019E2A0[];
// 1019F8A8: using guessed type int dword_1019F8A8[];
// 1019F8BC: using guessed type int dword_1019F8BC[];

//----- (1002A240) --------------------------------------------------------
int sub_1002A240()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1002A260) --------------------------------------------------------
int sub_1002A260()
{
  return nullsub_1(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1002A280) --------------------------------------------------------
int __cdecl sub_1002A280(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1003A5B0();
  dword_1019E2A0[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1019C1BC[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1002A000(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1002F1B0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_1019C1BC[result] = 8;
  }
  return result;
}
// 1019C1BC: using guessed type int dword_1019C1BC[];
// 1019E2A0: using guessed type int dword_1019E2A0[];

//----- (1002A2E0) --------------------------------------------------------
int __cdecl sub_1002A2E0(int a1)
{
  return sub_1002A280(0, a1);
}

//----- (1002A2F0) --------------------------------------------------------
int __cdecl sub_1002A2F0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1003A5B0();
  dword_1019F8BC[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1019F8A8[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1002A000(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1002F1B0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_1019F8A8[result] = 8;
  }
  return result;
}
// 1019F8A8: using guessed type int dword_1019F8A8[];
// 1019F8BC: using guessed type int dword_1019F8BC[];

//----- (1002A350) --------------------------------------------------------
int __cdecl sub_1002A350(int a1)
{
  return sub_1002A2F0(0, a1);
}

//----- (1002A360) --------------------------------------------------------
bool __cdecl sub_1002A360(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_1003B510() )
    v8 = v8 == 0;
  v9 = (&off_100AD5D0)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_100AD5C0[v8 != 0];
  v19 = off_100AD5C8[a1];
  v18 = v10;
  v21 = sub_1002A040(0, a6);
  v22 = sub_1002A040(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v14, v11);
  sub_1004A4B0(v12);
  return v8;
}
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002A4A0) --------------------------------------------------------
bool __cdecl sub_1002A4A0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_1003A5B0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_1003B510() )
    v16 = v16 == 0;
  sub_1002A060((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_101985A8[v11], 0x400u, &v30, a6);
  byte_101989A6[v11] = 42;
  byte_101989A7[v11] = 0;
  v17 = sub_1002A060((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v11], 0x400u, &v30, a7);
  byte_10198DA6[v11] = 42;
  byte_10198DA7[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_10198DA8[v11];
    byte_10198DA8[v11] = 0;
  }
  else
  {
    v17 = sub_1002A060((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_10198DA8[v11];
    _snprintf(&byte_10198DA8[v11], 0x400u, &v30, 0);
    byte_101991A6[v11] = 42;
    byte_101991A7[v11] = 0;
  }
  v19 = (&off_100AD5D0)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_101985A8[v11];
  v27 = &byte_101989A8[v11];
  v13 = off_100AD5C8[a1];
  v23 = off_100AD5C0[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v14);
  return v16;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002A850) --------------------------------------------------------
bool __cdecl sub_1002A850(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_1003A5B0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_1003B510() )
    v20 = v20 == 0;
  sub_1002A060((int)&v34, (char *)&unk_100AD8D8, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_101985A8[v12], 0x400u, &v34);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v21 = sub_1002A060((int)&v34, (char *)&unk_100AD8D8, 3, 0xCu, a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v34, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v13 = &byte_10198DA8[v12];
    v21 = sub_1002A060((int)&v34, (char *)&unk_100AD8D8, 3, 0xCu, v10);
    _snprintf(&byte_10198DA8[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v23 = (&off_100AD5D0)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_101985A8[v12];
  v32 = v13;
  v17 = off_100AD5C8[a1];
  v27 = off_100AD5C0[v20 != 0];
  v28 = v17;
  v31 = &byte_101989A8[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v18);
  return v20;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002ACA0) --------------------------------------------------------
bool __cdecl sub_1002ACA0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_1003A5B0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_1003B510() )
    v25 = v25 == 0;
  sub_1002A060((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_101985A8[v20], 0x400u, &v40);
  byte_101989A6[v20] = 42;
  byte_101989A7[v20] = 0;
  v26 = sub_1002A060((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_101989A8[v20], 0x400u, &v40, a7);
  byte_10198DA6[v20] = 42;
  byte_10198DA7[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_10198DA8[v20];
    byte_10198DA8[v20] = 0;
  }
  else
  {
    v21 = &byte_10198DA8[v20];
    v26 = sub_1002A060((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_10198DA8[v20], 0x400u, &v40, v28);
    byte_101991A6[v20] = 42;
    byte_101991A7[v20] = 0;
  }
  v29 = (&off_100AD5D0)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_101985A8[v20];
  v37 = &byte_101989A8[v20];
  v38 = v21;
  v22 = off_100AD5C0[v25 != 0];
  v34 = off_100AD5C8[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v23);
  return v25;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002B160) --------------------------------------------------------
bool __cdecl sub_1002B160(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_100AD924;
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002B520) --------------------------------------------------------
bool __cdecl sub_1002B520(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v13 = &byte_10198DA8[v12];
    v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101985A8[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C8[a1];
  v24 = off_100AD5C0[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002B920) --------------------------------------------------------
bool __cdecl sub_1002B920(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002BCE0) --------------------------------------------------------
bool __cdecl sub_1002BCE0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_1003A5B0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_1003B510() )
        v18 = v18 == 0;
      sub_1002A060((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_101985A8[3072 * v21], 0x400u, &v33, a6);
      byte_101989A6[v13] = 42;
      byte_101989A7[v13] = 0;
      v19 = sub_1002A060((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_101989A8[3072 * v21], 0x400u, &v33, a7);
      byte_10198DA6[v13] = 42;
      byte_10198DA7[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_10198DA8[v13];
        byte_10198DA8[v13] = 0;
      }
      else
      {
        v19 = sub_1002A060((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_10198DA8[v13];
        _snprintf(&byte_10198DA8[v13], 0x400u, &v33, a8);
        byte_101991A6[v13] = 42;
        byte_101991A7[v13] = 0;
      }
      v22 = (&off_100AD5D0)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_101985A8[3072 * v21];
      v30 = &byte_101989A8[3072 * v21];
      v15 = off_100AD5C8[a1];
      v26 = off_100AD5C0[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1004A4A0();
      sub_1002F0C0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1002F1B0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1004A4B0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002C220) --------------------------------------------------------
bool __cdecl sub_1002C220(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v13 = &byte_10198DA8[v12];
    v18 = sub_1002A060((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101985A8[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C8[a1];
  v24 = off_100AD5C0[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002C600) --------------------------------------------------------
bool __cdecl sub_1002C600(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002C9C0) --------------------------------------------------------
bool __cdecl sub_1002C9C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002CD60) --------------------------------------------------------
bool __cdecl sub_1002CD60(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v13 = &byte_10198DA8[v12];
    v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101985A8[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C8[a1];
  v24 = off_100AD5C0[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002D160) --------------------------------------------------------
bool __cdecl sub_1002D160(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002D500) --------------------------------------------------------
bool __cdecl sub_1002D500(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_1003A5B0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_1003B510() )
        v19 = v19 == 0;
      sub_1002A060((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_101985A8[3072 * v22];
      _snprintf(&byte_101985A8[3072 * v22], 0x400u, &v35, a6);
      byte_101989A6[v13] = 42;
      byte_101989A7[v13] = 0;
      v20 = sub_1002A060((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_101989A8[3072 * v22];
      _snprintf(&byte_101989A8[v13], 0x400u, &v35, a7);
      byte_10198DA6[v13] = 42;
      byte_10198DA7[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_10198DA8[v13];
        byte_10198DA8[v13] = 0;
      }
      else
      {
        v20 = sub_1002A060((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_10198DA8[v13];
        _snprintf(&byte_10198DA8[v13], 0x400u, &v35, a8);
        byte_101991A6[v13] = 42;
        byte_101991A7[v13] = 0;
      }
      v24 = (&off_100AD5D0)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_100AD5C8[a1];
      v28 = off_100AD5C0[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1004A4A0();
      sub_1002F0C0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_1002F1B0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1004A4B0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002DAE0) --------------------------------------------------------
bool __cdecl sub_1002DAE0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v13 = &byte_10198DA8[v12];
    v18 = sub_1002A060((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101985A8[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_101989A8[v12];
  v29 = v13;
  v14 = off_100AD5C8[a1];
  v24 = off_100AD5C0[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002DED0) --------------------------------------------------------
bool __cdecl sub_1002DED0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003A5B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003B510() )
    v17 = v17 == 0;
  sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101985A8[v12], 0x400u, &v31, a6);
  byte_101989A6[v12] = 42;
  byte_101989A7[v12] = 0;
  v18 = sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101989A8[v12], 0x400u, &v31, a7);
  byte_10198DA6[v12] = 42;
  byte_10198DA7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10198DA8[v12];
    byte_10198DA8[v12] = 0;
  }
  else
  {
    v18 = sub_1002A060((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10198DA8[v12];
    _snprintf(&byte_10198DA8[v12], 0x400u, &v31, a8);
    byte_101991A6[v12] = 42;
    byte_101991A7[v12] = 0;
  }
  v20 = (&off_100AD5D0)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_100AD5C0[v17 != 0];
  v25 = off_100AD5C8[a1];
  v24 = v14;
  v27 = &byte_101985A8[v12];
  v28 = &byte_101989A8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_1002F1B0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1004A4B0(v15);
  return v17;
}
// 1003A550: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002E270) --------------------------------------------------------
int sub_1002E270()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_1003A5B0();
  sub_10029FC0(1);
  sub_1002A350(-1);
  result = sub_1002A2E0(-1);
  dword_1019C1A8[v0] = 0;
  return result;
}
// 1019C1A8: using guessed type int dword_1019C1A8[];

//----- (1002E2A0) --------------------------------------------------------
BOOL __usercall sub_1002E2A0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_1003A5B0();
  sub_1004A4E0((int)&v13);
  sub_1004A4E0((int)&v14);
  sub_1004A4E0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_1004B130((int (__cdecl *)(unsigned int))sub_1002A240, v7, (int)&v13) )
  {
    if ( sub_1004B130((int (__cdecl *)(unsigned int))sub_1002A240, a2, (int)&v14) )
    {
      v9 = sub_1004AFA0(
             dword_1019E2B4[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1002A240,
             (void (__cdecl *)(_DWORD))sub_1002A260,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_1004B3D0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1004A5B0((void (__cdecl *)(_DWORD))sub_1002A260, (int)&v12);
  sub_1004A5B0((void (__cdecl *)(_DWORD))sub_1002A260, (int)&v13);
  sub_1004A5B0((void (__cdecl *)(_DWORD))sub_1002A260, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1019E2B4: using guessed type int dword_1019E2B4[];

//----- (1002E410) --------------------------------------------------------
bool __usercall sub_1002E410@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_1003A5B0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_1003B510() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1002C9C0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_1003B510() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_101985A8[3072 * v24], 0x400u, "%s", v9);
  byte_101989A6[v15] = 42;
  byte_101989A7[v15] = 0;
  _snprintf(&byte_101989A8[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_100AD5D0)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_10198DA6[v15] = 42;
  v17 = off_100AD5C0[v14 != 0];
  v18 = off_100AD5C8[a3];
  byte_10198DA7[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_101985A8[3072 * v24];
  v34 = &byte_101989A8[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v26, v19);
  sub_1004A4B0(v20);
  return v14;
}
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;

//----- (1002E680) --------------------------------------------------------
char __cdecl sub_1002E680(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_1003A5B0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1019E2B4[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_1019F8D0[v10];
  sub_10029D60(a3, 1, a6, 0x230u, &byte_1019F8D0[v10]);
  v27 = &byte_1019C1D0[v10];
  sub_10029D60(a3, 2, a7, 0x230u, &byte_1019C1D0[v10]);
  v24 = &byte_1019D7B0[v10];
  sub_10029D60(a3, 3, a6, 0x230u, &byte_1019D7B0[v10]);
  v26 = &byte_1019E2C8[v10];
  sub_10029D60(a3, 4, a7, 0x230u, &byte_1019E2C8[v10]);
  _snprintf(&byte_1019EDB8[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_1019EDB8[v10];
  byte_1019EFE7[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_10029D60(a3, 0, v25, 560 - (v11 - &byte_1019EDB8[v10 + 1]), &byte_1019EDB8[v10] + v11 - &byte_1019EDB8[v10 + 1]);
  v13 = &byte_1019EDB8[v10];
  byte_1019EFE7[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1019EDB4[v10] + v13 - &byte_1019EDB8[v10 + 1]) = 0;
  sub_10029D60(a3, 1, (int)&byte_1019EDB8[v10], 0x230u, &byte_10197AB8[v10]);
  sub_10029D60(a3, 1, (int)&byte_1019EDB8[v10], 0x230u, &byte_1019CCC0[v10]);
  v15 = sub_1002E2A0(v22, v27, v21, a2 == 1, (int)&byte_10197AB8[v10], (const char **)&v22);
  if ( sub_1003B510() )
    v15 = v15 == 0;
  v30 = (&off_100AD5D0)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_100AD5C8[a1];
  v34 = off_100AD5C0[v15 != 0];
  v17 = dword_1019E2B4[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1004A4A0();
  sub_1002F0C0(7, (int)&v30, v18);
  sub_1004A4B0(v19);
  return v15;
}
// 100AD5C0: using guessed type char *off_100AD5C0[5];
// 100AD5C8: using guessed type char *off_100AD5C8[3];
// 100AD5D0: using guessed type char *off_100AD5D0;
// 1019E2B4: using guessed type int dword_1019E2B4[];

//----- (1002E980) --------------------------------------------------------
bool __cdecl sub_1002E980(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, _DWORD *a7, unsigned int a8, int a9)
{
  unsigned int v9; // eax@1
  _DWORD *v10; // ecx@1
  _DWORD *v11; // edx@1
  int v12; // esi@5
  int v13; // eax@6
  _BYTE *v14; // ecx@6
  _BYTE *v15; // edx@6
  int v16; // eax@8
  _BYTE *v17; // ecx@8
  _BYTE *v18; // edx@8
  _BYTE *v19; // ecx@10
  _BYTE *v20; // edx@10
  int v21; // eax@12
  char v23; // [sp+18h] [bp-104h]@1
  char v24; // [sp+117h] [bp-5h]@1

  _snprintf(&v23, 0x100u, "%s - memcmp result", a5);
  v9 = a8;
  v10 = a7;
  v11 = a6;
  v24 = 0;
  if ( a8 < 4 )
  {
LABEL_4:
    if ( !v9 )
    {
LABEL_14:
      v21 = 0;
      return sub_1002B160(a1, a2, a3, a4, a5, v21, 0, 0, a9);
    }
  }
  else
  {
    while ( *v11 == *v10 )
    {
      v9 -= 4;
      ++v10;
      ++v11;
      if ( v9 < 4 )
        goto LABEL_4;
    }
  }
  v12 = *(_BYTE *)v11 - *(_BYTE *)v10;
  if ( *(_BYTE *)v11 == *(_BYTE *)v10 )
  {
    v13 = v9 - 1;
    v14 = (char *)v10 + 1;
    v15 = (char *)v11 + 1;
    if ( !v13 )
      goto LABEL_14;
    v12 = *v15 - *v14;
    if ( *v15 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = v15 + 1;
      if ( !v16 )
        goto LABEL_14;
      v12 = *v18 - *v17;
      if ( *v18 == *v17 )
      {
        v19 = v17 + 1;
        v20 = v18 + 1;
        if ( v16 == 1 )
          goto LABEL_14;
        v12 = *v20 - *v19;
        if ( *v20 == *v19 )
          goto LABEL_14;
      }
    }
  }
  v21 = 1;
  if ( v12 <= 0 )
    v21 = -1;
  return sub_1002B160(a1, a2, a3, a4, a5, v21, 0, 0, a9);
}

//----- (1002EAB0) --------------------------------------------------------
bool __cdecl sub_1002EAB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1002B160(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1002EB60) --------------------------------------------------------
bool __cdecl sub_1002EB60(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1002E410(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1002EBA0) --------------------------------------------------------
char __cdecl sub_1002EBA0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_1003B4F0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1004A150("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1003C290() )
          v7 = 0;
      }
      v5 = sub_1004A150("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1003C290() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1002ECB0) --------------------------------------------------------
char __cdecl sub_1002ECB0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1002ECE0) --------------------------------------------------------
bool __cdecl sub_1002ECE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1002ED10) --------------------------------------------------------
bool __cdecl sub_1002ED10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1002ED40) --------------------------------------------------------
bool __cdecl sub_1002ED40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1002ED70) --------------------------------------------------------
bool __cdecl sub_1002ED70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1002EDA0) --------------------------------------------------------
bool __cdecl sub_1002EDA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1002EDD0) --------------------------------------------------------
bool __cdecl sub_1002EDD0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1002EE10) --------------------------------------------------------
bool __cdecl sub_1002EE10(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1002EE50) --------------------------------------------------------
bool __cdecl sub_1002EE50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1002EE80) --------------------------------------------------------
bool __cdecl sub_1002EE80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1002EEB0) --------------------------------------------------------
char __cdecl sub_1002EEB0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1002EEE0) --------------------------------------------------------
bool __cdecl sub_1002EEE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1002EF10) --------------------------------------------------------
bool __cdecl sub_1002EF10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1002EF40) --------------------------------------------------------
bool __cdecl sub_1002EF40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1002EF70) --------------------------------------------------------
bool __cdecl sub_1002EF70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1002EFA0) --------------------------------------------------------
bool __cdecl sub_1002EFA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100ADB74, 9u);
}

//----- (1002EFD0) --------------------------------------------------------
bool __cdecl sub_1002EFD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1002F000) --------------------------------------------------------
bool __cdecl sub_1002F000(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1002F030) --------------------------------------------------------
bool __cdecl sub_1002F030(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1002F060) --------------------------------------------------------
bool __cdecl sub_1002F060(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1002F090) --------------------------------------------------------
bool __cdecl sub_1002F090(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1002F0C0) --------------------------------------------------------
int __cdecl sub_1002F0C0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_1003B4F0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1002F130) --------------------------------------------------------
int __cdecl sub_1002F130(int a1, char a2)
{
  return sub_1002F0C0(a1, (int)&a2, 1);
}

//----- (1002F150) --------------------------------------------------------
int __cdecl sub_1002F150(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1002F0C0(a1, (int)&v4, 2);
}

//----- (1002F180) --------------------------------------------------------
int __cdecl sub_1002F180(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1002F0C0(a1, (int)&v5, 3);
}

//----- (1002F1B0) --------------------------------------------------------
int __cdecl sub_1002F1B0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1002F0C0(a1, (int)&v6, 4);
}

//----- (1002F1F0) --------------------------------------------------------
int __cdecl sub_1002F1F0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1002F0C0(a1, (int)&v7, 5);
}

//----- (1002F230) --------------------------------------------------------
int __cdecl sub_1002F230(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1002F0C0(a1, (int)&v8, 6);
}

//----- (1002F280) --------------------------------------------------------
char __cdecl sub_1002F280(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_1003B4F0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1002F2B0) --------------------------------------------------------
char __cdecl sub_1002F2B0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1002F2C0) --------------------------------------------------------
char __cdecl sub_1002F2C0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = (char *)&unk_1008B778, v3) )
          v11 = &byte_10065A71;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1004B450(v16) )
        sub_1004B430((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1004B460((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1004B450: using guessed type _DWORD __cdecl sub_1004B450(_DWORD);
// 1002F2C0: using guessed type char var_104[255];

//----- (1002F440) --------------------------------------------------------
signed int __cdecl sub_1002F440(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1002F480) --------------------------------------------------------
signed int __cdecl sub_1002F480(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1002F520) --------------------------------------------------------
char __cdecl sub_1002F520(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1002F580) --------------------------------------------------------
char __cdecl sub_1002F580(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1004B410(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1002F5F0) --------------------------------------------------------
char *__cdecl sub_1002F5F0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_101A03C0, v1, v2);
  *(&byte_101A03C0 + v2) = 0;
  return &byte_101A03C0;
}

//----- (1002F690) --------------------------------------------------------
int __cdecl sub_1002F690(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1002F700) --------------------------------------------------------
bool __cdecl sub_1002F700(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1004F1A8(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1004F1A8(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1002F790) --------------------------------------------------------
char __cdecl sub_1002F790(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1002F840) --------------------------------------------------------
char __cdecl sub_1002F840(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1002F850) --------------------------------------------------------
char __cdecl sub_1002F850(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1004B410(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1002F8D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002F8D0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1004B4E0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1002F920) --------------------------------------------------------
signed int __cdecl sub_1002F920(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1002F850(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1002F970) --------------------------------------------------------
signed int __cdecl sub_1002F970(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_101A04C1 = 1;
    byte_101A04C0 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101A04C0 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101A04C1 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (1002F9D0) --------------------------------------------------------
bool __cdecl sub_1002F9D0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1002F180(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100C5798, (int)"failing_subroutine( depth-1 )");
    sub_1002F9D0(a1 - 1);
    exit_0(14);
  }
  return sub_1002EB60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1002FA40) --------------------------------------------------------
int sub_1002FA40()
{
  const char *v0; // eax@1

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_101A04C0 )
  {
    sub_1002EB60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1002F180(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1002F9D0(1);
    exit_0(14);
  }
  return sub_1002F1B0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (1002FD60) --------------------------------------------------------
char sub_1002FD60()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A04C0 )
  {
    v2 = 0;
    do
    {
      if ( off_100AE80C[v2] )
      {
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100AE814[v2 * 4], 0x100u, &v11);
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100AE80C[v2], 0x100u, &v12);
        sub_1004B500(&v12, &v11);
      }
      if ( byte_100AE808[v2 * 4] )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100AE810[v2];
        v4 = *(char **)&off_100AE814[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AE814[v2 * 4],
               off_100AE810[v2]);
        v6 = sub_1002E680(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1002A360(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)&unk_10088A84,
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100AE810[v2];
        v8 = *(char **)&off_100AE814[v2 * 4];
        v9 = sub_1002A000(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AE814[v2 * 4],
               off_100AE810[v2]);
        v10 = sub_1002E680(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1002A360(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)&unk_100889E4,
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)&unk_10088C18,
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100AE80C: using guessed type char *off_100AE80C[3];
// 100AE810: using guessed type char *off_100AE810[2];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (1002FF80) --------------------------------------------------------
char sub_1002FF80()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A04C0 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1002A360(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)&unk_100888B4,
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1002A360(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)&unk_1008887C,
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)&unk_10088878, 2, 2);
    v4 = sub_1002A360(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100887F8, 2, 2);
    v5 = sub_1002A360(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1002A360(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)&unk_100887F4,
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030180) --------------------------------------------------------
char sub_10030180()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AE89C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100AE899[v2 * 4];
        v4 = byte_100AE898[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + dword_100AE89C[v2])],
               (&off_100AE8A0)[v2 * 4]);
        v6 = sub_1002A4A0(
               0,
               *(&dword_100AE7EC + dword_100AE89C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1002A000(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100AE89C[v2]],
               (&off_100AE8A0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AE89C: using guessed type int dword_100AE89C[];
// 100AE8A0: using guessed type char *off_100AE8A0;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030300) --------------------------------------------------------
char sub_10030300()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AEB20[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100AEB18[v2 / 8];
        v4 = dbl_100AEB10[v2 / 8];
        v5 = dbl_100AEB08[v2 / 8];
        v6 = sub_1002A000(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100AEB24)[v2]);
        v7 = sub_1002A850(
               0,
               *(&dword_100AE7EC + dword_100AEB20[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100AEB20[v2 / 4]],
               (&off_100AEB24)[v2]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AEB08: using guessed type double dbl_100AEB08[];
// 100AEB10: using guessed type double dbl_100AEB10[];
// 100AEB18: using guessed type double dbl_100AEB18[];
// 100AEB20: using guessed type int dword_100AEB20[];
// 100AEB24: using guessed type char *off_100AEB24;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030480) --------------------------------------------------------
char sub_10030480()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF734[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100AF730[v2];
        v4 = flt_100AF72C[v2];
        v5 = flt_100AF728[v2];
        v6 = sub_1002A000(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100AF738[v2 * 4]);
        v7 = sub_1002ACA0(
               0,
               *(&dword_100AE7EC + dword_100AF734[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100AF734[v2]],
               *(_DWORD *)&off_100AF738[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF728: using guessed type float flt_100AF728[];
// 100AF72C: using guessed type float flt_100AF72C[];
// 100AF730: using guessed type float flt_100AF730[];
// 100AF734: using guessed type int dword_100AF734[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100305F0) --------------------------------------------------------
char sub_100305F0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A04C0 )
  {
    sub_1002EAB0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_100305F0,
      (int)sub_100305F0,
      (int)"This test is expected to fail");
    sub_1002EAB0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_100305F0,
      0,
      (int)"This test is expected to fail");
    result = sub_1002EAB0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100305F0,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100306F0) --------------------------------------------------------
char sub_100306F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AFEDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AFED8[v2];
        v4 = dword_100AFED4[v2];
        v5 = dword_100AFED0[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100AFEE0)[v2 * 4]);
        v7 = sub_1002B160(
               0,
               *(&dword_100AE7EC + dword_100AFEDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100AFEDC[v2]],
               (&off_100AFEE0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AFED0: using guessed type int dword_100AFED0[];
// 100AFED4: using guessed type int dword_100AFED4[];
// 100AFED8: using guessed type int dword_100AFED8[];
// 100AFEDC: using guessed type int dword_100AFEDC[];
// 100AFEE0: using guessed type char *off_100AFEE0;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030850) --------------------------------------------------------
char sub_10030850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B0670[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B066C[v2 / 2];
        v4 = word_100B066A[v2 / 2];
        v5 = word_100B0668[v2 / 2];
        v6 = sub_1002A000(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B0674)[v2]);
        v7 = sub_1002B520(
               0,
               *(&dword_100AE7EC + dword_100B0670[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B0670[v2 / 4]],
               (&off_100B0674)[v2]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0668: using guessed type __int16 word_100B0668[];
// 100B066A: using guessed type __int16 word_100B066A[];
// 100B066C: using guessed type __int16 word_100B066C[];
// 100B0670: using guessed type int dword_100B0670[];
// 100B0674: using guessed type char *off_100B0674;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100309B0) --------------------------------------------------------
char sub_100309B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B0C84[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B0C80[v2];
        v4 = dword_100B0C7C[v2];
        v5 = dword_100B0C78[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B0C88[v2 * 4]);
        v7 = sub_1002B920(
               0,
               *(&dword_100AE7EC + dword_100B0C84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B0C84[v2]],
               *(_DWORD *)&off_100B0C88[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0C78: using guessed type int dword_100B0C78[];
// 100B0C7C: using guessed type int dword_100B0C7C[];
// 100B0C80: using guessed type int dword_100B0C80[];
// 100B0C84: using guessed type int dword_100B0C84[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030B10) --------------------------------------------------------
char sub_10030B10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B1428[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B1424[v2];
        LODWORD(v3) = dword_100B1420[v2];
        HIDWORD(v4) = dword_100B141C[v2];
        LODWORD(v4) = dword_100B1418[v2];
        HIDWORD(v5) = dword_100B1414[v2];
        LODWORD(v5) = dword_100B1410[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B142C[v2 * 4]);
        v7 = sub_1002BCE0(
               0,
               *(&dword_100AE7EC + dword_100B1428[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B1428[v2]],
               *(_DWORD *)&off_100B142C[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B1410: using guessed type int dword_100B1410[];
// 100B1414: using guessed type int dword_100B1414[];
// 100B1418: using guessed type int dword_100B1418[];
// 100B141C: using guessed type int dword_100B141C[];
// 100B1420: using guessed type int dword_100B1420[];
// 100B1424: using guessed type int dword_100B1424[];
// 100B1428: using guessed type int dword_100B1428[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030C80) --------------------------------------------------------
char sub_10030C80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B2034[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B2032[v2 * 4];
        v4 = byte_100B2031[v2 * 4];
        v5 = byte_100B2030[v2 * 4];
        v6 = sub_1002A000(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B2038)[v2 * 4]);
        v7 = sub_1002C220(
               0,
               *(&dword_100AE7EC + dword_100B2034[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B2034[v2]],
               (&off_100B2038)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B2034: using guessed type int dword_100B2034[];
// 100B2038: using guessed type char *off_100B2038;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030DE0) --------------------------------------------------------
char sub_10030DE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B24CC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B24C8[v2];
        v4 = dword_100B24C4[v2];
        v5 = dword_100B24C0[v2];
        v6 = sub_1002A000(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B24D0)[v2 * 4]);
        v7 = sub_1002C600(
               0,
               *(&dword_100AE7EC + dword_100B24CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B24CC[v2]],
               (&off_100B24D0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B24C0: using guessed type int dword_100B24C0[];
// 100B24C4: using guessed type int dword_100B24C4[];
// 100B24C8: using guessed type int dword_100B24C8[];
// 100B24CC: using guessed type int dword_100B24CC[];
// 100B24D0: using guessed type char *off_100B24D0;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10030F40) --------------------------------------------------------
char sub_10030F40()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A04C0 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1002EB60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10065A71,
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1002EB60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           &byte_10065A71,
           "a",
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1002EB60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           &byte_10065A71,
           &byte_10065A71,
           (int)"This test is expected to fail");
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1002EB60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1002A360(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031160) --------------------------------------------------------
char sub_10031160()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B2C64[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B2C60[v2];
        v4 = dword_100B2C5C[v2];
        v5 = dword_100B2C58[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B2C68[v2 * 4]);
        v7 = sub_1002C9C0(
               0,
               *(&dword_100AE7EC + dword_100B2C64[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B2C64[v2]],
               *(_DWORD *)&off_100B2C68[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B2C58: using guessed type int dword_100B2C58[];
// 100B2C5C: using guessed type int dword_100B2C5C[];
// 100B2C60: using guessed type int dword_100B2C60[];
// 100B2C64: using guessed type int dword_100B2C64[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100312C0) --------------------------------------------------------
char sub_100312C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B2FD0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B2FCC[v2 / 2];
        v4 = word_100B2FCA[v2 / 2];
        v5 = word_100B2FC8[v2 / 2];
        v6 = sub_1002A000(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B2FD4)[v2]);
        v7 = sub_1002CD60(
               0,
               *(&dword_100AE7EC + dword_100B2FD0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B2FD0[v2 / 4]],
               (&off_100B2FD4)[v2]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B2FC8: using guessed type __int16 word_100B2FC8[];
// 100B2FCA: using guessed type __int16 word_100B2FCA[];
// 100B2FCC: using guessed type __int16 word_100B2FCC[];
// 100B2FD0: using guessed type int dword_100B2FD0[];
// 100B2FD4: using guessed type char *off_100B2FD4;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031420) --------------------------------------------------------
char sub_10031420()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3294[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B3290[v2];
        v4 = dword_100B328C[v2];
        v5 = dword_100B3288[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B3298[v2 * 4]);
        v7 = sub_1002D160(
               0,
               *(&dword_100AE7EC + dword_100B3294[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B3294[v2]],
               *(_DWORD *)&off_100B3298[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3288: using guessed type int dword_100B3288[];
// 100B328C: using guessed type int dword_100B328C[];
// 100B3290: using guessed type int dword_100B3290[];
// 100B3294: using guessed type int dword_100B3294[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031580) --------------------------------------------------------
char sub_10031580()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3610[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B360C[v2];
        LODWORD(v3) = dword_100B3608[v2];
        HIDWORD(v4) = dword_100B3604[v2];
        LODWORD(v4) = dword_100B3600[v2];
        HIDWORD(v5) = dword_100B35FC[v2];
        LODWORD(v5) = dword_100B35F8[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B3614[v2 * 4]);
        v7 = sub_1002D500(
               0,
               *(&dword_100AE7EC + dword_100B3610[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B3610[v2]],
               *(_DWORD *)&off_100B3614[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B35F8: using guessed type int dword_100B35F8[];
// 100B35FC: using guessed type int dword_100B35FC[];
// 100B3600: using guessed type int dword_100B3600[];
// 100B3604: using guessed type int dword_100B3604[];
// 100B3608: using guessed type int dword_100B3608[];
// 100B360C: using guessed type int dword_100B360C[];
// 100B3610: using guessed type int dword_100B3610[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100316F0) --------------------------------------------------------
char sub_100316F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3B7C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B3B7A[v2 * 4];
        v4 = byte_100B3B79[v2 * 4];
        v5 = byte_100B3B78[v2 * 4];
        v6 = sub_1002A000(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B3B80)[v2 * 4]);
        v7 = sub_1002DAE0(
               0,
               *(&dword_100AE7EC + dword_100B3B7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B3B7C[v2]],
               (&off_100B3B80)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3B7C: using guessed type int dword_100B3B7C[];
// 100B3B80: using guessed type char *off_100B3B80;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031850) --------------------------------------------------------
char sub_10031850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3D94[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B3D90[v2];
        v4 = dword_100B3D8C[v2];
        v5 = dword_100B3D88[v2];
        v6 = sub_1002A000(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B3D98[v2 * 4]);
        v7 = sub_1002DED0(
               0,
               *(&dword_100AE7EC + dword_100B3D94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B3D94[v2]],
               *(_DWORD *)&off_100B3D98[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3D88: using guessed type int dword_100B3D88[];
// 100B3D8C: using guessed type int dword_100B3D8C[];
// 100B3D90: using guessed type int dword_100B3D90[];
// 100B3D94: using guessed type int dword_100B3D94[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100319B0) --------------------------------------------------------
char sub_100319B0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A04C0 )
  {
    v2 = 0;
    do
    {
      if ( off_100B40FC[v2] )
      {
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B4104[v2 * 4], 0x100u, &v11);
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B40FC[v2], 0x100u, &v12);
        sub_1004B500(&v12, &v11);
      }
      if ( byte_100B40F8[v2 * 4] )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100B4100[v2];
        v4 = *(char **)&off_100B4104[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B4104[v2 * 4],
               off_100B4100[v2]);
        v6 = sub_1002E680(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1002A360(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100B4100[v2];
        v8 = *(char **)&off_100B4104[v2 * 4];
        v9 = sub_1002A000(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B4104[v2 * 4],
               off_100B4100[v2]);
        v10 = sub_1002E680(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1002A360(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100B40FC: using guessed type char *off_100B40FC[3];
// 100B4100: using guessed type char *off_100B4100[2];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031BD0) --------------------------------------------------------
char sub_10031BD0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_101A04C0 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1002A360(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1002A360(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1002A360(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1002A360(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1002A360(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031DD0) --------------------------------------------------------
char sub_10031DD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B418C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100B4189[v2 * 4];
        v4 = byte_100B4188[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + dword_100B418C[v2])],
               (&off_100B4190)[v2 * 4]);
        v6 = sub_1002A4A0(
               1,
               *(&dword_100AE7EC + dword_100B418C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1002A000(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B418C[v2]],
               (&off_100B4190)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B418C: using guessed type int dword_100B418C[];
// 100B4190: using guessed type char *off_100B4190;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10031F50) --------------------------------------------------------
char sub_10031F50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B4410[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100B4408[v2 / 8];
        v4 = dbl_100B4400[v2 / 8];
        v5 = dbl_100B43F8[v2 / 8];
        v6 = sub_1002A000(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B4414[v2]);
        v7 = sub_1002A850(
               1,
               *(&dword_100AE7EC + dword_100B4410[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B4410[v2 / 4]],
               *(_DWORD *)&off_100B4414[v2]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B43F8: using guessed type double dbl_100B43F8[];
// 100B4400: using guessed type double dbl_100B4400[];
// 100B4408: using guessed type double dbl_100B4408[];
// 100B4410: using guessed type int dword_100B4410[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100320D0) --------------------------------------------------------
char sub_100320D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B5024[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100B5020[v2];
        v4 = flt_100B501C[v2];
        v5 = flt_100B5018[v2];
        v6 = sub_1002A000(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B5028[v2 * 4]);
        v7 = sub_1002ACA0(
               1,
               *(&dword_100AE7EC + dword_100B5024[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B5024[v2]],
               *(_DWORD *)&off_100B5028[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B5018: using guessed type float flt_100B5018[];
// 100B501C: using guessed type float flt_100B501C[];
// 100B5020: using guessed type float flt_100B5020[];
// 100B5024: using guessed type int dword_100B5024[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032240) --------------------------------------------------------
char sub_10032240()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A04C0 )
  {
    sub_1002EAB0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10032240,
      (int)sub_10032240,
      0);
    sub_1002EAB0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10032240,
      0,
      0);
    result = sub_1002EAB0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10032240,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032330) --------------------------------------------------------
char sub_10032330()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B57BC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B57B8[v2];
        v4 = dword_100B57B4[v2];
        v5 = dword_100B57B0[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B57C0)[v2 * 4]);
        v7 = sub_1002B160(
               1,
               *(&dword_100AE7EC + dword_100B57BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B57BC[v2]],
               (&off_100B57C0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B57B0: using guessed type int dword_100B57B0[];
// 100B57B4: using guessed type int dword_100B57B4[];
// 100B57B8: using guessed type int dword_100B57B8[];
// 100B57BC: using guessed type int dword_100B57BC[];
// 100B57C0: using guessed type char *off_100B57C0;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032490) --------------------------------------------------------
char sub_10032490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B5F50[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B5F4C[v2 / 2];
        v4 = word_100B5F4A[v2 / 2];
        v5 = word_100B5F48[v2 / 2];
        v6 = sub_1002A000(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B5F54)[v2]);
        v7 = sub_1002B520(
               1,
               *(&dword_100AE7EC + dword_100B5F50[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B5F50[v2 / 4]],
               (&off_100B5F54)[v2]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B5F48: using guessed type __int16 word_100B5F48[];
// 100B5F4A: using guessed type __int16 word_100B5F4A[];
// 100B5F4C: using guessed type __int16 word_100B5F4C[];
// 100B5F50: using guessed type int dword_100B5F50[];
// 100B5F54: using guessed type char *off_100B5F54;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100325F0) --------------------------------------------------------
char sub_100325F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B6564[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B6560[v2];
        v4 = dword_100B655C[v2];
        v5 = dword_100B6558[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B6568[v2 * 4]);
        v7 = sub_1002B920(
               1,
               *(&dword_100AE7EC + dword_100B6564[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B6564[v2]],
               *(_DWORD *)&off_100B6568[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B6558: using guessed type int dword_100B6558[];
// 100B655C: using guessed type int dword_100B655C[];
// 100B6560: using guessed type int dword_100B6560[];
// 100B6564: using guessed type int dword_100B6564[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032750) --------------------------------------------------------
char sub_10032750()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B6D08[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B6D04[v2];
        LODWORD(v3) = dword_100B6D00[v2];
        HIDWORD(v4) = dword_100B6CFC[v2];
        LODWORD(v4) = dword_100B6CF8[v2];
        HIDWORD(v5) = dword_100B6CF4[v2];
        LODWORD(v5) = dword_100B6CF0[v2];
        v6 = sub_1002A000(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B6D0C[v2 * 4]);
        v7 = sub_1002BCE0(
               1,
               *(&dword_100AE7EC + dword_100B6D08[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B6D08[v2]],
               *(_DWORD *)&off_100B6D0C[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B6CF0: using guessed type int dword_100B6CF0[];
// 100B6CF4: using guessed type int dword_100B6CF4[];
// 100B6CF8: using guessed type int dword_100B6CF8[];
// 100B6CFC: using guessed type int dword_100B6CFC[];
// 100B6D00: using guessed type int dword_100B6D00[];
// 100B6D04: using guessed type int dword_100B6D04[];
// 100B6D08: using guessed type int dword_100B6D08[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100328C0) --------------------------------------------------------
char sub_100328C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B7914[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B7912[v2 * 4];
        v4 = byte_100B7911[v2 * 4];
        v5 = byte_100B7910[v2 * 4];
        v6 = sub_1002A000(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B7918)[v2 * 4]);
        v7 = sub_1002C220(
               1,
               *(&dword_100AE7EC + dword_100B7914[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B7914[v2]],
               (&off_100B7918)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B7914: using guessed type int dword_100B7914[];
// 100B7918: using guessed type char *off_100B7918;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032A20) --------------------------------------------------------
char sub_10032A20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B7DAC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B7DA8[v2];
        v4 = dword_100B7DA4[v2];
        v5 = dword_100B7DA0[v2];
        v6 = sub_1002A000(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B7DB0)[v2 * 4]);
        v7 = sub_1002C600(
               1,
               *(&dword_100AE7EC + dword_100B7DAC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B7DAC[v2]],
               (&off_100B7DB0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B7DA0: using guessed type int dword_100B7DA0[];
// 100B7DA4: using guessed type int dword_100B7DA4[];
// 100B7DA8: using guessed type int dword_100B7DA8[];
// 100B7DAC: using guessed type int dword_100B7DAC[];
// 100B7DB0: using guessed type char *off_100B7DB0;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032B80) --------------------------------------------------------
char sub_10032B80()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A04C0 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1002EB60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10065A71,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1002EB60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           &byte_10065A71,
           "a",
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1002EB60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           &byte_10065A71,
           &byte_10065A71,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1002EB60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1002A360(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032D80) --------------------------------------------------------
char sub_10032D80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8544[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B8540[v2];
        v4 = dword_100B853C[v2];
        v5 = dword_100B8538[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B8548[v2 * 4]);
        v7 = sub_1002C9C0(
               1,
               *(&dword_100AE7EC + dword_100B8544[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B8544[v2]],
               *(_DWORD *)&off_100B8548[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8538: using guessed type int dword_100B8538[];
// 100B853C: using guessed type int dword_100B853C[];
// 100B8540: using guessed type int dword_100B8540[];
// 100B8544: using guessed type int dword_100B8544[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10032EE0) --------------------------------------------------------
char sub_10032EE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B88B0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B88AC[v2 / 2];
        v4 = word_100B88AA[v2 / 2];
        v5 = word_100B88A8[v2 / 2];
        v6 = sub_1002A000(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B88B4)[v2]);
        v7 = sub_1002CD60(
               1,
               *(&dword_100AE7EC + dword_100B88B0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B88B0[v2 / 4]],
               (&off_100B88B4)[v2]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B88A8: using guessed type __int16 word_100B88A8[];
// 100B88AA: using guessed type __int16 word_100B88AA[];
// 100B88AC: using guessed type __int16 word_100B88AC[];
// 100B88B0: using guessed type int dword_100B88B0[];
// 100B88B4: using guessed type char *off_100B88B4;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10033040) --------------------------------------------------------
char sub_10033040()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8B74[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B8B70[v2];
        v4 = dword_100B8B6C[v2];
        v5 = dword_100B8B68[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B8B78[v2 * 4]);
        v7 = sub_1002D160(
               1,
               *(&dword_100AE7EC + dword_100B8B74[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B8B74[v2]],
               *(_DWORD *)&off_100B8B78[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8B68: using guessed type int dword_100B8B68[];
// 100B8B6C: using guessed type int dword_100B8B6C[];
// 100B8B70: using guessed type int dword_100B8B70[];
// 100B8B74: using guessed type int dword_100B8B74[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100331A0) --------------------------------------------------------
char sub_100331A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8EF0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B8EEC[v2];
        LODWORD(v3) = dword_100B8EE8[v2];
        HIDWORD(v4) = dword_100B8EE4[v2];
        LODWORD(v4) = dword_100B8EE0[v2];
        HIDWORD(v5) = dword_100B8EDC[v2];
        LODWORD(v5) = dword_100B8ED8[v2];
        v6 = sub_1002A000(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B8EF4[v2 * 4]);
        v7 = sub_1002D500(
               1,
               *(&dword_100AE7EC + dword_100B8EF0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B8EF0[v2]],
               *(_DWORD *)&off_100B8EF4[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8ED8: using guessed type int dword_100B8ED8[];
// 100B8EDC: using guessed type int dword_100B8EDC[];
// 100B8EE0: using guessed type int dword_100B8EE0[];
// 100B8EE4: using guessed type int dword_100B8EE4[];
// 100B8EE8: using guessed type int dword_100B8EE8[];
// 100B8EEC: using guessed type int dword_100B8EEC[];
// 100B8EF0: using guessed type int dword_100B8EF0[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10033310) --------------------------------------------------------
char sub_10033310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B945C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B945A[v2 * 4];
        v4 = byte_100B9459[v2 * 4];
        v5 = byte_100B9458[v2 * 4];
        v6 = sub_1002A000(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               (&off_100B9460)[v2 * 4]);
        v7 = sub_1002DAE0(
               1,
               *(&dword_100AE7EC + dword_100B945C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B945C[v2]],
               (&off_100B9460)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B945C: using guessed type int dword_100B945C[];
// 100B9460: using guessed type char *off_100B9460;
// 101A04C0: using guessed type char byte_101A04C0;

//----- (10033470) --------------------------------------------------------
char sub_10033470()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101A04C0 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9674[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B9670[v2];
        v4 = dword_100B966C[v2];
        v5 = dword_100B9668[v2];
        v6 = sub_1002A000(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * *(&dword_100AE7EC + v0)],
               *(_DWORD *)&off_100B9678[v2 * 4]);
        v7 = sub_1002DED0(
               1,
               *(&dword_100AE7EC + dword_100B9674[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1002A000(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B9674[v2]],
               *(_DWORD *)&off_100B9678[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9668: using guessed type int dword_100B9668[];
// 100B966C: using guessed type int dword_100B966C[];
// 100B9670: using guessed type int dword_100B9670[];
// 100B9674: using guessed type int dword_100B9674[];
// 101A04C0: using guessed type char byte_101A04C0;

//----- (100335D0) --------------------------------------------------------
char sub_100335D0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_101A04C1 )
  {
    sub_1002EB60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1002F1B0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1002B160(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_1003B510() )
      v1 = 3;
    sub_1002B160(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_1003B510();
    sub_1002B160(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1002F1B0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1002B160(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10033B70) --------------------------------------------------------
char sub_10033B70()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A04C1 )
  {
    v2 = 0;
    do
    {
      if ( off_100B99DC[v2] )
      {
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B99E4[v2 * 4], 0x100u, &v13);
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B99DC[v2], 0x100u, &v14);
        sub_1004B500(&v14, &v13);
      }
      if ( byte_100B99D8[v2 * 4] )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100B99E0[v2];
        v4 = *(char **)&off_100B99E4[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B99E4[v2 * 4],
               off_100B99E0[v2]);
        v12 = 1;
        v11 = sub_1002E680(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100B99E0[v2];
        v7 = *(char **)&off_100B99E4[v2 * 4];
        v8 = sub_1002A000(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B99E4[v2 * 4],
               off_100B99E0[v2]);
        v12 = 1;
        v11 = sub_1002E680(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B99DC: using guessed type char *off_100B99DC[3];
// 100B99E0: using guessed type char *off_100B99E0[2];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10033D80) --------------------------------------------------------
char sub_10033D80()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A04C1 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1002A360(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1002A360(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1002A360(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1002A360(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1002A360(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10033F70) --------------------------------------------------------
char sub_10033F70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9A2C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100B9A29[v2 * 4];
        v4 = byte_100B9A28[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B9A2C[v2]],
               (&off_100B9A30)[v2 * 4]);
        v6 = sub_1002A4A0(0, dword_100B9A2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1002A000(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100B9A2C[v2]],
               (&off_100B9A30)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100B9A2C: using guessed type int dword_100B9A2C[];
// 100B9A30: using guessed type char *off_100B9A30;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100340E0) --------------------------------------------------------
char sub_100340E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100B9CA8[v2 / 2];
      v4 = dbl_100B9CA0[v2 / 2];
      v5 = dbl_100B9C98[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100B9CB0[v2]],
             *(_DWORD *)&off_100B9CB4[v2 * 4]);
      v7 = sub_1002A850(0, dword_100B9CB0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100B9CB0[v2]],
             *(_DWORD *)&off_100B9CB4[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B9C98: using guessed type double dbl_100B9C98[];
// 100B9CA0: using guessed type double dbl_100B9CA0[];
// 100B9CA8: using guessed type double dbl_100B9CA8[];
// 100B9CB0: using guessed type int dword_100B9CB0[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034250) --------------------------------------------------------
char sub_10034250()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100BA8C0[v2];
      v4 = flt_100BA8BC[v2];
      v5 = flt_100BA8B8[v2];
      v6 = sub_1002A000(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BA8C4[v2]],
             *(_DWORD *)&off_100BA8C8[v2 * 4]);
      v7 = sub_1002ACA0(0, dword_100BA8C4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BA8C4[v2]],
             *(_DWORD *)&off_100BA8C8[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA8B8: using guessed type float flt_100BA8B8[];
// 100BA8BC: using guessed type float flt_100BA8BC[];
// 100BA8C0: using guessed type float flt_100BA8C0[];
// 100BA8C4: using guessed type int dword_100BA8C4[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100343B0) --------------------------------------------------------
char sub_100343B0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A04C1 )
  {
    sub_1002EAB0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_100343B0,
      (int)sub_100343B0,
      0);
    sub_1002EAB0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_100343B0,
      0,
      0);
    result = sub_1002EAB0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100343B0,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100344A0) --------------------------------------------------------
char sub_100344A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100BB058[v2];
      v4 = dword_100BB054[v2];
      v5 = dword_100BB050[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BB05C[v2]],
             (&off_100BB060)[v2 * 4]);
      v7 = sub_1002B160(0, dword_100BB05C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BB05C[v2]],
             (&off_100BB060)[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB050: using guessed type int dword_100BB050[];
// 100BB054: using guessed type int dword_100BB054[];
// 100BB058: using guessed type int dword_100BB058[];
// 100BB05C: using guessed type int dword_100BB05C[];
// 100BB060: using guessed type char *off_100BB060;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034600) --------------------------------------------------------
char sub_10034600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100BB7EC[v2 / 2];
      v4 = word_100BB7EA[v2 / 2];
      v5 = word_100BB7E8[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BB7F0[v2 / 4]],
             (&off_100BB7F4)[v2]);
      v7 = sub_1002B520(
             0,
             dword_100BB7F0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BB7F0[v2 / 4]],
             (&off_100BB7F4)[v2]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB7E8: using guessed type __int16 word_100BB7E8[];
// 100BB7EA: using guessed type __int16 word_100BB7EA[];
// 100BB7EC: using guessed type __int16 word_100BB7EC[];
// 100BB7F0: using guessed type int dword_100BB7F0[];
// 100BB7F4: using guessed type char *off_100BB7F4;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034760) --------------------------------------------------------
char sub_10034760()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100BBE00[v2];
      v4 = dword_100BBDFC[v2];
      v5 = dword_100BBDF8[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BBE04[v2]],
             *(_DWORD *)&off_100BBE08[v2 * 4]);
      v7 = sub_1002B920(0, dword_100BBE04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BBE04[v2]],
             *(_DWORD *)&off_100BBE08[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BBDF8: using guessed type int dword_100BBDF8[];
// 100BBDFC: using guessed type int dword_100BBDFC[];
// 100BBE00: using guessed type int dword_100BBE00[];
// 100BBE04: using guessed type int dword_100BBE04[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100348C0) --------------------------------------------------------
char sub_100348C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100BC5A4[v2];
      LODWORD(v3) = dword_100BC5A0[v2];
      HIDWORD(v4) = dword_100BC59C[v2];
      LODWORD(v4) = dword_100BC598[v2];
      HIDWORD(v5) = dword_100BC594[v2];
      LODWORD(v5) = dword_100BC590[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BC5A8[v2]],
             *(_DWORD *)&off_100BC5AC[v2 * 4]);
      v7 = sub_1002BCE0(0, dword_100BC5A8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BC5A8[v2]],
             *(_DWORD *)&off_100BC5AC[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BC590: using guessed type int dword_100BC590[];
// 100BC594: using guessed type int dword_100BC594[];
// 100BC598: using guessed type int dword_100BC598[];
// 100BC59C: using guessed type int dword_100BC59C[];
// 100BC5A0: using guessed type int dword_100BC5A0[];
// 100BC5A4: using guessed type int dword_100BC5A4[];
// 100BC5A8: using guessed type int dword_100BC5A8[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034A30) --------------------------------------------------------
char sub_10034A30()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100BD1B2[v2 * 4];
      v4 = byte_100BD1B1[v2 * 4];
      v5 = byte_100BD1B0[v2 * 4];
      v6 = sub_1002A000(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BD1B4[v2]],
             (&off_100BD1B8)[v2 * 4]);
      v7 = sub_1002C220(0, dword_100BD1B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BD1B4[v2]],
             (&off_100BD1B8)[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BD1B4: using guessed type int dword_100BD1B4[];
// 100BD1B8: using guessed type char *off_100BD1B8;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034B90) --------------------------------------------------------
char sub_10034B90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100BD648[v2];
      v4 = dword_100BD644[v2];
      v5 = dword_100BD640[v2];
      v6 = sub_1002A000(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BD64C[v2]],
             (&off_100BD650)[v2 * 4]);
      v7 = sub_1002C600(0, dword_100BD64C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BD64C[v2]],
             (&off_100BD650)[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BD640: using guessed type int dword_100BD640[];
// 100BD644: using guessed type int dword_100BD644[];
// 100BD648: using guessed type int dword_100BD648[];
// 100BD64C: using guessed type int dword_100BD64C[];
// 100BD650: using guessed type char *off_100BD650;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034CF0) --------------------------------------------------------
char sub_10034CF0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A04C1 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1002EB60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           &byte_10065A71,
           &byte_10065A71,
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1002EB60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1002EB60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10065A71,
           0);
    sub_1002A360(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1002EB60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1002A360(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10034EF0) --------------------------------------------------------
char sub_10034EF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100BDDE0[v2];
      v4 = dword_100BDDDC[v2];
      v5 = dword_100BDDD8[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BDDE4[v2]],
             *(_DWORD *)&off_100BDDE8[v2 * 4]);
      v7 = sub_1002C9C0(0, dword_100BDDE4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BDDE4[v2]],
             *(_DWORD *)&off_100BDDE8[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BDDD8: using guessed type int dword_100BDDD8[];
// 100BDDDC: using guessed type int dword_100BDDDC[];
// 100BDDE0: using guessed type int dword_100BDDE0[];
// 100BDDE4: using guessed type int dword_100BDDE4[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035050) --------------------------------------------------------
char sub_10035050()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100BE14C[v2 / 2];
      v4 = word_100BE14A[v2 / 2];
      v5 = word_100BE148[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE150[v2 / 4]],
             (&off_100BE154)[v2]);
      v7 = sub_1002CD60(
             0,
             dword_100BE150[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE150[v2 / 4]],
             (&off_100BE154)[v2]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BE148: using guessed type __int16 word_100BE148[];
// 100BE14A: using guessed type __int16 word_100BE14A[];
// 100BE14C: using guessed type __int16 word_100BE14C[];
// 100BE150: using guessed type int dword_100BE150[];
// 100BE154: using guessed type char *off_100BE154;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100351B0) --------------------------------------------------------
char sub_100351B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100BE410[v2];
      v4 = dword_100BE40C[v2];
      v5 = dword_100BE408[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE414[v2]],
             *(_DWORD *)&off_100BE418[v2 * 4]);
      v7 = sub_1002D160(0, dword_100BE414[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE414[v2]],
             *(_DWORD *)&off_100BE418[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BE408: using guessed type int dword_100BE408[];
// 100BE40C: using guessed type int dword_100BE40C[];
// 100BE410: using guessed type int dword_100BE410[];
// 100BE414: using guessed type int dword_100BE414[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035310) --------------------------------------------------------
char sub_10035310()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100BE78C[v2];
      LODWORD(v3) = dword_100BE788[v2];
      HIDWORD(v4) = dword_100BE784[v2];
      LODWORD(v4) = dword_100BE780[v2];
      HIDWORD(v5) = dword_100BE77C[v2];
      LODWORD(v5) = dword_100BE778[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE790[v2]],
             *(_DWORD *)&off_100BE794[v2 * 4]);
      v7 = sub_1002D500(0, dword_100BE790[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BE790[v2]],
             *(_DWORD *)&off_100BE794[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BE778: using guessed type int dword_100BE778[];
// 100BE77C: using guessed type int dword_100BE77C[];
// 100BE780: using guessed type int dword_100BE780[];
// 100BE784: using guessed type int dword_100BE784[];
// 100BE788: using guessed type int dword_100BE788[];
// 100BE78C: using guessed type int dword_100BE78C[];
// 100BE790: using guessed type int dword_100BE790[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035480) --------------------------------------------------------
char sub_10035480()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100BECFA[v2 * 4];
      v4 = byte_100BECF9[v2 * 4];
      v5 = byte_100BECF8[v2 * 4];
      v6 = sub_1002A000(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BECFC[v2]],
             (&off_100BED00)[v2 * 4]);
      v7 = sub_1002DAE0(0, dword_100BECFC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BECFC[v2]],
             (&off_100BED00)[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BECFC: using guessed type int dword_100BECFC[];
// 100BED00: using guessed type char *off_100BED00;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100355E0) --------------------------------------------------------
char sub_100355E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100BEF10[v2];
      v4 = dword_100BEF0C[v2];
      v5 = dword_100BEF08[v2];
      v6 = sub_1002A000(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BEF14[v2]],
             *(_DWORD *)&off_100BEF18[v2 * 4]);
      v7 = sub_1002DED0(0, dword_100BEF14[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BEF14[v2]],
             *(_DWORD *)&off_100BEF18[v2 * 4]);
      result = sub_1002A360(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BEF08: using guessed type int dword_100BEF08[];
// 100BEF0C: using guessed type int dword_100BEF0C[];
// 100BEF10: using guessed type int dword_100BEF10[];
// 100BEF14: using guessed type int dword_100BEF14[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035740) --------------------------------------------------------
char sub_10035740()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101A04C1 )
  {
    v2 = 0;
    do
    {
      if ( off_100BF27C[v2] )
      {
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100BF284[v2 * 4], 0x100u, &v13);
        sub_10029D60((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100BF27C[v2], 0x100u, &v14);
        sub_1004B500(&v14, &v13);
      }
      if ( byte_100BF278[v2 * 4] )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100BF280[v2];
        v4 = *(char **)&off_100BF284[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BF284[v2 * 4],
               off_100BF280[v2]);
        v12 = 1;
        v11 = sub_1002E680(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100BF280[v2];
        v7 = *(char **)&off_100BF284[v2 * 4];
        v8 = sub_1002A000(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BF284[v2 * 4],
               off_100BF280[v2]);
        v12 = 1;
        v11 = sub_1002E680(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BF27C: using guessed type char *off_100BF27C[3];
// 100BF280: using guessed type char *off_100BF280[2];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035950) --------------------------------------------------------
char sub_10035950()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101A04C1 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1002A360(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1002A360(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1002A360(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1002A360(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1002A360(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035B40) --------------------------------------------------------
char sub_10035B40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BF2CC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100BF2C9[v2 * 4];
        v4 = byte_100BF2C8[v2 * 4];
        v5 = sub_1002A000(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AE7D0[4 * dword_100BF2CC[v2]],
               (&off_100BF2D0)[v2 * 4]);
        v6 = sub_1002A4A0(1, dword_100BF2CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1002A000(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AE7D0[4 * dword_100BF2CC[v2]],
               (&off_100BF2D0)[v2 * 4]);
        LOBYTE(v0) = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1002F1B0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100BF2CC: using guessed type int dword_100BF2CC[];
// 100BF2D0: using guessed type char *off_100BF2D0;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035CB0) --------------------------------------------------------
char sub_10035CB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100BF548[v2 / 2];
      v4 = dbl_100BF540[v2 / 2];
      v5 = dbl_100BF538[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BF550[v2]],
             *(_DWORD *)&off_100BF554[v2 * 4]);
      v7 = sub_1002A850(1, dword_100BF550[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100BF550[v2]],
             *(_DWORD *)&off_100BF554[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BF538: using guessed type double dbl_100BF538[];
// 100BF540: using guessed type double dbl_100BF540[];
// 100BF548: using guessed type double dbl_100BF548[];
// 100BF550: using guessed type int dword_100BF550[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035E20) --------------------------------------------------------
char sub_10035E20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100C0160[v2];
      v4 = flt_100C015C[v2];
      v5 = flt_100C0158[v2];
      v6 = sub_1002A000(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C0164[v2]],
             *(_DWORD *)&off_100C0168[v2 * 4]);
      v7 = sub_1002ACA0(1, dword_100C0164[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C0164[v2]],
             *(_DWORD *)&off_100C0168[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C0158: using guessed type float flt_100C0158[];
// 100C015C: using guessed type float flt_100C015C[];
// 100C0160: using guessed type float flt_100C0160[];
// 100C0164: using guessed type int dword_100C0164[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10035F80) --------------------------------------------------------
char sub_10035F80()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101A04C1 )
  {
    sub_1002EAB0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10035F80,
      (int)sub_10035F80,
      0);
    sub_1002EAB0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10035F80,
      0,
      0);
    result = sub_1002EAB0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10035F80,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036070) --------------------------------------------------------
char sub_10036070()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100C08F8[v2];
      v4 = dword_100C08F4[v2];
      v5 = dword_100C08F0[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C08FC[v2]],
             (&off_100C0900)[v2 * 4]);
      v7 = sub_1002B160(1, dword_100C08FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C08FC[v2]],
             (&off_100C0900)[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C08F0: using guessed type int dword_100C08F0[];
// 100C08F4: using guessed type int dword_100C08F4[];
// 100C08F8: using guessed type int dword_100C08F8[];
// 100C08FC: using guessed type int dword_100C08FC[];
// 100C0900: using guessed type char *off_100C0900;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100361D0) --------------------------------------------------------
char sub_100361D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100C108C[v2 / 2];
      v4 = word_100C108A[v2 / 2];
      v5 = word_100C1088[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C1090[v2 / 4]],
             (&off_100C1094)[v2]);
      v7 = sub_1002B520(
             1,
             dword_100C1090[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C1090[v2 / 4]],
             (&off_100C1094)[v2]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C1088: using guessed type __int16 word_100C1088[];
// 100C108A: using guessed type __int16 word_100C108A[];
// 100C108C: using guessed type __int16 word_100C108C[];
// 100C1090: using guessed type int dword_100C1090[];
// 100C1094: using guessed type char *off_100C1094;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036330) --------------------------------------------------------
char sub_10036330()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100C16A0[v2];
      v4 = dword_100C169C[v2];
      v5 = dword_100C1698[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C16A4[v2]],
             *(_DWORD *)&off_100C16A8[v2 * 4]);
      v7 = sub_1002B920(1, dword_100C16A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C16A4[v2]],
             *(_DWORD *)&off_100C16A8[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C1698: using guessed type int dword_100C1698[];
// 100C169C: using guessed type int dword_100C169C[];
// 100C16A0: using guessed type int dword_100C16A0[];
// 100C16A4: using guessed type int dword_100C16A4[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036490) --------------------------------------------------------
char sub_10036490()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100C1E44[v2];
      LODWORD(v3) = dword_100C1E40[v2];
      HIDWORD(v4) = dword_100C1E3C[v2];
      LODWORD(v4) = dword_100C1E38[v2];
      HIDWORD(v5) = dword_100C1E34[v2];
      LODWORD(v5) = dword_100C1E30[v2];
      v6 = sub_1002A000(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C1E48[v2]],
             *(_DWORD *)&off_100C1E4C[v2 * 4]);
      v7 = sub_1002BCE0(1, dword_100C1E48[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C1E48[v2]],
             *(_DWORD *)&off_100C1E4C[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C1E30: using guessed type int dword_100C1E30[];
// 100C1E34: using guessed type int dword_100C1E34[];
// 100C1E38: using guessed type int dword_100C1E38[];
// 100C1E3C: using guessed type int dword_100C1E3C[];
// 100C1E40: using guessed type int dword_100C1E40[];
// 100C1E44: using guessed type int dword_100C1E44[];
// 100C1E48: using guessed type int dword_100C1E48[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036600) --------------------------------------------------------
char sub_10036600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100C2A52[v2 * 4];
      v4 = byte_100C2A51[v2 * 4];
      v5 = byte_100C2A50[v2 * 4];
      v6 = sub_1002A000(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C2A54[v2]],
             (&off_100C2A58)[v2 * 4]);
      v7 = sub_1002C220(1, dword_100C2A54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C2A54[v2]],
             (&off_100C2A58)[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C2A54: using guessed type int dword_100C2A54[];
// 100C2A58: using guessed type char *off_100C2A58;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036760) --------------------------------------------------------
char sub_10036760()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100C2EE8[v2];
      v4 = dword_100C2EE4[v2];
      v5 = dword_100C2EE0[v2];
      v6 = sub_1002A000(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C2EEC[v2]],
             (&off_100C2EF0)[v2 * 4]);
      v7 = sub_1002C600(1, dword_100C2EEC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C2EEC[v2]],
             (&off_100C2EF0)[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C2EE0: using guessed type int dword_100C2EE0[];
// 100C2EE4: using guessed type int dword_100C2EE4[];
// 100C2EE8: using guessed type int dword_100C2EE8[];
// 100C2EEC: using guessed type int dword_100C2EEC[];
// 100C2EF0: using guessed type char *off_100C2EF0;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100368C0) --------------------------------------------------------
char sub_100368C0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1002F1B0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10029EF0(0);
  sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1002F1B0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101A04C1 )
  {
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1002EB60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           &byte_10065A71,
           &byte_10065A71,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1002EB60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1002EB60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10065A71,
           0);
    sub_1002A360(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1002EB60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1002A360(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036AC0) --------------------------------------------------------
char sub_10036AC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100C3680[v2];
      v4 = dword_100C367C[v2];
      v5 = dword_100C3678[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C3684[v2]],
             *(_DWORD *)&off_100C3688[v2 * 4]);
      v7 = sub_1002C9C0(1, dword_100C3684[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C3684[v2]],
             *(_DWORD *)&off_100C3688[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3678: using guessed type int dword_100C3678[];
// 100C367C: using guessed type int dword_100C367C[];
// 100C3680: using guessed type int dword_100C3680[];
// 100C3684: using guessed type int dword_100C3684[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036C20) --------------------------------------------------------
char sub_10036C20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100C39EC[v2 / 2];
      v4 = word_100C39EA[v2 / 2];
      v5 = word_100C39E8[v2 / 2];
      v6 = sub_1002A000(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C39F0[v2 / 4]],
             (&off_100C39F4)[v2]);
      v7 = sub_1002CD60(
             1,
             dword_100C39F0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C39F0[v2 / 4]],
             (&off_100C39F4)[v2]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C39E8: using guessed type __int16 word_100C39E8[];
// 100C39EA: using guessed type __int16 word_100C39EA[];
// 100C39EC: using guessed type __int16 word_100C39EC[];
// 100C39F0: using guessed type int dword_100C39F0[];
// 100C39F4: using guessed type char *off_100C39F4;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036D80) --------------------------------------------------------
char sub_10036D80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100C3CB0[v2];
      v4 = dword_100C3CAC[v2];
      v5 = dword_100C3CA8[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C3CB4[v2]],
             *(_DWORD *)&off_100C3CB8[v2 * 4]);
      v7 = sub_1002D160(1, dword_100C3CB4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C3CB4[v2]],
             *(_DWORD *)&off_100C3CB8[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3CA8: using guessed type int dword_100C3CA8[];
// 100C3CAC: using guessed type int dword_100C3CAC[];
// 100C3CB0: using guessed type int dword_100C3CB0[];
// 100C3CB4: using guessed type int dword_100C3CB4[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10036EE0) --------------------------------------------------------
char sub_10036EE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100C402C[v2];
      LODWORD(v3) = dword_100C4028[v2];
      HIDWORD(v4) = dword_100C4024[v2];
      LODWORD(v4) = dword_100C4020[v2];
      HIDWORD(v5) = dword_100C401C[v2];
      LODWORD(v5) = dword_100C4018[v2];
      v6 = sub_1002A000(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C4030[v2]],
             *(_DWORD *)&off_100C4034[v2 * 4]);
      v7 = sub_1002D500(1, dword_100C4030[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C4030[v2]],
             *(_DWORD *)&off_100C4034[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4018: using guessed type int dword_100C4018[];
// 100C401C: using guessed type int dword_100C401C[];
// 100C4020: using guessed type int dword_100C4020[];
// 100C4024: using guessed type int dword_100C4024[];
// 100C4028: using guessed type int dword_100C4028[];
// 100C402C: using guessed type int dword_100C402C[];
// 100C4030: using guessed type int dword_100C4030[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10037050) --------------------------------------------------------
char sub_10037050()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100C459A[v2 * 4];
      v4 = byte_100C4599[v2 * 4];
      v5 = byte_100C4598[v2 * 4];
      v6 = sub_1002A000(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C459C[v2]],
             (&off_100C45A0)[v2 * 4]);
      v7 = sub_1002DAE0(1, dword_100C459C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C459C[v2]],
             (&off_100C45A0)[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C459C: using guessed type int dword_100C459C[];
// 100C45A0: using guessed type char *off_100C45A0;
// 101A04C1: using guessed type char byte_101A04C1;

//----- (100371B0) --------------------------------------------------------
char sub_100371B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101A04C1 )
  {
    sub_1002F1B0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10029EF0(0);
    sub_1002F1B0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1002F1B0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10029FE0(0);
    v2 = 0;
    do
    {
      sub_10029F10((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100C47B0[v2];
      v4 = dword_100C47AC[v2];
      v5 = dword_100C47A8[v2];
      v6 = sub_1002A000(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C47B4[v2]],
             *(_DWORD *)&off_100C47B8[v2 * 4]);
      v7 = sub_1002DED0(1, dword_100C47B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1002A000(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AE7D0[4 * dword_100C47B4[v2]],
             *(_DWORD *)&off_100C47B8[v2 * 4]);
      result = sub_1002A360(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1002F1B0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C47A8: using guessed type int dword_100C47A8[];
// 100C47AC: using guessed type int dword_100C47AC[];
// 100C47B0: using guessed type int dword_100C47B0[];
// 100C47B4: using guessed type int dword_100C47B4[];
// 101A04C1: using guessed type char byte_101A04C1;

//----- (10037310) --------------------------------------------------------
char **sub_10037310()
{
  return off_100AFEBC;
}
// 100AFEBC: using guessed type char *off_100AFEBC[3];

//----- (10037320) --------------------------------------------------------
signed int __cdecl sub_10037320(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_10027A50(a1);
  return sub_10028FE0(v1);
}

//----- (10037360) --------------------------------------------------------
signed int __cdecl sub_10037360(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10027A50(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_100294C0(v4, a4, 0) == a4 )
      result = sub_10029460(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100373C0) --------------------------------------------------------
signed int __cdecl sub_100373C0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10027A50(a1);
  return sub_100294C0(v3, a2, a3);
}

//----- (100373E0) --------------------------------------------------------
int __cdecl sub_100373E0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 0x7Fu, 0, 0);
}

//----- (10037400) --------------------------------------------------------
int __cdecl sub_10037400(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10025140(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10037430) --------------------------------------------------------
int __cdecl sub_10037430(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 3u, 0, 0);
}

//----- (10037460) --------------------------------------------------------
bool sub_10037460()
{
  return sub_10018280(99) == 0;
}

//----- (10037470) --------------------------------------------------------
bool sub_10037470()
{
  return sub_100182A0(99, 10000) == 0;
}

//----- (10037490) --------------------------------------------------------
int __cdecl sub_10037490(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_102234D4 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_10222C4C)(146, 1, a1);
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 102234D4: using guessed type char byte_102234D4;

//----- (100374C0) --------------------------------------------------------
char __cdecl sub_100374C0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102234D4 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_10222C4C)(dword_10222FA4, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 10222FA4: using guessed type int dword_10222FA4;
// 102234D4: using guessed type char byte_102234D4;

//----- (10037510) --------------------------------------------------------
char __cdecl sub_10037510(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102234D4 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_10222C4C)(dword_10222FA4, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 10222FA4: using guessed type int dword_10222FA4;
// 102234D4: using guessed type char byte_102234D4;

//----- (10037560) --------------------------------------------------------
int sub_10037560()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_10222C80, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_10222C3C)(512, &v6);
  v1 = 0;
  do
  {
    word_10222C84[v1 / 2] = 0;
    dword_10222C88[v1 / 4] = 0;
    dword_10222C80[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_10222C8C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_10222C90 = v7;
    dword_10222C94 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_10222C98;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_10222C3C)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_10222C90;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 10222C3C: using guessed type int dword_10222C3C;
// 10222C80: using guessed type int dword_10222C80[];
// 10222C84: using guessed type __int16 word_10222C84[];
// 10222C88: using guessed type int dword_10222C88[];
// 10222C8C: using guessed type int dword_10222C8C;
// 10222C90: using guessed type int dword_10222C90;
// 10222C94: using guessed type int dword_10222C94;
// 10222C98: using guessed type int dword_10222C98;

//----- (10037630) --------------------------------------------------------
__int16 sub_10037630()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_10222C9C;
  v1 = dword_10222CA0;
  v2 = 1;
  v3 = dword_10222C98;
  if ( (unsigned int)dword_10222CA0 >= 1 )
  {
    v4 = (unsigned __int16)word_10222C9C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_10222C4C)(v3, 2, &v5);
      result = v5;
      word_102233A0[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;
// 10222C98: using guessed type int dword_10222C98;
// 10222C9C: using guessed type __int16 word_10222C9C;
// 10222CA0: using guessed type int dword_10222CA0;
// 102233A0: using guessed type __int16 word_102233A0[];

//----- (10037690) --------------------------------------------------------
int __usercall sub_10037690@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10037710) --------------------------------------------------------
char sub_10037710()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_102234D4 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_10222C4C)(147, 12, &v17);
  byte_102234D4 = 1;
  dword_101ADC10 = 0;
  dword_101ADC14 = 0;
  dword_101ADC18 = 0;
  dword_101ADC1C = 0;
  byte_101ADC20 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  sub_10037690((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  }
  byte_102234D4 = 0;
  sub_10037490(&v16);
  if ( v16 != 101 )
  {
    byte_102234D4 = 2;
    return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  }
  if ( byte_102234D4 )
    return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  sub_10037510(&unk_10223388, &byte_102234CD);
  byte_102234CC = byte_102234CD - 1;
  if ( byte_102234D4 )
    return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  result = sub_100374C0(&unk_10223389, &unk_1022338A);
  byte_10222C60 = 0;
  if ( byte_102234D4 )
    return (unsigned int)memset(dword_10222C80, 0, 0x708u);
  return result;
}
// 101ADC10: using guessed type int dword_101ADC10;
// 101ADC14: using guessed type int dword_101ADC14;
// 101ADC18: using guessed type int dword_101ADC18;
// 101ADC1C: using guessed type int dword_101ADC1C;
// 101ADC20: using guessed type char byte_101ADC20;
// 10222C4C: using guessed type int dword_10222C4C;
// 10222C60: using guessed type char byte_10222C60;
// 10222C80: using guessed type int dword_10222C80[];
// 102234CC: using guessed type char byte_102234CC;
// 102234CD: using guessed type char byte_102234CD;
// 102234D4: using guessed type char byte_102234D4;

//----- (100378D0) --------------------------------------------------------
int (__cdecl *(*sub_100378D0())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_10222C3C = (int)off_100F6338;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_10222C4C)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10037690((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100DD294)[8 * v1];
      v3 = strlen((&off_100DD294)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100DD298)[v1];
        dword_10222C3C = (int)(&off_100DD298)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100DD294: using guessed type char *off_100DD294;
// 100DD298: using guessed type int (__cdecl *(*off_100DD298)[2])(int, int);
// 100F6338: using guessed type int (__cdecl *off_100F6338[2])(int, int);
// 10222C3C: using guessed type int dword_10222C3C;
// 10222C4C: using guessed type int dword_10222C4C;

//----- (10037A00) --------------------------------------------------------
bool __cdecl sub_10037A00(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_10222C88[v2 / 4] && word_10222C84[v2 / 2] && dword_10222C80[v2 / 4] )
      result = 1;
  }
  return result;
}
// 10222C80: using guessed type int dword_10222C80[];
// 10222C84: using guessed type __int16 word_10222C84[];
// 10222C88: using guessed type int dword_10222C88[];

//----- (10037A40) --------------------------------------------------------
int __cdecl sub_10037A40(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10037A00(0, a1) )
    result = dword_10222C88[3 * v1];
  else
    result = 0;
  return result;
}
// 10222C88: using guessed type int dword_10222C88[];

//----- (10037A70) --------------------------------------------------------
int __cdecl sub_10037A70(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10025140((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 4 );
  return result;
}

//----- (10037AA0) --------------------------------------------------------
unsigned int __cdecl sub_10037AA0(char *a1)
{
  return sub_10024FD0(a1, -100, 100, 0, 0);
}

//----- (10037AC0) --------------------------------------------------------
int __cdecl sub_10037AC0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 2u, 0, 0);
}

//----- (10037AE0) --------------------------------------------------------
int __cdecl sub_10037AE0(_BYTE *a1)
{
  return sub_10025230(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10037B00) --------------------------------------------------------
int __cdecl sub_10037B00(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 1u, 1u, 0);
}

//----- (10037B20) --------------------------------------------------------
int __cdecl sub_10037B20(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10025140((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 23 );
  return result;
}

//----- (10037B50) --------------------------------------------------------
unsigned int __cdecl sub_10037B50(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10024E90((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10025140((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10024E90((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025140((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025140((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10037E80) --------------------------------------------------------
unsigned int __cdecl sub_10037E80(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10024E90((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024FD0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100382C0) --------------------------------------------------------
int __cdecl sub_100382C0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 7u, 7u, 0);
}

//----- (100382E0) --------------------------------------------------------
int __cdecl sub_100382E0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 0x7Fu, 0x7Fu, 0);
}

//----- (10038300) --------------------------------------------------------
int __cdecl sub_10038300(int a1)
{
  int result; // eax@1

  result = sub_100382C0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_100382C0((unsigned __int8 *)(a1 + 1));
    if ( !result )
      result = sub_100382E0((unsigned __int8 *)(a1 + 2));
  }
  return result;
}

//----- (10038330) --------------------------------------------------------
int __cdecl sub_10038330(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10025140((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 56 );
  return result;
}

//----- (10038360) --------------------------------------------------------
unsigned int __cdecl sub_10038360(_BYTE *a1)
{
  return sub_10025020(a1, -1, 5, -1, 0);
}

//----- (10038380) --------------------------------------------------------
int __cdecl sub_10038380(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 4u, 2u, 0);
}

//----- (100383A0) --------------------------------------------------------
int __cdecl sub_100383A0(_BYTE *a1)
{
  return sub_10025230(a1, 0, 2u, 0, 0);
}

//----- (100383C0) --------------------------------------------------------
int __cdecl sub_100383C0(int a1)
{
  return sub_10024EE0(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10038410) --------------------------------------------------------
int __cdecl sub_10038410(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_100383C0((int)(a1 + 4));
  if ( !result )
    result = sub_10038380(a1);
  return result;
}

//----- (10038430) --------------------------------------------------------
int __cdecl sub_10038430(int a1)
{
  int result; // eax@1

  result = sub_10038AB0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10038AB0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10038AB0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1003ED10((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10024E90((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10024E90((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10024E90((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10024E90((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (100384C0) --------------------------------------------------------
unsigned int __cdecl sub_100384C0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10038360((_BYTE *)a1);
  if ( !result )
    result = sub_10038360((_BYTE *)(a1 + 4));
  return result;
}

//----- (100384E0) --------------------------------------------------------
signed int __cdecl sub_100384E0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024E90((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10024E90((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10038530) --------------------------------------------------------
unsigned int __cdecl sub_10038530(int a1)
{
  unsigned int result; // eax@1

  result = sub_10038360((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10038360((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10038360((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10038360((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10024E90((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10038590) --------------------------------------------------------
int __cdecl sub_10038590(_BYTE *a1)
{
  return sub_10025230(a1, 0, 0x20u, 2u, 0);
}

//----- (100385B0) --------------------------------------------------------
unsigned int __cdecl sub_100385B0(_BYTE *a1)
{
  return sub_10025020(a1, -1, 4, -1, 0);
}

//----- (100385D0) --------------------------------------------------------
int __cdecl sub_100385D0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 9u, 0, 0);
}

//----- (100385F0) --------------------------------------------------------
int __cdecl sub_100385F0(_BYTE *a1)
{
  return sub_10025230(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10038610) --------------------------------------------------------
signed int __cdecl sub_10038610(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025230(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10038640) --------------------------------------------------------
int __cdecl sub_10038640(_BYTE *a1)
{
  return sub_10025190(a1, 0, 0xFFFu, 640, 0);
}

//----- (10038660) --------------------------------------------------------
int __cdecl sub_10038660(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10025190(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100386A0) --------------------------------------------------------
int __cdecl sub_100386A0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10038610((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10038660((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10038660((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10037400((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10038660((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10038730) --------------------------------------------------------
int __cdecl sub_10038730(int a1)
{
  int result; // eax@1

  result = sub_10025140((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10025140((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10038760) --------------------------------------------------------
int __cdecl sub_10038760(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 3u, 1u, 0);
}

//----- (10038780) --------------------------------------------------------
unsigned int __cdecl sub_10038780(int a1)
{
  unsigned int result; // eax@1

  result = sub_10025020((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10025020((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (100387B0) --------------------------------------------------------
int __cdecl sub_100387B0(int a1)
{
  int result; // eax@1

  result = sub_10024EE0(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10024EE0(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10024EE0(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10024EE0(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10024EE0(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (100388A0) --------------------------------------------------------
int __cdecl sub_100388A0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024E90((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10025140((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10038780(a1 + 36);
        if ( !result )
        {
          result = sub_10024EE0(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_100387B0(a1 + 8);
            if ( !result )
            {
              result = sub_10038780(a1 + 28);
              if ( !result )
              {
                result = sub_10025190((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10037AC0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10038730(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10024E90((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10038760((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (100389B0) --------------------------------------------------------
signed int __cdecl sub_100389B0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025190(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100389E0) --------------------------------------------------------
signed int __cdecl sub_100389E0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025140(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10038A10) --------------------------------------------------------
int __cdecl sub_10038A10(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_1003A3D0(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10038A40) --------------------------------------------------------
int __cdecl sub_10038A40(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10038AA0) --------------------------------------------------------
int __cdecl sub_10038AA0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024E90((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10038A40((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10038AB0) --------------------------------------------------------
int __cdecl sub_10038AB0(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 5u, 0, 0);
}

//----- (10038AD0) --------------------------------------------------------
int __cdecl sub_10038AD0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10025140(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10038B00) --------------------------------------------------------
int __cdecl sub_10038B00(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 6u, 2u, 0);
}

//----- (10038B20) --------------------------------------------------------
int __cdecl sub_10038B20(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10025140(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10038B50) --------------------------------------------------------
int __cdecl sub_10038B50(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 8u, 0, 0);
}

//----- (10038B70) --------------------------------------------------------
int __cdecl sub_10038B70(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10025140(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10038BA0) --------------------------------------------------------
signed int __cdecl sub_10038BA0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025230(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10038BD0) --------------------------------------------------------
int __cdecl sub_10038BD0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10025140((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10025140((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10038C80) --------------------------------------------------------
int __cdecl sub_10038C80(int a1)
{
  int result; // eax@1

  result = sub_1003A2E0((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_1003A2E0((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_10037430((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10038C70(a1 + 24);
        if ( !result )
        {
          result = sub_10037430((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_100373E0((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_10037430((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10038C70: using guessed type _DWORD __cdecl sub_10038C70(_DWORD);

//----- (10038D00) --------------------------------------------------------
unsigned int __cdecl sub_10038D00(int a1)
{
  unsigned int result; // eax@1

  result = sub_10037AA0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10037AA0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10037AA0((char *)a1);
      if ( !result )
        result = sub_10037AA0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10038D40) --------------------------------------------------------
unsigned int __cdecl sub_10038D40(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10038D00(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10037AC0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10037B00((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10038D90) --------------------------------------------------------
int __cdecl sub_10038D90(int a1)
{
  int result; // eax@1

  result = sub_10037AE0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10025190((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10038DC0) --------------------------------------------------------
int __cdecl sub_10038DC0(int a1)
{
  int result; // eax@1

  result = sub_100383A0((_BYTE *)a1);
  if ( !result )
    result = sub_100385F0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10038DF0) --------------------------------------------------------
unsigned int __cdecl sub_10038DF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10038360((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10038360((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_100385B0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10038E20) --------------------------------------------------------
unsigned int __cdecl sub_10038E20(int a1)
{
  unsigned int result; // eax@1

  result = sub_10038360((_BYTE *)a1);
  if ( !result )
    result = sub_100385D0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10038E40) --------------------------------------------------------
unsigned int __cdecl sub_10038E40(int a1)
{
  unsigned int result; // eax@1

  result = sub_10038360((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10025140((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_100385B0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10038E80) --------------------------------------------------------
void __cdecl __noreturn sub_10038E80(int a1)
{
  exit_1(a1 + 4);
}

//----- (10038FF0) --------------------------------------------------------
signed int __cdecl sub_10038FF0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_100389E0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_100389B0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_100389E0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10039040) --------------------------------------------------------
int __cdecl sub_10039040(int a1)
{
  int result; // eax@1

  result = sub_10025190((_BYTE *)(a1 + 12), 0, 0x1E61u, 1200, 0);
  if ( !result )
  {
    result = sub_10038B00((unsigned __int8 *)a1);
    if ( !result )
    {
      result = sub_10038B50((unsigned __int8 *)(a1 + 11));
      if ( !result )
      {
        result = sub_10024E90((_BYTE *)(a1 + 1), 0, 0);
        if ( !result )
          result = sub_10025190((_BYTE *)(a1 + 14), 0, 0x1E61u, 1200, 0);
      }
    }
  }
  return result;
}

//----- (100390B0) --------------------------------------------------------
int __cdecl sub_100390B0(_BYTE *a1, int a2)
{
  return sub_10025230(a1, 0, 0x1FEu, 0, a2);
}

//----- (100390D0) --------------------------------------------------------
signed int __usercall sub_100390D0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10038FF0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10025140((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10024E90((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10037E80(v2 + 5, a2);
    else
      result = sub_10037B50(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10038BA0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100391A0) --------------------------------------------------------
int __usercall sub_100391A0@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_10038AD0(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10038B20(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024E90(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10038B70(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025230(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025230(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100390B0(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10039290) --------------------------------------------------------
int __cdecl sub_10039290(unsigned __int8 *a1)
{
  return sub_100391A0(a1, 0);
}

//----- (100392A0) --------------------------------------------------------
signed int __cdecl sub_100392A0(int a1)
{
  return sub_100390D0(a1, 0);
}

//----- (100392B0) --------------------------------------------------------
int __cdecl sub_100392B0(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_1004CBB0(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (100393B0) --------------------------------------------------------
signed int __cdecl sub_100393B0(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10039450) --------------------------------------------------------
char __cdecl sub_10039450(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10039490) --------------------------------------------------------
char __cdecl sub_10039490(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 7;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 648, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (100394D0) --------------------------------------------------------
signed int __cdecl sub_100394D0(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10039510) --------------------------------------------------------
char __cdecl sub_10039510(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 6;
    }
    else
    {
      sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 750, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10039550) --------------------------------------------------------
char __cdecl sub_10039550(int a1)
{
  char result; // al@3

  if ( a1 == 256 )
  {
    result = 0;
  }
  else if ( a1 == 512 )
  {
    result = 1;
  }
  else
  {
    sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 800, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10039590) --------------------------------------------------------
char __cdecl sub_10039590(char a1)
{
  return sub_10020510((int)&unk_100DE210, a1, 0x33u);
}

//----- (100395B0) --------------------------------------------------------
char __cdecl sub_100395B0(char a1)
{
  return sub_10020510((int)&unk_100DE278, a1, 0x31u);
}

//----- (100395D0) --------------------------------------------------------
char __cdecl sub_100395D0(char a1)
{
  return sub_10020510((int)&unk_100DE2DC, a1, 0x1Du);
}

//----- (100395F0) --------------------------------------------------------
char __cdecl sub_100395F0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10039590(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1003A400(v2);
  return result;
}

//----- (10039620) --------------------------------------------------------
char __cdecl sub_10039620(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100395B0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1003A400(v2);
  return result;
}

//----- (10039650) --------------------------------------------------------
char __cdecl sub_10039650(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100395D0(a1);
  if ( v2 == -80 )
  {
    result = 57;
    if ( a1 != 4 )
      result = 67;
  }
  else
  {
    result = sub_1003A400(v2);
  }
  return result;
}

//----- (10039690) --------------------------------------------------------
bool __fastcall sub_10039690(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_1000F100(0, 317, &v2) && !(v2 & 0x20000000) && v2 & 0x40000000;
}

//----- (100396D0) --------------------------------------------------------
signed int sub_100396D0()
{
  return sub_10018EB0((int)&off_100DE3A8);
}
// 100DE3A8: using guessed type char *off_100DE3A8;

//----- (100396E0) --------------------------------------------------------
char __cdecl sub_100396E0(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_100396D0() == 1 && !sub_100182A0(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_101ADC24 + 8), 0x34u);
    v1 = 1;
    sub_10018280(37);
  }
  return v1;
}
// 101ADC24: using guessed type int dword_101ADC24;

//----- (10039730) --------------------------------------------------------
bool sub_10039730()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_10020FE0((char *)&v2);
  return (unsigned __int8)sub_100396D0() && v0 && v2 < *(_DWORD *)(dword_101ADC24 + 60) + 18;
}
// 101ADC24: using guessed type int dword_101ADC24;

//----- (10039770) --------------------------------------------------------
char __cdecl sub_10039770(unsigned __int8 a1, signed int *a2, int a3, _BYTE *a4)
{
  unsigned __int8 v4; // cl@1
  _BYTE *v5; // ebp@1
  int v6; // esi@1
  int v7; // eax@1
  signed int *v8; // edi@1
  char v9; // al@2
  char v10; // al@2
  void *v11; // ecx@2
  char v12; // al@2
  char v13; // al@2
  void *v14; // ecx@2
  char v15; // ST14_1@2
  char v16; // al@2
  void *v17; // ecx@3
  char v18; // al@5
  signed int v19; // eax@5
  unsigned __int8 v20; // al@65
  int v21; // eax@66
  int v22; // ecx@66
  int v24; // [sp-Ch] [bp-30h]@16
  char v25; // [sp-8h] [bp-2Ch]@16
  int v26; // [sp+13h] [bp-11h]@6
  char v27; // [sp+17h] [bp-Dh]@3
  char v28; // [sp+18h] [bp-Ch]@2
  int v29; // [sp+1Ch] [bp-8h]@2

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  *a2 = 0;
  *(_DWORD *)v6 = 0;
  *v5 = 7;
  switch ( v7 )
  {
    case 15:
    case 16:
    case 127:
      v9 = sub_1003A400(v4);
      v10 = sub_10025E20(v9);
      sub_1001E0F0(v10, (_BYTE *)v6);
      v12 = sub_10020560(v11);
      v13 = sub_10020080(v12);
      v14 = (void *)*(_BYTE *)v6;
      v15 = *(_BYTE *)v6;
      LOBYTE(v29) = v13;
      v16 = sub_10020560(v14);
      v28 = sub_1001DF00(v16, v15);
      if ( v28 != 2 && sub_1004B8F0(v29, 0, &v28, &v27) && v27 == 2 )
      {
        v18 = sub_10020560(v17);
        v19 = sub_10020160(v18);
        *v8 = v19;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v26) = 0;
        while ( 1 )
        {
          LOBYTE(v29) = sub_10020080(v26);
          v28 = sub_1001DF00(v26, *(_BYTE *)v6);
          if ( v28 != 2 && sub_1004B8F0(v29, 0, &v28, &v27) && v27 == 2 )
            break;
          LOBYTE(v19) = v26 + 1;
          LOBYTE(v26) = v26 + 1;
          if ( (unsigned __int8)v26 >= 3u )
            return v19;
        }
        v19 = sub_10020160(v26);
        *v8 = v19;
        *v5 = 1;
      }
      break;
    case 17:
    case 31:
    case 32:
    case 33:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001E030(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 565;
        goto LABEL_72;
      }
      break;
    case 18:
    case 35:
    case 36:
    case 37:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001E030(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 582;
        goto LABEL_72;
      }
      break;
    case 19:
    case 30:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001DF50(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (unsigned __int8)v26 >= 2u )
      {
        v25 = 0;
        v24 = 597;
        goto LABEL_72;
      }
      break;
    case 20:
    case 34:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001DF50(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (unsigned __int8)v26 >= 2u )
      {
        v25 = 0;
        v24 = 612;
        goto LABEL_72;
      }
      break;
    case 21:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001E030(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 626;
        goto LABEL_72;
      }
      break;
    case 22:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001E030(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 640;
        goto LABEL_72;
      }
      break;
    case 23:
    case 115:
    case 116:
    case 117:
    case 118:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001DE80(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001DD70(0, 17);
        if ( (_BYTE)v19 )
        {
          *v8 = 256;
          *v5 = 2;
          *(_BYTE *)v6 = 17;
          return v19;
        }
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 665;
        goto LABEL_72;
      }
      break;
    case 24:
    case 119:
    case 120:
    case 121:
    case 122:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001DE80(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001DD70(1, 19);
        if ( (_BYTE)v19 )
        {
          *v8 = 512;
          *v5 = 2;
          *(_BYTE *)v6 = 19;
          return v19;
        }
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 691;
        goto LABEL_72;
      }
      break;
    case 27:
      *v5 = 2;
      LOBYTE(v19) = sub_1001E000(1);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001DC00(16);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 16;
        }
      }
      break;
    case 28:
      *v5 = 2;
      LOBYTE(v19) = sub_1001E000(2);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 2;
      }
      else
      {
        LOBYTE(v19) = sub_1001DC00(17);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 17;
        }
      }
      break;
    case 29:
      *v5 = 2;
      LOBYTE(v19) = sub_1001E000(3);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 3;
      }
      else
      {
        LOBYTE(v19) = sub_1001DC00(18);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 18;
        }
      }
      break;
    case 134:
      *v5 = 2;
      LOBYTE(v19) = sub_1001E000(21);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 21;
      }
      else
      {
        LOBYTE(v19) = sub_1001DC00(19);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 19;
        }
      }
      break;
    default:
      v20 = sub_1001E7B0(&a1, 1u, (int)&unk_100DE4E8, 12, 176, 176);
      LOBYTE(v26) = v20;
      if ( v20 >= 0xB0u )
      {
        v25 = 0;
        v24 = 848;
LABEL_72:
        LOBYTE(v19) = sub_10018A40("..\\lib\\adl\\iop_lru_utl.c", v24, v25, 0);
      }
      else
      {
        v21 = 6 * v20;
        v22 = dword_100DE4EC[2 * v21 / 4u];
        v19 = 2 * v21;
        *v8 = v22;
        LOBYTE(v22) = byte_100DE4F0[v19];
        *v5 = v22;
        switch ( (unsigned __int8)v22 )
        {
          case 0u:
            *(_DWORD *)v6 = *(int *)((char *)dword_100DE4EC + v19);
            break;
          case 2u:
            *(_BYTE *)v6 = byte_100DE4F1[v19];
            *(_BYTE *)(v6 + 1) = byte_100DE4F2[v19];
            break;
          case 1u:
            LOBYTE(v19) = byte_100DE4F1[v19];
            *(_BYTE *)v6 = v19;
            break;
          default:
            v25 = 0;
            v24 = 841;
            goto LABEL_72;
          case 4u:
          case 5u:
          case 6u:
            return v19;
        }
      }
      break;
  }
  return v19;
}
// 100DE4EC: using guessed type int dword_100DE4EC[];

//----- (10039E60) --------------------------------------------------------
int __cdecl sub_10039E60(signed int a1, char a2)
{
  int result; // eax@3
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10018600(10018, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10018600(10022, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 1u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10018600(10019, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10018600(10023, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 3u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10018600(10020, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10018600(10024, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 4u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10018600(10021, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10018600(10025, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 2u:
      result = sub_1004BB40(a2);
      v3 = result;
      break;
    default:
      sub_10018A40("..\\lib\\adl\\iop_freq_intf.c", 180, 1, 0);
      result = v3;
      break;
  }
  return result;
}

//----- (1003A020) --------------------------------------------------------
double __cdecl sub_1003A020(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_10222C5C + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_10222C5C + 12))() * v1);
}
// 10222C5C: using guessed type int dword_10222C5C;

//----- (1003A070) --------------------------------------------------------
int __cdecl sub_1003A070(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101ADC28 = *(_DWORD *)a1;
  dword_101ADC2C = *(_DWORD *)(a1 + 4);
  dword_101ADC30 = *(_DWORD *)(a1 + 8);
  dword_101ADC34 = *(_DWORD *)(a1 + 12);
  dword_10222C5C = (int)&dword_101ADC28;
  return result;
}
// 101ADC28: using guessed type int dword_101ADC28;
// 101ADC2C: using guessed type int dword_101ADC2C;
// 101ADC30: using guessed type int dword_101ADC30;
// 101ADC34: using guessed type int dword_101ADC34;
// 10222C5C: using guessed type int dword_10222C5C;

//----- (1003A0B0) --------------------------------------------------------
int __cdecl sub_1003A0B0(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1001E7B0(&a1, 1u, (int)&unk_100DFBD8, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100DFBD9 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1003A100) --------------------------------------------------------
char sub_1003A100()
{
  return 2;
}

//----- (1003A110) --------------------------------------------------------
char sub_1003A110()
{
  return 3;
}

//----- (1003A120) --------------------------------------------------------
char __cdecl sub_1003A120(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100F8E98[8 * a1];
  *a4 = word_100F8E9A[a2 + 4 * a1];
  return 1;
}
// 100F8E9A: using guessed type __int16 word_100F8E9A[];

//----- (1003A180) --------------------------------------------------------
char __cdecl sub_1003A180(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10018A40("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100FA760[16 * a1];
  *a4 = word_100FA768[a2 + 8 * a1];
  return 1;
}
// 100FA768: using guessed type __int16 word_100FA768[];

//----- (1003A1F0) --------------------------------------------------------
char sub_1003A1F0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10018640(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 1003A1F0: using guessed type int var_1C[7];

//----- (1003A270) --------------------------------------------------------
int __usercall sub_1003A270@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_10020790();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (1003A2B0) --------------------------------------------------------
int __cdecl sub_1003A2B0(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_1003A270(a1);
  v2 = result;
  if ( !result )
  {
    sub_10018A40("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (1003A2E0) --------------------------------------------------------
int __cdecl sub_1003A2E0(_BYTE *a1)
{
  return sub_10025190(a1, 0, 0x2710u, 5000, 0);
}

//----- (1003A300) --------------------------------------------------------
int __cdecl sub_1003A300(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 5u, 5u, 0);
}

//----- (1003A320) --------------------------------------------------------
int __cdecl sub_1003A320(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 6u, 0, 0);
}

//----- (1003A340) --------------------------------------------------------
int __cdecl sub_1003A340(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 0xEu, 1u, 0);
}

//----- (1003A360) --------------------------------------------------------
int __cdecl sub_1003A360(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 1u, 0, 0);
}

//----- (1003A390) --------------------------------------------------------
int __cdecl sub_1003A390(int a1)
{
  int result; // eax@1

  result = sub_1003A300((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1003A380(a1 + 12);
    if ( !result )
    {
      result = sub_1003A360((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_1003A340((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 1003A380: using guessed type _DWORD __cdecl sub_1003A380(_DWORD);

//----- (1003A3D0) --------------------------------------------------------
int __cdecl sub_1003A3D0(int a1)
{
  int result; // eax@1

  result = sub_1003EE20((void *)(a1 + 28));
  if ( !result )
    result = sub_1003A390(a1);
  return result;
}

//----- (1003A3F0) --------------------------------------------------------
signed int __fastcall sub_1003A3F0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (1003A400) --------------------------------------------------------
char __cdecl sub_1003A400(unsigned __int8 a1)
{
  return byte_100E17BC[6 * sub_1003A3F0(a1)];
}

//----- (1003A420) --------------------------------------------------------
__int16 __cdecl sub_1003A420(unsigned __int8 a1)
{
  return word_100E17B8[3 * sub_1003A3F0(a1)];
}
// 100E17B8: using guessed type __int16 word_100E17B8[];

//----- (1003A440) --------------------------------------------------------
char __cdecl sub_1003A440(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_1000F100(1, v2, a2) || sub_10038C80((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003A4F0) --------------------------------------------------------
char __cdecl sub_1003A4F0(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_1003A440(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (1003A560) --------------------------------------------------------
char *__cdecl sub_1003A560(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = &byte_10065A71;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (1003A5B0) --------------------------------------------------------
int sub_1003A5B0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10018160();
  result = 0;
  while ( 1 )
  {
    v3 = dword_1020D994[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_1020D994[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 1020D994: using guessed type int dword_1020D994[];

//----- (1003A5F0) --------------------------------------------------------
int __cdecl sub_1003A5F0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1003A660) --------------------------------------------------------
signed int __cdecl sub_1003A660(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1003A700) --------------------------------------------------------
int __usercall sub_1003A700@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_1003A660(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003A730) --------------------------------------------------------
signed int __usercall sub_1003A730@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_1003A660((_BYTE *)a3, (int)(&off_100E2FA8)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100E2FAC[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1004F1A8(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1004F1A8(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1004F1A8(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100E2FA8: using guessed type char *off_100E2FA8;

//----- (1003A900) --------------------------------------------------------
char *__usercall sub_1003A900@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (1003A960) --------------------------------------------------------
int __usercall sub_1003A960@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_1003A660((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003A9F0) --------------------------------------------------------
int __usercall sub_1003A9F0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_1003A700(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (1003AA40) --------------------------------------------------------
char **__usercall sub_1003AA40@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_1003A560(v6);
      if ( !sub_1003A660((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (1003AAA0) --------------------------------------------------------
const char *__usercall sub_1003AAA0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (1003AAC0) --------------------------------------------------------
int __usercall sub_1003AAC0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_1020D980[sub_1003A5B0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003AB00) --------------------------------------------------------
int __usercall sub_1003AB00@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_1003A730(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (1003AB90) --------------------------------------------------------
int __usercall sub_1003AB90@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (1003ACE0) --------------------------------------------------------
int __usercall sub_1003ACE0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1002F130(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_1003B5C0(v3, v6, 0);
        v7 = -*v3;
        sub_1002F130(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1002F130(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100E2C60);
      sub_1004BB90(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100E2C60);
      sub_1002F130(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (1003AD80) --------------------------------------------------------
int __usercall sub_1003AD80@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (1003ADC0) --------------------------------------------------------
char *__cdecl sub_1003ADC0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_1003A900(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_1003A900(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_1003A900(result, v5, (int)&v20);
      v10 = &byte_10065A71;
    }
    LOBYTE(v9) = 0;
    sub_1003A900(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_1003A900(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_1003A900(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_1003A900(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1002F0C0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 1003ADC0: using guessed type int var_61C[6];

//----- (1003AF70) --------------------------------------------------------
int __usercall sub_1003AF70@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_1003A560((char **)a1);
  result = sub_1002F150(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100E2C60);
  return result;
}

//----- (1003AFA0) --------------------------------------------------------
int __usercall sub_1003AFA0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100E2C60);
  v2 = (unsigned int)sub_1003A560((char **)a1);
  return sub_1002F130(10, v2);
}

//----- (1003AFD0) --------------------------------------------------------
void __cdecl sub_1003AFD0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_1003A560(v5);
            v7 = sub_1003A560((char **)v3);
            if ( !sub_1003A5F0(v7, (int)v6) )
            {
              v8 = sub_1003A560((char **)v3);
              sub_1002F1F0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_1003A560((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_1003A560((char **)v3);
        sub_1002F1F0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_1003AAA0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1002A000("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_1003A560((char **)v3);
            sub_1002F230(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_1003A5F0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_1003AAA0(v18);
                  v25 = sub_1002A000("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_1003A560((char **)v3);
                  sub_1002F230(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_1003A560((char **)v3);
                  sub_1002F230(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_1003A560((char **)v3);
              sub_1002F230(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_1003A560((char **)v3);
              sub_1002F230(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_1003A560((char **)v3);
              sub_1002F230(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_1003AFD0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_1003A560((char **)v3);
            sub_1002F230(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_1003A560((char **)v3);
            sub_1002F230(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_1003A560((char **)v3);
          sub_1002F230(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_1003A560((char **)v3);
        sub_1002F230(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_1003A560(a2);
      sub_1002F1F0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (1003B440) --------------------------------------------------------
int sub_1003B440()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_1020D980[sub_1003A5B0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_1003AFD0(i, 0, &v2);
  }
  return v2;
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003B490) --------------------------------------------------------
void *sub_1003B490()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_1020D980[0] = 0;
  dword_1020D984 = 0;
  dword_1020D988 = 0;
  dword_1020D98C = 0;
  dword_1020D990 = 0;
  result = &unk_1020D9A8;
  dword_1020D994[0] = -1;
  dword_1020D998 = -1;
  dword_1020D99C = -1;
  dword_1020D9A0 = -1;
  dword_1020D9A4 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_1003AD80((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 1020D980: using guessed type int dword_1020D980[];
// 1020D984: using guessed type int dword_1020D984;
// 1020D988: using guessed type int dword_1020D988;
// 1020D98C: using guessed type int dword_1020D98C;
// 1020D990: using guessed type int dword_1020D990;
// 1020D994: using guessed type int dword_1020D994[];
// 1020D998: using guessed type int dword_1020D998;
// 1020D99C: using guessed type int dword_1020D99C;
// 1020D9A0: using guessed type int dword_1020D9A0;
// 1020D9A4: using guessed type int dword_1020D9A4;

//----- (1003B4F0) --------------------------------------------------------
char *sub_1003B4F0()
{
  return (char *)&unk_1020D9A8 + 56 * sub_1003A5B0();
}

//----- (1003B510) --------------------------------------------------------
char sub_1003B510()
{
  return sub_1003B4F0()[33];
}

//----- (1003B520) --------------------------------------------------------
char __cdecl sub_1003B520(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_1003B4F0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1002ECB0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (1003B560) --------------------------------------------------------
int *__usercall sub_1003B560@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_1003B4F0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_1003A660((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (1003B5B0) --------------------------------------------------------
char **sub_1003B5B0()
{
  return &off_100E3010;
}
// 100E3010: using guessed type char *off_100E3010;

//----- (1003B5C0) --------------------------------------------------------
int __cdecl sub_1003B5C0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1002E270();
  v3 = sub_1003B4F0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_1003B440();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_1003AF70(a2);
    if ( a3 )
    {
      v7 = sub_1003ACE0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_1003ACE0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_1003AFA0(a2);
        return v7;
      }
    }
    sub_1003AFA0(a2);
    result = v7;
  }
  return result;
}

//----- (1003B670) --------------------------------------------------------
int __cdecl sub_1003B670(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_1003A900(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_1003A900(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_1003A900(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1002F0C0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_1003A900(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_1003A900(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_1003A900(v14, "group-begin", (int)&v29);
          sub_1002F0C0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_1003A560(v15);
          sub_1003B670(v16[2], v16[3], v16[4], v17, a4);
          sub_1003A560(v16);
          v18 = sub_1003ADC0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_1003A900(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_1003A900(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_1003A900(v20, "group-end", (int)&v29);
          result = sub_1002F0C0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_1003A900(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_1003A900(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_1003A900(v21, a4, (int)&v28);
          v23 = &byte_10065A71;
        }
        LOBYTE(v22) = 0;
        v24 = sub_1003A900(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_1003A900(v24, *(const char **)v5, (int)&v30);
        result = sub_1002F0C0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 1003B670: using guessed type int var_414[4];

//----- (1003B880) --------------------------------------------------------
char *__usercall sub_1003B880@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_1003A900(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_1003A900(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1002F0C0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_1003B670(a3, (int)a4, a5, a2, 0);
    result = sub_1003ADC0(a3, a4, a5, 0);
  }
  return result;
}
// 1003B880: using guessed type int var_20C[2];

//----- (1003B940) --------------------------------------------------------
char *__cdecl sub_1003B940(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_1020D980[sub_1003A5B0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_1003A560((char **)v2);
    sub_1003B880("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_1003B4F0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1003B880(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003B9E0) --------------------------------------------------------
int *__cdecl sub_1003B9E0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_1020D980[sub_1003A5B0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_1003A560(v2);
      if ( !sub_1003A660(a1, (int)v4) )
      {
        v5 = sub_1003A560(v3);
        sub_1003B880("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_1003B4F0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_1003A660(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1003B880(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003BAA0) --------------------------------------------------------
int __usercall sub_1003BAA0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_1003AAC0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_1003B5C0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_1003AAC0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_1003B5C0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_1003AF70(v5);
        sub_1003ACE0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_1003AFA0(v8);
          v10 = sub_1003AAC0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1003BC00) --------------------------------------------------------
signed int __usercall sub_1003BC00@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_1020D980[sub_1003A5B0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_1003B5C0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003BC70) --------------------------------------------------------
int __cdecl sub_1003BC70(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_1003B4F0();
  switch ( a1 )
  {
    case 9:
      sub_1002F130(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_1003A660((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_1003A660(v6, (int)"-q") )
            {
              sub_1003B9E0(v6);
              v9 = sub_1003B440();
              sub_1002F130(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1003B940(0);
              v8 = sub_1003B440();
              sub_1002F130(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1003B940(1);
            v7 = sub_1003B440();
            sub_1002F130(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1002F1B0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1002F130(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1003B940(0);
        v4 = sub_1003B440();
        sub_1002F130(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1002F130(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_1020D980[sub_1003A5B0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1003BC70 )
              v12(2, (int)&unk_100E2C60);
          }
        }
      }
      sub_1002E270();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1002F130(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_1020D980[sub_1003A5B0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1002F1B0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1003BAA0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1002F1B0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1003BC00((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1002F1B0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1003BC70 )
          v15(3, (int)&unk_100E2C60);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1003BC70: using guessed type int __cdecl sub_1003BC70(int, int);
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003BF50) --------------------------------------------------------
char **sub_1003BF50()
{
  return off_100E2E04;
}
// 100E2E04: using guessed type char *off_100E2E04[3];

//----- (1003BF60) --------------------------------------------------------
int __usercall sub_1003BF60@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_1003A9F0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_1003AB00(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1003BF50();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1003C050) --------------------------------------------------------
int __cdecl sub_1003C050(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_1003B4F0();
  *a1 = 0;
  v4 = sub_1002A000("Processing command '%s'", v2);
  sub_1002F1B0(3, (int)&unk_100ADB74, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_1003AB90(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1003BAA0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1003BC00((int)v3);
    v11 = 0;
    v6 = sub_1003A5B0();
    v7 = sub_1003AA40((int (**)(void))dword_1020D980[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_1003A960((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_1003A960((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1003B5C0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1003B5C0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1003BF60(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_1003B560(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1003BF60(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1003BF50();
        result = sub_1003BF60(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 1020D980: using guessed type int dword_1020D980[];
// 1003C050: using guessed type char var_2D4[720];

//----- (1003C290) --------------------------------------------------------
int sub_1003C290()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1003C050(&v4);
  if ( !sub_1003B4F0()[32] )
    sub_1002F130(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1002A000("%s %i, %s", "Command status:", v0, &v4);
    sub_1002F1B0(3, (int)&unk_100ADB74, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1002A000("%s %i", "Command status:", v0);
    sub_1002F1B0(3, (int)&unk_100ADB74, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1003C370) --------------------------------------------------------
int __cdecl sub_1003C370(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_1020D980[sub_1003A5B0()] = a1;
  sub_1003B4F0()[32] = a3;
  sub_1002E270();
  sub_1004A310(a2);
  v3 = sub_1003B5B0();
  sub_1002EBA0(v3);
  return sub_1003C290();
}
// 1020D980: using guessed type int dword_1020D980[];

//----- (1003C3C0) --------------------------------------------------------
int __cdecl sub_1003C3C0(int a1)
{
  return a1 + 9;
}

//----- (1003C3D0) --------------------------------------------------------
int __cdecl sub_1003C3D0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10018160();
  memset(a1, 0, 0xDCu);
  sub_1001F8F0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1003C3C0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1004BBA0((int)a1, (int)v3);
}

//----- (1003C450) --------------------------------------------------------
int __cdecl sub_1003C450(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1004BDB0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1003C480) --------------------------------------------------------
signed int __cdecl sub_1003C480(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1005F800(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_100181D0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_100181D0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1004BBA0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1003C4A0) --------------------------------------------------------
const char *__cdecl sub_1003C4A0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1003C4E0) --------------------------------------------------------
char __cdecl sub_1003C4E0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_1003A5B0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_1020DAC8 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1002F920((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1002F440((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1002F920((int)v6, 0);
      return v5;
    case 4:
      sub_1002F2C0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1002F5F0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1002F2B0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1002ECB0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1003C4A0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1002F8D0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        if ( v48 )
          sub_1002F8D0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        if ( v48 )
          sub_1002F8D0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1002F8D0((int)v6, v55);
              if ( v48 )
                sub_1002F8D0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1002F8D0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1002F8D0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1002F8D0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1002F520((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1002EFD0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1002F090((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1002EEE0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &byte_10065A71;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = &byte_10065A71;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = &byte_10065A71;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = &byte_10065A71;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &byte_10065A71;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &byte_10065A71;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = &byte_10065A71;
          v10 = sub_1002EFA0((const void **)a2, a3) == 0;
          v42 = &byte_10065A71;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1002ECE0((const void **)a2, a3) )
      {
        dword_1020DAC0 = 2;
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0((int)v6, "   Command Format:\r\n");
        sub_1002F8D0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1002F8D0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1002F8D0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1002F8D0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1002F8D0((int)v6, "                                         strings depending upon the command\r\n");
        sub_1002F8D0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1002F8D0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1002F8D0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0((int)v6, "   Notes:\r\n");
        sub_1002F8D0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1002F8D0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1002F8D0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1002F8D0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1002F8D0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1002F8D0((int)v6, "       without a test suite name.\r\n");
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0((int)v6, "   Examples:\r\n");
        sub_1002F8D0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1002F8D0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1002F8D0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1002F8D0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1002F8D0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1002F8D0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1002F8D0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1002F8D0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        sub_1002F8D0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1002F8D0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1002ED70((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, (const char *)&word_100E4624);
        return v5;
      }
      if ( sub_1002ED40((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_1020DAC0,
          &byte_10065A71,
          &v58,
          6 - dword_1020DAC0,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
        return v5;
      }
      if ( sub_1002EDA0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1002EDD0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_1020DAC0 += 2;
          return v5;
        }
        if ( sub_1002EE10((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_1020DAC0 < 2 )
            dword_1020DAC0 = 0;
          else
            dword_1020DAC0 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_1020DAC0,
          &byte_10065A71,
          a2[2],
          6 - dword_1020DAC0,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
        return v5;
      }
      if ( sub_1002ED10((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_1020DAC0,
          &byte_10065A71,
          a2[3],
          6 - dword_1020DAC0,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1002EE80((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
      }
      else if ( sub_1002EE50((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1003C4A0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1003C4A0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1002F8D0((int)v6, v55);
      }
      LOBYTE(v5) = sub_1002F580((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1002F850((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1002F8D0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100E4624: using guessed type __int16 word_100E4624;
// 1020DAC0: using guessed type int dword_1020DAC0;
// 1003C4E0: using guessed type char var_304[508];

//----- (1003D290) --------------------------------------------------------
signed int __cdecl sub_1003D290(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_1020DAC8 + 580 * sub_1003A5B0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1002F480(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1003D310) --------------------------------------------------------
char **__cdecl sub_1003D310(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_1020DAC8 + 580 * sub_1003A5B0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1002F690((int)v1, a1, (int)".txt");
  return &off_100E39F0;
}
// 100E39F0: using guessed type char *off_100E39F0;

//----- (1003D350) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D350(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_1003A5B0();
  return sub_1002F8D0((int)&unk_1020E620 + 1812 * v1, a1);
}

//----- (1003D370) --------------------------------------------------------
const char *sub_1003D370()
{
  return "See version control for test execution date";
}

//----- (1003D380) --------------------------------------------------------
__int64 sub_1003D380()
{
  return 0i64;
}

//----- (1003D390) --------------------------------------------------------
const char *sub_1003D390()
{
  return "Not Available";
}

//----- (1003D3A0) --------------------------------------------------------
int __usercall sub_1003D3A0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1003D3F0) --------------------------------------------------------
signed int __cdecl sub_1003D3F0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1003A5B0();
  return sub_1002F480(a1, a2, (int)&unk_1020E620 + 1812 * v2);
}

//----- (1003D540) --------------------------------------------------------
int __usercall sub_1003D540@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1004BE90((int)&a2[151 * (*a2 + 1)], (int)sub_1003D350, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1003D380();
  v4 = sub_1004A150("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1004C2E0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1004A150("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1004C2E0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1004C2E0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1004C260((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1004C0F0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1004A150("CFG_OutputTestRevision", (int)"False");
  if ( !sub_1003A660(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1004C260((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1004C260((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1002F5F0(v3);
  sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1004C1E0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1004A110(i, &v15, &v16); ++i )
  {
    sub_1004C260((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1004C330((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1004C1E0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1004C1E0((int)&a2[151 * (*a2 + 1)]);
  sub_1004C260((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1004C0F0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1003D540: using guessed type char var_103[253];

//----- (1003D8C0) --------------------------------------------------------
char __cdecl sub_1003D8C0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_1003A5B0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_1020E620 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1002F030(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1003D3A0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1004C260(v8, (int)"Req");
            sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1002F000(a2, a3) )
      {
        if ( sub_1002F790((int)v5, 3, 1, 0) )
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1004C1E0(v12);
          sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1004C0F0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1002EF40(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1004C330(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1002F060(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1004C330(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1002EFD0(a2, a3) )
      {
        if ( sub_1002F790((int)v5, 3, 1, 0) )
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1002F700((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1002EF70(a2, a3) )
      {
        sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1004C0F0(v13, (int)"success", (unsigned __int8 *)"0");
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1004C0F0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1002F790((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1002EF10(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1002F840((int)v5) )
            sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1004C330((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1002F790((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1002F2C0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1003D540((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1002F2B0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1004C330(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1004C330(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1004C330((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1002F840((int)v5) )
        sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1002EEB0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1004C190((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1004C330((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1002ECB0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1004C140((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1004C140((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1004C140((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100AD410, 3u) )
              v44 = &byte_10065A71;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1004C260(v19, (int)"Expected");
          sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1002F790((int)v5, 8, 1, 0) )
        sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1002F520((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1002F580((int)v5, (void (__cdecl *)(int))sub_1003D420);
      return v4;
    case 0:
    case 11:
      sub_1002F920((int)v5, (void (__cdecl *)(int))sub_1003D420);
      goto LABEL_139;
    case 1:
      sub_1002F440((int)v5);
      goto LABEL_139;
    case 12:
      sub_1002F850((int)v5, (void (__cdecl *)(int))sub_1003D420);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1004C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1004C0F0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1002F790((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1004C1E0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1003D420: using guessed type int sub_1003D420();
// 1003D8C0: using guessed type char var_104[255];

//----- (1003E6E0) --------------------------------------------------------
char **__cdecl sub_1003E6E0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_1020E620 + 1812 * sub_1003A5B0();
  *((_DWORD *)v1 + 146) = 0;
  sub_1002F690((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1004BE90(v2, (int)sub_1003D350, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100E4780;
}
// 100E4780: using guessed type char *off_100E4780;

//----- (1003E750) --------------------------------------------------------
int __cdecl sub_1003E750(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100E4BAE[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100E4BAE[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (1003E840) --------------------------------------------------------
__int16 __cdecl sub_1003E840(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (1003E890) --------------------------------------------------------
__int16 __cdecl sub_1003E890(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_1003E840((int)&v5, *a1);
  sub_1003E750((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (1003E910) --------------------------------------------------------
signed int __cdecl sub_1003E910(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_100216A0(v1) )
  {
    v2 = sub_10018540(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_100394D0(v8);
      if ( (v4 & sub_1001FDC0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_10024180(v8, v9);
    v6 = 0;
    while ( !sub_1001DCB0(v8, byte_100E4C25[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 1003E910: using guessed type char var_1AE[426];
// 1003E910: using guessed type char var_1B0[2];
// 1003E910: using guessed type char var_24C[68];

//----- (1003EA40) --------------------------------------------------------
char __cdecl sub_1003EA40(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int v4; // [sp+8h] [bp-250h]@0
  char v5[68]; // [sp+Ch] [bp-24Ch]@7
  char v6; // [sp+50h] [bp-208h]@1
  char v7[2]; // [sp+A8h] [bp-1B0h]@5
  char v8[426]; // [sp+AAh] [bp-1AEh]@4

  memset(&v6, 0, 0x202u);
  v2 = sub_1003E910(a2);
  if ( v2 == 256 || v2 == 512 )
  {
    LOBYTE(v4) = sub_10039550(v2);
    sub_10024180(v4, v5);
    if ( sub_1001DCB0(v4, byte_100E4C25[2 * a1]) && (a2 & (unsigned __int8)v5[12 * a1]) == a2 )
      return 1;
  }
  else if ( v2 == 0x8000 )
  {
    sub_10018540(6444, (int)&v6, 514);
    if ( v8[12 * a1] )
    {
      if ( (a2 & (unsigned __int8)v7[a1]) == a2 )
        return 1;
    }
  }
  return 0;
}
// 1003EA40: using guessed type char var_1AE[426];
// 1003EA40: using guessed type char var_1B0[2];
// 1003EA40: using guessed type char var_24C[68];

//----- (1003EB70) --------------------------------------------------------
char __cdecl sub_1003EB70(char *a1, char a2, char a3, char a4)
{
  signed int v4; // eax@1
  signed int v5; // esi@1
  int v7; // eax@9

  v4 = sub_1001F880(a1, (unsigned __int8)a2);
  v5 = v4;
  if ( v4 > (unsigned __int8)a3 )
    return 0;
  if ( a4 )
  {
    if ( v4 < 2 || strstr(a1, "00") == a1 || strstr(a1, "011") == a1 )
      return 0;
  }
  else if ( v4 < 4 || strstr(a1, "00") != a1 )
  {
    return 0;
  }
  v7 = 0;
  if ( v5 > 0 )
  {
    while ( word_100E15B8[(unsigned __int8)a1[v7]] & 0x210 )
    {
      if ( ++v7 >= v5 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 100E15B8: using guessed type __int16 word_100E15B8[];

//----- (1003EC10) --------------------------------------------------------
char __cdecl sub_1003EC10(char a1)
{
  return byte_100E5AD9[2 * (unsigned __int8)sub_1001E7B0(&a1, 1u, (int)&unk_100E5AD8, 2, 4, 3)];
}

//----- (1003EC40) --------------------------------------------------------
char __cdecl sub_1003EC40(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_1000F100(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10018A40("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1004BB00(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_1000F100(1, 538, a2);
  }
  if ( !v4 || sub_10038D90((int)v3) )
    return 0;
  return 1;
}

//----- (1003ECC0) --------------------------------------------------------
int __cdecl sub_1003ECC0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1003EC40(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1003ED10) --------------------------------------------------------
int __cdecl sub_1003ED10(unsigned __int8 *a1)
{
  return sub_10025140(a1, 0, 0, 0, 0);
}

//----- (1003ED30) --------------------------------------------------------
unsigned int __cdecl sub_1003ED30(void *a1)
{
  return sub_100250E0(a1, 0x20u, 0);
}

//----- (1003ED50) --------------------------------------------------------
unsigned int __cdecl sub_1003ED50(void *a1)
{
  return sub_100250E0(a1, 0x1Cu, 0);
}

//----- (1003ED70) --------------------------------------------------------
unsigned int __cdecl sub_1003ED70(void *a1)
{
  return sub_100250E0(a1, 0x10u, 0);
}

//----- (1003ED90) --------------------------------------------------------
unsigned int __cdecl sub_1003ED90(void *a1)
{
  return sub_100250E0(a1, 0xCu, 0);
}

//----- (1003EDB0) --------------------------------------------------------
unsigned int __cdecl sub_1003EDB0(void *a1)
{
  return sub_100250E0(a1, 8u, 0);
}

//----- (1003EDD0) --------------------------------------------------------
int __cdecl sub_1003EDD0(int a1)
{
  int result; // eax@1

  result = sub_10025140((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10025140((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_10025190((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (1003EE20) --------------------------------------------------------
int __cdecl sub_1003EE20(void *a1)
{
  int result; // eax@1

  result = sub_1003ED30((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1003ED30((char *)a1 + 128);
    if ( !result )
    {
      result = sub_1003EDB0((char *)a1 + 120);
      if ( !result )
      {
        result = sub_1003ED50((char *)a1 + 36);
        if ( !result )
        {
          result = sub_1003EDD0((int)a1 + 168);
          if ( !result )
          {
            result = sub_1003EDD0((int)a1 + 160);
            if ( !result )
            {
              result = sub_1003EDD0((int)a1 + 164);
              if ( !result )
              {
                result = sub_1003ED70(a1);
                if ( !result )
                {
                  result = sub_1003ED90((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_1003ED90((char *)a1 + 24);
                    if ( !result )
                      result = sub_1003EDB0((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1003EEF0) --------------------------------------------------------
unsigned int __cdecl sub_1003EEF0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1003ED30((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1003ED50((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1003ED70(a1);
      if ( !result )
      {
        result = sub_1003ED90((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1003ED90((char *)a1 + 24);
          if ( !result )
            result = sub_1003EDB0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1003EF50) --------------------------------------------------------
int __cdecl sub_1003EF50(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (1003EFA0) --------------------------------------------------------
char __cdecl sub_1003EFA0(char a1, int a2, int a3)
{
  int v3; // esi@1
  unsigned __int8 v4; // bl@2
  bool v5; // zf@3
  char v6; // dl@7
  int v8; // [sp+Ch] [bp-4h]@4

  v3 = a3;
  if ( *(_DWORD *)(a3 + 60) == 0x3FFFF )
    return 0;
  v4 = a2;
  if ( *(_DWORD *)(v3 + 8) != sub_10039E60(a2, 1) )
    return 0;
  v5 = *(_BYTE *)(v3 + 2) == -1;
  LOBYTE(a3) = 1;
  if ( v5 )
  {
    if ( !(a1 & 2) || *(float *)(v3 + 16) <= 370400.0 )
      return 1;
    return 0;
  }
  sub_10029B50((int)&v8, *(float *)(v3 + 32));
  sub_10029B50((int)&a2, *(float *)(v3 + 40));
  a2 = v8 - a2;
  sub_10018600(v4 + 2061, &v8, 4, &a2);
  if ( a1 & 1
    && (signed int)((a2 - v8 - ((unsigned int)(a2 - v8) >> 31)) ^ ((signed int)(a2 - v8 - ((unsigned int)(a2 - v8) >> 31)) >> 31)) > 119304647
    && *(float *)(v3 + 16) <= 92600.0 )
  {
    v6 = 0;
  }
  else
  {
    v6 = a3;
  }
  if ( a1 & 2 && *(float *)(v3 + 16) > 92600.0 )
    return 0;
  return v6;
}

//----- (1003F0B0) --------------------------------------------------------
void __cdecl sub_1003F0B0(char a1, int a2)
{
  int v2; // edi@4
  int v3; // eax@4
  int v4; // ecx@4
  int v5; // ecx@4
  char v6; // al@4
  signed int v7; // ST2C_4@5
  double v8; // st4@22
  double v9; // st6@22
  double v10; // st3@22
  double v11; // st2@27
  bool v12; // c0@27
  bool v13; // c3@27
  double v14; // st6@27
  float v15; // ST2C_4@48
  double v16; // st7@48
  bool v17; // zf@50
  bool v18; // [sp+1Fh] [bp-55h]@4
  float v19; // [sp+20h] [bp-54h]@48
  int v20; // [sp+24h] [bp-50h]@4
  int v21; // [sp+28h] [bp-4Ch]@4
  int v22; // [sp+2Ch] [bp-48h]@4
  int v23; // [sp+30h] [bp-44h]@4
  int v24; // [sp+34h] [bp-40h]@4
  char v25; // [sp+38h] [bp-3Ch]@4
  char v26; // [sp+48h] [bp-2Ch]@51
  char v27; // [sp+58h] [bp-1Ch]@47
  char v28; // [sp+68h] [bp-Ch]@6

  if ( !(unsigned __int8)sub_1001D470() || a1 != 3 && a1 != 4 )
  {
    *(float *)(a2 + 16) = 9.9999996e24;
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
    *(_BYTE *)(a2 + 64) = 0;
    *(float *)(a2 + 12) = 6.2831855;
    *(_BYTE *)(a2 + 71) = 0;
    *(float *)(a2 + 32) = 6.2831855;
    *(_BYTE *)(a2 + 2) = -1;
    *(float *)(a2 + 36) = 6.2831855;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 24) = 6.2831855;
    *(_BYTE *)(a2 + 1) = 0;
    *(_BYTE *)(a2 + 3) = 0;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(_BYTE *)(a2 + 4) = 0;
    *(float *)(a2 + 40) = 0.0;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 48) = 9.9999996e24;
    *(float *)(a2 + 52) = 9.9999996e24;
    *(float *)(a2 + 56) = 6.2831855;
    return;
  }
  v18 = sub_1001D660(0, (int)&v25);
  sub_100182A0(100, 10000);
  v2 = a2 + 71;
  v3 = 88 * (a1 == 4);
  *(_BYTE *)a2 = *(_BYTE *)(v3 + dword_10223500 + 68);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + dword_10223500 + 84);
  *(float *)(a2 + 20) = *(float *)(v3 + dword_10223500 + 92);
  *(float *)(a2 + 24) = *(float *)(v3 + dword_10223500 + 96);
  *(_BYTE *)(a2 + 1) = *(_BYTE *)(v3 + dword_10223500 + 69);
  *(_BYTE *)(a2 + 2) = *(_BYTE *)(v3 + dword_10223500 + 70);
  *(float *)(a2 + 32) = *(float *)(v3 + dword_10223500 + 100);
  *(float *)(a2 + 36) = *(float *)(v3 + dword_10223500 + 104);
  *(float *)(a2 + 40) = *(float *)(v3 + dword_10223500 + 108);
  *(float *)(a2 + 44) = *(float *)(v3 + dword_10223500 + 112);
  *(float *)(a2 + 48) = *(float *)(v3 + dword_10223500 + 116);
  *(float *)(a2 + 52) = *(float *)(v3 + dword_10223500 + 120);
  *(_BYTE *)(a2 + 3) = *(_BYTE *)(v3 + dword_10223500 + 74);
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(v3 + dword_10223500 + 88);
  v4 = dword_10223500;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v3 + dword_10223500 + 147);
  *(_WORD *)(a2 + 68) = *(_WORD *)(v3 + v4 + 151);
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(v3 + v4 + 153);
  v5 = v3 + dword_10223500 + 147;
  *(_DWORD *)v2 = *(_DWORD *)v5;
  *(_WORD *)(v2 + 4) = *(_WORD *)(v5 + 4);
  *(_BYTE *)(v2 + 6) = *(_BYTE *)(v5 + 6);
  v21 = *(_DWORD *)(v3 + dword_10223500 + 132);
  v22 = *(_DWORD *)(v3 + dword_10223500 + 136);
  v23 = *(_DWORD *)(v3 + dword_10223500 + 124);
  v24 = *(_DWORD *)(v3 + dword_10223500 + 128);
  sub_10018280(100);
  *(float *)(a2 + 56) = 6.2831855;
  v6 = sub_10029980(a1, &v20);
  *(_BYTE *)(a2 + 4) = v6;
  if ( v6 )
  {
    v7 = (signed __int16)(v20 + -32768);
    v20 -= 0x8000;
    *(float *)(a2 + 56) = (double)v7 * 0.00009587379924285279;
  }
  if ( !sub_100298C0(a1, &v28) )
    v28 = 0;
  if ( strcmp(&v28, (const char *)(a2 + 71)) || *(_BYTE *)v2 == 95 )
    *(_BYTE *)v2 = 0;
  *(_BYTE *)(a2 + 75) = 0;
  if ( !v18 && !*(_BYTE *)v2 )
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 20)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 20) > 9.9999996e24 )
  {
    *(float *)(a2 + 20) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 20) < -1000.0 )
  {
    *(float *)(a2 + 20) = -1000.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 32)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 32) > 6.283185482025146 )
  {
    v10 = 6.2831855;
    *(float *)(a2 + 32) = 6.2831855;
  }
  else
  {
    if ( *(float *)(a2 + 32) < -6.283185482025146 )
    {
      v8 = -6.2831855;
      v9 = 6.283185482025146;
      *(float *)(a2 + 32) = -6.2831855;
      v10 = 6.2831855;
      goto LABEL_26;
    }
    v10 = 6.2831855;
  }
  v9 = 6.283185482025146;
  v8 = -6.2831855;
LABEL_26:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 40)) & 0x7F800000) == 2139095040 )
  {
    v14 = v10;
  }
  else
  {
    v11 = *(float *)(a2 + 40);
    v12 = v11 < v9;
    v13 = v11 == v9;
    v14 = v10;
    if ( v12 || v13 )
    {
      if ( *(float *)(a2 + 40) < -6.283185482025146 )
        *(float *)(a2 + 40) = v8;
      goto LABEL_32;
    }
  }
  *(float *)(a2 + 40) = v14;
LABEL_32:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 44)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 44) > 9.9999996e24 )
  {
    *(float *)(a2 + 44) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 44) < 0.0 )
  {
    *(float *)(a2 + 44) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 48)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 48) > 9.9999996e24 )
  {
    *(float *)(a2 + 48) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 48) < 0.0 )
  {
    *(float *)(a2 + 48) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 36)) & 0x7F800000) == 2139095040
    || *(float *)(a2 + 36) > 0.17453292
    || *(float *)(a2 + 36) < 0.0 )
  {
    *(float *)(a2 + 36) = 0.0;
  }
  if ( *(_DWORD *)(a2 + 60) == 0x3FFFF )
  {
    *(float *)(a2 + 32) = v14;
    *(float *)(a2 + 36) = v14;
    *(_BYTE *)(a2 + 2) = -1;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(_BYTE *)(a2 + 1) = 0;
    *(float *)(a2 + 16) = 9.9999996e24;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 12) = v14;
    *(float *)(a2 + 24) = v14;
  }
  else
  {
    sub_100393B0((int)&v21, (int)&unk_100E5B98);
    sub_1004CC50((int)&v21, (int)&v27);
    if ( v18 )
    {
      sub_1005FE90((int)&v27, (int)&v25, (float *)(a2 + 16), &v19);
      v15 = v19 + 3.141592741012573;
      v16 = sub_1004CBD0(v15);
    }
    else
    {
      *(float *)(a2 + 16) = 9.9999996e24;
      v16 = 6.2831855;
    }
    v17 = *(_BYTE *)(a2 + 1) == 0;
    *(float *)(a2 + 12) = v16;
    if ( v17
      || (sub_1003EF50(6.2831855, -6.2831855),
          sub_100393B0((int)&v23, (int)&unk_100E5B98),
          sub_1004CC50((int)&v23, (int)&v26),
          !v18) )
    {
      *(float *)(a2 + 28) = 9.9999996e24;
    }
    else
    {
      sub_1005FE90((int)&v25, (int)&v26, (float *)(a2 + 28), &v19);
    }
  }
}
// 10223500: using guessed type int dword_10223500;

//----- (1003F650) --------------------------------------------------------
unsigned __int8 __cdecl sub_1003F650(unsigned __int16 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int16 v4; // ax@1
  unsigned __int16 v5; // cx@1
  unsigned __int8 result; // al@4
  int v7; // [sp+0h] [bp-10h]@1
  unsigned int v8; // [sp+4h] [bp-Ch]@1
  int v9; // [sp+8h] [bp-8h]@1
  int v10; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v4 = a1;
  v5 = a1 & 0x2000;
  if ( a1 & 0x2000 )
    v4 = a1 & 0xDFFF;
  else
    v5 = a1;
  LOWORD(v9) = v4;
  v8 = __PAIR__(__PAIR__(a3, a2), v5) & 0x1FFFFFF;
  BYTE2(v9) = a4;
  result = a3;
  LOWORD(v7) = (a2 != 0) - 0x7FFF;
  if ( !(a3 & 2) )
  {
    if ( v5 == 47 || v5 == 48 || v5 == 49 || v5 == 50 || v5 == 51 || v5 == 52 || v5 == 53 || v5 == 46 )
      sub_1001FE30(SBYTE3(v8));
    result = sub_10018300(7, (int)&v7, 20, 1);
  }
  return result;
}

//----- (1003F710) --------------------------------------------------------
__int16 *__cdecl sub_1003F710(char a1, unsigned __int16 a2)
{
  char *v2; // eax@1
  signed int v3; // ecx@1
  unsigned __int8 v4; // bl@3
  char v5; // cl@6
  int v6; // eax@6
  unsigned __int16 *v7; // esi@25
  int v8; // edi@25
  int v9; // eax@29
  unsigned __int16 *v10; // esi@32
  int v11; // edi@32
  int v12; // eax@36
  char v14; // [sp+8h] [bp-224h]@3
  char v15; // [sp+9h] [bp-223h]@3
  unsigned __int8 v16; // [sp+Ah] [bp-222h]@3
  char v17; // [sp+Bh] [bp-221h]@26
  unsigned __int16 v18; // [sp+Ch] [bp-220h]@26
  char v19[4]; // [sp+10h] [bp-21Ch]@3
  char v20; // [sp+14h] [bp-218h]@4
  char v21[20]; // [sp+15h] [bp-217h]@8
  char v22; // [sp+29h] [bp-203h]@9
  __int16 v23; // [sp+2Ch] [bp-200h]@13
  __int16 v24; // [sp+2Eh] [bp-1FEh]@15
  __int16 v25[100]; // [sp+98h] [bp-194h]@3
  __int16 v26[100]; // [sp+160h] [bp-CCh]@3

  v2 = byte_102119E2;
  v3 = 203;
  do
  {
    *((_WORD *)v2 - 1) = a2;
    *v2 = 3;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  memset(v26, 0, 0xC8u);
  memset(v25, 0, 0xC8u);
  v19[0] = 0;
  do
  {
    if ( !sub_1004C410(v19[0], &v20) )
      goto LABEL_20;
    if ( v20 )
    {
LABEL_9:
      ++v15;
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          if ( !v23 )
            goto LABEL_20;
          v25[v4] = v23;
LABEL_19:
          ++v4;
          goto LABEL_20;
        }
        if ( v22 != 2 )
          goto LABEL_20;
      }
      else if ( v24 )
      {
        v26[v16++] = v24;
      }
      if ( !v23 )
        goto LABEL_20;
      v25[v4] = v23;
      goto LABEL_19;
    }
    v5 = 0;
    v6 = 0;
    while ( v5 )
    {
      v5 = v21[v6++];
      if ( v5 != *(&byte_10065A71 + v6) )
        goto LABEL_9;
    }
LABEL_20:
    ++v19[0];
  }
  while ( v19[0] < 0x64u );
  if ( v15 )
  {
    if ( !a1 )
    {
      word_102119E0[0] = 6;
      byte_102119E2[0] = 1;
      word_102119E4 = 10;
      byte_102119E6 = 1;
      v14 = 2;
    }
    if ( v4 )
    {
      v7 = (unsigned __int16 *)v25;
      v8 = v4;
      do
      {
        if ( sub_1003A180(*v7, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v9 = 2 * (unsigned __int8)v14;
          word_102119E0[v9] = v18;
          byte_102119E2[v9 * 2] = 1;
          ++v14;
        }
        ++v7;
        --v8;
      }
      while ( v8 );
    }
    if ( v16 )
    {
      v10 = (unsigned __int16 *)v26;
      v11 = v16;
      do
      {
        if ( sub_1003A120(*v10, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v12 = 2 * (unsigned __int8)v14;
          word_102119E0[v12] = v18;
          byte_102119E2[v12 * 2] = 1;
          ++v14;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  return word_102119E0;
}
// 102119E0: using guessed type __int16 word_102119E0[];
// 102119E4: using guessed type __int16 word_102119E4;
// 102119E6: using guessed type char byte_102119E6;
// 1003F710: using guessed type __int16 var_CC[100];
// 1003F710: using guessed type __int16 var_194[100];
// 1003F710: using guessed type char var_217[20];

//----- (1003F980) --------------------------------------------------------
int __cdecl sub_1003F980(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100E8990 + a1);
        break;
      case 0:
        result = (int)*(&off_100E899C + a1);
        break;
      case 1:
        result = (int)*(&off_100E89A8 + a1);
        break;
      case 2:
        result = (int)*(&off_100E89B4 + a1);
        break;
      case 3:
        result = (int)*(&off_100E89C0 + a1);
        break;
      case 5:
        result = (int)*(&off_100E89CC + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100E8990: using guessed type void *off_100E8990;
// 100E899C: using guessed type void *off_100E899C;
// 100E89A8: using guessed type void *off_100E89A8;
// 100E89B4: using guessed type void *off_100E89B4;
// 100E89C0: using guessed type void *off_100E89C0;
// 100E89CC: using guessed type void *off_100E89CC;

//----- (1003FA00) --------------------------------------------------------
int __cdecl sub_1003FA00(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100E8900 + a1);
        break;
      case 0:
        result = (int)*(&off_100E890C + a1);
        break;
      case 1:
        result = (int)*(&off_100E8918 + a1);
        break;
      case 2:
        result = (int)*(&off_100E8924 + a1);
        break;
      case 3:
        result = (int)*(&off_100E8930 + a1);
        break;
      case 5:
        result = (int)*(&off_100E893C + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100E8900: using guessed type void *off_100E8900;
// 100E890C: using guessed type void *off_100E890C;
// 100E8918: using guessed type void *off_100E8918;
// 100E8924: using guessed type void *off_100E8924;
// 100E8930: using guessed type void *off_100E8930;
// 100E893C: using guessed type void *off_100E893C;

//----- (1003FA80) --------------------------------------------------------
int __cdecl sub_1003FA80(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100E89D8 + a1);
        break;
      case 0:
        result = (int)*(&off_100E89E4 + a1);
        break;
      case 1:
        result = (int)*(&off_100E89F0 + a1);
        break;
      case 2:
        result = (int)*(&off_100E89FC + a1);
        break;
      case 3:
        result = (int)*(&off_100E8A08 + a1);
        break;
      case 5:
        result = (int)*(&off_100E8A14 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100E89D8: using guessed type void *off_100E89D8;
// 100E89E4: using guessed type void *off_100E89E4;
// 100E89F0: using guessed type void *off_100E89F0;
// 100E89FC: using guessed type void *off_100E89FC;
// 100E8A08: using guessed type void *off_100E8A08;
// 100E8A14: using guessed type void *off_100E8A14;

//----- (1003FB00) --------------------------------------------------------
void *__cdecl sub_1003FB00(unsigned __int8 a1, char a2)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = *(&off_100E8948 + a1);
        break;
      case 0:
        result = *(&off_100E8954 + a1);
        break;
      case 1:
        result = *(&off_100E8960 + a1);
        break;
      case 2:
        result = *(&off_100E896C + a1);
        break;
      case 3:
        result = *(&off_100E8978 + a1);
        break;
      case 5:
        result = &unk_100E7CDC;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100E8948: using guessed type void *off_100E8948;
// 100E8954: using guessed type void *off_100E8954;
// 100E8960: using guessed type void *off_100E8960;
// 100E896C: using guessed type void *off_100E896C;
// 100E8978: using guessed type void *off_100E8978;

//----- (1003FB80) --------------------------------------------------------
int __cdecl sub_1003FB80(char a1)
{
  return sub_1001E7B0(&a1, 1u, (int)&unk_100E8A20, 28, 12, 11);
}

//----- (1003FBA0) --------------------------------------------------------
int __cdecl sub_1003FBA0(char a1)
{
  return sub_1001E7B0(&a1, 1u, (int)&unk_100E8390, 16, 11, 11);
}

//----- (1003FBC0) --------------------------------------------------------
int __cdecl sub_1003FBC0(char a1)
{
  return sub_1001E7B0(&a1, 1u, (int)&unk_100E8440, 64, 19, 19);
}

//----- (1003FBE0) --------------------------------------------------------
void *__cdecl sub_1003FBE0(char a1, unsigned __int8 a2, char a3)
{
  void *v3; // esi@1
  unsigned __int8 v4; // al@3
  void *result; // eax@4

  v3 = 0;
  if ( a2 >= 3u || (unsigned __int8)a1 > 0x3Fu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1003FB80(a1);
    switch ( a3 )
    {
      case 6:
        result = &unk_100E7CC8;
        break;
      case 0:
        result = *(&off_100E8A24 + a2 + 7 * v4);
        break;
      case 1:
        result = *(&off_100E8A30 + a2 + 7 * v4);
        break;
      case 2:
        result = &unk_100E7CD4;
        break;
      case 3:
        result = &unk_100E7CD8;
        break;
      case 5:
        v3 = &unk_100E7CDC;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100E8A24: using guessed type void *off_100E8A24;
// 100E8A30: using guessed type void *off_100E8A30;

//----- (1003FCA0) --------------------------------------------------------
void *__cdecl sub_1003FCA0(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0xBu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1003FBA0(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_100E8394 + a1 + 4 * v4);
        break;
      case 0:
        result = &unk_100E7CCC;
        break;
      case 1:
        result = &unk_100E7CD0;
        break;
      case 2:
        result = &unk_100E7CD4;
        break;
      case 3:
        result = &unk_100E7CD8;
        break;
      case 5:
        v3 = &unk_100E7CDC;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100E8394: using guessed type void *off_100E8394;

//----- (1003FD40) --------------------------------------------------------
void *__cdecl sub_1003FD40(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0x13u )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1003FBC0(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_100E8444 + a1 + 16 * v4);
        break;
      case 0:
        result = *(&off_100E8450 + a1 + 16 * v4);
        break;
      case 1:
        result = *(&off_100E845C + a1 + 16 * v4);
        break;
      case 2:
        result = *(&off_100E8468 + a1 + 16 * v4);
        break;
      case 3:
        result = *(&off_100E8474 + a1 + 16 * v4);
        break;
      case 5:
        v3 = &unk_100E7CDC;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100E8444: using guessed type void *off_100E8444;
// 100E8450: using guessed type void *off_100E8450;
// 100E845C: using guessed type void *off_100E845C;
// 100E8468: using guessed type void *off_100E8468;
// 100E8474: using guessed type void *off_100E8474;

//----- (1003FE10) --------------------------------------------------------
char sub_1003FE10()
{
  return *(_BYTE *)(dword_1021A3CC + 33316);
}
// 1021A3CC: using guessed type int dword_1021A3CC;

//----- (1003FE20) --------------------------------------------------------
BOOL __fastcall sub_1003FE20(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10003BF0(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (1003FE50) --------------------------------------------------------
void *__cdecl sub_1003FE50(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100E8CE4;
      break;
    case 0:
      result = &unk_100E8CE8;
      break;
    case 1:
      result = &unk_100E8CEC;
      break;
    case 2:
      result = &unk_100E8CF8;
      break;
    case 3:
      result = &unk_100E8CF4;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1003FEA0) --------------------------------------------------------
char sub_1003FEA0()
{
  signed int v0; // esi@1
  char result; // al@11

  qmemcpy(dword_102123B0, &unk_100E8DB0, 0x5Cu);
  v0 = 23;
  if ( sub_100216C0(0) == 1 )
  {
    dword_1021240C = 65569;
    dword_10212410 = 65910;
    dword_10212414 = 65909;
    dword_10212418 = 65912;
    dword_1021241C = 65914;
    dword_10212420 = 65913;
    dword_10212424 = 65578;
    dword_10212428 = 65852;
    dword_1021242C = 65908;
    dword_10212430 = 65898;
    v0 = 33;
  }
  if ( sub_100216C0(7u) == 1 || sub_100216C0(8u) == 1 )
    dword_102123B0[v0++] = 65635;
  if ( sub_1003EA40(0, 4u) || sub_1003EA40(1u, 4u) )
  {
    dword_102123B0[v0] = 65951;
    dword_102123B4[v0] = 65952;
    dword_102123B8[v0] = 65950;
    dword_102123BC[v0] = 65949;
    dword_102123C0[v0] = 65953;
    v0 += 5;
  }
  if ( sub_100216C0(2u) == 1 )
  {
    dword_102123B0[v0] = 65906;
    dword_102123B4[v0] = 65905;
    dword_102123B8[v0] = 65907;
    dword_102123BC[v0] = 65912;
    dword_102123C0[v0] = 65914;
    dword_102123C4[v0] = 65913;
    dword_102123C8[v0] = 65578;
    dword_102123CC[v0] = 65569;
    dword_102123D0[v0] = 65944;
    dword_102123D4[v0] = 65945;
    dword_102123D8[v0] = 65946;
    dword_102123DC[v0] = 65947;
    dword_102123E0[v0] = 65954;
    v0 += 13;
  }
  result = sub_1004C4C0(1);
  if ( result )
  {
    dword_102123B0[v0] = 65569;
    dword_102123B4[v0] = 65944;
    dword_102123B8[v0] = 65945;
    dword_102123BC[v0] = 65946;
    dword_102123C0[v0] = 65947;
    result = 122;
    dword_102123C4[v0] = 65954;
    dword_102123C8[v0] = 65912;
    dword_102123CC[v0] = 65914;
    dword_102123D0[v0] = 65913;
    dword_102123D4[v0] = 65578;
    v0 += 10;
  }
  LOWORD(dword_102123B0[v0]) = 904;
  BYTE2(dword_102123B0[v0]) = 3;
  return result;
}
// 102123B0: using guessed type int dword_102123B0[];
// 102123B4: using guessed type int dword_102123B4[];
// 102123B8: using guessed type int dword_102123B8[];
// 102123BC: using guessed type int dword_102123BC[];
// 102123C0: using guessed type int dword_102123C0[];
// 102123C4: using guessed type int dword_102123C4[];
// 102123C8: using guessed type int dword_102123C8[];
// 102123CC: using guessed type int dword_102123CC[];
// 102123D0: using guessed type int dword_102123D0[];
// 102123D4: using guessed type int dword_102123D4[];
// 102123D8: using guessed type int dword_102123D8[];
// 102123DC: using guessed type int dword_102123DC[];
// 102123E0: using guessed type int dword_102123E0[];
// 1021240C: using guessed type int dword_1021240C;
// 10212410: using guessed type int dword_10212410;
// 10212414: using guessed type int dword_10212414;
// 10212418: using guessed type int dword_10212418;
// 1021241C: using guessed type int dword_1021241C;
// 10212420: using guessed type int dword_10212420;
// 10212424: using guessed type int dword_10212424;
// 10212428: using guessed type int dword_10212428;
// 1021242C: using guessed type int dword_1021242C;
// 10212430: using guessed type int dword_10212430;

//----- (10040130) --------------------------------------------------------
int *__cdecl sub_10040130(char a1)
{
  int *result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = (int *)&unk_100E8CE4;
      break;
    case 0:
      result = (int *)&unk_100E8DA0;
      break;
    case 1:
      result = (int *)&unk_100E8CEC;
      break;
    case 2:
      sub_1003FEA0();
      result = dword_102123B0;
      break;
    case 3:
      result = (int *)&unk_100E8EA4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 102123B0: using guessed type int dword_102123B0[];

//----- (10040190) --------------------------------------------------------
bool __thiscall sub_10040190(void *this)
{
  return (sub_1001FDC0(this) & 0x800) == 2048;
}

//----- (100401B0) --------------------------------------------------------
void *__cdecl sub_100401B0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100E8F30;
        break;
      case 0:
        result = &unk_100E8F34;
        break;
      case 1:
        result = &unk_100E8F38;
        break;
      case 2:
        result = &unk_100E8F8C;
        break;
      case 3:
        result = &unk_100E8FB0;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10040210) --------------------------------------------------------
int __cdecl sub_10040210(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x33u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100ED194 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100ED19C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100ED1A4 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100ED1AC + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100ED1B4 + a1 + 11 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 189, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100ED194: using guessed type void *off_100ED194;
// 100ED19C: using guessed type void *off_100ED19C;
// 100ED1A4: using guessed type void *off_100ED1A4;
// 100ED1AC: using guessed type void *off_100ED1AC;
// 100ED1B4: using guessed type void *off_100ED1B4;

//----- (100402E0) --------------------------------------------------------
int __cdecl sub_100402E0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // cl@2
  int result; // eax@8
  int v6; // [sp-Ch] [bp-7Ch]@13
  char v7; // [sp-8h] [bp-78h]@13
  char v8; // [sp+8h] [bp-68h]@6

  if ( a1 >= 2u || (v4 = a2, a2 >= 0xAu) || a3 >= 4u )
  {
LABEL_22:
    result = 0;
  }
  else if ( a3 == 1 )
  {
    if ( !a2 )
    {
      _snprintf(&v8, 0x64u, "INVALID CONFIG: anlg_in chnl %d - format %d", 0, 1);
      sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 265, 0, &v8);
      v4 = 0;
    }
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_100EDA58 + a1 + 10 * v4);
        break;
      case 0:
        result = (int)*(&off_100EDA60 + a1 + 10 * v4);
        break;
      case 1:
        result = (int)*(&off_100EDA68 + a1 + 10 * v4);
        break;
      case 2:
        result = (int)*(&off_100EDA70 + a1 + 10 * v4);
        break;
      case 3:
        result = (int)*(&off_100EDA78 + a1 + 10 * v4);
        break;
      default:
        v7 = 0;
        v6 = 292;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_100EDBE8 + a1 + 10 * a3);
        break;
      case 0:
        result = (int)*(&off_100EDBF0 + a1 + 10 * a3);
        break;
      case 1:
        result = (int)*(&off_100EDBF8 + a1 + 10 * a3);
        break;
      case 2:
        result = (int)*(&off_100EDC00 + a1 + 10 * a3);
        break;
      case 3:
        result = (int)*(&off_100EDC08 + a1 + 10 * a3);
        break;
      default:
        v7 = 0;
        v6 = 322;
LABEL_21:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", v6, v7, 0);
        goto LABEL_22;
    }
  }
  return result;
}
// 100EDA58: using guessed type void *off_100EDA58;
// 100EDA60: using guessed type void *off_100EDA60;
// 100EDA68: using guessed type void *off_100EDA68;
// 100EDA70: using guessed type void *off_100EDA70;
// 100EDA78: using guessed type void *off_100EDA78;
// 100EDBE8: using guessed type void *off_100EDBE8;
// 100EDBF0: using guessed type void *off_100EDBF0;
// 100EDBF8: using guessed type void *off_100EDBF8;
// 100EDC00: using guessed type void *off_100EDC00;
// 100EDC08: using guessed type void *off_100EDC08;

//----- (10040580) --------------------------------------------------------
int __cdecl sub_10040580(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0xBu )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100EDC88 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_100EDC90 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_100EDC98 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_100EDCA0 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_100EDCA8 + a1 + 10 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 407, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100EDC88: using guessed type void *off_100EDC88;
// 100EDC90: using guessed type void *off_100EDC90;
// 100EDC98: using guessed type void *off_100EDC98;
// 100EDCA0: using guessed type void *off_100EDCA0;
// 100EDCA8: using guessed type void *off_100EDCA8;

//----- (10040650) --------------------------------------------------------
int __cdecl sub_10040650(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 8u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100EDE44 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100EDE4C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100EDE54 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100EDE5C + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100EDE64 + a1 + 11 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 606, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100EDE44: using guessed type void *off_100EDE44;
// 100EDE4C: using guessed type void *off_100EDE4C;
// 100EDE54: using guessed type void *off_100EDE54;
// 100EDE5C: using guessed type void *off_100EDE5C;
// 100EDE64: using guessed type void *off_100EDE64;

//----- (10040720) --------------------------------------------------------
int __cdecl sub_10040720(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 3u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100EDFA0 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_100EDFA8 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_100EDFB0 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_100EDFB8 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_100EDFC0 + a1 + 10 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 689, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100EDFA0: using guessed type void *off_100EDFA0;
// 100EDFA8: using guessed type void *off_100EDFA8;
// 100EDFB0: using guessed type void *off_100EDFB0;
// 100EDFB8: using guessed type void *off_100EDFB8;
// 100EDFC0: using guessed type void *off_100EDFC0;

//----- (100407F0) --------------------------------------------------------
int __cdecl sub_100407F0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EE018 + a1);
        break;
      case 0:
        result = (int)*(&off_100EE020 + a1);
        break;
      case 1:
        result = (int)*(&off_100EE028 + a1);
        break;
      case 2:
        result = (int)*(&off_100EE030 + a1);
        break;
      case 3:
        result = (int)*(&off_100EE038 + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 768, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100EE018: using guessed type void *off_100EE018;
// 100EE020: using guessed type void *off_100EE020;
// 100EE028: using guessed type void *off_100EE028;
// 100EE030: using guessed type void *off_100EE030;
// 100EE038: using guessed type void *off_100EE038;

//----- (10040880) --------------------------------------------------------
int __cdecl sub_10040880(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EE040 + a1);
        break;
      case 0:
        result = (int)*(&off_100EE048 + a1);
        break;
      case 1:
        result = (int)*(&off_100EE050 + a1);
        break;
      case 2:
        result = (int)*(&off_100EE058 + a1);
        break;
      case 3:
        result = (int)*(&off_100EE060 + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 847, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100EE040: using guessed type void *off_100EE040;
// 100EE048: using guessed type void *off_100EE048;
// 100EE050: using guessed type void *off_100EE050;
// 100EE058: using guessed type void *off_100EE058;
// 100EE060: using guessed type void *off_100EE060;

//----- (10040910) --------------------------------------------------------
int __cdecl sub_10040910(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EE068 + a1);
        break;
      case 0:
        result = (int)*(&off_100EE070 + a1);
        break;
      case 1:
        result = (int)*(&off_100EE078 + a1);
        break;
      case 2:
        result = (int)*(&off_100EE080 + a1);
        break;
      case 3:
        result = (int)*(&off_100EE088 + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 927, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100EE068: using guessed type void *off_100EE068;
// 100EE070: using guessed type void *off_100EE070;
// 100EE078: using guessed type void *off_100EE078;
// 100EE080: using guessed type void *off_100EE080;
// 100EE088: using guessed type void *off_100EE088;

//----- (100409A0) --------------------------------------------------------
int __cdecl sub_100409A0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x31u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100EE094 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100EE09C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100EE0A4 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100EE0AC + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100EE0B4 + a1 + 11 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1118, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100EE094: using guessed type void *off_100EE094;
// 100EE09C: using guessed type void *off_100EE09C;
// 100EE0A4: using guessed type void *off_100EE0A4;
// 100EE0AC: using guessed type void *off_100EE0AC;
// 100EE0B4: using guessed type void *off_100EE0B4;

//----- (10040A70) --------------------------------------------------------
int __cdecl sub_10040A70(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x1Du )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100EE904 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100EE90C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100EE914 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100EE91C + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100EE924 + a1 + 11 * a2);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1308, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100EE904: using guessed type void *off_100EE904;
// 100EE90C: using guessed type void *off_100EE90C;
// 100EE914: using guessed type void *off_100EE914;
// 100EE91C: using guessed type void *off_100EE91C;
// 100EE924: using guessed type void *off_100EE924;

//----- (10040B40) --------------------------------------------------------
int __cdecl sub_10040B40(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EEE24 + a1);
        break;
      case 0:
        result = (int)*(&off_100EEE2C + a1);
        break;
      case 1:
        result = (int)*(&off_100EEE34 + a1);
        break;
      case 2:
        result = (int)*(&off_100EEE3C + a1);
        break;
      case 3:
        result = (int)*(&off_100EEE44 + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1466, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100EEE24: using guessed type void *off_100EEE24;
// 100EEE2C: using guessed type void *off_100EEE2C;
// 100EEE34: using guessed type void *off_100EEE34;
// 100EEE3C: using guessed type void *off_100EEE3C;
// 100EEE44: using guessed type void *off_100EEE44;

//----- (10040BD0) --------------------------------------------------------
int __cdecl sub_10040BD0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EEE4C + a1);
        break;
      case 0:
        result = (int)*(&off_100EEE54 + a1);
        break;
      case 1:
        result = (int)*(&off_100EEE5C + a1);
        break;
      case 2:
        result = (int)*(&off_100EEE64 + a1);
        break;
      case 3:
        result = (int)*(&off_100EEE6C + a1);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1545, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100EEE4C: using guessed type void *off_100EEE4C;
// 100EEE54: using guessed type void *off_100EEE54;
// 100EEE5C: using guessed type void *off_100EEE5C;
// 100EEE64: using guessed type void *off_100EEE64;
// 100EEE6C: using guessed type void *off_100EEE6C;

//----- (10040C60) --------------------------------------------------------
int __cdecl sub_10040C60(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 8);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 16);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 32);
        break;
      default:
        sub_10018A40("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1627, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10040D00) --------------------------------------------------------
int __cdecl sub_10040D00(unsigned __int8 a1, char a2)
{
  return sub_10040C60((int)&off_100EEE9C, a1, a2);
}
// 100EEE9C: using guessed type void *off_100EEE9C;

//----- (10040D20) --------------------------------------------------------
int __cdecl sub_10040D20(unsigned __int8 a1, char a2)
{
  return sub_10040C60((int)&off_100EEE74, a1, a2);
}
// 100EEE74: using guessed type void *off_100EEE74;

//----- (10040D40) --------------------------------------------------------
void *__cdecl sub_10040D40(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100EEF48;
        break;
      case 0:
        result = &unk_100EEF4C;
        break;
      case 1:
        result = &unk_100EEF50;
        break;
      case 2:
        result = &unk_100EEFD8;
        break;
      case 3:
        result = &unk_100EF04C;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10040DA0) --------------------------------------------------------
int __cdecl sub_10040DA0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 >= 7 || a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100EF12C + a1);
        break;
      case 0:
        result = (int)*(&off_100EF134 + a1);
        break;
      case 1:
        result = (int)*(&off_100EF13C + a1);
        break;
      case 2:
        result = (int)*(&off_100EF144 + a1);
        break;
      case 3:
        result = (int)*(&off_100EF14C + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100EF12C: using guessed type void *off_100EF12C;
// 100EF134: using guessed type void *off_100EF134;
// 100EF13C: using guessed type void *off_100EF13C;
// 100EF144: using guessed type void *off_100EF144;
// 100EF14C: using guessed type void *off_100EF14C;

//----- (10040E20) --------------------------------------------------------
void *__cdecl sub_10040E20(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100EF158;
      break;
    case 0:
      result = &unk_100EF15C;
      break;
    case 1:
      result = &unk_100EF360;
      break;
    case 2:
      result = &unk_100EF164;
      break;
    case 3:
      result = &unk_100EF168;
      break;
    case 5:
      result = &unk_100EF16C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10040E80) --------------------------------------------------------
void *__cdecl sub_10040E80(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100EF170;
      break;
    case 0:
      result = &unk_100EF19C;
      break;
    case 1:
      result = &unk_100EF1C0;
      break;
    case 2:
      result = &unk_100EF1F0;
      break;
    case 3:
      result = &unk_100EF268;
      break;
    case 5:
      result = &unk_100EF16C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10040EE0) --------------------------------------------------------
void *__cdecl sub_10040EE0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100EF158;
      break;
    case 0:
      result = &unk_100EF36C;
      break;
    case 1:
      result = &unk_100EF160;
      break;
    case 2:
      result = &unk_100EF380;
      break;
    case 3:
      result = &unk_100EF168;
      break;
    case 5:
      result = &unk_100EF16C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10040F40) --------------------------------------------------------
int __cdecl sub_10040F40(char a1, char a2)
{
  int result; // eax@1
  char v3; // cl@2

  result = 0;
  switch ( a1 )
  {
    case 3:
      v3 = 0;
      break;
    case 4:
      v3 = 1;
      break;
    case 5:
      v3 = 2;
      break;
    default:
      if ( a1 != 6 )
        return 0;
      v3 = 3;
      break;
  }
  switch ( a2 )
  {
    case 6:
      result = (int)*(&off_100EF390 + (unsigned __int8)v3);
      break;
    case 0:
      result = (int)*(&off_100EF3A0 + (unsigned __int8)v3);
      break;
    case 1:
      result = (int)*(&off_100EF3B0 + (unsigned __int8)v3);
      break;
    case 2:
      result = (int)*(&off_100EF3C0 + (unsigned __int8)v3);
      break;
    case 3:
      result = (int)*(&off_100EF3D0 + (unsigned __int8)v3);
      break;
    case 5:
      result = (int)*(&off_100EF3E0 + (unsigned __int8)v3);
      break;
    default:
      return result;
  }
  return result;
}
// 100EF390: using guessed type void *off_100EF390;
// 100EF3A0: using guessed type void *off_100EF3A0;
// 100EF3B0: using guessed type void *off_100EF3B0;
// 100EF3C0: using guessed type void *off_100EF3C0;
// 100EF3D0: using guessed type void *off_100EF3D0;
// 100EF3E0: using guessed type void *off_100EF3E0;

//----- (10040FE0) --------------------------------------------------------
void *__cdecl sub_10040FE0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100EF3F0;
        break;
      case 0:
        result = &unk_100EF3F4;
        break;
      case 1:
        result = &unk_100EF428;
        break;
      case 2:
        result = &unk_100EF458;
        break;
      case 3:
        result = &unk_100EF498;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10041040) --------------------------------------------------------
void *__cdecl sub_10041040(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100EF4C0;
        break;
      case 0:
        result = &unk_100EF4C4;
        break;
      case 1:
        result = &unk_100EF4E0;
        break;
      case 2:
        result = &unk_100EF524;
        break;
      case 3:
        result = &unk_100EF538;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (100410A0) --------------------------------------------------------
signed int __usercall sub_100410A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100F0160[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100EF560[2 * (unsigned __int8)v68] ^ dword_100EF960[2 * BYTE1(v65)] ^ dword_100EFD60[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100F0160[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100F0160[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100F0160[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100F0160[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100F0160[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100F0160[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100F0160[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100F0160[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100F0160[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100F0560[(unsigned __int8)v57] ^ dword_100F1160[v58 >> 24] ^ dword_100F0960[BYTE1(v59)] ^ dword_100F0D60[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100F0560[(unsigned __int8)v59] ^ dword_100F0D60[(unsigned __int8)(v58 >> 16)] ^ dword_100F1160[v57 >> 24] ^ dword_100F0960[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100F0560[(unsigned __int8)v60] ^ dword_100F0960[BYTE1(v58)] ^ dword_100F0D60[(unsigned __int8)(v57 >> 16)] ^ dword_100F1160[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100F0560[(unsigned __int8)v58] ^ dword_100F0960[BYTE1(v57)] ^ dword_100F0D60[(unsigned __int8)(v59 >> 16)] ^ dword_100F1160[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F0160[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100F0160[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F0160[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F0160[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F0160[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100EF560[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100EF960[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100EFD60[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F0160[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100F0560: using guessed type int dword_100F0560[];
// 100F0960: using guessed type int dword_100F0960[];
// 100F0D60: using guessed type int dword_100F0D60[];
// 100F1160: using guessed type int dword_100F1160[];

//----- (10042150) --------------------------------------------------------
int __usercall sub_10042150@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_100410A0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (100421B0) --------------------------------------------------------
signed int __usercall sub_100421B0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100F1160[(unsigned __int8)v9] ^ dword_100F0560[BYTE1(v9)] ^ dword_100F0960[(unsigned __int8)(v9 >> 16)] ^ dword_100F0D60[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100F1160[(unsigned __int8)v129] ^ dword_100F0560[BYTE1(v129)] ^ dword_100F0960[(unsigned __int8)(v129 >> 16)] ^ dword_100F0D60[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100F1160[(unsigned __int8)v133] ^ dword_100F0560[BYTE1(v133)] ^ dword_100F0960[(unsigned __int8)(v133 >> 16)] ^ dword_100F0D60[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100F1160[(unsigned __int8)v137] ^ dword_100F0560[BYTE1(v137)] ^ dword_100F0960[(unsigned __int8)(v137 >> 16)] ^ dword_100F0D60[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100F1160[(unsigned __int8)v141] ^ dword_100F0560[BYTE1(v141)] ^ dword_100F0960[(unsigned __int8)(v141 >> 16)] ^ dword_100F0D60[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100F1160[(unsigned __int8)v145] ^ dword_100F0560[BYTE1(v145)] ^ dword_100F0960[(unsigned __int8)(v145 >> 16)] ^ dword_100F0D60[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100F1160[(unsigned __int8)v149] ^ dword_100F0560[BYTE1(v149)] ^ dword_100F0960[(unsigned __int8)(v149 >> 16)] ^ dword_100F0D60[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100F1160[(unsigned __int8)v153] ^ dword_100F0560[BYTE1(v153)] ^ dword_100F0960[(unsigned __int8)(v153 >> 16)] ^ dword_100F0D60[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100F1160[(unsigned __int8)v157] ^ dword_100F0560[BYTE1(v157)] ^ dword_100F0960[(unsigned __int8)(v157 >> 16)] ^ dword_100F0D60[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100F1160[(unsigned __int8)v161] ^ dword_100F0560[BYTE1(v161)] ^ dword_100F0960[(unsigned __int8)(v161 >> 16)] ^ dword_100F0D60[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100F1160[(unsigned __int8)v77] ^ dword_100F0560[BYTE1(v77)] ^ dword_100F0960[(unsigned __int8)(v77 >> 16)] ^ dword_100F0D60[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100F1160[(unsigned __int8)v82] ^ dword_100F0560[BYTE1(v82)] ^ dword_100F0960[(unsigned __int8)(v82 >> 16)] ^ dword_100F0D60[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100F1160[(unsigned __int8)v89] ^ dword_100F0560[BYTE1(v89)] ^ dword_100F0960[(unsigned __int8)(v89 >> 16)] ^ dword_100F0D60[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100F1160[(unsigned __int8)v94] ^ dword_100F0560[BYTE1(v94)] ^ dword_100F0960[(unsigned __int8)(v94 >> 16)] ^ dword_100F0D60[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100F1160[(unsigned __int8)v100] ^ dword_100F0560[BYTE1(v100)] ^ dword_100F0960[(unsigned __int8)(v100 >> 16)] ^ dword_100F0D60[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100F1160[(unsigned __int8)v100] ^ dword_100F0560[BYTE1(v100)] ^ dword_100F0960[(unsigned __int8)(v100 >> 16)] ^ dword_100F0D60[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100F1160[(unsigned __int8)v108] ^ dword_100F0560[BYTE1(v108)] ^ dword_100F0960[(unsigned __int8)(v108 >> 16)] ^ dword_100F0D60[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100F1160[(unsigned __int8)v114] ^ dword_100F0560[BYTE1(v114)] ^ dword_100F0960[(unsigned __int8)(v114 >> 16)] ^ dword_100F0D60[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100F1160[(unsigned __int8)v120] ^ dword_100F0560[BYTE1(v120)] ^ dword_100F0960[(unsigned __int8)(v120 >> 16)] ^ dword_100F0D60[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100F1160[(unsigned __int8)v19] ^ dword_100F0560[BYTE1(v19)] ^ dword_100F0960[(unsigned __int8)(v19 >> 16)] ^ dword_100F0D60[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100F0560[(unsigned __int8)v23] ^ dword_100F0960[BYTE1(v23)] ^ dword_100F0D60[(unsigned __int8)(v23 >> 16)] ^ dword_100F1160[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100F1160[(unsigned __int8)v26] ^ dword_100F0560[BYTE1(v26)] ^ dword_100F0960[(unsigned __int8)(v26 >> 16)] ^ dword_100F0D60[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100F0560[(unsigned __int8)v31] ^ dword_100F0960[BYTE1(v31)] ^ dword_100F0D60[(unsigned __int8)(v31 >> 16)] ^ dword_100F1160[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100F1160[(unsigned __int8)v35] ^ dword_100F0560[BYTE1(v35)] ^ dword_100F0960[(unsigned __int8)(v35 >> 16)] ^ dword_100F0D60[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100F0560[(unsigned __int8)v41] ^ dword_100F0960[BYTE1(v41)] ^ dword_100F0D60[(unsigned __int8)(v41 >> 16)] ^ dword_100F1160[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100F1160[(unsigned __int8)v43] ^ dword_100F0560[BYTE1(v43)] ^ dword_100F0960[(unsigned __int8)(v43 >> 16)] ^ dword_100F0D60[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100F0560[(unsigned __int8)v47] ^ dword_100F0960[BYTE1(v47)] ^ dword_100F0D60[(unsigned __int8)(v47 >> 16)] ^ dword_100F1160[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100F1160[(unsigned __int8)v52] ^ dword_100F0560[BYTE1(v52)] ^ dword_100F0960[(unsigned __int8)(v52 >> 16)] ^ dword_100F0D60[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100F0560[(unsigned __int8)v58] ^ dword_100F0960[BYTE1(v58)] ^ dword_100F0D60[(unsigned __int8)(v58 >> 16)] ^ dword_100F1160[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100F1160[(unsigned __int8)v60] ^ dword_100F0560[BYTE1(v60)] ^ dword_100F0960[(unsigned __int8)(v60 >> 16)] ^ dword_100F0D60[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100F0560[(unsigned __int8)v66] ^ dword_100F0960[BYTE1(v66)] ^ dword_100F0D60[(unsigned __int8)(v66 >> 16)] ^ dword_100F1160[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100F1160[(unsigned __int8)v69] ^ dword_100F0560[BYTE1(v69)] ^ dword_100F0960[(unsigned __int8)(v69 >> 16)] ^ dword_100F0D60[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100F0560: using guessed type int dword_100F0560[];
// 100F0960: using guessed type int dword_100F0960[];
// 100F0D60: using guessed type int dword_100F0D60[];
// 100F1160: using guessed type int dword_100F1160[];

//----- (10042F30) --------------------------------------------------------
void *__usercall sub_10042F30@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10042F50) --------------------------------------------------------
unsigned int __cdecl sub_10042F50(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_100181D0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10018220: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10042FB0) --------------------------------------------------------
int __usercall sub_10042FB0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10042FF0) --------------------------------------------------------
int __usercall sub_10042FF0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10044710) --------------------------------------------------------
unsigned int __usercall sub_10044710@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100F1588[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100F1598[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10042FF0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10042FF0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100F1588: using guessed type int dword_100F1588[];
// 100F1598: using guessed type int dword_100F1598[];

//----- (10044810) --------------------------------------------------------
void *__usercall sub_10044810@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10042FF0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10044890) --------------------------------------------------------
void *__usercall sub_10044890@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10044710(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10042FB0(v3 + 64);
    result = sub_10044810(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10044810(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10044930) --------------------------------------------------------
int __usercall sub_10044930@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10044890(a1, 0, 0);
  sub_10044710(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10042FB0(a1 + 64);
  sub_10044810(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10044810(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10044710(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (100449F0) --------------------------------------------------------
int __usercall sub_100449F0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10042FB0(a2 + 64);
    sub_10044810(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10044810(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10044A50) --------------------------------------------------------
int __usercall sub_10044A50@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10042FF0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10044A50: using guessed type char var_40[64];

//----- (10044B10) --------------------------------------------------------
int __usercall sub_10044B10@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10044A50((char *)a1);
  return sub_10044A50(v8);
}

//----- (10044BD0) --------------------------------------------------------
char __cdecl sub_10044BD0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10044890(a3 + 296, a2, a1);
    sub_10042150(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10044C20) --------------------------------------------------------
char __cdecl sub_10044C20(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10042150(a3, (int)a1, a2);
    sub_10044890(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10044C70) --------------------------------------------------------
bool __cdecl sub_10044C70(int a1, int a2)
{
  if ( a2 )
    sub_10044930(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10044CA0) --------------------------------------------------------
int __usercall sub_10044CA0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10042F30(&v24);
  sub_100449F0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10044890((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10044890((int)&v23, v12, (char *)&v31);
          sub_10044930((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10044CA0: using guessed type char var_14[16];

//----- (10044EB0) --------------------------------------------------------
int __usercall sub_10044EB0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10044B10(v2);
  v3 = 20;
  do
  {
    sub_10044A50((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10044B10(v2);
}

//----- (10044F00) --------------------------------------------------------
char *__cdecl sub_10044F00(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10044B10(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10044F90) --------------------------------------------------------
signed int __cdecl sub_10044F90(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10044CA0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_100421B0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10042F30((void *)(a6 + 296));
      sub_100449F0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10044F90: using guessed type char var_40[8];
// 10044F90: using guessed type __int16 var_38[26];

//----- (100450C0) --------------------------------------------------------
bool __cdecl sub_100450C0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10044EB0(&v4, (int)sub_10042F50);
  if ( v2 )
    sub_10044F00(a2, (int)&v4);
  return v2;
}

//----- (10045140) --------------------------------------------------------
BOOL __usercall sub_10045140@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100F1DA0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100F1CA0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100F1BA0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (100451E0) --------------------------------------------------------
int __usercall sub_100451E0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10045270) --------------------------------------------------------
unsigned int __fastcall sub_10045270(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10045290) --------------------------------------------------------
int __usercall sub_10045290@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10045320) --------------------------------------------------------
int __usercall sub_10045320@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100F1DA0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100F1DA0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100F15A8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100F1EA0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100F1CA0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100F1BA0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100F1630[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100F1F18[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100F15A8: using guessed type int dword_100F15A8[];
// 100F1630: using guessed type int dword_100F1630[];
// 100F1EA0: using guessed type int dword_100F1EA0[];
// 100F1F18: using guessed type int dword_100F1F18[];

//----- (100457A0) --------------------------------------------------------
int __usercall sub_100457A0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10045290(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10045850) --------------------------------------------------------
void *__usercall sub_10045850@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (100458B0) --------------------------------------------------------
int __usercall sub_100458B0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10045A80) --------------------------------------------------------
signed int __usercall sub_10045A80@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10045270(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10045B00) --------------------------------------------------------
_WORD *__fastcall sub_10045B00(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10045B70) --------------------------------------------------------
signed int __usercall sub_10045B70@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_100F1F92[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_100F1F90[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_100F1F94[v3];
  v4 = (unsigned __int16)word_100F1F96[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 100F1F90: using guessed type __int16 word_100F1F90[];
// 100F1F92: using guessed type __int16 word_100F1F92[];
// 100F1F94: using guessed type __int16 word_100F1F94[];
// 100F1F96: using guessed type __int16 word_100F1F96[];

//----- (10045C30) --------------------------------------------------------
unsigned int __usercall sub_10045C30@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10045DE0) --------------------------------------------------------
unsigned int __usercall sub_10045DE0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10045EB0) --------------------------------------------------------
int __usercall sub_10045EB0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10045F60) --------------------------------------------------------
int __usercall sub_10045F60@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10045FA0) --------------------------------------------------------
unsigned int __usercall sub_10045FA0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10048010(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046000) --------------------------------------------------------
signed int __usercall sub_10046000@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (100460E0) --------------------------------------------------------
int __usercall sub_100460E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10046680) --------------------------------------------------------
_WORD *__fastcall sub_10046680(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_100F2144;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_100F2158;
  *(_DWORD *)(a2 + 5660) = &unk_100F216C;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_10045B00(a2 + 5228, a2);
}
// 100F2144: using guessed type void *off_100F2144;
// 100F2158: using guessed type void *off_100F2158;

//----- (100466E0) --------------------------------------------------------
signed int __cdecl sub_100466E0(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_10048010(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_10046680(v3, v1);
    sub_10045B70(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10046770) --------------------------------------------------------
int __usercall sub_10046770@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_100451E0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_100451E0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_100451E0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (100469B0) --------------------------------------------------------
int __usercall sub_100469B0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_100457A0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_100457A0(a1, a3, a4);
  }
  return result;
}

//----- (10046A50) --------------------------------------------------------
signed int __usercall sub_10046A50@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10045EB0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10045EB0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10045EB0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_100458B0(a1, a2);
  return sub_10045A80(a1, v16, v5);
}

//----- (10046C30) --------------------------------------------------------
unsigned int __usercall sub_10046C30@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10045FA0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10046D70) --------------------------------------------------------
int __usercall sub_10046D70@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100F161C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_100460E0(a1, a1 + 2936, a2 - 1);
  return sub_100460E0(v24, v24 + 5228, a3 - 1);
}

//----- (10047020) --------------------------------------------------------
signed int __cdecl sub_10047020(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10045F60(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10045F60(v9, *(_WORD *)(a1 + 30));
      sub_10045F60(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10048010(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10045850(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100F1F98 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10046770(v2);
    }
    else
    {
      sub_100469B0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10045850(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10045F60(v2, *(_WORD *)(a1 + 30));
    sub_10045F60(v13, *(_WORD *)(a1 + 28));
    sub_10045850(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100F1F98: using guessed type int (__cdecl *off_100F1F98)(int, int);

//----- (100472E0) --------------------------------------------------------
signed int __cdecl sub_100472E0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_100466E0(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10047490) --------------------------------------------------------
signed int __usercall sub_10047490@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10046000(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10046000(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10046A50(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F161C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F161B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F161A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F1619[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10047560) --------------------------------------------------------
_WORD *__usercall sub_10047560@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10046A50(a2, a2 + 5628);
  sub_10046A50(v4, v4 + 5640);
  v8 = sub_10047490(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_100469B0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10045320(v4, (int)&unk_100F16A8, (int)&unk_100F1B28);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10046D70(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10045320(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10045B00(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10045290(v4);
  return result;
}

//----- (10047780) --------------------------------------------------------
signed int __cdecl sub_10047780(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10046C30(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10045C30(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10045DE0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10045140(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10045140(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10047560(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10045850(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10047560(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10045850(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10047A90) --------------------------------------------------------
signed int __cdecl sub_10047A90(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10046C30(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10045C30(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10045DE0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10045140(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10047560(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10045850(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10045140(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10047560(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10045850(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10045140(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10047560(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10045850(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10047EA0) --------------------------------------------------------
signed int __cdecl sub_10047EA0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10046C30(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10047560(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10045850(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10047560(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10045850(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10047560(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10045850(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10048010) --------------------------------------------------------
int __cdecl sub_10048010(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10048110) --------------------------------------------------------
signed int __cdecl sub_10048110(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10048130) --------------------------------------------------------
signed int __usercall sub_10048130@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10048130: using guessed type int var_78[14];
// 10048130: using guessed type int var_3C[15];

//----- (100485D0) --------------------------------------------------------
int (__cdecl *__usercall sub_100485D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10048620) --------------------------------------------------------
int __usercall sub_10048620@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10048640) --------------------------------------------------------
signed int __cdecl sub_10048640(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100F2180[a1];
  v51 = dword_100F2180[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100F2180[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100F2180[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100F2180[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100F2180[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100F2180: using guessed type int dword_100F2180[];

//----- (100489F0) --------------------------------------------------------
int __usercall sub_100489F0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10048B30) --------------------------------------------------------
signed int __usercall sub_10048B30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10048130(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10048B80) --------------------------------------------------------
signed int __usercall sub_10048B80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10048130(a7, a6, a4, 257, (int)&unk_100F2218, (int)&unk_100F2298, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10048130(a8, &a6[a4], a5, 0, (int)&unk_100F2318, (int)&unk_100F2390, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10048C20) --------------------------------------------------------
int __usercall sub_10048C20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100F2408;
  *a4 = &unk_100F3408;
  return 0;
}

//----- (10048C40) --------------------------------------------------------
signed int __cdecl sub_10048C40(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 0;
  if ( a2 < 0 )
  {
    v5 = 1;
    v4 = -a2;
  }
  if ( (1 << v4) + 14152 <= a4 && !(a3 & 3) )
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v4;
    *(_DWORD *)(a3 + 12) = v5;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v4) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_10048010;
    sub_100485D0(0, *(_DWORD *)(a3 + 20), a1);
    JUMPOUT(&loc_10048AF0);
  }
  return -4;
}

//----- (10048D30) --------------------------------------------------------
signed int __cdecl sub_10048D30(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_100485D0(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10048D40) --------------------------------------------------------
int __usercall sub_10048D40@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10048640(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100F2180[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100F2180[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100F2180[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100F2180[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_100489F0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_100489F0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_100489F0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_100489F0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100F2180: using guessed type int dword_100F2180[];

//----- (100493E0) --------------------------------------------------------
int __usercall sub_100493E0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10048C20(&v67, &v69, &v66, &v68);
          sub_10048620(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_100489F0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100F21C8[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100F21C8[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10048B30(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10048B80(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10048620(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10048D40(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_100489F0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_100489F0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_100489F0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100F2180[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100F2180[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_100489F0(v7, v3, v58);
}
// 100F2180: using guessed type int dword_100F2180[];
// 100F21C8: using guessed type int dword_100F21C8[];

//----- (10049DC0) --------------------------------------------------------
signed int __usercall sub_10049DC0@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_100493E0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_100485D0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1004A0F0) --------------------------------------------------------
signed int __cdecl sub_1004A0F0(int a1, int a2)
{
  return sub_10049DC0(a1, a2);
}

//----- (1004A110) --------------------------------------------------------
char __cdecl sub_1004A110(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_102124B8[592 * a1]) || byte_10212508[v3]) )
  {
    *a2 = &byte_102124B8[v3];
    *a3 = &byte_10212508[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004A150) --------------------------------------------------------
char *__cdecl sub_1004A150(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_102124B8;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10212508[592 * v2];
}

//----- (1004A1C0) --------------------------------------------------------
char *__usercall sub_1004A1C0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1004A1F0) --------------------------------------------------------
void __cdecl sub_1004A1F0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1004A150(v2 + 3, (int)&byte_10065A71);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1004A1F0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1004A2B0) --------------------------------------------------------
void __cdecl sub_1004A2B0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_102124B0 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_102124B0;
    v4 = (char *)(&byte_102124B8[592 * dword_102124B0] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10212508[v3];
    v8 = (char *)(&byte_10212508[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1004A1F0(v7);
    ++dword_102124B0;
  }
}
// 102124B0: using guessed type int dword_102124B0;

//----- (1004A310) --------------------------------------------------------
void *__cdecl sub_1004A310(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_102124B8, 0, 0x73A0u);
  dword_102124B0 = 0;
  if ( a1 )
  {
    v2 = sub_1004B460(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1004B640((int)&v11, 512, v2) )
      {
        do
        {
          sub_1004A1C0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1004A2B0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1004A2B0(&v11, v4 + 1);
          }
        }
        while ( sub_1004B640((int)&v11, 512, v3) );
      }
      result = (void *)sub_1004B410(v3);
    }
    else
    {
      result = (void *)sub_1002F230(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 102124B0: using guessed type int dword_102124B0;

//----- (1004A4A0) --------------------------------------------------------
int sub_1004A4A0()
{
  return 0;
}

//----- (1004A4B0) --------------------------------------------------------
void __cdecl sub_1004A4B0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (1004A4E0) --------------------------------------------------------
int __cdecl sub_1004A4E0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1004A500) --------------------------------------------------------
bool __cdecl sub_1004A500(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1004A530) --------------------------------------------------------
void *__cdecl sub_1004A530(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1004A570) --------------------------------------------------------
unsigned int __usercall sub_1004A570@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1004A590) --------------------------------------------------------
int __usercall sub_1004A590@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1004A5B0) --------------------------------------------------------
char __cdecl sub_1004A5B0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1004A500(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1004A4E0(a2);
  }
  return result;
}

//----- (1004A5E0) --------------------------------------------------------
signed int __cdecl sub_1004A5E0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1004A570(v5, v7, v9);
          v11 = (_BYTE *)sub_1004A570(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1004A570(a4, v7, v9);
            sub_1004A590(v16, (int)&unk_100F3618);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1004A6C0) --------------------------------------------------------
void __cdecl sub_1004A6C0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1004A570((int)v3, v4, v6);
          v8 = sub_1004A570(a2, v4, v6);
          v9 = sub_1004A570(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1004A770) --------------------------------------------------------
void *__usercall sub_1004A770@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1004A570(a1, v31, v4);
      v6 = sub_1004A570(a2, 0, 0);
      sub_1004A590(v5, v6);
      v7 = sub_1004A570(a1, v33, v4);
      v8 = sub_1004A570(a2, *(_DWORD *)a2 - 1, 0);
      sub_1004A590(v7, v8);
      v9 = sub_1004A570(a1, v31, v34 - v4 - 1);
      v10 = sub_1004A570(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1004A590(v9, v10);
      v11 = sub_1004A570(a1, v33, v34 - v4 - 1);
      v12 = sub_1004A570(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1004A590(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1004A570(a2, 0, 1);
    v16 = (void *)sub_1004A570(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1004A570(a1, a3 + i, v18);
      v20 = sub_1004A570(a2, i, 0);
      sub_1004A590(v19, v20);
      v21 = sub_1004A570(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1004A570(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1004A590(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1004A570(a2, i, 1);
    v25 = (void *)sub_1004A570(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1004A570(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1004A570(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (1004A9F0) --------------------------------------------------------
void __cdecl sub_1004A9F0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1004A570(a1, v2, v4);
          v6 = sub_1004A570(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (1004AAC0) --------------------------------------------------------
char __cdecl sub_1004AAC0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1004A500(a1);
  if ( result )
  {
    result = sub_1004A500(a4);
    if ( result )
    {
      sub_1004A5B0(a3, a4);
      sub_1004A530(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (1004AB30) --------------------------------------------------------
int __usercall sub_1004AB30@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1004A530(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1004A770((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1004A570((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1004A570(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1004A5B0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_1004AAC0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (1004AE90) --------------------------------------------------------
int __usercall sub_1004AE90@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1004A530(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1004A6C0(v8, a3, (int)&v16);
  sub_1004A530(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_1004AB30(9u, v7, (int)&v16, (int)&unk_100F35F4, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1004A570((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1004A570(a6, v9, v11);
            sub_1004A590(v13, (int)&unk_100F3618);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1004A5B0(a5, (int)&v15);
  sub_1004A5B0(a5, (int)&v16);
  return v10;
}

//----- (1004AFA0) --------------------------------------------------------
int __cdecl sub_1004AFA0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1004A530(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_1004A9F0(a3, a8);
  if ( a1 )
    result = sub_1004AE90(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1004A5E0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (1004B130) --------------------------------------------------------
char __cdecl sub_1004B130(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1004B460((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1004B4C0(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1004B4C0(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1004A530(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1004B4C0(v6, v7, v12) == v7 && (!v9 || sub_1004B4C0(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1004B410(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004B280) --------------------------------------------------------
char __usercall sub_1004B280@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1004B460(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1004B4E0((int)&v14, 14, v9) == 14 && sub_1004B4E0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1004B4E0(v12, v6, v10) == v6 && (!v7 || sub_1004B4E0((int)&unk_100F37C0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1004B410(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1004B410(v10);
  }
  return v30;
}

//----- (1004B3D0) --------------------------------------------------------
char __cdecl sub_1004B3D0(int a1, int a2)
{
  char result; // al@2

  if ( sub_1004A500(a1) )
    result = sub_1004B280(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (1004B410) --------------------------------------------------------
BOOL __cdecl sub_1004B410(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10019290(a1) == 0;
}
// 10019280: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1004B430) --------------------------------------------------------
BOOL __cdecl sub_1004B430(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100192D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1004B460) --------------------------------------------------------
unsigned int __cdecl sub_1004B460(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10019350: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1004B4C0) --------------------------------------------------------
signed int __cdecl sub_1004B4C0(void *a1, int a2, unsigned int a3)
{
  return sub_10019360(a3, a1, a2);
}

//----- (1004B4E0) --------------------------------------------------------
int __cdecl sub_1004B4E0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 100194D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004B500) --------------------------------------------------------
char __cdecl sub_1004B500(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1004B460((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1004B460((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1004B4C0(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1004B4E0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1004B4C0(&v8, 512, v3);
        }
        v2 = i;
        sub_1004B410(v4);
      }
      sub_1004B410(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1004B640) --------------------------------------------------------
int __cdecl sub_1004B640(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1004B4C0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1004B6C0) --------------------------------------------------------
char __cdecl sub_1004B6C0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_10222C4C)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1004B710) --------------------------------------------------------
char __cdecl sub_1004B710(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_10222C4C)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1004B7C0) --------------------------------------------------------
char __cdecl sub_1004B7C0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_10222C4C)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1004B820) --------------------------------------------------------
char __cdecl sub_1004B820(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_10222C4C)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 10222C4C: using guessed type int dword_10222C4C;

//----- (1004B8F0) --------------------------------------------------------
char __cdecl sub_1004B8F0(char a1, char a2, char *a3, char *a4)
{
  char *v4; // ebp@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // bl@1
  int v8; // eax@1
  int v9; // esi@5
  char v10; // al@11
  unsigned __int8 v11; // al@26
  bool v12; // cf@26
  bool v13; // zf@26
  char v15[4]; // [sp+10h] [bp-58h]@9
  char v16[24]; // [sp+14h] [bp-54h]@22
  char v17[56]; // [sp+2Ch] [bp-3Ch]@33

  v4 = a4;
  v5 = 904;
  v6 = 1000;
  v7 = 0;
  v8 = sub_1001E7B0(&a1, 1u, (int)&unk_100F8010, 4, 8, 8);
  if ( v8 < 8 )
    v5 = (unsigned __int16)word_100F8012[2 * v8];
  switch ( a1 )
  {
    case 3:
    case 4:
    case 5:
      if ( a2 )
        v9 = (unsigned __int8)*a3 + 2;
      else
        v9 = (unsigned __int8)*a3;
      if ( (unsigned __int16)v5 < 0x388u && v9 < 4 && sub_1000F100(2, v5, v15) == 1 && !sub_10037A70((int)v15) )
      {
        v10 = v15[v9];
        goto LABEL_36;
      }
      return v7;
    case 6:
    case 7:
      if ( a2 )
      {
        if ( a2 == 1 )
        {
          v6 = (unsigned __int8)*a3 + 8;
        }
        else if ( a2 == 2 )
        {
          if ( (unsigned __int8)*a3 < 8u )
            v6 = (unsigned __int8)*a3 + 13;
        }
        else
        {
          v6 = (unsigned __int8)*a3 + 21;
        }
      }
      else
      {
        v6 = (unsigned __int8)*a3;
      }
      if ( (unsigned __int16)v5 < 0x388u && v6 < 23 && sub_1000F100(2, v5, v16) == 1 && !sub_10037B20((int)v16) )
      {
        *v4 = v16[v6];
        goto LABEL_37;
      }
      return v7;
    case 0x19:
    case 0x1A:
    case 0x2B:
      if ( a2 == 2 )
      {
        v11 = *a3;
        if ( (unsigned __int8)*a3 < 0x10u )
          goto LABEL_31;
        v12 = v11 < 0x28u;
        v13 = v11 == 40;
      }
      else
      {
        v11 = *a3;
        v12 = (unsigned __int8)*a3 < 0x10u;
        v13 = *a3 == 16;
      }
      if ( v12 || v13 )
        v6 = v11;
LABEL_31:
      if ( (unsigned __int16)v5 < 0x388u && v6 < 56 && sub_1000F100(2, v5, v17) == 1 && !sub_10038330((int)v17) )
      {
        v10 = v17[v6];
LABEL_36:
        *v4 = v10;
LABEL_37:
        v7 = 1;
      }
      return v7;
    default:
      return v7;
  }
}
// 100F8012: using guessed type __int16 word_100F8012[];
// 1004B8F0: using guessed type char var_58[4];
// 1004B8F0: using guessed type char var_54[24];
// 1004B8F0: using guessed type char var_3C[56];

//----- (1004BB00) --------------------------------------------------------
bool __cdecl sub_1004BB00(void *a1)
{
  char v1; // cl@1

  v1 = sub_1000F100(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10038D90((int)a1);
}

//----- (1004BB40) --------------------------------------------------------
int __cdecl sub_1004BB40(char a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 == 1 )
  {
    sub_10018640(10026, (int)&v2, 4);
    result = v2;
  }
  else
  {
    sub_10018640(10027, (int)&v2, 4);
    result = v2;
  }
  return result;
}

//----- (1004BB90) --------------------------------------------------------
int __cdecl sub_1004BB90(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1004BBA0) --------------------------------------------------------
int __cdecl sub_1004BBA0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1005F770: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1005F780: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1005F790: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1005F7A0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1005F850: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1004BCE0) --------------------------------------------------------
char __usercall sub_1004BCE0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1004BDB0) --------------------------------------------------------
signed int __cdecl sub_1004BDB0(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1005F7B0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1004BCE0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1004BBA0(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1005F860: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1004BE90) --------------------------------------------------------
int __cdecl sub_1004BE90(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1004BEB0) --------------------------------------------------------
int (__cdecl *__usercall sub_1004BEB0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1004BEC0) --------------------------------------------------------
int __usercall sub_1004BEC0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1004C0F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C0F0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1004BEB0(a1, (int)" ");
  sub_1004BEB0(a1, a2);
  sub_1004BEB0(a1, (int)&unk_100FBEF4);
  v3 = sub_1004BEC0(a3, a1);
  sub_1004BEB0(a1, v3);
  return sub_1004BEB0(a1, (int)&unk_100FBEF0);
}

//----- (1004C140) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C140(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1004BEB0(a1, (int)" ");
  sub_1004BEB0(a1, a2);
  sub_1004BEB0(a1, (int)&unk_100FBEFC);
  v3 = sub_1004BEC0(a3, a1);
  sub_1004BEB0(a1, v3);
  return sub_1004BEB0(a1, (int)&unk_100FBEF8);
}

//----- (1004C190) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C190(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1004BEB0(a1, (int)&unk_100FBF00);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1004BEC0(a2, a1);
    result = sub_1004BEB0(a1, v3);
  }
  return result;
}

//----- (1004C1E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C1E0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100FBF08;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1004BEB0(a1, dword_100FBE5C[(signed int)result]);
      sub_1004BEB0(a1, (int)&unk_100FBF04);
      sub_1004BEB0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100FBF00;
    }
    result = sub_1004BEB0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1004BEB0(a1, (int)&word_100E4624);
  }
  return result;
}
// 100E4624: using guessed type __int16 word_100E4624;
// 100FBE5C: using guessed type int dword_100FBE5C[];

//----- (1004C260) --------------------------------------------------------
int __cdecl sub_1004C260(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1004BEB0(a1, (int)&unk_100FBF00);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1004BEB0(a1, (int)(&off_100FBE60)[2 * (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84))]);
  sub_1004BEB0(a1, (int)&unk_100FBF0C);
  sub_1004BEB0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 100FBE60: using guessed type __int16 *off_100FBE60;

//----- (1004C2E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C2E0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1004BEC0(a2, a1);
    sub_1004BEB0(a1, v3);
    result = sub_1004BEB0(a1, (int)&word_100E4624);
  }
  else
  {
    sub_1004BEB0(a1, (int)a2);
    result = sub_1004BEB0(a1, (int)&word_100E4624);
  }
  return result;
}
// 100E4624: using guessed type __int16 word_100E4624;

//----- (1004C330) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C330(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1004C260(a1, a2);
  if ( a3 && *a3 )
    sub_1004C190(a1, a3);
  return sub_1004C1E0(a1);
}

//----- (1004C370) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004C370(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1004C330(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1004C3D0) --------------------------------------------------------
bool __thiscall sub_1004C3D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return !sub_10018540(6569, (int)&v2 + 3, 1) && (BYTE3(v2) == 4 || BYTE3(v2) == 2 || BYTE3(v2) == 5);
}

//----- (1004C410) --------------------------------------------------------
char __cdecl sub_1004C410(char a1, void *a2)
{
  void *v3; // ecx@3
  char v4; // al@5

  if ( sub_10018540((unsigned __int8)a1 + 36000, (int)a2, 132) )
    return 0;
  v3 = a2;
  if ( !a2 || *(_BYTE *)a2 )
  {
LABEL_8:
    if ( *((_BYTE *)a2 + 21) == 4 )
    {
      if ( *((_BYTE *)a2 + 24) == 1 )
      {
        if ( !sub_1004C3D0(v3) )
        {
          sub_10018A40("..\\lib\\adl\\sys_utl_airframe_tests.c", 206, 0, 0);
          memset(a2, 0, 0x84u);
        }
      }
      else if ( *((_BYTE *)a2 + 24) == 3 && !*((_BYTE *)a2 + 58) )
      {
        *((_DWORD *)a2 + 15) |= 0x200u;
        return 1;
      }
    }
  }
  else
  {
    v4 = 0;
    while ( v4 )
    {
      v4 = *((_BYTE *)v3 + 1);
      v3 = (char *)v3 + 1;
      if ( v4 != *((_BYTE *)v3 + &byte_10065A71 - (_BYTE *)a2) )
        goto LABEL_8;
    }
  }
  return 1;
}

//----- (1004C4C0) --------------------------------------------------------
char __cdecl sub_1004C4C0(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_100185C0(6470, (int)&a1, 1);
      result = a1 && sub_1003E910(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_1001E000(14);
    }
    else
    {
      sub_10018A40("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10040190(v1);
  }
  return result;
}

//----- (1004C540) --------------------------------------------------------
int __cdecl sub_1004C540(unsigned __int8 a1, unsigned int a2)
{
  return dword_10102798[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10102798: using guessed type int dword_10102798[];

//----- (1004C560) --------------------------------------------------------
unsigned int __cdecl sub_1004C560(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10102798[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10102798[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10102798[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10102798[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10102798[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10102798[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10102798[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10102798[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10102798[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10102798[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10102798: using guessed type int dword_10102798[];

//----- (1004C690) --------------------------------------------------------
int __cdecl sub_1004C690(int a1, int a2)
{
  return a2 * (signed __int64)a1 >> 31;
}

//----- (1004C6A0) --------------------------------------------------------
int __cdecl sub_1004C6A0(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx@0
  int v3; // eax@1
  __int64 v4; // ST30_8@1
  unsigned int v5; // eax@1
  unsigned int v6; // ST28_4@1
  unsigned int v7; // ST20_4@1
  __int64 v8; // rax@1
  unsigned __int64 v9; // ST3C_8@1
  unsigned __int64 v10; // rax@1
  signed __int64 v11; // rdi@1
  unsigned __int64 v12; // ST3C_8@1
  __int64 v13; // ST20_8@1
  unsigned __int64 v14; // ST3C_8@1
  signed __int64 v15; // kr00_8@1
  signed __int64 v16; // rdi@1
  unsigned __int64 v17; // ST3C_8@1
  int result; // eax@1

  v3 = 1686629713i64 * a1 >> 29;
  v4 = v3;
  v5 = v3 * (signed __int64)v3 >> 30;
  v6 = v5;
  v7 = v5 >> 1;
  v8 = v5 >> 1;
  v9 = __PAIR__(HIDWORD(v8), v7);
  v10 = __PAIR__(HIDWORD(v8), v7) << 31;
  v11 = -715827883i64 * v9 + 0x7FFFFFFFFFFFFFFFi64;
  v12 = v7 * (unsigned __int64)v6;
  v13 = SHIDWORD(v12);
  v14 = HIDWORD(v12) * (unsigned __int64)v6;
  v15 = -5965232i64 * SHIDWORD(v14) + 178956971i64 * (signed int)v13 + 0x7FFFFFFFFFFFFFFFi64 - v10;
  v16 = -852176i64 * SHIDWORD(v14) + 35791394 * v13 + v11;
  v17 = HIDWORD(v14) * (unsigned __int64)v6;
  result = (signed int)((unsigned __int64)(-108i64 * SHIDWORD(v17) + 11836i64 * SHIDWORD(v17) + v16) >> 32) * v4 >> 31;
  *v2 = result;
  *a2 = (unsigned __int64)(-1184i64 * SHIDWORD(v17) + 106522i64 * SHIDWORD(v17) + v15) >> 32;
  return result;
}

//----- (1004C8B0) --------------------------------------------------------
int __cdecl sub_1004C8B0(int a1, int *a2, int *a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // edx@2
  int result; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  sub_1004C6A0(((a1 + 0x20000000) & 0x3FFFFFFF) - 0x20000000, &v7);
  v3 = ((a1 + 0x20000000) >> 30) & 3;
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = v7;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        *a2 = -a1;
        result = (int)a3;
        *a3 = -v5;
      }
      else
      {
        result = (int)a2;
        *a2 = -v7;
        *a3 = a1;
      }
    }
    else
    {
      *a2 = v7;
      result = -a1;
      *a3 = -a1;
    }
  }
  else
  {
    result = a1;
    *a2 = a1;
    *a3 = v7;
  }
  return result;
}

//----- (1004C950) --------------------------------------------------------
double __cdecl sub_1004C950(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1004C9F0) --------------------------------------------------------
int __cdecl sub_1004C9F0(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1004CA30) --------------------------------------------------------
double __cdecl sub_1004CA30(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1004CAD0) --------------------------------------------------------
double __cdecl sub_1004CAD0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (1004CB30) --------------------------------------------------------
double __cdecl sub_1004CB30(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (1004CBB0) --------------------------------------------------------
void __cdecl sub_1004CBB0(double a1)
{
  sub_1004CAD0(a1, 3.1415926535898);
}

//----- (1004CBD0) --------------------------------------------------------
double __cdecl sub_1004CBD0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_1004CB30(a1, 3.1415927);
  return result;
}

//----- (1004CC10) --------------------------------------------------------
int __cdecl sub_1004CC10(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (1004CC30) --------------------------------------------------------
int __cdecl sub_1004CC30(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (1004CC50) --------------------------------------------------------
int __cdecl sub_1004CC50(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (1004CC70) --------------------------------------------------------
double __cdecl sub_1004CC70(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_1004CBB0(result);
    }
  }
  return result;
}

//----- (1004CCE0) --------------------------------------------------------
double __cdecl sub_1004CCE0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_1004CBD0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (1004CD70) --------------------------------------------------------
int __cdecl sub_1004CD70(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (1004CDA0) --------------------------------------------------------
int __cdecl sub_1004CDA0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (1004F1A8) --------------------------------------------------------
int __cdecl sub_1004F1A8(int a1, int a2, char a3)
{
  return vscan_fn(sub_1005685F, a2, 0, &a3);
}
// 1004F140: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005041D) --------------------------------------------------------
int __cdecl sub_1005041D(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10059713() + 8 && (void **)v2 != sub_10059713() + 16 || !sub_100596B5((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_1010F288;
      else
        v9 = (_BYTE *)(dword_10224560[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10059595((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10059595((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 10059671: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (10050FB2) --------------------------------------------------------
int __cdecl sub_10050FB2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10219BA4 = a1;
  return result;
}
// 10219BA4: using guessed type int dword_10219BA4;

//----- (10051185) --------------------------------------------------------
signed int __cdecl sub_10051185(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10219BAC )
  {
    *a1 = dword_10219BAC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10219BAC: using guessed type int dword_10219BAC;

//----- (100511BC) --------------------------------------------------------
signed int __cdecl sub_100511BC(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10219BAC )
  {
    *a1 = dword_10219BB8;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10219BAC: using guessed type int dword_10219BAC;
// 10219BB8: using guessed type int dword_10219BB8;

//----- (10051E02) --------------------------------------------------------
void sub_10051E02()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_10224560;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_10224660 );
}
// 10224560: using guessed type int dword_10224560[];
// 10224660: using guessed type int dword_10224660;

//----- (100522AF) --------------------------------------------------------
int (*sub_100522AF())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_1010D780;
  v1 = (int (**)(void))&unk_1010D780;
  if ( &unk_1010D780 < &unk_1010D780 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_1010D780 );
  }
  return result;
}

//----- (100522D3) --------------------------------------------------------
void __cdecl sub_100522D3()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_1010D788;
  if ( &unk_1010D788 < &unk_1010D788 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_1010D788 );
  }
}

//----- (1005685F) --------------------------------------------------------
int __cdecl sub_1005685F(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_1010F288;
  }
  else
  {
    v6 = &dword_10224560[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_1010F288) : (v8 = &dword_10224560[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1005D3E1(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1005D3E1(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1005D3E1(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1005D3E1(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1005D3E1(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1010F264[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1005D3E1(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1005D3E1(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1005D3E1(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1005D3E1(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100514BB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10056824: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 1005683A: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1010F264: using guessed type int (*off_1010F264[3])();
// 10224560: using guessed type int dword_10224560[];
// 1005685F: using guessed type char var_24[11];

//----- (100578A4) --------------------------------------------------------
#error "100578A9: positive sp value has been found (funcsize=0)"

//----- (100578AF) --------------------------------------------------------
#error "100578B4: positive sp value has been found (funcsize=0)"

//----- (100578BA) --------------------------------------------------------
#error "100578BF: positive sp value has been found (funcsize=0)"

//----- (100578C0) --------------------------------------------------------
#error "100578C5: positive sp value has been found (funcsize=0)"

//----- (100578C6) --------------------------------------------------------
#error "100578CB: positive sp value has been found (funcsize=0)"

//----- (100578CC) --------------------------------------------------------
#error "100578D1: positive sp value has been found (funcsize=0)"

//----- (100578D2) --------------------------------------------------------
#error "100578ED: positive sp value has been found (funcsize=0)"

//----- (100578F3) --------------------------------------------------------
#error "10057908: positive sp value has been found (funcsize=0)"

//----- (1005790E) --------------------------------------------------------
#error "10057929: positive sp value has been found (funcsize=0)"

//----- (1005792A) --------------------------------------------------------
#error "10057939: positive sp value has been found (funcsize=0)"

//----- (1005793A) --------------------------------------------------------
#error "1005794D: positive sp value has been found (funcsize=0)"

//----- (1005794E) --------------------------------------------------------
#error "1005795D: positive sp value has been found (funcsize=0)"

//----- (1005795E) --------------------------------------------------------
#error "1005797D: positive sp value has been found (funcsize=0)"

//----- (10057983) --------------------------------------------------------
#error "1005799C: positive sp value has been found (funcsize=0)"

//----- (100579A2) --------------------------------------------------------
#error "100579C1: positive sp value has been found (funcsize=0)"

//----- (100579C2) --------------------------------------------------------
#error "100579D5: positive sp value has been found (funcsize=0)"

//----- (100579D6) --------------------------------------------------------
#error "100579ED: positive sp value has been found (funcsize=0)"

//----- (100579EE) --------------------------------------------------------
#error "10057A01: positive sp value has been found (funcsize=0)"

//----- (10057A02) --------------------------------------------------------
#error "10057A21: positive sp value has been found (funcsize=0)"

//----- (10057A27) --------------------------------------------------------
#error "10057A40: positive sp value has been found (funcsize=0)"

//----- (10057A46) --------------------------------------------------------
#error "10057A65: positive sp value has been found (funcsize=0)"

//----- (10057A66) --------------------------------------------------------
#error "10057A79: positive sp value has been found (funcsize=0)"

//----- (10057A7A) --------------------------------------------------------
#error "10057A91: positive sp value has been found (funcsize=0)"

//----- (10057A92) --------------------------------------------------------
#error "10057AA5: positive sp value has been found (funcsize=0)"

//----- (10057AA6) --------------------------------------------------------
#error "10057AC5: positive sp value has been found (funcsize=0)"

//----- (10057ACB) --------------------------------------------------------
#error "10057AE4: positive sp value has been found (funcsize=0)"

//----- (10057AEA) --------------------------------------------------------
#error "10057B09: positive sp value has been found (funcsize=0)"

//----- (10057B0A) --------------------------------------------------------
#error "10057B1D: positive sp value has been found (funcsize=0)"

//----- (10057B1E) --------------------------------------------------------
#error "10057B35: positive sp value has been found (funcsize=0)"

//----- (10057B36) --------------------------------------------------------
#error "10057B49: positive sp value has been found (funcsize=0)"

//----- (10057B4A) --------------------------------------------------------
#error "10057B69: positive sp value has been found (funcsize=0)"

//----- (10057B6F) --------------------------------------------------------
#error "10057B88: positive sp value has been found (funcsize=0)"

//----- (10057B8E) --------------------------------------------------------
#error "10057BAD: positive sp value has been found (funcsize=0)"

//----- (10057BAE) --------------------------------------------------------
#error "10057BC1: positive sp value has been found (funcsize=0)"

//----- (10057BC2) --------------------------------------------------------
#error "10057BD9: positive sp value has been found (funcsize=0)"

//----- (10057BDA) --------------------------------------------------------
#error "10057BED: positive sp value has been found (funcsize=0)"

//----- (10057BEE) --------------------------------------------------------
#error "10057C0D: positive sp value has been found (funcsize=0)"

//----- (10057C13) --------------------------------------------------------
#error "10057C2C: positive sp value has been found (funcsize=0)"

//----- (10057C32) --------------------------------------------------------
#error "10057C51: positive sp value has been found (funcsize=0)"

//----- (10057C52) --------------------------------------------------------
#error "10057C65: positive sp value has been found (funcsize=0)"

//----- (10057C66) --------------------------------------------------------
#error "10057C7D: positive sp value has been found (funcsize=0)"

//----- (10057C7E) --------------------------------------------------------
#error "10057C91: positive sp value has been found (funcsize=0)"

//----- (10057C92) --------------------------------------------------------
#error "10057CB1: positive sp value has been found (funcsize=0)"

//----- (10057CB7) --------------------------------------------------------
#error "10057CD0: positive sp value has been found (funcsize=0)"

//----- (10057CD6) --------------------------------------------------------
#error "10057CF5: positive sp value has been found (funcsize=0)"

//----- (10057CF6) --------------------------------------------------------
#error "10057D09: positive sp value has been found (funcsize=0)"

//----- (10057D0A) --------------------------------------------------------
#error "10057D21: positive sp value has been found (funcsize=0)"

//----- (10057D22) --------------------------------------------------------
#error "10057D35: positive sp value has been found (funcsize=0)"

//----- (100587FC) --------------------------------------------------------
int __cdecl sub_100587FC(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1005BA89((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10053BB1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100588A2) --------------------------------------------------------
int __cdecl sub_100588A2(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1005BFCB((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10053BB1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10058D12) --------------------------------------------------------
void sub_10058D12()
{
  dword_10224544 = 0;
}
// 10224544: using guessed type int dword_10224544;

//----- (10058DCA) --------------------------------------------------------
int sub_10058DCA()
{
  dword_10224678 = _get_sse2_info();
  return 0;
}
// 10058D6A: using guessed type int _get_sse2_info(void);
// 10224678: using guessed type int dword_10224678;

//----- (10058DD7) --------------------------------------------------------
DWORD __cdecl sub_10058DD7(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1005E3A1(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_10224560[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1004DF2E: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (10058F73) --------------------------------------------------------
_WORD *__cdecl sub_10058F73(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_10224560[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_10224560[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10058DD7(a1, 0, 0, 2u);
  if ( sub_100596B5(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1004DF2E: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100516D7: using guessed type int _getptd(void);
// 10224560: using guessed type int dword_10224560[];
// 10058F73: using guessed type CHAR var_410[688];

//----- (10059595) --------------------------------------------------------
_WORD *__cdecl sub_10059595(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_10224560[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_10058F73(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1005E4B2(a1);
  return v6;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005E412: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (100596B5) --------------------------------------------------------
int __cdecl sub_100596B5(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_10224560[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (10059713) --------------------------------------------------------
void **sub_10059713()
{
  return &off_1010FCF0;
}
// 1010FCF0: using guessed type void *off_1010FCF0;

//----- (10059719) --------------------------------------------------------
signed int sub_10059719()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_10224540;
  if ( !dword_10224540 )
  {
    v0 = 512;
LABEL_5:
    dword_10224540 = v0;
    goto LABEL_6;
  }
  if ( dword_10224540 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_10223520 = v1;
  if ( v1 || (dword_10224540 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_10223520 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_1010FCF0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_1010FF70 )
        break;
      v1 = dword_10223520;
    }
    v5 = 0;
    v6 = &unk_1010FD00;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_10224560[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_1010FD60 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10051ACB: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 1010FCF0: using guessed type void *off_1010FCF0;
// 1010FF70: using guessed type int dword_1010FF70;
// 10224540: using guessed type int dword_10224540;
// 10224560: using guessed type int dword_10224560[];

//----- (1005A002) --------------------------------------------------------
int sub_1005A002()
{
  return _decode_pointer(dword_1021A1E0);
}
// 100514BB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1021A1E0: using guessed type int dword_1021A1E0;

//----- (1005A1BF) --------------------------------------------------------
int __cdecl sub_1005A1BF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1021A1EC = a1;
  return result;
}
// 1021A1EC: using guessed type int dword_1021A1EC;

//----- (1005A1C9) --------------------------------------------------------
int __cdecl sub_1005A1C9(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1021A1F8 = a1;
  return result;
}
// 1021A1F8: using guessed type int dword_1021A1F8;

//----- (1005A1D3) --------------------------------------------------------
int __cdecl sub_1005A1D3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1021A1FC = a1;
  return result;
}
// 1021A1FC: using guessed type int dword_1021A1FC;

//----- (1005A2B2) --------------------------------------------------------
int __cdecl sub_1005A2B2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1021A200 = a1;
  return result;
}
// 1021A200: using guessed type int dword_1021A200;

//----- (1005BA89) --------------------------------------------------------
signed int __cdecl sub_1005BA89(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10110148 - 1;
    v64 = v3;
    v65 = dword_10110148 / 32;
    v9 = dword_10110148 % 32;
    v10 = (int *)(&v60 + dword_10110148 / 32);
    v66 = 31 - dword_10110148 % 32;
    if ( (1 << (31 - dword_10110148 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10110144 - dword_10110148 )
    {
      if ( v3 > dword_10110144 )
      {
        if ( v3 < dword_10110140 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10110154 + v3;
          v50 = dword_1011014C / 32;
          v51 = dword_1011014C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1011014C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1011014C / 32;
          v44 = dword_1011014C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1011014C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10110154 + dword_10110140;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10110144 - v64) / 32;
      v62 = v59;
      v18 = (dword_10110144 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10110148 - 1;
      v25 = dword_10110148 / 32;
      v65 = dword_10110148 / 32;
      v26 = (int *)(&v60 + dword_10110148 / 32);
      v64 = 31 - dword_10110148 % 32;
      if ( (1 << (31 - dword_10110148 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10110148 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1011014C + 1) / 32;
      v37 = (dword_1011014C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1011014C));
  if ( dword_10110150 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10110150 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10110140: using guessed type int dword_10110140;
// 10110144: using guessed type int dword_10110144;
// 10110148: using guessed type int dword_10110148;
// 1011014C: using guessed type int dword_1011014C;
// 10110150: using guessed type int dword_10110150;
// 10110154: using guessed type int dword_10110154;

//----- (1005BFCB) --------------------------------------------------------
signed int __cdecl sub_1005BFCB(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10110160 - 1;
    v64 = v3;
    v65 = dword_10110160 / 32;
    v9 = dword_10110160 % 32;
    v10 = (int *)(&v60 + dword_10110160 / 32);
    v66 = 31 - dword_10110160 % 32;
    if ( (1 << (31 - dword_10110160 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1011015C - dword_10110160 )
    {
      if ( v3 > dword_1011015C )
      {
        if ( v3 < dword_10110158 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1011016C + v3;
          v50 = dword_10110164 / 32;
          v51 = dword_10110164 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_10110164 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_10110164 / 32;
          v44 = dword_10110164 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_10110164 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1011016C + dword_10110158;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1011015C - v64) / 32;
      v62 = v59;
      v18 = (dword_1011015C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10110160 - 1;
      v25 = dword_10110160 / 32;
      v65 = dword_10110160 / 32;
      v26 = (int *)(&v60 + dword_10110160 / 32);
      v64 = 31 - dword_10110160 % 32;
      if ( (1 << (31 - dword_10110160 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10110160 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_10110164 + 1) / 32;
      v37 = (dword_10110164 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_10110164));
  if ( dword_10110168 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10110168 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10110158: using guessed type int dword_10110158;
// 1011015C: using guessed type int dword_1011015C;
// 10110160: using guessed type int dword_10110160;
// 10110164: using guessed type int dword_10110164;
// 10110168: using guessed type int dword_10110168;
// 1011016C: using guessed type int dword_1011016C;

//----- (1005CADC) --------------------------------------------------------
int sub_1005CADC()
{
  return 0;
}

//----- (1005D2C1) --------------------------------------------------------
int __cdecl sub_1005D2C1(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_1010F288;
    }
    else
    {
      v7 = &dword_10224560[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10059671: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (1005D3E1) --------------------------------------------------------
int __cdecl sub_1005D3E1(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_1010F288;
    }
    else
    {
      v2 = &dword_10224560[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_1010F288) : (v4 = &dword_10224560[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10059671: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (1005E320) --------------------------------------------------------
signed int __cdecl sub_1005E320(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_10224560[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_10219878 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 10219878: using guessed type int dword_10219878;
// 10224560: using guessed type int dword_10224560[];

//----- (1005E3A1) --------------------------------------------------------
signed int __cdecl sub_1005E3A1(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_10224560[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 100510B8: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (1005E4B2) --------------------------------------------------------
void __cdecl sub_1005E4B2(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_10224560[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 10224560: using guessed type int dword_10224560[];

//----- (1005E7B3) --------------------------------------------------------
int sub_1005E7B3()
{
  return flsall(1);
}
// 1005E6D9: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1005E7BC) --------------------------------------------------------
int __cdecl sub_1005E7BC(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1021A21C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1021A21C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_1021A220 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1021A224 = _encode_pointer(v7);
    if ( sub_10051185(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1021A22C = _encode_pointer(v8);
      if ( dword_1021A22C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1021A228 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1021A228 == v23
    || dword_1021A22C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1021A228),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1021A22C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_1021A220 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1021A220);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1021A224 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1021A224);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100511BC(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1021A21C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10050FBC: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10051444: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100514B2: using guessed type int _encoded_null(void);
// 100514BB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1021A21C: using guessed type int dword_1021A21C;
// 1021A220: using guessed type int dword_1021A220;
// 1021A224: using guessed type int dword_1021A224;
// 1021A228: using guessed type int dword_1021A228;
// 1021A22C: using guessed type int dword_1021A22C;

//----- (1005F5D1) --------------------------------------------------------
signed int __cdecl sub_1005F5D1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1005E3A1(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_10224560[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_10224560[0] + 68) & 1)
    && (v1 = sub_1005E3A1(2), sub_1005E3A1(1) == v1)
    || (v2 = (void *)sub_1005E3A1(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1005E320(a1);
  *(_BYTE *)(dword_10224560[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004DF2E: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10224560: using guessed type int dword_10224560[];

//----- (1005F7B0) --------------------------------------------------------
int __cdecl sub_1005F7B0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1005FF86: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1005F800) --------------------------------------------------------
int __cdecl sub_1005F800(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1004CDCC: using guessed type int SYS_exit_krnl(void);
// 1004CDD2: using guessed type int SYS_enter_krnl(void);
// 1005FF8C: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1005F870) --------------------------------------------------------
double __cdecl sub_1005F870(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (1005F8A0) --------------------------------------------------------
void __cdecl sub_1005F8A0(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_1001AE10(a1, a2, a4);
  v4 = sqrt(sub_1001AED0(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (1005F900) --------------------------------------------------------
int __cdecl sub_1005F900(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (1005FAC0) --------------------------------------------------------
void __cdecl sub_1005FAC0(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_1004CBD0(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_1004CC70(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_1004CC70(v29 * v37, v24);
    v20 = sub_1004CC70(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_1005F900(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (1005FE90) --------------------------------------------------------
void __cdecl sub_1005FE90(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_1004CC10(a1, (int)&v9);
  sub_1004CC10(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_1004CBD0(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_1005FAC0((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_1005F8A0(&v9, &v7, a3, (int)&v11);
    *a4 = sub_1004CCE0(v11, v12);
  }
}

#error "There were 51 decompilation failure(s) on 1616 function(s)"
